<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankStmtISOAccountStatement</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class BankStmtISOAccountStatement extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcNetAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the net amount.
    /// </summary>
    /// <returns>
    /// The net amount.
    /// </returns>
    public BankStatementNetAmount calcNetAmount()
    {
        BankStatementNetAmount amount;
        BankStmtISOReportEntry reportEntry;

        select sum(Amount) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Debit
                && reportEntry.BankStatementLineStatus == BankStatementLineStatus::Booked;
        amount += reportEntry.Amount;

        select sum(Amount) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Credit
                && reportEntry.BankStatementLineStatus == BankStatementLineStatus::Booked;
        amount -= reportEntry.Amount;

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMatchedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the matched but unreconciled amount.
    /// </summary>
    /// <returns>The matched amount.</returns>
    internal AmountCur calcMatchedAmount()
    {
        AmountCur amount;
        BankStmtISOReportEntry reportEntry;
        BankReconciliationMatching matchingRelation;
        BankReconciliationMatchingItem matchingItem;

        select sum(Amount) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Debit
                && reportEntry.BankStatementLineStatus == BankStatementLineStatus::Booked
                && reportEntry.Reconciled == NoYes::No
            join matchingItem
                where matchingItem.BankStmtISOReportEntry == reportEntry.RecId
            join matchingRelation
                where matchingItem.BankReconciliationMatching == matchingRelation.RecId;
        amount += reportEntry.Amount;

        select sum(Amount) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Credit
                && reportEntry.BankStatementLineStatus == BankStatementLineStatus::Booked
                && reportEntry.Reconciled == NoYes::No
            join matchingItem
                where matchingItem.BankStmtISOReportEntry == reportEntry.RecId
            join matchingRelation
                where matchingItem.BankReconciliationMatching == matchingRelation.RecId;
        amount -= reportEntry.Amount;

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReconciledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reconciled amount.
    /// </summary>
    /// <returns>The reconciled amount.</returns>
    internal AmountCur calcReconciledAmount()
    {
        return this.getReconciledAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUnmatchedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the unmatched amount.
    /// </summary>
    /// <returns>The matched amount.</returns>
    internal AmountCur calcUnmatchedAmount()
    {
        AmountCur amount;
        BankStmtISOReportEntry reportEntry;
        BankReconciliationMatchingItem matchingItem;

        select sum(Amount) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Debit
                && reportEntry.BankStatementLineStatus == BankStatementLineStatus::Booked
            notexists join matchingItem
                where matchingItem.BankStmtISOReportEntry == reportEntry.RecId;
        amount += reportEntry.Amount;

        select sum(Amount) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Credit
                && reportEntry.BankStatementLineStatus == BankStatementLineStatus::Booked
            notexists join matchingItem
                where matchingItem.BankStmtISOReportEntry == reportEntry.RecId;
        amount -= reportEntry.Amount;

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotalLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total line number.
    /// </summary>
    /// <returns>
    /// The total line number.
    /// </returns>
    public NumberOfRecords calcTotalLines()
    {
        BankStmtISOReportEntry reportEntry;

        select count(RecId) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId;

        return reportEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMatchedLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the matched but unreconciled line number.
    /// </summary>
    /// <returns>The matched line number.</returns>
    internal NumberOfRecords calcMatchedLines()
    {
        BankStmtISOReportEntry reportEntry;
        BankReconciliationMatching matchingRelation;
        BankReconciliationMatchingItem matchingItem;

        select count(RecId) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
                && reportEntry.Reconciled == NoYes::No
            exists join matchingItem
                where matchingItem.BankStmtISOReportEntry == reportEntry.RecId
            join matchingRelation
                where matchingItem.BankReconciliationMatching == matchingRelation.RecId;

        return reportEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReconciledLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reconciled line number.
    /// </summary>
    /// <returns>The reconciled line number.</returns>
    internal NumberOfRecords calcReconciledLines()
    {
        BankStmtISOReportEntry reportEntry;
        BankReconciliationMatching matchingRelation;
        BankReconciliationMatchingItem matchingItem;

        select count(RecId) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
                && reportEntry.Reconciled == NoYes::Yes;

        return reportEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUnmatchedLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the unmatched line number.
    /// </summary>
    /// <returns>The unmatched line number.</returns>
    internal NumberOfRecords calcUnmatchedLines()
    {
        BankStmtISOReportEntry reportEntry;
        BankReconciliationMatchingItem matchingItem;

        select count(RecId) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
            notexists join matchingItem
                where matchingItem.BankStmtISOReportEntry == reportEntry.RecId;

        return reportEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the record of the bank account statement.
    /// </summary>
    public void delete()
    {
        ttsbegin;

        this.deleteStatement();

        super();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispEmployeeName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the name of employee who validates this bank statement.
    /// </summary>
    /// <returns>
    ///     Name of employee.
    /// </returns>
    public display BankStatementValidatedByWorkerName dispEmployeeName()
    {
        return HcmWorker::find(HcmWorker::userId2Worker(this.ValidatedBy)).name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispEndingBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the ending balance for current bank statement.
    /// </summary>
    /// <returns>
    ///     The ending balance.
    /// </returns>
    public display BankStatementEndingBalance dispEndingBalance()
    {
        return this.getEndingBalance();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispMaxBookingDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the max booking datetime for current bank statement.
    /// </summary>
    /// <returns>
    ///     The max booking datetime.
    /// </returns>
    public display BankStatementBookingDate dispMaxBookingDateTime()
    {
        return this.getMaxBookingDateTime();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispMinBookingDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the min booking datetime for current bank statement.
    /// </summary>
    /// <returns>
    ///     The min booking datetime.
    /// </returns>
    public display BankStatementBookingDate dispMinBookingDateTime()
    {
        return this.getMinBookingDateTime();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispNetAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the net amount for current bank statement.
    /// </summary>
    /// <returns>
    ///     The net amount.
    /// </returns>
    public display BankStatementNetAmount dispNetAmount()
    {
        return this.getNetAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispOpeningBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the opening balance for current bank statement.
    /// </summary>
    /// <returns>
    ///     The opening balance.
    /// </returns>
    public display BankStatementOpeningBalance dispOpeningBalance()
    {
        return this.getOpeningBalance();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispReconciledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the reconciled amount for current bank statement.
    /// </summary>
    /// <returns>
    ///     The reconciled amount.
    /// </returns>
    public display BankStatementReconciledAmount dispReconciledAmount()
    {
        return this.getReconciledAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispTotalCreditLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the total credit lines of current bank statement.
    /// </summary>
    /// <returns>
    ///     Total credit lines.
    /// </returns>
    public display BankStatementTotalCreditLines dispTotalCreditLines()
    {
        return this.getTotalCreditLines();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispTotalDebitLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the total debit lines of current bank statement.
    /// </summary>
    /// <returns>
    ///     Total debit lines.
    /// </returns>
    public display BankStatementTotalDebitLines dispTotalDebitLines()
    {
        return this.getTotalDebitLines();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispUnreconciledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the reconciled amount for current bank statement.
    /// </summary>
    /// <returns>
    ///     The reconciled amount.
    /// </returns>
    public display BankStatementReconciledAmount dispUnreconciledAmount()
    {
        return this.getUnreconciledAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the acccounting date.
    /// </summary>
    /// <returns>
    /// The accounting date.
    /// </returns>
    public TransDate getAccountingDate()
    {
        return this.AccountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBalanceByType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the balance amount for current bank statement according to balance type.
    /// </summary>
    /// <param name="_type">
    ///     Given balance type.
    /// </param>
    /// <returns>
    ///     The balance amount.
    /// </returns>
    private AmountCur getBalanceByType(BankStatementBalanceType _type)
    {
        BankStmtISOCashBalance balance;
        AmountCur amount;

        balance = BankStmtISOCashBalance::findByStatementAndBalanceType(this.RecId, _type);

        if (balance.RecId != 0)
        {
            amount = BankStmtISOAccountStatement::getShowingAmount(
                balance.CashBalanceAmount,
                balance.AmountCreditDebitIndicator,
                false);
        }

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankAccountTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank account table of the statement.
    /// </summary>
    /// <returns>
    /// The bank account table.
    /// </returns>
    public BankAccountTable getBankAccountTable()
    {
        return BankAccountTable::find(this.BankAccountTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the currency code.
    /// </summary>
    /// <returns>
    /// The currency code.
    /// </returns>
    public CurrencyCode getCurrencyCode()
    {
        CurrencyCode currency = Currency::findCurrencyCodeISO(this.AccountCurrency).CurrencyCode;

        if (!currency)
        {
            currency = BankAccountTable::find(this.BankAccountTable).CurrencyCode;
        }

        return currency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyISO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the currency ISO code.
    /// </summary>
    /// <returns>
    /// The currency ISO code.
    /// </returns>
    public CurrencyCodeISO getCurrencyISO()
    {
        CurrencyCodeISO currency = this.AccountCurrency;

        if (!currency)
        {
            currency = Currency::find(this.getBankAccountTable().CurrencyCode).CurrencyCodeISO;
        }

        return currency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEndingBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the ending balance for current bank statement.
    /// </summary>
    /// <returns>
    ///     The ending balance.
    /// </returns>
    public BankStatementEndingBalance getEndingBalance()
    {
        return this.getBalanceByType(BankStatementBalanceType::Closing);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineCountByIndicator</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the line counts of current bank statement.
    /// </summary>
    /// <param name="_drCr">
    ///     Indicates which direction will be calculated.
    /// </param>
    /// <returns>
    ///     Line counts.
    /// </returns>
    private NumberOfRecords getLineCountByIndicator(BankStatementAmountDrCrIndicator _drCr)
    {
        BankStmtISOReportEntry reportEntry;

        select count(RecId) from reportEntry
            where reportEntry.AmountCreditDebitIndicator == _drCr
                && reportEntry.BankStmtISOAccountStatement == this.RecId;

        return reportEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatementEmpty</Name>
				<Source><![CDATA[
    private boolean isStatementEmpty()
    {
        BankStmtISOReportEntry reportEntry;

        select count(RecId) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId;

        return reportEntry.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxBookingDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the max booking datetime for current bank statement.
    /// </summary>
    /// <returns>
    ///     The max booking datetime.
    /// </returns>
    public BankStatementBookingDate getMaxBookingDateTime()
    {
        BankStmtISOReportEntry reportEntry;

        select firstonly BookingDateTime from reportEntry
            order by BookingDateTime desc
            where reportEntry.BankStmtISOAccountStatement == this.RecId;

        return reportEntry.BookingDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMinBookingDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the min booking datetime for current bank statement.
    /// </summary>
    /// <returns>
    ///     The min booking datetime.
    /// </returns>
    public BankStatementBookingDate getMinBookingDateTime()
    {
        BankStmtISOReportEntry reportEntry;

        select firstonly BookingDateTime from reportEntry
            order by BookingDateTime
            where reportEntry.BankStmtISOAccountStatement == this.RecId;

        return reportEntry.BookingDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNetAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the net amount for current bank statement.
    /// </summary>
    /// <returns>
    ///     The net amount.
    /// </returns>
    public BankStatementNetAmount getNetAmount()
    {
        return this.getBalanceByType(BankStatementBalanceType::NetAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpeningBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the opening balance for current bank statement.
    /// </summary>
    /// <returns>
    ///     The opening balance.
    /// </returns>
    public BankStatementOpeningBalance getOpeningBalance()
    {
        return this.getBalanceByType(BankStatementBalanceType::Opening);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReconciledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the reconciled amount for current bank statement.
    /// </summary>
    /// <returns>
    ///     The reconciled amount.
    /// </returns>
    public BankStatementReconciledAmount getReconciledAmount()
    {
        BankStmtISOReportEntry reportEntry;
        AmountCur amount;

        select sum(Amount) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Debit
                && reportEntry.Reconciled == NoYes::Yes
                && reportEntry.BankStatementLineStatus == BankStatementLineStatus::Booked;
        amount += reportEntry.Amount;

        select sum(Amount) from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Credit
                && reportEntry.Reconciled == NoYes::Yes
                && reportEntry.BankStatementLineStatus == BankStatementLineStatus::Booked;
        amount -= reportEntry.Amount;

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalCreditLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the total credit lines of current bank statement.
    /// </summary>
    /// <returns>
    ///     Total credit lines.
    /// </returns>
    public BankStatementTotalCreditLines getTotalCreditLines()
    {
        return this.getLineCountByIndicator(DebitCredit::Credit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalDebitLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the total debit lines of current bank statement.
    /// </summary>
    /// <returns>
    ///     Total debit lines.
    /// </returns>
    public BankStatementTotalDebitLines getTotalDebitLines()
    {
        return this.getLineCountByIndicator(DebitCredit::Debit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnreconciledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the reconciled amount for current bank statement.
    /// </summary>
    /// <returns>
    ///     The reconciled amount.
    /// </returns>
    public BankStatementReconciledAmount getUnreconciledAmount()
    {
        return this.getNetAmount() - this.getReconciledAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMatchedLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether current bank statement has matched line.
    /// </summary>
    /// <returns>
    ///     Returns true if matched line exists. Otherwise, return false.
    /// </returns>
    internal boolean hasMatchedLine()
    {
        BankStmtISOReportEntry reportEntry;
        BankReconciliationMatching matching;
        BankReconciliationMatchingItem matchingItem;
        boolean ret;

        select firstOnly RecId from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId
        exists join matchingItem
            where matchingItem.BankStmtISOReportEntry == reportEntry.RecId
        exists join matching
            where matchingItem.BankReconciliationMatching == matching.RecId
                && matching.Cancelled == NoYes::No;

        if (reportEntry.RecId)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUnreconciledLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether current bank statement has unreconciled line.
    /// </summary>
    /// <returns>
    ///     Returns true if unreconciled line exists. Otherwise, return false.
    /// </returns>
    private boolean hasUnreconciledLine()
    {
        BankStmtISOReportEntry reportEntry;
        boolean ret;

        select firstOnly RecId from reportEntry
            where reportEntry.Reconciled == NoYes::No
                && reportEntry.BankStmtISOAccountStatement == this.RecId;

        if (reportEntry.RecId)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();

        this.AccountingDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts record to the bank stmt ISO account statement.
    /// </summary>
    public void insert()
    {
        ttsBegin;

        if (!this.DefaultDimension)
        {
            this.DefaultDimension = BankAccountTable::find(this.BankAccountTable).DefaultDimension;
        }

        //insert source document header
        SourceDocumentProcessorFacade::submitSourceDocumentImplementation(this);

        super();

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllowedMarkNewBankDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the bank statement is allowed to mark new bank document.
    /// </summary>
    /// <returns>
    ///     true if the bank statement is allowed to mark new bank document; otherwise, false.
    /// </returns>
    public boolean isAllowedMarkNewBankDocument()
    {
        return !this.Posted && (this.Status == BankStatementStatus::Validated || this.Status == BankStatementStatus::Open);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllowedUpdateStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the statement is allowed to be updated to the target status.
    /// </summary>
    /// <param name="_targetStatus">
    /// The target status.
    /// </param>
    /// <returns>
    /// True is the statement is allowed be updated to target status; otherwise, false.
    /// </returns>
    public boolean isAllowedUpdateStatus(BankStatementStatus _targetStatus)
    {
        boolean isValidUpdate;

        switch (this.Status)
        {
            case BankStatementStatus::Open:
                if (_targetStatus == BankStatementStatus::Validated)
                {
                    isValidUpdate = true;
                }
                break;

            case BankStatementStatus::Validated:
                if (_targetStatus == BankStatementStatus::Open)
                {
                    if (!this.Posted)
                    {
                        isValidUpdate = true;
                    }
                }
                else if (_targetStatus == BankStatementStatus::Matched)
                {
                    isValidUpdate = true;
                }
                else if (_targetStatus == BankStatementStatus::Reconciled && this.isStatementEmpty())
                {
                    isValidUpdate = true;
                }
                break;

            case BankStatementStatus::Matched:
                if (_targetStatus == BankStatementStatus::Validated
                    || _targetStatus == BankStatementStatus::Reconciled)
                {
                    isValidUpdate = true;
                }
                break;

            case BankStatementStatus::Reconciled:
                if (_targetStatus == BankStatementStatus::Validated
                    || _targetStatus == BankStatementStatus::Matched)
                {
                    isValidUpdate = true;
                }
                break;
        }

        return isValidUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEditable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the bank statement is editable.
    /// </summary>
    /// <returns>
    ///     Returns true if the bank statement is open or validated. Otherwise, returns false.
    /// </returns>
    public boolean isEditable()
    {
        return !this.isPassedValidation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isManual</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the bank statement is manually input.
    /// </summary>
    /// <returns>
    ///     Returns true if the bank statement is manually input. Otherwise, returns false.
    /// </returns>
    public boolean isManual()
    {
        return this.Manual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatementLineEditable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the bank statement lines are editable.
    /// </summary>
    /// <returns>true if the bank statement lines are editable; otherwise, false.</returns>
    internal boolean isStatementLineEditable()
    {
        return this.isEditable() && this.isManual();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPassedValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the statement is passed validation.
    /// </summary>
    /// <returns>
    /// True if the statement is passed validation; otherwise, false.
    /// </returns>
    public boolean isPassedValidation()
    {
        return (this.Status == BankStatementStatus::Validated
                || this.Status == BankStatementStatus::Matched
                || this.Status == BankStatementStatus::Reconciled);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPostable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the bank statement is postable.
    /// </summary>
    /// <returns>
    ///     Returns true if the bank statement is able to post. Otherwise, returns false.
    /// </returns>
    public boolean isPostable()
    {
        return this.isPassedValidation()
                && !this.Posted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatementHeaderPosted</Name>
				<Source><![CDATA[
    internal boolean isStatementHeaderPosted()
    {
        return this.Posted && this.Voucher != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatementCanPostLineTable</Name>
				<Source><![CDATA[
    internal boolean isStatementCanPostLineTable()
    {
        return this.isPassedValidation() && !this.isStatementHeaderPosted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatementReversible</Name>
				<Source><![CDATA[
    public boolean isStatementReversible()
    {
        return this.Posted && (!BankStmtISOReportEntry::existsNewForStatement(this.RecId)
            || FeatureStateProvider::isFeatureEnabled(BankStatementReversePostWithNewTransactionFeature::instance()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocHeaderTypeEnumName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source doc header type enum name information.
    /// </summary>
    /// <returns>
    /// The enum name of the source doc header type.
    /// </returns>
    public enumName parmSourceDocHeaderTypeEnumName()
    {
        return enumStr(SourceDocument_BankStatement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocHeaderTypeEnumValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source doc header type enum value information.
    /// </summary>
    /// <returns>
    /// The enum value of he source doc header type.
    /// </returns>
    public SourceDocumentTypeEnumValue parmSourceDocHeaderTypeEnumValue()
    {
        return SourceDocument_BankStatement::BankStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>previewPaneTitle</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives the title on top of the preview pane.
    /// </summary>
    /// <returns>
    ///     Title field of the preview pane.
    /// </returns>
    public display Caption previewPaneTitle()
    {
        return strFmt("@SYS26868", this.Identification, this.BankAccountTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshMatchingStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Refreshes the matching status.
    /// </summary>
    public void refreshMatchingStatus()
    {
        ttsBegin;
        this.updateStatus(this.getTargetStatusForUpdate(), true);
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTargetStatusForUpdate</Name>
				<Source><![CDATA[
    internal BankStatementStatus getTargetStatusForUpdate()
    {
        boolean hasMatchedLine = this.hasMatchedLine();
        boolean hasUnreconciledLine = this.hasUnreconciledLine();
        boolean isStatementEmpty = this.isStatementEmpty();
        BankStatementStatus targetStatus;

        //The statement must have passed validation before it is involved in matching.
        if (this.Status == BankStatementStatus::Open)
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        // Matched if there is a line is matched but not all lines are reconciled.
        if (hasMatchedLine && hasUnreconciledLine)
        {
            targetStatus = BankStatementStatus::Matched;
        }
        else if (!hasMatchedLine && !isStatementEmpty)
        {
            // Validated if there is no line is matched.
            targetStatus = BankStatementStatus::Validated;
        }
        else if (!hasUnreconciledLine)
        {
            // Reconciled if there is no line is unreconciled.
            targetStatus = BankStatementStatus::Reconciled;
        }

        return targetStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates bank statement status.
    /// </summary>
    /// <param name="_targetStatus">
    /// The target status.
    /// </param>
    /// <param name="_doUpdate">
    /// A boolean value indicating whether to commit the update.
    /// </param>
    public void updateStatus(BankStatementStatus _targetStatus, boolean _doUpdate = false)
    {
        if (this.validateUpdateStatus(_targetStatus))
        {
            this.Status = _targetStatus;

            if (_doUpdate)
            {
                ttsBegin;
                this.selectForUpdate(true);
                this.update();
                ttsCommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Peforms validation.
    /// </summary>
    public void validate()
    {
        if (FeatureStateProvider::isFeatureEnabled(BankModernReconciliationFeature::instance()))
        {
            // Confirming
            setPrefix("@Bank:Confirming");
            // Bank statement: %1
            setPrefix(strFmt("@GLS221345", this.Identification));
            BankStatementValidate::processValidate(this.RecId);
        }
        else
        {
            // Validating
            setPrefix("@GLS221344");
            // Bank statement: %1
            setPrefix(strFmt("@GLS221345", this.Identification));
            BankStatementValidate::processValidate(this.RecId);
        }
        this.reread();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOnly</Name>
				<Source><![CDATA[
    /// <summary>
    /// Peforms validation.
    /// </summary>
    internal void validateOnly()
    {
        setPrefix("@GLS221344");
        setPrefix(strFmt("@GLS221345", this.Identification));

        BankStatementValidate::processValidateOnly(this.RecId);
        this.reread();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean ret = true;

        ret = super();

        if (ret)
        {
            if (!this.isEditable())
            {
                // Only open bank statement can be deleted.
                ret = checkFailed("@Bank:BankStmtDeleteValidationWarning");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the field value of the bank stmt ISO account statement.
    /// </summary>
    /// <param name="_fieldName">
    /// The field name.
    /// </param>
    /// <param name="_arrayIndex">
    /// The array index.
    /// </param>
    /// <returns>
    /// Returns true if the validation succeed.
    /// </returns>
    public boolean validateFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        boolean ret;

        ret = super(_fieldName, _arrayIndex);

        if (ret)
        {
            switch (_fieldName)
            {
                case fieldStr(BankStmtISOAccountStatement, BankAccountTable)    :
                    ret = BankAccountTable::checkIsAdvancedBankReconEnabled(this.BankAccountTable);
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateUpdateStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the bank statement can be updated to the target status.
    /// </summary>
    /// <param name="_targetStatus">
    /// The target status.
    /// </param>
    /// <returns>
    /// True if the bank statement can be updated to the target status; otherwise, false.
    /// </returns>
    internal boolean validateUpdateStatus(BankStatementStatus _targetStatus)
    {
        boolean isValidUpdate;

        isValidUpdate = this.isAllowedUpdateStatus(_targetStatus);

        //performs checking on related data of the statement
        if (isValidUpdate)
        {
            switch (_targetStatus)
            {
                case BankStatementStatus::Open:
                    if (BankStmtISOReportEntry::existsNewForStatement(this.RecId))
                    {
                        //The bank statement has line marked as new bank document.
                        isValidUpdate = checkFailed("@SYS4081981");
                    }

                    isValidUpdate = isValidUpdate && this.validateFollowingStatementOpen();

                    break;

                default:
                    isValidUpdate = true;
                    break;
            }
        }

        return isValidUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            ret = BankAccountTable::checkIsAdvancedBankReconEnabled(this.BankAccountTable);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    static boolean checkExist(BankStatementId _statementId)
    {
        if (_statementId && !BankStmtISOAccountStatement::exist(_statementId))
        {
            return checkFailed(strFmt(BankStmtISOAccountStatement::txtNotExist(), _statementId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteStatement</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deletes the statement line and all of its related records.
    /// </summary>
    protected void deleteStatement()
    {
        BankStmtISOAccountStatement otherAccountStatement;
        BankStmtISOCashBalance cashBalance;
        BankStmtISOReportEntry reportEntry;
        BankStmtISOPartyIdentification partyIdentification;
        BankStmtISODocument document;
        BankStmtISOGroupHeader groupHeader;
        BankStmtISOGroupHeader groupHeaderDeleted;

        ttsbegin;

        delete_from partyIdentification
            where this.UltimateReceiverId == partyIdentification.RecId;

        delete_from partyIdentification
            where this.OriginatorId == partyIdentification.RecId;

        delete_from reportEntry
            where reportEntry.BankStmtISOAccountStatement == this.RecId;

        delete_from cashBalance
            where cashBalance.BankStmtISOAccountStatement == this.RecId;

        //delete document if this is the only statement
        select firstonly RecId from otherAccountStatement
            where otherAccountStatement.RecId != this.RecId
                && otherAccountStatement.BankStmtISODocument == this.BankStmtISODocument;
        if (otherAccountStatement.RecId == 0)
        {
            select RecId, MessageSender, MessageRecipient, MessageIdentification from groupHeader
                exists join document
                    where groupHeader.RecId == document.GroupHeader
                        && document.RecId == this.BankStmtISODocument;

            delete_from partyIdentification
                where partyIdentification.RecId == groupHeader.MessageSender;

            delete_from partyIdentification
                where partyIdentification.RecId == groupHeader.MessageRecipient;

            if (this.isManual() && this.isEditable())
            {
                NumberSeq::releaseNumber(BankParameters::numRefBankStatementDownloadId().NumberSequenceId, groupHeader.MessageIdentification);
            }

            delete_from groupHeaderDeleted
                where groupHeaderDeleted.RecId == groupHeader.RecId;

            delete_from document
                where document.RecId == this.BankStmtISODocument;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the bank statement exist.
    /// </summary>
    /// <param name="_statementId">
    /// The statement id.
    /// </param>
    /// <returns>
    /// Returns true if the bank statement exist.
    /// </returns>
    static boolean exist(BankStatementId _statementId)
    {
        return _statementId
            && (select firstonly RecId from bankStmtISOAccountStatement
                where bankStmtISOAccountStatement.Identification == _statementId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds <c>BankStmtISOAccountStatement</c> record according to RecId.
    /// </summary>
    /// <param name="_recId">
    ///     Record Id
    /// </param>
    /// <param name="_forUpdate">
    ///     Indicates whether selected record can be updated.
    /// </param>
    /// <param name="_concurrencyModel">
    ///     Currency model
    /// </param>
    /// <returns>
    ///     Record of <c>BankStmtISOAccountStatement</c>.
    /// </returns>
    public static BankStmtISOAccountStatement find(
        RecId _recId,
        boolean _forUpdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankStmtISOAccountStatement statement;

        statement.selectForUpdate(_forUpdate);

        if (_forUpdate
            && _concurrencyModel != ConcurrencyModel::Auto)
        {
            statement.concurrencyModel(_concurrencyModel);
        }

        select firstonly statement
            where statement.RecId == _recId;

        return statement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByStatementId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds <c>BankStmtISOAccountStatement</c> record according to bank statement Id.
    /// </summary>
    /// <param name="_statementId">
    ///     Bank statement id.
    /// </param>
    /// <param name="_forUpdate">
    ///     Indicates whether selected record can be updated.
    /// </param>
    /// <param name="_concurrencyModel">
    ///     Currency model
    /// </param>
    /// <returns>
    ///     Record of <c>BankStmtISOAccountStatement</c>.
    /// </returns>
    [SysObsolete('This method is obsolete.  Use BankStmtISOAccountStatement::findByBankAccountAndStatementId instead.', true, 30\6\2020)]
    public static BankStmtISOAccountStatement findByStatementId(
        BankStatementId     _statementId,
        boolean             _forUpdate = false,
        ConcurrencyModel    _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankStmtISOAccountStatement statement;

        statement.selectForUpdate(_forUpdate);

        if (_forUpdate
            && _concurrencyModel != ConcurrencyModel::Auto)
        {
            statement.concurrencyModel(_concurrencyModel);
        }

        select firstonly statement
            where statement.Identification == _statementId;

        return statement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByBankAccountAndStatementId</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Finds the <c>BankStmtISOAccountStatement</c> record for the given bank account and bank statement Id.
    /// </summary>
    /// <param name="_bankAccountId">
    ///     The bank account id.
    /// </param>
    /// <param name="_statementId">
    ///     The bank statement id.
    /// </param>
    /// <param name="_forUpdate">
    ///     Indicates whether selected record can be updated.
    /// </param>
    /// <param name="_concurrencyModel">
    ///     The concurrency model.
    /// </param>
    /// <returns>
    ///     A record of <c>BankStmtISOAccountStatement</c>.
    /// </returns>
    public static BankStmtISOAccountStatement findByBankAccountAndStatementId(
        CompanyBankAccountId _bankAccountId,
        BankStatementId _statementId,
        boolean _forUpdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankStmtISOAccountStatement statement;

        statement.selectForUpdate(_forUpdate);

        if (_forUpdate
            && _concurrencyModel != ConcurrencyModel::Auto)
        {
            statement.concurrencyModel(_concurrencyModel);
        }

        select firstonly statement
            where statement.Identification == _statementId
                && statement.BankAccountTable == _bankAccountId;

        return statement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getShowingAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the showing amount according to debit/credit indicator from table.
    /// </summary>
    /// <param name="_amount">
    ///     Original amount which is stored in table.
    /// </param>
    /// <param name="_indicator">
    ///     Debit/Credit indicator which is stored in table.
    /// </param>
    /// <param name="_isBioColumn">
    ///     Indicates whether the amount is shown in debit or credit column.
    /// </param>
    /// <param name="_columnDrCr">
    ///     Indicates which column the amount is shown.
    /// </param>
    /// <returns>
    ///     The showing amount.
    /// </returns>
    public static BankStmtISODecimal getShowingAmount(
        BankStmtISODecimal _amount,
        BankStatementAmountDrCrIndicator _indicator,
        boolean _isBioColumn,
        DebitCredit _columnDrCr = DebitCredit::Debit)
    {
        BankStmtISODecimal amount = _amount;

        if (_isBioColumn)
        {
            if (_indicator != _columnDrCr)
            {
                amount = 0;
            }
        }
        else
        {
            if (_indicator == DebitCredit::Credit)
            {
                amount = -1 * amount;
            }
        }

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIndicatorAndAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the amount indicator and amount to table.
    /// </summary>
    /// <param name="_amount">
    ///     Input amount.
    /// </param>
    /// <param name="_isBioColumn">
    ///     Indicates whether the amount is input from debit or credit column.
    /// </param>
    /// <param name="_columnDrCr">
    ///     Indicates which column the amount is input from.
    /// </param>
    /// <returns>
    ///     The showing amount.
    /// </returns>
    public static container setIndicatorAndAmount(
        BankStmtISODecimal _amount,
        boolean _isBioColumn,
        DebitCredit _columnDrCr = DebitCredit::Debit)
    {
        container ret;

        if (_isBioColumn)
        {
            ret += _columnDrCr;
            ret += _amount;
        }
        else
        {
            if (_amount >= 0)
            {
                ret += DebitCredit::Debit;
                ret += _amount;
            }
            else
            {
                ret += DebitCredit::Credit;
                ret += -1 * _amount;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    static TxtNotExist txtNotExist()
    {
        // Bank reconciliation statement %1 does not exist.
        return "@GLS221346";
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBalances</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Create missing cash balance records
    /// </summary>
    public void initBalances()
    {
        BankStmtISOCashBalance importedStatementBalance;
        boolean hasOpening;
        boolean hasClosing;
        boolean hasNetAmount;

        //add missing balances
        while select BankStatementBalanceType from importedStatementBalance
            where importedStatementBalance.BankStmtISOAccountStatement == this.RecId
        {
            if (importedStatementBalance.BankStatementBalanceType == BankStatementBalanceType::Opening)
            {
                hasOpening = true;
            }
            if (importedStatementBalance.BankStatementBalanceType == BankStatementBalanceType::Closing)
            {
                hasClosing = true;
            }
            if (importedStatementBalance.BankStatementBalanceType == BankStatementBalanceType::NetAmount)
            {
                hasNetAmount = true;
            }
        }

        if (!hasOpening)
        {
            importedStatementBalance.clear();
            importedStatementBalance.BankStatementBalanceType = BankStatementBalanceType::Opening;
            importedStatementBalance.BankStmtISOAccountStatement = this.RecId;
            importedStatementBalance.insert();
        }

        if (!hasClosing)
        {
            importedStatementBalance.clear();
            importedStatementBalance.BankStatementBalanceType = BankStatementBalanceType::Closing;
            importedStatementBalance.BankStmtISOAccountStatement = this.RecId;
            importedStatementBalance.insert();
        }

        if (!hasNetAmount)
        {
            importedStatementBalance.clear();
            importedStatementBalance.BankStatementBalanceType = BankStatementBalanceType::NetAmount;
            importedStatementBalance.BankStmtISOAccountStatement = this.RecId;
            importedStatementBalance.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFollowingStatementOpen</Name>
				<Source><![CDATA[
    private boolean validateFollowingStatementOpen()
    {
        boolean ret = true;

        BankStmtISOAccountStatement statementLocal;

        select firstonly Identification, Status from statementLocal
            order by ToDateTime
            where statementLocal.BankAccountTable == this.BankAccountTable
                && statementLocal.BankStatementType == BankStatementType::Reconciliation
                && statementLocal.ToDateTime > this.ToDateTime;

        if (statementLocal.RecId != 0 && statementLocal.Status != BankStatementStatus::Open)
        {
            ret = checkFailed(strFmt("@CashManagement:BankStatementFollowingValidatedNotAllowReopen", this.Identification, statementLocal.Identification, BankStatementStatus::Open));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>notExistPartialPostedStatement</Name>
				<Source><![CDATA[
    public static boolean notExistPartialPostedStatement()
    {
        BankStmtISOAccountStatement statementHeader;
        BankStmtISOReportEntry statementLine;

        select count(RecId) from statementHeader
            where !statementHeader.Posted
            exists join statementLine
            where statementLine.BankStmtISOAccountStatement == statementHeader.RecId
                && statementLine.IsNewBankDocument
                && statementLine.Voucher != '';

        return statementHeader.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankStatementStatus</Name>
				<Source><![CDATA[
    internal static void updateBankStatementStatus(RefRecId _accountStatementRecId)
    {
        BankStmtISOAccountStatement statement = BankStmtISOAccountStatement::find(_accountStatementRecId);
        BankStatementStatus targetStatus = statement.getTargetStatusForUpdate();

        if (statement.Status != targetStatus)
        {
            statement.updateStatus(targetStatus, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existUnmatchedBankStmtISOReportEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds if unmatched bank statement line exists.
    /// </summary>
    /// <returns>ture if unmatched statement line exists; otherwise, false</returns>
    internal boolean existUnmatchedBankStmtISOReportEntry()
    {
        BankStmtISOReportEntry statementLineUnmatched;
        BankReconciliationMatchingItem matchingItem;

        select firstonly RecId from statementLineUnmatched
            where statementLineUnmatched.BankStmtISOAccountStatement == this.RecId
                && statementLineUnmatched.Reconciled == NoYes::No
            notexists join matchingItem
                where matchingItem.BankStmtISOReportEntry == statementLineUnmatched.RecId;

        return statementLineUnmatched.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existReconciledBankStmtISOReportEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds if reconciled bank statement line exists.
    /// </summary>
    /// <returns>ture if reconciled statement line exists; otherwise, false</returns>
    internal boolean existReconciledBankStmtISOReportEntry()
    {
        BankStmtISOReportEntry statementLineReconciled;
        BankReconciliationMatchingItem matchingItem;

        select firstonly RecId from statementLineReconciled
            where statementLineReconciled.BankStmtISOAccountStatement == this.RecId
                && statementLineReconciled.Reconciled == NoYes::Yes;

        return statementLineReconciled.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existPostedLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds if posted line exists in statement.
    /// </summary>
    /// <returns>ture if posted line exists in statement; otherwise, false</returns>
    internal boolean existPostedLine()
    {
        BankStmtISOReportEntry postedLine;

        select firstonly RecId from postedLine
            where postedLine.BankStmtISOAccountStatement == this.RecId
                && postedLine.Voucher != '';

        return postedLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getToDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the to date.
    /// </summary>
    /// <returns>The to date.</returns>
    internal date getToDate()
    {
        date toDate;

        if (FeatureStateProvider::isFeatureEnabled(BankUserPreferredTimeZoneAlignmentFeature::instance()))
        {
            toDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(this.ToDateTime, DateTimeUtil::getUserPreferredTimeZone()));
        }
        else
        {
            toDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(this.ToDateTime, DateTimeUtil::getCompanyTimeZone()));
        }

        return toDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextStatementDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets next statement ending date after or equal to the specific date.
    /// </summary>
    /// <param name = "_date">The specific date.</param>
    /// <param name = "_accountId">The bank account id.</param>
    /// <returns>The next statement ending date after or equal to the specific date.</returns>
    internal static TransDate getNextStatementDate(TransDate _date, CompanyBankAccountId _accountId)
    {
        TransDateTime minDateTime;

        if (FeatureStateProvider::isFeatureEnabled(BankUserPreferredTimeZoneAlignmentFeature::instance()))
        {
            minDateTime = DateTimeUtil::newDateTime(_date, DateTimeUtil::time(DateTimeUtil::minValue()), DateTimeUtil::getUserPreferredTimeZone());
        }
        else
        {
            minDateTime = DateTimeUtil::newDateTime(_date, DateTimeUtil::time(DateTimeUtil::minValue()), DateTimeUtil::getCompanyTimeZone());
        }

        BankStmtISOAccountStatement statement;

        select firstonly RecId, ToDateTime from statement
            order by ToDateTime
            where statement.BankAccountTable == _accountId
                && statement.Status != BankStatementStatus::Open
                && statement.ToDateTime >= minDateTime;

        if (!statement.RecId)
        {
            return dateNull();
        }
        else
        {
            return statement.getToDate();
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>BankElectronicBanking</ConfigurationKey>
	<DeveloperDocumentation>@SYS316331</DeveloperDocumentation>
	<Label>@SYS316320</Label>
	<SingularLabel>@CashManagement:BankStatement</SingularLabel>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>AccountIdOtherId</TitleField1>
	<TitleField2>OriginatorId</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>Found</CacheLookup>
	<Modules>Bank</Modules>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>SourceDocumentHeader</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>SourceDocumentHeader</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountIdOtherId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OriginatorId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UltimateReceiverId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Distribution</Name>
			<Label>@SYS81056</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountingDistributionTemplate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceDocumentHeader</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>General</Name>
			<Label>@SYS35893</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountIdOtherId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AdditionalStatementInfo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankStmtISODocument</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OriginatorId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UltimateReceiverId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TotalAccountsInGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TotalEntriesNumberOfEntries</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GroupControlTotal</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FromDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TotalRecordsInGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AsOfDateModifier</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GroupStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS53631</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Identification</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankAccountTable</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RegistrationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SwiftNo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IBAN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SequenceNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Period</Name>
			<Label>@SYS40</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FromDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ToDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Posting</Name>
			<Label>@SYS5943</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountingDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Posted</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Status</Name>
			<Label>@SYS36398</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Manual</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Type</Name>
			<Label>@GLS221315</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankStatementType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Validation</Name>
			<Label>@SYS4440</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ValidatedBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidatedDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountCurrency</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BankStmtISOCurrencyCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountIdOtherId</Name>
			<AosAuthorization>Yes</AosAuthorization>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BankStatementIdentificationText</ExtendedDataType>
			<Label>@SYS1996</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>AccountingDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>AccountingDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>AccountingDistributionTemplate</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>AccountingDistributionTemplateRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AdditionalStatementInfo</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BankStmtISOMax500Text</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>AsOfDateModifier</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BankStmtISONumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankAccountTable</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankStatementType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<EnumType>BankStatementType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankStmtISODocument</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>LedgerDimensionValueSet</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>FromDateTime</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>BankStmtISODateTime</ExtendedDataType>
			<Label>@SYS24050</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>GroupControlTotal</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>BankStmtISODecimal</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>GroupStatus</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BankStmtISONumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>IBAN</Name>
			<AosAuthorization>Yes</AosAuthorization>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>BankIBAN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Identification</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BankStatementId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Manual</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>BankStatementManual</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OriginatorId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Posted</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Posted</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RegistrationId</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>BankRegNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SequenceNumber</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>BankStmtISOMax15NumericText</ExtendedDataType>
			<Label>@SYS2658</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceDocumentHeader</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Status</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<EnumType>BankStatementStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SwiftNo</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>SWIFTNo</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ToDateTime</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>BankStmtISODateTime</ExtendedDataType>
			<Label>@SYS36680</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>TotalAccountsInGroup</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BankStmtISONumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>TotalEntriesNumberOfEntries</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BankStmtISONumber</ExtendedDataType>
			<Label>@GLS221310</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>TotalRecordsInGroup</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BankStmtISONumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>UltimateReceiverId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ValidatedBy</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BankStatementValidatedBy</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ValidatedDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@GLS221316</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Voucher</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Voucher</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>BankStmtISODocumentIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>BankStmtISODocument</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>BankStmtISOPartyIdentificationIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>OriginatorId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>BankStmtISOPartyIdentificationIdx1</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>UltimateReceiverId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>BankAccountTableIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>BankAccountTable</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SourceDocumentHeaderIdx</Name>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceDocumentHeader</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>dataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>VoucherDateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Voucher</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AccountingDate</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SourceDocumentHeaderImplementation</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>SourceDocumentHeader</MapField>
					<MapFieldTo>SourceDocumentHeader</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AccountingDistributionTemplate</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>AccountingDistributionTemplate</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountingDistributionTemplate</Name>
					<Field>AccountingDistributionTemplate</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankAccount</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>BankAccountTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankAccountTable</Name>
					<Field>BankAccountTable</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountCurrency</Name>
					<Field>AccountCurrency</Field>
					<RelatedField>CurrencyCodeISO</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Relation1</Name>
			<Cardinality>OneMore</Cardinality>
			<RelatedTable>BankStmtISODocument</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankStmtISODocument</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankStmtISODocument_BankStmtISOAccountStatement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankStmtISODocument</Name>
					<Field>BankStmtISODocument</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Relation2</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>BankStmtISOPartyIdentification</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankStmtISOPartyIdentification</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankStmtISOPartyIdentification_BankStmtISOAccountStatement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OriginatorId</Name>
					<Field>OriginatorId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Relation3</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>BankStmtISOPartyIdentification</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankStmtISOPartyIdentification_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankStmtISOPartyIdentification_1_BankStmtISOAccountStatement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>UltimateReceiverId</Name>
					<Field>UltimateReceiverId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SourceDocumentHeader</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>SourceDocumentHeader</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceDocumentHeader</Name>
					<Field>SourceDocumentHeader</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>