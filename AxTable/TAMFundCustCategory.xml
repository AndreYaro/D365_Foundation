<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TAMFundCustCategory</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class TAMFundCustCategory extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addToHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a category node to the hierarchy that is specified in the <c>FundID</c> field.
    /// </summary>
    /// <returns>
    /// true if the specified category was successfully added; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Always call this method instead of the insert method to create a new record in the
    /// <c>TAMFundCustCategory</c> table.
    /// </remarks>
    public boolean addToHierarchy()
    {
        TAMFundCustCategory tamFundCustCategory;
        TAMFundCustCategory tamFundCustCategoryParent;
        TAMFundCustCategory tamFundCustCategoryRoot;
        boolean             ret = false;

        try
        {
            ttsBegin;

            if (this.RecId
                && TAMFundCustCategory::exist(this.RecId))
            {
                // If the record already exists, then just update it.
                if (this.validateWrite())
                {
                    this.update();
                    ret = true;
                }
                else
                {
                    throw error("@SYS18447");
                }
            }
            else
            {
                if (this.ParentCategory)
                {
                    // Lock the root node to prevent concurrent modifications.
                    select pessimisticlock firstonly RecId from tamFundCustCategoryRoot
                        where tamFundCustCategoryRoot.FundID        == this.FundID
                           && tamFundCustCategoryRoot.NestedSetLeft == 1;

                    tamFundCustCategoryParent = TAMFundCustCategory::find(this.ParentCategory, true);
                    if (!tamFundCustCategoryParent || !tamFundCustCategoryParent.RecId)
                    {
                        // Parent specified is not valid or it was deleted.
                        throw error("@SYS134257");
                    }
                    else
                    {
                        this.initFromParent(tamFundCustCategoryParent);
                        this.NestedSetLeft  = tamFundCustCategoryParent.NestedSetRight;
                        this.NestedSetRight = tamFundCustCategoryParent.NestedSetRight + 1;
                        this.Level          = tamFundCustCategoryParent.Level + 1;

                        // First, we need to make some space.
                        // A while select statement is used instead of an update_recordset as the
                        // nested set left and nested set right are alternate keys and the
                        // ordering needs to be specified.
                        while select forupdate tamFundCustCategory
                            order by NestedSetLeft desc
                            where tamFundCustCategory.NestedSetLeft >= tamFundCustCategoryParent.NestedSetRight
                               && tamFundCustCategory.FundID        == tamFundCustCategoryParent.FundID
                        {
                            tamFundCustCategory.NestedSetLeft = tamFundCustCategory.NestedSetLeft + 2;
                            if (tamFundCustCategory.validateWrite())
                            {
                                tamFundCustCategory.update();
                            }
                            else
                            {
                                throw error("@SYS18447");
                            }
                        }

                        while select forupdate tamFundCustCategory
                            order by NestedSetRight desc
                            where tamFundCustCategory.NestedSetRight >= tamFundCustCategoryParent.NestedSetRight
                               && tamFundCustCategory.FundID         == tamFundCustCategoryParent.FundID
                        {
                            tamFundCustCategory.NestedSetRight = tamFundCustCategory.NestedSetRight + 2;
                            if (tamFundCustCategory.validateWrite())
                            {
                                tamFundCustCategory.update();
                            }
                            else
                            {
                                throw error("@SYS18447");
                            }
                        }

                        // Finally, insert the child.
                        if (this.validateWrite())
                        {
                            this.insert();
                            ret = true;
                        }
                        else
                        {
                            throw error("@SYS18447");
                        }
                    }
                }
                else
                {
                    ret = this.setRoot();
                }
            }
            ttsCommit;
        }
        catch
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSubTree</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the currently selected category subtree.
    /// </summary>
    public void deleteSubTree()
    {
        #EcoResCategoryDefaults

        EcoResCategoryNestedSetLeft  delLeft  = this.NestedSetLeft;
        EcoResCategoryNestedSetRight delRight = this.NestedSetRight;
        EcoResCategoryNestedSetRight delGap   = delRight - delLeft + 1;
        TAMFundCustCategory          tamFundCustCategory;
        TAMFundCustCategory          tamFundCustCategoryRoot;
        TAMFundCustCategory          tamFundCustCategoryDescendents;
        RecId                        derivedFinHierarchyRecId;

        ttsBegin;

        // Lock the tree for further modifications.
        select pessimisticlock firstonly RecId from tamFundCustCategory
            where tamFundCustCategoryRoot.FundID         == this.FundID
                && tamFundCustCategoryRoot.NestedSetLeft == #ECORESROOTNESTEDLEFTVALUE;

        // Meanwhile make sure there were no modifications.
        tamFundCustCategory = TAMFundCustCategory::find(this.RecId, true);
        if (!tamFundCustCategory.RecId)
        {
            // The node specified is not valid or already deleted.
            throw error("@SYS134263");
        }
        else if (tamFundCustCategory.NestedSetLeft     != this.NestedSetLeft
                 || tamFundCustCategory.NestedSetRight != this.NestedSetRight
                 || tamFundCustCategory.FundID         != this.FundID)
        {
                // The tree has been modified.
                throw error("@SYS134262");
        }

        // Delete the descendants.
        tamFundCustCategoryDescendents = tamFundCustCategory.getDescendants(true);
        while (tamFundCustCategoryDescendents)
        {
            if (tamFundCustCategoryDescendents.validateDelete())
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    && derivedFinHierarchyRecId != 0)
                {
                    LedgerDerivedFinHierarchyFilterResults::deleteResultsForDerivedFinHierarchyNode(derivedFinHierarchyRecId);
                    LedgerDerivedFinHierarchyRuleCriteria::deleteCriteriaForDerivedFinHierarchyNode(derivedFinHierarchyRecId);
                }
                tamFundCustCategoryDescendents.delete();
            }
            else
            {
                throw error("@SYS134261");
            }

            next tamFundCustCategoryDescendents;
        }

        // Delete this node.
        if (tamFundCustCategory.validateDelete())
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && derivedFinHierarchyRecId != 0)
            {
                LedgerDerivedFinHierarchyFilterResults::deleteResultsForDerivedFinHierarchyNode(derivedFinHierarchyRecId);
                LedgerDerivedFinHierarchyRuleCriteria::deleteCriteriaForDerivedFinHierarchyNode(derivedFinHierarchyRecId);
            }
            tamFundCustCategory.delete();
        }
        else
        {
            throw error("@SYS134261");
        }

        // Remove the gap.  The while select is used instead of an update_recordset
        // since nested set left and nested set right are alternate keys and ordering
        // needs to be specified.
        while select forupdate tamFundCustCategory
            order by NestedSetLeft asc
            where tamFundCustCategory.NestedSetLeft >= delLeft
               && tamFundCustCategory.FundID        == this.FundID
        {
            tamFundCustCategory.NestedSetLeft = tamFundCustCategory.NestedSetLeft - delGap;
            if (tamFundCustCategory.validateWrite())
            {
                tamFundCustCategory.update();
            }
            else
            {
                throw error("@SYS18447");
            }
        }

        while select forupdate tamFundCustCategory
            order by NestedSetRight asc
            where tamFundCustCategory.NestedSetRight >= delRight
               && tamFundCustCategory.FundID         == this.FundID
        {
            tamFundCustCategory.NestedSetRight = tamFundCustCategory.NestedSetRight - delGap;
            if (tamFundCustCategory.validateWrite())
            {
                tamFundCustCategory.update();
            }
            else
            {
                throw error("@SYS18447");
            }
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCurrentDistAmt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums up the budgeted amount of the children of the selected node.
    /// </summary>
    /// <param name="_ignoreCurrent">
    /// Determines whether or not to ignore the currently selected record.
    /// </param>
    /// <returns>
    /// Budgeted amount of the children of the selected node.
    /// </returns>
    /// <remarks>
    /// The parameter <paramref name="_ignoreCurrent"/> was added so this
    /// method could be used for validation.
    /// </remarks>
    public display Amount displayCurrentDistAmt(boolean _ignoreCurrent = false)
    {
        TAMFundCustCategory tamFundCustCategory;
        AmountCur           parentDistAmt;

        if (_ignoreCurrent)
        {
            select sum (BudgetedAmount) from tamFundCustCategory
                where tamFundCustCategory.ParentCategory == this.RecId
                   && tamFundCustCategory.RecId          != this.RecId;
        }
        else
        {
            select sum (BudgetedAmount) from tamFundCustCategory
                where tamFundCustCategory.ParentCategory == this.RecId;
        }
        parentDistAmt = tamFundCustCategory.BudgetedAmount;

        return parentDistAmt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFundDistAmt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums the budgeted amount of all the customer nodes in the fund hierarchy.
    /// </summary>
    /// <returns>
    /// The budgeted amount of all the customer nodes in the fund hierarchy.
    /// </returns>
    public display Amount displayFundDistAmt()
    {
        return TAMFundCustCategory::getFundDistAmt(this.FundID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayParentBudgeted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the amount budgeted for the parent group of the currently selected
    /// node of the fund hierarchy.
    /// </summary>
    /// <returns>
    /// The budget amount for the parent group.
    /// </returns>
    public display AmountCur displayParentBudgeted()
    {
        TAMFundCustCategory tamFundCustCategory;
        AmountCur           parentBudgetedAmt;

        // If there is a parent id on the selected node, then there is another group
        // above that node.  Find the amount budgeted to that group.
        if (this.ParentCategory)
        {
            tamFundCustCategory = TAMFundCustCategory::find(this.ParentCategory);
            parentBudgetedAmt = tamFundCustCategory.BudgetedAmount;
        }
        else
        {
            // If the current node is root, then there is no parent, so return 0.
            parentBudgetedAmt = 0;
        }

        return parentBudgetedAmt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayParentDistAmt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums the budgeted amount of the siblings of the selected node.
    /// </summary>
    /// <param name="_ignoreCurrent">
    /// Determines whether or not to ignore the currently selected record.
    /// </param>
    /// <returns>
    /// The budgeted amount of the siblings of the selected node.
    /// </returns>
    /// <remarks>
    /// The parameter <paramref name="_ignoreCurrent"/> was added so this
    /// method could be used for validation.
    /// </remarks>
    public display Amount displayParentDistAmt(boolean _ignoreCurrent = false)
    {
        TAMFundCustCategory tamFundCustCategory;
        AmountCur           parentDistAmt;

        // If there is a parent id on the selected node, then there is another group
        // above that node.  Find the amount budgeted to that group.
        if (this.ParentCategory)
        {
            if (_ignoreCurrent)
            {
                select sum (BudgetedAmount) from tamFundCustCategory
                    where tamFundCustCategory.ParentCategory == this.ParentCategory
                       && tamFundCustCategory.RecId != this.RecId;
            }
            else
            {
                select sum (BudgetedAmount) from tamFundCustCategory
                    where tamFundCustCategory.ParentCategory == this.ParentCategory;
            }

            parentDistAmt = tamFundCustCategory.BudgetedAmount;
        }
        else
        {
            // If the current node is root, then there is no parent, so return 0.
            parentDistAmt = 0;
        }

        return parentDistAmt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the child count for the specified record in the
    /// <c>TAMFundCustCategory</c> table.
    /// </summary>
    /// <param name="_activeOnly">
    /// A <c>Boolean</c> value that indicates whether to retrieve only active
    /// child categories.
    /// </param>
    /// <returns>
    /// The number of children for the specified category.
    /// </returns>
    public int64 getChildCount(boolean _activeOnly = false)
    {
        int64               childCount          = 0;
        TAMFundCustCategory tamFundCustCategory =  null;

        if (this.RecId && TAMFundCustCategory::exist(this.RecId))
        {
            select count(RecId) from tamFundCustCategory
                where tamFundCustCategory.FundID          == this.FundID
                   && tamFundCustCategory.ParentCategory  == this.RecId
                   && (tamFundCustCategory.IsActive    == true
                       || tamFundCustCategory.IsActive == _activeOnly);

            childCount = tamFundCustCategory.RecId;
        }
        return childCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildren</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves all the child categories of the current category.
    /// </summary>
    /// <param name="_forUpdate">
    /// A <c>Boolean</c> value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_activeOnly">
    /// A <c>Boolean</c> value that indicates whether to retrieve active categories only.
    /// </param>
    /// <returns>
    /// A record buffer of the <c>TAMFundCustCategory</c> table if children found; otherwise,
    /// an empty buffer.
    /// </returns>
    public TAMFundCustCategory getChildren(
        boolean _forUpdate  = false,
        boolean _activeOnly = false)
    {
        TAMFundCustCategory tamFundCustCategory;

        if (this.RecId
            && TAMFundCustCategory::exist(this.RecId))
        {
            tamFundCustCategory.selectForUpdate(_forUpdate);

            select tamFundCustCategory
                order by tamFundCustCategory.Name
                where tamFundCustCategory.FundID          == this.FundID
                   && tamFundCustCategory.ParentCategory  == this.RecId
                   && (tamFundCustCategory.IsActive    == true
                       || tamFundCustCategory.IsActive == _activeOnly);
        }
        return tamFundCustCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDescendants</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves all the descendant categories of the current category.
    /// </summary>
    /// <param name="_forUpdate">
    /// A <c>Boolean</c> value that indicates whether to read the record for
    /// update; optional.
    /// </param>
    /// <param name="_activeOnly">
    /// A <c>Boolean</c> value that indicates whether to retrieve active categories only.
    /// </param>
    /// <returns>
    /// A record buffer of the <c>TAMFundCustCategory</c> table if descendants found;
    /// otherwise, an empty buffer.
    /// </returns>
    public TAMFundCustCategory getDescendants(
        boolean _forUpdate  = false,
        boolean _activeOnly = false)
    {
        TAMFundCustCategory tamFundCustCategory;

        if (this.RecId
            && TAMFundCustCategory::exist(this.RecId))
        {
            tamFundCustCategory.selectForUpdate(_forUpdate);

            select tamFundCustCategory
                order by tamFundCustCategory.NestedSetLeft
                where tamFundCustCategory.FundID        == this.FundID
                   && tamFundCustCategory.NestedSetLeft  > this.NestedSetLeft
                   && tamFundCustCategory.NestedSetRight < this.NestedSetRight
                   && (tamFundCustCategory.IsActive    == true
                       || tamFundCustCategory.IsActive == _activeOnly);
        }

        return tamFundCustCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a child category record of the <c>TAMFundCustCategory</c> table,
    /// based on the specified parent category.
    /// </summary>
    /// <param name="_tamFundCustCategory">
    /// The parent category record from the <c>TAMFundCustCategory</c> table.
    /// </param>
    public void initFromParent(TAMFundCustCategory _tamFundCustCategory)
    {
        this.FundID         = _tamFundCustCategory.FundID;
        this.ParentCategory = _tamFundCustCategory.RecId;
        this.IsActive       = _tamFundCustCategory.IsActive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current record.
    /// </summary>
    public void initValue()
    {
        super();
        this.IsActive = NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
        public void insert()
    {
        super();

        if (!this.ParentCategory)
        {
            TAMFundTable::updateFundBudgetAmount(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new category root node to a hierarchy.
    /// </summary>
    /// <returns>
    /// true if the specified root category was added; otherwise, false.
    /// </returns>
    public boolean setRoot()
    {
        #EcoResCategoryDefaults

        TAMFundCustCategory tamFundCustCategory;
        TAMFundTable        tamFundTable;
        boolean             ret = false;

        try
        {
            ttsBegin;

            tamFundTable = TAMFundTable::find(this.FundID);

            if (!tamFundTable || !tamFundTable.RecId)
            {
                // Hierarchy specified is not valid.
                throw error("@SYS301577");
            }

            tamFundCustCategory = TAMFundCustCategory::getRoot(tamFundTable.FundID, true);
            if (tamFundCustCategory.RecId
                && tamFundCustCategory.RecId != this.RecId)
            {
                // A different root node already exists.
                throw error("@SYS301578");
            }

            if (this.ParentCategory)
            {
                // Parent cannot be specified for root node.
                throw error("@SYS301579");
            }

            this.NestedSetLeft = #ECORESROOTNESTEDLEFTVALUE;
            this.Level         = 1;

            if (!this.RecId)
            {
                this.NestedSetRight = #ECORESROOTNESTEDLEFTVALUE + 1;

                if (this.validateWrite())
                {
                    this.insert();
                    ret = true;
                }
            }
            else
            {
                if (this.validateWrite())
                {
                    this.update();
                    ret = true;
                }
            }

            ttsCommit;
        }
        catch
        {
            ret = false;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
        public void update()
    {
        super();

        if (!this.ParentCategory)
        {
            TAMFundTable::updateFundBudgetAmount(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
        public boolean validateWrite()
    {
        TAMFundCustCategory tamFundCustCategory_parent;
        boolean             ret;

        ret = super();

        if (ret)
        {
            if (!this.RecId)
            {
                if (TAMFundCustCategory::findName(this.FundID, this.Name))
                {
                    ret = false;
                }
            }
            else
            {
                tamFundCustCategory_parent = TAMFundCustCategory::find(this.ParentCategory);
                if (tamFundCustCategory_parent)
                {
                    if (this.BudgetedAmount + this.displayParentDistAmt(true) > tamFundCustCategory_parent.BudgetedAmount)
                    {
                        ret = checkFailed("@MCR26099");
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createHierarchyRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates the root category node for a given category hierarchy.
    /// </summary>
    /// <param name="_tamFundId">
    /// The fund ID for which to retrieve in the <c>TAMFundTable</c> table.
    /// </param>
    /// <param name="_ecoResCategoryName">
    /// The root category name to be created in the specified category hierarchy.
    /// </param>
    /// <returns>
    /// The root category record of the <c>TAMFundCustCategory</c> table if successfully created; otherwise, an
    /// empty buffer.
    /// </returns>
    public static TAMFundCustCategory createHierarchyRoot(
        TAMFundID           _tamFundId,
        EcoResCategoryName  _ecoResCategoryName = "@SYS136676")
    {
        TAMFundCustCategory tamFundCustCategory;

        ttsBegin;

        if (!tamFundCustCategory || !tamFundCustCategory.RecId)
        {
            tamFundCustCategory.initValue();
            tamFundCustCategory.FundID = _tamFundId;
        }

        tamFundCustCategory.Name = _ecoResCategoryName;
        tamFundCustCategory.BudgetedAmount = TAMFundTable::find(_tamFundId).TotalFundAmt;
        tamFundCustCategory.setRoot();

        ttsCommit;

        return tamFundCustCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified category is located in the
    /// <c>EcoResCategory</c> table.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    /// The category ID in the <c>TAMFundCustCategory</c> table to
    /// check for existence.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean exist(EcoResCategoryId _ecoResCategoryId)
    {
        TAMFundCustCategory tamFundCustCategory;
        boolean             ret = false;

        if (_ecoResCategoryId)
        {
            select firstOnly RecId from tamFundCustCategory
                where tamFundCustCategory.RecId == _ecoResCategoryId;
        }
        if (tamFundCustCategory.RecId)
        {
            ret = true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified category in the <c>EcoResCategory</c> table.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    /// The category ID in the <c>EcoResCategory</c> table to retrieve.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record of the <c>TAMFundCustCategory</c> table if found; otherwise, an empty buffer.
    /// </returns>
    public static TAMFundCustCategory find(
        EcoResCategoryId _ecoResCategoryId,
        boolean          _forUpdate = false)
    {
        TAMFundCustCategory tamFundCustCategory;

        if (_ecoResCategoryId)
        {
            tamFundCustCategory.selectForUpdate(_forUpdate);
            select firstOnly tamFundCustCategory
                where tamFundCustCategory.RecId == _ecoResCategoryId;
        }

        return tamFundCustCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>TAMFundCustCategory</c> table.
    /// </summary>
    /// <param name="_tamFundId">
    /// The fund ID of the <c>TAMFundCustCategory</c> table record to find.
    /// </param>
    /// <param name="_ecoResCategoryName">
    /// The name of the <c>TAMFundCustCategory</c> table record to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A <c>Boolean</c> value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in <c>TAMFundCustCategory</c>; otherwise, an empty record.
    /// </returns>
    public static TAMFundCustCategory findName(
        TAMFundID           _tamFundId,
        EcoResCategoryName  _ecoResCategoryName,
        boolean             _forUpdate = false)
    {
        TAMFundCustCategory tamFundCustCategory;

        if (_tamFundId && _ecoResCategoryName)
        {
            tamFundCustCategory.selectForUpdate(_forUpdate);

            select firstonly tamFundCustCategory
                where tamFundCustCategory.Name == _ecoResCategoryName
                   && tamFundCustCategory.FundID == _tamFundId;
        }

        return tamFundCustCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNonExistByString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first <c>string</c> value so that in the table that is specified by
    /// the value of the <paramref name="_tableId" /> table, there is no existing record
    /// with the <paramref name="_matchingFieldId" /> field's value matching the
    /// specified value of the <paramref name="_matchingFieldValue" /> parameter, and
    /// the <paramref name="_strFieldId" /> field's value that matches the String value
    /// found.
    /// </summary>
    /// <param name="_tableId">
    /// The ID of table to search.
    /// </param>
    /// <param name="_matchingFieldId">
    /// The ID of field in the table to match.
    /// </param>
    /// <param name="_matchingFieldValue">
    /// The value with which to match the value of the
    /// <paramref name="_matchingFieldId" /> field.
    /// </param>
    /// <param name="_strFieldId">
    /// The ID of the String field in the table to match.
    /// </param>
    /// <param name="_strFieldType">
    /// The ID of the extended data type of a String field.
    /// </param>
    /// <param name="_strValueExactMatch">
    /// The exact value with which to match the <paramref name="_strFieldId" />
    /// String field.
    /// </param>
    /// <param name="_strValueFormatter">
    /// The formatter for the value to match the <paramref name="_strFieldId" />
    /// String field.
    /// </param>
    /// <param name="_excludedRecId">
    /// The record ID to exclude in search for non-exist name.
    /// </param>
    /// <returns>
    /// The first string value that does not match the string field of any existing
    /// record in the table.
    /// </returns>
    /// <remarks>
    ///  For example, if
    ///  <list type="bullet">
    ///   <item>
    ///    <description>
    ///    the table is <c>EcoResCategory</c> ,
    ///    </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_matchingFieldId" /> is CategoryHierarchy, </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_matchingFieldValue" /> is 12345678, </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_strFieldId" /> is Name, </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_strValueExactMatch" /> is "New Node", </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_strValueFormatter" /> is "New Node # %1", </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_excludedRecId" /> is 87654321, </description>
    ///   </item>
    ///  </list>
    ///   then,
    ///  <list type="number">
    ///   <item>
    ///    <description>
    ///    If the <c>EcoResCategory</c> table, excluding 87654321, has no record with
    ///    CategoryHierarchy=12345678 and Name="New Node", the return value would be "New Node".
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    If the <c>EcoResCategory</c> table, excluding 87654321, has no record with
    ///    CategoryHierarchy=12345678 and Name="New Node # 1", the return value would be "New Node # 1".
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    If the <c>EcoResCategory</c> table, excluding 87654321, has no record with
    ///    CategoryHierarchy=12345678 and Name="New Node # 2", -- return value would be "New Node # 2".
    ///    </description>
    ///   </item>
    ///  </list>
    ///   An exception is thrown if we cannot find one after exhausting all possibilities.The formatter
    ///  should take one argument, which will be replaced by an integer starting from 1 and incremented by 1
    ///  when searching for non-match.
    /// </remarks>
    public static str findNonExistByString(
        TableId         _tableId,
        FieldId         _matchingFieldId,
        anytype         _matchingFieldValue,
        FieldId         _strFieldId,
        ExtendedTypeId  _strFieldType,
        str             _strValueExactMatch,
        str             _strValueFormatter,
        RecId           _excludedRecId = 0)
    {
        DictTable   dictTable = new DictTable(_tableId);
        Common      common = dictTable.makeRecord();
        int         idx = 0;
        anytype     result;
        anytype     firstStringValue;
        int         edtMaxLen = new DictType(_strFieldType).stringLen();

        result = _strValueExactMatch;

        do
        {
            select crossCompany common
                where common.(_strFieldId)      == result
                   && common.(_matchingFieldId) == _matchingFieldValue
                   && common.RecId              != _excludedRecId;
            if (!common.RecId)
            {
                break;
            }

            // Detect an infinite loop.
            if (1 == idx)
            {
                firstStringValue = common.(_strFieldId);
            }
            else if (idx > 0 && firstStringValue == common.(_strFieldId))
            {
                throw error(strFmt("@SYS330468",
                    _tableId,
                    tableId2name(_tableId),
                    _matchingFieldId,
                    fieldId2name(_tableId, _matchingFieldId),
                    _matchingFieldValue,
                    _strFieldId,
                    fieldId2name(_tableId, _strFieldId),
                    idx,
                    firstStringValue));
            }

            idx++;
            result = strFmt(_strValueFormatter, idx);

            // trim as necessary.
            if (strLen(result) > edtMaxLen)
            {
                result = subStr(result, 1, edtMaxLen);
            }
        } while (true);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNonExistNameInHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a name that does not match any existing record in the
    /// <c>EcoResCategory</c> table of the given hierarchy.
    /// </summary>
    /// <param name="_tamFundId">
    /// The fund ID to use to search categories.
    /// </param>
    /// <returns>
    /// A string that would not conflict with any existing name column of the
    /// <c>EcoResCategory</c> table of the record in the given hierarchy.
    /// </returns>
    public static EcoResCategoryName findNonExistNameInHierarchy(TAMFundID _tamFundId)
    {
        EcoResCategoryName ecoResCategoryName;

        if (_tamFundId)
        {
            ecoResCategoryName = TAMFundCustCategory::findNonExistByString(
                tableNum(TAMFundCustCategory),
                fieldNum(TAMFundCustCategory, FundID),
                _tamFundId,
                fieldNum(TAMFundCustCategory, Name),
                extendedTypeNum(EcoResCategoryName),
                "@SYS134268",
                "@SYS136676");
        }
        return ecoResCategoryName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFundDistAmt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums budgeted amount of all the customer nodes in the fund hierarchy.
    /// </summary>
    /// <param name="_tamFundId">
    /// The fund ID in the <c>TAMFundTable</c> table to retrieve.
    /// </param>
    /// <returns>
    /// Budgeted amount of all the customer nodes in the fund hierarchy.
    /// </returns>
    public static Amount getFundDistAmt(TAMFundID _tamFundId)
    {
        TAMFundCustCategory tamFundCustCategory;
        AmountCur           fundDistAmt;

        if (_tamFundId)
        {
            select sum (BudgetedAmount) from tamFundCustCategory
                where tamFundCustCategory.FundID == _tamFundId
                   && tamFundCustCategory.Customer;
            fundDistAmt = tamFundCustCategory.BudgetedAmount;
        }

        return fundDistAmt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the root or very first category of the hierarchy.
    /// </summary>
    /// <param name="_tamFundId">
    /// The fund ID in the <c>TAMFundTable</c> table to retrieve.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for
    /// update; optional.
    /// </param>
    /// <returns>
    /// A record of the <c>TAMFundCustCategory</c> table if found; otherwise,
    /// an empty buffer.
    /// </returns>
    public static TAMFundCustCategory getRoot(
        TAMFundID _tamFundId,
        boolean   _forUpdate = false)
    {
        #EcoResCategoryDefaults

        TAMFundCustCategory tamFundCustCategory;

        if (_tamFundId)
        {
            tamFundCustCategory.selectForUpdate(_forUpdate);
            select firstonly tamFundCustCategory
                where tamFundCustCategory.FundID        == _tamFundId
                   && tamFundCustCategory.NestedSetLeft == #ECORESROOTNESTEDLEFTVALUE;
        }

        return tamFundCustCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertMCRCategoryCust</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Creates record into table <c>MCRCustomersCategory</c>.
    /// </summary>
    /// <param name="_tamFundCustCategory">
    ///  A record buffer of table <c>TAMFundCustCategory</c> to find existing
    /// record in table <c>MCRCustomersCategory</c> for a selected category
    /// hierarchy.
    /// </param>
    /// <param name="_custTable">
    /// A record buffer of table <c>CustTable</c> to find existing record
    /// in table <c>MCRCustomersCategory</c> for selected product.
    /// </param>
    /// <returns>
    /// A record in the <c>MCRCustomersCategory</c> table; otherwise,
    /// an empty record.
    /// </returns>
    public static TAMFundCustCategory insertMCRCategoryCust(
        TAMFundCustCategory _tamFundCustCategory,
        CustTable           _custTable)
    {
        TAMFundCustCategory   tamFundCustCategoryNew;
        TAMFundCustCategory   tamFundCustCategorySelected;

        select firstonly RecId from tamFundCustCategorySelected
            where tamFundCustCategorySelected.FundID == _tamFundCustCategory.FundID
                && tamFundCustCategorySelected.Customer == _custTable.RecId;

        if (tamFundCustCategorySelected.RecId == 0)
        {
            tamFundCustCategoryNew.clear();
            tamFundCustCategoryNew.initValue();
            tamFundCustCategoryNew.ParentCategory = _tamFundCustCategory.RecId;
            tamFundCustCategoryNew.FundID         = _tamFundCustCategory.FundID;
            tamFundCustCategoryNew.Customer       = _custTable.RecId;

            if (tamFundCustCategoryNew.validateWrite())
            {
                tamFundCustCategoryNew.insert();
            }
            else
            {
                throw error("@SYS18447");
            }
        }
        else
        {
            error (strFmt("@MCR39558",
                CustTable::findRecId(_custTable.RecId).name(),
                TAMFundTable::find(_tamFundCustCategory.FundID).FundID));
        }

        return tamFundCustCategoryNew;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRootBudgetAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the budgeted amount for the root node
    /// to the total fund amount.
    /// </summary>
    /// <param name="_tamFundTable">
    /// The <c>TAMFundTable</c> record used to update the root node.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Error indicating that validation failed
    /// while updating the <c>TAMFundCustCategory</c> record.
    /// </exception>
    public static void updateRootBudgetAmount(TAMFundTable _tamFundTable)
    {
        TAMFundCustCategory tamFundCustCategory =
            TAMFundCustCategory::getRoot(_tamFundTable.FundID, true);

        if (tamFundCustCategory)
        {
            ttsBegin;

            tamFundCustCategory.BudgetedAmount = _tamFundTable.TotalFundAmt;

            if (tamFundCustCategory.validateWrite())
            {
                // Need to use doUpdate since this is called from the insert and
                // update methods.
                tamFundCustCategory.doUpdate();
            }
            else
            {
                throw error("@SYS18447");
            }

            ttsCommit;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>TAMPromotionsManagement</ConfigurationKey>
	<DeveloperDocumentation>@MCR39275</DeveloperDocumentation>
	<Label>@MCR39275</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>FundID</TitleField1>
	<TitleField2>Name</TitleField2>
	<CacheLookup>FoundAndEmpty</CacheLookup>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<InstanceRelationType>InstanceRelationType</InstanceRelationType>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>SalesAndMarketing</Modules>
	<ReplacementKey>FundNameIdx</ReplacementKey>
	<SupportInheritance>Yes</SupportInheritance>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FundID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FundID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@SYS104259</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Code</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Customer</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FundID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InstanceRelationType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsActive</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Level</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NestedSetLeft</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NestedSetRight</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BudgetedAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>BudgetedAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Amount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Code</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryCommodityCode</ExtendedDataType>
			<Label>@SYS300623</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Customer</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>CustTableRefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>FundID</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TAMFundID</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InstanceRelationType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RelationType</ExtendedDataType>
			<Label>@SYS133857</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsActive</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS26201</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Level</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryLevel</ExtendedDataType>
			<Label>@SYS300625</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryName</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>NestedSetLeft</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryNestedSetLeft</ExtendedDataType>
			<Label>@SYS300627</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>NestedSetRight</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryNestedSetRight</ExtendedDataType>
			<Label>@SYS300626</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ParentCategory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TAMFundCustCategoryRefRecId</ExtendedDataType>
			<Label>@SYS130838</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>FundNameIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>FundID</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Name</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ParentCategoryIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ParentCategory</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CustomerIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Customer</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>NestedSetRightIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>NestedSetRight</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>NestedSetLeftIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>NestedSetLeft</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Customer</Name>
					<SourceEDT>CustTableRefRecId</SourceEDT>
					<Field>Customer</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TAMFundCustCategory_Parent</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TAMFundCustCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ParentCategory</Name>
					<Field>ParentCategory</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TAMFundTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>TAMFundTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FundID</Name>
					<SourceEDT>TAMFundID</SourceEDT>
					<Field>FundID</Field>
					<RelatedField>FundID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Fund</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>