<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TmpProjAdjustmentCreate</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class TmpProjAdjustmentCreate extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkActivity</Name>
				<Source><![CDATA[
    private boolean checkActivity()
    {      
        boolean ret = true;

        if (this.ActivityNumber)
        {
            //Disable checking for activity to be closed to allow Tmp Proj Adjustment Create DS
            //to be saved even with closed activities. Else the Form is not able to exit.
			//There is a check at the Form level - See ProjAdjustment check for closed activities.
            ret = ProjActivityHelper::validateProjActivityParentLinkV2(this.ProjId, this.ActivityNumber, false);

            // validate if activity is a root activity.
            if (ret && !ProjParameters::allowParentActivitySelection(this.ActivityNumber))
            {
                ret = checkFailed("@Proj:ParentActivityError");
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCategoryId</Name>
				<Source><![CDATA[
    protected boolean checkCategoryId()
    {
        boolean         ret = true;
        
        if (this.CategoryId)
        {
            ProjCategory projCategory = ProjCategory::find(this.CategoryId);

            switch(this.AdjustmentType)
            {
                case ProjAdjustmentType::Hour:
                    if (projCategory.CategoryType != ProjCategoryType::Hour)
                    {
                        ret = checkFailed(strFmt("@SYS54897",this.CategoryId));
                    }

                    ret = ret && projCategory.validateIfInactiveAllowed();
                    break;

                case ProjAdjustmentType::Revenue:                  
                    if (projCategory.CategoryType != ProjCategoryType::Revenue)
                    {
                        ret = checkFailed(strFmt("@SYS54897",this.CategoryId));
                    }

                    if (ret && (projCategory.SetupEstimate || projCategory.PSACustPaymentRetention))
                    {
                        if (FeatureStateProvider::isFeatureEnabled(ProjEstimatesToRevRecRenameFeature::instance()))
                        {
                            ret = checkFailed("@Proj:RegistrationFeeCannotUseCategoryV2");
                        }
                        else
                        {
                            ret = checkFailed("@Proj:RegistrationFeeCannotUseCategory");
                        }
                    }


                    ProjRevenueTrans projRevenueTrans;
                    // check original transaction settings against created transaction
                    select firstonly projRevenueTrans
                        where projRevenueTrans.TransId == this.TransId;

                    if (ProjCategory::find(projRevenueTrans.CategoryId).SetupSubscription == NoYes::Yes)
                    {
                        if (projCategory.SetupSubscription == NoYes::No)
                        {
                            ret = checkFailed("@SYS88807");
                        }
                    }
                    else
                    {
                        ret = ret && projCategory.validateIfInactiveAllowed();
                    }
                    
                    break;
            }

            if (ret && projCategory.psaIndirectComponent)
            {
                ret = checkFailed("@PSA11059");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLineProperty</Name>
				<Source><![CDATA[
    private boolean checkLineProperty()
    {
        boolean ret = true;
        NoYes toBeInvoiced = ProjLineProperty::find(this.LinePropertyId).ToBeInvoiced;

        if (toBeInvoiced)
        {
            ProjTransType projTransType;

            switch (this.AdjustmentType)
            {
                case ProjAdjustmentType::Cost:
                    projTransType = ProjTransType::Cost;
                    break;

                case ProjAdjustmentType::Revenue:
                    projTransType = ProjTransType::Revenue;
                    break;

                case ProjAdjustmentType::Hour:
                    projTransType = ProjTransType::Hour;
                    break;

                case ProjAdjustmentType::Item:
                    projTransType = ProjTransType::Item;
                    break;
            }

            ProjTable projTable = ProjTable::find(this.ProjId);

            if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(projTable, projTransType))
            {
                ret = checkFailed(strFmt("@PSA10715", ProjType::FixedPrice));
            }
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjId</Name>
				<Source><![CDATA[
    private boolean checkProjId()
    {
        boolean     ret = true;
        ProjTable   projTable = ProjTable::find(this.ProjId);
        if (!projTable)
        {
            ret = checkFailed(strFmt("@SYS11217", this.ProjId));
        }
        else
        {
            ProjCategory projCategory = ProjCategory::find(this.CategoryId);
            switch(projCategory.CategoryType)
            {
                case ProjCategoryType::Hour:
                    if(! projTable.status().checkRule(ProjStatusRule::CreateJournal))
                    {
                        ret = checkFailed(strFmt("@SYS135526",projTable.Status));
                    }
                    if (ret && ! projTable.status().activeInTree())
                    {
                        ret = checkFailed(strFmt("@SYS96612",this.ProjId));
                    }
                    break;

                case ProjCategoryType::Revenue:
                    if(! projTable.status().checkRule(ProjStatusRule::CreateJournal))
                    {
                        ret = checkFailed(strFmt("@SYS135526",projTable.Status));
                    }
                    if (ret && (!projTable.status().activeInTreeRevenue()) &&
                        !ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(projTable, ProjTransType::Revenue))
                    {
                        ret = checkFailed(strFmt("@Proj:ProjectCannotBeSelected", projTable.ProjId));
                    }
                    if (ret && ! projTable.status().activeInTree())
                    {
                        ret = checkFailed(strFmt("@SYS96612",this.ProjId));
                    }
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCategoryAllowed</Name>
				<Source><![CDATA[
    public boolean checkCategoryAllowed()
    {
        boolean ret = true;

        if (this.ActivityNumber && this.CategoryId)
        {
            if (ProjActivity::find(this.ActivityNumber).Mandatory)
            {
                if (this.CategoryId != (ProjActivity::find(this.ActivityNumber).CategoryDefault))
                {
                    ret = checkFailed("@SYS81827");
                }

                this.CategoryId = ProjActivity::find(this.ActivityNumber).CategoryDefault;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidTaxCodes_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the tax codes is valid or not.
    /// </summary>
    /// <returns>
    /// true if the tax codes is valid ; otherwise, false.
    /// </returns>
    public boolean checkValidTaxCodes_IN()
    {
        FormulaDesigner_IN  formulaDesigner;
        TaxTable            taxTable;
        boolean             ret = true;

        select RecId from formulaDesigner
        join RecId from taxTable
            where formulaDesigner.TaxItemGroup == this.TaxItemGroupId
               && taxTable.TaxCode == formulaDesigner.TaxCode
               && (taxTable.TaxType_IN == TaxType_IN::Customs
               || taxTable.TaxType_IN == TaxType_IN::Excise);

        if (formulaDesigner.RecId)
        {
            ret = checkFailed("@GLS3800203");
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>CompanyInfo</c> record associated with the current record.
    /// </summary>
    /// <returns>
    /// The <c>CompanyInfo</c> record.
    /// </returns>
    public CompanyInfo companyInfo()
    {
        return CompanyInfo::findDataArea(this.company());
    }

]]></Source>
			</Method>
			<Method>
				<Name>custAccount</Name>
				<Source><![CDATA[
    CustAccount custAccount()
    {
        return ProjFundingSource::findCustAccount(ProjTable::projInvoiceStatic(this.ProjId).ProjInvoiceProjId).CustAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedCategoryId</Name>
				<Source><![CDATA[
    public void fieldModifiedCategoryId()
    {
        this.checkCategoryAllowed();

        this.setLineProperty();
        this.setTaxItemGroupId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedProjId</Name>
				<Source><![CDATA[
    public void fieldModifiedProjId()
    {
        this.setActivityId();
        this.setCurrencyId();
        this.setTaxGroupId();
        this.setDimension();
        if (this.mustSetLineProperty())
        {
            this.setLineProperty();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetLineProperty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if line property must be set.
    /// </summary>
    /// <returns>true if line property must be set; otherwise, false.</returns>
    protected boolean mustSetLineProperty()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>identification</Name>
				<Source><![CDATA[
    display EmplItemId identification()
    {
        if (this.checkAdjustmentType(ProjAdjustmentType::Item))
        {
            return this.ItemId;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>identificationResource</Name>
				<Source><![CDATA[
    display ResourceRecId identificationResource()
    {
        if (this.checkAdjustmentType(ProjAdjustmentType::Hour))
        {
            return this.Resource;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPriceDisc</Name>
				<Source><![CDATA[
    PriceCur initFromPriceDisc(PriceDisc priceDisc)
    {
        return priceDisc.price();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    InventDim inventDim()
    {
        return InventDim::find(this.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a dimension set that holds the merged combination of the current <c>defaultDimension</c>
    /// field on this table and the provided dimension set.
    /// </summary>
    /// <param name="_primaryDefaultDimension">
    /// A first dimension set to merge with the current <c>defaultDimension</c> field on this table.
    /// </param>
    /// <param name="_secondaryDefaultDimension">
    /// A second dimension set to merge with the current <c>defaultDimension</c> field on this table;
    /// optional.
    /// </param>
    /// <param name="_dimensionMerge">
    /// A <c>dimensionMerge</c> object that was initialized with the current buffer; optional.
    /// </param>
    /// <returns>
    /// A dimension set that holds the merged combination of the current <c>defaultDimension</c> field on
    /// this table and the provided dimension set.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are not overwritten when they are merged.
    /// </remarks>

    public DimensionDefault mergeDimension(
    DimensionDefault _primaryDefaultDimension,
    DimensionDefault _secondaryDefaultDimension = 0,
    DimensionMerge   _dimensionMerge = DimensionMerge::newFromTable(this,
                                                                    this.companyInfo().RecId
                                                                    )
    )
    {
        return _dimensionMerge.merge(_primaryDefaultDimension, _secondaryDefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceGroupId</Name>
				<Source><![CDATA[
    PriceGroupId priceGroupId()
    {
        return ProjTable::findPriceGroup(this.ProjId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceQty</Name>
				<Source><![CDATA[
    ProjQtyCost priceQty()
    {
        return this.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTable</Name>
				<Source><![CDATA[
    ProjTable projTable(boolean _forUpdate = false)
    {
        return ProjTable::find(this.ProjId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setActivityId</Name>
				<Source><![CDATA[
    public void setActivityId()
    {
        if (this.ProjId != this.orig().ProjId)
        {
            this.ActivityNumber    = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCurrencyId</Name>
				<Source><![CDATA[
    public void setCurrencyId()
    {
        if (ProjInvoiceTable::find(ProjTable::find(this.ProjId).ProjInvoiceProjId).CurrencyId)
        {
            this.CurrencyId = ProjInvoiceTable::find(ProjTable::find(this.ProjId).ProjInvoiceProjId).CurrencyId;
        }
        else
        {
            this.CurrencyId = Ledger::accountingCurrency(CompanyInfo::findDataArea(curext()).RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// A dimension set is applied to the <c>TmpProjAdjustmentCreate.dimension</c> field based on the project, resource and item dimensions.
    /// </summary>
    public void setDimension()
    {
        this.inventDim().modifiedInventSiteFromParent(this);

        DimensionDefault projectDimension   = DefaultDimensionDefaultingStrategy::newCopy(
            DefaultDimensionDefaultingDimensionTarget::newFromRecord(this),
            DefaultDimensionDefaultingDimensionUnknownSource::newFromDimensionDefault(ProjTable::find(this.ProjId).DefaultDimension),
            DimensionCopy::newFromTable(this, CompanyInfo::findDataArea(curext()).RecId))
            .getDefaultDimension();

        DimensionDefault resourceDimension;
        resourceDimension = ResourceFacade::getDefaultDimensionByDate(this.Resource, this.TransDate);
        
        DimensionDefault inventDimension    = DefaultDimensionDefaultingStrategy::newCopy(
            DefaultDimensionDefaultingDimensionTarget::newFromRecord(this),
            DefaultDimensionDefaultingDimensionUnknownSource::newFromDimensionDefault(InventTable::find(this.ItemId).DefaultDimension),
            DimensionCopy::newFromTable(this, CompanyInfo::findDataArea(curext()).RecId))
            .getDefaultDimension();

        this.DefaultDimension = DefaultDimensionDefaultingStrategy::newServiceMerge(
            DefaultDimensionDefaultingDimensionTarget::newFromRecord(this),
            DefaultDimensionDefaultingDimensionCollection::construct()
                .add(DefaultDimensionDefaultingDimensionUnknownSource::newFromDimensionDefault(projectDimension))
                .add(DefaultDimensionDefaultingDimensionUnknownSource::newFromDimensionDefault(resourceDimension))
                .add(DefaultDimensionDefaultingDimensionUnknownSource::newFromDimensionDefault(inventDimension))).getDefaultDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHourCostPrice</Name>
				<Source><![CDATA[
    public void setHourCostPrice()
    {
        TmpProjAdjustmentCreateCost     tmpProjAdjustmentCreateCost;

        select forupdate tmpProjAdjustmentCreateCost
            where tmpProjAdjustmentCreateCost.RefRecId == this.RecId;

        if (this.checkAdjustmentType(ProjAdjustmentType::Hour))
        {
            ProjPriceParameters priceParams = this.instantiateProjectPriceParametersForHourCostPriceLookup();
            TmpProjAdjustmentCreateCost.CostPrice = ProjHourCostPrice::findCostPriceByPriceParameters(priceParams, false);
        }
        tmpProjAdjustmentCreateCost.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProjectPriceParametersForHourCostPriceLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a <c>ProjPriceParameters</c> parameter class instance.
    /// </summary>
    /// <returns>The <c>ProjPriceParameters</c> class instance.</returns>
    protected ProjPriceParameters instantiateProjectPriceParametersForHourCostPriceLookup()
    {
        ProjPriceParameters priceParams = ProjHourCostPrice::constructPriceParametersForFindCostPrice(
                this.ProjId ,
                this.Resource,
                this.CategoryId,
                this.LinePropertyId,
                this.Transdate,
                '',
                '',
                '',
                this.ResourceCategory);

        return priceParams;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLineProperty</Name>
				<Source><![CDATA[
    public void setLineProperty()
    {
        this.LinePropertyId = ProjLinePropertySetup::findLinePropertyId(this.ProjId, this.CategoryId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Project name is applied to the ProjName field in the form datasource <c>TmpProjAdjustmentCreate</c> table based on project ID.
    /// </summary>
    public void setProjName()
    {
        this.ProjName = ProjTable::name(this.ProjId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceAgreement</Name>
				<Source><![CDATA[
    SalesPrice setPriceAgreement()
    {
        PriceDisc   priceDisc;
        SalesPrice  salesPrice;

        priceDisc = this.createPriceDiscInstance(this.createAndInitPriceDiscParameters());

        if (priceDisc.findPrice(this.priceGroupId()))
        {
            salesPrice  = this.initFromPriceDisc(priceDisc);
        }

        return salesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceDiscParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>PriceDiscParameters</c> class.
    /// </summary>
    /// <returns>An instance of the <c>PriceDiscParameters</c> class.</returns>
    protected PriceDiscParameters createPriceDiscParameters()
    {
        return PriceDiscParameters::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndInitPriceDiscParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes an instance of the <c>PriceDiscParameters</c> class.
    /// </summary>
    /// <returns>An instance of the <c>PriceDiscParameters</c> class.</returns>
    protected PriceDiscParameters createAndInitPriceDiscParameters()
    {
        PriceDiscParameters parameters = this.createPriceDiscParameters();

        parameters.parmModuleType(ModuleInventPurchSales::Sales);
        parameters.parmItemId(this.itemId);
        parameters.parmInventDim(this.inventDim());
        parameters.parmUnitID(this.SalesUnit);
        parameters.parmPriceDiscDate(this.Transdate);
        parameters.parmQty(this.Qty);
        parameters.parmAccountNum(this.custAccount());
        parameters.parmCurrencyCode(this.CurrencyId);

        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceDiscInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>PriceDisc</c> class.
    /// </summary>
    /// <param name = "_parameters">An instance of the <c>PriceDiscParameters</c> class.</param>
    /// <returns>An instance of the <c>PriceDisc</c> class.</returns>
    protected PriceDisc createPriceDiscInstance(PriceDiscParameters _parameters)
    {
        return PriceDisc::newFromPriceDiscParameters(_parameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxGroupId</Name>
				<Source><![CDATA[
    public void setTaxGroupId()
    {
        this.TaxgroupId = ProjParameters::taxGroupInvoice(this.ProjId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxItemGroupId</Name>
				<Source><![CDATA[
    public void setTaxItemGroupId()
    {
        if (this.checkAdjustmentType(ProjAdjustmentType::Item))
        {
            this.TaxItemGroupId     = ProjParameters::taxItemGroupItem(this.CategoryId,this.ItemId);
        }
        else
        {
            this.TaxItemGroupId     = ProjCategory::find(this.CategoryId).TaxItemGroupId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    boolean validateField(FieldId _field)
    {
        boolean ret;
        // <GIN>
        #ISOcountryRegionCodes
        // </GIN>

        ret = super(_field);
        if (ret)
        {
            switch (_field)
            {
                case fieldNum(TmpProjAdjustmentCreate,LinePropertyId):
                    ret = this.checkLineProperty();
                    break;

                case fieldNum(TmpProjAdjustmentCreate, ActivityNumber):
                    ret = this.checkActivity();
                    break;

                case fieldNum(TmpProjAdjustmentCreate, CategoryId):
                    ret = this.checkCategoryAllowed();

                case fieldNum(TmpProjAdjustmentCreate,ProjId):
                    ret = this.checkProjId();
                    break;

                // <GIN>
                case fieldNum(TmpProjAdjustmentCreate, TaxItemGroupId):
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
                    && this.TaxItemGroupId
                        && (this.checkAdjustmentType(ProjAdjustmentType::Hour)
                    || this.checkAdjustmentType(ProjAdjustmentType::Revenue)))
                    {
                        ret = ret && this.checkValidTaxCodes_IN();
                    }
                    break;
                //</GIN>
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;

        ret = super();

        if (this && ret)
        {
            ret = this.checkProjId() && this.checkActivity() && this.checkCategoryAllowed() && this.checkCategoryId();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromAdjustment</Name>
				<Source><![CDATA[
    static void createFromAdjustment(
    TmpProjAdjustment               _tmpProjAdjustment,
    TmpProjAdjustmentCost           _tmpProjAdjustmentCost,
    TmpProjAdjustmentSale           _tmpProjAdjustmentSale,
    TmpProjAdjustmentCreate         _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateCost     _tmpProjAdjustmentCreateCost,
    TmpProjAdjustmentCreateSale     _tmpProjAdjustmentCreateSale,
    AmountCur                       _newTotalCostAmount,
    AmountCur                       _newTotalSaleAmount
)
    {
        real                            percent;
        AmountCur                       oldTotalCostAmount;
        AmountCur                       oldTotalSaleAmount;
        Map                             distributions;
        MapEnumerator                   enumerateMap;

        PSAIndirectCostCalculation      oCalculation;
        PSAIndirectComponentTrans       indirectComponentTrans;
        AmountCur                       amountCurRev,amountCurInvoice;
        oCalculation      = new PSAIndirectCostCalculation();

        oldTotalCostAmount = TmpProjAdjustmentCreate::oldTotalCostAmount(_tmpProjAdjustmentCreate, _tmpProjAdjustment, _tmpProjAdjustmentCost);
        oldTotalSaleAmount = TmpProjAdjustmentCreate::oldTotalSaleAmount(_tmpProjAdjustmentCreate, _tmpProjAdjustment, _tmpProjAdjustmentSale);

        if (oldTotalCostAmount || oldTotalSaleAmount)
        {
            distributions = new Map(Types::Int64, Types::Real);

            if (oldTotalCostAmount)
            {
                while select sum(CostPrice), FundingSource from _tmpProjAdjustmentCost
                group by _tmpProjAdjustmentCost.FundingSource
                where _tmpProjAdjustmentCost.TransId == _tmpProjAdjustment.TransId
                {
                    percent = (_tmpProjAdjustmentCreate.priceQty() * _tmpProjAdjustmentCost.CostPrice) / oldTotalCostAmount;
                    distributions.insert(_tmpProjAdjustmentCost.FundingSource, percent);
                }
            }

            if (distributions.empty())
            {
                _tmpProjAdjustmentCreate.populateDistributions(_tmpProjAdjustmentSale, _tmpProjAdjustment, oldTotalSaleAmount, distributions);
            }

            enumerateMap = distributions.getEnumerator();
            while (enumerateMap.moveNext())
            {
                //Fee does not have cost
                if (_tmpProjAdjustmentCreate.AdjustmentType != ProjAdjustmentType::Revenue)
                {
                    //Cost
                    _tmpProjAdjustmentCreateCost.clear();
                    _tmpProjAdjustmentCreateCost.RefRecId = _tmpProjAdjustmentCreate.RecId;

                    select firstonly _tmpProjAdjustmentCost
                        where _tmpProjAdjustmentCost.TransId == _tmpProjAdjustment.TransId
                            && _tmpProjAdjustmentCost.FundingSource == enumerateMap.currentKey();
                    if (_tmpProjAdjustmentCost)
                    {
                        _tmpProjAdjustmentCreateCost.CostRefRecId = _tmpProjAdjustmentCost.CostRefRecId;
                    }

                    _tmpProjAdjustmentCreateCost.FundingSource = enumerateMap.currentKey();

                    _tmpProjAdjustmentCreateCost.LineAmount = (enumerateMap.currentValue() * _newTotalCostAmount);

                    Qty qty = _tmpProjAdjustmentCreate.priceQty();                    
                    
                    if (_tmpProjAdjustmentCreate.checkUseCostPriceFromOriginalTransactionForHour() || qty == 0)
                    {
                        _tmpProjAdjustmentCreateCost.CostPrice = _tmpProjAdjustmentCost.CostPrice;
                    }
                    else if (qty != 0)
                    {
                        _tmpProjAdjustmentCreateCost.CostPrice = _tmpProjAdjustmentCreateCost.LineAmount / qty;
                    }

                    _tmpProjAdjustmentCreateCost.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_tmpProjAdjustmentCreate.DefaultDimension, ProjFundingSource::find(_tmpProjAdjustmentCreateCost.FundingSource).DefaultDimension);

                    indirectComponentTrans = PSAIndirectComponentTrans::findByTransId(_tmpProjAdjustmentCreate.TransID, PSAIndirectComponentType::Cost);
                    _tmpProjAdjustmentCreateCost.PSAIndirectCost = oCalculation.calculate(_tmpProjAdjustmentCreateCost.CostPrice,
                                                                                          indirectComponentTrans.IndirectComponentGroup,
                                                                                          PSAIndirectComponentType::Cost,
                                                                                          indirectComponentTrans.IndirectComponentId,
                                                                                          _tmpProjAdjustmentCreate.Transdate, // Add transaction date as a parameter to the search.
                                                                                          indirectComponentTrans.RecId, // Add record ID as a parameter for logging.
                                                                                          _tmpProjAdjustmentCreate.priceQty());

                    _tmpProjAdjustmentCreateCost.insert();
                }

                select firstonly _tmpProjAdjustmentSale
                    where _tmpProjAdjustmentSale.TransId == _tmpProjAdjustment.TransId
                    && _tmpProjAdjustmentSale.FundingSource == enumerateMap.currentKey();

                if (_tmpProjAdjustmentSale)
                {
                    //Sale
                    // Actual initializing happening here.
                    _tmpProjAdjustmentCreate.initTmpProjAdjustmentCreateSaleFromMap(_tmpProjAdjustmentSale, _newTotalSaleAmount, enumerateMap, _tmpProjAdjustmentCreateSale);

                    if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                    {
                        indirectComponentTrans = PSAIndirectComponentTrans::findByTransId(_tmpProjAdjustmentCreate.TransID, PSAIndirectComponentType::Revenue);
                        amountCurRev    = oCalculation.calculate(_tmpProjAdjustmentCreateSale.SalesPrice,
                                                      indirectComponentTrans.IndirectComponentGroup,
                                                      PSAIndirectComponentType::Revenue,
                                                      indirectComponentTrans.IndirectComponentId,
                                                      _tmpProjAdjustmentCreate.Transdate, //  Add trans date as a parameter to the search
                                                      indirectComponentTrans.RecId, //  Add RecId as a parameter for logging
                                                      _tmpProjAdjustmentCreate.priceQty());

                        indirectComponentTrans = PSAIndirectComponentTrans::findByTransId(_tmpProjAdjustmentCreate.TransID, PSAIndirectComponentType::Invoice);
                        amountCurInvoice    = oCalculation.calculate(_tmpProjAdjustmentCreateSale.SalesPrice,
                                                      indirectComponentTrans.IndirectComponentGroup,
                                                      PSAIndirectComponentType::Invoice,
                                                      indirectComponentTrans.IndirectComponentId,
                                                      _tmpProjAdjustmentCreate.Transdate, //  Add trans date as a parameter to the search
                                                      indirectComponentTrans.RecId, //  Add RecId as a parameter for logging
                                                      _tmpProjAdjustmentCreate.priceQty());

                        _tmpProjAdjustmentCreateSale.psaIndirectInvoice = amountCurInvoice;
                        _tmpProjAdjustmentCreateSale.psaIndirectRevenue = amountCurRev;
                    }

                    _tmpProjAdjustmentCreateSale.insert();

                    if (ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
					{
						// The insert method will handle if the tranasction is billable and the funding source allows
						// for billing.
                        ProjTrans projTrans = new ProjTransTmpProjAdjustmentCreate(_tmpProjAdjustmentCreate);
						ProjFundingLimitTrackingManager::insertFundingLimitsTrackingByProjTran(
							projTrans,
                            _tmpProjAdjustmentCreateSale.FundingSource,
                            _tmpProjAdjustmentCreateSale.LineAmount + _tmpProjAdjustmentCreateSale.PSAIndirectRevenue,
                            _tmpProjAdjustmentCreate.TmpTransId);
					}
                }
            }
        }
        else
        {
			TmpProjAdjustmentCreate::createFromAllocation(
                                    _tmpProjAdjustmentCreate,
                                    _tmpProjAdjustmentCreateCost,
                                    _tmpProjAdjustmentCreateSale,
                                    _newTotalCostAmount,
                                    _newTotalSaleAmount,
                                    _tmpProjAdjustmentCost,
                                    _tmpProjAdjustmentSale);

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDiscPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Discount percentage to be used for amount calculation.
    /// </summary>
    /// <param name = "_discPercent">The discount percentage value.</param>
    /// <returns>The discount percentage value.</returns>
    protected DiscPct parmDiscPercent(DiscPct _discPercent)
    {
        return _discPercent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpProjAdjustmentCreateSaleFromMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes project adjustment to create from map.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentSale">A <c>TmpProjAdjustmentSale</c> table buffer.</param>
    /// <param name = "_newTotalSaleAmount">The new total sale amount value.</param>
    /// <param name = "_enumerateMap">The map enumerator.</param>
    /// <param name = "_tmpProjAdjustmentCreateSale">The <c>TmpProjAdjustmentCreateSale</c> table buffer.</param>
    protected void initTmpProjAdjustmentCreateSaleFromMap(TmpProjAdjustmentSale _tmpProjAdjustmentSale, 
        AmountCur _newTotalSaleAmount, 
        MapEnumerator _enumerateMap, 
        TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale
    )
    {
        ProjQtyCost qty = this.priceQty();
        _tmpProjAdjustmentCreateSale.RefRecId   = this.RecId;
        _tmpProjAdjustmentCreateSale.SaleRefRecId   = _tmpProjAdjustmentSale.SaleRefRecId;
        _tmpProjAdjustmentCreateSale.FundingSource  = _enumerateMap.currentKey();

        if ((this.FromSplitForm == NoYes::Yes && _tmpProjAdjustmentSale && this.checkUseSalesPriceFromOriginalTransactionForHour(this.TotalCostAmountCur, _tmpProjAdjustmentSale.SalesPrice))
            || (qty == 0))
        {
            _tmpProjAdjustmentCreateSale.SalesPrice = _tmpProjAdjustmentSale.SalesPrice;
            _tmpProjAdjustmentCreateSale.LineAmount = _enumerateMap.currentValue() * _newTotalSaleAmount;
        }
        else if (qty != 0)
        {
            _tmpProjAdjustmentCreateSale.SalesPrice = (_enumerateMap.currentValue() * _newTotalSaleAmount) / qty;
            _tmpProjAdjustmentCreateSale.LineAmount = PriceDisc::price2Amount(_tmpProjAdjustmentCreateSale.SalesPrice,
                                                            InventTable::find(this.ItemId).salesPriceUnit(),
                                                            0,this.Qty,0,0,this.parmDiscPercent(0),this.CurrencyId,0,false);
        }

        if (!ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
        {
			ProjFundingEngine::updateFundingLimits(new ProjTransTmpProjAdjustmentCreate(this),
										_tmpProjAdjustmentCreateSale.FundingSource,
										(this.Qty * _tmpProjAdjustmentCreateSale.SalesPrice),
										true,
										true);
        }
        _tmpProjAdjustmentCreateSale.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(this.DefaultDimension, ProjFundingSource::find(_tmpProjAdjustmentCreateSale.FundingSource).DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert record to <c>distributions</c> map.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentSale">A <c>tmpProjAdjustmentSale</c> table buffer.</param>
    /// <param name = "_tmpProjAdjustment">A <c>tmpProjAdjustment</c> table buffer.</param>
    /// <param name = "_oldTotalSaleAmount">The old total sale amount value.</param>
    /// <param name = "_distributions">The distributions map to populate.</param>
    protected void populateDistributions(tmpProjAdjustmentSale _tmpProjAdjustmentSale, tmpProjAdjustment _tmpProjAdjustment, AmountCur _oldTotalSaleAmount, Map distributions)
    {
        if (_oldTotalSaleAmount)
        {
            while select _tmpProjAdjustmentSale
                    where _tmpProjAdjustmentSale.TransId == _tmpProjAdjustment.TransId
            {
                real percent = (this.priceQty() * _tmpProjAdjustmentSale.SalesPrice) / _oldTotalSaleAmount;
                distributions.insert(_tmpProjAdjustmentSale.FundingSource, percent);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUpdatedSalesprice</Name>
				<Source><![CDATA[
    private AmountCur getUpdatedSalesprice(AmountCur _costAmount)
    {
        TmpProjAdjustmentCreateSalesPriceParameters tmpProjAdjustmentCreateSalesPriceParameters = TmpProjAdjustmentCreateSalesPriceParameters::construct();
        tmpProjAdjustmentCreateSalesPriceParameters.initializeParameters(
                    this,
                    _costAmount,
                     0,
                     ProjSalesPriceMarkup::Yes);

        return TmpProjAdjustmentCreate::retrieveSalesPrice(tmpProjAdjustmentCreateSalesPriceParameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUpdatedSalespriceMarkUp</Name>
				<Source><![CDATA[
    private AmountCur getUpdatedSalespriceMarkUp(AmountCur _costAmount)
    {
        TmpProjAdjustmentCreateSalesPriceParameters tmpProjAdjustmentCreateSalesPriceParameters = TmpProjAdjustmentCreateSalesPriceParameters::construct();
        tmpProjAdjustmentCreateSalesPriceParameters.initializeParameters(
                    this,
                    _costAmount,
                     0,
                     ProjSalesPriceMarkup::MarkupPct);

        return TmpProjAdjustmentCreate::retrieveSalesPrice(tmpProjAdjustmentCreateSalesPriceParameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUseSalesPriceFromOriginalTransactionForHour</Name>
				<Source><![CDATA[
    protected boolean checkUseSalesPriceFromOriginalTransactionForHour(AmountCur _costAmount,
        AmountCur _salesPriceOriginal)
    {
        if (this.AdjustmentType == ProjAdjustmentType::Hour)
        {
            if (this.SalesPriceMarkup == ProjSalesPriceMarkup::Yes)
            {
                return _salesPriceOriginal == this.getUpdatedSalesprice(_costAmount);
            }
            else if (this.SalesPriceMarkup == ProjSalesPriceMarkup::MarkupPct)
            {
                return _salesPriceOriginal == this.getUpdatedSalespriceMarkUp(_costAmount);
            }
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkHourTransactionFromSplitForm</Name>
				<Source><![CDATA[
    private boolean checkHourTransactionFromSplitForm()
    {
        return this.FromSplitForm && this.AdjustmentType == ProjAdjustmentType::Hour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUseCostPriceFromOriginalTransactionForHour</Name>
				<Source><![CDATA[
    protected boolean checkUseCostPriceFromOriginalTransactionForHour()
    {
        return this.checkHourTransactionFromSplitForm() && this.UpdateHourCost == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fundingSourceMapping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the funding rule allocation percentage of the original transaction and compares it to the funding rule allocation percentage
    /// of the new transaction. If the funding rule allocation percentage has not changed after the transaction is posted, return a map of funding sources
    /// of new transaction to funding sources of original transaction
    /// </summary>
    /// <param name = "_newFundingSourceAlloc">funding rule allocation percentage of new transaction</param>
    /// <param name = "_origCostDistribution">cost distribution of original transaction</param>
    /// <param name = "_origTotalCost">total cost of original transaction</param>
    /// <returns>A map of funding source recIDs of new transaction to funding source recIDs of original transaction</returns>
    protected Map fundingSourceMapping(List _newFundingSourceAlloc, Map _origCostDistribution, AmountCur _origTotalCost)
    {
        Map fundingsourceMap = new Map(Types::Int64, Types::Int64); //Maps funding source of original transaction to new transaction if funding rule allocation percentage is the same
        
        //If number of funding sources are different return empty map
        if (_newFundingSourceAlloc.elements() == _origCostDistribution.elements() && _origTotalCost != 0)
        {
            AmountCur costAmountOrig;
            Percent allocPercentOrig;
            boolean fundingSourceMatch = true;
            ListEnumerator listEnumerator = _newFundingSourceAlloc.getEnumerator();
            while (listEnumerator.moveNext())
            {
                ProjSplitAllocation projSplitAlloc = listEnumerator.current();
                RefRecId fundingSourceId = projSplitAlloc.parmFundingSourceRefRecId();
                Percent allocPercent = projSplitAlloc.parmPercent();
                //Check if the original and new transaction have the same funding source
                //If yes, compare the allocation percentage and insert the funding sources in the map
                if (fundingSourceMatch && _origCostDistribution.exists(fundingSourceId))
                {
                    costAmountOrig = _origCostDistribution.lookup(fundingSourceId);
                    allocPercentOrig = costAmountOrig / _origTotalCost * 100;
                    fundingsourceMap.insert(fundingSourceId, fundingSourceId);
                    if (allocPercent != allocPercentOrig)
                    {
                        fundingsourceMap = new Map(Types::Int64, Types::Int64);
                        break;
                    }
                }
                else
                {
                    //Funding sources are different
                    //Iterate through the cost distributions of the original transaction, calculate allocation percentage
                    //and check if one of the calculated allocation percentage matched the allocation percentage of the new transaction
                    //If a match is found insert the funding source of the new transaction and the original transaction in the map
                    //and delete the entry from the cost distributions of the original transaction
                    fundingSourceMatch = false;
                    MapEnumerator enumerateMap = new MapEnumerator(_origCostDistribution);
                    RefRecId recToRemove;
                    while (enumerateMap.moveNext())
                    {
                        costAmountOrig = enumerateMap.currentValue();
                        allocPercentOrig = costAmountOrig / _origTotalCost * 100;
                        if (allocPercent == allocPercentOrig)
                        {
                            fundingsourceMap.insert(fundingSourceId, enumerateMap.currentKey());
                            recToRemove = enumerateMap.currentKey();
                            break;
                        }
                    }
                    if (recToRemove)
                    {
                        _origCostDistribution.remove(recToRemove);
                    }
                    else
                    {
                        fundingsourceMap = new Map(Types::Int64, Types::Int64);
                        break;
                    }
                }
            }
        }
        
        return fundingsourceMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromAllocation</Name>
				<Source><![CDATA[
    static void createFromAllocation(
    TmpProjAdjustmentCreate         _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateCost     _tmpProjAdjustmentCreateCost,
    TmpProjAdjustmentCreateSale     _tmpProjAdjustmentCreateSale,
    AmountCur                       _totalCostAmount,
    AmountCur                       _totalSaleAmount,
    TmpProjAdjustmentCost           _tmpProjAdjustmentCost = null,
    TmpProjAdjustmentSale           _tmpProjAdjustmentSale = null
)
    {
        ProjFundingEngine projFundingEngine;
        Map costDistributions;
        Map saleDistributions;
        Map indirectRevenueDistributions = new Map(Types::Int64, Types::Real);
        Map indirectInvoiceDistributions = new Map(Types::Int64, Types::Real);
        Map indirectCostDistributions = new Map(Types::Int64, Types::Real);
        MapEnumerator enumerateMap;
        PSAIndirectCostCalculation oCalculation;
        PSAIndirectComponentTrans indirectComponentTrans;
        AmountCur amountCurRev, amountCurInvoice, amountCurCost;
        TmpProjAdjustmentSale tmpProjAdjSale;
        TmpProjAdjustmentCost tmpProjAdjCost;
        boolean salesPriceAndLineAmountSet = false;
        boolean hourTransactionFromSplitForm = _tmpProjAdjustmentCreate.checkHourTransactionFromSplitForm();
        boolean fundingAllocationUpdated = false;
        Map fundingSourcesMap = new Map(Types::Int64, Types::Int64);
        Map costDistributionsOrig = new Map(Types::Int64, Types::Real);
        AmountCur totalCostOrig = 0;

        oCalculation      = new PSAIndirectCostCalculation();
        if (!ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
        {
			//  Orignal implementation does not roll back the posting process so the Funding Limits are updated.
			projFundingEngine = ProjFundingEngine::construct(new ProjTransTmpProjAdjustmentCreate(_tmpProjAdjustmentCreate), _totalCostAmount, _totalSaleAmount + _tmpProjAdjustmentCreate.IndirectSales);
        }
		else
        {
			// Pass "False" for posting parameter to allocate as we don't want to update the Funding Limits
            projFundingEngine = ProjFundingEngine::construct(new ProjTransTmpProjAdjustmentCreate(_tmpProjAdjustmentCreate), _totalCostAmount, _totalSaleAmount + _tmpProjAdjustmentCreate.IndirectSales, false);
        }

        if ( projFundingEngine.allocate())
        {
            // Allocation to Funding limits was rolled back, use the tracking of fund limit touched by the Funding Engine
			// and write tracking records to act as committed amounts.
			if (ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
            {
				// Create FundingLimitHistory records from list provided by ProjFundingEngine
                Map fundingLimitUpdates = projFundingEngine.getFundingLimitList();
                enumerateMap = new MapEnumerator(fundingLimitUpdates);
                while (enumerateMap.moveNext())
                {
                    ttsbegin;
                    ProjFundingLimitTracking projFundingLimitTracking;
                    ProjFundingLimitTrackingManager::initalizeProjFundingLimitTracking(projFundingLimitTracking,
                                                                enumerateMap.currentKey(),
                                                                enumerateMap.currentValue(),
																0,
																0,
																0,
																0,
																0,
																NoYes::No,
																NoYes::No,
																NoYes::No,
																_tmpProjAdjustmentCreate.TmpTransId);
                    projFundingLimitTracking.insert();
                    ttscommit;
                }				
            }

            if (hourTransactionFromSplitForm)
            {
                tmpProjAdjCost.linkPhysicalTableInstance(_tmpProjAdjustmentCost);
                while select tmpProjAdjCost where tmpProjAdjCost.TransId == _tmpProjAdjustmentCreate.TransId
                {
                    costDistributionsOrig.insert(tmpProjAdjCost.FundingSource, tmpProjAdjCost.CostPrice);
                    totalCostOrig += tmpProjAdjCost.CostPrice;
                }

                if (totalCostOrig != 0)
                {
                    List fundingSourceAllocation = projFundingEngine.parmfundingSourceAllocation();
                    fundingSourcesMap = _tmpProjAdjustmentCreate.fundingSourceMapping(fundingSourceAllocation, costDistributionsOrig, totalCostOrig);
                    fundingAllocationUpdated = fundingSourcesMap.empty();
                }
            }

            PSAIndirectComponentId indirectComponentId;

            // Get indirect component ID based on indirect component group and adjustment transaction date.
            if (_tmpProjAdjustmentCreate.PSAIndirectComponentGroup)
            {
                indirectComponentId = (select reverse firstonly ComponentId from PSAIndirectCompoundingSetup order by DateFrom
                                           where PSAIndirectCompoundingSetup.ProjComponentGroupId == _tmpProjAdjustmentCreate.PSAIndirectComponentGroup
                                              && PSAIndirectCompoundingSetup.DateFrom <= _tmpProjAdjustmentCreate.Transdate).ComponentId;
            }

            //Fee transactions don't have cost
            if (_tmpProjAdjustmentCreate.AdjustmentType != ProjAdjustmentType::Revenue)
            {
                costDistributions = projFundingEngine.parmCostDistributions();
                enumerateMap = new MapEnumerator(costDistributions);
                while (enumerateMap.moveNext())
                {
                    _tmpProjAdjustmentCreateCost.clear();
                    _tmpProjAdjustmentCreateCost.RefRecId       = _tmpProjAdjustmentCreate.RecId;
                    tmpProjAdjCost.linkPhysicalTableInstance(_tmpProjAdjustmentCost);
                    
                    select firstonly CostRefRecId from tmpProjAdjCost
                            where tmpProjAdjCost.TransId == _tmpProjAdjustmentCreate.TransID
                            && tmpProjAdjCost.FundingSource == enumerateMap.currentKey();
                    if (tmpProjAdjCost.CostRefRecId)
                    {
                        _tmpProjAdjustmentCreateCost.CostRefRecId = tmpProjAdjCost.CostRefRecId;
                    }
                    else
                    {
                        _tmpProjAdjustmentCreateCost.CostRefRecId = _tmpProjAdjustmentCost.CostRefRecId;
                    }
                    
                    _tmpProjAdjustmentCreateCost.FundingSource  = enumerateMap.currentKey();
                    _tmpProjAdjustmentCreateCost.LineAmount     = enumerateMap.currentValue();
                    _tmpProjAdjustmentCreateCost.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_tmpProjAdjustmentCreate.DefaultDimension, ProjFundingSource::find(_tmpProjAdjustmentCreateCost.FundingSource).DefaultDimension);
                    
                    Qty qty = _tmpProjAdjustmentCreate.priceQty();
                    if (!fundingAllocationUpdated && _tmpProjAdjustmentCreate.checkUseCostPriceFromOriginalTransactionForHour())
                    {
                        tmpProjAdjCost.linkPhysicalTableInstance(_tmpProjAdjustmentCost);
                        if (fundingSourcesMap.exists(enumerateMap.currentKey()))
                        {
                            select firstonly CostPrice from tmpProjAdjCost
                                where tmpProjAdjCost.TransId == _tmpProjAdjustmentCreate.TransID
                                && tmpProjAdjCost.FundingSource == fundingSourcesMap.lookup(enumerateMap.currentKey());
                        }
                        else
                        {
                            select firstonly CostPrice from tmpProjAdjCost
                                where tmpProjAdjCost.TransId == _tmpProjAdjustmentCreate.TransID;
                        }
                        
                        _tmpProjAdjustmentCreateCost.CostPrice = tmpProjAdjCost.CostPrice;
                    }
                    else
                    {
                        _tmpProjAdjustmentCreateCost.CostPrice = _tmpProjAdjustmentCreateCost.LineAmount / (qty ? qty : 1);
                    }

                    indirectComponentTrans = PSAIndirectComponentTrans::findByTransId(_tmpProjAdjustmentCreate.TransID, PSAIndirectComponentType::Cost);
                    amountCurCost = oCalculation.calculate(enumerateMap.currentValue() / (_tmpProjAdjustmentCreate.priceQty() ? _tmpProjAdjustmentCreate.priceQty() : 1),
                                                           _tmpProjAdjustmentCreate.PSAIndirectComponentGroup,
                                                           PSAIndirectComponentType::Cost,
                                                           indirectComponentId ? indirectComponentId : indirectComponentTrans.IndirectComponentId,
                                                           _tmpProjAdjustmentCreate.Transdate, // Add transaction date as a parameter to the search.
                                                           indirectComponentTrans.RecId, // Add record ID as a parameter for logging.
                                                           _tmpProjAdjustmentCreate.priceQty());       

                    if (amountCurCost != 0)
                    {
                        if (!indirectCostDistributions.empty())
                        {
                            if (indirectCostDistributions.exists(_tmpProjAdjustmentCreateCost.FundingSource))
                            {
                                _tmpProjAdjustmentCreateCost.PSAIndirectCost = indirectCostDistributions.lookup(_tmpProjAdjustmentCreateCost.FundingSource);
                            }
                        }
                        else
                        {
                            indirectCostDistributions = ProjFundingEngine::ledgerDistributions(projFundingEngine.parmfundingSourceAllocation(), amountCurCost, _tmpProjAdjustmentCreate.CurrencyId);
                            _tmpProjAdjustmentCreateCost.PSAIndirectCost = indirectCostDistributions.lookup(_tmpProjAdjustmentCreateCost.FundingSource);
                        }
                    }
                   
                    _tmpProjAdjustmentCreateCost.insert();
                }
            }

            saleDistributions = projFundingEngine.parmSaleDistributions();
            enumerateMap = new MapEnumerator(saleDistributions);
            while (enumerateMap.moveNext())
            {
                
                _tmpProjAdjustmentCreateSale.clear();
                _tmpProjAdjustmentCreateSale.RefRecId       = _tmpProjAdjustmentCreate.RecId;

                tmpProjAdjSale.linkPhysicalTableInstance(_tmpProjAdjustmentSale);

                select firstonly SaleRefRecId from tmpProjAdjSale
                    where tmpProjAdjSale.TransId == _tmpProjAdjustmentCreate.TransID
                       && tmpProjAdjSale.FundingSource == enumerateMap.currentKey();
                if (tmpProjAdjSale.SaleRefRecId)
                {
                    _tmpProjAdjustmentCreateSale.SaleRefRecId = tmpProjAdjSale.SaleRefRecId;
                }
                else
                {
                    _tmpProjAdjustmentCreateSale.SaleRefRecId = _tmpProjAdjustmentSale.SaleRefRecId;
                }

                _tmpProjAdjustmentCreateSale.FundingSource  = enumerateMap.currentKey();

                indirectComponentTrans = PSAIndirectComponentTrans::findByTransId(_tmpProjAdjustmentCreate.TransID, PSAIndirectComponentType::Revenue);
                // Indirect revenue should calculate for sales price given.
                amountCurRev    = oCalculation.calculate(_totalSaleAmount / (_tmpProjAdjustmentCreate.priceQty() ? _tmpProjAdjustmentCreate.priceQty() : 1),
                                                    _tmpProjAdjustmentCreate.PSAIndirectComponentGroup,
                                                    PSAIndirectComponentType::Revenue,
                                                    indirectComponentId ? indirectComponentId : indirectComponentTrans.IndirectComponentId,
                                                    _tmpProjAdjustmentCreate.Transdate, //  Add trans date as a parameter to the search
                                                    indirectComponentTrans.RecId, //  Add RecId as a parameter for logging
                                                    _tmpProjAdjustmentCreate.priceQty());

                indirectComponentTrans = PSAIndirectComponentTrans::findByTransId(_tmpProjAdjustmentCreate.TransID, PSAIndirectComponentType::Invoice);
                // Indirect revenue should calculate for sales price given.
                amountCurInvoice    = oCalculation.calculate(_totalSaleAmount / (_tmpProjAdjustmentCreate.priceQty() ? _tmpProjAdjustmentCreate.priceQty() : 1),
                                                    _tmpProjAdjustmentCreate.PSAIndirectComponentGroup,
                                                    PSAIndirectComponentType::Invoice,
                                                    indirectComponentId ? indirectComponentId : indirectComponentTrans.IndirectComponentId,
                                                    _tmpProjAdjustmentCreate.Transdate, //  Add trans date as a parameter to the search
                                                    indirectComponentTrans.RecId, //  Add RecId as a parameter for logging
                                                    _tmpProjAdjustmentCreate.priceQty());

                if(amountCurRev != 0)
                {
                    if(!indirectRevenueDistributions.empty())
                    {
                        if(indirectRevenueDistributions.exists(_tmpProjAdjustmentCreateSale.FundingSource))
                        {
                            _tmpProjAdjustmentCreateSale.PSAIndirectRevenue = indirectRevenueDistributions.lookup(_tmpProjAdjustmentCreateSale.FundingSource);
                        }
                    }
                    else
                    {
                        indirectRevenueDistributions = ProjFundingEngine::ledgerDistributions(projFundingEngine.parmfundingSourceAllocation(),amountCurRev, _tmpProjAdjustmentCreate.CurrencyId);
                        _tmpProjAdjustmentCreateSale.PSAIndirectRevenue = indirectRevenueDistributions.lookup(_tmpProjAdjustmentCreateSale.FundingSource);
                    }
                }

                if(amountCurInvoice != 0)
                {
                    if(!indirectInvoiceDistributions.empty())
                    {
                        if(indirectInvoiceDistributions.exists(_tmpProjAdjustmentCreateSale.FundingSource))
                        {
                            _tmpProjAdjustmentCreateSale.PSAIndirectInvoice = indirectInvoiceDistributions.lookup(_tmpProjAdjustmentCreateSale.FundingSource);
                        }
                    }
                    else
                    {
                        indirectInvoiceDistributions = ProjFundingEngine::ledgerDistributions(projFundingEngine.parmfundingSourceAllocation(),amountCurInvoice, _tmpProjAdjustmentCreate.CurrencyId);
                        _tmpProjAdjustmentCreateSale.PSAIndirectInvoice = indirectInvoiceDistributions.lookup(_tmpProjAdjustmentCreateSale.FundingSource);
                    }
                }

                if (hourTransactionFromSplitForm && !fundingAllocationUpdated)
                {
                    tmpProjAdjSale.linkPhysicalTableInstance(_tmpProjAdjustmentSale);

                    if (fundingSourcesMap.exists(enumerateMap.currentKey()))
                    {
                    select firstonly SalesPrice from tmpProjAdjSale
                        where tmpProjAdjSale.TransId == _tmpProjAdjustmentCreate.TransID
                            && tmpProjAdjSale.FundingSource == fundingSourcesMap.lookup(enumerateMap.currentKey());
                    }
                    else
                    {
                        select firstonly SalesPrice from tmpProjAdjSale
                            where tmpProjAdjSale.TransId == _tmpProjAdjustmentCreate.TransID;
                    }
                    if (tmpProjAdjSale && _tmpProjAdjustmentCreate.checkUseSalesPriceFromOriginalTransactionForHour(_tmpProjAdjustmentCreateCost.LineAmount, tmpProjAdjSale.SalesPrice))
                    {
                        _tmpProjAdjustmentCreateSale.SalesPrice = tmpProjAdjSale.SalesPrice;
                        _tmpProjAdjustmentCreateSale.LineAmount = enumerateMap.currentValue() - _tmpProjAdjustmentCreateSale.PSAIndirectRevenue;
                        salesPriceAndLineAmountSet = true;
                    }
                }

                if (!salesPriceAndLineAmountSet)
                {
                    ProjSalesPriceCost calculatedSalesPrice;

                    if (_tmpProjAdjustmentCreate.SalesPriceMarkup != ProjSalesPriceMarkup::No)
                    {
                        calculatedSalesPrice = CurrencyExchangeHelper::amount(enumerateMap.currentValue(), _tmpProjAdjustmentCreate.CurrencyId);
                    }
                    else
                    {
                        calculatedSalesPrice = enumerateMap.currentValue();
                    }

                    // If there is an indirect component, we need to subtract it from lineamount to deduce the sales price.
                    _tmpProjAdjustmentCreateSale.SalesPrice = (calculatedSalesPrice - _tmpProjAdjustmentCreateSale.PSAIndirectRevenue) / (_tmpProjAdjustmentCreate.priceQty() ? _tmpProjAdjustmentCreate.priceQty() : 1);
                    _tmpProjAdjustmentCreateSale.LineAmount = PriceDisc::price2Amount(_tmpProjAdjustmentCreateSale.SalesPrice,
                                                                    InventTable::find(_tmpProjAdjustmentCreate.ItemId).salesPriceUnit(),
                                                                    0,_tmpProjAdjustmentCreate.Qty,0,0,0,_tmpProjAdjustmentCreate.CurrencyId,0,false);
                }
                _tmpProjAdjustmentCreateSale.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_tmpProjAdjustmentCreate.DefaultDimension, ProjFundingSource::find(_tmpProjAdjustmentCreateSale.FundingSource).DefaultDimension);

                _tmpProjAdjustmentCreateSale.insert();
            }
        }
        else
        {
            throw Global::error("@SYS136009");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTrxAmounts</Name>
				<Source><![CDATA[
    static void createTrxAmounts(
    TmpProjAdjustment               _tmpProjAdjustment,
    TmpProjAdjustmentCost           _tmpProjAdjustmentCost,
    TmpProjAdjustmentSale           _tmpProjAdjustmentSale,
    TmpProjAdjustmentCreate         _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateCost     _tmpProjAdjustmentCreateCost,
    TmpProjAdjustmentCreateSale     _tmpProjAdjustmentCreateSale,
    AmountCur                       _totalCostAmount,
    AmountCur                       _totalSaleAmount
)
    {
        boolean                         mustUpdateFundingSource;

        mustUpdateFundingSource = TmpProjAdjustmentCreate::mustUpdateFundingSource(_tmpProjAdjustment, _tmpProjAdjustmentSale, _tmpProjAdjustmentCreate);
        if (mustUpdateFundingSource)
        {
			TmpProjAdjustmentCreate::createFromAllocation(
                                    _tmpProjAdjustmentCreate,
                                    _tmpProjAdjustmentCreateCost,
                                    _tmpProjAdjustmentCreateSale,
                                    _totalCostAmount,
                                    _totalSaleAmount,
                                    _tmpProjAdjustmentCost,
                                    _tmpProjAdjustmentSale);
        }
        else
        {
			TmpProjAdjustmentCreate::createFromAdjustment(
				_tmpProjAdjustment,
				_tmpProjAdjustmentCost,
				_tmpProjAdjustmentSale,
				_tmpProjAdjustmentCreate,
				_tmpProjAdjustmentCreateCost,
				_tmpProjAdjustmentCreateSale,
				_totalCostAmount,
				_totalSaleAmount
				);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCreateAdjustment</Name>
				<Source><![CDATA[
    static void deleteCreateAdjustment(
    TmpProjAdjustment               _tmpProjAdjustment,
    TmpProjAdjustmentCost           _tmpProjAdjustmentCost,
    TmpProjAdjustmentSale           _tmpProjAdjustmentSale,
    TmpProjAdjustmentCreate         _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateCost     _tmpProjAdjustmentCreateCost,
    TmpProjAdjustmentCreateSale     _tmpProjAdjustmentCreateSale
)
    {
        boolean updateFundingLimits;

        updateFundingLimits = false;

        while select forupdate _tmpProjAdjustmentCreate
        where _tmpProjAdjustmentCreate.TransID == _tmpProjAdjustment.TransId
        {
            if (!_tmpProjAdjustmentCreate.AdjustOrig)
            {
                updateFundingLimits = true;
            }
            TmpProjAdjustmentCreate::deleteCreateAdjustmentAmount(_tmpProjAdjustmentCreate, _tmpProjAdjustmentCreateCost, _tmpProjAdjustmentCreateSale);
            _tmpProjAdjustmentCreate.delete();
        }

        if (updateFundingLimits)
        {
			if (!ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
            {
                TmpProjAdjustment::updateFundingLimits(_tmpProjAdjustment, _tmpProjAdjustmentSale, true);
			}
			else
			{
				ProjFundingLimitTrackingManager::deleteFundingLimitTrackingByTransId(_tmpProjAdjustment.TransId);
			}
		}
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCreateAdjustmentAmount</Name>
				<Source><![CDATA[
    static void deleteCreateAdjustmentAmount(
    TmpProjAdjustmentCreate         _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateCost     _tmpProjAdjustmentCreateCost,
    TmpProjAdjustmentCreateSale     _tmpProjAdjustmentCreateSale
)
    {
        delete_from _tmpProjAdjustmentCreateCost
        where _tmpProjAdjustmentCreateCost.RefRecId == _tmpProjAdjustmentCreate.RecId;

        if (!ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
        {
			while select forupdate _tmpProjAdjustmentCreateSale
				where _tmpProjAdjustmentCreateSale.RefRecId == _tmpProjAdjustmentCreate.RecId
			{
				if (!_tmpProjAdjustmentCreate.AdjustOrig)
				{
					ProjFundingEngine::updateFundingLimits(new ProjTransTmpProjAdjustmentCreate(_tmpProjAdjustmentCreate),
										_tmpProjAdjustmentCreateSale.FundingSource,
										-(_tmpProjAdjustmentCreate.Qty * _tmpProjAdjustmentCreateSale.SalesPrice));
				}           
                _tmpProjAdjustmentCreateSale.delete();;
			}
        }
		else
        {
            ProjFundingLimitTrackingManager::deleteFundingLimitTrackingByTransId(_tmpProjAdjustmentCreate.TmpTransId);
            delete_from _tmpProjAdjustmentCreateSale 
                where _tmpProjAdjustmentCreateSale.RefRecId == _tmpProjAdjustmentCreate.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateFundingSource</Name>
				<Source><![CDATA[
    public static boolean mustUpdateFundingSource(
        TmpProjAdjustment          tmpProjAdjustment,
        TmpProjAdjustmentSale      tmpProjAdjustmentSale,
        TmpProjAdjustmentCreate    tmpProjAdjustmentCreate
    )
    {
        boolean ret = false;
        
        // Check for Funding Source selected
        if (tmpProjAdjustmentCreate.FundingSource == NoYes::Yes)
        {
            ret = true;
        }

        // Check for Project Date changed - Rules/Limit might apply
        if (!ret && tmpProjAdjustment.TransDate != tmpProjAdjustmentCreate.Transdate)
        {
            ret = true;
        }

        // Check for project changed - Rules/Limit might apply
        if (!ret && tmpProjAdjustment.ProjId != tmpProjAdjustmentCreate.ProjId)
        {
            ret = true;
        }

        // Check for Caterory changed - Rules/Limit might apply
        if (!ret && tmpProjAdjustment.CategoryId != tmpProjAdjustmentCreate.CategoryId)
        {
            ret = true;
        }

        // Check for Activity changed - Rules/Limit might apply
        if (!ret && tmpProjAdjustment.ActivityNumber != tmpProjAdjustmentCreate.ActivityNumber)
        {
            ret = true;
        }

        // Check for Total Sales Amount changed - Rules/Limit might apply
        if (!ret && tmpProjAdjustment.TotalSalesAmountCur != tmpProjAdjustmentCreate.TotalSalesAmountCur)
        {
            ret = true;
        }

        // If Split by percentage, quantity would change
        if (!ret && tmpProjAdjustment.Qty != tmpProjAdjustmentCreate.Qty)
        {
            ret = true;
        }

        // Check for On-Hold funding source during original posting.
        if (!ret)
        {
            ProjFundingSource projFundingSource;
            ProjInvoiceTable originalContract = ProjInvoiceTable::find(ProjTable::find(tmpProjAdjustment.ProjId).ProjInvoiceProjId);

            // Does On-Hold funding source exist for contract
            select firstonly RecId from projFundingSource
                where projFundingSource.ContractId == originalContract.ProjInvoiceProjId &&
                      projFundingSource.FundingType == ProjFundingType::OnHoldFundingSource;
            if (projFundingSource)
            {
                // If On-Hold account used - Always update funding sources for adjustments.
                select count(RecId) from tmpProjAdjustmentSale
                    where tmpProjAdjustmentSale.FundingSource == projFundingSource.RecId;
                if (tmpProjAdjustmentSale.RecId != 0)
                {
                    ret = true;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>oldTotalCostAmount</Name>
				<Source><![CDATA[
    static AmountCur oldTotalCostAmount(
    TmpProjAdjustmentCreate _tmpProjAdjustmentCreate,
    TmpProjAdjustment       _tmpProjAdjustment,
    TmpProjAdjustmentCost   _tmpProjAdjustmentCost
)
    {
        AmountCur ret;

        while select _tmpProjAdjustmentCost
        where _tmpProjAdjustmentCost.TransId == _tmpProjAdjustment.TransId
        {
            ret += (_tmpProjAdjustmentCreate.priceQty() * _tmpProjAdjustmentCost.CostPrice);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>oldTotalSaleAmount</Name>
				<Source><![CDATA[
    static AmountCur oldTotalSaleAmount(
    TmpProjAdjustmentCreate _tmpProjAdjustmentCreate,
    TmpProjAdjustment       _tmpProjAdjustment,
    TmpProjAdjustmentSale   _tmpProjAdjustmentSale
)
    {
        AmountCur ret;

        while select _tmpProjAdjustmentSale
        where _tmpProjAdjustmentSale.TransId == _tmpProjAdjustment.TransId
        {
            ret += (_tmpProjAdjustmentCreate.priceQty() * _tmpProjAdjustmentSale.SalesPrice);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalCostAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The cost amount for the transaction.
    /// </summary>
    /// <param name = "_tmpProjAdjustment">
    /// _tmpProjAdjustment holds the table buffer.
    /// </param>
    /// <param name = "_percent">
    /// The percent value that needs to calculate cost amount value.
    /// </param>
    /// <returns>
    ///     Returns total cost amount for the transaction.
    /// </returns>
    static AmountCur getTotalCostAmount(TmpProjAdjustment _tmpProjAdjustment, Percent _percent = 100)
    {
        return _tmpProjAdjustment.TotalCostAmountCur * (_percent / 100);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalSalesAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The sales amount for the transaction.
    /// </summary>
    /// <param name = "_tmpProjAdjustment">
    /// _tmpProjAdjustment holds the table buffer.
    /// </param>
    /// <param name = "_percent">
    /// The percent value that needs to calculate sale amount value.
    /// </param>
    /// <returns>
    ///     Returns total sales amount for the transaction.
    /// </returns>
    static AmountCur getTotalSalesAmount(TmpProjAdjustment _tmpProjAdjustment, Percent _percent = 100)
    {
        return _tmpProjAdjustment.TotalSalesAmountCur * (_percent / 100);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveSalesPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// The sales price calculation for the project.
    /// </summary>
    /// <param name="_tmpProjAdjustmentCreateSalesPriceParameters">
    /// The parameter class that has the information for the sales price calculation.
    /// </param>
    /// <returns>
    /// Sales price for the project.
    /// </returns>
    [Replaceable]
    public static SalesPrice retrieveSalesPrice(TmpProjAdjustmentCreateSalesPriceParameters _tmpProjAdjustmentCreateSalesPriceParameters)
    {
        SalesPrice      salesPrice;
        ProjPriceParameters priceParams;

        CostPrice costPrice()
        {
            return CurrencyExchangeHelper::price(_tmpProjAdjustmentCreateSalesPriceParameters.parmTotalCostAmount() / (_tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().priceQty() ? _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().priceQty() : 1));
        }

        SalesPrice revenueSalesPrice()
        {
            return CurrencyExchangeHelper::price(_tmpProjAdjustmentCreateSalesPriceParameters.parmRevenueTotalSaleAmount() / (_tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().priceQty() ? _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().priceQty() :1));
        }

        switch (_tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().AdjustmentType)
        {
            case ProjAdjustmentType::Hour:
                if (TmpProjAdjustmentCreate::checkSalesPriceMarkupForYes(_tmpProjAdjustmentCreateSalesPriceParameters))
                {
                    priceParams = ProjHourSalesPrice::constructPriceParametersForFindHourSalesPrice(
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().ProjId,
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().Resource,
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CategoryId,
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().LinePropertyId,
                        costPrice(),
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CurrencyId,
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().Transdate,
                        '',
                        '',
                        '',
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().ResourceCategory);
                    [salesPrice] = ProjHourSalesPrice::findHourSalesPriceByPriceParameters(priceParams, false);
                }
                else  // ProjSalesPriceMarkup::MarkupPct
                {
                    salesPrice  = ExchangeRateHelper::curPrice(costPrice() * (_tmpProjAdjustmentCreateSalesPriceParameters.parmMarkUpPct() + 100) / 100, _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CurrencyId);
                }
                break;
            case ProjAdjustmentType::Cost:
                if (TmpProjAdjustmentCreate::checkSalesPriceMarkupForYes(_tmpProjAdjustmentCreateSalesPriceParameters))
                {
                    priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().ProjId,
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().Resource,
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CategoryId,
                        costPrice(),
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CurrencyIdCost,
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CurrencyId,
                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().Transdate);
                    [salesPrice] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams);
                }
                else  // ProjSalesPriceMarkup::MarkupPct
                {
                    if (Ledger::find(Ledger::current()).AccountingCurrency != _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CurrencyIdCost)
                    {
                        salesPrice  = ExchangeRateHelper::curPrice(ProjCostTrans::find(_tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().TransID).costPrice() * (_tmpProjAdjustmentCreateSalesPriceParameters.parmMarkUpPct() + 100) / 100,
                                                                                        _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CurrencyId);
                    }
                    else
                    {
                        salesPrice  = ExchangeRateHelper::curPrice(costPrice() * (_tmpProjAdjustmentCreateSalesPriceParameters.parmMarkUpPct() + 100) / 100, _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CurrencyId);
                    }
                }
                break;
            case ProjAdjustmentType::Revenue:
                if (TmpProjAdjustmentCreate::checkSalesPriceMarkupForYes(_tmpProjAdjustmentCreateSalesPriceParameters))
                {
                    if (ProjCategory::find(_tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CategoryId).SetupSubscription)
                    {
                        salesPrice  = SMASalesPriceSubscription::findSalesPrice(_tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().smaSubscriptionId,
                                                                            _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().ProjId,
                                                                            _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CategoryId,
                                                                            _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().Transdate,
                                                                            _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CurrencyId,
                                                                            SMASubscriptionTable::find(_tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().smaSubscriptionId).invoicePeriodCode());
                    }
                    else
                    {
                        [salesPrice] = ProjRevenueSalesPrice::findProjRevenueSalesPrice(_tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().ProjId,
                                                                                   _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().Resource,
                                                                                   _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CategoryId,
                                                                                   _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CurrencyId,
                                                                                   _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().Transdate,
                                                                                   '',
                                                                                   false,
                                                                                   _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().ResourceCategory);
                    }
                }
                else
                {
                    salesPrice  = revenueSalesPrice();
                    if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && TmpProjAdjustmentCreate::checkSalesPriceMarkupForMarkupPct(_tmpProjAdjustmentCreateSalesPriceParameters))
                    {
                        salesPrice = salesPrice*(_tmpProjAdjustmentCreateSalesPriceParameters.parmMarkUpPct() + 100)/ 100 ;
                    }
                }
                break;
            case ProjAdjustmentType::Item:
                if (TmpProjAdjustmentCreate::checkSalesPriceMarkupForYes(_tmpProjAdjustmentCreateSalesPriceParameters))
                {
                    salesPrice  = _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().setPriceAgreement();
                }
                else  // ProjSalesPriceMarkup::MarkupPct
                {
                    salesPrice  = ExchangeRateHelper::curPrice(ProjItemTrans::find(_tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().TransID).costAmountTotal() * (_tmpProjAdjustmentCreateSalesPriceParameters.parmMarkUpPct() + 100) / 100 / _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().Qty, _tmpProjAdjustmentCreateSalesPriceParameters.parmTmpProjAdjustmentCreate().CurrencyId);
                }
                break;
        }

        return salesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSalesPriceMarkupForYes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for sales price markup value.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreateSalesPriceParameters">
    /// An enum value of <c>ProjSalesPricemarkup</c>.
	/// </param>
    /// <returns>
    /// true if sales price markup is yes; otherwise,false.
	/// </returns>
    protected static boolean checkSalesPriceMarkupForYes(TmpProjAdjustmentCreateSalesPriceParameters _tmpProjAdjustmentCreateSalesPriceParameters)
    {
        return _tmpProjAdjustmentCreateSalesPriceParameters.parmSalesPriceMarkup() == ProjSalesPriceMarkup::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSalesPriceMarkupForMarkupPct</Name>
				<Source><![CDATA[
    /// <summary>
    ///	Checks for sales price markup value.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreateSalesPriceParameters">
    /// An enum value of <c>ProjSalesPricemarkup</c>.
	/// </param>
    /// <returns>
    /// true if sales price markup is markup percentage; otherwise,false.
	///</returns>
    protected static boolean checkSalesPriceMarkupForMarkupPct(TmpProjAdjustmentCreateSalesPriceParameters _tmpProjAdjustmentCreateSalesPriceParameters)
    {
        return _tmpProjAdjustmentCreateSalesPriceParameters.parmSalesPriceMarkup() == ProjSalesPriceMarkup::MarkupPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPrice</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsolete. Use TmpProjAdjustmentCreate::retrieveSalesPrice() instead.', true, 30\06\2018)]
    static SalesPrice salesPrice(
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    AmountCur                   _totalCostAmount,
    AmountCur                   _revenueTotalSaleAmount,
    ProjSalesPriceMarkup        _salesPriceMarkup   = ProjSalesPriceMarkup::Yes,
    Percent                     _markUpPct          = 0)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCostAmount</Name>
				<Source><![CDATA[
    static AmountCur totalCostAmount(
        RefRecId _recId,
        TmpProjAdjustmentCreate _tmpProjAdjustmentCreate,
        TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost)
    {
        AmountCur ret;
        TmpProjAdjustmentCreate tmpProjAdjustmentCreateLocal;
        TmpProjAdjustmentCreateCost tmpProjAdjustmentCreateCostLocal;

        tmpProjAdjustmentCreateLocal.linkPhysicalTableInstance(_tmpProjAdjustmentCreate);
        tmpProjAdjustmentCreateCostLocal.linkPhysicalTableInstance(_tmpProjAdjustmentCreateCost);

        select tmpProjAdjustmentCreateLocal
            where tmpProjAdjustmentCreateLocal.RecId == _recId;

        if (_tmpProjAdjustmentCreate)
        {
            while select tmpProjAdjustmentCreateCostLocal
            where tmpProjAdjustmentCreateCostLocal.RefRecId == tmpProjAdjustmentCreateLocal.RecId
            {
                if (ProjAdjustCostUnbalancedPostingFromPurchOrderFlight::instance().isEnabled() && tmpProjAdjustmentCreateLocal.OriginCost == ProjOrigin::PurchaseOrder)
                {
                    ret += CurrencyExchangeHelper::price((tmpProjAdjustmentCreateLocal.priceQty() * tmpProjAdjustmentCreateCostLocal.CostPrice), tmpProjAdjustmentCreateLocal.CurrencyIdCost);
                }
                else
                {
                    ret += (tmpProjAdjustmentCreateLocal.priceQty() * tmpProjAdjustmentCreateCostLocal.CostPrice);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalSaleAmount</Name>
				<Source><![CDATA[
    static AmountCur totalSaleAmount(
    RefRecId                    _recId,
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale
)
    {
        AmountCur                   ret;
        TmpProjAdjustmentCreate     tmpProjAdjustmentCreateLocal;
        TmpProjAdjustmentCreateSale tmpProjAdjustmentCreateSaleLocal;

        tmpProjAdjustmentCreateLocal.linkPhysicalTableInstance(_tmpProjAdjustmentCreate);
        tmpProjAdjustmentCreateSaleLocal.linkPhysicalTableInstance(_tmpProjAdjustmentCreateSale);

        select tmpProjAdjustmentCreateLocal
        where tmpProjAdjustmentCreateLocal.RecId == _recId;

        if (_tmpProjAdjustmentCreate)
        {
            while select tmpProjAdjustmentCreateSaleLocal
            where tmpProjAdjustmentCreateSaleLocal.RefRecId == tmpProjAdjustmentCreateLocal.RecId
            {
                ret += (tmpProjAdjustmentCreateLocal.priceQty() * tmpProjAdjustmentCreateSaleLocal.SalesPrice);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjAdjustmentCreateOriganlTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the orignal project journal transaction for the ProjAdjustmentCreate.
    /// </summary>
    /// <param name="_tmpProjAdjustmentCreate">
    /// The TmpProjAdjustmentCreate table.
    /// </param>
    /// <returns>
    /// Returns orignal project journal transaction for the ProjAdjustmentCreate.
    /// </returns>
    public static Common getProjAdjustmentCreateOriganlTrans(TmpProjAdjustmentCreate _tmpProjAdjustmentCreate)
    {
        Common  projAdjustmentCreateOriganlTrans;

        switch (_tmpProjAdjustmentCreate.AdjustmentType)
        {
            case ProjAdjustmentType::Hour :
                projAdjustmentCreateOriganlTrans = ProjEmplTrans::find(_tmpProjAdjustmentCreate.TransId);
                break;

            case ProjAdjustmentType::Cost:
                projAdjustmentCreateOriganlTrans = ProjCostTrans::find(_tmpProjAdjustmentCreate.TransId);
                break;

            case ProjAdjustmentType::Revenue:
                projAdjustmentCreateOriganlTrans = projRevenueTrans::find(_tmpProjAdjustmentCreate.TransId);
                break;

            case ProjAdjustmentType::Item:
                projAdjustmentCreateOriganlTrans = ProjItemTrans::find(_tmpProjAdjustmentCreate.TransId);
                break;
        }

        return projAdjustmentCreateOriganlTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIndirectCosts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets adjusted indirect costs for a particular transaction on the <c>ProjAdjustment</c> form.
    /// </summary>
    /// <param name="_costPrice">
    /// Unit cost price of the adjusted transaction.
    /// </param>
    public void setIndirectCosts(CostPrice _costPrice)
    {
        AmountCur indirectCost;
        PSAIndirectComponentGroupId groupId = this.PSAIndirectComponentGroup;
        PSAIndirectCompoundingSetup indirectCompoundingSetup ;
        PSAIndirectComponent        indirectComponent;
        TransDate transDate = this.TransDate;

        while select maxof(DateFrom), ComponentId from indirectCompoundingSetup
            exists join indirectComponent
                group by indirectCompoundingSetup.ComponentId
                where indirectCompoundingSetup.ProjComponentGroupId == groupId
                    && indirectCompoundingSetup.DateFrom <= transDate
                    && indirectComponent.ComponentId == indirectCompoundingSetup.ComponentId
        {
            PSAIndirectCostCalculation indirectCostCalculation = new PSAIndirectCostCalculation();
            indirectCost += indirectCostCalculation.calculate(_costPrice,
                                                                    groupId,
                                                                    PSAIndirectComponentType::Cost,
                                                                    indirectCompoundingSetup.ComponentId,
                                                                    transDate,
                                                                    0,
                                                                    this.Qty);
        }
       
        this.IndirectCost = indirectCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIndirectCosts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get indirect costs of a transaction.
    /// </summary>
    /// <returns>
    /// Returns indirect costs of a transaction.
    /// </returns>
    public AmountCur getIndirectCosts()
    {
        return this.IndirectCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNewTotalCostAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets total cost amount which includes indirect costs if any 
    /// </summary>
	public void setNewTotalCostAmount()
    {
        this.NewTotalCostAmount = this.TotalCostAmountCur;
        if(this.IndirectCost)
        {
            this.NewTotalCostAmount += this.IndirectCost;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNewTotalSaleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets total sale amount which includes indirect sales if any
    /// </summary>
    public void setNewTotalSaleAmount()
    {
        this.NewTotalSaleAmount = this.TotalSalesAmountCur;
        if(this.IndirectSales)
        {
            this.NewTotalSaleAmount += this.IndirectSales;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIndirectSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets adjusted indirect sales amount for a particular transaction on the <c>ProjAdjustment</c> form.
    /// </summary>
    /// <param name="_salesPrice">
    /// unit sales price of the adjusted transaction.
    /// </param>
    public void setIndirectSales(SalesPrice _salesPrice)
    {
        AmountCur indirectSales;
        PSAIndirectComponentGroupId groupId = this.PSAIndirectComponentGroup;
        PSAIndirectCompoundingSetup indirectCompoundingSetup ;
        PSAIndirectComponent        indirectComponent;
        TransDate transdate = this.Transdate;

        select reverse firstonly indirectCompoundingSetup
            exists join indirectComponent
            order by indirectCompoundingSetup.DateFrom
            where indirectCompoundingSetup.ProjComponentGroupId == groupId
            && indirectCompoundingSetup.DateFrom <= transDate
            && indirectComponent.ComponentId == indirectCompoundingSetup.ComponentId;
        
        if(indirectCompoundingSetup.RecId != 0)
        {
            PSAIndirectCostCalculation indirectCostCalculation = new PSAIndirectCostCalculation();

            indirectSales = indirectCostCalculation.calculate(_salesPrice,
                                                                groupId,
                                                                PSAIndirectComponentType::Revenue,
                                                                indirectCompoundingSetup.ComponentId,
                                                                transDate,
                                                                0,
                                                                this.Qty);
        }

        this.IndirectSales = indirectSales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIndirectSales</Name>
				<Source><![CDATA[
    public AmountCur getIndirectSales()
    {
        return this.IndirectSales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAdjustmentType</Name>
				<Source><![CDATA[
    public boolean checkAdjustmentType(ProjAdjustmentType _adjustmentType)
    {
        boolean ret = false;
        switch(this.AdjustmentType)
        {
            case _adjustmentType :
                ret = true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the assessable value.
    /// </summary>
    public void update()
    {
        // <GIN>
        if (TaxParameters::checkTaxParameters_IN())
        {
            this.AssessableValue_IN = this.TotalSalesAmountCur;
        }
        // </GIN>

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateNewTemporaryTransId</Name>
				<Source><![CDATA[
	public ProjTransIdBase generateNewTemporaryTransId()
    {
        const int     maxRetries = 1000;
        int           retryCount = 0;
        
		
        Random random = new Random();

        ProjTransIdBase temporaryTransId = ProjConstants::AdjustmentTempIdPrefix + int2Str(random.nextInt());

        ProjFundingLimitTracking projFundingLimitTracking;
        while select firstonly TransId from projFundingLimitTracking where projFundingLimitTracking.TransId == temporaryTransId
		{
			if (retryCount > maxRetries)
			{
				throw error("@Proj:CreateTempAdjustmentTransIdError");
			}

            temporaryTransId = ProjConstants::AdjustmentTempIdPrefix + int2Str(random.nextInt());
			retryCount++;
		}

        return temporaryTransId;
   }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<DeveloperDocumentation>@SYS322130</DeveloperDocumentation>
	<Label>@SYS76162</Label>
	<ClusteredIndex></ClusteredIndex>
	<PrimaryIndex>RecId</PrimaryIndex>
	<TableType>TempDB</TableType>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Currency</Name>
			<Label>@SYS7572</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CurrencyId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Customs_IN</Name>
			<Label>@GLS5007</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustomsTariffCodeTable_IN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimension</Name>
			<Label>@SYS14926</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Transdate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActivityNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LinePropertyId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Item</Name>
			<Label>@SYS7407</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Quantity</Name>
			<Label>@SYS59970</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTax</Name>
			<Label>@SYS67871</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxgroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ServiceTax_IN</Name>
			<Label>@GLS5006</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ServiceCodeTable_IN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Subscription</Name>
			<Label>@SYS14482</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SMAStartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SMAEnddate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SMABasePrice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SMAIndex</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>System</Name>
			<Label>@SYS15320</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AdjustOrig</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AdjustmentType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SMASubscriptionPeriodType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SMASubscriptionId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OriginCost</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SalesUnit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjIdentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemAdjustVersion</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjAdjustRefId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PackingSlipId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtyToBeInvoiced</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>txt</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WithholdingTax_IN</Name>
			<Label>@SYS333997</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TDSGroup_IN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TCSGroup_IN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ActivityNumber</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjActivityNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AdjustCorrection</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>LedgerCorrection</ExtendedDataType>
			<Label>@GLS112551</Label>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AdjustmentType</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>ProjAdjustmentType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AdjustOrig</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjAdjustOrig</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AssessableValue_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@GLS5298</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CategoryId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencyId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjSalesCurrencyCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencyIdCost</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@SYS56483</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CustomsTariffCodeTable_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS5516</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>LedgerDimensionValueSet</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DirectSettlement_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<EnumType>DirectSettlement_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DSA_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<Label>@GLS5341</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ExciseRecordType_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<EnumType>ExciseRecordType_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ExciseTariffCodes_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS5344</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ExciseType_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<EnumType>ExciseType_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTransId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ItemAdjustVersion</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjItemAdjustVersion</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ItemIdSmall</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ItemType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>ProjOrigin</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimension</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ConfigurationKey>LogisticsBasic</ConfigurationKey>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LinePropertyId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjLinePropertyId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>MaximumRetailPrice_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>MaximumRetailPrice_IN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Module</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>ModuleAxapta</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OriginCost</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>ProjOrigin</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PackingSlipId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>PackingSlipId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PostalAddress_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>LogisticsPostalAddressRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjAdjustRefId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjAdjustRefId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjIdentId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjItemId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ProjIdentResource</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ResourceRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSAIndirectComponentGroup</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>PSAIndirectComponentGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSAProjOrigTransId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>PSAProjOrigTransId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSAWrkCtrId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>PSAWrkCtrId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Qty</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjQtyCost</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>QtyToBeInvoiced</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjQtyCost</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Resource</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ResourceRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ResourceCategory</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ResourceCategoryRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ResourceLegalEntity</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>CompanyInfoRecId</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SalesPriceMarkup</Name>
			<EnumType>ProjSalesPriceMarkup</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SalesTaxFormTypes_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>SalesTaxFormTypesRecId_IN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SalesUnit</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>SalesUnit</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ServiceCodeTable_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS5065</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SMABasePrice</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>SMABasePrice</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>SMAEnddate</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>SMAEnddate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SMAIndex</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>SMAIndex</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>SMAStartDate</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>SMAStartDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SMASubscriptionId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>SMASubscriptionId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SMASubscriptionPeriodType</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>SMASubscriptionPeriodType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxgroupId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TaxGroup</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxInformation_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>TaxInformationRefRecId_IN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxInventVATCommodityCodeId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TaxInventVATCommodityCodeId_IN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxItemGroupId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TaxItemGroup</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TCSGroup_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>TaxWithholdGroup</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@gls5363</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TDSGroup_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>TaxWithholdGroup</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@GLS5362</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>IndirectCost</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@Proj:IndirectCosts</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>IndirectSales</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@Proj:IndirectSales</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TotalCostAmountCur</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TotalSalesAmountCur</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>NewTotalCostAmount</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@Proj:TotalCostPrice</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>NewTotalSaleAmount</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@Proj:TotalSalesPrice</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>Transdate</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjTransDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransID</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ProjCostTransId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>txt</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>Description255</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>FundingSource</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjName</Name>
			<AllowEdit>No</AllowEdit>
			<ExtendedDataType>ProjName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>FromSplitForm</Name>
			<Label>@Proj:FromSplitForm</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UpdateHourCost</Name>
			<Label>@Proj:UpdateHourCost</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TmpTransId</Name>
			<ExtendedDataType>ProjTransIdBase</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TransIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>TransID</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>LedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DefaultDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>DefaultDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ResourceIdx1</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjIdentResource</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>DimensionDefaultMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>DefaultDimension</MapField>
					<MapFieldTo>DefaultDimension</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>TransitDocumentTransactionMap_IN</MappingTable>
			<Connections />
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalLine</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
					<MapFieldTo>CurrencyId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryLocation</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryState</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventDimId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventTransId</MapField>
					<MapFieldTo>InventTransId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemId</MapField>
					<MapFieldTo>ItemId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineNum</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchQty</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchUnit</MapField>
					<MapFieldTo>SalesUnit</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>TableId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
					<MapFieldTo>TaxgroupId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxItemGroup</MapField>
					<MapFieldTo>TaxItemGroupId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TransDate</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustomsTariffCodeTable_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustomsTariffCodeTable_IN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustomsTariffCodeTable_IN_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CustomsTariffCodeTable_IN_1_TmpProjAdjustmentCreate</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustomsTariffCodeTable_IN</Name>
					<Field>CustomsTariffCodeTable_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DimensionAttributeValueSet</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DimensionAttributeValueSet_TmpProjAdjustmentCreate</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ExciseTariffCodes_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ExciseTariffCodes_IN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ExciseTariffCodes_IN_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ExciseTariffCodes_IN_1_TmpProjAdjustmentCreate</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ExciseTariffCodes_IN</Name>
					<Field>ExciseTariffCodes_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>IdentWorker</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker_Identity</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>HcmWorker_TmpProjAdjustmentCreate</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AdjustmentType</Name>
					<Field>AdjustmentType</Field>
					<ValueStr>ProjAdjustmentType::Hour</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>IndirectComponentGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PSAIndirectComponentGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PSAIndirectComponentGroup</Name>
					<Field>PSAIndirectComponentGroup</Field>
					<RelatedField>ComponentGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AdjustmentType</Name>
					<Field>AdjustmentType</Field>
					<ValueStr>ProjAdjustmentType::Item</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjIdentId</Name>
					<Field>ProjIdentId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DimensionAttributeValueCombination</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DimensionAttributeValueCombination_TmpProjAdjustmentCreate</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimension</Name>
					<Field>LedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PostalAddress_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LogisticsPostalAddress</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LogisticsPostalAddress</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TmpProjAdjustmentCreate</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PostalAddress_IN</Name>
					<Field>PostalAddress_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjIdentResource</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ResourceView</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjIdentResource</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjIdentResource</Name>
					<Field>ProjIdentResource</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjLineProperty</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjLineProperty</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LinePropertyId</Name>
					<Field>LinePropertyId</Field>
					<RelatedField>LinePropertyId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>Resource</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ResourceView</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Resource</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Resource</Name>
					<Field>Resource</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ResourceCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ResourceCategoryView</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ResourceCategory</Name>
					<Field>ResourceCategory</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SalesTaxFormTypes_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SalesTaxFormTypes_IN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>SalesTaxFormTypes_IN_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>SalesTaxFormTypes_IN_1_TmpProjAdjustmentCreate</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SalesTaxFormTypes_IN</Name>
					<Field>SalesTaxFormTypes_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesUnit</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UnitOfMeasure</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SalesUnit</Name>
					<Field>SalesUnit</Field>
					<RelatedField>Symbol</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ServiceCodeTable_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ServiceCodeTable_IN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ServiceCodeTable_IN_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ServiceCodeTable_IN_1_TmpProjAdjustmentCreate</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ServiceCodeTable_IN</Name>
					<Field>ServiceCodeTable_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxInformation_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxInformation_IN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxInformation_IN</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxInformation_IN_TmpProjAdjustmentCreate</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxInformation_IN</Name>
					<Field>TaxInformation_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TaxItemGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxItemGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxItemGroupId</Name>
					<Field>TaxItemGroupId</Field>
					<RelatedField>TaxItemGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxWithholdGroupHeadingTCS_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxWithholdGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxWithholdGroupHeading_2</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxWithholdGroupHeading_2_TmpProjAdjustmentCreate</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TCSGroup_IN</Name>
					<Field>TCSGroup_IN</Field>
					<RelatedField>TaxWithholdGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxWithholdGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxWithholdGroupHeadingTDS_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxWithholdGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxWithholdGroupHeading_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxWithholdGroupHeadingTDS_IN_TmpProjAdjustmentCreate</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TDSGroup_IN</Name>
					<Field>TDSGroup_IN</Field>
					<RelatedField>TaxWithholdGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxWithholdGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WrkCtrTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WrkCtrTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PSAWrkCtrId</Name>
					<SourceEDT>PSAWrkCtrId</SourceEDT>
					<Field>PSAWrkCtrId</Field>
					<RelatedField>WrkCtrId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>IsIndividualResource</Name>
					<SourceEDT>PSAWrkCtrId</SourceEDT>
					<RelatedField>IsIndividualResource</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>WrkCtrIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TmpProjMarkedAndPending</Name>
			<RelatedTable>TmpProjMarkedAndPending</RelatedTable>
			<RelationshipType>Link</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TransID</Name>
					<Field>TransID</Field>
					<RelatedField>TransID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TaxGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxgroupId</Name>
					<Field>TaxgroupId</Field>
					<RelatedField>TaxGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>