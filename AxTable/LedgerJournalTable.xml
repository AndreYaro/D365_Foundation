<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class LedgerJournalTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowPosting_IT</Name>
				<Source><![CDATA[
    public boolean allowPosting_IT()
    {
        return !(LedgerJournalName::find(this.JournalName).GeneratePayments_IT &&
                 !this.PaymentsGenerated_IT);
    }

]]></Source>
			</Method>
			<Method>
				<Name>approved</Name>
				<Source><![CDATA[
    boolean approved()
    {
        return (this.Approver || !this.ledgerJournalName().ApproveActive);
    }

]]></Source>
			</Method>
			<Method>
				<Name>approvedName</Name>
				<Source><![CDATA[
    display HcmPersonnelNumberId approvedName()
    {
        return HcmWorker::find(this.Approver).PersonnelNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canApplyServiceReverseCharge_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether service tax reverse charge can be applied for the voucher.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher to be checked.
    /// </param>
    /// <returns>
    /// True: reverse charge can be applied (current scope: only vendor voucher can apply reverse charge).
    /// False otherwise.
    /// </returns>
    public boolean canApplyServiceReverseCharge_IN(Voucher _voucher)
    {
        boolean             isOk = false;
        LedgerJournalTrans  ledgerJournalTrans;
        if (this.JournalType == LedgerJournalType::Approval)
        {
            isOk = true;
        }
        else
        {
            select firstOnly RecId from ledgerJournalTrans
                where  ledgerJournalTrans.JournalNum    == this.JournalNum
                    && ledgerJournalTrans.Voucher       == _voucher
                    && ((ledgerJournalTrans.AccountType             == LedgerJournalACType::Vend && ledgerJournalTrans.LedgerDimension)
                        || (ledgerJournalTrans.OffsetAccountType    == LedgerJournalACType::Vend && ledgerJournalTrans.OffsetLedgerDimension));

            isOk = ledgerJournalTrans.RecId != 0;
        }
        return isOk;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteJournal</Name>
				<Source><![CDATA[
    /// <summary>
/// Gets the slip journal transaction which has some document status
/// </summary>
/// <returns>
/// False if the journal has status else True
/// </returns>
/// <remarks>
/// This method is called from delete method of form data source LedgerjournalTable and also form method enableButtonsActive
/// The form functionality is limited by the form context and the rights of the security model.
/// </remarks>
public boolean canDeleteJournal()
{
    LedgerJournalTrans_RCash    ledgerJournalTrans_RCash;
    LedgerJournalTrans          ledgerJournalTrans;

    select firstOnly RecId from ledgerJournalTrans_RCash
        where ledgerJournalTrans_RCash.TransStatus == RCashTransStatus::Approved ||
              ledgerJournalTrans_RCash.TransStatus == RCashTransStatus::Confirmed
    exists join ledgerJournalTrans
        where ledgerJournalTrans.RecId      == ledgerJournalTrans_RCash.RefRecId
           && ledgerJournalTrans.JournalNum == this.JournalNum;

    return ledgerJournalTrans_RCash.RecId ? false : true;
}

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    public str caption()
    {
        return strFmt("@SYS28641", this.JournalName, this.JournalNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfWorkflowCompletedIcon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the transaction that is represented by the current record in the
    /// <c>LedgerJournalTable</c> table completed the workflow process.
    /// </summary>
    /// <returns>
    /// The workflow setup icon, if the transaction has a task or approval operating over it; otherwise, a
    /// blank icon.
    /// </returns>
    public display ImageRes checkIfWorkflowCompletedIcon()
    {
        #resAppl

        if (this.WorkflowApprovalStatus == LedgerJournalWFApprovalStatus::PendingApproval)
        {
            return #ImageSetupWorkflow;
        }
        else
        {
            return #ImageBlank2;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalMayBeBooked</Name>
				<Source><![CDATA[
    boolean checkJournalMayBeBooked()
    {
        this.checkJournalOpen();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalOpen</Name>
				<Source><![CDATA[
    boolean checkJournalOpen()
    {
        if (this.PostedDateTime)
        {
            return checkFailed(strFmt("@SYS18421", this.JournalNum));
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotGroupBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if journal is blocked by a user group.
    /// </summary>
    /// <returns>True if locked; otherwise, false.</returns>
    public boolean checkNotGroupBlocked()
    {
        if (this.GroupBlockId)
        {
            if (!UserInfoHelp::userInUserGroup(curUserId(), this.GroupBlockId))
            {
                return checkFailed(strFmt("@SYS28638", this.JournalNum, this.GroupBlockId));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotSystemBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if journal is locked by the system.
    /// </summary>
    /// <returns>True if locked; otherwise, false.</returns>
    public boolean checkNotSystemBlocked()
    {
        if (this.SystemBlocked)
        {
            return checkFailed(strFmt("@SYS21618", this.JournalNum));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotUserBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if journal is locked by another user.
    /// </summary>
    /// <returns>True if locked; otherwise, false.</returns>
    public boolean checkNotUserBlocked()
    {
        if (this.UserBlockId)
        {
            if (this.UserBlockId != curUserId())
            {
                return checkFailed(strFmt("@SYS21617", this.JournalNum));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotInUse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if journal is in use by another user.
    /// </summary>
    /// <returns>True if in use; otherwise, false.</returns>
    public boolean checkNotInUse()
    {
        if (this.SessionId && isSessionActive(this.SessionId, this.SessionLoginDateTime))
        {
            if (this.inUseUserId() != curUserId())
            {
                return checkFailed(strFmt("@SYS18418", this.JournalNum, this.inUseUserId()));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a field to its default value.
    /// </summary>
    /// <param name="_fieldId">
    /// The ID of the field to set to the default value.
    /// </param>
    public void defaultField(FieldId _fieldId)
    {
        LedgerJournalTableType ledgerJournalTableType;

        ledgerJournalTableType = this.type();
        if (ledgerJournalTableType)
        {
            ledgerJournalTableType.defaultField(_fieldId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultRow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults field values for a <c>LedgerJournalTable</c> table row.
    /// </summary>
    public void defaultRow()
    {
        LedgerJournalTableType ledgerJournalTableType;

        ledgerJournalTableType = this.type();

        if (ledgerJournalTableType)
        {
            ledgerJournalTableType.defaultRow();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    void delete()
    {
        ttsbegin;

        TaxUncommitted::deleteForDocumentHeader(this.TableId, this.RecId, false, false);
        TMSInvoiceTable::clearReferenceToLedgerJournal(this.JournalNum);

        super();

        if (! this.Posted)
        {
            Num num = this.JournalNum;

            // The journal batch number sequence can be modified, but there is no reference stored as to which number sequence was used
            // when the journal batch number was reserved.  To account for potential number sequence setup change, check the format
            // before invoking API to release the number.
            if (NumberSeq::numCheckFormat(num, LedgerParameters::numRefJournalNum().numberSequenceTable()))
            {
                NumberSeq::releaseNumber(LedgerParameters::numRefJournalNum().NumberSequenceId, num);
            }
            else
            {
                // The NumberSeq::numCheckFormat API displays a warning message if the number sequence format did not match,
                // remove the warning message to not introduce confusion to the end user.
                int line = infologLine();
                infolog.clear(line - 1);
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributeJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Distributes the lines of a journal into several new journals.
    /// </summary>
    /// <param name="_suppressClientMessages">
    /// A Boolean value that indicates whether items, such as dialog boxes, should be suppressed during the
    /// distribution process. Infolog messages are okay. The default is false.
    /// </param>
    /// <returns>
    /// A <c>RecordSortedList</c> object that holds the record buffers for the new journals.
    /// </returns>
    /// <remarks>
    /// The original journal is not contained by the list returned by this method.The number of lines in
    /// each journal might not match the requested number because all lines with the same voucher number
    /// must remain in the same journal.The journal is split across voucher boundaries when the total size
    /// of the journal is larger than the amount set by the user. For example, if the maximum size of a
    /// journal is 1000, but the first voucher boundary occurs at 1278, the original journal will have 1277
    /// records in it. The newly created journal will have the next 1000+ records starting at 1278.
    /// </remarks>
    public RecordSortedList distributeJournalLines(boolean _suppressClientMessages = false)
    {
        return LedgerJournalDistribute::newLedgerJournalTable(this).distributeJournalLines(_suppressClientMessages);
    }

]]></Source>
			</Method>
			<Method>
				<Name>editExchRate</Name>
				<Source><![CDATA[
    public edit ExchRate editExchRate(boolean set, ExchRate _exchRate)
    {
        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), this.CurrencyCode);

        if (set)
        {
            if (this.CurrencyCode == '')
            {
                this.ExchRate = _exchRate;
            }
            else
            {
                this.ExchRate = exchangeRateHelper.prepareExchangeRateForStorage(_exchRate);
            }

            if (Ledger::isReportingCurrencySameAsAccountingCurrency())
            {
                this.editReportingCurrencyExchRate(set, _exchRate);
            }
        }
        else
        {
            if (this.CurrencyCode == '')
            {
                _exchRate = this.ExchRate;
            }
            else
            {
                _exchRate = exchangeRateHelper.displayStoredExchangeRate(this.ExchRate);
            }
        }

        return _exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editExchRateSecond</Name>
				<Source><![CDATA[
    public edit ExchrateSecondary editExchRateSecond(boolean set, ExchrateSecondary _exchRate)
    {
        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), this.CurrencyCode);

        if (set)
        {
            if (this.CurrencyCode == '')
            {
                this.ExchrateSecondary = _exchRate;
            }
            else
            {
                this.ExchrateSecondary = exchangeRateHelper.prepareExchangeRateForStorage(_exchRate);
                this.setReportingCurrencyExchangeRateSecond();
            }
        }
        else
        {
            if (this.CurrencyCode == '')
            {
                _exchRate = this.ExchrateSecondary;
            }
            else
            {
                _exchRate = exchangeRateHelper.displayStoredExchangeRate(this.ExchrateSecondary);
            }
        }

        return _exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existVoucher</Name>
				<Source><![CDATA[
    boolean existVoucher()
    {
        return (select firstonly RecId from ledgerJournalTrans
                index NumVoucherIdx
                    where ledgerJournalTrans.JournalNum == this.JournalNum).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>facturedFully_RU</Name>
				<Source><![CDATA[
    public boolean facturedFully_RU(FactureEditLinesEngineTaxCorrection_RU _engine = null)
    {
        boolean                                ret    = true;
        FactureEditLinesEngineTaxCorrection_RU engine = _engine;

        if (! engine)
        {
            engine = FactureEditLinesEngine_RU::construct(null, FactureModule_RU::TaxCorrectionPurch);
        }

        ret = engine.jourFullyFactured(this.RecId, true);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOriginalJournalType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the journal type of the original journal.
    /// </summary>
    /// <returns>
    /// If this is an inter-company created <see cref="T:LedgerJournalTrans" /> record, the journal type of
    /// the original journal. Otherwise, returns the zero value of the <see cref="T:LedgerJournalType"
    /// /><c>Daily</c>.
    /// </returns>
    public LedgerJournalType findOriginalJournalType()
    {
        LedgerJournalTable          ledgerJournalTableLocal;
        LedgerJournalId             originalJournalNum;

        // If this is an intercompany-created LedgerJournalTrans, find the original journal type.
        if (this.OriginalCompany != '')
        {
            originalJournalNum = this.OriginalJournalNum;
            changecompany(this.OriginalCompany)
            {
                ledgerJournalTableLocal = LedgerJournalTable::find(originalJournalNum);
            }
        }

        return ledgerJournalTableLocal.JournalType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAnyLine_RU</Name>
				<Source><![CDATA[
    public LedgerJournalTrans getAnyLine_RU(boolean _forupdate = false)
    {
        LedgerJournalTrans  ledgerJournalTrans;

        ledgerJournalTrans.selectForUpdate(_forupdate);

        select firstonly ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == this.JournalNum;

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetBalanceForMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the balance for the offset account type and main account.
    /// </summary>
    /// <param name="_mainAccount">
    /// The main account to include in the balance.
    /// </param>
    /// <returns>
    /// The balance of the selected transactions as an <c>AmountMST</c> value.
    /// </returns>
    /// <remarks>
    /// The summary debit and credit amounts are converted to an <c>AmountMST</c> data type before netting
    /// the balance amount.
    /// </remarks>

    public AmountMST getOffsetBalanceForMainAccount(
        MainAccountRecId        _mainAccount)
    {
        LedgerJournalTrans                  ledgerJournalTrans;
        DimensionAttributeValueCombination  dimAttrValueCombo;
        AmountMST                           balance;

        while select JournalNum, AmountCurDebit, AmountCurCredit, Company, CurrencyCode,
                    ExchRate, ExchRateSecond, TransDate
                from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == this.JournalNum
                    && ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger
                exists join RecId from dimAttrValueCombo
                    where ledgerJournalTrans.OffsetLedgerDimension == dimAttrValueCombo.RecId
                        && dimAttrValueCombo.MainAccount == _mainAccount
        {
            balance += ledgerJournalTrans.calcAmountMST();
        }

        return balance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromLedgerJournalName</Name>
				<Source><![CDATA[
    void initFromLedgerJournalName(LedgerJournalNameId _ledgerJournalNameId = this.JournalName)
    {
        JournalTableData::newTable(this).initFromJournalName(LedgerJournalName::find(_ledgerJournalNameId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromLedgerJournalTable</Name>
				<Source><![CDATA[
    public void initFromLedgerJournalTable(LedgerJournalTable   _ledgerJournalTable)
    {
        LedgerJournalTableData  journalTableData;

        journalTableData = JournalTableData::newTable(this);
        journalTableData.initFromLedgerJournalTable(_ledgerJournalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWFApprovalStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets an initial state of the <c>WorkflowApprovalStatus</c> field of the <c>LedgerJournalTable</c>
    /// table.
    /// </summary>
    /// <param name="_ledgerJournalName">
    /// A <c>LedgerJournalName</c> buffer.
    /// </param>
    /// <param name="_isJournalAlreadyApproved">
    /// A Boolean value that indicates whether the journal is already approved; optional.
    /// </param>
    /// <remarks>
    /// The valid initial states are None and Not Submitted.Only journals with a current workflow approval
    /// status not associated to running workflow instances can have an initial workflow approval state
    /// set.An Infolog will be generated when an already approved journal cannot have its workflow approval
    /// status set to Not Submitted.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// The current workflow approval status of the journal indicates that an active workflow instance
    /// exists.
    /// </exception>
    public void initWFApprovalStatus(LedgerJournalName _ledgerJournalName, boolean _isJournalAlreadyApproved = false)
    {
        // Is the current status not associated to an active running workflow instance?
        if (this.WorkflowApprovalStatus != LedgerJournalWFApprovalStatus::Approved &&
            this.WorkflowApprovalStatus != LedgerJournalWFApprovalStatus::None     &&
            this.WorkflowApprovalStatus != LedgerJournalWFApprovalStatus::NotSubmitted)
        {
            throw error(strFmt("@SYS111649", this.JournalName, this.JournalNum));
        }

        if (_ledgerJournalName.checkWorkflowApprovalEnabled(true))
        {
            // Workflow approval is enabled for the journal.
            this.WorkflowApprovalStatus = LedgerJournalWFApprovalStatus::NotSubmitted;
        }
        else
        {
            // Workflow approval is disabled for the journal.
            this.WorkflowApprovalStatus = LedgerJournalWFApprovalStatus::None;

            if (_isJournalAlreadyApproved)
            {
                // Notify the user that the journal's workflow status has been reset to "None".
                info("@SYS111654");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        ttsbegin;

        if ((!this.JournalName) && this.JournalNum)
        {
            throw error("@SYS16764");
        }

        if (!this.Name)
        {
            this.Name = this.ledgerJournalName().Name;
        }

        if (!this.JournalNum)
        {
            this.JournalNum = JournalTableData::newTable(this).nextJournalId();

            if (!this.JournalNum)
            {
                throw error("@SYS27388");
            }

            this.initFromLedgerJournalName();
        }

        if (!this.ParentJournalNum)
        {
            this.ParentJournalNum = this.JournalNum;
        }

        this.defaultReportingCurrencyExchangeRateIfSameCurrencies();

        super();

        // <GCN>
        this.SysExtensionSerializerMap::postInsert();
        // </GCN>

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inUseUserId</Name>
				<Source><![CDATA[
    JournalBlockInUseUserId inUseUserId()
    {
        return this.SessionId && isSessionActive(this.SessionId, this.SessionLoginDateTime) ? new xSession(this.SessionId).userId() : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBillOfExchangePromissoryOrRemittance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that determines whether the current record is a bill of exchange, promissory or remittance journal type.
    /// </summary>
    /// <returns>
    /// true if the current record is a bill of exchange, promissory or remittance journal type; otherwise, false.
    /// </returns>
    public boolean isBillOfExchangePromissoryOrRemittance()
    {
        return this.JournalType == LedgerJournalType::CustBillOfExchangeAccept
            || this.JournalType == LedgerJournalType::CustBillOfExchangeDraw
            || this.JournalType == LedgerJournalType::CustBillOfExchangeProtest
            || this.JournalType == LedgerJournalType::CustBillOfExchangeRedraw
            || this.JournalType == LedgerJournalType::CustBillOfExchangeSettle
            || this.JournalType == LedgerJournalType::CustPaymRemittance
            || this.JournalType == LedgerJournalType::VendPaymRemittance
            || this.JournalType == LedgerJournalType::VendPromissoryNoteDraw
            || this.JournalType == LedgerJournalType::VendPromissoryNoteRedraw
            || this.JournalType == LedgerJournalType::VendPromissoryNoteSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEligableForDistributionBeforePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the line count on the journal is above the maximum allowed threshold, and should be
    /// distributed into several journals before it tries to post.
    /// </summary>
    /// <returns>
    /// true if the number of lines over the max limit and the journal should be distributed into several journals;
    /// otherwise, false.
    /// </returns>
    /// <remarks>
    /// Journals that have many lines create roll back segments that are very large, which could cause
    /// server problems. By default, the maximum number of lines allowed in a journal is 1000, and any journals
    /// with more than 1000 lines will be forcibly split.
    /// </remarks>
    public boolean isEligableForDistributionBeforePost()
    {
        if (LedgerJournalForcedJournalSplitFeature::isEnabled())
        {
            boolean ret;

            ret = LedgerJournalName::find(this.JournalName).NewVoucher != NewVoucher::OneVoucher;

            ret = ret && this.numOfLines() > LedgerJournalMaxLineLimit::getMaxLineLimit();

            return ret;
        }
        else
        {
            boolean ret;

            ret = this.LinesLimitBeforeDistribution > 0;

            ret = ret && LedgerJournalName::find(this.JournalName).NewVoucher != NewVoucher::OneVoucher;

            ret = ret && this.numOfLines() > this.LinesLimitBeforeDistribution;

            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateIsUnderLineLimit</Name>
				<Source><![CDATA[
    internal boolean validateIsUnderLineLimit()
    {
        if (LedgerJournalForcedJournalSplitFeature::isEnabled()
            && LedgerJournalTable::journalTypeAllowsSplitting(this.JournalType))
        {
            int numLines = this.numOfLines();
            int limit = LedgerJournalMaxLineLimit::getMaxLineLimit();
            if (numLines > limit)
            {
                return checkFailed(strFmt("@GeneralLedger:LedgerJournalMaxLineLimitExceeded", this.JournalNum, limit));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalTypeAllowsSplitting</Name>
				<Source><![CDATA[
    internal static boolean journalTypeAllowsSplitting(LedgerJournalType _ledgerJournalType)
    {
        boolean ret = true;

        if (_ledgerJournalType == LedgerJournalType::PayrollDisbursement
            || _ledgerJournalType == LedgerJournalType::Approval)
        {
            ret = false;
        }

        // Fixed asset journals are not allowed to be split and behavior is independent of automatic split feature.
        // isEligableForDistributionBeforePost() is extended to return false always for asset journals.
        // Adding below code to avoid throwing warning as well when asset journal posted with more than 1000 lines.
        if (ret
            && AssetIgnoreJournalSplittingFlight::instance().isEnabled()
            && (_ledgerJournalType == LedgerJournalType::Assets
                || _ledgerJournalType == LedgerJournalType::Assets_RU
                || _ledgerJournalType == LedgerJournalType::AssetBudgets
                || _ledgerJournalType == LedgerJournalType::AssetBudgets_RU))
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEligableForBankSummarization</Name>
				<Source><![CDATA[
    internal boolean isEligableForBankSummarization()
    {
        return this.BankTransSummarizationEnabled
            && this.BankTransSummarizationCriteria != BankTransSummarizationCriteria::NoSummarization;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGroupPrivate</Name>
				<Source><![CDATA[
    display NoYes isGroupPrivate()
    {
        return this.GroupBlockId ? NoYes::Yes: NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInWFApprovalProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a journal is in the workflow approval process.
    /// </summary>
    /// <returns>
    /// true if the journal is in the workflow approval process; otherwise, false.
    /// </returns>
    public boolean isInWFApprovalProcess()
    {
        return this.WorkflowApprovalStatus != LedgerJournalWFApprovalStatus::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPositiveDRCROnlyEnabled_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the postive DR CR is enabled for the journal table.
    /// </summary>
    /// <returns>
    /// True if allow only postive debits credits is enabled; otherwise, false.
    /// </returns>
    public boolean isPositiveDRCROnlyEnabled_JP()
    {
        #ISOCountryRegionCodes

        return SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP])
            && this.JournalType == LedgerJournalType::Daily
            && this.ledgerJournalName().PositiveDRCROnly_JP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUserPrivate</Name>
				<Source><![CDATA[
    edit NoYes isUserPrivate(boolean _set, NoYes _isUserPrivate)
    {
        if (_set)
        {
            this.markUserPrivate();
        }

        return this.UserBlockId ? NoYes::Yes: NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWFApprovalApproved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a journal has been approved because of the workflow approval process.
    /// </summary>
    /// <returns>
    /// true if the workflow approval status for the journal is <c>Approved</c>; otherwise, false.
    /// </returns>
    public boolean isWFApprovalApproved()
    {
        return this.WorkflowApprovalStatus == LedgerJournalWFApprovalStatus::Approved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWFUserPermittedToEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the current user is a valid workflow user for the current workflow status.
    /// </summary>
    /// <param name="_workflowWorkItemTable">
    /// A WorkflowWorkItemTable buffer that represents the work item associated
    /// to the current LedgerJournalTable buffer.
    /// </param>
    /// <param name="_workflowUser">
    /// A workflow user.
    /// </param>
    /// <returns>
    /// true if the current user can edit the journal in its current workflow approval state; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used with journals that support workflow approvals.
    /// The _workflowItemTable and the _workflowUser parameters are required when the LedgerJournalTable table
    /// WorkflowApprovalStatus field is in a LedgerJournalWFApprovalStatus::ChangeRequested state.
    /// The _workflowWorkItem is needed because the user (the _workflowUser) attempting to edit the journal
    /// must be the user assigned to the workflow work item.
    /// The _workflowUser parameter is required when the current user is not the user you want to validate
    /// against the workflow work item user.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// The journal's workflow status is not correct for the use of this method.
    /// </exception>
    public boolean isWFUserPermittedToEdit(WorkflowWorkItemTable _workflowWorkItemTable, WorkflowUser _workflowUser = curUserId())

    {
        Debug::assert(this.WorkflowApprovalStatus != LedgerJournalWFApprovalStatus::None);

        switch (this.WorkflowApprovalStatus)
        {
            case LedgerJournalWFApprovalStatus::ChangeRequested:
                // Check that the _workflowUser is a valid editor for the change requested journal.
                //
                // The assumption is that a journal with workflow approval status of "ChangeRequested" should
                // always have an associated workflow work item and it should have a WorkflowWorkItemTable.Type
                // of "Return" or "RequestChange" and it should be assigned to a specific user.
                //
                if (_workflowWorkItemTable.RecId == 0)
                {
                    //
                    // If there is not a workflow work item it is possible that it has not been created yet or
                    // it is not assigned to the current user. This is not an error, just do not allow editing
                    // on the document to be allowed.
                    //
                    return false;
                }
                else if (_workflowWorkItemTable.Type == WorkflowWorkItemType::Return     ||
                         _workflowWorkItemTable.Type == WorkflowWorkItemType::RequestChange)
                {
                    if (_workflowWorkItemTable.UserId == _workflowUser)
                    {
                        // The _workflowUser can edit the journal.
                        return true;
                    }
                    else
                    {
                        // The _workflowUser can not edit the journal.
                        return false;
                    }
                }

                //
                // The workflow work item type is not the correct type for the journal's
                // current workflow approval status.
                //
                error("@SYS111651");
                break;
            case LedgerJournalWFApprovalStatus::NotSubmitted:
                // The document is always editable in the None and NotSubmitted states.
                return true;
            case LedgerJournalWFApprovalStatus::None:
                throw error("@SYS109633");
        }

        // The document is not editable in any other state.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalBalanceOnAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates a balance amount, specified journal, account type, and account.
    /// </summary>
    /// <param name="_accountType">
    /// The <c>LedgerJournalACType</c> enumeration value to use to restrict the selected rows.
    /// </param>
    /// <param name="_dimensionDynamicAccount">
    /// The account number to use to restrict the selected rows.
    /// </param>
    /// <param name="_onlyOffset">
    /// A Boolean value that restricts the balance calculation the offset portion of the
    /// <c>LedgerJournalTrans</c> records that are selected.
    /// </param>
    /// <returns>
    /// The balance of the selected transactions as an <c>AmountMST</c> value.
    /// </returns>
    /// <remarks>
    /// The summary debit and credit amounts are converted to an <c>AmountMST</c> data type before netting
    /// the balance amount.
    /// </remarks>

    AmountMST journalBalanceOnAccount(
        LedgerJournalACType     _accountType,
        DimensionDynamicAccount _dimensionDynamicAccount,
        boolean                 _onlyOffset = false)
    {
        LedgerJournalTrans  ledgerJournalTrans;
        AmountMST           balance;
        AmountMST           amountDebitMST;
        AmountMST           amountCreditMST;

        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        if (!_onlyOffset)
        {
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                while   select  sum(AmountCurDebit), sum(AmountCurCredit)
                    from    ledgerJournalTrans
                    group by Company,       AccountType,        LedgerDimension,
                             OffsetCompany, OffsetAccountType,  OffsetLedgerDimension,
                             CurrencyCode,  ExchRate,           ExchRateSecond, Triangulation, TransDate
                             ,JournalNum, VatDueDate_W, DocumentDate, TaxGroup
                    where   ledgerJournalTrans.JournalNum      == this.JournalNum &&
                            ledgerJournalTrans.AccountType     == _accountType    &&
                            ledgerJournalTrans.LedgerDimension == _dimensionDynamicAccount
                {
                    amountDebitMST  = ledgerJournalTrans.calcDebitMST();
                    amountCreditMST = ledgerJournalTrans.calcCreditMST();
                    balance += (amountDebitMST - amountCreditMST);
                }
            }
            else
            {
            // </GEERU>
                while select sum(AmountCurDebit), sum(AmountCurCredit)
                    from ledgerJournalTrans
                        group by Company, AccountType, LedgerDimension, JournalNum,
                                 OffsetCompany, OffsetAccountType, OffsetLedgerDimension,
                                 CurrencyCode, ExchRate, ExchRateSecond, Triangulation, TransDate
                        where ledgerJournalTrans.JournalNum == this.JournalNum &&
                              ledgerJournalTrans.AccountType == _accountType &&
                              ledgerJournalTrans.LedgerDimension == _dimensionDynamicAccount
                {
                    amountDebitMST  = ledgerJournalTrans.calcDebitMST();
                    amountCreditMST = ledgerJournalTrans.calcCreditMST();
                    balance += (amountDebitMST - amountCreditMST);
                }
            //<GEERU>
            }
            // </GEERU>
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            while select sum(AmountCurDebit), sum(AmountCurCredit)
                from ledgerJournalTrans
                group by Company, AccountType, LedgerDimension,
                         OffsetCompany, OffsetAccountType,  OffsetLedgerDimension,
                         CurrencyCode, ExchRate, ExchRateSecond, Triangulation, TransDate
                         ,JournalNum, DocumentDate, TaxGroup
                where  ledgerJournalTrans.JournalNum               == this.JournalNum  &&
                       ledgerJournalTrans.OffsetAccountType        == _accountType     &&
                       ledgerJournalTrans.OffsetLedgerDimension    == _dimensionDynamicAccount

            {
                amountDebitMST  = ledgerJournalTrans.calcDebitMST();
                amountCreditMST = ledgerJournalTrans.calcCreditMST();
                balance -= (amountDebitMST - amountCreditMST);
            }
        }
        else
        {
        // </GEERU>
            while select sum(AmountCurDebit), sum(AmountCurCredit)
                    from ledgerJournalTrans
                    group by Company, AccountType, LedgerDimension, JournalNum,
                        OffsetCompany, OffsetAccountType, OffsetLedgerDimension,
                        CurrencyCode,
                        // <GEEU>
                        VatDueDate_W,
                        // </GEEU>
                        ExchRate, ExchRateSecond, Triangulation, TransDate
                    where   ledgerJournalTrans.JournalNum == this.JournalNum  &&
                            ledgerJournalTrans.OffsetAccountType == _accountType &&
                            ledgerJournalTrans.OffsetLedgerDimension == _dimensionDynamicAccount
            {
                amountDebitMST  = ledgerJournalTrans.calcDebitMST();
                amountCreditMST = ledgerJournalTrans.calcCreditMST();
                balance -= (amountDebitMST - amountCreditMST);
            }
        // <GEERU>
        }
        // </GEERU>

        return balance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalTotalAccountCreditMST</Name>
				<Source><![CDATA[
    AmountMST journalTotalAccountCreditMST(
        DimensionDynamicAccount _dimensionDynamicAccount,
        LedgerJournalACType     _ledgerJournalACType,
        CompanyId               _companyId = curext(),
        boolean                 _useMainAccountOnly = false,
        RecId                   _mainAccountRecId = 0)
    {
        LedgerJournalTrans                  ledgerJournalTransFieldList;
        AmountMST                           balanceSheet = 0;
        DimensionAttributeValueCombination  dimAttrValueCombo;
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        if (this.JournalNum)
        {
            if (_useMainAccountOnly && _ledgerJournalACType == LedgerJournalACType::Ledger)
            {
                // Use only MainAccount for calculation
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    while select LedgerDimension, Company, AmountCurCredit, CurrencyCode, TransDate, Triangulation, ExchRate,
                            ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum, VatDueDate_W, DocumentDate, TaxGroup from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum
                            && ledgerJournalTransFieldList.AccountType      == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurCredit  != 0
                            && ledgerJournalTransFieldList.Company          == _companyId
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                       == ledgerJournalTransFieldList.LedgerDimension
                            && dimAttrValueCombo.MainAccount                == _mainAccountRecId
                    {
                        balanceSheet += ledgerJournalTransFieldList.calcCreditMST();
                    }

                    while select OffsetLedgerDimension, OffsetCompany, AmountCurDebit, CurrencyCode, TransDate, Triangulation,
                            ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum, VatDueDate_W, DocumentDate, TaxGroup from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum            == this.JournalNum
                            && ledgerJournalTransFieldList.OffsetAccountType    == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurDebit       != 0
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                           == ledgerJournalTransFieldList.OffsetLedgerDimension
                            && dimAttrValueCombo.MainAccount                    == _mainAccountRecId
                    {
                        if (!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitMST();
                        }
                    }
                }
                else
                {
                // </GEERU>
                    while select LedgerDimension, Company, AmountCurCredit, CurrencyCode, TransDate, JournalNum,
                            Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum
                            && ledgerJournalTransFieldList.AccountType      == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurCredit  != 0
                            && ledgerJournalTransFieldList.Company          == _companyId
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                       == ledgerJournalTransFieldList.LedgerDimension
                            && dimAttrValueCombo.MainAccount                == _mainAccountRecId
                    {
                        balanceSheet += ledgerJournalTransFieldList.calcCreditMST();
                    }

                    while select OffsetLedgerDimension, OffsetCompany, AmountCurDebit, CurrencyCode, TransDate, JournalNum,
                            Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum            == this.JournalNum
                            && ledgerJournalTransFieldList.OffsetAccountType    == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurDebit       != 0
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                           == ledgerJournalTransFieldList.OffsetLedgerDimension
                            && dimAttrValueCombo.MainAccount                    == _mainAccountRecId
                    {
                        if (!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitMST();
                        }
                    }
                }
            }
            else
            {
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    while select LedgerDimension, Company, OffsetLedgerDimension, OffsetCompany, AmountCurDebit, AmountCurCredit,
                            CurrencyCode, TransDate, Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum, VatDueDate_W, DocumentDate, TaxGroup
                            from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum    == this.JournalNum              &&
                        ((ledgerJournalTransFieldList.LedgerDimension   == _dimensionDynamicAccount     &&
                          ledgerJournalTransFieldList.AccountType       == _ledgerJournalACType         &&
                          ledgerJournalTransFieldList.AmountCurCredit  != 0)                            ||
                         (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount     &&
                          ledgerJournalTransFieldList.OffsetAccountType     == _ledgerJournalACType         &&
                          ledgerJournalTransFieldList.AmountCurDebit        != 0))
                    {
                        if (ledgerJournalTransFieldList.LedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.Company         == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditMST();
                        }
                        if (ledgerJournalTransFieldList.OffsetLedgerDimension== _dimensionDynamicAccount &&
                            (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) == false ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId))
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitMST();
                        }
                    }
                }
                else
                {
                // </GEERU>
                    while select LedgerDimension, Company, OffsetLedgerDimension, OffsetCompany, AmountCurDebit, AmountCurCredit, JournalNum,
                                CurrencyCode, TransDate, Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary from ledgerJournalTransFieldList
                            where ledgerJournalTransFieldList.JournalNum        == this.JournalNum          &&
                            ((ledgerJournalTransFieldList.LedgerDimension       == _dimensionDynamicAccount &&
                              ledgerJournalTransFieldList.AccountType           == _ledgerJournalACType     &&
                              ledgerJournalTransFieldList.AmountCurCredit        != 0)                       ||
                             (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount &&
                              ledgerJournalTransFieldList.OffsetAccountType     == _ledgerJournalACType     &&
                              ledgerJournalTransFieldList.AmountCurDebit       != 0))
                    {
                        if (ledgerJournalTransFieldList.LedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.Company         == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditMST();
                        }
                        if (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount &&
                            (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) == false ||
                             ledgerJournalTransFieldList.OffsetCompany == _companyId))
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitMST();
                        }
                    }
                //<GEERU>
                }
                //</GEERU>
            }
        }

        return balanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalTotalAccountCreditReportingCurrency</Name>
				<Source><![CDATA[
    AmountMST journalTotalAccountCreditReportingCurrency(
        DimensionDynamicAccount _dimensionDynamicAccount,
        LedgerJournalACType     _ledgerJournalACType,
        CompanyId               _companyId = curext(),
        boolean                 _useMainAccountOnly = false,
        RecId                   _mainAccountRecId = 0)
    {
        LedgerJournalTrans                  ledgerJournalTransFieldList;
        AmountMST                           balanceSheet = 0;
        DimensionAttributeValueCombination  dimAttrValueCombo;
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        if (this.JournalNum)
        {
            if (_useMainAccountOnly && _ledgerJournalACType == LedgerJournalACType::Ledger)
            {
                // Use only MainAccount for calculation
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    while select AccountType, LedgerDimension, Company, AmountCurCredit, CurrencyCode, TransDate, Triangulation, ExchRate, 
                            ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum, VatDueDate_W, DocumentDate, 
                            TaxGroup from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum
                            && ledgerJournalTransFieldList.AccountType      == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurCredit  != 0
                            && ledgerJournalTransFieldList.Company          == _companyId
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                       == ledgerJournalTransFieldList.LedgerDimension
                            && dimAttrValueCombo.MainAccount                == _mainAccountRecId
                    {
                        balanceSheet += ledgerJournalTransFieldList.calcCreditReportingCurrency();
                    }

                    while select AccountType, OffsetLedgerDimension, OffsetCompany, AmountCurDebit, CurrencyCode, TransDate, Triangulation, 
                            ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum, VatDueDate_W, 
                            DocumentDate, TaxGroup from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum            == this.JournalNum
                            && ledgerJournalTransFieldList.OffsetAccountType    == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurDebit       != 0
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                           == ledgerJournalTransFieldList.OffsetLedgerDimension
                            && dimAttrValueCombo.MainAccount                    == _mainAccountRecId
                    {
                        if (!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitReportingCurrency();
                        }
                    }
                }
                else
                {
                    // </GEERU>
                    while select AccountType, LedgerDimension, Company, AmountCurCredit, CurrencyCode, TransDate, Triangulation, ExchRate, 
                            ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum
                        from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum
                            && ledgerJournalTransFieldList.AccountType      == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurCredit  != 0
                            && ledgerJournalTransFieldList.Company          == _companyId
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                       == ledgerJournalTransFieldList.LedgerDimension
                            && dimAttrValueCombo.MainAccount                == _mainAccountRecId
                    {
                        balanceSheet += ledgerJournalTransFieldList.calcCreditReportingCurrency();
                    }

                    while select AccountType, OffsetLedgerDimension, OffsetCompany, AmountCurDebit, CurrencyCode, TransDate, Triangulation,
                            ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum
                        from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum            == this.JournalNum
                            && ledgerJournalTransFieldList.OffsetAccountType    == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurDebit       != 0
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                           == ledgerJournalTransFieldList.OffsetLedgerDimension
                            && dimAttrValueCombo.MainAccount                    == _mainAccountRecId
                    {
                        if (!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitReportingCurrency();
                        }
                    }
                }                
            }
            else
            {
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    while select AccountType, LedgerDimension, Company, OffsetLedgerDimension, OffsetCompany, AmountCurDebit, AmountCurCredit,  
                            CurrencyCode, TransDate, Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, 
                            JournalNum, VatDueDate_W, DocumentDate, TaxGroup from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum    == this.JournalNum              &&
                        ((ledgerJournalTransFieldList.LedgerDimension   == _dimensionDynamicAccount     &&
                          ledgerJournalTransFieldList.AccountType       == _ledgerJournalACType         &&
                          ledgerJournalTransFieldList.AmountCurCredit  != 0)                            ||
                         (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount     &&
                          ledgerJournalTransFieldList.OffsetAccountType     == _ledgerJournalACType         &&
                          ledgerJournalTransFieldList.AmountCurDebit        != 0))
                    {
                        if (ledgerJournalTransFieldList.LedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.Company         == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditReportingCurrency();
                        }
                        if (ledgerJournalTransFieldList.OffsetLedgerDimension== _dimensionDynamicAccount &&
                            (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) == false ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId))
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitReportingCurrency();
                        }
                    }
                }
                else
                {
                    // </GEERU>
                    while select AccountType, LedgerDimension, Company, OffsetLedgerDimension, OffsetCompany, AmountCurDebit, AmountCurCredit, 
                            CurrencyCode, TransDate, Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary,
                            JournalNum
                            from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum          &&
                        ((ledgerJournalTransFieldList.LedgerDimension       == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.AccountType           == _ledgerJournalACType     &&
                            ledgerJournalTransFieldList.AmountCurCredit        != 0)                       ||
                            (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.OffsetAccountType     == _ledgerJournalACType     &&
                            ledgerJournalTransFieldList.AmountCurDebit       != 0))
                    {
                        if (ledgerJournalTransFieldList.LedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.Company         == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditReportingCurrency();
                        }
                        if (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount &&
                            (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) == false ||
                                ledgerJournalTransFieldList.OffsetCompany == _companyId))
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitReportingCurrency();
                        }
                    }
                //<GEERU>
                }
                //</GEERU>
            }
        }

        return balanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalTotalAccountDebitMST</Name>
				<Source><![CDATA[
    AmountMST journalTotalAccountDebitMST(
        DimensionDynamicAccount _dimensionDynamicAccount,
        LedgerJournalACType     _ledgerJournalACType,
        CompanyId               _companyId = curext(),
        boolean                 _useMainAccountOnly = false,
        RecId                   _mainAccountRecId = 0)
    {
        LedgerJournalTrans                  ledgerJournalTransFieldList;
        AmountMST                           balanceSheet = 0;
        DimensionAttributeValueCombination  dimAttrValueCombo;
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        if (this.JournalNum)
        {
            if (_useMainAccountOnly && _ledgerJournalACType == LedgerJournalACType::Ledger)
            {
                // Use only MainAccount for calculation
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
                {
                    while select LedgerDimension, Company, AmountCurDebit, CurrencyCode, TransDate, Triangulation, ExchRate,
                            ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum, VatDueDate_W, DocumentDate, TaxGroup from ledgerJournalTransFieldList
                        index hint NumVoucherIdx
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum
                            && ledgerJournalTransFieldList.AccountType      == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurDebit   != 0
                            && ledgerJournalTransFieldList.Company          == _companyId
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                       == ledgerJournalTransFieldList.LedgerDimension
                            && dimAttrValueCombo.MainAccount                == _mainAccountRecId
                    {
                        balanceSheet += ledgerJournalTransFieldList.calcDebitMST();
                    }

                    while select OffsetLedgerDimension, OffsetCompany, AmountCurCredit, CurrencyCode, TransDate, Triangulation,
                            ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum, VatDueDate_W, DocumentDate, TaxGroup from ledgerJournalTransFieldList
                        index hint NumVoucherIdx
                        where ledgerJournalTransFieldList.JournalNum            == this.JournalNum
                            && ledgerJournalTransFieldList.OffsetAccountType    == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurCredit      != 0
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                           == ledgerJournalTransFieldList.OffsetLedgerDimension
                            && dimAttrValueCombo.MainAccount                    == _mainAccountRecId
                    {
                        if (!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditMST();
                        }
                    }
                }
                else
                {
                // </GEERU>
                    while select LedgerDimension, Company, AmountCurDebit, CurrencyCode, TransDate, JournalNum,
                            Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum
                            && ledgerJournalTransFieldList.AccountType      == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurDebit   != 0
                            && ledgerJournalTransFieldList.Company          == _companyId
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                       == ledgerJournalTransFieldList.LedgerDimension
                            && dimAttrValueCombo.MainAccount                == _mainAccountRecId
                    {
                        balanceSheet += ledgerJournalTransFieldList.calcDebitMST();
                    }

                    while select OffsetLedgerDimension, OffsetCompany, AmountCurCredit, CurrencyCode, JournalNum,
                            TransDate, Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum            == this.JournalNum
                            && ledgerJournalTransFieldList.OffsetAccountType    == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurCredit      != 0
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                           == ledgerJournalTransFieldList.OffsetLedgerDimension
                            && dimAttrValueCombo.MainAccount                    == _mainAccountRecId
                    {
                        if (!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditMST();
                        }
                    }
                }
            }
            else
            {
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
                {
                    while select LedgerDimension, Company, OffsetLedgerDimension, OffsetCompany, AmountCurDebit, AmountCurCredit,
                             CurrencyCode, TransDate, Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum, VatDueDate_W, DocumentDate, TaxGroup
                             from ledgerJournalTransFieldList
                        index hint NumVoucherIdx
                        where ledgerJournalTransFieldList.JournalNum         == this.JournalNum              &&
                        ((ledgerJournalTransFieldList.LedgerDimension        == _dimensionDynamicAccount     &&
                          ledgerJournalTransFieldList.AccountType            == _ledgerJournalACType         &&
                          ledgerJournalTransFieldList.AmountCurDebit         != 0)                           ||
                         (ledgerJournalTransFieldList.OffsetLedgerDimension  == _dimensionDynamicAccount     &&
                          ledgerJournalTransFieldList.OffsetAccountType      == _ledgerJournalACType         &&
                          ledgerJournalTransFieldList.AmountCurCredit        != 0))
                    {
                        if (ledgerJournalTransFieldList.LedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.Company    == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitMST();
                        }
                        if (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount &&
                            (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) == false ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId))
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditMST();
                        }
                    }
                }
                else
                {
                // </GEERU>
                    while select LedgerDimension, Company, OffsetLedgerDimension, OffsetCompany, AmountCurDebit, AmountCurCredit,
                            CurrencyCode, TransDate, Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary,
                            JournalNum
                        from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum          &&
                        ((ledgerJournalTransFieldList.LedgerDimension       == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.AccountType           == _ledgerJournalACType     &&
                            ledgerJournalTransFieldList.AmountCurDebit        != 0)                       ||
                            (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.OffsetAccountType     == _ledgerJournalACType     &&
                            ledgerJournalTransFieldList.AmountCurCredit       != 0))
                    {
                        if (ledgerJournalTransFieldList.LedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.Company         == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitMST();
                        }
                        if (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount &&
                            (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) == false ||
                             ledgerJournalTransFieldList.OffsetCompany == _companyId))
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditMST();
                        }
                    }
                // <GEERU>
                }
                // </GEERU>
            }
        }

        return balanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalTotalAccountDebitReportingCurrency</Name>
				<Source><![CDATA[
    AmountMST journalTotalAccountDebitReportingCurrency(
        DimensionDynamicAccount _dimensionDynamicAccount,
        LedgerJournalACType     _ledgerJournalACType,
        CompanyId               _companyId = curext(),
        boolean                 _useMainAccountOnly = false,
        RecId                   _mainAccountRecId = 0)
    {
        LedgerJournalTrans                  ledgerJournalTransFieldList;
        AmountMST                           balanceSheet = 0;
        DimensionAttributeValueCombination  dimAttrValueCombo;      
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        if (this.JournalNum)
        {
            if (_useMainAccountOnly && _ledgerJournalACType == LedgerJournalACType::Ledger)
            {
                // Use only MainAccount for calculation
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
                {
                    while select LedgerDimension, Company, AmountCurDebit, CurrencyCode, TransDate, Triangulation, ExchRate, ExchRateSecond,
                            ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum, VatDueDate_W, DocumentDate, TaxGroup 
                            from ledgerJournalTransFieldList
                        index hint NumVoucherIdx
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum
                            && ledgerJournalTransFieldList.AccountType      == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurDebit   != 0
                            && ledgerJournalTransFieldList.Company          == _companyId
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                       == ledgerJournalTransFieldList.LedgerDimension
                            && dimAttrValueCombo.MainAccount                == _mainAccountRecId
                    {
                        balanceSheet += ledgerJournalTransFieldList.calcDebitReportingCurrency();
                    }

                    while select AccountType, OffsetLedgerDimension, OffsetCompany, AmountCurCredit, CurrencyCode, TransDate, Triangulation, 
                            ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum, VatDueDate_W, 
                            DocumentDate, TaxGroup from ledgerJournalTransFieldList
                        index hint NumVoucherIdx
                        where ledgerJournalTransFieldList.JournalNum            == this.JournalNum
                            && ledgerJournalTransFieldList.OffsetAccountType    == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurCredit      != 0
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                           == ledgerJournalTransFieldList.OffsetLedgerDimension
                            && dimAttrValueCombo.MainAccount                    == _mainAccountRecId
                    {
                        if (!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditReportingCurrency();
                        }
                    }
                }
                else
                {
                    // </GEERU>
                    while select LedgerDimension, Company, AmountCurDebit, CurrencyCode, TransDate, Triangulation, ExchRate,
                            ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum
                        from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum
                            && ledgerJournalTransFieldList.AccountType      == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurDebit   != 0
                            && ledgerJournalTransFieldList.Company          == _companyId
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                       == ledgerJournalTransFieldList.LedgerDimension
                            && dimAttrValueCombo.MainAccount                == _mainAccountRecId
                    {
                        balanceSheet += ledgerJournalTransFieldList.calcDebitReportingCurrency();
                    }

                    while select AccountType, OffsetLedgerDimension, OffsetCompany, AmountCurCredit, CurrencyCode, TransDate, Triangulation,
                            ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, JournalNum
                        from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum            == this.JournalNum
                            && ledgerJournalTransFieldList.OffsetAccountType    == _ledgerJournalACType
                            && ledgerJournalTransFieldList.AmountCurCredit      != 0
                    exists join RecId from dimAttrValueCombo
                        where dimAttrValueCombo.RecId                           == ledgerJournalTransFieldList.OffsetLedgerDimension
                            && dimAttrValueCombo.MainAccount                    == _mainAccountRecId
                    {
                        if (!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditReportingCurrency();
                        }
                    }                
                }
                // </GEERU>
            }
            else
            {
                //<GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
                {
                    while select AccountType, LedgerDimension, Company, OffsetLedgerDimension, OffsetCompany, AmountCurDebit, AmountCurCredit,
                            CurrencyCode, TransDate, Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, 
                            JournalNum, VatDueDate_W, DocumentDate, TaxGroup from ledgerJournalTransFieldList
                        index hint NumVoucherIdx
                        where ledgerJournalTransFieldList.JournalNum         == this.JournalNum              &&
                        ((ledgerJournalTransFieldList.LedgerDimension        == _dimensionDynamicAccount     &&
                          ledgerJournalTransFieldList.AccountType            == _ledgerJournalACType         &&
                          ledgerJournalTransFieldList.AmountCurDebit         != 0)                           ||
                         (ledgerJournalTransFieldList.OffsetLedgerDimension  == _dimensionDynamicAccount     &&
                          ledgerJournalTransFieldList.OffsetAccountType      == _ledgerJournalACType         &&
                          ledgerJournalTransFieldList.AmountCurCredit        != 0))
                    {
                        if (ledgerJournalTransFieldList.LedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.Company    == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitReportingCurrency();
                        }
                        if (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount &&
                            (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) == false ||
                            ledgerJournalTransFieldList.OffsetCompany == _companyId))
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditReportingCurrency();
                        }
                    }
                }
                else
                {
                    // </GEERU>
                    while select AccountType, LedgerDimension, Company, OffsetLedgerDimension, OffsetCompany, AmountCurDebit, AmountCurCredit,
                            CurrencyCode, TransDate,Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary,
                            JournalNum
                            from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum        == this.JournalNum          &&
                        ((ledgerJournalTransFieldList.LedgerDimension       == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.AccountType           == _ledgerJournalACType     &&
                            ledgerJournalTransFieldList.AmountCurDebit        != 0)                       ||
                            (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.OffsetAccountType     == _ledgerJournalACType     &&
                            ledgerJournalTransFieldList.AmountCurCredit       != 0))
                    {
                        if (ledgerJournalTransFieldList.LedgerDimension == _dimensionDynamicAccount &&
                            ledgerJournalTransFieldList.Company         == _companyId)
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcDebitReportingCurrency();
                        }
                        if (ledgerJournalTransFieldList.OffsetLedgerDimension == _dimensionDynamicAccount &&
                            (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) == false ||
                                ledgerJournalTransFieldList.OffsetCompany == _companyId))
                        {
                            balanceSheet += ledgerJournalTransFieldList.calcCreditReportingCurrency();
                        }
                    }                
                }
                // </GEERU>
            }
        }
        return balanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalName</Name>
				<Source><![CDATA[
    LedgerJournalName ledgerJournalName()
    {
        return LedgerJournalName::find(this.JournalName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTable_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>LedgerJournalTable_W</c> record associated with the current record.
    /// </summary>
    /// <returns>
    /// The <c>LedgerJournalTable_W</c> record associated with the current record.
    /// </returns>
    public LedgerJournalTable_W ledgerJournalTable_W()
    {
        return this.SysExtensionSerializerMap::getExtensionTable(tableNum(LedgerJournalTable_W), !this.Posted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logged</Name>
				<Source><![CDATA[
    display boolean logged()
    {
        return strlen(this.Log) > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mainAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the main account type of the voucher for the current journal.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher in the current journal to evaluate.
    /// </param>
    /// <returns>
    /// The main account type of the voucher.
    /// </returns>
    /// <remarks>
    /// The project account type is considered the most important type and overrules the other accounts.If
    /// more than one account is of type <c>Cust</c> or <c>Vend</c>, the main account is considered a
    /// <c>Ledger</c> account.
    /// </remarks>
    public LedgerJournalACType mainAccountType(Voucher _voucher)
    {
        LedgerJournalTrans  ledgerJournalTransFieldList;
        LedgerJournalACType accountType;
        Counter             counter;
        // <GEERU><GEEU>
        boolean             isCashModuleEnabled = RCashParameters::isCashModuleEnabled();
        // </GEERU></GEEU>

        accountType = LedgerJournalACType::Ledger;
        while select AccountType, OffsetAccountType, OffsetLedgerDimension from ledgerJournalTransFieldList
            group by AccountType, OffsetAccountType, OffsetLedgerDimension
            where ledgerJournalTransFieldList.JournalNum == this.JournalNum &&
                ledgerJournalTransFieldList.Voucher == _voucher &&
                (ledgerJournalTransFieldList.AccountType == LedgerJournalACType::Project ||
                    ledgerJournalTransFieldList.AccountType == LedgerJournalACType::Cust ||
                    ledgerJournalTransFieldList.AccountType == LedgerJournalACType::Vend ||
                    // <GEERU><GEEU>
                    ledgerJournalTransFieldList.AccountType == LedgerJournalACType::RCash ||
                    ledgerJournalTransFieldList.OffsetAccountType == LedgerJournalACType::RCash ||
                    ledgerJournalTransFieldList.AccountType == LedgerJournalACType::Employee_RU ||
                    ledgerJournalTransFieldList.OffsetAccountType == LedgerJournalACType::Employee_RU ||
                    // </GEERU></GEEU>
                    ledgerJournalTransFieldList.OffsetAccountType == LedgerJournalACType::Project ||
                    ledgerJournalTransFieldList.OffsetAccountType == LedgerJournalACType::Cust ||
                    ledgerJournalTransFieldList.OffsetAccountType == LedgerJournalACType::Vend)
        {
            if (ledgerJournalTransFieldList.AccountType == LedgerJournalACType::Project ||
                (ledgerJournalTransFieldList.OffsetAccountType == LedgerJournalACType::Project &&
                 ledgerJournalTransFieldList.OffsetLedgerDimension))
            {
                accountType = LedgerJournalACType::Project;
                break;
            }

            if (accountType != ledgerJournalTransFieldList.AccountType &&
                (ledgerJournalTransFieldList.AccountType    == LedgerJournalACType::Cust ||
                 ledgerJournalTransFieldList.AccountType    == LedgerJournalACType::Vend
                 // <GEERU><GEEU>
                 || ledgerJournalTransFieldList.AccountType == LedgerJournalACType::Employee_RU
                 || (isCashModuleEnabled
                    && (ledgerJournalTransFieldList.AccountType          == LedgerJournalACType::RCash
                        && ledgerJournalTransFieldList.OffsetAccountType != LedgerJournalACType::Cust
                        && ledgerJournalTransFieldList.OffsetAccountType != LedgerJournalACType::Vend))
                 // </GEERU></GEEU>
                 ))
            {
                accountType = ledgerJournalTransFieldList.AccountType;
                counter++;
            }

            if (accountType != ledgerJournalTransFieldList.OffsetAccountType &&
               (ledgerJournalTransFieldList.OffsetAccountType   == LedgerJournalACType::Cust ||
                ledgerJournalTransFieldList.OffsetAccountType   == LedgerJournalACType::Vend
                // <GEERU><GEEU>
                || ledgerJournalTransFieldList.OffsetAccountType == LedgerJournalACType::Employee_RU
                || (isCashModuleEnabled
                    && (ledgerJournalTransFieldList.OffsetAccountType == LedgerJournalACType::RCash
                        && ledgerJournalTransFieldList.AccountType    != LedgerJournalACType::Cust
                        && ledgerJournalTransFieldList.AccountType    != LedgerJournalACType::Vend))
                // </GEERU></GEEU>
                ))
            {
                accountType = ledgerJournalTransFieldList.OffsetAccountType;
                counter++;
            }

            if (counter > 1)
            {
                accountType = LedgerJournalACType::Ledger;
                break;
            }
        }

        return accountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markApproved</Name>
				<Source><![CDATA[
    boolean markApproved()
    {
        // <GJP>
        #isoCountryRegionCodes
        // </GJP>

        boolean     ret;
        UserGroupId approveGroupId = this.ledgerJournalName().ApproveGroupId;
        // <GCN>
        LedgerJournalTable_W ledgerJournalTable_W;
        // </GCN>

        if (UserInfoHelp::userInUserGroup(curUserId(), approveGroupId))
        {
            this.Approver = HcmWorker::userId2Worker(curUserId());

            if (!this.Approver)
            {
                throw error("@SYS335749");
            }

            this.RejectedBy = '';

            // <GCN>
            if ((this.JournalType == LedgerJournalType::Daily
                || this.JournalType == LedgerJournalType::Assets)
                && LedgerParameters::isJournalApproval_CN())
            {
                ledgerJournalTable_W = this.ledgerJournalTable_W();
                ledgerJournalTable_W.ApprovalStatus_CN = LedgerApprovalStatus_CN::Approved;
                this.packLedgerJournalTable_W(ledgerJournalTable_W);
            }
            // </GCN>

            // <GJP>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP])
                && this.JournalType == LedgerJournalType::CustPayment)
            {
                LedgerJournalTrans::updateApproveJBAPayment(this.Approver, this.JournalNum);
            }
            // </GJP>

            ret = true;
        }
        else
        {
            throw error(strFmt("@SYS28634", approveGroupId));
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markRejected</Name>
				<Source><![CDATA[
    void markRejected()
    {
        UserGroupId approveGroupId = this.ledgerJournalName().ApproveGroupId;
        // <GCN>
        LedgerJournalTable_W ledgerJournalTable_W;
        // </GCN>

        if (UserInfoHelp::userInUserGroup(curUserId(), approveGroupId))
        {
            this.RejectedBy = curUserId();

            // <GCN>
            if (this.JournalType == LedgerJournalType::Daily
                && LedgerParameters::isJournalApproval_CN())
            {
                ledgerJournalTable_W = this.ledgerJournalTable_W();
                ledgerJournalTable_W.ApprovalStatus_CN = LedgerApprovalStatus_CN::Rejected;
                this.packLedgerJournalTable_W(ledgerJournalTable_W);

                this.ReportedAsReadyBy = '';
            }
            // </GCN>
            this.Approver = 0;
        }
        else
        {
            throw error(strFmt("@SYS26739",approveGroupId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markReportAsReady</Name>
				<Source><![CDATA[
    void markReportAsReady()
    {
        // <GCN>
        LedgerJournalTable_W ledgerJournalTable_W;
        // </GCN>

        this.ReportedAsReadyBy = curUserId();
        this.RejectedBy = '';

        // <GCN>
        if ((this.JournalType == LedgerJournalType::Daily
            || this.JournalType == LedgerJournalType::Assets)
            && LedgerParameters::isJournalApproval_CN())
        {
            ledgerJournalTable_W = this.ledgerJournalTable_W();
            ledgerJournalTable_W.ApprovalStatus_CN = LedgerApprovalStatus_CN::Ready;
            this.packLedgerJournalTable_W(ledgerJournalTable_W);
        }
        // </GCN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>markUserPrivate</Name>
				<Source><![CDATA[
    void markUserPrivate()
    {
        this.UserBlockId  = this.UserBlockId  ? '' : curUserId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCheckDeduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// If any journal lines have deductions insure those journal lines
    ///  1) Are payments (credit)
    ///  2) Have transactions marked for settlement
    ///  3) Total of transactions marked for settlement is positive
    ///  4) Are short pays (journal line amount does not fully settle transactions)
    ///
    ///  If deductions are required to fully settle transactions also check that parent payment journal
    ///  line amount plus sum of of its deductions fully settles the transactions.
    /// </summary>
    /// <returns>
    /// true if above conditions are met; Otherwise, false
    /// </returns>
    private boolean mcrCheckDeduction()
    {
        CustParameters              custParameters;
        TAMDeduction                tamDeduction;
        LedgerJournalTrans          ledgerJournalTransParent;
        AmountMST                   paymentAmountMST;
        AmountMST                   specAmountMST;
        AmountMST                   remainAmountMST;
        AmountMST                   deductionAmountMST;
        CurrencyCode                companyCurrency;
        boolean                     ret = true;

        // Only need to check if journal has deduction
        if (! this.mcrHasDeduction())
        {
            return ret;
        }

        companyCurrency = Ledger::accountingCurrency(CompanyInfo::current());
        custParameters = CustParameters::find();

        setPrefix(strFmt("@SYS26909", this.JournalNum));

        while select ledgerJournalTransParent
            where ledgerJournalTransParent.JournalNum == this.JournalNum
            join TableId from tamDeduction
                where ledgerJournalTransParent.RecId == tamDeduction.LedgerJournalTransParentRecId
        {
            setPrefix(strFmt("@SYS25866", ledgerJournalTransParent.Voucher));

            // Must specify positive credit amount
            if (ledgerJournalTransParent.AmountCurCredit <= 0)
            {
                ret = checkFailed("@MCR27502");
                continue;
            }

            // Enable if line has positive amount to settle and line does not cover (short pay)

            // Transactions must be marked for settlement
            if (SpecTrans::getSpecTransCount(curext(),
                                             ledgerJournalTransParent.TableId,
                                             ledgerJournalTransParent.RecId) == 0)
            {
                ret = checkFailed("@MCR27506");
                continue;
            }

            // Settle amount
            // Use new SpecTransManager class to calc specAmount
            specAmountMST = SpecTransManager::getTotalSettleAmountForSpecReference(
                curext(),
                ledgerJournalTransParent.TableId,
                ledgerJournalTransParent.RecId,
                companyCurrency,
                ledgerJournalTransParent.Company,
                ledgerJournalTransParent.TransDate);

            // Settle amount has to be greater than zero
            if (specAmountMST < 0)
            {
                ret = checkFailed("@MCR27507");
                continue;
            }

            // Payment amount
            paymentAmountMST = ledgerJournalTransParent.calcAmountMST();

            // Deduction amount negated
            deductionAmountMST = TAMDeduction::sumDeductionAmountMST(ledgerJournalTransParent.RecId);
            deductionAmountMST = - deductionAmountMST;

            // Remaining amount should not be negative (deduction and payment should not leave a credit
            // for the customer)
            remainAmountMST = specAmountMST + paymentAmountMST +  deductionAmountMST;
            if (remainAmountMST < 0)
            {
                ret = checkFailed(strFmt("@MCR27503",
                                         abs(paymentAmountMST),
                                         abs(deductionAmountMST),
                                         specAmountMST));
                continue;
            }

            // If require full settlement then remaining amount must be less than penny difference
            if (custParameters.tamDeductionRequireFullSettle
                && custParameters.MaxMSTDiff < remainAmountMST)
            {
                ret = checkFailed(strFmt("@MCR27504",
                                         abs(paymentAmountMST),
                                         abs(deductionAmountMST),
                                         specAmountMST));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCheckPaymentDeclined</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if any payments are declined
    /// </summary>
    /// <returns>
    /// true if any payments have a status of declined
    /// </returns>
    private boolean  mcrCheckPaymentDeclined()
    {
        LedgerJournalTrans  ledgerJournalTrans;
        MCRCustPaymTable    custPaymTable;
        boolean             paymDeclined;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == this.JournalNum
                join RecId from custPaymTable
                    where custPaymTable.RefRecId   == ledgerJournalTrans.RecId
                       && custPaymTable.RefTableId == ledgerJournalTrans.TableId
                       && custPaymTable.Status     == MCRCustPaymStatus::Declined;

        if (ledgerJournalTrans.RecId)
        {
            paymDeclined =true;
        }
        else
        {
            paymDeclined =false;
        }
        return paymDeclined;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCheckPaymentNotAuthorized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if any payments are not authorized.
    /// </summary>
    /// <returns>
    /// true if any payments do not have an authorized status.
    /// </returns>
    public boolean  mcrCheckPaymentNotAuthorized()
    {
        LedgerJournalTrans  ledgerJournalTrans;
        MCRCustPaymTable    custPaymTable;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == this.JournalNum
                join RecId from custPaymTable
                    where custPaymTable.RefRecId   == ledgerJournalTrans.RecId
                       && custPaymTable.RefTableId == ledgerJournalTrans.TableId
                       && custPaymTable.Status     != MCRCustPaymStatus::Authorized;

        if (ledgerJournalTrans.RecId)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDisplayDepositSlipNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the deposit number for a journal if one exist on the <c>LedgerJournalTable</c> table.
    /// </summary>
    /// <returns>
    /// the deposit number for a journal if one exist on the <c>LedgerJournalTable</c> table
    /// </returns>
    display BankDepositNum mcrDisplayDepositSlipNum()
    {
        LedgerJournalTrans tLedgerJournalTrans;

        select firstonly BankDepositNum from tLedgerJournalTrans
            where tLedgerJournalTrans.JournalNum == this.JournalNum &&
            tLedgerJournalTrans.BankDepositNum !="";

        return tLedgerJournalTrans.BankDepositNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrHasDeduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>TAMDeduction</c> table.
    /// </summary>
    /// <returns>
    /// true if there is at least one journal line that represents a deduction.
    /// </returns>
    /// <remarks>
    /// Note that other journals posted for deduction updates (matching, denying, write-off etc.) will
    ///  have journal lines that are related to deductions but the sense of this method is the deduction
    ///  as originally posted.  Currently only the customer payment journal can have a deduction in this
    ///  sense.
    /// </remarks>
    public boolean mcrHasDeduction()
    {
        LedgerJournalTrans  ledgerJournalTrans;
        TAMDeduction        tamDeduction;
        boolean             hasDeduction;

        if (this.JournalType == LedgerJournalType::CustPayment)
        {
            select firstonly RecId from tamDeduction
                join TableId from ledgerJournalTrans
                where tamDeduction.LedgerJournalTransParentRecId == ledgerJournalTrans.RecId
                   && ledgerJournalTrans.JournalNum           == this.JournalNum;
            if (tamDeduction.RecId)
            {
                hasDeduction = true;
            }
        }
        return hasDeduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {        
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(LedgerJournalTable, LedgerJournalInclTax):
                // Update lines 'include sales tax' accordind to header when tax information is enabled.
                if (TaxIntegrationUtils::isTaxInformationEnabled())
                {
                    if (Box::confirm(this.LedgerJournalInclTax ? "@TaxGST:MarkAmountsIncludeSalesTaxForGeneralJournal" : "@TaxGST:UnmarkAmountsIncludeSalesTaxForGeneralJournal"))
                    {
                        ttsbegin;
                        LedgerJournalTrans  ledgerJournalTrans;
                        TransTaxInformation transTaxInformation;

                        while select ledgerJournalTrans
                            where ledgerJournalTrans.JournalNum == this.JournalNum
                        {
                            transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(ledgerJournalTrans);
                            if (transTaxInformation)
                            {
                                transTaxInformation.selectForUpdate(true);
                                transTaxInformation.InclTax = this.LedgerJournalInclTax;
                                transTaxInformation.update();
                            }

                            // Mark dirty for recalculation.
                            ledgerJournalTrans.markCurrentTaxDocumentTaxStatusDirty();
                        }
                        ttscommit;
                    }
                    else
                    {
                        // Select 'No', don't update header and lines.
                        this.LedgerJournalInclTax = !this.LedgerJournalInclTax;
                    }
                }
                break;

            case fieldNum(LedgerJournalTable, OffsetAccountType):
                this.OffsetLedgerDimension = 0;
                break;

            case fieldNum(LedgerJournalTable, CurrencyCode):
                if (this.CurrencyCode)
                {                                       
                    this.ExchRate = ExchangeRateHelper::getExchangeRate1_Static(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                        this.CurrencyCode,
                        DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                    this.ExchrateSecondary = ExchangeRateHelper::getExchangeRate2_Static(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                        this.CurrencyCode,
                        DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                    
                    if (Ledger::reportingCurrency())
                    {
                        this.ReportingCurrencyExchRate = ExchangeRateCalculation::getExchangeRate1_Static(Ledger::reportingCurrencyExchangeRateType(),
                                                        this.CurrencyCode,
                                                        Ledger::reportingCurrency(),
                                                        DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                        this.ReportingCurrencyExchRateSecondary = ExchangeRateCalculation::getExchangeRate2_Static(Ledger::reportingCurrencyExchangeRateType(),
                                                        this.CurrencyCode,
                                                        Ledger::reportingCurrency(),
                                                        DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                    }
                    this.euroTriangulation  = NoYes::No;
                }
                break;

            case fieldNum(LedgerJournalTable, ReverseEntry):
                if (!this.ReverseEntry)
                {
                    this.ReverseDate = dateNull();
                }
                break;

            case fieldNum(LedgerJournalTable, DelayTaxCalculation):
                LedgerJournalTrans ledgerJournalTrans;

                ttsbegin;
                ledgerJournalTrans.skipDataMethods(true);
                ledgerJournalTrans.skipEvents(true);

                update_recordset ledgerJournalTrans
                    setting DelayTaxCalculation = this.DelayTaxCalculation
                    where ledgerJournalTrans.JournalNum == this.JournalNum;
                
                if (this.DelayTaxCalculation)
                {
                    TaxUncommitted taxUncommitted;

                    delete_from taxUncommitted
                        where taxUncommitted.HeadingTableId == tableNum(LedgerJournalTable)
                        && taxUncommitted.HeadingRecId == this.RecId;
                }
                else
                {
                    this.disableDelayTaxCalcualtion();
                }
                ttscommit;
               
                break;

            case fieldNum(LedgerJournalTable, JournalName):
                this.inheritBankTransSummarizationConfigurationFromJournalName();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Counts the number of lines in a journal.
    /// </summary>
    /// <returns>
    ///    A <c>Counter</c> object indicating the number of lines in the journal.
    /// </returns>
    /// <remarks>
    ///    The <c>LedgerJournalTable</c> table does contain a <c>NumOfLines</c> field that is designed to keep track of the number of lines in a journal. However, this field is not updated before ledger
    ///    journals are integrated with the new journal framework.
    /// </remarks>
    public Counter numOfLines()
    {
        return any2int((select count(RecId) from ledgerJournalTrans where ledgerJournalTrans.JournalNum == this.JournalNum).RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfVouchers</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Counts the number of unique voucher numbers in the journal.
    /// </summary>
    /// <returns>
    ///    A <c>counter</c> indicating the number of unique voucher numbers.
    /// </returns>
    public Counter numOfVouchers()
    {
        SysDictTable journalTransTable = new SysDictTable(tableNum(LedgerJournalTrans));
        FieldName voucherField = journalTransTable.fieldName(fieldNum(LedgerJournalTrans, Voucher));
        FieldName journalNumField = journalTransTable.fieldName(fieldNum(LedgerJournalTrans, JournalNum));
        FieldName dataAreaField = journalTransTable.fieldName(fieldNum(LedgerJournalTrans, DataAreaId));
        FieldName partitionField = journalTransTable.fieldName(fieldNum(LedgerJournalTrans, Partition));

        str sql = 'select count(distinct %1) from %2 where %3 = %4 and %5 = %6 and %7 = %8';

        sql = strFmt(sql,
                     voucherField,
                     journalTransTable.name(),
                     journalNumField,
                     '@JournalNum',
                     dataAreaField,
                     '@DataAreaId',
                     partitionField,
                     '@Partition');
        
        Map paramMap = SqlParams::create();
        paramMap.add('JournalNum', this.JournalNum);
        paramMap.add('DataAreaId', this.DataAreaId);
        paramMap.add('Partition', getcurrentpartitionrecid());

        SqlStatementExecutePermission permission = new SqlStatementExecutePermission(sql);
        permission.assert();

        //Setup the connection needed to send the command to SQL Server.
        Connection userConnection = new Connection();
        Statement stmt = userConnection.createStatement();

        ResultSet sqlres = stmt.executeQueryWithParameters(sql, paramMap);
        CodeAccessPermission::revertAssert();

        //Select queries record
        sqlres.next();

        return sqlres.getInt(1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>packLedgerJournalTable_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the <c>LedgerJournalTable_W</c> record associated with the current record.
    /// </summary>
    /// <param name="_ledgerJournalTable_W">
    /// The <c>_ledgerJournalTable_W</c> record.
    /// </param>
    public void packLedgerJournalTable_W(LedgerJournalTable_W _ledgerJournalTable_W)
    {
        _ledgerJournalTable_W.LedgerJournalTable = this.RecId;

        this.SysExtensionSerializerMap::packExtensionTable(_ledgerJournalTable_W);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOffsetAccount</Name>
				<Source><![CDATA[
    public LedgerJournalAC parmOffsetAccount(LedgerJournalAC _account = '', LedgerJournalACType _accountType = this.OffsetAccountType)
    {
        DimensionAttributeValueCombination  davc;
        LedgerJournalAC                     account;

        if (!prmisDefault(_accountType))
        {
            this.OffsetAccountType = _accountType;
        }

        if (!prmisDefault(_account))
        {
            // If account has been changed, update the backing ledger dimension value
            if (_account)
            {
                this.OffsetLedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_account, _accountType);
                account = _account;
            }
            else
            {
                account = '';
                this.OffsetLedgerDimension = 0;
            }
        }
        else if (this.OffsetLedgerDimension)
        {
            // If the account has not been changed, then pull the value from DAVC as the master
            select firstonly DisplayValue from davc
                where davc.RecId == this.OffsetLedgerDimension;
            account = davc.DisplayValue;
        }

        return account;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOffsetLedgerDimension</Name>
				<Source><![CDATA[
    public DimensionDynamicDefaultAccount parmOffsetLedgerDimension(DimensionDynamicDefaultAccount _ledgerDimension = this.OffsetLedgerDimension)
    {
        this.OffsetLedgerDimension = _ledgerDimension;
        return this.OffsetLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsInitFromledgerJournalName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>LedgerJournalTable</c> record with the values from <c>LedgerJournalName</c>
    /// record.
    /// </summary>
    /// <param name="_ledgerJournalName">
    /// The <c>LedgerJournalName</c> record.
    /// </param>
    /// <returns>
    /// The <c>LedgerJournalTable</c> record.
    /// </returns>
    public LedgerJournalTable pdsInitFromledgerJournalName(
        LedgerJournalName _ledgerJournalName)
    {
        ExchangeRateHelper  exchangeRateHelper;
        LedgerJournalName   ledgerJournalName;
        LedgerJournalTable  ledgerJournalTable;

        ledgerJournalTable.JournalName              = _ledgerJournalName.JournalName;

        ledgerJournalName                           = _ledgerJournalName;

        ledgerJournalTable.Name                     = ledgerJournalName.Name;
        ledgerJournalTable.NumberSequenceTable      = ledgerJournalName.NumberSequenceTable;

        ledgerJournalTable.OffsetLedgerDimension    = ledgerJournalName.OffsetLedgerDimension;
        ledgerJournalTable.OffsetAccountType        = ledgerJournalName.OffsetAccountType;
        ledgerJournalTable.JournalType              = ledgerJournalName.JournalType;
        ledgerJournalTable.DocumentNum              = ledgerJournalName.DocumentNum;
        ledgerJournalTable.FixedExchRate            = ledgerJournalName.FixedExchRate;
        ledgerJournalTable.DetailSummaryPosting     = ledgerJournalName.DetailSummary;
        ledgerJournalTable.FixedOffsetAccount       = ledgerJournalName.FixedOffsetAccount;
        ledgerJournalTable.CurrencyCode             = ledgerJournalName.CurrencyCode;
        ledgerJournalTable.CurrentOperationsTax     = ledgerJournalName.CurrentOperationsTax;
        ledgerJournalTable.DefaultDimension         = ledgerJournalName.DefaultDimension;
        ledgerJournalTable.Name                     = ledgerJournalName.Name;
        ledgerJournalTable.LedgerJournalInclTax     = ledgerJournalName.LedgerJournalInclTax;
        ledgerJournalTable.OverrideSalesTax         = ledgerJournalName.OverrideSalesTax;

        if (ledgerJournalTable.CurrencyCode)
        {
            exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerJournalTable.CurrencyCode);
            ledgerJournalTable.ExchRate = exchangeRateHelper.getExchangeRate1();
            ledgerJournalTable.ExchrateSecondary = exchangeRateHelper.getExchangeRate2();
        }

        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateTaxesForJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Removes the <c>TaxUncommitted</c> records and recalculates taxes for the journal.
    /// </summary>
    private void recalculateTaxesForJournal()
    {
        TaxUncommitted::deleteForDocumentHeader(this.TableId, this.RecId, false);

        // recalculate taxes for the entire Journal
        LedgerJournalEngine_Server::calculateTaxForCompleteJournal(this.JournalNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>rejected</Name>
				<Source><![CDATA[
    boolean rejected()
    {
        return (this.RejectedBy || ! this.ledgerJournalName().ApproveActive);
    }

]]></Source>
			</Method>
			<Method>
				<Name>rejectedName</Name>
				<Source><![CDATA[
    display UserName rejectedName()
    {
        return this.RejectedBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportedAsReady</Name>
				<Source><![CDATA[
    boolean reportedAsReady()
    {
        // <GCN>
        if (this.JournalType == LedgerJournalType::Daily
            && LedgerParameters::isJournalApproval_CN())
        {
            return (this.ReportedAsReadyBy
                || !this.ledgerJournalName().ApproveActive);
        }
        else
        {
        // </GCN>
            return ((this.ReportedAsReadyBy && ! this.RejectedBy) || ! this.ledgerJournalName().ApproveActive);
        // <GCN>
        }
        // </GCN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportedAsReadyName</Name>
				<Source><![CDATA[
    display UserName reportedAsReadyName()
    {
        return this.ReportedAsReadyBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultDimension</Name>
				<Source><![CDATA[
    public void setDefaultDimension(LedgerJournalName _ledgerJournalName)
    {
        if (_ledgerJournalName != null)
        {
            this.DefaultDimension = _ledgerJournalName.DefaultDimension;
        }
        else
        {
            this.DefaultDimension = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEndBalance</Name>
				<Source><![CDATA[
    void setEndBalance(LedgerJournalEndBalance _ledgerJournalEndBalance)
    {
        this.EndBalance = _ledgerJournalEndBalance;
        this.overwriteSystemfields(true);
        this.update();
        this.overwriteSystemfields(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFacturedFully_RU</Name>
				<Source><![CDATA[
    public void setFacturedFully_RU(FacturedFully_RU _factured)
    {
        // do nothing
    }

]]></Source>
			</Method>
			<Method>
				<Name>setJournalBalance</Name>
				<Source><![CDATA[
    void setJournalBalance(LedgerJournalBalance _ledgerJournalBalance)
    {
        this.JournalBalance = _ledgerJournalBalance;
        this.overwriteSystemfields(true);
        this.update();
        this.overwriteSystemfields(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setToOpenValue_CN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Set the current journal to open status.
    /// </summary>
    public void setToOpenValue_CN()
    {
        LedgerJournalTable_W ledgerJournalTable_W;

        this.ReportedAsReadyBy  = '';
        this.Approver           = 0;

        this.RejectedBy         = '';

        ledgerJournalTable_W = this.ledgerJournalTable_W();
        ledgerJournalTable_W.ApprovalStatus_CN = LedgerApprovalStatus_CN::Open;
        this.packLedgerJournalTable_W(ledgerJournalTable_W);
    }

]]></Source>
			</Method>
			<Method>
				<Name>type</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>LedgerJournalTableType</c> derivative for the <c>LedgerJournalTable</c> table.
    /// </summary>
    /// <returns>
    /// A <c>LedgerJournalTableType</c> derivative.
    /// </returns>
    private LedgerJournalTableType type()
    {
        return LedgerJournalTableType::construct(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        boolean recalculateTax;

        if (this.LedgerJournalInclTax != this.orig().LedgerJournalInclTax
            || this.TaxObligationCompany != this.orig().TaxObligationCompany
            || this.haveTaxesChangedForTaxIntegration())
        {
            recalculateTax = true;
        }

        // Delete any journal line error records
        if (this.Posted == NoYes::Yes && this.orig().Posted == NoYes::No)
        {
            LedgerJournalTrans_Error::deleteJournalErrorLinks(this.JournalNum);
        }

        this.defaultReportingCurrencyExchangeRateIfSameCurrencies();

		super();

        // <GCN>
        this.SysExtensionSerializerMap::postUpdate();
        // </GCN>

        if (recalculateTax)
        {
            this.recalculateTaxesForJournal();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>haveTaxesChangedForTaxIntegration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if taxes may have changed for the <c>LedgerJournalTable</c> under tax service integration.
    /// </summary>
    /// <param name = "_originalLedgerJournalTable">
    /// The original <c>LedgerJournalTable</c> table record.
    /// </param>
    /// <returns>
    /// true if taxes may have changed; otherwise, false.
    /// </returns>
    protected boolean haveTaxesChangedForTaxIntegration(LedgerJournalTable _originalLedgerJournalTable = this.orig())
    {
        boolean isTaxChangedForTaxIntegration = false;
        if (this.isTaxIntegrationEnabled())
        {
            isTaxChangedForTaxIntegration = this.CurrencyCode != _originalLedgerJournalTable.CurrencyCode
                || this.JournalName != _originalLedgerJournalTable.JournalName;
        }
        return isTaxChangedForTaxIntegration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>userBlockIdName</Name>
				<Source><![CDATA[
    display JournalBlockUserId userBlockIdName()
    {
        return this.UserBlockId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the value for a field.
    /// </summary>
    /// <param name="p1">
    /// The field ID that corresponds to the field to validate.
    /// </param>
    /// <returns>s
    /// true if the field is valid; otherwise, false .
    /// </returns>
    public boolean validateField(FieldId p1)
    {
        boolean isValid = true;
        LedgerJournalTableType ledgerJournalTableType;

        ledgerJournalTableType = this.type();

        if (ledgerJournalTableType)
        {
            isValid = ledgerJournalTableType.validateField(p1);
        }

        if (isValid)
        {
            isValid = super(p1);
        }

        if (isValid)
        {
            switch (p1)
            {
                case fieldNum(LedgerJournalTable, LinesLimitBeforeDistribution) :
                    if (!LedgerJournalForcedJournalSplitFeature::isEnabled()
                        && this.LinesLimitBeforeDistribution > LedgerJournalName::maxLimitOfLinesBeforeDistribution())
                    {
                        isValid = checkFailed(strFmt("@SYS86512", LedgerJournalName::maxLimitOfLinesBeforeDistribution()));
                    }
                    break;

                case fieldNum(LedgerJournalTable, OffsetLedgerDimension):
                    if (this.OffsetAccountType == LedgerJournalACType::Bank)
                    {
                        if (this.parmOffsetAccount())
                        {
                            isValid = BankAccountTable::checkIsActive(this.parmOffsetAccount());
                        }
                    }
                    break;

                case (fieldNum(LedgerJournalTable, TaxObligationCompany)) :
                    if (this.TaxObligationCompany == TaxObligationCompany::Source && TaxParameters::find().PurchTaxOnOperations)
                    {
                        isValid = checkFailed("@SYS4003093");
                    }
                    break;

                case fieldNum(LedgerJournalTable, BankAccountId):
                    if (this.BankAccountId)
                    {
                        isValid = BankAccountTable::checkIsActive(this.BankAccountId);
                    }
                    break;

                case fieldNum(LedgerJournalTable, JournalName):
                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && this.JournalName == CustParameters::find().CollectionsWriteOffLedgerJournalName)
                    {
                        isValid = checkFailed("@SPS2429");
                    }
                    break;

                case fieldNum(LedgerJournalTable, BankTransSummarizationEnabled):
                    if (this.BankTransSummarizationEnabled)
                    {
                        LedgerJournalName ledgerJournalName = LedgerJournalName::find(this.JournalName);
                        if (ledgerJournalName.NewVoucher != NewVoucher::BalanceSheet)
                        {
                            isValid = checkFailed("@CashManagement:SummarizationErrorMessage");
                        }

                        NumberSequenceReference reference = BankParameters::numRefSummarizationID();
                        if (!reference || !reference.NumberSequenceId)
                        {
                            isValid = checkFailed(strfmt("@SYS26165", "@CashManagement:BankTransSummarizationID"));
                        }
                    }
                    break;
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    boolean validateWrite(JournalTableData  _journalTableData = JournalTableData::newTable(this))
    {
        boolean ret = true;

        ret = _journalTableData.validateWritePre(ret);

        ret = ret && super();

        if (ret)
        {
            if ((this.JournalType == LedgerJournalType::PurchaseLedger ||
                 this.JournalType == LedgerJournalType::Approval)      &&
                (this.OffsetLedgerDimension || this.OffsetAccountType))
            {
                ret = checkFailed(strFmt("@SYS27049",this.JournalType));
            }

            if (ret  && Ledger::isReportingCurrencySameAsAccountingCurrency())
            {
                if (this.ReportingCurrencyExchRate != this.ExchRate)
                {
                    ret = checkFailed(strFmt("@GeneralLedger:ExchangeRateMismatchForSameLedgerCurrency", Ledger::accountingCurrency(), Ledger::reportingCurrency()));
                }

                if (this.ReportingCurrencyExchRateSecondary != this.ExchrateSecondary)
                {
                    ret = checkFailed(strFmt("@GeneralLedger:SecondaryExchangeRateMismatchForSameLedgerCurrency", Ledger::accountingCurrency(), Ledger::reportingCurrency()));
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>aggregateLedgerJournalTrans</Name>
				<Source><![CDATA[
    public static void aggregateLedgerJournalTrans(LedgerJournalId _ledgerJournalId)
    {
        CustVendPaymModeTable   custVendPaymModeTable;
        LedgerJournalTrans      ledgerJournalTrans;
        LedgerJournalTrans      ledgerJournalTransAggr;
        SpecTrans               specTrans;
        RecId                   masterRecid;
        AmountCur               totalAmountCur;
        boolean                 hasAggregated;
        PaymSpec                paymSpec;
        // <GBR>
        LedgerJournalTransPayment_BR paymentAggr_br;
        LedgerJournalTransPayment_BR payment_br;
        // </GBR>

        // for each set of record in the group by, count their number and sum the values
        while select count(RecId), sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransAggr
            group by LedgerDimension, CurrencyCode, PaymMode, PostingProfile, TransDate, PaymSpec, PaymId
                where ledgerJournalTransAggr.JournalNum == _ledgerJournalId
            // <GBR>
            outer join sum(FineAmountCur_BR),sum(FinInterestAmountCur_BR) from paymentAggr_br
                where paymentAggr_br.RefRecId == ledgerJournalTransAggr.RecId
            // </GBR>
        {
            totalAmountCur =  ledgerJournalTransAggr.AmountCurCredit - ledgerJournalTransAggr.AmountCurDebit;

            if (ledgerJournalTransAggr.RecId > 1)
            {
                ttsbegin;

                masterRecid = 0;
                hasAggregated = false;
                while select forupdate ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum     == _ledgerJournalId                         &&
                        ledgerJournalTrans.LedgerDimension== ledgerJournalTransAggr.LedgerDimension   &&
                        ledgerJournalTrans.CurrencyCode   == ledgerJournalTransAggr.CurrencyCode      &&
                        ledgerJournalTrans.PaymMode       == ledgerJournalTransAggr.PaymMode          &&
                        ledgerJournalTrans.PostingProfile == ledgerJournalTransAggr.PostingProfile    &&
                        ledgerJournalTrans.TransDate      == ledgerJournalTransAggr.TransDate         &&
                        ledgerJournalTrans.PaymSpec       == ledgerJournalTransAggr.PaymSpec          &&
                        ledgerJournalTrans.PaymId         == ledgerJournalTransAggr.PaymId
                {
                    custVendPaymModeTable = CustVendPaymModeTable::findCommon(ledgerJournalTrans);

                    if ((custVendPaymModeTable.PaymSumBy == PaymSumBy::Total)
                        || (custVendPaymModeTable.PaymSumBy == PaymSumBy::TransDate)
                        || (custVendPaymModeTable.PaymSumBy == PaymSumBy::Week))
                    {
                        if (masterRecid == 0) // found the new "master"
                        {
                            // use the SUM() values
                            if (totalAmountCur < 0)
                            {
                                ledgerJournalTrans.AmountCurDebit  = -totalAmountCur;
                                ledgerJournalTrans.AmountCurCredit = 0;
                            }
                            else
                            {
                                ledgerJournalTrans.AmountCurCredit = totalAmountCur;
                                ledgerJournalTrans.AmountCurDebit  = 0;
                            }
                            // <GBR>
                            if (BrazilParameters::isEnabled())
                            {
                                payment_br = ledgerJournalTrans.getPaymentExtension_BR();
                                payment_br.FinInterestAmountCur_BR = paymentAggr_br.FinInterestAmountCur_BR;
                                payment_br.FineAmountCur_BR = paymentAggr_br.FineAmountCur_BR;
                                ledgerJournalTrans.packExtensionTable(payment_br);
                            }
                            // </GBR>

                            ledgerJournalTrans.update();

                            // save the "master" record's Recid
                            masterRecid = ledgerJournalTrans.RecId;
                        }
                        else
                        {
                            // move the SpecTrans to the new ledgerJournalTrans and delete all but the master trans record
                            update_recordset specTrans
                                setting SpecRecId = masterRecid
                                where specTrans.SpecTableId == ledgerJournalTrans.TableId &&
                                      specTrans.SpecRecId   == ledgerJournalTrans.RecId &&
                                      specTrans.SpecCompany == ledgerJournalTrans.company();

                            ledgerJournalTrans.delete();
                            hasAggregated = true;
                        }
                    }
                }

                if (hasAggregated)
                {
                    ledgerJournalTrans = LedgerJournalTrans::findRecId(masterRecid, true);
                    paymSpec = ledgerJournalTrans.PaymSpec;
                    ledgerJournalTrans.paymModeModified();
                    ledgerJournalTrans.PaymSpec = paymSpec;
                    ledgerJournalTrans.fillPaymentNotes();
                    ledgerJournalTrans.update();
                }

                ttscommit;
            }
            totalAmountCur = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotalTaxAmountApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for an approval scenario.
    /// </summary>
    /// <param name="_ledgerJournalId">
    /// The Journal ID.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// The total tax amount for the specified parameters.
    /// </returns>
    static AmountMST calcTotalTaxAmountApproval(LedgerJournalId _ledgerJournalId,
                                                Voucher         _voucher,
                                                TransDate       _transDate)
    {
        AmountMST           amountMST;
        LedgerJournalTrans  ledgerJournalTrans;
        VendTrans           vendTrans;
        InvoiceId           oldInvoice;
        boolean             first = true;

        while select JournalNum, Voucher, TransDate, PurchLedgerPosting, TaxGroup, TaxItemGroup, TaxCode, Invoice, VendTransId
            from ledgerJournalTrans
            order by JournalNum, Voucher, Invoice
            where ledgerJournalTrans.JournalNum         == _ledgerJournalId &&
                  ledgerJournalTrans.Voucher            == _voucher         &&
                  ledgerJournalTrans.TransDate          == _transDate       &&
                  ledgerJournalTrans.PurchLedgerPosting == ArrivalPostingType::None &&
                  ((ledgerJournalTrans.TaxGroup && ledgerJournalTrans.TaxItemGroup) ||
                    ledgerJournalTrans.TaxCode)
        {
            // we only calculate taxes once for each invoice
            // since taxes now calculates on an entire invoice.
            if (first || oldInvoice != ledgerJournalTrans.Invoice)
            {
                if (ledgerJournalTrans.VendTransId)
                {
                    vendTrans = VendTrans::find(ledgerJournalTrans.VendTransId);
                }

                amountMST += ledgerJournalTrans.totalTaxAmountSingleLine(true, false, false);

                oldInvoice = ledgerJournalTrans.Invoice;
                first = false;
            }
        }

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    static boolean checkExist(LedgerJournalId _ledgerJournalId)
    {
        if (_ledgerJournalId && !LedgerJournalTable::exist(_ledgerJournalId))
        {
            return checkFailed(strFmt(LedgerJournalTable::txtNotExist(),_ledgerJournalId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExistNonPosted_HU</Name>
				<Source><![CDATA[
    public static boolean checkExistNonPosted_HU()
    {
        LedgerJournalTable ledgerJournalTable;

        select firstonly RecId from ledgerJournalTable
            where  ledgerJournalTable.JournalType == LedgerJournalType::RCash &&
                 ! ledgerJournalTable.Posted;

        return ledgerJournalTable.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAllLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the compositional records related to the <c>LedgerJournalTable</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTableRecId">
    /// The <c>LedgerJournalTable</c> table record id.
    /// </param>
    [SysObsolete('Use LedgerJournalDeleteTransaction class instead.', true, 30\06\2020)]
    public static void deleteAllLines(LedgerJournalTableRecId _ledgerJournalTableRecId)
    {
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;
        LedgerJournalTrans_Project ledgerJournalTrans_Project;
        TaxUncommitted taxUncommitted;

        // <GEERU>
        PaymentOrderBudgetTrans_RU paymentOrderBudgetTrans_RU;
        // </GEERU>

        // <GEEU>
        CzCustAdvanceInvoiceLink czCustAdvanceInvoiceLink;
        CzVendAdvanceInvoiceLink czVendAdvanceInvoiceLink;
        // </GEEU>

        #ISOCountryRegionCodes

        ledgerJournalTable = LedgerJournalTable::findByRecId(_ledgerJournalTableRecId);

        ledgerJournalTrans.configureForSkipDelete();
        ledgerJournalTrans_Asset.configureForSkipDelete();
        ledgerJournalTrans_Project.configureForSkipDelete();
        taxUncommitted.configureForSkipDelete();

        NumberSequenceTable numberSequenceTable = NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable); 

        // release each separate voucher because when the number sequence is continuous, each voucher is tracked and has to be explicitly released.
        if (ledgerJournalTable.JournalType != LedgerJournalType::Periodic
            && ledgerJournalTable.JournalType != LedgerJournalType::VendInvoicePool
            && numberSequenceTable.Continuous)
        {
            while select Voucher from ledgerJournalTrans
                group by ledgerJournalTrans.Voucher
                    where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
            {                                
                if(NumberSeq::numCheckFormat(ledgerJournalTrans.Voucher, numberSequenceTable))
                {
                    NumberSeq::releaseNumber(ledgerJournalTable.NumberSequenceTable, ledgerJournalTrans.Voucher);
                }
                else
                {
                    // The NumberSeq::numCheckFormat API displays a warning message if the number sequence format did not match
                    // remove the warning message to not introduce confusion to the end user.
                    int line = infolog.line();
                    infolog.clear(line-1);
                }
            }
        }

        // use a TTS because budget processing is performed on ttsCommit
        ttsBegin;

        while select JournalNum, Voucher from ledgerJournalTrans
            group by ledgerJournalTrans.JournalNum,
                ledgerJournalTrans.Voucher
            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
        {
            ledgerJournalTrans.removeBudgetForVoucher();
        }

        ttsCommit;

        // For Approval Journal put records back in the pool
        if (ledgerJournalTable.JournalType == LedgerJournalType::Approval)
        {
            VendTrans vendTrans;
            LedgerJournalVoucherChanged journalChanged;
            while select * from vendTrans
                    where vendTrans.JournalNum == ledgerJournalTable.JournalNum
                join ToVoucher from journalChanged 
                    where journalChanged.FromVoucher == vendTrans.Voucher
                       && journalChanged.FromDate == vendTrans.TransDate
            {
                LedgerJournalEngine_Server::removeVoucher(vendTrans, ledgerJournalTable, journalChanged.ToVoucher);
            }
        }

        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL]))
        {
            while select Voucher, TransDate from ledgerJournalTrans
                group by ledgerJournalTrans.JournalNum,
                    ledgerJournalTrans.Voucher,
                    ledgerJournalTrans.TransDate
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
            {
                delete_from czCustAdvanceInvoiceLink
                    where czCustAdvanceInvoiceLink.PaymentCompany == curext()
                        && czCustAdvanceInvoiceLink.Voucher == ledgerJournalTrans.Voucher
                        && czCustAdvanceInvoiceLink.TransDate == ledgerJournalTrans.TransDate;

                delete_from czVendAdvanceInvoiceLink
                    where czVendAdvanceInvoiceLink.PaymentCompany == curext()
                        && czVendAdvanceInvoiceLink.Voucher == ledgerJournalTrans.Voucher
                        && czVendAdvanceInvoiceLink.TransDate == ledgerJournalTrans.TransDate;
            }
        }
        // </GEEU>

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            // delete record of <c>TaxEngineLedgerJournalTransHeader</c> related to this record.
            TaxEngineLedgerJournalTransHeader::deleteByLedgerJournalNum(ledgerJournalTable.JournalNum);
        }
        // </GTE>

        while select * from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
        {
            ledgerJournalTrans.deleteForHeader(ledgerJournalTable);
        }

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            TaxWithholdUncommitted_IN::deleteForDocumentHeader(tableNum(LedgerJournalTable), ledgerJournalTable.RecId, false);

            if (!ledgerJournalTable.Posted)
            {
                TaxVoucherService::calculateWithholdTaxForJournal_IN(ledgerJournalTable.JournalNum);
            }
        }
        // </GIN>

        // <GEEPL>
        if (isConfigurationkeyEnabled(configurationKeyNum(LedgerBasicSalesTax)) &&
            SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            ExportSalesInvoiceDomesticTaxVoucher::deleteUnpostedDomesticSalesTaxVoucher(ledgerJournalTable.JournalNum);
        }
        // </GEEPL>

        delete_from taxUncommitted
            where taxUncommitted.HeadingTableId == tableNum(LedgerJournalTable)
                && taxUncommitted.HeadingRecId == ledgerJournalTable.RecId;

        delete_from ledgerJournalTrans_Asset
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == ledgerJournalTrans_Asset.RefRecId
                    && ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;

        delete_from ledgerJournalTrans_Project
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == ledgerJournalTrans_Project.RefRecId
                    && ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;

        if (LedgerJournalTable::canJournalTypeHaveSettlements(ledgerJournalTable.JournalType)
            && LedgerJournalTable::hasAnySpecTrans(ledgerJournalTable.JournalNum))
        {
            LedgerJournalTable::deleteMarkedTransactionsForJournal(ledgerJournalTable.JournalNum);
        }

        LedgerJournalTrans_Error::deleteJournalErrorLinks(ledgerJournalTable.JournalNum);

        delete_from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            delete_from paymentOrderBudgetTrans_RU
                where paymentOrderBudgetTrans_RU.JournalNum == LedgerJournalTable.JournalNum;
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    static boolean exist(LedgerJournalId _ledgerJournalId)
    {
        return _ledgerJournalId && (select firstonly RecId from ledgerJournalTable
                                        index TypeNumIdx
                                        where ledgerJournalTable.JournalNum == _ledgerJournalId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    static LedgerJournalTable find(LedgerJournalId  _ledgerJournalId,
                                   boolean          _forUpdate = false)
    {
        LedgerJournalTable ledgerJournalTable;

        if (_ledgerJournalId)
        {
            ledgerJournalTable.selectForUpdate(_forUpdate);

            select firstonly ledgerJournalTable
                index TypeNumIdx
                where ledgerJournalTable.JournalNum == _ledgerJournalId;
        }

        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByIntegrationKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the journal table record using an integration key.
    /// </summary>
    /// <param name = "_integrationKey">
    /// The integration key.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the select is used in the context of an update on the table;
    /// optional. The default value is false.
    /// </param>
    /// <returns>
    /// A <c>LedgerJournalTable</c> buffer.
    /// </returns>
    /// <remarks>
    /// The CDS integration key may either contain a journal batch number, if the header was created in F&O, or
    /// an integration key, if the header was created in externally.
    /// </remarks>
    public static LedgerJournalTable findByIntegrationKey(CDSIntegrationkey _integrationKey, boolean _forUpdate = false)
    {
        LedgerJournalTable ledgerJournalTable;

        if (_integrationKey)
        {
            ledgerJournalTable.selectForUpdate(_forUpdate);

            select firstonly ledgerJournalTable
                where ledgerJournalTable.IntegrationKey == _integrationKey
                    || ledgerJournalTable.JournalNum == _integrationKey;
        }

        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a record in the <c>LedgerJournalTable</c> table by searching on the <c>RecId</c> field.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of a <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the select is used in the context of an update on the table;
    /// optional. The default value is false.
    /// </param>
    /// <returns>
    /// A <c>LedgerJournalTable</c> buffer.
    /// </returns>
    /// <remarks>
    /// When the <c>RecId</c> field has a non-zero value, the buffer contains valid data.
    /// </remarks>
    static LedgerJournalTable findByRecId(RecId _recId, boolean _forUpdate = false)
    {
        LedgerJournalTable ledgerJournalTable;

        if (_recId)
        {
            ledgerJournalTable.selectForUpdate(_forUpdate);

            select firstonly ledgerJournalTable
                where ledgerJournalTable.RecId == _recId;
        }
        //
        //  This method always returns a LedgerJournalTable buffer; therefore
        //  inspection of the contents of the RecId field of the returned buffer
        //  should be made order to ensure that the buffer is not empty.
        //
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecId</Name>
				<Source><![CDATA[
    [SysObsolete('This method has been deprecated. Use the findByRecId method instead.', false, 24\4\2023)]    
    public static LedgerJournalTable findRecId(RecId   _recId, boolean _forUpdate = false)
    {
        return LedgerJournalTable::findByRecId(_recId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVendorInvoicePool</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and returns the vendor invoice pool <c>LedgerJournalTable</c>, if one exists.
    /// </summary>
    /// <param name="_insert">
    /// A Boolean value that determines whether the record should be created if it does not exist; optional.
    /// </param>
    /// <returns>
    /// A single <c>LedgerJournalTable</c> table record, if it exists.
    /// </returns>
    /// <remarks>
    /// There is only one vendor invoice pool LedgerJournalTable record per company.
    /// </remarks>
    static LedgerJournalTable findVendorInvoicePool(boolean _insert = true)
    {
        LedgerJournalTable  ledgerJournalTable;

        select firstonly ledgerJournalTable
            where ledgerJournalTable.Posted         == NoYes::No    &&
                  ledgerJournalTable.JournalType    == LedgerJournalType::VendInvoicePool;

        if (!ledgerJournalTable && _insert)
        {
            ttsbegin;
            ledgerJournalTable.JournalNum   = JournalTableData::newTable(ledgerJournalTable).nextJournalId();
            ledgerJournalTable.Posted       = NoYes::No;
            ledgerJournalTable.Name         = "@SYS57805";
            ledgerJournalTable.JournalName  = "@SYS60854";
            ledgerJournalTable.JournalType  = LedgerJournalType::VendInvoicePool;
            ledgerJournalTable.insert();
            ttscommit;
        }
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initApproveStatus_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the approve status of ledger journal table.
    /// </summary>
    public static void initApproveStatus_CN()
    {
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTable_W ledgerJournalTable_W;

        ttsbegin;
        while select forupdate ledgerJournalTable
            where   ledgerJournalTable.JournalType == LedgerJournalType::Daily
                &&  ledgerJournalTable.Posted      == NoYes::No
            join forupdate ledgerJournalTable_W
            where   ledgerJournalTable.RecId       == ledgerJournalTable_W.LedgerJournalTable
        {
            ledgerJournalTable.ReportedAsReadyBy = '';
            ledgerJournalTable.Approver          = 0;
            ledgerJournalTable.RejectedBy        = '';
            ledgerJournalTable.update();

            ledgerJournalTable_W.ApprovalStatus_CN = LedgerApprovalStatus_CN::Open;
            ledgerJournalTable_W.update();
        }

        while select forupdate ledgerJournalTable_W
            where       ledgerJournalTable_W.ApprovalStatus_CN  != LedgerApprovalStatus_CN::Approved

            exists join ledgerJournalTable
                where   ledgerJournalTable.RecId                == ledgerJournalTable_W.LedgerJournalTable &&
                        ledgerJournalTable.JournalType          == LedgerJournalType::Daily
                    &&  ledgerJournalTable.Posted               == NoYes::Yes
        {
            ledgerJournalTable_W.ApprovalStatus_CN = LedgerApprovalStatus_CN::Approved;
            ledgerJournalTable_W.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertJournalsInLedgerJournalMultiPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts journals into a <c>LedgerJournalMultiPost</c> object.
    /// </summary>
    /// <param name="_journalList">
    /// A <c>RecordSortedList</c> object that holds the record buffers for the journals.
    /// </param>
    /// <param name="_parmBuffer">
    /// A record buffer that holds the parameters that are used to execute the posting; optional.
    /// </param>
    /// <returns>
    /// A <c>LedgerJournalMultiPost</c> object.
    /// </returns>
    static public LedgerJournalMultiPost insertJournalsInLedgerJournalMultiPost(
        RecordSortedList        _journalList,
        LedgerJournalParmPost   _parmBuffer = _parmBuffer)
    {
        LedgerJournalMultiPost  ledgerJournalMultiPost;
        LedgerJournalTable      ledgerJournalTable;
        ParmBuffer              parmBuffer;
        boolean                 journalFound;
        Args                    args = new Args();

        args.parmEnumType(enumNum(UnknownNoYes));

        if (_parmBuffer.TransferErrors)
        {
            args.parmEnum(UnknownNoYes::Yes);
        }
        else
        {
            args.parmEnum(UnknownNoYes::No);
        }

        ledgerJournalMultiPost = LedgerJournalMultiPost::construct(args);

        if (prmisDefault(_parmBuffer))
        {
            parmBuffer = ledgerJournalMultiPost.defaultParmBuffer();
        }
        else
        {
            parmBuffer = _parmBuffer;
        }

        RunBaseMultiParm::initParm(ledgerJournalMultiPost);

        journalFound = _journalList.first(ledgerJournalTable);

        while (journalFound)
        {
            ledgerJournalMultiPost.insert(ledgerJournalTable, parmBuffer);
            journalFound = _journalList.next(ledgerJournalTable);
        }

        return ledgerJournalMultiPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSimpleMethod_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method attempts to find if the LedgerJournalTrans is created using simple method.
    /// </summary>
    /// <param name="_ledgerJournalId">
    /// The journal id of LedgerJournalTable
    /// </param>
    /// <returns>
    /// return true if the LedgerjournalTrans created using simple method, else return false.
    /// </returns>
    public static boolean isSimpleMethod_CN(LedgerJournalId _ledgerJournalId)
    {
        LedgerJournalTrans  minVoucher;
        LedgerJournalTrans  maxVoucher;

        select firstonly Voucher from minVoucher
            order by Voucher
            where minVoucher.JournalNum == _ledgerJournalId
            outer join firstonly Voucher from maxVoucher
                order by Voucher desc
                where minVoucher.JournalNum == maxVoucher.JournalNum;

        return (minVoucher.Voucher == maxVoucher.Voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalBalanceMST</Name>
				<Source><![CDATA[
    static container journalBalanceMST(LedgerJournalId       _ledgerJournalId,
                                              boolean               _addTax = false,
                                              LedgerJournalInclTax  _ledgerJournalInclTax = LedgerJournalTable::find(_ledgerJournalId).LedgerJournalInclTax,
                                              boolean               _throwExceptions = true)
    {
        LedgerJournalTable      ledgerJournalTable;
        LedgerJournalTrans      ledgerJournalTransFieldList;
        AmountMST               journalTotalDebit;
        AmountMST               journalTotalCredit;        
        AmountMST               journalTotalOffset;
        AmountMSTSecondary      journalTotalDebitReportingCurrency;
        AmountMSTSecondary      journalTotalCreditReportingCurrency;     
        Voucher                 oldVoucher;
        TransDate               oldTransDate;
        AmountMST               taxAmountToPost;
        AmountMST               taxAmountReverse;
        AmountMST               taxDifference;
        AmountMST               amountMSTDebit;
        AmountMST               amountMSTCredit;
        AmountMSTSecondary      amountDebitReportingCurrency;
        AmountMSTSecondary      amountCreditReportingCurrency;
        CurrencyCode            reportingCurrency = Ledger::reportingCurrency();

        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        void addTax()
        {
            if (_addTax && oldVoucher)
            {
                taxAmountToPost = LedgerJournalTable::calcTotalTaxAmountApproval(_ledgerJournalId,
                                                                                   oldVoucher,
                                                                                   oldTransDate);
                if (taxAmountToPost)
                {
                    taxAmountReverse = Tax::netTaxTotalMSTVoucherDate(oldVoucher,
                                                                      oldTransDate,
                                                                      _ledgerJournalId);

                    taxDifference = _ledgerJournalInclTax ? taxAmountReverse :  -(taxAmountToPost - taxAmountReverse);

                    if (taxDifference < 0)
                    {
                        journalTotalDebit -= taxDifference;
                    }
                    else
                    {
                        journalTotalCredit += taxDifference;
                    }
                }
            }
        }

        // If all lines match the accounting currency then there
        // is no reason to do currency conversion on each line
        select firstOnly RecId from ledgerJournalTransFieldList
            where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                && ledgerJournalTransFieldList.CurrencyCode != Ledger::accountingCurrency();

        if (ledgerJournalTransFieldList == null)
        {
            // sum the amounts for all lines because all lines use the accounting currency

            if (_addTax)
            {
                // group by voucher + date because they are the basis of tax calculation

                // Process lines with and without an offset separately because they affect the
                // balance differently and because a single query to do it was more complex and slower

                while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                    group by ledgerJournalTransFieldList.Voucher,
                        ledgerJournalTransFieldList.TransDate//,
                    where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                        && ledgerJournalTransFieldList.OffsetLedgerDimension == 0
                {
                    journalTotalDebit += ledgerJournalTransFieldList.AmountCurDebit;
                    journalTotalCredit += ledgerJournalTransFieldList.AmountCurCredit;

                    journalTotalOffset += ledgerJournalTransFieldList.AmountCurDebit - ledgerJournalTransFieldList.AmountCurCredit;

                    // process the current voucher + date because we are grouping by voucher + date
                    oldVoucher = ledgerJournalTransFieldList.Voucher;
                    oldTransDate = ledgerJournalTransFieldList.TransDate;
                    addTax();
                }

                // don't need to process last voucher + date because of grouping by voucher + date

                while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                    group by ledgerJournalTransFieldList.Voucher,
                        ledgerJournalTransFieldList.TransDate
                    where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                        && ledgerJournalTransFieldList.OffsetLedgerDimension != 0
                {
                    // do nothing to the journal totals because lines with an offset have no effect

                    journalTotalOffset += ledgerJournalTransFieldList.AmountCurDebit - ledgerJournalTransFieldList.AmountCurCredit;

                    // process the current voucher + date because we are grouping by voucher + date
                    oldVoucher = ledgerJournalTransFieldList.Voucher;
                    oldTransDate = ledgerJournalTransFieldList.TransDate;
                    addTax();
                }

                // don't need to process last voucher + date because of grouping by voucher + date
            }
            else
            {
                // no additional grouping because it is not necessary

                // Process lines with and without an offset separately because they affect the
                // balance differently and because a single query to do it was more complex and slower

                while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                    where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                        && ledgerJournalTransFieldList.OffsetLedgerDimension == 0
                {
                    journalTotalDebit += ledgerJournalTransFieldList.AmountCurDebit;
                    journalTotalCredit += ledgerJournalTransFieldList.AmountCurCredit;

                    journalTotalOffset += ledgerJournalTransFieldList.AmountCurDebit - ledgerJournalTransFieldList.AmountCurCredit;
                }

                while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                    where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                        && ledgerJournalTransFieldList.OffsetLedgerDimension != 0
                {
                    journalTotalDebit += ledgerJournalTransFieldList.AmountCurDebit;
                    journalTotalCredit += ledgerJournalTransFieldList.AmountCurCredit;

                    // Credit and debit are reversed since this is an offset account
                    journalTotalDebit += ledgerJournalTransFieldList.AmountCurCredit;
                    journalTotalCredit += ledgerJournalTransFieldList.AmountCurDebit;

                    journalTotalOffset += ledgerJournalTransFieldList.AmountCurDebit - ledgerJournalTransFieldList.AmountCurCredit;
                }
            }
        }
        else
        {
            ledgerJournalTable = LedgerJournalTable::find(_ledgerJournalId);

            // have to process each line that does not use the accounting currency because a
            // line-by-line currency conversion must be used to get the accounting currency amount
            while select Voucher, TransDate, AmountCurDebit, AmountCurCredit, CurrencyCode, JournalNum,
                Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, OffsetLedgerDimension, Company
                // <GEEU>
                , DocumentDate // Used in exchange rate calculation for GEEU
                , TaxGroup     // Used in exchange rate calculation for GEEU
                , VatDueDate_W // Used in exchange rate calculation for GEEU
                // </GEEU>
            from ledgerJournalTransFieldList
            order by Voucher
            where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                && ledgerJournalTransFieldList.CurrencyCode != Ledger::accountingCurrency()
            {
                if (ledgerJournalTransFieldList.Voucher != oldVoucher ||
                    ledgerJournalTransFieldList.TransDate != oldTransDate)
                {
                    // process the previous voucher + date because we are not grouping by voucher + date
                    addTax();
                }

                oldVoucher      = ledgerJournalTransFieldList.Voucher;
                oldTransDate    = ledgerJournalTransFieldList.TransDate;
                amountMSTCredit = 0;
                amountMSTDebit  = 0;

                if (ledgerJournalTransFieldList.AmountCurDebit)
                {
                    amountMSTDebit = ledgerJournalTransFieldList.calcDebitMST(_throwExceptions, ledgerJournalTable);
                    journalTotalDebit += amountMSTDebit;
                }

                if (ledgerJournalTransFieldList.AmountCurCredit)
                {
                    amountMSTCredit = ledgerJournalTransFieldList.calcCreditMST(_throwExceptions, ledgerJournalTable);
                    journalTotalCredit += amountMSTCredit;
                }

                if (ledgerJournalTransFieldList.OffsetLedgerDimension)
                {
                    journalTotalDebit  += amountMSTCredit;
                    journalTotalCredit += amountMSTDebit;

                    // Don't use amountDebitMST and amountCreditMST, because they are
                    // rounded, we need the originals.
                    journalTotalOffset += ledgerJournalTransFieldList.calcAmountMST(_throwExceptions);
                }
            }

            // process the last voucher + date
            addTax();

            // process the lines that use the accounting currency as
            // a group because row-by-row conversion is not required

            // process lines with and without an offset separately because they affect the
            // balance differently and because a single query to do it was more complex and slower

            if (_addTax)
            {
                // group by voucher + date because they are the basis of tax calculation

                // Process lines with and without an offset separately because they affect the
                // balance differently and because a single query to do it was more complex and slower

                while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                    group by ledgerJournalTransFieldList.Voucher,
                        ledgerJournalTransFieldList.TransDate
                    where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                        && ledgerJournalTransFieldList.CurrencyCode == Ledger::accountingCurrency()
                        && ledgerJournalTransFieldList.OffsetLedgerDimension == 0
                {
                    journalTotalDebit += ledgerJournalTransFieldList.AmountCurDebit;
                    journalTotalCredit += ledgerJournalTransFieldList.AmountCurCredit;

                    journalTotalOffset += ledgerJournalTransFieldList.AmountCurDebit - ledgerJournalTransFieldList.AmountCurCredit;

                    // process the current voucher + date because we are grouping by voucher + date
                    oldVoucher = ledgerJournalTransFieldList.Voucher;
                    oldTransDate = ledgerJournalTransFieldList.TransDate;
                    addTax();
                }

                // don't need to process last voucher + date because of grouping by voucher + date

                while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                    group by ledgerJournalTransFieldList.Voucher,
                        ledgerJournalTransFieldList.TransDate
                    where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                        && ledgerJournalTransFieldList.CurrencyCode == Ledger::accountingCurrency()
                        && ledgerJournalTransFieldList.OffsetLedgerDimension != 0
                {
                    journalTotalDebit += ledgerJournalTransFieldList.AmountCurDebit;
                    journalTotalCredit += ledgerJournalTransFieldList.AmountCurCredit;

                    // Credit and debit are reversed since this is an offset account
                    journalTotalDebit += ledgerJournalTransFieldList.AmountCurCredit;
                    journalTotalCredit += ledgerJournalTransFieldList.AmountCurDebit;

                    journalTotalOffset += ledgerJournalTransFieldList.AmountCurDebit - ledgerJournalTransFieldList.AmountCurCredit;

                    // process the current voucher + date because we are grouping by voucher + date
                    oldVoucher = ledgerJournalTransFieldList.Voucher;
                    oldTransDate = ledgerJournalTransFieldList.TransDate;
                    addTax();
                }

                // don't need to process last voucher + date because of grouping by voucher + date
            }
            else
            {
                // no additional grouping because it is not necessary

                // Process lines with and without an offset separately because they affect the
                // balance differently and because a single query to do it was more complex and slower

                while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                    where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                        && ledgerJournalTransFieldList.CurrencyCode == Ledger::accountingCurrency()
                        && ledgerJournalTransFieldList.OffsetLedgerDimension == 0
                {
                    journalTotalDebit += ledgerJournalTransFieldList.AmountCurDebit;
                    journalTotalCredit += ledgerJournalTransFieldList.AmountCurCredit;

                    journalTotalOffset += ledgerJournalTransFieldList.AmountCurDebit - ledgerJournalTransFieldList.AmountCurCredit;
                }

                while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                    where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                        && ledgerJournalTransFieldList.CurrencyCode == Ledger::accountingCurrency()
                        && ledgerJournalTransFieldList.OffsetLedgerDimension != 0
                {
                    journalTotalDebit += ledgerJournalTransFieldList.AmountCurDebit;
                    journalTotalCredit += ledgerJournalTransFieldList.AmountCurCredit;

                    // Credit and debit are reversed since this is an offset account
                    journalTotalDebit += ledgerJournalTransFieldList.AmountCurCredit;
                    journalTotalCredit += ledgerJournalTransFieldList.AmountCurDebit;

                    journalTotalOffset += ledgerJournalTransFieldList.AmountCurDebit - ledgerJournalTransFieldList.AmountCurCredit;
                }
            }
        }
                      
        if (reportingcurrency != '')
        {
            if (reportingcurrency == Ledger::accountingCurrency())
            {
                //Setting up the reporting currency value to the accounting currency value
                //because the currencies are set to the same currency.
                journalTotalDebitReportingCurrency  = journalTotalDebit;
                journalTotalCreditReportingCurrency = journalTotalCredit;                
            }
            else
            {
                // If all lines match the reporting currency then there
                // is no reason to do currency conversion on each line.
                select firstOnly RecId from ledgerJournalTransFieldList
                    where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                        && ledgerJournalTransFieldList.CurrencyCode != reportingcurrency;

                if (ledgerJournalTransFieldList == null)
                {
                    // sum the amounts for all lines because all lines use the reporting currency
                    // no additional grouping because it is not necessary.

                    // Process lines with and without an offset separately because they affect the
                    // balance differently and because a single query to do it was more complex and slower.

                    while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                            && ledgerJournalTransFieldList.OffsetLedgerDimension == 0
                    {
                        journalTotalDebitReportingCurrency += ledgerJournalTransFieldList.AmountCurDebit;
                        journalTotalCreditReportingCurrency += ledgerJournalTransFieldList.AmountCurCredit;
                    }

                    while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                            && ledgerJournalTransFieldList.OffsetLedgerDimension != 0
                    {
                        journalTotalDebitReportingCurrency += ledgerJournalTransFieldList.AmountCurDebit;
                        journalTotalCreditReportingCurrency += ledgerJournalTransFieldList.AmountCurCredit;

                        // Credit and debit are reversed since this is an offset account.
                        journalTotalDebitReportingCurrency += ledgerJournalTransFieldList.AmountCurCredit;
                        journalTotalCreditReportingCurrency += ledgerJournalTransFieldList.AmountCurDebit;
                    }
            
                }
                else
                {
                    ledgerJournalTable = LedgerJournalTable::find(_ledgerJournalId);

                    // have to process each line that does not use the reporting currency because a
                    // line-by-line currency conversion must be used to get the reporting currency amount.
                    while select AccountType, Voucher, TransDate, AmountCurDebit, AmountCurCredit, CurrencyCode, JournalNum,
                        Triangulation, ExchRate, ExchRateSecond, ReportingCurrencyExchRate, ReportingCurrencyExchRateSecondary, OffsetLedgerDimension, Company
                        // <GEEU>
                        , DocumentDate // Used in exchange rate calculation for GEEU
                    , TaxGroup     // Used in exchange rate calculation for GEEU
                    , VatDueDate_W // Used in exchange rate calculation for GEEU
                    // </GEEU>
                    from ledgerJournalTransFieldList
                    order by Voucher
                    where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                        && ledgerJournalTransFieldList.CurrencyCode != reportingcurrency
                    {
                        amountCreditReportingCurrency = 0;
                        amountDebitReportingCurrency  = 0;

                        if (ledgerJournalTransFieldList.AmountCurDebit)
                        {
                            amountDebitReportingCurrency = ledgerJournalTransFieldList.calcDebitReportingCurrency(_throwExceptions, ledgerJournalTable);
                            journalTotalDebitReportingCurrency += amountDebitReportingCurrency;
                        }

                        if (ledgerJournalTransFieldList.AmountCurCredit)
                        {
                            amountCreditReportingCurrency = ledgerJournalTransFieldList.calcCreditReportingCurrency(_throwExceptions, ledgerJournalTable);
                            journalTotalCreditReportingCurrency += amountCreditReportingCurrency;
                        }

                        if (ledgerJournalTransFieldList.OffsetLedgerDimension)
                        {
                            journalTotalDebitReportingCurrency  += amountCreditReportingCurrency;
                            journalTotalCreditReportingCurrency += amountDebitReportingCurrency;
                        }
                    }

                    // process the lines that use the reporting currency as
                    // a group because row-by-row conversion is not required

                    // process lines with and without an offset separately because they affect the
                    // balance differently and because a single query to do it was more complex and slower
        
                    // no additional grouping because it is not necessary

                    while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                            && ledgerJournalTransFieldList.CurrencyCode == reportingcurrency
                            && ledgerJournalTransFieldList.OffsetLedgerDimension == 0
                    {
                        journalTotalDebitReportingCurrency += ledgerJournalTransFieldList.AmountCurDebit;
                        journalTotalCreditReportingCurrency += ledgerJournalTransFieldList.AmountCurCredit;
                    }

                    while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransFieldList
                        where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                            && ledgerJournalTransFieldList.CurrencyCode == reportingcurrency
                            && ledgerJournalTransFieldList.OffsetLedgerDimension != 0
                    {
                        journalTotalDebitReportingCurrency += ledgerJournalTransFieldList.AmountCurDebit;
                        journalTotalCreditReportingCurrency += ledgerJournalTransFieldList.AmountCurCredit;

                        // Credit and debit are reversed since this is an offset account
                        journalTotalDebitReportingCurrency += ledgerJournalTransFieldList.AmountCurCredit;
                        journalTotalCreditReportingCurrency += ledgerJournalTransFieldList.AmountCurDebit;
                    }
                }
            }
        }

        return [journalTotalDebit, journalTotalCredit, journalTotalOffset, journalTotalDebitReportingCurrency, journalTotalCreditReportingCurrency];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the balance fields of the <c>LedgerJournalTable</c> record.
    /// </summary>
    public void updateBalances()
    {
        if (this.RecId)
        {
            ttsbegin;

            this.selectForUpdate(true);

            [this.JournalTotalDebit, this.JournalTotalCredit, this.JournalTotalOffsetBalance,
             this.JournalTotalDebitReportingCurrency,
             this.JournalTotalCreditReportingCurrency] = LedgerJournalEngine_Server::construct().initBalances(this.JournalNum, true);

            this.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupJournalNumByJournalName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a lookup for the <c>LedgerJournalTable</c> table.
    /// </summary>
    /// <param name="_formControl">
    /// The control for the field that has the lookup.
    /// </param>
    /// <param name="_journalName">
    /// The name of journals you want to filter.
    /// </param>
    public static void lookupJournalNumByJournalName(FormStringControl _formControl, LedgerJournalNameId _journalName)
    {
        SysTableLookup          sysTableLookup;
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;
        QueryBuildRange         queryBuildRangeJournalName;
        QueryBuildRange         queryBuildRangePosted;

        sysTableLookup = SysTableLookup::newParameters(tableNum(LedgerJournalTable), _formControl);
        query = new Query();
        queryBuildDataSource = query.addDataSource(tableNum(LedgerJournalTable));
        queryBuildRangeJournalName = queryBuildDataSource.addRange(fieldNum(LedgerJournalTable, JournalName));
        queryBuildRangePosted = queryBuildDataSource.addRange(fieldNum(LedgerJournalTable, Posted));

        sysTableLookup.addLookupfield(fieldNum(LedgerJournalTable, JournalNum));
        sysTableLookup.addLookupfield(fieldNum(LedgerJournalTable, JournalName));
        sysTableLookup.addLookupfield(fieldNum(LedgerJournalTable, Name));

        queryBuildRangeJournalName.value(queryValue(_journalName));
        queryBuildRangePosted.value(queryValue(NoYes::No));

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    static TxtNotExist txtNotExist()
    {
        return "@SYS17145";
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxSupported</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value indicating wheather <c>LedgerJournalTable</c> instance supports taxes.
    /// </summary>
    /// <returns>
    /// true if taxes are supported for the current record; otherwise false.
    /// </returns>
    public boolean isTaxSupported()
    {
        return this.JournalType != LedgerJournalType::Assets;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxIntegrationEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether tax integration is enabled, and current journal type is supported.
    /// </summary>
    /// <returns>true if tax integration is enabled and support current journal type; otherwise, false.</returns>
    public boolean isTaxIntegrationEnabled()
    {
        return TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(this.JournalType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canJournalTypeHaveSettlements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a journal type can have settlements.
    /// </summary>
    /// <param name = "_ledgerJournalType">The type of journal.</param>
    /// <returns>true if the journal type can have settlements; otherwise, false.</returns>
    [SysObsolete('This method always returns true and will be removed in future versions. Use hasAnySpecTrans instead.', false, 31\03\2019)]
    public static boolean canJournalTypeHaveSettlements(LedgerJournalType _ledgerJournalType)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasAnySpecTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a journal has any <c>SpecTrans</c> records associated with either
    /// the payment journal line or a payment proposal for the journal.
    /// </summary>
    /// <param name = "_journalNumber">The journal number.</param>
    /// <returns>true if the journal has <c>SpecTrans</c> records; otherwise false.</returns>
    public static boolean hasAnySpecTrans(LedgerJournalId _journalNumber)
    {
        LedgerJournalTrans ledgerJournalTrans;
        SpecTrans specTrans;

        select firstonly RecId from specTrans
            exists join ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _journalNumber
                    && ledgerJournalTrans.company() == specTrans.SpecCompany
                    && ledgerJournalTrans.TableId == specTrans.SpecTableId
                    && ledgerJournalTrans.RecId == specTrans.SpecRecId;

        boolean hasAnySpecTrans = specTrans.RecId != 0;

        if (!hasAnySpecTrans)
        {
            hasAnySpecTrans = CustVendPaymProposalLine::existByJournalId(_journalNumber);
        }

        return hasAnySpecTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteMarkedTransactionsForJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes marked transactions for an entire payment journal, including existing
    /// payment proposal entries and documents marked against journal lines.
    /// </summary>
    /// <param name = "_journalNumber">The payment journal number.</param>
    internal static void deleteMarkedTransactionsForJournal(LedgerJournalId _journalNumber)
    {
        CustVendPaymProposalLine::deleteByJournalId(_journalNumber);

        SpecTrans::deleteForJournalNum(_journalNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasLinesOfTransactionType</Name>
				<Source><![CDATA[
    private boolean hasLinesOfTransactionType(LedgerTransType _ledgerTransType)
    {
        ledgerJournalTrans ledgerJournalTrans;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == this.JournalNum
                && ledgerJournalTrans.TransactionType == _ledgerTransType;

        return ledgerJournalTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerjournaltable_customs_it</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>LedgerJournalTable_Customs_IT</c> record associated with the current record.
    /// </summary>
    /// <returns>
    /// The <c>LedgerJournalTable_Customs_IT</c> record associated with the current record.
    /// </returns>
    public ledgerjournaltable_customs_it ledgerjournaltable_customs_it()
    {
        return this.sysextensionserializermap::getextensiontable(tablenum(ledgerjournaltable_customs_it));
    }

]]></Source>
			</Method>
			<Method>
				<Name>packLedgerJournalTable_Customs_IT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the <c>LedgerJournalTable_Customs_IT</c> record associated with the current record.
    /// </summary>
    /// <param name="_ledgerJournalTable_Customs">
    /// The <c>LedgerJournalTable_Customs_IT</c> record.
    /// </param>
    public void packLedgerJournalTable_Customs_IT(LedgerJournalTable_Customs_IT _ledgerJournalTable_Customs)
    {
        _ledgerJournalTable_Customs.LedgerJournalTable = this.RecId;

        this.SysExtensionSerializerMap::packExtensionTable(_ledgerJournalTable_Customs);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxCalculatedForAllJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the tax is calculated for all the records in <c>LedgerJournalTrans</c> table, and are present in <c>TaxUncommitted</c>.
    /// </summary>
    /// <returns>
    /// true if the records exists; otherwise, false.
    /// </returns>
    public boolean isTaxCalculatedForAllJournalTrans()
    {
        TaxUncommitted taxUncommmited;
        LedgerJournalTrans ledgerJournalTrans;
        boolean result = false;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == this.JournalNum
            notexists join taxUncommmited
                where taxUncommmited.HeadingTableId == this.TableId
                    && taxUncommmited.HeadingRecid == this.RecId
                    && taxUncommmited.Voucher == ledgerJournalTrans.Voucher;

        if (!ledgerJournalTrans.RecId)
        {
            result = true;
        }
        
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editReportingCurrencyExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// gets and sets the second reporting currency exchange rate.
    /// </summary>
    /// <param name = "set">
    /// A Boolean value that determines whether the reason code is set.
    /// </param>
    /// <param name = "_reportingCurrencyExchRate">
    /// The new exchange rate when <paramref name="set" /> is true.
    /// </param>
    /// <returns>
    /// The exchange rate value from the reocrd of <c>ExchangeRate</c> table.
    /// </returns>
    public edit ReportingCurrencyExchRate editReportingCurrencyExchRate(boolean set, ReportingCurrencyExchRate _reportingCurrencyExchRate)
    {
        return this.LedgerJournalReportingCurrencyExchangeRates::editReportingCurrencyExchangeRate(set, _reportingCurrencyExchRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>editReportingCurrencyExchRateSecond</Name>
				<Source><![CDATA[
    /// <summary>
    /// gets and sets the second reporting currency second exchange rate.
    /// </summary>
    /// <param name = "set">A Boolean value that determines whether the reason code is set.
    /// </param>
    /// <param name = "_reportingCurrencyExchrateSecondary">
    /// The new second exchange rate when <paramref name="set" /> is true.
    /// </param>
    /// <returns>The second exchange rate value from the reocrd of <c>ExchangeRate</c> table.
    /// </returns>
    public edit ReportingCurrencyExchRateSecondary editReportingCurrencyExchRateSecond(boolean set, ReportingCurrencyExchrateSecondary _reportingCurrencyExchrateSecondary)
    {
        return this.LedgerJournalReportingCurrencyExchangeRates::editReportingCurrencyExchangeRateSecond(set, _reportingCurrencyExchrateSecondary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportingCurrencyExchangeRateField</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the reporting currency exchange rate field ID.
    /// </summary>
    /// <returns>
    ///     The reporting currency exchange rate field ID.
    /// </returns>
    /// <remarks>
    ///     Used with the <c>LedgerJournalReportingCurrencyExchangeRates</c> map.
    /// </remarks>
    internal FieldId getReportingCurrencyExchangeRateField()
    {
        return fieldNum(LedgerJournalTable, ReportingCurrencyExchRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportingCurrencyExchangeRateSecondField</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the reporting currency exchange rate secondary field ID.
    /// </summary>
    /// <returns>
    ///     The reporting currency exchange rate secondary field ID.
    /// </returns>
    /// <remarks>
    ///     Used with the <c>LedgerJournalReportingCurrencyExchangeRates</c> map.
    /// </remarks>
    internal FieldId getReportingCurrencyExchangeRateSecondField()
    {
        return fieldNum(LedgerJournalTable, ReportingCurrencyExchRateSecondary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the currency code.
    /// </summary>
    /// <returns>
    ///     The currency code.
    /// </returns>
    /// <remarks>
    ///     Used with the <c>LedgerJournalReportingCurrencyExchangeRates</c> map.
    /// </remarks>
    internal CurrencyCode getCurrencyCode()
    {
        return this.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUnpostedSiblings</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check if unposted sibling journal exists.
    ///
    ///     Here siblings are the group of journals which got split during the journal posting and are tied together through the column ParentJournalNum
    /// </summary>
    /// <returns>
    ///     returns true if at least one unposted sibling exists else returns false.
    /// </returns>
    internal boolean hasUnpostedSiblings()
    {
        LedgerJournalTable unpostedLedgerJournal;
        boolean unpostedSiblingExists = true;

        select firstonly RecId from unpostedLedgerJournal
            where unpostedLedgerJournal.ParentJournalNum == this.ParentJournalNum
            && unpostedLedgerJournal.Posted == NoYes::No;        

        if (!unpostedLedgerJournal.RecId)
        {
            // All the siblings have been posted.
            unpostedSiblingExists = false;
        }

        return unpostedSiblingExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParentJournalNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the Parent Journal Number.
    ///
    ///     This column binds the all the split journals together.
    /// </summary>
    /// <returns>
    ///     The Parent Journal Number.
    /// </returns>
    internal LedgerJournalId getParentJournalNumber()
    {
        return this.ParentJournalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostedSiblingsCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets count of all related posted journals by parent journal number.
    /// A large journal can be split into multiple journals after posting, this helper
    /// function counts all entries and then subtract 1 from total count since we want to
    /// exclude the parent journal from total count.
    /// </summary>
    /// <returns>Number of related posted journals.</returns>
    internal Counter getPostedSiblingsCount()
    {
        if (!this.getParentJournalNumber())
            return 0;

        LedgerJournalTable postedSiblingJournals;

        select count(RecId) from postedSiblingJournals
            where postedSiblingJournals.ParentJournalNum == this.getParentJournalNumber()
            && postedSiblingJournals.Posted == NoYes::Yes;

        return (postedSiblingJournals.RecId - 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyLegalEntity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the primary company's <c>LegalEntityRecId</c>.
    /// </summary>
    /// <returns>
    ///     The primary company's <c>LegalEntityRecId</c>.
    /// </returns>
    /// <remarks>
    ///     Used with the <c>LedgerJournalReportingCurrencyExchangeRates</c> map.
    /// </remarks>
    internal LegalEntityRecId getCompanyLegalEntity()
    {
        return CompanyInfo::current();
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReportingCurrencyExchangeRateIfSameCurrencies</Name>
				<Source><![CDATA[
    private void defaultReportingCurrencyExchangeRateIfSameCurrencies()
    {
        this.LedgerJournalReportingCurrencyExchangeRates::setReportingCurrencyExchangeRate();
        this.setReportingCurrencyExchangeRateSecond();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReportingCurrencyExchangeRateSecond</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the reporting currency exchange rate second for the current buffer.
    /// </summary>
    /// <remarks>Reporting currency exchange rate second is set only if a reporting currency is setup in the <c>Ledger</c>.
    /// </remarks>
    internal void setReportingCurrencyExchangeRateSecond()
    {
        this.LedgerJournalReportingCurrencyExchangeRates::setReportingCurrencyExchangeRateSecond();
    }

]]></Source>
			</Method>
			<Method>
				<Name>disableDelayTaxCalcualtion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate tax while DelayTaxCalculation changed from yes to no.
    /// </summary>
    public void disableDelayTaxCalcualtion()
    {
        LedgerJournalTrans ledgerJournalTrans;

        while select * from ledgerJournalTrans
            group by ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice
            where ledgerJournalTrans.JournalNum == this.JournalNum
        {
            LedgerJournalTrans::getTaxInstance(ledgerJournalTrans.JournalNum,
                                               ledgerJournalTrans.Voucher,
                                               ledgerJournalTrans.Invoice,
                                               true,
                                               null,
                                               false,
                                               ledgerJournalTrans.TransDate
                                               );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultAndValidateReportingExchangeRates</Name>
				<Source><![CDATA[
    internal boolean defaultAndValidateReportingExchangeRates(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean areExchangeRatesValid = true;
        boolean shouldUpdateLedgerJournalTable;

        if (Ledger::isReportingCurrencySameAsAccountingCurrency())
        {
            this.selectForUpdate(true);

            if (this.ExchRate != this.ReportingCurrencyExchRate)
            {
                if (this.ReportingCurrencyExchRate == 0)
                {
                    this.ReportingCurrencyExchRate = this.ExchRate;
                    shouldUpdateLedgerJournalTable = true;
                }
                else if (_ledgerPostingMessageCollection)
                {
                    areExchangeRatesValid = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GeneralLedger:ExchangeRateMismatchForSameLedgerCurrency", Ledger::accountingCurrency(), Ledger::reportingCurrency()));
                }
                else
                {
                    areExchangeRatesValid = checkFailed(strFmt("@GeneralLedger:ExchangeRateMismatchForSameLedgerCurrency", Ledger::accountingCurrency(), Ledger::reportingCurrency()));
                }
            }

            if (this.ExchRateSecondary != this.ReportingCurrencyExchRateSecondary)
            {
                if (this.ReportingCurrencyExchRateSecondary == 0)
                {
                    this.ReportingCurrencyExchRateSecondary = this.ExchrateSecondary;
                    shouldUpdateLedgerJournalTable = true;
                }
                else if(_ledgerPostingMessageCollection)
                {
                    areExchangeRatesValid = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GeneralLedger:SecondaryExchangeRateMismatchForSameLedgerCurrency", Ledger::accountingCurrency(), Ledger::reportingCurrency()));
                }
                else
                {
                    areExchangeRatesValid = checkFailed(strFmt("@GeneralLedger:SecondaryExchangeRateMismatchForSameLedgerCurrency", Ledger::accountingCurrency(), Ledger::reportingCurrency()));
                }
            }

            if (shouldUpdateLedgerJournalTable)
            {
                ttsbegin;

                this.doUpdate();

                ttscommit;
            }
        }

        return areExchangeRatesValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inheritBankTransSummarizationConfigurationFromJournalName</Name>
				<Source><![CDATA[
    internal void inheritBankTransSummarizationConfigurationFromJournalName(LedgerJournalNameId _journalNameId = this.JournalName)
    {
        LedgerJournalName ledgerJournalName = LedgerJournalName::find(_journalNameId);
        this.BankTransSummarizationEnabled = ledgerJournalName.BankTransSummarizationEnabled;
        this.BankTransSummarizationCriteria = ledgerJournalName.BankTransSummarizationCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSessionInfo</Name>
				<Source><![CDATA[
    internal static void setSessionInfo(LedgerJournalTable _ledgerJournalTable)
    {
        ttsbegin;
        _ledgerJournalTable.selectForUpdate(true);

        // Associate our session information with the record
        xSession xSession = new xSession(sessionid());
        _ledgerJournalTable.SessionId = sessionid();
        _ledgerJournalTable.SessionLoginDateTime = xSession.loginDateTime();
        _ledgerJournalTable.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockJournalAndSetSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set system lock and current session on journal
    /// </summary>
    /// <param name = "_ledgerJournalTable">ledger journal table to be updated</param>
    /// <param name = "_blockedReason">reason of system lock</param>
    internal static void lockJournalAndSetSession(
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalSystemBlockedReason _blockedReason)
    {
        ttsbegin;
        _ledgerJournalTable.selectForUpdate(true);

        _ledgerJournalTable.SystemBlocked = NoYes::Yes;
        _ledgerJournalTable.SystemBlockedReason = _blockedReason;

        // Associate our session information with the record 
        xSession xSession = new xSession(sessionid());
        _ledgerJournalTable.SessionId = sessionid();
        _ledgerJournalTable.SessionLoginDateTime = xSession.loginDateTime();

        _ledgerJournalTable.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unlock the journal
    /// </summary>
    /// <param name = "_journalToUnlock">ledger journal table to be unlocked</param>
    internal static void unlockJournal(LedgerJournalTable _journalToUnlock)
    {
        ttsbegin;
        _journalToUnlock.selectForUpdate(true);
        _journalToUnlock.SystemBlocked = 0;
        _journalToUnlock.SystemBlockedReason = LedgerJournalSystemBlockedReason::None;
        _journalToUnlock.SessionId = 0;
        _journalToUnlock.SessionLoginDateTime = utcDateTimeNull();
        _journalToUnlock.UserBlockId = '';
        _journalToUnlock.InUseBy = '';
        _journalToUnlock.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIsBlockedOrInUse</Name>
				<Source><![CDATA[
    internal boolean checkIsBlockedOrInUse()
    {
        if (!this.checkNotSystemBlocked() ||
            !this.checkNotGroupBlocked()  ||
            !this.checkNotUserBlocked() ||
            !this.checkNotInUse())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasJournalControl</Name>
				<Source><![CDATA[
    internal static boolean hasJournalControl(LedgerJournalNameId _journalName)
    {
        LedgerJournalControlHeader ledgerJournalControlHeader;

        select firstonly RecId from ledgerJournalControlHeader
            where ledgerJournalControlHeader.JournalName == _journalName;
        return ledgerJournalControlHeader.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCheckTaxBooksSetup_IT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks TaxBookTypeJournal of journal name to determine if it's ok to check further of TaxBookSection for Italy.
    /// </summary>
    /// <returns>true, if the journal name is valid for tax book setup check; otherwise, false.</returns>
    internal boolean shouldCheckTaxBooksSetup_IT()
    {
        #ISOCountryRegionCodes
        boolean ret;

        // Italian functionality of VAT books
        if (MultipleTaxIdReportingHelper::isLegalEntityOrAddressInCountryRegion([#isoIT], MultipleTaxIdScope::VATDeclaration)
            && this.ledgerJournalName().TaxBookTypeJournal != TaxBookTypeJournal::Empty)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasic</ConfigurationKey>
	<DeveloperDocumentation>@SYS125938</DeveloperDocumentation>
	<FormRef>LedgerJournalTable</FormRef>
	<Label>@SYS55327</Label>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>JournalNum</TitleField1>
	<TitleField2>JournalName</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>PostedJournalNumIdx</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<Modules>AccountingFoundation</Modules>
	<PrimaryIndex>TypeNumIdx</PrimaryIndex>
	<ReplacementKey>TypeNumIdx</ReplacementKey>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>CustBillOfExchangeJour</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>CustBillOfExchangeJour</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CustVendPaymProposalLine</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustVendPaymProposalLine</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>LedgerJournalTrans</Name>
			<DeleteAction>CascadeRestricted</DeleteAction>
			<Relation></Relation>
			<Table>LedgerJournalTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction1</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>LedgerJournalTable</Relation>
			<Table>LedgerJournalTable_Customs_IT</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction2</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustVendPaymProposalBatchProcess</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JournalNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NumberSequenceTable</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetAccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Posted</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JournalName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JournalNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@SYS80094</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RetailStatementId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Amount</Name>
			<Label>@SYS12227</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ApprovalProcedure</Name>
			<Label>@SYS28125</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReportedAsReadyBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Approver</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RejectedBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkflowApprovalStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AssetTransferStatus_LT</Name>
			<Label>@GLS113451</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AssetTransferType_LT</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BillOfExchange</Name>
			<Label>@SYS69795</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankRemittanceType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankAccountId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>DefaultValues</Name>
			<Label>@SYS21682</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OffsetAccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FixedOffsetAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FixedExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchrateSecondary</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EUROTriangulation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrentOperationsTax</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetLedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Description</Name>
			<Label>@SYS6303</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DocumentNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimension</Name>
			<Label>@SYS342338</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JournalNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>JournalTotals</Name>
			<Label>@SYS26007</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JournalBalance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalTotalDebit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalTotalCredit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>journalTotalOffsetBalance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EndBalance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalTotalDebitReportingCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalTotalCreditReportingCurrency</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Log</Name>
			<Label>@SYS2515</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Log</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OriginalJournalNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Named</Name>
			<Label>@SYS26819</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JournalName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Origin</Name>
			<Label>@SYS101765</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OriginalCompany</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OriginalJournalNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PaymentsGenerated</Name>
			<Label>@SYS99755</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymentsGenerated_IT</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Post</Name>
			<Label>@SYS6098</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Posted</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PostedDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DetailSummaryPosting</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LinesLimitBeforeDistribution</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PromissoryNote</Name>
			<Label>@SYS71440</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankAccountId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Protest</Name>
			<Label>@SYS71693</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProtestSettledBill</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustVendNegInstProtestProcess</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReversingEntry</Name>
			<Label>@SYS116155</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReverseEntry</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReverseDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTax</Name>
			<Label>@SYS5878</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerJournalInclTax</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxObligationCompany</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DelayTaxCalculation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OverrideSalesTax</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Session</Name>
			<Label>@SYS7115</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SessionId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SessionLoginDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SystemLog</Name>
			<Label>@SYS20367</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SystemBlocked</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UserBlockId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GroupBlockId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InUseBy</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Totals</Name>
			<Label>@SYS8311</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>NumOfLines</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>UnifiedWorkListPreview</Name>
			<Label>@SYS116253</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VoucherAllocation</Name>
			<Label>@SYS85406</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VoucherAllocatedAtPosting</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VoucherJournalTable</Name>
			<Label>@SYS22363</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>NumberSequenceTable</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReportingCurrency</Name>
			<Label>@GeneralLedger:ReportingCurrency</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReportingCurrencyFixedExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReportingCurrencyExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReportingCurrencyExchRateSecondary</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>UserBlockId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JournalBlockUserId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Approver</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasic</ConfigurationKey>
			<ExtendedDataType>HcmApprover</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AssetTransferType_LT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>LtAssetTransferType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankAccountId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CustVendNegotiableInstrument</ConfigurationKey>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankRemittanceType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>BankRemittanceType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencyCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CurrentOperationsTax</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CurrentOperationsTax</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CustVendNegInstProtestProcess</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CustVendNegInstProtestProcess</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionValueSet</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DetailSummaryPosting</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>DetailSummary</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DocumentNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DocumentNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EndBalance</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalEndBalance</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>EUROTriangulation</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EUROTriangulation</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchRate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExchRate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchrateSecondary</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExchrateSecondary</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>FixedExchRate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>FixedExchRate</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>FixedOffsetAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>FixedOffsetAccount</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>GroupBlockId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JournalBlockUserGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InUseBy</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>UserId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>JournalBalance</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalBalance</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>JournalName</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalNameId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>JournalNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>JournalTotalCredit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Label>@SYS55617</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>JournalTotalDebit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Label>@SYS55615</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>journalTotalOffsetBalance</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Label>@SYS55069</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>JournalType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>LedgerJournalType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LedgerJournalInclTax</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalInclTax</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>LinesLimitBeforeDistribution</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalLinesLimit</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Log</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LogText</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Name</ExtendedDataType>
			<Label>@SYS6303</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>NumberSequenceTable</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS4105</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>NumOfLines</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JournalNumOfLines</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OffsetAccountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<SysSharingType>Never</SysSharingType>
			<EnumType>LedgerJournalACType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OffsetLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDynamicDefaultAccount</ExtendedDataType>
			<Label>@SYS11162</Label>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OriginalCompany</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerAdvIntercompanyAccounting</ConfigurationKey>
			<ExtendedDataType>SelectableDataArea</ExtendedDataType>
			<Label>@SYS68851</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OriginalJournalNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalId</ExtendedDataType>
			<Label>@SYS53617</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldContainer">
			<Name>PackedExtensions</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SysExtensionSerializerPackedContainer</ExtendedDataType>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ParentJournalNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalId</ExtendedDataType>
			<Label>@LedgerJournal:ParentJournalNumber</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PaymentsGenerated_IT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>IT</CountryRegionCodes>
			<Label>@SYS99755</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Posted</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JournalPosted</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>PostedDateTime</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JournalPostedDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProtestSettledBill</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CustVendNegotiableInstrument</ConfigurationKey>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS73750</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RejectedBy</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ConfigurationKey>LedgerBasic</ConfigurationKey>
			<ExtendedDataType>UserId</ExtendedDataType>
			<Label>@SYS22205</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RemoveLineAfterPosting</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalDelLine</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReportedAsReadyBy</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ConfigurationKey>LedgerBasic</ConfigurationKey>
			<ExtendedDataType>UserId</ExtendedDataType>
			<Label>@SYS22056</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RetailStatementId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailStatementId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ReverseDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasicReversingEntries</ConfigurationKey>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS116153</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReverseEntry</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasicReversingEntries</ConfigurationKey>
			<Label>@SYS116155</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>SessionId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JournalSessionId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>SessionLoginDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JournalSessionLoginDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SystemBlocked</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JournalSystemBlocked</ExtendedDataType>
			<Label>@SYS21780</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxObligationCompany</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>TaxObligationCompany</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>VoucherAllocatedAtPosting</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VoucherAllocatedAtPosting</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkflowApprovalStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>LedgerJournalWFApprovalStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsLedgerDimensionNameUpdated</Name>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ReportingCurrencyExchRate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReportingCurrencyExchRate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ReportingCurrencyExchRateSecondary</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReportingCurrencyExchRateSecondary</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReportingCurrencyFixedExchRate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReportingCurrencyFixedExchRate</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>JournalTotalCreditReportingCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMSTSecondary</ExtendedDataType>
			<Label>@GeneralLedger:CreditTotalReportingCurrency</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>JournalTotalDebitReportingCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMSTSecondary</ExtendedDataType>
			<Label>@GeneralLedger:DebitTotalReportingCurrency</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>IntegrationKey</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CDSIntegrationKey</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DelayTaxCalculation</Name>
			<HelpText>@TaxDelayTaxCalculation:DelayTaxCalculationDescription</HelpText>
			<Label>@TaxDelayTaxCalculation:DelayTaxCalculation</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OverrideSalesTax</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxIntegrationOverrideSalesTax</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>FinTag</Name>
			<ExtendedDataType>FinTagRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsAdjustmentJournal</Name>
			<AssetClassification>System metadata</AssetClassification>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SystemBlockedReason</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>LedgerJournalSystemBlockedReason</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TypeNumIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>JournalNum</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PostedJournalNumIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>JournalType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Posted</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JournalNum</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueSetIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>DefaultDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueCombinationIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>OffsetLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ApproverIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>Approver</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>JournalNumRetailStatementIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>JournalNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RetailStatementId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>MRJournalNumIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>JournalNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Name</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JournalType</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JournalName</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ModifiedBy</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PostedDateTime</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TypePostedParentJournalNumIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ParentJournalNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Posted</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SystemBlockedPerfIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>SystemBlocked</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Posted</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PostedJournalTypeIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PostedDateTime</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Posted</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JournalType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JournalName</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>CustVendInvoiceJour</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>AttorneyDate_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>AttorneyId_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>AttorneyIssuedName_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CashDisc</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CashDiscBaseDate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CashDiscCode</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CashDiscDate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ConsigneeAccount_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ConsignorAccount_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ConsInvoice_JP</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CorrectedInvoiceDate_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CorrectedInvoiceId_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Correct_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DefaultDimension</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryDate_ES</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryName_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryPostalAddress_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DocumentDate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DocumentNum</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DueDate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EndDisc</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EndDisc_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchRate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchRateSecondary</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FacturedFully_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FactureId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FactureModule_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FixedDueDate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>GroupId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InclTax</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>IntrastatFulfillmentDate_HU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventOwnerId_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventProfileType_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceAccount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceAmountMST_JP</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceAmountMST_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceDate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceId</MapField>
					<MapFieldTo>JournalNum</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceNum</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceRegister_LT</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceStatus_LT</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LanguageId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LedgerVoucher</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>MCRPaymOrderID</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>NonRealRevenue_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Num</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>NumberSequenceCode_LT</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>NumberSequenceGroupId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>OffSessionId_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>OneTimeAccount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>OrderAccount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PaymDayId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Payment</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PaymentSched</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PaymId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PostingProfile</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Prepayment</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PrintCopies_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PrintOriginals_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PrintStandardCurrency_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Proforma</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PurchInternalInvoiceId_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>RoundOff_W</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesInvoicePostingType_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesOrderbalance</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceDocumentHeader_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SumTax</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Triangulation</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>UnitedVATInvoice</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Updated</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VATNum</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VATOnPayment_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VendPaymentGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>WhoIsAuthor_LT</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>JournalTableMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>BlockUserGroupId</MapField>
					<MapFieldTo>GroupBlockId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>BlockUserId</MapField>
					<MapFieldTo>UserBlockId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeletePostedLines</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Description</MapField>
					<MapFieldTo>Name</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DetailSummary</MapField>
					<MapFieldTo>DetailSummaryPosting</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JournalId</MapField>
					<MapFieldTo>JournalNum</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JournalIdOriginal</MapField>
					<MapFieldTo>OriginalJournalNum</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JournalNameId</MapField>
					<MapFieldTo>JournalName</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JournalType</MapField>
					<MapFieldTo>JournalType</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>NumOfLines</MapField>
					<MapFieldTo>NumOfLines</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Posted</MapField>
					<MapFieldTo>Posted</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PostedDateTime</MapField>
					<MapFieldTo>PostedDateTime</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PostedUserId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SessionId</MapField>
					<MapFieldTo>SessionId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SessionLoginDateTime</MapField>
					<MapFieldTo>SessionLoginDateTime</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SystemBlocked</MapField>
					<MapFieldTo>SystemBlocked</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxObligationCompany</MapField>
					<MapFieldTo>TaxObligationCompany</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TimesheetNbr</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VoucherChange</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VoucherDraw</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VoucherNumberSeq</MapField>
					<MapFieldTo>NumberSequenceTable</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SysExtensionSerializerMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>PackedExtensions</MapField>
					<MapFieldTo>PackedExtensions</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PackedPrioritizedIdList</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalTable</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>InclTax</MapField>
					<MapFieldTo>LedgerJournalInclTax</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Posted</MapField>
					<MapFieldTo>Posted</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>TableId</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>LedgerJournalReportingCurrencyExchangeRates</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>ExchangeRate</MapField>
					<MapFieldTo>ExchRate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchangeRateSecond</MapField>
					<MapFieldTo>ExchrateSecondary</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ReportingCurrencyExchangeRate</MapField>
					<MapFieldTo>ReportingCurrencyExchRate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ReportingCurrencyExchangeRateSecond</MapField>
					<MapFieldTo>ReportingCurrencyExchRateSecondary</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Approver_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>Approver_LedgerJournalTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Approver</Name>
					<Field>Approver</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankAccountTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankAccountTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankAccountId</Name>
					<SourceEDT>CompanyBankAccountId</SourceEDT>
					<Field>BankAccountId</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Currency</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CurrencyCode</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>CurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DataArea</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>DataArea</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OriginalCompany</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<Field>OriginalCompany</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>isVirtual_Extern</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<RelatedField>isVirtual</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DefaultDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalName</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalName</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JournalName</Name>
					<SourceEDT>LedgerJournalNameId</SourceEDT>
					<Field>JournalName</Field>
					<RelatedField>JournalName</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>JournalNameIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OriginalJournalNum</Name>
					<SourceEDT>LedgerJournalId</SourceEDT>
					<Field>OriginalJournalNum</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TypeNumIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>NumberSequenceTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>NumberSequenceTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>NumberSequenceTable</Name>
					<Field>NumberSequenceTable</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>OffsetLedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetLedgerDimension</Name>
					<Field>OffsetLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>UserGroupInfo</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>UserGroupInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>GroupBlockId</Name>
					<SourceEDT>JournalBlockUserGroupId</SourceEDT>
					<Field>GroupBlockId</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>UserIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>UserInfo_InUseBy</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>UserInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>UserInfo_InUseBy</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InUseBy</Name>
					<SourceEDT>UserId</SourceEDT>
					<Field>InUseBy</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>UserInfo_RejectedBy</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>UserInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>UserInfo_RejectedBy</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RejectedBy</Name>
					<SourceEDT>UserId</SourceEDT>
					<Field>RejectedBy</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>UserInfo_ReportedAsReadyBy</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>UserInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>UserInfo_ReportedAsReadyBy</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReportedAsReadyBy</Name>
					<SourceEDT>UserId</SourceEDT>
					<Field>ReportedAsReadyBy</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>UserInfo_UserBlockId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>UserInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>UserInfo_UserBlockId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>UserBlockId</Name>
					<SourceEDT>JournalBlockUserId</SourceEDT>
					<Field>UserBlockId</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LedgerJournalTable_JournalNum</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LedgerJournalTable</RelatedTable>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JournalNum</Name>
					<Field>JournalNum</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>FinTag</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>FinTag</RelatedTable>
			<RelatedTableRole>FinTag</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans_FinTag</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FinTag</Name>
					<Field>FinTag</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>