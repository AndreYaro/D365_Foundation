<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSOutboundSortPosition</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class WHSOutboundSortPosition extends common
{

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    public static WHSOutboundSortPosition find(
        WHSOutboundSortPositionRecId    _recId,
        boolean                         _forupdate = false)
    {
        WHSOutboundSortPosition sortPosition;
    
        if (_recId)
        {
            sortPosition.selectForUpdate(_forUpdate);
    
            select firstOnly sortPosition
                where sortPosition.RecId == _recId;
        }
    
        return sortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAndClosePosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>WHSOutboundSortPosition</c> record with an Assigned sort position status
    /// matching the given sort identifier to close the position.
    /// </summary>
    /// <param name = "_sortIdentifier">
    /// The given sort identifier associated with the position.
    /// </param>
    /// <param name = "_closeAsFull">
    /// true if closing position as full; otherwise, false.
    /// </param>
    internal static void findAndClosePosition(WHSOutboundSortIdentifier	_sortIdentifier)
    {
        WHSSortPutawayValidator sortPutawayValidator = WHSSortPutawayValidator::newWithIdentifier(_sortIdentifier);

        sortPutawayValidator.validateOnlyOneSortPosition();

        ttsbegin;

        WHSOutboundSortPosition sortPosition = WHSOutboundSortPosition::findBySortIdentifier(_sortIdentifier, true);

        sortPosition.closeSortPosition();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAndClosePositionAsFull</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>WHSOutboundSortPosition</c> record with an Assigned sort position status
    /// matching the given sort identifier to close the position using the full functionality.
    /// </summary>
    /// <param name = "_sortIdentifier">
    /// The given sort identifier associated with the position.
    /// </param>
    /// <param name = "_sortPositionId">
    /// The given sort position id to close as full.
    /// </param>
    internal static void findAndClosePositionAsFull(
        WHSOutboundSortIdentifier	_sortIdentifier,
        WHSOutboundSortPositionId   _sortPositionId)
    {
        WHSSortPutawayValidator sortPutawayValidator = WHSSortPutawayValidator::newWithIdentifier(_sortIdentifier);

        sortPutawayValidator.validateOnlyOneSortPosition();

        ttsbegin;

        WHSOutboundSortPosition sortPosition = WHSOutboundSortPosition::findBySortIdentifier(_sortIdentifier, true);

        if (!sortPosition)
        {
            // If using a position with no sort transaction, find with the sort position ID.
            sortPosition = WHSOutboundSortPosition::findBySortPositionId(_sortPositionId, true);
        }

        sortPosition.closeSortPositionAsFull(_sortIdentifier);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAndClosePositionFromPositionLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>WHSOutboundSortPosition</c> record with an Assigned sort position status
    /// matching the given sort position license plate to close the position.
    /// </summary>
    /// <param name = "_sortPositionLP">
    /// The given sort position license plate associated with the position.
    /// </param>
    [Hookable(false)]
    internal static void findAndClosePositionFromPositionLP(WHSLicensePlateId _sortPositionLP)
    {
        ttsbegin;

        WHSOutboundSortPosition sortPosition = WHSOutboundSortPosition::findByAssignedSortPositionLP(_sortPositionLP, true);

        if (sortPosition)
        {
            sortPosition.closeSortPosition();
        }
        else
        {
            throw Error("@WAX:WHSOutboundSortPositionCloseError");
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySortIdentifier</Name>
				<Source><![CDATA[
    private static WHSOutboundSortPosition findBySortIdentifier(
        WHSOutboundSortIdentifier   _sortIdentifier,
        boolean                     _forUpdate = false)
    {
        WHSOutboundSortPosition      sortPosition;
        WHSOutboundSortPositionTrans sortPositionTrans;

        if (_sortIdentifier)
        {
            sortPosition.selectForUpdate(_forUpdate);

            select forupdate sortPosition
                where sortPosition.SortPositionStatus == WHSOutboundSortPositionStatus::Assigned
                exists join sortPositionTrans
                    where sortPositionTrans.OutboundSortPosition    == sortPosition.RecId
                    &&    sortPositionTrans.SortIdentifier          == _sortIdentifier;
        }

        return sortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySortPositionId</Name>
				<Source><![CDATA[
    private static WHSOutboundSortPosition findBySortPositionId(
        WHSOutboundSortPositionId   _sortPositionId,
        boolean                     _forUpdate)
    {
        WHSOutboundSortPosition	sortPosition;

        if (_sortPositionId)
        {
            sortPosition.selectForUpdate(_forUpdate);

            select firstonly forupdate sortPosition
                where sortPosition.SortPositionId       == _sortPositionId
                &&    sortPosition.SortPositionStatus   == WHSOutboundSortPositionStatus::Assigned;
        }

        return sortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findForContainerBySortTemplateId</Name>
				<Source><![CDATA[
    private static WHSOutboundSortPosition findForContainerBySortTemplateId(
        WHSOutboundSortPositionId   _sortPositionId,
        WHSOutboundSortTemplateId	_sortTemplateId,
        boolean                     _forUpdate)
    {
        WHSOutboundSortPosition	sortPosition;
        WHSOutboundSortTemplate sortTemplate;

        if (_sortPositionId && _sortTemplateId)
        {
            sortPosition.selectForUpdate(_forUpdate);

            select firstonly sortPosition
                where sortPosition.SortPositionId       == _sortPositionId
                &&    sortPosition.SortPositionStatus   == WHSOutboundSortPositionStatus::Assigned
                &&	  sortPosition.SortTemplateId		== _sortTemplateId
                exists join sortTemplate
                    where sortTemplate.SortTemplateId == sortPosition.SortTemplateId
                    &&	  sortTemplate.SortTemplateType == WHSOutboundSortTemplateType::Container;
        }

        return sortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByAssignedSortPositionLP</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static WHSOutboundSortPosition findByAssignedSortPositionLP(
         WHSLicensePlateId  _sortPositionLP,
         boolean            _forUpdate = false)
    {
        WHSOutboundSortPosition sortPosition;
    
        if (_sortPositionLP)
        {
            sortPosition.selectForUpdate(_forUpdate);
    
            select firstonly sortPosition
                where sortPosition.SortPositionStatus == WHSOutboundSortPositionStatus::Assigned
                &&    sortPosition.LicensePlateId     == _sortPositionLP;
        }
    
        return sortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewContainerSortPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a new sort position for container.
    /// </summary>
    /// <param name="_sortTemplate">
    /// The sort template used to create the sort position.
    /// </param>
    /// <param name="_sortPositionId">
    /// The new sort position's ID.
    /// </param>
    /// <param name="_sortIdentifier">
    /// The sort identifier that is being sorted to the new position.
    /// </param>
    /// <returns>
    /// The newly created sort position.
    /// </returns>
    [Hookable(false)]
    public static WHSOutboundSortPosition createNewContainerSortPosition(
        WHSOutboundSortTemplate     _sortTemplate,
        WHSOutboundSortPositionId   _sortPositionId,
        WHSOutboundSortIdentifier	_sortIdentifier)
    {
        return WHSOutboundSortPosition::createNewContainerSortPositionWithWarehouseAndLocation(
            _sortTemplate, 
            _sortTemplate.InventLocationId,
            _sortTemplate.WMSLocationId,
            _sortPositionId,
            _sortIdentifier);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewContainerSortPositionWithWarehouseAndLocation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static WHSOutboundSortPosition createNewContainerSortPositionWithWarehouseAndLocation(
        WHSOutboundSortTemplate     _sortTemplate,
        InventLocationId            _warehouseId,
        WMSLocationId               _locationId,
        WHSOutboundSortPositionId   _sortPositionId,
        WHSOutboundSortIdentifier	_sortIdentifier)
    {
        if (appl.ttsLevel() == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        WHSOutboundSortPosition sortPosition;

        if (_sortPositionId && _sortIdentifier && _sortTemplate)
        {
            sortPosition.SortPositionId     = _sortPositionId;
            sortPosition.SortPositionStatus = WHSOutboundSortPositionStatus::Assigned;
            sortPosition.initFromSortTemplateIdWarehouseAndLocation(_sortTemplate.SortTemplateId, _warehouseId, _locationId);
    
            sortPosition.insert();
    
            WHSOutboundSortPositionCriteria::createContainerSortPositionCriteria(_sortTemplate, sortPosition, _sortIdentifier);
        }

        return sortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewWaveDemandSortPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a new outbound sort position for wave demand inventory.
    /// </summary>
    /// <param name="_sortTemplate">
    /// The sort template used to create the sort position.
    /// </param>
    /// <param name="_sortPositionId">
    /// The new sort position's ID.
    /// </param>
    /// <param name="_sortIdentifier">
    /// The sort identifier for the inventory being sorted.
    /// </param>
    /// <param name="_itemId">
    /// The item being sorted.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions being sorted.
    /// </param>
    /// <returns>
    /// The newly created sort position.
    /// </returns>
    [Hookable(false)]
    public static WHSOutboundSortPosition createNewWaveDemandSortPosition(
        WHSOutboundSortTemplate     _sortTemplate,
        WHSOutboundSortPositionId   _sortPositionId,
        WHSOutboundSortIdentifier   _sortIdentifier,
        ItemId                      _itemId,
        InventDim                   _inventDim)
    {
        if (appl.ttsLevel() == 0 || _sortTemplate.SortTemplateType != WHSOutboundSortTemplateType::WaveDemand)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        WHSOutboundSortPosition sortPosition;

        sortPosition.SortPositionId     = _sortPositionId;
        sortPosition.SortPositionStatus = WHSOutboundSortPositionStatus::Assigned;

        sortPosition.initFromSortTemplateIdWarehouseAndLocation(_sortTemplate.SortTemplateId, _inventDim.InventLocationId, _inventDim.wMSLocationId);
        sortPosition.insert();

        WHSOutboundSortPositionCriteria::createWaveDemandSortPositionCriteria(_sortTemplate,
                                                                              sortPosition,
                                                                             _sortIdentifier,
                                                                             _itemId,
                                                                             _inventDim);

        return sortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewWaveSortPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new outbound sort position from wave.
    /// </summary>
    /// <param name="_waveId">
    /// A wave ID to create sort positions for.
    /// </param>
    /// <param name="_sortTemplate">
    /// A sort template used to create the sort position.
    /// </param>
    /// <param name="_sortPositionId">
    /// The new sort position's ID.
    /// </param>
    /// <param name="_queryRun">
    /// The query run object used to get the date for the sort position.
    /// </param>
    /// <returns>
    /// The create sort position record.
    /// </returns>
    [Hookable(false)]
    public static WHSOutboundSortPosition createNewWaveSortPosition(
        WHSWaveId                   _waveId,
        WHSOutboundSortTemplate     _sortTemplate,
        WHSOutboundSortPositionId   _sortPositionId,
        QueryRun                    _queryRun)
    {
        if (appl.ttsLevel() == 0 || _sortTemplate.SortTemplateType != WHSOutboundSortTemplateType::WaveDemand)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        WHSOutboundSortPosition sortPosition;
    
        sortPosition.WaveId                 = _waveId;
        sortPosition.SortPositionId         = _sortPositionId;
        sortPosition.SortPositionStatus     = WHSOutboundSortPositionStatus::Assigned;

        InventLocationId warehouseId = WHSWaveTable::find(_waveId).InventLocationId;

        sortPosition.initFromSortTemplateIdWarehouseAndLocation(_sortTemplate.SortTemplateId, warehouseId, _sortTemplate.defaultSortingLocationId(warehouseId));
       
        
        var context = WHSOutboundSortPositionCreateContext::current();

        if (context && context.sortPositionNum)
        {
            sortPosition.SortPositionNum = context.sortPositionNum;
        }
        
    
        sortPosition.insert();
    
        WHSOutboundSortPositionCriteria::createWaveSortPositionCriteria(_sortTemplate,
                                                                        sortPosition,
                                                                        _queryRun);
    
        return sortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeSortPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the sort position, creating work or picking against the order based on setup.
    /// </summary>
    public void closeSortPosition()
    {
        if (appl.ttsLevel() == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        this.SortPositionStatus = WHSOutboundSortPositionStatus::Closed;
    
        this.update();
    
        WHSOutboundSortTemplate sortTemplate = WHSOutboundSortTemplate::find(this.SortTemplateId);

        // Pack position as container if configured on template.
        if (sortTemplate.AutoPackSortPosition)
        {
            this.packSortPosition(sortTemplate.PackProfileId);
        }
    
        if (sortTemplate.CreateWorkOnPositionClose)
        {
            if (WHSOutboundSortPositionTrans::existByOutboundSortPosition(this.RecId))
            {
                WHSWorkBuildId workBuildId = this.createWorkForSortedInventoryPicking();

                this.validateWorkCreation(workBuildId);

                if (sortTemplate.AutoPackSortPosition)
                {
                    this.updateContainerIdOnWorkTable();
                }
            }
        }
        else
        {
            this.pickPositionForOrder();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkCreation</Name>
				<Source><![CDATA[
    private void validateWorkCreation(WHSWorkBuildId _workBuildId)
    {
        WHSWorkTable workTable;

        select firstonly RecId from workTable
            where workTable.WorkBuildId == _workBuildId
            && workTable.WorkTransType == WHSWorkTransType::SortedInventoryPicking;

        if (!workTable.RecId)
        {
            throw Exception::Error;
        }
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkForSortedInventoryPicking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates work for the sorted inventory picking work creation process.
    /// </summary>
    /// <returns>The work creation number.</returns>
    protected WHSWorkBuildId createWorkForSortedInventoryPicking()
    {
        return WHSWorkCreateSortedInventoryPicking::construct(this).createWork();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateContainerIdOnWorkTable</Name>
				<Source><![CDATA[
    private void updateContainerIdOnWorkTable()
    {
        ttsbegin;

        WHSWorkTable workTable = WHSWorkTable::findByLicensePlateForUpdate(this.LicensePlateId, false, WHSWorkStatus::PendingReview, true);
        
        workTable.ContainerId = this.LicensePlateId;

        workTable.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeSortPositionAsFull</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the current sort position and creates a new copy of that sort position for additional sorting of the container or license plate (sort identifier).
    /// </summary>
    /// <param name = "_sortIdentifier">
    /// The given sort identifier associated with the position.
    /// </param>
    [Hookable(false)]
    public void closeSortPositionAsFull(WHSOutboundSortIdentifier _sortIdentifier)
    {
        if (appl.ttsLevel() == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        this.closeSortPosition();

        WHSOutboundSortPosition newSortPosition = this.createSortPositionCopyWithCriteria();

        if (!newSortPosition.RecId)
        {
            throw error(strFmt("@WAX:WHSOutboundSortPositionUnableToCreateError", this.SortPositionId));
        }

        WHSOutboundSortPositionTrans::createContainerSortPositionTransAndRemoveRFInstruction(_sortIdentifier,
                                                                                             newSortPosition.RecId,
                                                                                             newSortPosition.SortTemplateId);

        WHSOutboundSortRFInstruction sortInstruction;

        update_recordSet sortInstruction
            setting OutboundSortPositionRecId = newSortPosition.RecId
            where sortInstruction.OutboundSortPositionRecId == this.RecId;

        // Any work lines that have not been physically sorted but were supposed to go to the old, full sort position now go to the new sort position.
        WHSOutboundSortPosition::updateUnSortedWorkLinesToNewSortPosition(this.RecId, newSortPosition.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUnSortedWorkLinesToNewSortPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates work lines that have not yet been sorted to their assigned sort position to a different sort position.
    /// </summary>
    /// <param name="_currentSortPositionRecId">
    /// The current sort position the work lines are assigned to.
    /// </param>
    /// <param name="_newSortPositionRecId">
    /// The new sort position the work lines are going to be assigned to.
    /// </param>
    private static void updateUnSortedWorkLinesToNewSortPosition(
        WHSOutboundSortPositionRecId    _currentSortPositionRecId,
        WHSOutboundSortPositionRecId    _newSortPositionRecId)
    {
        WHSWorkLine   workLine;

        update_recordSet workLine
            setting OutboundSortPosition         = _newSortPositionRecId
            where workLine.OutboundSortPosition  == _currentSortPositionRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSortPositionCopyWithCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a copy of the given sort position, including sort position criteria.
    /// </summary>
    /// <returns>
    /// The new sort position that is a copy of the original.
    /// </returns>
    private WHSOutboundSortPosition createSortPositionCopyWithCriteria()
    {
        WHSOutboundSortPosition     newSortPosition;

        buf2Buf(this, newSortPosition);

        newSortPosition.LicensePlateId       = '';
        newSortPosition.SortPositionStatus   = WHSOutboundSortPositionStatus::Assigned;
            
        newSortPosition.insert();

        WHSOutboundSortPosition::copySortPositionsCriteria(this.RecId, newSortPosition.RecId);

        return newSortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copySortPositionsCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates duplicate sort position criteria from one sort position to another.
    /// </summary>
    /// <param name="_copyFromSortPositionRecId">
    /// The record Id of the sort position we are copying criteria from.
    /// </param>
    /// <param name="_copyToSortPositionRecId">
    /// The record Id of the sort position we are copying criteria to.
    /// </param>
    private static void copySortPositionsCriteria(
        WHSOutboundSortPositionRecId _copyFromSortPositionRecId,
        WHSOutboundSortPositionRecId _copyToSortPositionRecId)
    {
        RecordInsertList recInsertList = new RecordInsertList(tableNum(WHSOutboundSortPositionCriteria));

        WHSOutboundSortPositionCriteria sortPositionCriteria;

        while select sortPositionCriteria
            where sortPositionCriteria.OutboundSortPosition == _copyFromSortPositionRecId
        {
            WHSOutboundSortPositionCriteria copyOfSortPositionCriteria;

            buf2Buf(sortPositionCriteria, copyOfSortPositionCriteria);

            copyOfSortPositionCriteria.RecId = 0;
            copyOfSortPositionCriteria.OutboundSortPosition = _copyToSortPositionRecId;

            recInsertList.add(copyOfSortPositionCriteria);
        }

        recInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickPositionForOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pick the inventory in a position against the order.
    /// </summary>
    private void pickPositionForOrder()
    {
        WHSOutboundSortPositionTrans    sortPositionTrans;
        InventTable                     inventTable;
    
        while select ItemId, ProductQuantity, UnitSymbol, InventDimId, LoadLine, RecId from sortPositionTrans
            where sortPositionTrans.OutboundSortPosition == this.RecId
            join inventTable
                where inventTable.ItemId == sortPositionTrans.ItemId
        {
            // Need to select loadLine in the loop so in case multiple sortPositionTrans reference the same load Line.
            WHSLoadLine loadLine = WHSLoadLine::findbyRecId(sortPositionTrans.LoadLine, true);
    
            InventDimParm inventDimParmAboveLocation = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(inventTable);
    
            InventHandlingQty locInventQty = InventTableModule::unitConvert(sortPositionTrans.ItemId,
                                                                            ModuleInventPurchSales::Invent,
                                                                            sortPositionTrans.UnitSymbol,
                                                                            sortPositionTrans.ProductQuantity,
                                                                            sortPositionTrans.InventDimId);
    
            loadLine.PickedQty += locInventQty;

            loadLine.update();
    
            InventDim pickInventDim = InventDim::find(sortPositionTrans.InventDimId);

            pickInventDim.wMSLocationId     = this.WMSLocationId;
            pickInventDim.LicensePlateId    = this.LicensePlateId;
            pickInventDim                   = InventDim::findOrCreate(pickInventDim);

            WhsInventTransPickIdAllocator pickIdAllocator = (WHSInventTransPickIdAllocationConfigurationProvider::isInventTransPickIdAllocationEnabled() ? WhsLoadLineInventTransPickIdAllocator::newFromLoadLineAndPickedQuantity(loadLine, locInventQty) : null);

            using (WhsInventPickingContext context = WhsInventPickingContext::newFromPickIdAllocator(pickIdAllocator))
            {
                WHSInvent::pickTargetTransaction(WHSInvent::getCommonFromWorkTransType(WHSWorkTransType::SortedInventoryPicking, loadLine.InventTransId),
                                                 pickInventDim.InventDimId,
                                                 locInventQty,
                                                 inventDimParmAboveLocation,
                                                 true);
            }

            if (pickIdAllocator)
            {
                pickIdAllocator.allocationComplete();
            }
    
            if (WHSLoadTable::validateLoadCanBeLoaded(loadLine.LoadId))
            {
                WHSLoadTable::updateLoadStatus(loadLine.LoadId, WHSLoadStatus::Loaded);
            }

            if (WHSShipmentTable::validateShipmentCanBeLoaded(loadLine.ShipmentId))
            {
                WHSShipmentTable::updateShipmentStatus(loadLine.ShipmentId, WHSShipmentStatus::Loaded);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForLicensePlateId</Name>
				<Source><![CDATA[
    public static boolean existForLicensePlateId(WHSLicensePlateId _licensePlateId)
    {
        return _licensePlateId &&
               (select firstOnly LicensePlateId from WHSOutboundSortPosition
                    where WHSOutboundSortPosition.LicensePlateId == _licensePlateId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsForAssignedLicensePlateId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a record exists with assigned status for a specified license plate ID.
    /// </summary>
    /// <param name = "_licensePlateId">The license plate ID to search for.</param>
    /// <returns>true if a record exists for the license plate ID in assigned status; otherwise, false.</returns>
    [Hookable(false)]
    public static boolean existsForAssignedLicensePlateId(WHSLicensePlateId	_licensePlateId)
    {
        return WHSOutboundSortPosition::findForAssignedLicensePlateId(_licensePlateId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findForAssignedLicensePlateId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a record with assigned status for a specified license plate ID.
    /// </summary>
    /// <param name = "_licensePlateId">The license plate ID to search for.</param>
    /// <param name = "_forUpdate">A Boolean value that indicates whether to read the record for update; optional.</param>
    /// <returns> A record in the <c>WHSOutboundSortPosition</c> table; otherwise, an empty record.</returns>
    [Hookable(false)]
    internal static WHSOutboundSortPosition findForAssignedLicensePlateId(WHSLicensePlateId	_licensePlateId, boolean _forUpdate = false)
    {
        WHSOutboundSortPosition outboundSortPosition;

        if (_licensePlateId)
        {
            outboundSortPosition.selectForUpdate(_forUpdate);

            select firstOnly outboundSortPosition
                where outboundSortPosition.LicensePlateId     == _licensePlateId
                   && outboundSortPosition.SortPositionStatus == WHSOutboundSortPositionStatus::Assigned;
        }

        return outboundSortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveSortPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a sort position based on the <c>PackedQueryRun</c> field on the <c>WHSOutboundSortTemplate</c> table.
    /// </summary>
    /// <param name = "_inventLocationId">
    /// The current warehouse.
    /// </param>
    /// <param name = "_wmsLocationId">
    /// The current location.
    /// </param>
    /// <param name = "_containerId">
    /// The current container ID.
    /// </param>
    /// <param name="_sortTemplateId">
    /// The parameter of type <c>WHSOutboundSortTemplateId</c>.
    /// </param>
    /// <returns>
    /// The sort position based on the query.
    /// </returns>
    [Hookable(false)]
    public static WHSOutboundSortPosition retrieveSortPosition(
        InventLocationId			_inventLocationId,
        WMSLocationId				_wmsLocationId,
        WHSContainerId				_containerId,
        WHSOutboundSortTemplateId	_sortTemplateId)
    {
        WHSInstrumentationLogger instrumentationLogger = WHSOutboundSortPosition::instrumentationLogger();

        using (var activityContext = instrumentationLogger.outboundSortingActivities().retrieveSortPosition())
        {
            WHSOutboundSortPosition sortPosition;
            boolean                 foundSortPosition;
            int                     investigatedSortPositions;

            if (_inventLocationId && _wmsLocationId && _containerId)
            {
                WHSOutboundSortTemplate sortTemplate;

                while select sortPosition
                    where sortPosition.SortTemplateId		== _sortTemplateId
                    &&	  sortPosition.SortPositionStatus   == WHSOutboundSortPositionStatus::Assigned
                    &&    sortPosition.WMSLocationId        == _wmsLocationId
                    &&    sortPosition.InventLocationId     == _inventLocationId
                    join PackedQueryRun from sortTemplate
                        where sortTemplate.SortTemplateId == sortPosition.SortTemplateId
                {
                    investigatedSortPositions++;

                    foundSortPosition = sortPosition.validateContainerCriteria(_containerId, sortTemplate.PackedQueryRun, instrumentationLogger);

                    if (foundSortPosition)
                    {
                        break;
                    }
                }
            }

            instrumentationLogger.outboundSortingActivities().retrievedSortPosition(activityContext, foundSortPosition, investigatedSortPositions);
            instrumentationLogger.logRecordInformation(sortPosition);

            return sortPosition;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerCriteria</Name>
				<Source><![CDATA[
    private boolean validateContainerCriteria(WHSContainerId _containerId, container _packedCriteriaQuery, WHSInstrumentationLogger _instrumentationLogger)
    {
        using (var activityContext = _instrumentationLogger.outboundSortingActivities().validateSortPositionContainerCriteria())
        {
            _instrumentationLogger.logRecordInformation(this);

            Query query = new query(_packedCriteriaQuery);

            this.setCriteriaRanges(query);

            QueryBuildDataSource qbdsContainer = query.dataSourceTable(tableNum(WHSContainerTable));
            qbdsContainer.addRange(fieldNum(WHSContainerTable, ContainerId)).value(queryValue(_containerId));
            qbdsContainer.firstOnly(true);

            QueryRun queryRun = new QueryRun(query);

            boolean foundSortPosition = queryRun.next();

            _instrumentationLogger.outboundSortingActivities().validatedSortPositionContainerCriteria(activityContext, foundSortPosition);

            return foundSortPosition;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCriteriaRanges</Name>
				<Source><![CDATA[
    private void setCriteriaRanges(Query _query)
    {
        WHSOutboundSortPositionCriteria sortPositionCriteria;

        while select sortPositionCriteria
            where sortPositionCriteria.OutboundSortPosition == this.recId
        {
            SysDictField dictField = new SysDictField(sortPositionCriteria.GroupTableId, sortPositionCriteria.GroupFieldId);
            
            QueryBuildRange qbrCriteria = _query.dataSourceTable(sortPositionCriteria.GroupTableId).addRange(sortPositionCriteria.GroupFieldId);
            
            if (dictField.baseType() == Types::String)
            {
                qbrCriteria.value(queryValue(sortPositionCriteria.SortPositionCriteriaValue));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOrMoveContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process or move sort trans records tied to a container.
    /// </summary>
    /// <param name = "_sortTemplate">
    /// The current sort template being used.
    /// </param>
    /// <param name = "_sortPosition">
    /// The current sort position to sort the container to.
    /// </param>
    /// <param name = "_sortIdentifier">
    /// The sort identifier related to the container's container ID.
    /// </param>
    /// <param name = "_inventDim">
    /// The current <c>InventDim</c> record.
    /// </param>
    /// <param name = "_userId">
    /// The current user performing the sort.
    // </param>
    internal static void processOrMoveContainer(
        WHSOutboundSortTemplate		_sortTemplate,
        WHSOutboundSortPosition		_sortPosition,
        WHSOutboundSortIdentifier	_sortIdentifier,
        InventDim					_inventDim,
        WHSUserId					_userId)
    {
        WHSOutboundSortPosition::validateContainerNotOpen(_sortIdentifier);
        WHSOutboundSortPosition::validateContainerNotAssignedToClosedSortPosition(_sortIdentifier);
        
        WHSOutboundSortPositionTrans    sortPositionTrans;
        WHSOutboundSortPosition         sortPosition;

        select firstonly RecId from sortPositionTrans
            where sortPositionTrans.SortIdentifier      == _sortIdentifier
            &&    sortPositionTrans.SortTemplateType    == WHSOutboundSortTemplateType::Container
            exists join sortPosition
                where sortPosition.RecId                == sortPositionTrans.OutboundSortPosition
                &&    sortPosition.SortPositionStatus   == WHSOutboundSortPositionStatus::Assigned;

        if (!sortPositionTrans)
        {
            WHSOutboundSortPosition::processContainerSortTrans(_sortPosition,
                                                               _sortIdentifier,
                                                               _inventDim,
                                                               _userId);
        }
        else if (_sortTemplate.SortPositionAssignment == WHSOutboundSortPositionAssignment::Manual)
        {
            WHSOutboundSortPosition::moveContainerToPosition(_sortIdentifier,
                                                            _sortPosition,
                                                            _inventDim,
                                                            _userId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerNotAssignedToClosedSortPosition</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void validateContainerNotAssignedToClosedSortPosition(WHSOutboundSortIdentifier _sortIdentifier)
    {        
        if (_sortIdentifier)
        {
            WHSOutboundSortPosition      sortPosition;
            WHSOutboundSortPositionTrans sortPositionTrans;

            select RecId from sortPositionTrans
                where sortPositionTrans.SortIdentifier      == _sortIdentifier
                   && sortPositionTrans.SortTemplateType    == WHSOutboundSortTemplateType::Container
                exists join sortPosition
                    where sortPosition.RecId == sortPositionTrans.OutboundSortPosition
                       && sortPosition.SortPositionStatus == WHSOutboundSortPositionStatus::Closed;
                     

            if (sortPositionTrans)
            {
                throw error(strFmt("@WAX:WHSValidateContainerNotAssignedToClosedSortPositionForOutboundSort", _sortIdentifier));
            }
        }       
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerNotOpen</Name>
				<Source><![CDATA[
    private static void validateContainerNotOpen(WHSOutboundSortIdentifier _sortIdentifier)
    {
        WHSContainerTable containerTable = WHSContainerTable::findByContainerId(_sortIdentifier);
            
        if (containerTable.ContainerStatus == WHSContainerStatus::Open)
        {
            throw error(strFmt("@WAX:WHSPreventOutboundSortingForOpenContainers", containerTable.ContainerId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processContainerSortTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process sort trans records tied to a container.
    /// </summary>
    /// <param name = "_sortPosition">
    /// The current sort position to sort the container to.
    /// </param>
    /// <param name = "_sortIdentifier">
    /// The sort identifier related to the container's container ID.
    /// </param>
    /// <param name = "_inventDim">
    /// The current <c>InventDim</c> record.
    /// </param>
    /// <param name = "_userId">
    /// The current user performing the sort.
    // </param>
    private static void processContainerSortTrans(
        WHSOutboundSortPosition		_sortPosition,
        WHSOutboundSortIdentifier	_sortIdentifier,
        InventDim					_inventDim,
        WHSUserId					_userId)
    {
        ttsbegin;

        InventDim inventDim = _inventDim;
    
        WHSInventStatusId inventStatusId = WHSOutboundSortPositionTrans::createContainerSortPositionTransAndRemoveRFInstruction(_sortIdentifier,
                                                                                                                                _sortPosition.RecId,
                                                                                                                                _sortPosition.SortTemplateId);

        // Move item to sortPosition plate
        WHSWorkCreateMovementBasic::createBasicMovementWork(_userId,
                                                            '',
                                                            0,
                                                            '',
                                                            _inventDim,
                                                            _sortIdentifier,
                                                            _sortPosition.WMSLocationId,
                                                            _sortPosition.WMSLocationId,
                                                            _sortPosition.LicensePlateId,
                                                            inventStatusId,
                                                            inventStatusId,
                                                            false,
                                                            true);

        WHSContainerTable containerTable = WHSContainerTable::findByContainerId(_sortIdentifier, true);
    
        inventDim = inventDim::find(containerTable.InventDimId);
        inventDim.LicensePlateId = _sortPosition.LicensePlateId;
        inventDim = InventDim::findOrCreate(inventDim);

        containerTable.InventDimId = inventDim.inventDimId;
    
        containerTable.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveContainerToPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves a presorted container to a new position.
    /// </summary>
    /// <param name = "_sortIdentifier">
    /// The sort identifier related to the container's container ID.
    /// </param>
    /// <param name = "_sortPosition">
    /// The current sort position to sort the container to.
    /// </param>
    /// <param name = "_inventDim">
    /// The current <c>InventDim</c> record.
    /// </param>
    /// <param name = "_userId">
    /// The current user performing the sort.
    // </param>
    private static void moveContainerToPosition(
        WHSOutboundSortIdentifier	_sortIdentifier,
        WHSOutboundSortPosition		_sortPosition,
        InventDim					_inventDim,
        WHSUserId					_userId)
    {
        ttsbegin;

        WHSOutboundSortPosition fromSortPosition;
        WHSOutboundSortPositionTrans sortPositionTrans;

        select firstonly WMSLocationId, LicensePlateId from fromSortPosition
            where fromSortPosition.SortPositionStatus == WHSOutboundSortPositionStatus::Assigned
            exists join sortPositionTrans
                where sortPositionTrans.OutboundSortPosition    == fromSortPosition.RecId
                &&    sortPositionTrans.SortIdentifier          == _sortIdentifier;

        update_recordSet sortPositionTrans
            setting OutboundSortPosition = _sortPosition.RecId
            where sortPositionTrans.SortIdentifier      == _sortIdentifier
            &&    sortPositionTrans.SortTemplateType    == WHSOutboundSortTemplateType::Container;

        // Move container to sort position license plate.
        WHSWorkCreateMovementBasic::createBasicContainerMovementWork(_sortIdentifier,
                                                                    _userId,
                                                                    _inventDim,
                                                                    fromSortPosition.WMSLocationId,
                                                                    fromSortPosition.LicensePlateId,
                                                                    _sortPosition.WMSLocationId,
                                                                    _sortPosition.LicensePlateId);

        if (!WHSOutboundSortPositionTrans::existByOutboundSortPosition(fromSortPosition.RecId))
        {
            WHSOutboundSortPosition::find(fromSortPosition.RecId, true).closeSortPosition();
        }
    
        WHSContainerTable containerTable = WHSContainerTable::findByContainerId(_sortIdentifier, true);

        InventDim inventDim = _inventDim;

        inventDim = inventDim::find(containerTable.InventDimId);
        inventDim.LicensePlateId = _sortPosition.LicensePlateId;
        inventDim = InventDim::findOrCreate(inventDim);

        containerTable.InventDimId = inventDim.inventDimId;
    
        containerTable.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packSortPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pack the sort position into a container.
    /// </summary>
    /// <param name="_packProfileId">
    /// The pack profile used to pack the position to a container.
    /// </param>
    private void packSortPosition(WHSPackProfileId _packProfileId)
    {
        WHSPackProfile					packProfile;
        WHSContainerTable				containerTable;
        WHSOutboundSortPositionTrans    sortPositionTrans;
        WHSLoadLine						loadLine;
    
        ttsBegin;
    
        packProfile = WHSPackProfile::find(_packProfileId);
    
        while select LoadLine, ItemId, ProductQuantity, UnitSymbol, InventDimId from sortPositionTrans
            where sortPositionTrans.OutboundSortPosition == this.RecId
        {
            if (containerTable.RecId == 0)
            {
                loadLine = WHSLoadLine::findbyRecId(sortPositionTrans.LoadLine);

                WHSWorker worker = WHSWorker::findByWorker();
                WHSCreateContainerParameters createContainerParameters = WHSCreateContainerParameters::createFromParameters(
                    loadLine.ShipmentId,
                    this.LicensePlateId,
                    packProfile.DefaultContainerType,
                    '',
                    '',
                    null,
                    packProfile.PrintContainerLabel,
                    '',
                    worker.RecId);
                WHSContainerTable::createContainerWithParameters(createContainerParameters);
    
                containerTable = WHSContainerTable::find(loadLine.ShipmentId, this.LicensePlateId);
            }
   
            // Create container lines based off sorting transactions.
            WHSContainerLine::createContainerLine(loadLine.ShipmentId,
                                                containerTable.ContainerId,
                                                sortPositionTrans.ItemId,
                                                sortPositionTrans.ProductQuantity,
                                                sortPositionTrans.UnitSymbol,
                                                sortPositionTrans.LoadLine,
                                                sortPositionTrans.InventDimId);
        }
  
        if (containerTable.RecId != 0)
        {
            WHSContainerTable::closeContainerAfterWaveDemandSort(containerTable.ContainerId,
                                                             packProfile.CloseContainerProfileId,
                                                             this.WMSLocationId);
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processWaveDemandSort</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes outbound sort for wave demand inventory.
    /// </summary>
    /// <param name = "_sortRFInstruction">The mobile device instruction for inventory in sort location.</param>
    /// <param name = "_inventoryLicensePlateId">The inventory license plate in sort location.</param>
    /// <param name = "_sortPositionLicensePlateId">The license plate assigned to the sort location.</param>
    /// <param name = "_userId">The warehouse work user executing the sort.</param>
    [Hookable(false)]
    public static void processWaveDemandSort(
        WHSOutboundSortRFInstruction    _sortRFInstruction,
        WHSLicensePlateId               _inventoryLicensePlateId,
        WHSLicensePlateId               _sortPositionLicensePlateId,
        WHSUserId                       _userId)
    {
        if (appl.ttsLevel() == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        WHSOutboundSortPositionTrans    sortPositionTrans;
        WHSOutboundSortPosition         sortPosition;

        sortPosition = WHSOutboundSortPosition::find(_sortRFInstruction.OutboundSortPositionRecId, true);

        if (!sortPosition)
        {
            throw error("@WAX:WHSOutboundSortPositionMissing");
        }
    
        if (!sortPosition.LicensePlateId)
        {
            sortPosition.LicensePlateId = _sortPositionLicensePlateId;
            sortPosition.update();
        }
    
        // Create sort transaction for the position.
        sortPositionTrans.SortIdentifier        = sortPosition.LicensePlateId;
        sortPositionTrans.OutboundSortPosition  = _sortRFInstruction.OutboundSortPositionRecId;
        sortPositionTrans.WorkLine              = _sortRFInstruction.WorkLineRecId;
        sortPositionTrans.OutboundSortPosition  = sortPosition.RecId;
        sortPositionTrans.SortTemplateId        = sortPosition.SortTemplateId;
        sortPositionTrans.SortTransStatus       = WHSOutboundSortPositionStatus::Closed;
        sortPositionTrans.ItemId                = _sortRFInstruction.ItemId;
        sortPositionTrans.InventDimId           = _sortRFInstruction.InventDimId;
        sortPositionTrans.ProductQuantity       = _sortRFInstruction.ProductQuantity;
        sortPositionTrans.UnitSymbol            = _sortRFInstruction.UnitSymbol;
        sortPositionTrans.LoadLine              = _sortRFInstruction.LoadLineRecId;
        sortPositionTrans.SortTemplateType      = WHSOutboundSortTemplate::find(sortPosition.SortTemplateId).SortTemplateType;
        sortPositionTrans.insert();

        // Move inventory to position license plate.
        InventDim inventDim = InventDim::find(_sortRFInstruction.InventDimId);

        WHSWorkCreateMovementBasic::createBasicMovementWork(_userId,
                                                            sortPositionTrans.ItemId,
                                                            sortPositionTrans.ProductQuantity,
                                                            sortPositionTrans.UnitSymbol,
                                                            inventDim,
                                                            _inventoryLicensePlateId,
                                                            sortPosition.WMSLocationId,
                                                            sortPosition.WMSLocationId,
                                                            sortPosition.LicensePlateId,
                                                            inventDim.InventStatusId,
                                                            inventDim.InventstatusId);
    
        // Delete sort instruction once processed.
        WHSOutboundSortRFInstruction sortRFInstruction;

        delete_from sortRFInstruction
            where sortRFInstruction.RecId == _sortRFInstruction.RecId;

        // Determine if sort position should be automatically closed.
        sortPosition.autoCloseSortPosition();
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoCloseSortPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if sort position can close, if true we close it.
    /// </summary>
    [Hookable(false)]
    public void autoCloseSortPosition()
    {
        if (WHSOutboundSortTemplate::find(this.SortTemplateId).AutoCloseSortPosition && this.checkSortPositionComplete())
        {
            this.closeSortPosition();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSortPositionComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if sort position is complete.
    /// </summary>
    /// <returns>true if sort position is complete; otherwise, false.</returns>
    private boolean checkSortPositionComplete()
    {
        WHSWorkLine                             workline;
        WHSSortPositionTransactionSumByWorkLine sortTransSumByWorkLine;
        boolean ret = true;

        select firstOnly RecId from workLine
            where workLine.OutboundSortPosition == this.RecId
            &&    workLine.WorkStatus           != WHSWorkStatus::Cancelled
            &&    workLine.WorkStatus           != WHSWorkStatus::Combined
            // In the case of short picking quantity 0, the work line remains closed but with quantity 0.
            && (!WHSOutboundSortingExcludeZeroQtyWorkLineFromSortFlight::instance().isEnabled() 
                || workLine.InventQtyWork != 0)
            notExists join sortTransSumByWorkLine
                where sortTransSumByWorkLine.WorkLine               == workLine.RecId
                &&    sortTransSumByWorkLine.SumOfProductQuantity   >= workLine.InventQtyWork;

        return workline.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSortPositionLicensePlateId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static WHSLicensePlateId getSortPositionLicensePlateId(
        WHSOutboundSortPositionId   _sortPositionId,
        WHSOutboundSortTemplateId   _sortTemplateId,
        WMSLocationId               _wmsLocationId,
        InventLocationId            _inventLocationId)
    {
        WHSOutboundSortPosition sortPosition;

        select firstonly LicensePlateId from sortPosition
            where sortPosition.SortPositionId       == _sortPositionId
            &&    sortPosition.SortTemplateId		== _sortTemplateId
            &&	  sortPosition.SortPositionStatus   == WHSOutboundSortPositionStatus::Assigned
            &&    sortPosition.WMSLocationId        == _wmsLocationId
            &&    sortPosition.InventLocationId     == _inventLocationId;

        return sortPosition.LicensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNumberOfAssignedPositions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of positions that are assigned in a sort location.
    /// </summary>
    /// <param name="_sortTemplate">
    /// A <c>WHSOutboundSortTemplate</c> record defining the sort position.
    /// </param>
    /// <returns>
    /// The number of assigned sort positions.
    /// </returns>
    [Hookable(false)]
    public static int calculateNumberOfAssignedPositions(WHSOutboundSortTemplate _sortTemplate)
    {
        return WHSOutboundSortPosition::calculateNumberOfAssignedPositionsForWarehouseGroupAll(_sortTemplate.SortTemplateId, _sortTemplate.InventLocationId, _sortTemplate.WMSLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNumberOfAssignedPositionsForWarehouseGroupAll</Name>
				<Source><![CDATA[
    internal static int calculateNumberOfAssignedPositionsForWarehouseGroupAll(WHSOutboundSortTemplateId _sortTemplateId, InventLocationId _warehouseId, WMSLocationId _locationId)
    {
        WHSOutboundSortPosition sortPosition;
    
        if (_sortTemplateId && _warehouseId && _locationId)
        {
            select count(RecId), maxof(SortPositionNum) from sortPosition
                where sortPosition.SortPositionStatus   == WHSOutboundSortPositionStatus::Assigned
                &&    sortPosition.InventLocationId     == _warehouseId
                &&    sortPosition.WMSLocationId        == _locationId
                &&    sortPosition.SortTemplateId       == _sortTemplateId;
        }
    
        return sortPosition.SortPositionNum != 0 ? sortPosition.SortPositionNum : any2int(sortPosition.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSortPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the sort position record with the given license plate.
    /// </summary>
    /// <param name = "_sortIdentifier">
    /// The current container or license plate.
    /// </param>
    /// <param name = "_sortPositionId">
    /// The sort position ID associated with the sort position to be updated.
    /// </param>
    /// <param name = "_licensePlateId">
    /// The license plate to use for updating the sort position.
    /// </param>
    [Hookable(false)]
    public static void updateSortPosition(
        WHSOutboundSortIdentifier   _sortIdentifier,
        WHSOutboundSortPositionId   _sortPositionId,
        WHSLicensePlateId           _licensePlateId)
    {
        WHSSortPutawayValidator sortPutawayValidator = WHSSortPutawayValidator::newWithIdentifier(_sortIdentifier);

        sortPutawayValidator.validateOnlyOneSortPosition();

        ttsbegin;

        WHSOutboundSortPosition	sortPosition = WHSOutboundSortPosition::findBySortPositionId(_sortPositionId, true);

        if (!sortPosition.LicensePlateId)
        {
            sortPosition.LicensePlateId = _licensePlateId;
    
            sortPosition.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePositionForContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the container can be sorted to the position.
    /// </summary>
    /// <param name="_containerId">
    /// The container id being validated.
    /// </param>
    /// <param name="_sortPositionId">
    /// The sort positions being sorted to.
    /// </param>
    /// <param name="_sortTemplateId">
    /// The sort template ID being used.
    /// </param>
    /// <returns>
    /// true if the container matches the criteria; otherwise, false.
    /// </returns>
    [Hookable(false)]
    public static boolean validatePositionForContainer(
        WHSContainerId				_containerId,
        WHSOutboundSortPositionId	_sortPositionId,
        WHSOutboundSortTemplateId	_sortTemplateId)
    {
        WHSOutboundSortPosition sortPosition = WHSOutboundSortPosition::findForContainerBySortTemplateId(_sortPositionId, _sortTemplateId, false);
        WHSOutboundSortTemplate	sortTemplate = WHSOutboundSortTemplate::find(sortPosition.SortTemplateId);

        if (sortPosition)
        {
            if (!sortPosition.validateContainerCriteria(_containerId, sortTemplate.PackedQueryRun, WHSOutboundSortPosition::instrumentationLogger()))
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSortPositionInUse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the sort position is currently in use by assigned or sorted inventory.
    /// </summary>
    /// <param name = "_sortPositionRecId">The outbound sort position being evaluated.</param>
    /// <returns>True, if the outbound sort position is in use; otherwise, False.</returns>
    [Hookable(false)]
    internal static boolean isSortPositionInUse(WHSOutboundSortPositionRecId _sortPositionRecId)
    {
        return WHSOutboundSortPosition::isSortPositionInUseInternal(_sortPositionRecId, 0, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSortPositionInUseByOtherWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the sort position is currently in use by assigned or sorted inventory excluding current work detail line.
    /// </summary>
    /// <param name = "_sortPositionRecId">The outbound sort position being evaluated.</param>
    /// <param name = "_workLineToExcludeRecId">A specific work line that should be excluded from the evaluation.</param>
    /// <returns>True, if the outbound sort position is in use; otherwise, False.</returns>
    [Hookable(false)]
    internal static boolean isSortPositionInUseByOtherWorkLine(
        WHSOutboundSortPositionRecId    _sortPositionRecId,
        WHSWorkLineRecID                _workLineToExcludeRecId)
    {
        return WHSOutboundSortPosition::isSortPositionInUseInternal(_sortPositionRecId, _workLineToExcludeRecId, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSortPositionInUseByOtherWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the sort position is currently in use by assigned or sorted inventory excluding current work header.
    /// </summary>
    /// <param name = "_sortPositionRecId">The outbound sort position being evaluated.</param>
    /// <param name = "_workIdToExclude">A specific work unit that should be excluded from the evaluation.</param>
    /// <returns>True, if the outbound sort position is in use; otherwise, False.</returns>
    [Hookable(false)]
    internal static boolean isSortPositionInUseByOtherWork(
        WHSOutboundSortPositionRecId    _sortPositionRecId,
        WHSWorkId                       _workIdToExclude)
    {
        return WHSOutboundSortPosition::isSortPositionInUseInternal(_sortPositionRecId, 0, _workIdToExclude);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSortPositionInUseInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the sort position is currently in use by assigned or sorted inventory.
    /// </summary>
    /// <param name = "_sortPositionRecId">
    /// The outbound sort position being evaluated.
    /// </param>
    /// <param name = "_workLineToExcludeRecId">
    /// A specific work line that should be excluded from the evaluation.
    /// </param>
    /// <param name = "_workIdToExclude">
    /// A specific work unit that should be excluded from the evaluation.
    /// </param>
    /// <returns>
    /// True, if the outbound sort position is in use; otherwise, False.
    /// </returns>
    private static boolean isSortPositionInUseInternal(
        WHSOutboundSortPositionRecId    _sortPositionRecId,
        WHSWorkLineRecID                _workLineToExcludeRecId,
        WHSWorkId                       _workIdToExclude)
    {
        WHSWorkLine                     workLine;
        WHSOutboundSortPosition         sortPosition;
        WHSOutboundSortPositionTrans    sortPositionTrans;

        // Check if there is inventory currently sorted to the sort position.
        boolean inventoryToSortPosition = WHSOutboundSortPositionTrans::existByOutboundSortPosition(_sortPositionRecId);

        if (inventoryToSortPosition)
        {
            return inventoryToSortPosition;
        }

        // Determine if there is additional work inventory that is going to be sorted to this position.
        select firstOnly RecId from workLine
            where workLine.OutboundSortPosition  == _sortPositionRecId
            &&    workLine.WorkStatus       != WHSWorkStatus::Cancelled
            &&    workLine.RecId            != _workLineToExcludeRecId
            &&    workLine.WorkId           != _workIdToExclude
            notexists join sortPositionTrans
                where sortPositionTrans.WorkLine == workLine.RecId
                exists join sortPosition
                    where sortPosition.RecId                == sortPositionTrans.OutboundSortPosition
                    &&    sortPosition.SortPositionStatus   == WHSOutboundSortPositionStatus::Assigned;

        boolean workInventoryToSortPosition = workLine.RecId != 0;

        return workInventoryToSortPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSortPositionsForCancelledWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete positions tied to work that is being cancelled.
    /// </summary>
    /// <param name="_workId">
    /// The work being cancelled.
    /// </param>
    [Hookable(false)]
    internal static void deleteSortPositionsForCancelledWork(WHSWorkId _workId)
    {
        if (appl.ttsLevel() == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        WHSWorkLine             cancelledWorkLine;
        WHSOutboundSortPosition sortPosition;

        while select OutboundSortPosition from cancelledWorkLine
            group by OutboundSortPosition
            where cancelledWorkLine.WorkId                  == _workId
            &&    cancelledWorkLine.OutboundSortPosition    != 0
        {
            if (!WHSOutboundSortPosition::isSortPositionInUseByOtherWork(cancelledWorkLine.OutboundSortPosition, _workId))
            {
                delete_from sortPosition
                    where sortPosition.RecId == cancelledWorkLine.OutboundSortPosition;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSortTemplateAndWaveId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates sort position fields that can be defaulted by the sort template and wave.
    /// </summary>
    /// <param name="_sortTemplate">
    /// The sort template that is being used to default fields.
    /// </param>
    /// <param name="_waveId">
    /// The wave that is being used to default fields.
    /// </param>
    [Hookable(false)]
    internal void initFromSortTemplateAndWaveId(
        WHSOutboundSortTemplate _sortTemplate,
        WHSWaveId               _waveId)
    {
        InventLocationId warehouseId = WHSWaveTable::find(_waveId).InventLocationId;

        this.initFromSortTemplateIdWarehouseAndLocation(_sortTemplate.SortTemplateId, warehouseId, _sortTemplate.defaultSortingLocationId(warehouseId));
        this.WaveId             = _waveId;
        this.SortPositionId     = _sortTemplate.SortPositionPrefix + int2str(WHSWaveTable::numberOfSortPositionsForWave(_waveId) + 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    private static WHSInstrumentationLogger instrumentationLogger()
    {
        return WHSInstrumentationLogger::createLogger(tableStr(WHSOutboundSortPosition));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWaveDemandSortInstructions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates sort instructions for wave demand inventory.
    /// </summary>
    /// <param name = "_licensePlateId">The license plate being sorted.</param>
    /// <param name = "_itemId">The item being sorted.</param>
    /// <param name = "_inventDimId">The inventory dimensions being sorted.</param>
    /// <returns>Outbound sorting position.</returns>
    [Hookable(false)]
    public static WHSOutboundSortPosition createWaveDemandSortInstructions(
        WHSLicensePlateId   _licensePlateId,
        ItemId              _itemId,
        InventDimId         _inventDimId)
    {
        if (!_licensePlateId)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        WHSWorkExecute  workExecute = new WHSWorkExecute();
        boolean         itemIsDimTrackingControlled = workExecute.itemIsDimTrackingControlled(_itemId);

        ttsbegin;
    
        Query query = new Query();
        QueryBuildDataSource qbdsWorkLine = query.addDataSource(tableNum(WHSWorkLine));
        qbdsWorkLine.addRange(fieldNum(WHSWorkLine, ItemId)).value(queryValue(_itemId));
        qbdsWorkLine.addRange(fieldNum(WHSWorkLine, WorkStatus)).value(queryValue(enum2int(WHSWorkStatus::Closed)));

        if (WHSOutboundSortingExcludeZeroQtyWorkLineFromSortFlight::instance().isEnabled())
        {
            // In the case of short picking quantity 0, the work line remains closed but with quantity 0.
            qbdsWorkLine.addRange(fieldNum(WHSWorkLine, InventQtyWork)).value(SysQuery::valueNot(0));
        }

        QueryBuildDataSource qbdsWorkTable = qbdsWorkLine.addDataSource(tableNum(WHSWorkTable));
        qbdsWorkTable.relations(true);
        qbdsWorkTable.fetchMode(QueryFetchMode::One2One);
        qbdsWorkTable.addRange(fieldNum(WHSWorkTable, TargetLicensePlateId)).value(queryValue(_licensePlateId));

        QueryBuildDataSource qbdsSortPosition = qbdsWorkLine.addDataSource(tableNum(WHSOutboundSortPosition));
        qbdsSortPosition.relations(true);
        qbdsSortPosition.fetchMode(QueryFetchMode::One2One);
        qbdsSortPosition.addRange(fieldNum(WHSOutboundSortPosition, SortPositionStatus)).value(queryValue(enum2int(WHSOutboundSortPositionStatus::Assigned)));

        InventDim inventDimCriteria;

        // For items with below location tracking dimensions need to reference dimension tracking records.
        if (itemIsDimTrackingControlled)
        {
            QueryBuildDataSource qbdsDimTracking = qbdsWorkLine.addDataSource(tableNum(WHSDimTracking));
            qbdsDimTracking.relations(true);
            qbdsDimTracking.fetchMode(QueryFetchMode::One2One);

            QueryBuildDataSource qbdsInventDimDT = qbdsDimTracking.addDataSource(tableNum(InventDim));
            qbdsInventDimDT.relations(true);
            inventDimCriteria = InventDim::find(_inventDimId);
            inventDimCriteria.wMSLocationId = '';
            inventDimCriteria.LicensePlateId = '';
            InventDim::queryAddRangeCriteria(qbdsInventDimDT, inventDimCriteria);
            qbdsInventDimDT.fetchMode(QueryFetchMode::One2One);
        }
        else
        {
            // Filter by above location dimension criteria if item does not have below location tracking dimensions.
            QueryBuildDataSource qbdsInventdim = qbdsWorkLine.addDataSource(tableNum(InventDim));
            qbdsInventdim.relations(true);
            qbdsInventdim.fetchMode(QueryFetchMode::One2One);

            inventDimCriteria = InventDim::find(_inventDimId);
            inventDimCriteria.clearLocationAndBelowDim(_itemId);
            InventDim::queryAddRangeCriteria(qbdsInventdim, inventDimCriteria);

            // For items that are not DimTracking controlled we should eliminate selecting already sorted inventory.
            QueryBuildDataSource qbdsSortTransaction = query.dataSourceTable(tableNum(WHSWorkLine)).addDataSource(tableNum(WHSOutboundSortPositionTrans));
            qbdsSortTransaction.relations(true);
            qbdsSortTransaction.joinMode(JoinMode::NoExistsJoin);
            qbdsSortTransaction.fetchMode(QueryFetchMode::One2One);
        }

        queryRun queryRun = new QueryRun(query);
            
        RecordInsertList rilSortInstruction = new RecordInsertList(tableNum(WHSOutboundSortRFInstruction));
        WHSOutboundSortRFInstruction sortRFInstruction;

        while (queryRun.next())
        {
            WHSWorkLine workLine = queryRun.get(tableNum(WHSWorkLine));
            WHSOutboundSortPosition sortPosition = queryRun.get(tableNum(WHSoutboundSortPosition));
            InventDim sortInstructionInventDim;
            ProductQuantity convertedDimTrackingQty;

            if (itemIsDimTrackingControlled)
            {
                WHSDimTracking dimTracking = queryRun.get(tableNum(WHSDimTracking));
                sortInstructionInventDim = queryRun.get(tableNum(InventDim));
                sortInstructionInventDim.wMSLocationId = '';
                sortInstructionInventDim.LicensePlateId = '';
                sortInstructionInventDim = InventDim::findOrCreate(sortInstructionInventDim);
                convertedDimTrackingQty = EcoResReleasedProductUnitConverter::construct().convert(dimTracking.Qty,
                                                                                                UnitOfMeasure::findBySymbol(WHSCatchWeightHelper::inventHandlingUnitId(_itemId)).RecId,
                                                                                                UnitOfMeasure::findBySymbol(workLine.UnitId).RecId,
                                                                                                NoYes::Yes,
                                                                                                _itemId,
                                                                                                sortInstructionInventDim.InventDimId);
            }

            sortRFInstruction.SortIdentifier            = _licensePlateId;
            sortRFInstruction.OutboundSortPositionRecId = sortPosition.RecId;
            sortRFInstruction.WorkLineRecId             = workLine.RecId;
            sortRFInstruction.ItemId                    = workLine.ItemId;
            sortRFInstruction.InventDimId               = itemIsDimTrackingControlled ? sortInstructionInventDim.inventDimId : workLine.InventDimId;
            sortRFInstruction.ProductQuantity           = itemIsDimTrackingControlled ? convertedDimTrackingQty : workLine.QtyWork;
            sortRFInstruction.UnitSymbol                = workLine.UnitId;
            sortRFInstruction.LoadLineRecId             = workLine.LoadLineRefRecId;
            rilSortInstruction.add(sortRFInstruction);
        }

        rilSortInstruction.insertDatabase();
    
        ttscommit;

        return WHSOutboundSortPosition::find(sortRFInstruction.OutboundSortPositionRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSortTemplateIdWarehouseAndLocation</Name>
				<Source><![CDATA[
    private void initFromSortTemplateIdWarehouseAndLocation(WHSOutboundSortTemplateId _sortTemplateId, InventLocationId _warehouseId, WMSLocationId _locationId)
    {
        this.InventLocationId   = _warehouseId;
        this.WMSLocationId      = _locationId;
        this.SortTemplateId     = _sortTemplateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    [Hookable(false)]
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockOutboundSortPosition</Name>
				<Source><![CDATA[
    internal static void lockOutboundSortPosition(WHSOutboundSortPosition _outboundSortPosition)
    {
        WHSOutboundSortPosition sortPosition;
        sortPosition.readPast(true);

        select firstonly pessimisticlock sortPosition
            where sortPosition.RecId == _outboundSortPosition.RecId;
        
        if (!sortPosition)
        {
            throw error(strFmt("@WAX:WHSOutboundSortPositionLockCouldNotBeAquired", _outboundSortPosition.SortPositionId));
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>WHSandTMS</ConfigurationKey>
	<DeveloperDocumentation>@WAX:WHSOutboundSortPositionDevDocumentation</DeveloperDocumentation>
	<Label>@WAX:WHSOutboundSortPositionLabel</Label>
	<SubscriberAccessLevel>
		<Read>Allow</Read>
	</SubscriberAccessLevel>
	<TableGroup>Main</TableGroup>
	<TitleField1>SortPositionId</TitleField1>
	<TitleField2>WMSLocationId</TitleField2>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>SortPositionIdx</ClusteredIndex>
	<CreatedDateTime>Yes</CreatedDateTime>
	<Modules>Inventory</Modules>
	<TableContents>BaseData</TableContents>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SortTemplateId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LicensePlateId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WMSLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SortPositionStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SortPositionId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SortPositionNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SortTemplateId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSOutboundSortTemplateId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LicensePlateId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLicensePlateId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WMSLocationId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WMSLocationId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventLocationId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventLocationId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SortPositionStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>WHSOutboundSortPositionStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SortPositionId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSOutboundSortPositionId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WaveId</Name>
			<ExtendedDataType>WHSWaveId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>SortPositionNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSOutboundSortPositionNum</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>SortPositionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>SortPositionId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventLocationId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WMSLocationId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>SortPositionStatus</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LicensePlateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>LicensePlateId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SortTemplateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>SortTemplateId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>SortPositionStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WMSLocationId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventLocationId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WaveIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>WaveId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>LicensePlate</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSLicensePlate</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LicensePlateId</Name>
					<Field>LicensePlateId</Field>
					<RelatedField>LicensePlateId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventLocation</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventLocation</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventLocationId</Name>
					<Field>InventLocationId</Field>
					<RelatedField>InventLocationId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SortTemplate</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>WHSOutboundSortTemplate</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SortTemplateId</Name>
					<Field>SortTemplateId</Field>
					<RelatedField>SortTemplateId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>Location</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WMSLocation</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WMSLocationId</Name>
					<Field>WMSLocationId</Field>
					<RelatedField>wMSLocationId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventLocationId</Name>
					<Field>InventLocationId</Field>
					<RelatedField>inventLocationId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WaveTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWaveTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveId</Name>
					<Field>WaveId</Field>
					<RelatedField>WaveId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>