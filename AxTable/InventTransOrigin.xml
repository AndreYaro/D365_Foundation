<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventTransOrigin</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class InventTransOrigin extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>assemblyInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a related assembly inventory transaction originator.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    /// An assembly inventory transaction originator if the record exists; otherwise, false.
    /// </returns>
    public InventTransOrigin assemblyInventTransOrigin(boolean _forUpdate= false)
    {
        return InventTransOrigin::assemblyInventTransOriginByOriginRecId(this.RecId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assemblyInventTransOriginByOriginRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the related assembly inventory transaction originator for the specified originator.
    /// </summary>
    /// <param name="_inventTransOriginRecId">
    /// The RecId of the inventory transaction originator for which related assembly inventory transaction originators must be found.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    /// An assembly inventory transaction originator if the record exists; otherwise, false.
    /// </returns>
    public static InventTransOrigin assemblyInventTransOriginByOriginRecId(InventTransOriginId _inventTransOriginRecId, boolean _forUpdate = false)
    {
        InventTransOrigin                   inventTransOrigin;
        InventTransOriginAssemblyComponent  inventTransOriginAssemblyComponent;

        if (_forUpdate)
        {
            inventTransOrigin.selectForUpdate(_forUpdate);
        }

        select firstonly inventTransOrigin
            exists join inventTransOriginAssemblyComponent
                where inventTransOriginAssemblyComponent.AssemblyInventTransOrigin  == inventTransOrigin.RecId
                   && inventTransOriginAssemblyComponent.ComponentInventTransOrigin == _inventTransOriginRecId;

        return inventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendAC</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the related customer account or vendor account.
    /// </summary>
    /// <returns>
    ///    A vendor account or customer account when applicable; otherwise, an empty string.
    /// </returns>
    display public CustVendAC custVendAC()
    {
        return InventTransOrigin::custVendAccountNumberByPartyAndReferenceCategory(this.Party, this.ReferenceCategory);
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendAccountNumberByPartyAndReferenceCategory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the related customer account or vendor account.
    /// </summary>
    /// <param name = "_partyRecId">The RecId for the party.</param>
    /// <param name = "_referenceCategory">The reference category.</param>
    /// <returns>A vendor account or customer account when applicable; otherwise, an empty string.</returns>
    public static CustVendAC custVendAccountNumberByPartyAndReferenceCategory(
        DirPartyRecId   _partyRecId,
        InventTransType _referenceCategory)
    {
        if (!_partyRecId)
        {
            return '';
        }

        switch (_referenceCategory)
        {
            case InventTransType::Sales :
            case InventTransType::SalesQuotation :
            case InventTransType::Project :
                return CustTable::findByPartyRecId(_partyRecId).AccountNum;

            case InventTransType::Purch :
                return VendTable::findByPartyRecId(_partyRecId).AccountNum;

            default :
                return '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes a record in the <c>InventTransOrigin</c> table.
    /// </summary>
    /// <param name="_deleteTransactions">
    ///    A Boolean value that indicates whether the related <c>InventTrans</c> records should be deleted;
    ///    optional.
    /// </param>
    public void delete(NoYes _deleteTransactions = NoYes::Yes)
    {
        InventTrans                 inventTrans;

        ttsbegin;

        if (_deleteTransactions)
        {
            while select forupdate inventTrans
                where inventTrans.InventTransOrigin == this.RecId
            {
                inventTrans.delete(NoYes::No, NoYes::No);
            }
        }

        InventTransOriginTransfer::deleteTransferRef(this.RecId);
        InventTransOriginAssemblyComponent::deleteAssemblyRef(this.RecId);

        // Implemented in logic because a cascading delete action to RequisitionLineFirmedOrderline would trigger too often. The modeled delete action deliberately exists but with without any action
        RequisitionLineFirmedOrderLine::deleteFromInventTransOrigin(this);

        super();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the owner of the current inventory transaction originator is an intercompany
    ///    order.
    /// </summary>
    /// <returns>
    ///    true if the owner of the current inventory transaction originator is an intercompany order;
    ///    otherwise, false.
    /// </returns>
    public boolean interCompanyOrder()
    {
        boolean             ret;

        switch (this.ReferenceCategory)
        {
            case    InventTransType::Sales:
                ret = InventTransOriginSalesLine::salesLine(this.RecId).salesTable().isInterCompanyOrder();
                break;
            case    InventTransType::Purch:
                ret = InventTransOriginPurchLine::purchLine(this.RecId).purchTable().isInterCompanyOrder();
                break;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an <c>inventMovement</c> object based on a <c>InventTransOrigin</c> record.
    /// </summary>
    /// <param name="_direction">
    /// For <c>InventTransOrigin</c> records where different movement classes are used for issues and
    /// receipts the <paramref name="_direction" /> parameter can be used to specify direction.
    /// </param>
    /// <param name="_noThrow">
    /// A Boolean value that specifies whether to throw an exception if movement cannot be created.
    /// </param>
    /// <returns>
    /// An <c>inventMovement</c> object.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The corresponding movement can no longer be created.
    /// </exception>
    public InventMovement inventMovement(
        InventDirection _direction  = InventDirection::None,
        boolean         _noThrow    = false)
    {
        InventJournalTrans      inventJournalTrans;
        InventQuarantineOrder   inventQuarantineOrder;
        InventTransferLine      inventTransferLine;
        KanbanJob               kanbanJob;

        Common                  originator;
        InventMovSubType        inventMovSubType = InventMovSubType::None;

        if (!this.RecId)
        {
            if (_noThrow)
            {
                return null;
            }
            throw error("@SYS20765");
        }

        originator = this.originator(true);

        if (!originator.RecId
            && (this.ReferenceCategory == InventTransType::InventTransaction
                || this.ReferenceCategory == InventTransType::InventCounting))
        {
            return InventMov_Virtuel::newInventTrans(InventTrans::findByInventTransOrigin(this.RecId));
        }

        if (!originator.RecId && this.ReferenceCategory == InventTransType::InventTransArchive)
        {
            return InventMov_InventTransArchive::newInventTrans(InventTrans::findByInventTransOrigin(this.RecId));
        } 

        if (!originator.RecId && this.ReferenceCategory == InventTransType::WHSInventTransArchiveOnlyAffectsLocationAndBelow)
        {
            return InventMov_WHSInventTransArchiveOnlyAffectsLocationAndBelow::newInventTrans(InventTrans::findByInventTransOrigin(this.RecId));
        }

        switch (originator.TableId)
        {
            case tableNum(InventJournalTrans):
                inventJournalTrans = originator as InventJournalTrans;
                if (inventJournalTrans.JournalType == InventJournalType::Transfer)
                {
                    switch (_direction)
                    {
                        case InventDirection::Receipt:
                            inventMovSubType = InventMovSubType::TransferReceipt;
                            break;
                        default:
                            inventMovSubType = InventMovSubType::None;
                            break;
                    }
                }
                break;
            case tableNum(InventTransferLine):
                inventTransferLine = originator as InventTransferLine;
                switch (this.InventTransId)
                {
                    case inventTransferLine.InventTransId:
                        inventMovSubType = InventMovSubType::None;
                        break;
                    case inventTransferLine.InventTransIdTransitFrom:
                        inventMovSubType = InventMovSubType::TransferOrderTransitFrom;
                        break;
                    case inventTransferLine.InventTransIdTransitTo:
                        inventMovSubType = InventMovSubType::TransferOrderTransitTo;
                        break;
                    case inventTransferLine.InventTransIdReceive:
                        inventMovSubType = InventMovSubType::TransferOrderTo;
                        break;
                    case inventTransferLine.InventTransIdScrap:
                        return InventMov_TransferScrap::construct(inventTransferLine); // No subtype so return directly
                }
                break;
            case tableNum(InventQuarantineOrder):
                inventQuarantineOrder = originator as InventQuarantineOrder;
                inventMovSubType = inventQuarantineOrder.getInventMovSubType(_direction);
                break;
            case tableNum(InventBlocking):
            case tableNum(WMSOrderTrans):
            case tableNum(WHSWorkInventTrans):
            case tableNum(WHSContainerTrans):
            case tableNum(WHSWorkQuarantine):
                switch (_direction)
                {
                    case InventDirection::Receipt:
                        inventMovSubType = InventMovSubType::TransferReceipt;
                        break;
                    default:
                        inventMovSubType = InventMovSubType::None;
                        break;
                }
                break;
            case tableNum(KanbanJob):
                kanbanJob = originator as KanbanJob;
                if (kanbanJob.Type == LeanKanbanJobType::Transfer)
                {
                    switch (_direction)
                    {
                        case InventDirection::Receipt:
                            inventMovSubType = InventMovSubType::TransferReceipt;
                            break;
                        default:
                            inventMovSubType = InventMovSubType::None;
                            break;
                    }
                }
                break;
        }

        if (_noThrow)
        {
            return InventMovement::constructNoThrow(originator,inventMovSubType);
        }
        return InventMovement::construct(originator,inventMovSubType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a related item.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>InventTable</c> table if it exists; otherwise an empty record.
    /// </returns>
    public InventTable inventTable(boolean _forUpdate = false)
    {
        return InventTable::find(this.ItemId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransferIssue_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the inventory transaction is a issue for an inventory transfer.
    /// </summary>
    /// <param name="_transType">
    ///    The type of the transaction.
    /// </param>
    /// <returns>
    ///    true if the inventory transaction is a issue for an inventory transfer; otherwise, false.
    /// </returns>
    public boolean isInventTransferIssue_RU(InventTransType _transType = this.ReferenceCategory)
    {
        InventTransferLine inventTransferLine;

        if (_transType != InventTransType::TransferOrderShip    &&
            _transType != InventTransType::TransferOrderReceive &&
            _transType != InventTransType::TransferOrderScrap)
        {
            return false;
        }

        switch (_transType)
        {
            case InventTransType::TransferOrderScrap:
                return true;
            case InventTransType::TransferOrderShip:
                inventTransferLine = this.originator();
                return inventTransferLine.InventTransId == this.InventTransId;
            case InventTransType::TransferOrderReceive:
                inventTransferLine = this.originator();
                return inventTransferLine.InventTransIdTransitFrom == this.InventTransId;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPhysicalOffsetInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the offset to this inventory transaction is considered a part of the total
    /// inventory.
    /// </summary>
    /// <returns>
    /// true if the offset to the transaction is considered inventory; otherwise, false.
    /// </returns>
    public boolean isPhysicalOffsetInventory()
    {
        switch (this.ReferenceCategory)
        {
            case InventTransType::Sales:
            case InventTransType::BOMMain:
            case InventTransType::BOMLine:
            case InventTransType::Production:
            case InventTransType::ProdLine:
            case InventTransType::InventLossProfit:
            case InventTransType::KanbanEmptied:
            case InventTransType::KanbanJobPickingList:
            case InventTransType::KanbanJobProcess:
            case InventTransType::KanbanJobWIP:
            case InventTransType::PmfProdCoBy:
                return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPhysicalTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transaction is part of a physically posted transfer.
    /// </summary>
    /// <returns>
    ///    true if the transaction is part of a physically posted transfer; otherwise, false.
    /// </returns>
    public boolean isPhysicalTransfer()
    {
        return (this.ReferenceCategory == InventTransType::QuarantineOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProductionRelated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current record is an input or an output in a production
    /// </summary>
    /// <returns>
    ///    true if the current record is an input or an output in a production; otherwise, false.
    /// </returns>
    public boolean isProductionRelated()
    {
        switch (this.ReferenceCategory)
        {
            case InventTransType::ProdLine:
            case InventTransType::Production:
            case InventTransType::PmfProdCoBy:
                return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current record is the transfer type.
    /// </summary>
    /// <returns>
    ///    true if the current record is the transfer type; otherwise, false.
    /// </returns>
    public boolean isTransfer()
    {
        return InventTransOrigin::isReferenceCategoryTransfer(this.ReferenceCategory);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isArchivedTransaction</Name>
				<Source><![CDATA[
    public boolean isArchivedTransaction()
    {
        switch (this.ReferenceCategory)
        {
            case InventTransType::InventTransArchive:
            case InventTransType::WHSInventTransArchiveOnlyAffectsLocationAndBelow:
                return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the item dimensions related to the current inventory transactions originator.
    /// </summary>
    /// <returns>
    ///    A record in the <c>InventDim</c> table.
    /// </returns>
    public InventDim itemInventDim()
    {
        return InventDim::find(this.ItemInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the item name of a related item.
    /// </summary>
    /// <returns>
    ///    The name of the item related to the current <c>InventTransOrigin</c> record.
    /// </returns>
    display SalesLineShowItemName itemName()
    {
        return this.inventTable().itemName(this.itemInventDim());
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpRefReferenceId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles Go to Main Table commands on the <c>ReferenceId</c> field.
    /// </summary>
    /// <returns>
    ///    true if a Go to Main Table action has been handled by this method; otherwise, false.
    /// </returns>
    public boolean jumpRefReferenceId()
    {
        return InventTransFormHelper::jumpRefReferenceId(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>originator</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the originator record for the current <c>InventTransOrigin</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The originator record.
    /// </returns>
    public Common originator(boolean    _forUpdate = false)
    {
        Common              originator;

        switch (this.ReferenceCategory)
        {
            case InventTransType::WHSWork:
                originator = WHSInventTransOriginWorkFrom::workInventTrans(this.RecId, _forUpdate);

                if (!originator)
                {
                    originator = WHSInventTransOriginWorkTo::workInventTrans(this.RecId, _forUpdate);
                }

                return originator;

            case InventTransType::WHSQuarantine:
                originator = WHSInventTransOriginQuarantineFrom::workQuarantine(this.RecId, _forUpdate);

                if (!originator)
                {
                    originator = WHSInventTransOriginQuarantineTo::workQuarantine(this.RecId, _forUpdate);
                }

                return originator;

            case InventTransType::WHSContainer:
                originator = WHSInventTransOriginContainerFrom::containerTrans(this.RecId, _forUpdate);
                if (!originator)
                {
                    originator = WHSInventTransOriginContainerTo::containerTrans(this.RecId, _forUpdate);
                }

                return originator;

            case InventTransType::Sales:
                return InventTransOriginSalesLine::salesLine(this.RecId, _forUpdate);

            case InventTransType::SalesQuotation:
                return InventTransOriginSalesQuotationLine::salesQuotationLine(this.RecId, _forUpdate);

            case InventTransType::ProdLine:
                return InventTransOriginProdBOM::prodBOM(this.RecId, _forUpdate);

            case InventTransType::Production:
                return InventTransOriginProdTable::prodTable(this.RecId, _forUpdate);

            case InventTransType::Purch:
                originator = InventTransOriginPurchLine::purchLine(this.RecId, _forUpdate);

                if (!originator)
                {
                    originator = InventTransOriginPurchRFQCaseLine::purchRFQCaseLine(this.RecId, _forUpdate);
                }

                if (!originator)
                {
                    originator = InventTransOriginPurchRFQLine::purchRFQLine(this.RecId, _forUpdate);
                }

                return originator;

            case InventTransType::InventTransfer:
                originator = InventTransOriginJournalTrans::inventJournalTrans(this.RecId, _forUpdate);
                if (!originator)
                { // It wasn't the issue - now try the receipt.
                    originator = InventTransOriginJournalTransReceipt::inventJournalTrans(this.RecId, _forUpdate);
                }
                return originator;

            case InventTransType::BOMMain:
            case InventTransType::BOMLine:
            case InventTransType::InventCounting:
            case InventTransType::Project:
            case InventTransType::Asset:
            case InventTransType::InventLossProfit:
            case InventTransType::InventTransaction:
                return InventTransOriginJournalTrans::inventJournalTrans(this.RecId, _forUpdate);

            case InventTransType::InventOwnershipChange:
                return InventTransOriginJournalTrans::inventJournalTrans(this.RecId, _forUpdate);

            case InventTransType::WMSOrder:
            case InventTransType::WMSTransport:
                return InventTransOriginWMSOrder::wmsOrder(this.RecId, _forUpdate);

            case InventTransType::QuarantineOrder:
                return InventTransOriginQuarantineOrder::inventQuarantineOrder(this.RecId, _forUpdate);

            case InventTransType::TransferOrderShip:
                originator = InventTransOriginTransferShip::inventTransferLine(this.RecId, _forUpdate);
                if (originator)
                {
                    return originator;
                }
                else
                {
                    return InventTransOriginTransferTransitTo::inventTransferLine(this.RecId, _forUpdate);
                }

            case InventTransType::TransferOrderReceive:
                originator = InventTransOriginTransferReceive::inventTransferLine(this.RecId, _forUpdate);
                if (originator)
                {
                    return originator;
                }
                else
                {
                    return InventTransOriginTransferTransitFrom::inventTransferLine(this.RecId, _forUpdate);
                }

            case InventTransType::TransferOrderScrap:
                return InventTransOriginTransferScrap::inventTransferLine(this.RecId, _forUpdate);

            case InventTransType::QualityOrder:
                return InventTransOriginQualityOrder::inventQualityOrderTable(this.RecId, _forUpdate);

            case InventTransType::Blocking:
                originator = InventTransOriginBlockingIssue::inventBlocking(this.RecId, _forUpdate);
                if (originator)
                {
                    return originator;
                }
                else
                {
                    return InventTransOriginBlockingReceipt::inventBlocking(this.RecId, _forUpdate);
                }

            case InventTransType::KanbanEmptied:
                return InventTransOriginKanbanEmptied::kanban(this.RecId, _forUpdate);

            case InventTransType::KanbanJobPickingList:
                originator = InventTransOriginKanbanJobPickList::kanbanJobPickingList(this.RecId, _forUpdate);
                if (!originator)
                {
                    originator = InventTransOriginKanbanJobPickReversal::kanbanJobPickingListReversal(this.RecId, _forUpdate);
                }
                return originator;

            case InventTransType::KanbanJobProcess:
                return InventTransOriginKanbanJobProcess::kanbanJob(this.RecId, _forUpdate);

            case InventTransType::KanbanJobWIP:
                return InventTransOriginKanbanJobWIP::kanbanJob(this.RecId, _forUpdate);

            case InventTransType::KanbanJobTransferIssue:
                return InventTransOriginKanbanJobTrsIssue::kanbanJob(this.RecId, _forUpdate);

            case InventTransType::KanbanJobTransferReceipt:
                return InventTransOriginKanbanJobTrsReceipt::kanbanJob(this.RecId, _forUpdate);

            case InventTransType::ConsignmentReplenishmentOrder:
                return InventTransOriginConsignmentReplenishmentOrderLine::replenishmentOrderLine(this.RecId, _forUpdate);

            // the SummedUp value doesn't represent a single originator
            case InventTransType::SummedUp:
                return null;
            case InventTransType::PmfProdCoBy:
                return InventTransOriginPmfProdCoBy::prodCoBy(this.RecId, _forUpdate);
            case InventTransType::Statement:
                // ReferenceId should have the value of the StatementId
                RetailTransactionSalesTrans salesTrans = RetailTransactionSalesTrans::findInventTransIdByStore(RetailStatementTable::find(this.ReferenceId).storeId, this.InventTransId, _forUpdate);
                /*  Sometimes no salesTrans record is selected because InventTransId has not been written in the DB yet. 
                    Later, when the instance of InventMov_Statement tries to access salesTrans.ItemId, it finds nothing and causes incorrect behavior.
                    But we already have ItemId in this context, so we set ItemId anyways if salesTrans is not selected. */
                if (!salesTrans.RecId)
                {
                    salesTrans.ItemId = this.ItemId;
                    salesTrans.InventTransId = this.InventTransId;
                    salesTrans.InventDimId = this.ItemInventDimId;
                }
                return salesTrans;

            // <GEERU>
            case InventTransType::ProdRelease_RU:
                return InventTransOriginProdJournalRelease_RU::prodJournalRelease(this.RecId, _forUpdate);
            // </GEERU>
            // <GJP>
            case InventTransType::Assembling_JP:
                return InventTransOriginAssetComponent_JP::assetComponent(this.RecId, _forUpdate);
            // </GJP>
            case InventTransType::WHSOrderCommittedReservation:
                return WHSInventTransOriginOrderCommittedReservation::orderCommittedReservation(this.RecId, _forUpdate);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts the <c>RecId</c> reference to the party table to a name.
    /// </summary>
    /// <returns>
    ///    A string with a name; otherwise, an empty string.
    /// </returns>
    display DirPartyName partyName()
    {
        return DirPartyTable::findRec(this.Party).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a related transfer <c>InventTransOrigin</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    A transfer counterpart inventory originator.
    /// </returns>
    public InventTransOrigin transferInventTransOrigin(boolean _forUpdate = false)
    {
    // return InventTransOrigin::find(InventTransOriginTransfer::findTransferRefId(this.RecId), _forUpdate);
    // using direct select for performance reasons

        InventTransOrigin           inventTransOrigin;
        InventTransOriginTransfer   inventTransOriginTransfer;

        if (_forUpdate)
        {
            inventTransOrigin.selectForUpdate(_forUpdate);
        }

        select firstonly inventTransOrigin
            exists join inventTransOriginTransfer
            where (inventTransOriginTransfer.IssueInventTransOrigin == inventTransOrigin.RecId
                && inventTransOriginTransfer.ReceiptInventTransOrigin == this.RecId)
              ||  (inventTransOriginTransfer.IssueInventTransOrigin == this.RecId
                && inventTransOriginTransfer.ReceiptInventTransOrigin == inventTransOrigin.RecId);

        if (!inventTransOrigin.RecId)
        {
            // InventTransTransfer is set for transfer journal and transfer orders for versions after 4.0
            // before 4.0 the same InventTransId was set for both TransferFrom and TransferTo transactions
            // so we return reference to the same origin for backward compatibility
            inventTransOrigin = this;
        }

        return inventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoicedCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates the cost value for a specific <c>InventTransOrigin</c> record.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// The <c>InventTransOrigin</c> value.
    /// </param>
    /// <returns>
    /// A container that contains a quantity and cost value.
    /// </returns>
    /// <remarks>
    /// The calculation is based on financial updated inventory transactions related to a
    /// <c>InventTransOrigin</c> record.
    /// </remarks>
    public static container calcInvoicedCostValue(InventTransOriginId _inventTransOriginId)
    {
        InventTrans         inventTrans;
        InventQty           qty;
        CostAmount          value;
        PdsCWInventQty      cwQty;

        while select inventTrans
            where inventTrans.InventTransOrigin     == _inventTransOriginId     &&
                  inventTrans.StatusReceipt         <= StatusReceipt::Purchased &&
                  inventTrans.StatusIssue           <= StatusIssue::Sold
        {
            qty   += inventTrans.Qty;
            value += inventTrans.costValue();
            cwQty += inventTrans.PdsCWQty;
        }

        return [qty,value, cwQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoicedCostValueSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the cost value in reporting currency for a specific <c>InventTransOrigin</c> record.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The <c>InventTransOrigin</c> value.
    /// </param>
    /// <returns>
    ///    A container that contains a quantity and cost value in reporting currency.
    /// </returns>
    public static container calcInvoicedCostValueSecCur_RU(InventTransOriginId _inventTransOriginId)
    {
        InventTrans inventTrans;
        InventQty   qty;
        CostAmount  value;

        while select inventTrans
            where inventTrans.InventTransOrigin     == _inventTransOriginId     &&
                  inventTrans.StatusReceipt         <= StatusReceipt::Purchased &&
                  inventTrans.StatusIssue           <= StatusIssue::Sold
        {
            qty   += inventTrans.Qty;
            value += inventTrans.costValueSecCur_RU();
        }

        return [qty, value];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkedCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the cost value of specified marked transactions.
    /// </summary>
    /// <param name="_markingRefInventTransOrigin">
    ///    The ID of one of the marked inventory transaction originators.
    /// </param>
    /// <param name="_itemId">
    ///    The ID of the item involved in the marking.
    /// </param>
    /// <param name="_inclPhysicalCostValue">
    ///    true if the physical cost values should be included in the calculated value; otherwise, false.
    /// </param>
    /// <param name="_inventTransOriginId">
    ///    The ID of the inventory transaction originators marked with a <c>_markingRefInventTransOrigin</c>
    ///    parameter.
    /// </param>
    /// <returns>
    ///    A container that contains the quantity and cost value of the marked transactions.
    /// </returns>
    public static container  calcMarkedCostValue(
        InventTransOriginId _markingRefInventTransOrigin,
        ItemId              _itemId,
        boolean             _inclPhysicalCostValue,
        InventTransOriginId _inventTransOriginId
        )
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        InventQty       qty;
        CostAmount      value;
        InventQty       physicalQty;
        CostAmount      physicalValue;

        InventTransferUpdRecordInventDimForCostContext context = InventTransferUpdRecordInventDimForCostContext::current();
        if (context && context.inventDimCriteria)
        {
            InventDim inventDim;
            select TableId from inventTransOrigin
            where   inventTransOrigin.RecId                 == _markingRefInventTransOrigin
                 && inventTransOrigin.ItemId                == _itemId
            join sum(Qty),sum(CostAmountPosted),sum(CostAmountAdjustment) from inventTrans
            where inventTrans.InventTransOrigin             == inventTransOrigin.RecId
               && inventTrans.StatusIssue                   == StatusIssue::None
               && inventTrans.StatusReceipt                 == StatusReceipt::Purchased
               && inventTrans.PackingSlipReturned           == NoYes::No
               && inventTrans.MarkingRefInventTransOrigin   == _inventTransOriginId
            #InventDimJoin(inventTrans.inventDimId, inventDim, context.inventDimCriteria, context.inventDimParm); 
            context.inventDimCriteria = null;
            context.inventDimParm = null;
        }
        else
        {
            select TableId from inventTransOrigin
                where   inventTransOrigin.RecId                 == _markingRefInventTransOrigin
                     && inventTransOrigin.ItemId                == _itemId
            join sum(Qty),sum(CostAmountPosted),sum(CostAmountAdjustment) from inventTrans
                where inventTrans.InventTransOrigin             == inventTransOrigin.RecId
                   && inventTrans.StatusIssue                   == StatusIssue::None
                   && inventTrans.StatusReceipt                 == StatusReceipt::Purchased
                   && inventTrans.PackingSlipReturned           == NoYes::No
                   && inventTrans.MarkingRefInventTransOrigin   == _inventTransOriginId;
        }

        qty   += inventTrans.Qty;
        value += inventTrans.costValue();

        if (_inclPhysicalCostValue)
        {
            ProjInventOrderIssueListForQuarantineContext projInventContext = ProjInventOrderIssueListForQuarantineContext::current();
            ProjId projId = InventTrans::getProjIdByMarkingRefInventTransOrigin(_inventTransOriginId);
            if (projId && projInventContext && ProjPartialReceiptWithIncldPhysicalPriceMarkingFlight::instance().isEnabled())
            {
                [physicalQty, physicalValue] = InventTransOrigin::calcMarkedPhysicalCostValue(_markingRefInventTransOrigin, _itemId, _inventTransOriginId);
                
                if (physicalQty != 0)
                {
                    qty     = physicalQty;
                    value   = physicalValue;
                }
            }
            else
            {
                [physicalQty, physicalValue] = InventTransOrigin::calcMarkedPhysicalCostValue(_markingRefInventTransOrigin, _itemId, _inventTransOriginId);
                qty     += physicalQty;
                value   += physicalValue;
            }
        }

        return [qty,value];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkedCostValueSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the cost value in reporting currency of specified marked transactions.
    /// </summary>
    /// <param name="_markingRefInventTransOrigin">
    ///    The ID of one of the marked inventory transaction originators.
    /// </param>
    /// <param name="_itemId">
    ///    The ID of the item involved in the marking.
    /// </param>
    /// <param name="_inclPhysicalCostValue">
    ///    true if the physical cost values should be included in the calculated value; otherwise, false.
    /// </param>
    /// <param name="_inventTransOriginId">
    ///    The ID of the inventory transaction originators marked with a <c>_markingRefInventTransOrigin</c>
    ///    parameter.
    /// </param>
    /// <returns>
    ///    A container that contains the quantity and cost value in reporting currency of the marked transactions.
    /// </returns>
    public static container calcMarkedCostValueSecCur_RU(
        InventTransOriginId _markingRefInventTransOrigin,
        ItemId              _itemId,
        boolean             _inclPhysicalCostValue,
        InventTransOriginId _inventTransOriginId
        )
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        InventQty           qty;
        CostAmount          value;

        select TableId from inventTransOrigin
            where   inventTransOrigin.RecId                 == _markingRefInventTransOrigin
                 && inventTransOrigin.ItemId                == _itemId
        join sum(Qty),sum(CostAmountSecCurPosted_RU), sum(CostAmountSecCurAdjustment_RU) from inventTrans
            where inventTrans.InventTransOrigin             == inventTransOrigin.RecId
               && inventTrans.StatusIssue                   == StatusIssue::None
               && inventTrans.StatusReceipt                 == StatusReceipt::Purchased
               && inventTrans.PackingSlipReturned           == NoYes::No
               && inventTrans.MarkingRefInventTransOrigin   == _inventTransOriginId;

        qty   += inventTrans.Qty;
        value += inventTrans.costValueSecCur_RU();

        if (_inclPhysicalCostValue)
        {
            select TableId from inventTransOrigin
                where   inventTransOrigin.RecId                 == _markingRefInventTransOrigin
                     && inventTransOrigin.ItemId                == _itemId
            join sum(Qty), sum(CostAmountSecCurPhysical_RU) from inventTrans
                where inventTrans.InventTransOrigin             == inventTransOrigin.RecId
                   && inventTrans.StatusIssue                   == StatusIssue::None
                   && inventTrans.StatusReceipt                 == StatusReceipt::Received
                   && inventTrans.PackingSlipReturned           == NoYes::No
                   && inventTrans.MarkingRefInventTransOrigin   == _inventTransOriginId;

            qty   += inventTrans.Qty;
            value += inventTrans.CostAmountSecCurPhysical_RU;
        }

        return [qty, value];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkedPhysicalCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the physical cost value of specified marked transactions.
    /// </summary>
    /// <param name="_markingRefInventTransOrigin">
    ///    The ID of one of the marked inventory transaction originators.
    /// </param>
    /// <param name="_itemId">
    ///    The ID of the item involved in the marking.
    /// </param>
    /// <param name="_inventTransOriginId">
    ///    The ID of the inventory transaction originators marked with a <c>_markingRefInventTransOrigin</c>
    ///    parameter.
    /// </param>
    /// <returns>
    ///    A container that contains the quantity and physical cost value of the marked transactions.
    /// </returns>
    public static container  calcMarkedPhysicalCostValue(
        InventTransOriginId _markingRefInventTransOrigin,
        ItemId              _itemId,
        InventTransOriginId _inventTransOriginId)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        select TableId from inventTransOrigin
            where   inventTransOrigin.RecId                 == _markingRefInventTransOrigin
                    && inventTransOrigin.ItemId             == _itemId
        join sum(Qty),sum(CostAmountPhysical) from inventTrans
            where inventTrans.InventTransOrigin             == inventTransOrigin.RecId
                && inventTrans.StatusIssue                  == StatusIssue::None
                && inventTrans.StatusReceipt                == StatusReceipt::Received
                && inventTrans.PackingSlipReturned          == NoYes::No
                && inventTrans.MarkingRefInventTransOrigin  == _inventTransOriginId;

        return [inventTrans.Qty, inventTrans.CostAmountPhysical];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReturnCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity and value of a specified return of items.
    /// </summary>
    /// <param name="_returnTransOriginId">
    /// The ID of the transactions for the return.
    /// </param>
    /// <param name="_toTransOriginId">
    /// The ID of the transactions for the original issue of the items
    /// </param>
    /// <returns>
    /// A container that contains a quantity and cost value.
    /// </returns>
    public static container  calcReturnCostValue(
        InventTransOriginId     _returnTransOriginId,
        InventTransOriginId     _toTransOriginId)
    {
        InventTrans     inventTrans;
        InventQty       qty;
        CostAmount      value;
        // <GEERU>
        CostAmount      valueSecCur;
        // </GEERU>

        // <GEERU>
        select sum(Qty),sum(CostAmountPosted),sum(CostAmountAdjustment),sum(CostAmountSecCurPosted_RU),sum(CostAmountSecCurAdjustment_RU) from inventTrans
        // </GEERU>
            where inventTrans.InventTransOrigin         == _returnTransOriginId
              &&  inventTrans.StatusIssue               == StatusIssue::Sold
              &&  inventTrans.StatusReceipt             == StatusReceipt::None
              &&  inventTrans.PackingSlipReturned       == 0
              &&  inventTrans.ReturnInventTransOrigin   == _toTransOriginId;

        qty   += inventTrans.Qty;
        value += inventTrans.costValue();
        // <GEERU>
        valueSecCur += inventTrans.costValueSecCur_RU();
        // </GEERU>

        // <GEERU>
        return [qty, value, valueSecCur];
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeReferenceId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the reference ID on the inventory transaction originator record for a given
    ///    <c>InventTransId</c> value.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The inventory transaction originator ID.
    /// </param>
    /// <param name="_newReferenceId">
    ///    The new reference ID value for the inventory transaction originator.
    /// </param>
    static public void changeReferenceId(
        InventTransOriginId     _inventTransOriginId,
        InventTransRefId        _newReferenceId)
    {
        InventTransOrigin   inventTransOrigin;

        if (!_inventTransOriginId)
        {
            return;
        }

        inventTransOrigin = InventTransOrigin::find(_inventTransOriginId,true);

        if (inventTransOrigin)
        {
            inventTransOrigin.ReferenceId = _newReferenceId;
            inventTransOrigin.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearUnboundMarking</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes the marking from transactions if they refer to absent records.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The ID of the inventory transaction originator for which marking is removed.
    /// </param>
    public static void clearUnboundMarking(InventTransOriginId _inventTransOriginId)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOriginMarking;

        ttsbegin;
        inventTrans.skipEvents(true);
        inventTrans.skipDataMethods(true);
        update_recordset inventTrans
            setting MarkingRefInventTransOrigin = 0
            where inventTrans.MarkingRefInventTransOrigin !=0
                && inventTrans.InventTransOrigin == _inventTransOriginId
        notexists join inventTransOriginMarking
            where inventTransOriginMarking.RecId == inventTrans.MarkingRefInventTransOrigin;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventTransOriginCreateContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventTransOrigin</c> record from an <c>InventTransOriginCreateContract</c> instance.
    /// </summary>
    /// <param name="_originCreateContract">An instance of the <c>InventTransOriginCreateContract</c> class which contains information about how to create the inventory originator record.</param>
    protected void initFromInventTransOriginCreateContract(InventTransOriginCreateContract _originCreateContract)
    {
        this.InventTransId                 = _originCreateContract.parmInventTransId();
        this.ItemId                        = _originCreateContract.parmItemId();
        this.ReferenceCategory             = _originCreateContract.parmReferenceCategory();
        this.ReferenceId                   = _originCreateContract.parmReferenceId();
        this.Party                         = _originCreateContract.parmPartyRecId();
        this.ItemInventDimId               = _originCreateContract.parmProductDimensionId();
        this.IsExcludedFromInventoryValue  = _originCreateContract.parmIsExcludedFromInventoryValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new record in the <c>InventTransOrigin</c> table.
    /// </summary>
    /// <param name="_originCreateContract">An instance of the <c>InventTransOriginCreateContract</c> class which contains information about how to create the inventory originator record.</param>
    /// <returns>The inventory originator that has been created.</returns>
    public static InventTransOrigin createOrigin(InventTransOriginCreateContract _originCreateContract)
    {
        InventTransOrigin   inventTransOrigin;
        inventTransOrigin.initFromInventTransOriginCreateContract(_originCreateContract);

        inventTransOrigin.insert();

        return inventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteMarking</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes the marking from transactions with the specified inventory transaction originator.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The ID of the inventory transaction originator for which marking is removed.
    /// </param>
    /// <param name="_markingRefInventTransOrigin">
    ///    The ID of the inventory transaction originator with which the transactions must be marked.
    /// </param>
    /// <param name="_markQty">
    ///    The quantity on transactions for which marking is removed.
    /// </param>
    /// <param name="_clearItemReference">
    ///    Specifies whether other reference fields should be cleared.
    /// </param>
    /// <param name="_inventDimCriteria">
    ///    The inventory dimension values to match when finding transactions.
    /// </param>
    /// <param name="_inventDimParm">
    ///    The inventory dimensions to match when finding transactions.
    /// </param>
    /// <param name="_showInfoReservRemoved">
    ///    true if information about the removed marking should be shown; otherwise, false.
    /// </param>
    /// <param name="_interCompanyBypassMarkingAllowed">
    ///    true if additional reference fields should be cleared in special intercompany cases; otherwise,
    ///    false.
    /// </param>
    /// <param name="_cwMarkQty">
    /// The catch weight quantity on transactions for which marking is removed.
    /// </param>
    /// <param name="_outQuantities">
    /// A variable that will be updated with the inventory and catch-weight quantities for which marking was removed.
    /// </param>
    /// <param name="_onlyFinancialPosted">
    ///     true for selecting financial posted transactions only.
    /// </param>
    /// <param name="_sortOrder">
    ///     The sort order for the status fields to use when finding transactions to unmark.
    /// </param>
    /// <returns>
    ///    The quantity for which marking was removed.
    /// </returns>
    public static InventQty deleteMarking(
        InventTransOriginId _inventTransOriginId,
        InventTransOriginId _markingRefInventTransOrigin,
        InventQty           _markQty,                      // sign as _inventTransOriginId
        boolean             _clearItemReference = false,
        InventDim           _inventDimCriteria = null,
        InventDimParm       _inventDimParm = null,
        boolean             _showInfoReservRemoved = false,
        boolean             _interCompanyBypassMarkingAllowed = false,
        PdsCWInventQty      _cwMarkQty = 0,
        PmfQtyDataCarrier   _outQuantities = new PmfQtyDataCarrier()
        , boolean             _onlyFinancialPosted = false
        , SortOrder         _sortOrder = SortOrder::Descending
    )
    {
        InventTrans     inventTrans;

        InventQty       markNow;
        InventQty       markQtyUpd;

        InventQty       cwMarkNow;
        PdsCWInventQty  cwMarkQtyUpd;

        InventDim       inventDim;
        InventMovement  movement;

        boolean         showReservInfoOnlyOnce  = true;
        boolean         clearItemRefOnlyOnce    = true;

        ttsbegin;

        if (_markQty)
        {
            markNow = _markQty;
            cwMarkNow = _cwMarkQty;

            if (_sortOrder == SortOrder::Descending)
            {
                InventTransOriginParameters insertParameters = InventTransOriginParameters::current();
                PackingSlipId packingSlipId;
                InvoiceId invoiceId;

                if (insertParameters)
                {
                    packingSlipId = insertParameters.packingSlipId();
                }
                if (SysTransactionScopeCache::isSet(classStr(ProjAdjustmentUpdate), _markingRefInventTransOrigin))
                {
                    invoiceId =  SysTransactionScopeCache::get(classStr(ProjAdjustmentUpdate), _markingRefInventTransOrigin);
                }

                VoucherPhysical voucherPhysical;
                InventTransferStornoContext_RU inventTransferStornoContext_RU = InventTransferStornoContext_RU::current();
                if (inventTransferStornoContext_RU)
                {
                    voucherPhysical = inventTransferStornoContext_RU.parmVoucherPhysical();
                }

                SysDaQueryObject inventTransToBeMarkedQueryObject = new InventTransToBeMarkedQueryBuilder()
                                                                        .setInventTransToBeMarked(inventTrans)
                                                                        .setInventDimForSearch(inventDim)
                                                                        .setInventDimCriteria(_inventDimCriteria)
                                                                        .setInventDimParmForValidateEnabled(_inventDimParm)
                                                                        .setMarkInventTransOriginId(_inventTransOriginId)
                                                                        .setMarkQty(_markQty)
                                                                        .setPackingSlipId(packingSlipId)
                                                                        .setInvoiceId(invoiceId)
                                                                        .setMarkSortOrder(SortOrder::Descending)
                                                                        // <GEERU>
                                                                        .setIsDeleteMarkingOperation(true)
                                                                        .setOnlyFinancialPosted(_onlyFinancialPosted)
                                                                        .setVoucherPhysicalId(voucherPhysical)
                                                                        // </GEERU>
                                                                        .setMarkingRefInventTransOrigin(_markingRefInventTransOrigin)
                                                                        .buildInventTransQuery();
                SysDaFindStatement findStatement = new SysDaFindStatement();
                findStatement.execute(new SysDaFindObject(inventTransToBeMarkedQueryObject));
            }
            else
            {
                SysDaQueryObject inventTransToBeMarkedQueryObject = new InventTransToBeMarkedQueryBuilder()
                                                                        .setInventTransToBeMarked(inventTrans)
                                                                        .setInventDimForSearch(inventDim)
                                                                        .setInventDimCriteria(_inventDimCriteria)
                                                                        .setInventDimParmForValidateEnabled(_inventDimParm)
                                                                        .setMarkInventTransOriginId(_inventTransOriginId)
                                                                        .setMarkQty(_markQty)
                                                                        .setMarkSortOrder(SortOrder::Ascending)
                                                                        .setIsDeleteMarkingOperation(true)
                                                                        .setMarkingRefInventTransOrigin(_markingRefInventTransOrigin)
                                                                        .buildInventTransQuery();
                SysDaFindStatement findStatement = new SysDaFindStatement();
                findStatement.execute(new SysDaFindObject(inventTransToBeMarkedQueryObject));
            }
            WHSInventUpdRemoveReservePhysicalForCWContext context = WHSInventUpdRemoveReservePhysicalForCWContext::current();
            InventTransOriginRemoveMarkingPhysicalReservationContext removePhysicalReservationConext = InventTransOriginRemoveMarkingPhysicalReservationContext::current();
            boolean removeReservationOnReservePhysicalTrans = InventBlockingMarkingSync::needRemoveReservationOnReservePhysicalTrans(_markingRefInventTransOrigin)
                                                                || (context
                                                                    && context.removeReservationOnReservePhysicalTrans)
                                                                || (removePhysicalReservationConext 
                                                                    && removePhysicalReservationConext.removeReservationOnReservePhysicalTrans);

            while (inventTrans)
            {
                InventTransOrigin::updateSplitInventTrans(inventTrans, markNow, cwMarkNow);
                InventTransOrigin::clearMarkingOnInventTrans(inventTrans);

                // remove reservation
                if (inventTrans.StatusIssue == StatusIssue::ReservOrdered ||
                    (inventTrans.StatusIssue == StatusIssue::ReservPhysical && removeReservationOnReservePhysicalTrans))
                {
                    inventTrans.StatusIssue = StatusIssue::OnOrder;
                    movement = inventTrans.inventMovement(true);
                    if (movement)
                    {
                        inventTrans.InventDimId = movement.inventDimId();

                        if (_showInfoReservRemoved && showReservInfoOnlyOnce)
                        {
                            setPrefix("@SYS15961");
                            setPrefix(strFmt("@SYS26868",#PreFixFieldValue(inventTransOrigin,ReferenceCategory, movement.transType()),
                                                     #PreFixFieldValue(inventTransOrigin,ReferenceId, movement.transRefId())));

                            setPrefix(strFmt("@SYS26868",#PreFixFieldValue(inventTrans,ItemId, movement.itemId()),
                                                     #PreFixFieldValue(inventTransOrigin,InventTransId, movement.transId())));

                            info("@SYS79529",'',inventTrans.infoActionOrigin());
                            showReservInfoOnlyOnce = false;
                        }

                        if (movement is InventMov_TransferFrom)
                        {
                            InventUpdate::updateTransDimTransferReceipt(movement, inventTrans, movement.inventdim());
                        }
                    }
                }

                inventTrans.update();

                // remove inventRef fields from the reference
                if (_clearItemReference && clearItemRefOnlyOnce)
                {
                    movement = inventTrans.inventMovement(true);
                    if (movement
                    &&  movement.markingRefInventTransOrigin() == _markingRefInventTransOrigin
                    && (TradeInterCompany::markingAllowed(inventTrans) || _interCompanyBypassMarkingAllowed))
                    {
                        movement.clearInventRefFields();
                    }
                    clearItemRefOnlyOnce = false;
                }

                markNow     -= inventTrans.Qty;
                markQtyUpd  -= inventTrans.Qty;

                cwMarkNow       -= inventTrans.PdsCWQty;
                cwMarkQtyUpd    -= inventTrans.PdsCWQty;

                inventTrans.updateSumUp();

                if (! markNow)
                {
                    break;
                }

                next inventTrans;
            }
        }

        ttscommit;

        _outQuantities.parmInventQty(markQtyUpd);
        _outQuantities.parmCwQty(cwMarkQtyUpd);

        return markQtyUpd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearMarkingOnInventTrans</Name>
				<Source><![CDATA[
    protected static void clearMarkingOnInventTrans(InventTrans _inventTrans)
    {
        _inventTrans.clearMarking();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteMarkingPhysicalDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes the marking from transactions with the specified inventory transaction originator and dimensions. Only transactions related to physical on hand is considered.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The ID of the inventory transaction originator for which marking is removed.
    /// </param>
    /// <param name="_markingRefInventTransOrigin">
    ///    The ID of the inventory transaction originator with which the transactions must be marked.
    /// </param>
    /// <param name="_inventDimId">
    ///    The inventory dimension ID to match exactly when finding transactions.
    /// </param>
    /// <param name="_markQty">
    ///    The quantity on transactions for which marking is removed.
    /// </param>
    /// <param name="_cwMarkQty">
    ///    The catch weight quantity on transactions for which marking is removed.
    /// </param>
    /// <returns>
    ///    A container with the inventory quantity and catch weight quantity which marking was removed.
    /// </returns>
    public static container deleteMarkingPhysicalDim(
        InventTransOriginId _inventTransOriginId,
        InventTransOriginId _markingRefInventTransOrigin,
        InventDimId         _inventDimId,
        InventQty           _markQty,                      // sign as _inventTransOriginId
        PdsCWInventQty      _cwMarkQty = 0
    )
    {
        InventTrans     inventTrans;

        InventQty       markNow;
        InventQty       markQtyUpd;
        InventQty       cwMarkNow;
        PdsCWInventQty  cwMarkQtyUpd;

        ttsbegin;

        if (_markQty)
        {
            markNow = _markQty;
            cwMarkNow = _cwMarkQty;

            while select forupdate inventTrans
                order by StatusReceipt desc, StatusIssue desc
                where inventTrans.ValueOpen                     == InventTransOpen::Yes
                   && inventTrans.InventTransOrigin             == _inventTransOriginId
                   &&   inventTrans.InventDimId                 == _inventDimId
                   && ((inventTrans.Qty > 0 && _markQty > 0)
                   ||  (inventTrans.Qty < 0 && _markQty < 0))
                   && ! inventTrans.PackingSlipReturned
                   &&   inventTrans.MarkingRefInventTransOrigin == _markingRefInventTransOrigin
                   &&   inventTrans.StatusReceipt               <= StatusReceipt::Registered        // Don't include pending receipts
                   &&   inventTrans.StatusIssue                 <= StatusIssue::ReservPhysical      // Don't include pending issue unless reserved against physical on hand

            {
                InventTransOrigin::updateSplitInventTrans(inventTrans, markNow, cwMarkNow);
                inventTrans.clearMarking();

                inventTrans.update();

                markNow     -= inventTrans.Qty;
                markQtyUpd  -= inventTrans.Qty;

                cwMarkNow       -= inventTrans.PdsCWQty;
                cwMarkQtyUpd    -= inventTrans.PdsCWQty;

                inventTrans.updateSumUp();

                if (! markNow)
                {
                    break;
                }
            }
        }

        ttscommit;

        return [markQtyUpd, cwMarkQtyUpd];
    }

]]></Source>
			</Method>
			<Method>
				<Name>existMarked_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether any inventory transaction exists for the inventory transactions originator and reference lot.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The ID of the inventory transactions originator.
    /// </param>
    /// <param name="_markingOriginId">
    ///    The ID of the reference lot.
    /// </param>
    /// <returns>
    ///    true if any transaction exists; otherwise, false.
    /// </returns>
    public static boolean existMarked_RU(InventTransOriginId _inventTransOriginId,
                                         InventTransOriginId _markingOriginId = 0)
    {
        InventTrans inventTrans;

        select firstonly RecId from inventTrans
            where inventTrans.InventTransOrigin   == _inventTransOriginId                                                                             &&
                ((inventTrans.MarkingRefInventTransOrigin    && inventTrans.MarkingRefInventTransOrigin != _inventTransOriginId) || _markingOriginId) &&
                 (inventTrans.MarkingRefInventTransOrigin    == _markingOriginId || ! _markingOriginId)                                               &&
                  inventTrans.PackingSlipReturned == NoYes::No;

        return inventTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the inventory transaction originator for a specified <c>InventTransOriginId</c> value.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    An identification of the inventory transaction originator.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    An inventory transaction originator for the given <c>InventTransOriginId</c> value if the record
    ///    exists; otherwise, an empty buffer.
    /// </returns>
    public static InventTransOrigin find(InventTransOriginId _inventTransOriginId, boolean _forUpdate = false)
    {
        InventTransOrigin   inventTransOrigin;

        if (_inventTransOriginId)
        {
            if (_forUpdate)
            {
                inventTransOrigin.selectForUpdate(_forUpdate);
            }

            select firstonly inventTransOrigin where inventTransOrigin.RecId == _inventTransOriginId;
        }

        return inventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the inventory transaction originator record for the given <c>InventTransId</c> value.
    /// </summary>
    /// <param name="_inventTransId">
    ///    An <c>InventTransId</c> value of the inventory transaction originator.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    An inventory transaction originator record for a given <c>InventTransId</c> value if a record that
    ///    corresponds exists; otherwise, an empty buffer.
    /// </returns>
    public static InventTransOrigin findByInventTransId(InventTransId _inventTransId, boolean _forUpdate = false)
    {
        InventTransOrigin   inventTransOrigin;

        if (_inventTransId)
        {
            if (_forUpdate)
            {
                inventTransOrigin.selectForUpdate(_forUpdate);
            }

            select firstonly inventTransOrigin where inventTransOrigin.InventTransId == _inventTransId;
        }

        return inventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByInventTransIdInDataArea</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the inventory transaction originator record for the given <c>InventTransId</c> value.
    /// </summary>
    /// <param name="_inventTransId">
    ///    An <c>InventTransId</c> value of the inventory transaction originator.
    /// </param>
    /// <param name="_dataAreaId">
    ///    The Data Area ID for the inventory transaction originator record.
    /// </param>
    /// <returns>
    ///    An inventory transaction originator record for a given <c>InventTransId</c> value if a record that
    ///    corresponds exists; otherwise, an empty buffer.
    /// </returns>
    public static InventTransOrigin findByInventTransIdInDataArea(InventTransId _inventTransId, DataAreaId _dataAreaId)
    {
        InventTransOrigin   inventTransOrigin;

        if (_inventTransId && _dataAreaId)
        {
            select firstonly crossCompany inventTransOrigin
                where inventTransOrigin.InventTransId   == _inventTransId
                   && inventTransOrigin.DataAreaId      == _dataAreaId;
        }

        return inventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMarkingRefInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the ID of an inventory transaction originator marked with the specified inventory transaction
    ///    originator.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The ID of the inventory transaction originator for which marking is examined.
    /// </param>
    /// <param name="_itemId">
    ///    The ID of the item that is marked.
    /// </param>
    /// <param name="_findVirtual">
    ///    true if virtual transactions should be examined; otherwise, false.
    /// </param>
    /// <param name="_findForce">
    ///    true if a time-using examination of many transactions should be used as a last resort; otherwise,
    ///    false.
    /// </param>
    /// <returns>
    ///    The ID of an inventory transaction originator marked with the specified value.
    /// </returns>
    public static InventTransOriginId findMarkingRefInventTransOrigin(
        InventTransOriginId _inventTransOriginId,
        ItemId              _itemId,
        boolean             _findVirtual    = false,
        boolean             _findForce      = false)
    {
        InventTransOrigin       inventTransOrigin;
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin_Virt;
        InventTrans             inventTrans_Virt;
        InventTransOrigin       inventTransOrigin_Quarantine;
        InventTrans             inventTrans_Quarantine;

        //Find virtual invent trans
        if (_findVirtual)
        {
            // Try to find virtual trans which directly mark with given inventTrans
            select firstonly TableId from inventTransOrigin
                where   inventTransOrigin.RecId                 == _inventTransOriginId
                     && inventTransOrigin.ItemId                == _itemId
                join MarkingRefInventTransOrigin, RecId from inventTrans
                where inventTrans.InventTransOrigin             == inventTransOrigin.RecId
                   && inventTrans.MarkingRefInventTransOrigin
                   && inventTrans.ValueOpen                     == InventTransOpen::Yes
                exists join inventTransOrigin_Virt
                where inventTransOrigin_Virt.RecId              == inventTrans.MarkingRefInventTransOrigin
                   && inventTransOrigin_Virt.ReferenceCategory  == InventTransType::InventTransaction
                   &&!inventTransOrigin_Virt.ReferenceId
                exists join inventTrans_Virt
                where inventTrans_Virt.ValueOpen                == InventTransOpen::Yes
                   && inventTrans_Virt.InventTransOrigin        == inventTrans.MarkingRefInventTransOrigin;

            if (inventTrans.MarkingRefInventTransOrigin)
            {
                return inventTrans.MarkingRefInventTransOrigin;
            }

            // Try to find virtual trans which may indirectly mark with given inventTrans
            // When quarantine management is On
            select firstonly TableId from inventTransOrigin
                where   inventTransOrigin.RecId                             == _inventTransOriginId
                     && inventTransOrigin.ItemId                            == _itemId
                join TableId from inventTrans
                where inventTrans.InventTransOrigin                         == inventTransOrigin.RecId
                   && inventTrans.MarkingRefInventTransOrigin
                   && inventTrans.ValueOpen                                 == InventTransOpen::Yes
                join  TableId from inventTransOrigin_Quarantine
                where inventTransOrigin_Quarantine.RecId                    == inventTrans.MarkingRefInventTransOrigin
                   && inventTransOrigin_Quarantine.ReferenceCategory        == InventTransType::QuarantineOrder
                join MarkingRefInventTransOrigin from inventTrans_Quarantine
                where inventTrans_Quarantine.InventTransOrigin              == inventTransOrigin_Quarantine.RecId
                   && inventTrans_Quarantine.ValueOpen                      == InventTransOpen::Yes
                   && inventTrans_Quarantine.MarkingRefInventTransOrigin
                   && inventTrans_Quarantine.MarkingRefInventTransOrigin    != inventTrans_Quarantine.InventTransOrigin
                   && inventTrans_Quarantine.MarkingRefInventTransOrigin    != inventTrans.InventTransOrigin
                exists join inventTransOrigin_Virt
                where inventTransOrigin_Virt.RecId                          == inventTrans_Quarantine.MarkingRefInventTransOrigin
                   && inventTransOrigin_Virt.ReferenceCategory              == InventTransType::InventTransaction;

            if (inventTrans_Quarantine.MarkingRefInventTransOrigin)
            {
                return inventTrans_Quarantine.MarkingRefInventTransOrigin;
            }

            if (_findForce )
            {
                // Find by MarkingRefInventTransOrigin
                select firstonly InventTransOrigin from inventTrans
                    where inventTrans.MarkingRefInventTransOrigin               == _inventTransOriginId
                        && inventTrans.ValueOpen                                == InventTransOpen::Yes
                    exists join inventTransOrigin
                        where inventTransOrigin.RecId                           == inventTrans.InventTransOrigin
                           && inventTransOrigin.ReferenceCategory               == InventTransType::InventTransaction
                           && inventTransOrigin.ItemId                          == _itemId;

                if (inventTrans.InventTransOrigin)
                {
                    return inventTrans.InventTransOrigin;
                }

                select firstonly TableId from inventTrans_Quarantine
                    where inventTrans_Quarantine.MarkingRefInventTransOrigin    ==_inventTransOriginId
                       && inventTrans_Quarantine.ValueOpen == InventTransOpen::Yes
                    join TableId from inventTransOrigin_Quarantine
                    where   inventTransOrigin_Quarantine.RecId              == inventTrans_Quarantine.InventTransOrigin
                         && inventTransOrigin_Quarantine.ReferenceCategory  == InventTransType::QuarantineOrder
                         && inventTransOrigin_Quarantine.ItemId             == _itemId
                    join inventTrans
                    where inventTrans.ValueOpen == InventTransOpen::Yes
                       && inventTrans.MarkingRefInventTransOrigin           == inventTrans_Quarantine.InventTransOrigin
                    exists join inventTransOrigin
                    where inventTransOrigin.RecId                           == inventTrans.InventTransOrigin
                       && inventTransOrigin.ReferenceCategory               == InventTransType::InventTransaction
                       &&!inventTransOrigin.ReferenceId;

                return inventTrans.InventTransOrigin;
            }

            InventTransOriginBlockingIssue inventTransOriginBlockingIssue;
            InventTransOriginBlockingReceipt inventTransOriginBlockingReceipt;

            // Try to find virtual trans which may indirectly mark with given inventTrans when blocking transaction marked with virtual transaction
            select MarkingRefInventTransOrigin from inventTrans
                where inventTrans.ValueOpen                                  == InventTransOpen::Yes
                   && inventTrans.InventTransOrigin                          == _inventTransOriginId
                   && inventTrans.ItemId                                     == _itemId
                   && inventTrans.MarkingRefInventTransOrigin                != 0
                join InventTransOrigin from inventTransOriginBlockingIssue
                where inventTransOriginBlockingIssue.InventTransOrigin       == inventTrans.MarkingRefInventTransOrigin
                join InventTransOrigin from inventTransOriginBlockingReceipt
                where inventTransOriginBlockingReceipt.InventBlockingReceipt == inventTransOriginBlockingIssue.InventBlockingIssue
                join InventTransOrigin from inventTrans_Virt
                where inventTrans_Virt.ValueOpen                             == InventTransOpen::Yes
                   && inventTrans_Virt.MarkingRefInventTransOrigin           == inventTransOriginBlockingReceipt.InventTransOrigin
                   && inventTrans_Virt.Itemid                                == _itemId
                exists join inventTransOrigin_Virt
                where inventTransOrigin_Virt.RecId                           == inventTrans_Virt.InventTransOrigin
                   && inventTransOrigin_Virt.ReferenceCategory               == InventTransType::InventTransaction
                   && !inventTransOrigin_Virt.ReferenceId;

            if (inventTrans_Virt.InventTransOrigin)
            {
                return inventTrans_Virt.InventTransOrigin;
            }
        }
        else
        {
            // Find marked invent trans
            select firstonly TableId from inventTransOrigin
                where   inventTransOrigin.RecId                 == _inventTransOriginId
                     && inventTransOrigin.ItemId                == _itemId
                join MarkingRefInventTransOrigin from inventTrans
                where inventTrans.InventTransOrigin             == inventTransOrigin.RecId
                   && inventTrans.MarkingRefInventTransOrigin
                   && inventTrans.ValueOpen                     == InventTransOpen::Yes;

            if (inventTrans.MarkingRefInventTransOrigin)
            {
                return inventTrans.MarkingRefInventTransOrigin;
            }

            if (_findForce)
            {
                select firstonly InventTransOrigin from inventTrans
                where inventTrans.MarkingRefInventTransOrigin   == _inventTransOriginId
                   && inventTrans.ValueOpen                     == InventTransOpen::Yes
                    exists join inventTransOrigin
                    where inventTransOrigin.RecId               == inventTrans.InventTransOrigin
                       && inventTransOrigin.ItemId              == _itemId;

                return inventTrans.InventTransOrigin;
            }
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupTransIdReturn</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates and shows a lookup where the user can select the transaction ID of the origin that must be
    ///    returned.
    /// </summary>
    /// <param name="_ctrl">
    ///    The calling form control.
    /// </param>
    /// <param name="_buffer">
    ///    The calling table buffer.
    /// </param>
    /// <param name="_inventDim">
    ///    The calling <c>InventDim</c> table buffer.
    /// </param>
    public static void lookupTransIdReturn(
        FormStringControl  _ctrl,
        Common             _buffer,
        InventDim          _inventDim)
    {
        Args                args = new Args();
        Object              formRun;

        args.name(formStr(InventTransOriginReturnLookup));
        args.caller(_ctrl);
        args.record(_buffer);

        formRun = classfactory.formRunClass(args);
        formRun.parmInventDimCaller(_inventDim);
        formRun.init();

        _ctrl.performFormLookup(formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfMarkedTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds marking information for the specified inventory transaction originator.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// The ID of the inventory transaction originator for which marking is calculated.
    /// </param>
    /// <returns>
    /// A container that contains three values; the first value is the number of different movements that
    /// are marked with the specified originator.
    /// </returns>
    public static container numOfMarkedTransOrigin(InventTransOriginId _inventTransOriginId)
    {
        InventTrans         inventTrans;
        InventTransOriginId markedOriginId;
        Integer             numOfMarked;
        InventQty           qtyMarked;
        PdsCWInventQty      cwQtyMarked;

        while select MarkingRefInventTransOrigin, sum(Qty), sum(QtySettled), sum(PdsCWQty), sum(PdsCWSettled)
            from inventTrans
            group by MarkingRefInventTransOrigin
            where inventTrans.InventTransOrigin             == _inventTransOriginId
               && inventTrans.MarkingRefInventTransOrigin   != 0
        {
            numOfMarked++;
            markedOriginId   = inventTrans.MarkingRefInventTransOrigin;
            qtyMarked   += inventTrans.openQty();
            cwQtyMarked += inventTrans.pdsCWOpenQty();
        }

        return [numOfMarked, qtyMarked, markedOriginId, cwQtyMarked];
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the marked quantity for the specified inventory transaction originator.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// The ID of the inventory transaction originator for which marking is calculated.
    /// </param>
    /// <param name="_markingRefInventTransOrigin">
    /// The ID of the inventory transaction originator with which the transactions must be marked.
    /// </param>
    /// <param name="_outQuantities">
    /// A variable to update together with the marked inventory and catch-weight quantities.
    /// </param>
    /// <returns>
    /// The marked quantity.
    /// </returns>
    /// <remarks>
    /// This method includes transactions that are marked with all the values other than the value of the
    /// <paramref name="_inventTransOriginId" /> parameter when the value of the <paramref
    /// name="_markingRefInventTransOrigin" /> parameter is zero.
    /// </remarks>
    public static InventQtyMarked qtyMarked(
        InventTransOriginId _inventTransOriginId,
        InventTransOriginId _markingRefInventTransOrigin    = 0,
        PmfQtyDataCarrier _outQuantities = new PmfQtyDataCarrier()
        )
    {
        InventTrans     inventTrans,inventTransMark;
        InventQtyMarked qtyMark;
        PdsCWInventQty  cwQtyMark;

        while select sum(Qty),sum(QtySettled), sum(PdsCWQty), sum(PdsCWSettled)
            from inventTrans
            group by MarkingRefInventTransOrigin
            where inventTrans.InventTransOrigin             == _inventTransOriginId
               && ((inventTrans.MarkingRefInventTransOrigin  && inventTrans.MarkingRefInventTransOrigin != _inventTransOriginId) || _markingRefInventTransOrigin)
               && (inventTrans.MarkingRefInventTransOrigin  == _markingRefInventTransOrigin || !_markingRefInventTransOrigin )
               && inventTrans.PackingSlipReturned           == NoYes::No

        {
            select sum(Qty),sum(QtySettled), sum(PdsCWQty), sum(PdsCWSettled)
                from inventTransMark
                where inventTransMark.InventTransOrigin             == inventTrans.MarkingRefInventTransOrigin
                   && inventTransMark.MarkingRefInventTransOrigin   == _inventTransOriginId
                   && inventTransMark.PackingSlipReturned           == NoYes::No;

            if (inventTrans.Qty < 0 || (inventTrans.Qty == 0 && inventTransMark.Qty > 0 ))
            {
                qtyMark -=  min(-inventTrans.openQty(),inventTransMark.openQty());
                cwQtyMark -=  min(-inventTrans.pdsCWOpenQty(),inventTransMark.pdsCWOpenQty());
            }
            else
            {
                qtyMark += min(inventTrans.openQty(),-inventTransMark.openQty());
                cwQtyMark += min(inventTrans.pdsCWOpenQty(),-inventTransMark.pdsCWOpenQty());
            }
        }

        _outQuantities.parmInventQty(qtyMark);
        _outQuantities.parmCwQty(cwQtyMark);

        return qtyMark; //sign as _inventTransId
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryAddRangeInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a <c>InventTransId</c> range to the query.
    /// </summary>
    /// <param name="_query">
    ///    A <c>Query</c> object.
    /// </param>
    /// <returns>
    ///    A <c>QueryBuildRange</c> object.
    /// </returns>
    public static QueryBuildRange queryAddRangeInventTransId(Query _query)
    {
        QueryBuildDataSource    queryBuildDataSource;
        QueryBuildRange         queryBuildRange;

        queryBuildDataSource    = _query.dataSourceTable(tableNum(InventTransOrigin));
        queryBuildDataSource.clearDynalinks();

        queryBuildRange     = SysQuery::findOrCreateRange(queryBuildDataSource, fieldNum(InventTransOrigin,InventTransId));
        queryBuildRange.status(RangeStatus::Hidden);

        return queryBuildRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>referenceCategoryByTransId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the reference category for a specified <c>InventTransId</c> value.
    /// </summary>
    /// <param name="_transId">
    ///    The ID of the record to find.
    /// </param>
    /// <returns>
    ///    The reference category for a specified <c>InventTransId</c> value.
    /// </returns>
    public static InventTransType referenceCategoryByTransId(InventTransId _transId)
    {
        return (select firstonly ReferenceCategory from inventTransOrigin
                    where inventTransOrigin.InventTransId == _transId).ReferenceCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>referenceIdByTransId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the reference ID for a specified <c>InventTransId</c> value.
    /// </summary>
    /// <param name="_transId">
    ///    The ID of the record to find.
    /// </param>
    /// <returns>
    ///    The reference ID for a specified <c>InventTransId</c> value.
    /// </returns>
    public static InventTransRefId referenceIdByTransId(InventTransId _transId)
    {
        return (select firstonly ReferenceId from inventTransOrigin
                    where inventTransOrigin.InventTransId == _transId).ReferenceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionsExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether any inventory transaction exists for the inventory transactions originator.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The ID of the inventory transactions originator.
    /// </param>
    /// <returns>
    ///    true if any transaction exists; otherwise, false.
    /// </returns>
    public static boolean transactionsExist(InventTransOriginId _inventTransOriginId)
    {
        InventTrans     inventTrans;

        select firstonly RecId from inventTrans where inventTrans.InventTransOrigin == _inventTransOriginId;

        return inventTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates marking for the specified inventory transaction originator.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// The ID of the inventory transaction originator for which marking is updated.
    /// </param>
    /// <param name="_markingRefInventTransOrigin">
    /// The ID of the inventory transaction originator to mark.
    /// </param>
    /// <param name="_markQty">
    /// The quantity to mark.
    /// </param>
    /// <param name="_voucherId">
    /// The transactions with which this voucher will be marked.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order for the status fields to use when finding transactions to mark.
    /// </param>
    /// <param name="_preferPhysicalBeforeExpected">
    /// A Boolean value that indicates whether transactions which contribute to physical on hand should be
    /// preferred over expected transactions.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension values to match with when finding transactions to mark.
    /// </param>
    /// <param name="_inventDimParm">
    /// The inventory dimensions to match with when finding transactions to mark.
    /// </param>
    /// <param name="_cwMarkQty">
    /// The catch weight quantity to mark.
    /// </param>
    /// <param name="_outQuantities">
    /// A variable that will be updated by using the marked inventory and catch-weight quantities.
    /// </param>
    /// <returns>
    /// The marked quantity.
    /// </returns>
    public static InventQty updateMarking(
        InventTransOriginId     _inventTransOriginId,
        InventTransOriginId     _markingRefInventTransOrigin,
        InventQty               _markQty,           // sign as _inventTransOriginId
        Voucher                 _voucherId             = '',
        SortOrder               _sortOrder = SortOrder::Ascending,
        boolean                 _preferPhysicalBeforeExpected = false,
        InventDim               _inventDimCriteria = null,
        InventDimParm           _inventDimParm = null,
        PdsCWInventQty          _cwMarkQty = 0,
        PmfQtyDataCarrier       _outQuantities = new PmfQtyDataCarrier()
        )
    {
        InventTrans     inventTrans;

        InventQty       markNow;
        InventQty       markQtyUpd;
        InventDim       inventDim;

        PdsCWInventQty  cwMarkNow;
        PdsCWInventQty  cwMarkQtyUpd;

        boolean settleTrans()
        {
            InventTransOrigin::updateSplitInventTrans(inventTrans, markNow, cwMarkNow);
            inventTrans.setMarking(_markingRefInventTransOrigin);
            inventTrans.update();

            markNow     -= inventTrans.Qty;
            markQtyUpd  -= inventTrans.Qty;

            cwMarkNow       -= inventTrans.PdsCWQty;
            cwMarkQtyUpd    -= inventTrans.PdsCWQty;

            if (! markNow)
            {
                return true;
            }

            return false;
        }

        if (_markQty)
        {
            InventTransOrigin inventTransOrigin = InventTransOrigin::find(_inventTransOriginId);

            markNow = _markQty;
            cwMarkNow = _cwMarkQty;
            boolean isScrapTransaction = inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderScrap;

            if (InventTable::isItemCatchWeightAndWarehouseProcessEnabled(inventTransOrigin.ItemId))
            {
                [markNow, cwMarkNow, markQtyUpd, cwMarkQtyUpd] = InventTransOrigin::updateMarkingForWarehouseEnabledCatchWeightItem(
                    _inventTransOriginId,
                    _markingRefInventTransOrigin,
                    _markQty,
                    _voucherId,
                    _sortOrder,
                    _preferPhysicalBeforeExpected,
                    _inventDimCriteria,
                    _inventDimParm,
                    _cwMarkQty);

                // Since the above method excludes the CW items where the handling qty is zero, then fall back to the existing logic of marking.
                // Which means if we have a scenario where we call into this method to mark 1 cwQty/1000 qty and we have two transactions,
                // one for 1 cwQty/900 qty and one for 0 cwQty/100 qty, then this "if" condition will ensure to mark those records as well.
                if (! markNow)
                {
                    _outQuantities.parmInventQty(markQtyUpd);
                    _outQuantities.parmCwQty(cwMarkQtyUpd);
                    return markQtyUpd;
                }
            }

            ttsbegin;

            if (_sortOrder == SortOrder::Ascending)
            {
                SysDaQueryObject inventTransToBeMarkedQueryObject = new InventTransToBeMarkedQueryBuilder()
                                                                        .setInventTransToBeMarked(inventTrans)
                                                                        .setInventDimForSearch(inventDim)
                                                                        .setInventDimCriteria(_inventDimCriteria)
                                                                        .setInventDimParmForValidateEnabled(_inventDimParm)
                                                                        .setMarkInventTransOriginId(_inventTransOriginId)
                                                                        .setMarkQty(_markQty)
                                                                        .setIsScrapTransaction(isScrapTransaction)
                                                                        .setMarkSortOrder(SortOrder::Ascending)
                                                                        .setMarkVoucherId(_voucherId)                                                                      .setIsDeleteMarkingOperation(false)
                                                                        .setIsUpdateMarkingOperation(true)
                                                                        .buildInventTransQuery();

                SysDaSearchObject inventTransToBeMarkedSearchObject = new SysDaSearchObject(inventTransToBeMarkedQueryObject);
                SysDaSearchStatement inventTransToBeMarkedStatement = new SysDaSearchStatement();
                while (inventTransToBeMarkedStatement.next(inventTransToBeMarkedSearchObject))
                {
                    if (settleTrans())
                    {
                        break;
                    }
                }
            }
            else
            {
                if (_preferPhysicalBeforeExpected)
                {
                    InventTransToBeMarkedQueryBuilder inventTransToBeMarkedQueryBuilder = new InventTransToBeMarkedQueryBuilder()
                                                                                            .setInventTransToBeMarked(inventTrans)
                                                                                            .setInventDimForSearch(inventDim)
                                                                                            .setInventDimCriteria(_inventDimCriteria)
                                                                                            .setInventDimParmForValidateEnabled(_inventDimParm)
                                                                                            .setMarkInventTransOriginId(_inventTransOriginId)
                                                                                            .setMarkQty(_markQty)
                                                                                            .setIsScrapTransaction(isScrapTransaction)
                                                                                            .setMarkVoucherId(_voucherId)
                                                                                            .setIsStatusConditionAdded(true)
                                                                                            .setMarkSortOrder(SortOrder::Descending)
                                                                                            .setIsUpdateMarkingOperation(true);

                    InventDestructiveQualityOrderUpdateMarkingContext context = InventDestructiveQualityOrderUpdateMarkingContext::current();
                    if (context && context.parmPackingSlipId())
                    {
                        inventTransToBeMarkedQueryBuilder.setPackingSlipId(context.parmPackingSlipId());
                    }
                    SysDaQueryObject inventTransToBeMarkedQueryObject = inventTransToBeMarkedQueryBuilder.buildInventTransQuery();

                    SysDaSearchObject inventTransToBeMarkedSearchObject = new SysDaSearchObject(inventTransToBeMarkedQueryObject);
                    SysDaSearchStatement inventTransToBeMarkedStatement = new SysDaSearchStatement();
                    while (inventTransToBeMarkedStatement.next(inventTransToBeMarkedSearchObject))
                    {
                        if (settleTrans())
                        {
                            break;
                        }
                    }
                }

                if (markNow != 0)
                {
                    // if something still isn't marked then use expected receipts/issue
                    SysDaQueryObject inventTransToBeMarkedQueryObject = new InventTransToBeMarkedQueryBuilder()
                                                                            .setInventTransToBeMarked(inventTrans)
                                                                            .setInventDimForSearch(inventDim)
                                                                            .setInventDimCriteria(_inventDimCriteria)
                                                                            .setInventDimParmForValidateEnabled(_inventDimParm)
                                                                            .setMarkInventTransOriginId(_inventTransOriginId)
                                                                            .setMarkQty(_markQty)
                                                                            .setIsScrapTransaction(isScrapTransaction)
                                                                            .setMarkVoucherId(_voucherId)
                                                                            .setMarkSortOrder(SortOrder::Descending)
                                                                            .setIsUpdateMarkingOperation(true)
                                                                            .buildInventTransQuery();

                    SysDaSearchObject inventTransToBeMarkedSearchObject = new SysDaSearchObject(inventTransToBeMarkedQueryObject);
                    SysDaSearchStatement inventTransToBeMarkedStatement = new SysDaSearchStatement();
                    while (inventTransToBeMarkedStatement.next(inventTransToBeMarkedSearchObject))
                    {
                        if (settleTrans())
                        {
                            break;
                        }
                    }
                }
            }

            ttscommit;
        }

        _outQuantities.parmInventQty(markQtyUpd);
        _outQuantities.parmCwQty(cwMarkQtyUpd);

        return markQtyUpd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkingForWarehouseEnabledCatchWeightItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates marking for the specified inventory transaction originator in case of warehouse enabled catch weight item.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// The ID of the inventory transaction originator for which marking is updated.
    /// </param>
    /// <param name="_markingRefInventTransOrigin">
    /// The ID of the inventory transaction originator to mark.
    /// </param>
    /// <param name="_markQty">
    /// The quantity to mark.
    /// </param>
    /// <param name="_voucherId">
    /// The transactions with which this voucher will be marked.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order for the status fields to use when finding transactions to mark.
    /// </param>
    /// <param name="_preferPhysicalBeforeExpected">
    /// Determines if the transactions which contribute to physical on hand should be preferred over expected transactions.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension values to match with when finding transactions to mark.
    /// </param>
    /// <param name="_inventDimParm">
    /// Selects the inventory dimensions to match with when finding transactions to mark.
    /// </param>
    /// <param name="_cwMarkQty">
    /// The catch weight quantity to mark.
    /// </param>
    /// <returns>
    /// A container with values: Remaining inventory qty to mark, remaining catch weight qty to mark, inventory qty marked, and catch weight qty marked.
    /// </returns>
    private static container updateMarkingForWarehouseEnabledCatchWeightItem(
        InventTransOriginId     _inventTransOriginId,
        InventTransOriginId     _markingRefInventTransOrigin,
        InventQty               _markQty,
        Voucher                 _voucherId,
        SortOrder               _sortOrder,
        boolean                 _preferPhysicalBeforeExpected,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm,
        PdsCWInventQty          _cwMarkQty)
    {
        InventTrans     inventTrans;

        InventQty       markNow;
        InventQty       markQtyUpd;
        InventDim       inventDim;

        PdsCWInventQty  cwMarkNow;
        PdsCWInventQty  cwMarkQtyUpd;

        boolean settleTrans()
        {
            InventTransOrigin::updateSplitInventTrans(inventTrans, markNow, cwMarkNow);
            inventTrans.setMarking(_markingRefInventTransOrigin);
            inventTrans.update();

            markNow     -= inventTrans.Qty;
            markQtyUpd  -= inventTrans.Qty;

            cwMarkNow       -= inventTrans.PdsCWQty;
            cwMarkQtyUpd    -= inventTrans.PdsCWQty;

            if (! markNow)
            {
                return true;
            }

            return false;
        }

        ttsbegin;

        markNow = _markQty;
        cwMarkNow = _cwMarkQty;
            
        if (_cwMarkQty)
        {
            boolean isScrapTransaction = InventTransOrigin::find(_inventTransOriginId).ReferenceCategory == InventTransType::TransferOrderScrap;

            if (_sortOrder == SortOrder::Ascending)
            {
                // In case of CW items there can be transaction where Qty field have weight value and the PdsCWQty field can be empty, ignore these records for marking else it will throw spit errors.
                while select forupdate inventTrans
                    order by StatusReceipt, StatusIssue // Automatically prefers physically updated before expected
                    where inventTrans.ValueOpen             == InventTransOpen::Yes
                        && inventTrans.InventTransOrigin     == _inventTransOriginId
                        && ((inventTrans.Qty > 0 && _markQty > 0) ||  (inventTrans.Qty < 0 && _markQty < 0))
                        && ((inventTrans.PdsCWQty > 0 && _cwMarkQty > 0) || (inventTrans.PdsCWQty < 0 && _cwMarkQty < 0))
                        && !inventTrans.PackingSlipReturned
                        && (!inventTrans.MarkingRefInventTransOrigin || isScrapTransaction)
                        && (inventTrans.Voucher              == _voucherId || ! _voucherId)
                        #inventDimExistsJoin(inventTrans.inventDimId,inventDim, _inventDimCriteria, _inventDimParm)

                {
                    if (settleTrans())
                    {
                        break;
                    }
                }
            }
            else
            {
                if (_preferPhysicalBeforeExpected)
                {
                    while select forupdate inventTrans
                        order by StatusReceipt desc, StatusIssue desc
                        where inventTrans.ValueOpen             == InventTransOpen::Yes
                            && inventTrans.InventTransOrigin     == _inventTransOriginId
                            && inventTrans.StatusReceipt         <= StatusReceipt::Arrived
                            && inventTrans.StatusIssue           <= StatusIssue::Picked
                            && ((inventTrans.Qty > 0 && _markQty > 0) ||  (inventTrans.Qty < 0 && _markQty < 0))
                            && ((inventTrans.PdsCWQty > 0 && _cwMarkQty > 0) ||  (inventTrans.PdsCWQty < 0 && _cwMarkQty < 0))
                            && !inventTrans.PackingSlipReturned
                            && (!inventTrans.MarkingRefInventTransOrigin || isScrapTransaction)
                            && (inventTrans.Voucher              == _voucherId || ! _voucherId)
                            #inventDimExistsJoin(inventTrans.inventDimId,inventDim, _inventDimCriteria, _inventDimParm)

                    {
                        if (settleTrans())
                        {
                            break;
                        }
                    }
                }

                if (markNow != 0)
                {
                    // if something still isn't marked then use expected receipts/issues
                    while select forupdate inventTrans
                        order by StatusReceipt desc, StatusIssue desc
                        where inventTrans.ValueOpen             == InventTransOpen::Yes
                            && inventTrans.InventTransOrigin     == _inventTransOriginId
                            && ((inventTrans.Qty > 0 && _markQty > 0) ||  (inventTrans.Qty < 0 && _markQty < 0))
                            && ((inventTrans.PdsCWQty > 0 && _cwMarkQty > 0) ||  (inventTrans.PdsCWQty < 0 && _cwMarkQty < 0))
                            && !inventTrans.PackingSlipReturned
                            && (!inventTrans.MarkingRefInventTransOrigin || isScrapTransaction)
                            && (inventTrans.Voucher              == _voucherId || ! _voucherId)
                            #inventDimExistsJoin(inventTrans.inventDimId,inventDim, _inventDimCriteria, _inventDimParm)

                    {
                        if (settleTrans())
                        {
                            break;
                        }
                    }
                }
            }
        }

        ttscommit;

        return [markNow, cwMarkNow, markQtyUpd, cwMarkQtyUpd];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSplitInventTrans</Name>
				<Source><![CDATA[
    private static void updateSplitInventTrans(
        InventTrans _inventTrans,
        InventQty _markNow,
        InventQty _cwMarkNow)
	{
        if (_inventTrans.financialOpenQty() != _inventTrans.Qty)
        {
            _inventTrans.updateSplit(_inventTrans.financialOpenQty(), _inventTrans.pdsCWFinancialOpenQty());
        }

        if (abs(_markNow) < abs(_inventTrans.Qty))
        {
            boolean isInventTransQtyPositive = _inventTrans.Qty > 0;
            boolean isInventTransPdsCWQtyPositive = _inventTrans.PdsCWQty > 0;

            if (InventTable::isItemCatchWeightAndWarehouseProcessEnabled(_inventTrans.ItemId))
            {
                isInventTransPdsCWQtyPositive = isInventTransQtyPositive;
            }

            _inventTrans.updateSplit(isInventTransQtyPositive ? abs(_markNow) : - abs(_markNow),
                                     isInventTransPdsCWQtyPositive ? abs(_cwMarkNow) : - abs(_cwMarkNow));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReferenceCategoryTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the reference category is a transfer.
    /// </summary>
    /// <param name="_referenceCategory">
    ///    The reference category.
    /// </param>
    /// <returns>
    ///    true if the reference category is a transfer; otherwise, false.
    /// </returns>
    public static boolean isReferenceCategoryTransfer(InventTransType _referenceCategory)
    {
        switch (_referenceCategory)
        {
            case InventTransType::InventTransfer:
            case InventTransType::Blocking:
            case InventTransType::WMSTransport:
            case InventTransType::QuarantineOrder:
            case InventTransType::TransferOrderShip:
            case InventTransType::TransferOrderReceive:
            case InventTransType::KanbanJobTransferIssue:
            case InventTransType::KanbanJobTransferReceipt:
            case InventTransType::SummedUp:
            case InventTransType::WHSWork:
            case InventTransType::WHSContainer:
            case InventTransType::WHSQuarantine:
                return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTransTypeOnlyAffectsLocationAndBelowContainer</Name>
				<Source><![CDATA[
    [Hookable(false), Wrappable(false)]
    public static container buildTransTypeOnlyAffectsLocationAndBelowContainer()
    {
        SysDictEnum dictEnum = new SysDictEnum(enumNum(InventTransType));
        Enumerator enumerator = dictEnum.getEnumerator();

        container inventTransTypeCon;
        while (enumerator.moveNext())
        {
            InventTransType inventTransType = enumerator.current();

            // Archive inventory transaction type will be excluded
            if (inventTransType != InventTransType::WHSInventTransArchiveOnlyAffectsLocationAndBelow
            &&  WhsInvent::transTypeOnlyAffectsLocationAndBelow(inventTransType))
            {
                inventTransTypeCon += [inventTransType];
            }
           
        }

        return inventTransTypeCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReferenceCategoryFromInventJournal</Name>
				<Source><![CDATA[
    internal boolean isReferenceCategoryFromInventJournal()
    {
        return ((this.ReferenceCategory == InventTransType::InventTransaction)
                || (this.ReferenceCategory == InventTransType::InventTransfer)
                || (this.ReferenceCategory == InventTransType::Project)
                || (this.ReferenceCategory == InventTransType::Asset)
                || (this.ReferenceCategory == InventTransType::BOMLine)
                || (this.ReferenceCategory == InventTransType::BOMMain)
                || (this.ReferenceCategory == InventTransType::InventCounting)
                || (this.ReferenceCategory == InventTransType::InventLossProfit));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LogisticsBasic</ConfigurationKey>
	<DeveloperDocumentation>@SYS319571</DeveloperDocumentation>
	<FormRef>InventTrans</FormRef>
	<Label>@SYS127538</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>ReferenceCategory</TitleField1>
	<TitleField2>ReferenceId</TitleField2>
	<AllowArchival>Yes</AllowArchival>
	<AllowRetention>Yes</AllowRetention>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>RecId</ClusteredIndex>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<Modules>Inventory</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<ReplacementKey>InventTransIdIdx</ReplacementKey>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>InventTrans</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>InventTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>InventTransOriginAssemblyComponent</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>InventTransOriginAssemblyComponent</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>InventTransOriginTransfer</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>InventTransOriginTransfer</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>InventTransPosting</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>InventTransPosting</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReferenceCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReferenceId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Party</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemInventDimId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Lot</Name>
			<Label>@SYS16247</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReferenceCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReferenceId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>OriginReference</Name>
			<Label>@SYS134704</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReferenceCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReferenceId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>partyName</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Other</Name>
			<Label>@SYS1284</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemInventDimId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemInventDimId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Party</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>DirPartyRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReferenceCategory</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<GroupPrompt>@SYS1201</GroupPrompt>
			<EnumType>InventTransType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReferenceId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransRefId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsExcludedFromInventoryValue</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventIsExcludedFromInventoryValue</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>InventTransIdIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ItemIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ReferenceCategory</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ReferenceIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ReferenceId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ReferenceCategory</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>IsExcludedReferenceCategoryIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>IsExcludedFromInventoryValue</DataField>
					<Optional>Yes</Optional>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ReferenceCategory</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DirPartyTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DirPartyTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DirPartyTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DirPartyTable_InventTransOrigin</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Party</Name>
					<Field>Party</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ItemIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ItemInventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemInventDimId</Name>
					<Field>ItemInventDimId</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>