<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>JmgTermReg</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Note: If JmgParameters.GetRegistration is set to JmgGetRegistrationTimeFrom::AOSServer then the
/// RegDateTime field of this table is not stored as UTC but legal entity time with the user preferred time zone removed.
/// The user preferred time zone must therefore always be applied when reading RegDateTime values from this table
/// also when the JmgParameters.GetRegistration is set to JmgGetRegistrationTimeFrom::AOSServer.
/// JmgProfileSeconds::getJmgTermRegCurrentTime can be used to obtain the current time comparable to RegDateTime.
/// </summary>
public class JmgTermReg extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>assignProfileDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns the profile date to registrations with a registration time
    /// later than the one in the <c>JmgTermReg</c> table.
    /// </summary>
    private void assignProfileDate()
    {
        JmgTermReg  nextJob, jobStop;

        while select forupdate nextJob order by RegDateTime,RegType
            where nextJob.Worker      == this.Worker &&
                  nextJob.RegDateTime >= this.RegDateTime &&
                  nextJob.RegType     != JmgTermRegType::JobStop &&
                  nextJob.RegType     != JmgTermRegType::TeamStop &&
                  nextJob.RegType     != JmgTermRegType::BrkFlowStop &&
                  nextJob.RecId       != this.RecId
        {
            // Break if new ClockIn is found - ClockOut registration is then missing
            if (nextJob.RegType == JmgTermRegType::ClockIn)
                break;

            // Set profiledate based on the latest ClockIn registration
            nextJob.ProfileDate = this.ProfileDate;
            nextJob.update();

            // If STOP registration - profiledate is taken from matched START reg.
            if  ((nextJob.RegType == JmgTermRegType::JobStart  ||
                  nextJob.RegType == JmgTermRegType::TeamStart ||
                  nextJob.RegType == JmgTermRegType::BrkFlowStart) && (nextJob.MatchRecIdStartStop))
            {
                select firstonly forupdate jobStop
                    where jobStop.RecId == nextJob.MatchRecIdStartStop;

                if (jobStop)
                {
                    jobStop.ProfileDate = nextJob.ProfileDate;
                    jobStop.update();
                }
            }

            // Break search loop if registration is a ClockOut registration
            if (nextJob.RegType == JmgTermRegType::ClockOut)
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assistName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the name of the worker that is associated with the <c>JmgTermReg</c> record.
    /// </summary>
    /// <returns>
    /// The name of the worker.
    /// </returns>
    public display DirPartyName assistName()
    {
        return HcmWorker::worker2Name(this.Worker);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreatePlannedAbs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a planned absence by using a workers clock out registration.
    /// </summary>
    /// <param name="_journalTrans">
    /// The clock out registration, which contains a reference to the absence.
    /// </param>
    void checkCreatePlannedAbs(JmgStampJournalTrans _journalTrans)
    {
        HRMAbsenceCode          hrmAbsenceCode;
        JmgAbsenceCalendar      absenceCalendar;

        // Check for creating planned absence
        if (! _journalTrans)
        {
            if (_journalTrans.Module == JmgModuleEnum::IPC && _journalTrans.JourRegType == JmgJourRegTypeEnum::SignOut && _journalTrans.JobIDAbs)
            {
                hrmAbsenceCode = HRMAbsenceCode::findByJobId(_journalTrans.JobIDAbs);
                if (hrmAbsenceCode && hrmAbsenceCode.JmgContinousAbsence)
                {
                    absenceCalendar.Worker              = _journalTrans.Worker;
                    absenceCalendar.JobId               = _journalTrans.JobIDAbs;
                    absenceCalendar.FromDateTime        = DateTimeUtil::newDateTime(_journalTrans.StartDate,_journalTrans.StartTime,DateTimeUtil::getUserPreferredTimeZone());
                    if (hrmAbsenceCode.MaxInSerieActive == NoYes::Yes)
                    {
                        absenceCalendar.ToDateTime          = DateTimeUtil::newDateTime(_journalTrans.StartDate + hrmAbsenceCode.MaxInSerie,timeMax(),DateTimeUtil::getUserPreferredTimeZone());
                    }
                    else
                    {
                        absenceCalendar.ToDateTime       = DateTimeUtil::newDateTime(_journalTrans.StartDate + 90,timeMax(),DateTimeUtil::getUserPreferredTimeZone());
                    }
                    absenceCalendar.DisableAtSigning    = NoYes::Yes;
                    absenceCalendar.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalSignIn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a journal registration that is based on the specified <c>JmgTermReg</c> record.
    /// </summary>
    /// <param name="_termReg">
    /// The <c>JmgTermReg</c> record from which the journal registration is created.
    /// </param>
    void createJournalSignIn(JmgTermReg _termReg)
    {
        // Create journalrecord for START signind, and init STOP time and state
        JmgStampJournalTrans journalTrans;

        select firstonly forupdate journalTrans
            where journalTrans.TermRegStartRecID  == _termReg.RecId;

        this.initializeJournalTransSignIn(journalTrans, _termReg);

        journalTrans.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeJournalTransSignIn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a journal registration record that is based on the specified <c>JmgTermReg</c> record.
    /// </summary>
    /// <param name = "_journalTrans">
    /// The journal registration record to initialize.
    /// </param>
    /// <param name="_termReg">
    /// The <c>JmgTermReg</c> record from which the journal registration is initialized.
    /// </param>
    protected void initializeJournalTransSignIn(JmgStampJournalTrans _journalTrans, JmgTermReg _termReg)
    {
        _termReg.createUpdateJournalInit(_journalTrans, _termReg.JobId, _termReg.JobIdAbs);

        _journalTrans.Worker             = _termReg.Worker;
        _journalTrans.ProfileDate        = _termReg.ProfileDate;
        _journalTrans.StartDate          = this.getUserPreferredDate(_termReg.RegDateTime);
        _journalTrans.StartTime          = this.getUserPreferredTime(_termReg.RegDateTime);
        _journalTrans.WorkerPilot        = _termReg.WorkerPilot;
        _journalTrans.WrkCtrIdPilot      = _termReg.WrkCtrIdPilot;
        _journalTrans.Active             = _termReg.JobActive;
        _journalTrans.WrkCtrId           = _termReg.ResNo;
        _journalTrans.termRegStartRecID  = _termReg.RecId;
        _journalTrans.termRegStopRecID   = _termReg.MatchRecIdStartStop;
        _journalTrans.ProjCategory       = _termReg.CostCategory;
        _journalTrans.TermStart          = _termReg.TerminalId;

        // Initiate GOOD, SCRRAP and FINISHCODE from START stamp
        if (_journalTrans.RecId)
        {
            _journalTrans.QtyStartup      += _termReg.TmpStartItems;
            _journalTrans.PdsCWQtyStartup += _termReg.TmpPdsCWStartItems;
        }
        else
        {
            _journalTrans.QtyStartup      = _termReg.StartItems;
            _journalTrans.PdsCWQtyStartup = _termReg.PdsCWStartItems;
        }

        _journalTrans.QtyGood            = _termReg.GoodItems;
        _journalTrans.QtyError           = _termReg.ScrapItems;

        _journalTrans.PdsCWQtyGood       = _termReg.PdsCWGoodItems;
        _journalTrans.PdsCWQtyError      = _termReg.PdsCWScrapItems;

        _journalTrans.JobFinished        = (_termReg.FinishedCode == 2) ? 1 : 0;
        _journalTrans.ErrorSpecification = _termReg.ErrorSpecification;

        // if START and STOP matched, set STOP time and status
        _journalTrans.StopDate           = dateNull();
        _journalTrans.StopTime           = 0;

        if (_journalTrans.termRegStopRecID)
        {
            JmgTermReg termJobStop;

            select firstonly termJobStop
                where termJobStop.RecId == _journalTrans.termRegStopRecID;

            this.initializeJournalTransSignInFromTermJobStop(_journalTrans, termJobStop);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeJournalTransSignInFromTermJobStop</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a journal registration record that is based on the specified <c>JmgTermReg</c> record representing a stop job.
    /// </summary>
    /// <param name = "_journalTrans">
    /// The journal registration record to initialize.
    /// </param>
    /// <param name="_termJobStop">
    /// The <c>JmgTermReg</c> record representing a stop job from which the journal registration is initialized.
    /// </param>
    protected void initializeJournalTransSignInFromTermJobStop(JmgStampJournalTrans _journalTrans, JmgTermReg _termJobStop)
    {
        if (_termJobStop)
        {
            _journalTrans.StopDate  = this.getUserPreferredDate(_termJobStop.RegDateTime);
            _journalTrans.StopTime  = this.getUserPreferredTime(_termJobStop.RegDateTime);
            _journalTrans.TermStop  = _termJobStop.TerminalId;

            // Initiate GOOD, SCRRAP og FINISHCODE from STOP stamp
            _journalTrans.QtyGood       += _termJobStop.GoodItems;
            _journalTrans.QtyError      += _termJobStop.ScrapItems;

            _journalTrans.PdsCWQtyGood       += _termJobStop.PdsCWGoodItems;
            _journalTrans.PdsCWQtyError      += _termJobStop.PdsCWScrapItems;

            _journalTrans.JobFinished    = (_termJobStop.FinishedCode == 2) ? 1 : _journalTrans.JobFinished;
            _journalTrans.ErrorSpecification = _journalTrans.ErrorSpecification + _termJobStop.ErrorSpecification;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTeamRegCoAss</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates copies of the current active registrations from a pilot when the worker makes a stop
    /// assistance registration.
    /// </summary>
    /// <param name="origMatched">
    /// true if the original registration is already matched with a <c>JmgTermReg</c> record; otherwise,
    /// false.
    /// </param>
    void createTeamRegCoAss(boolean     origMatched)
    {
        // Copy registrations from a jobpilote when a co-assistant
        // stops the co-assistant function
        JmgTermReg                  teamStart;
        JmgTermReg                  jobPilot;

        if (this.RegType == JmgTermRegType::TeamStop && this.MatchRecIdStartStop && !origMatched)
        {
            select firstonly teamStart order by RegType,Worker,JobActive,RegDateTime
                where teamStart.RecId == this.MatchRecIdStartStop;
            if (teamStart)
            {
                while select jobPilot
                    where jobPilot.RegType          == JmgTermRegType::JobStart
                        && ((jobPilot.Worker        != 0
                        &&  jobPilot.Worker         == teamStart.WorkerPilot)
                        ||  (jobPilot.Worker        == 0
                        &&   jobPilot.WrkCtrIdPilot == teamStart.WrkCtrIdPilot))
                        && jobPilot.JobActive
                        && jobPilot.RegDateTime     <= this.RegDateTime
                {
                    JmgTermJob job = JmgTermJob::construct(this.getAssistantJobId(teamStart.Worker, jobPilot.JobId));
                    this.createAssistantRegistration(teamStart, job, jobPilot);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTeamRegPilote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates copies of the raw registration on workers, which are currently assistants to the worker or
    /// resource that is associated with the <c>JmgTermReg</c> record.
    /// </summary>
    /// <param name="origMatched">
    /// true if the original registration is already matched with a <c>JmgTermReg</c> record; otherwise,
    /// false.
    /// </param>
    void createTeamRegPilote(boolean     origMatched)
    {
        JmgTermReg                  coAssist;
        JmgTermReg                  jobStart;

        // Create registrations on co-assistants when a START reg.
        // is closed with a STOP reg.
        if (this.RegType == JmgTermRegType::JobStop && !this.WorkerPilot && this.MatchRecIdStartStop && !origMatched)
        {
            // Check if employee is a pilot and copy registration to co-assistant
            while select RegDateTime, WorkerPilot, Worker, WrkCtrIdPilot
                from  coAssist
                order by RegDateTime
                where coAssist.RegType          == JmgTermRegType::TeamStart
                    && (coAssist.WorkerPilot    == this.Worker
                    ||  (coAssist.Worker        == 0
                    &&   coAssist.WrkCtrIdPilot == this.WrkCtrIdPilot))
                    && coAssist.JobActive
                    && coAssist.RegDateTime     <= this.RegDateTime
            {
                select firstonly jobStart
                    where jobStart.RecId == this.MatchRecIdStartStop;

                if (jobStart)
                {
                    JmgTermJob job = JmgTermJob::construct(this.getAssistantJobId(coAssist.Worker, this.JobId));
                    this.createAssistantRegistration(coAssist, job, jobStart);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAssistantRegistration</Name>
				<Source><![CDATA[
    private void createAssistantRegistration(JmgTermReg _assistantStartReg, JmgTermJob _job, JmgTermReg _pilotStartReg)
    {
        JmgDateTime startDateTime = _assistantStartReg.RegDateTime >  _pilotStartReg.RegDateTime    ? _assistantStartReg.RegDateTime : _pilotStartReg.RegDateTime;
        JmgSeconds seconds = int642int(DateTimeUtil::getDifference(this.RegDateTime,startDateTime));
                
        JmgRegistrationParameters regParams = this.createRegistrationParametersForAssistant(_job, _assistantStartReg, _pilotStartReg, seconds);

        // Insert START registration on co-assistant
        _job.makeRegistration(_assistantStartReg.Worker, this.getUserPreferredDate(startDateTime),
                                        this.getUserPreferredTime(startDateTime), true, regParams);

        // Insert matching STOP registration on co-assistant
        _job.makeRegistration(_assistantStartReg.Worker, this.getUserPreferredDate(this.RegDateTime),
                                        this.getUserPreferredTime(this.RegDateTime), false, regParams);

        if (!JmgManufacturingExecutionWorkloadConfigurationProvider::isJobDeployedOnSpoke(JmgJobTable::find(_job.jobId())))
        {
            JmgStampJournalTrans jmgStampJournalTrans;

            select forUpdate firstonly jmgStampJournalTrans
                    where jmgStampJournalTrans.Worker       == _assistantStartReg.Worker
                        && jmgStampJournalTrans.JobId       == _job.jobId()
                        && jmgStampJournalTrans.StartDate   == this.getUserPreferredDate(startDateTime)
                        && jmgStampJournalTrans.StartTime   == this.getUserPreferredTime(startDateTime)
                        && jmgStampJournalTrans.StopDate    == this.getUserPreferredDate(this.RegDateTime)
                        && jmgStampJournalTrans.StopTime    == this.getUserPreferredTime(this.RegDateTime);

            if (jmgStampJournalTrans)
            {
                jmgStampJournalTrans.Seconds = seconds;
                jmgStampJournalTrans.update();
            }

            JmgPostStandardSystem jmgPostStandardSystem = JmgPostStandardSystem::construct();
            jmgPostStandardSystem.parmWorker(_assistantStartReg.Worker);
            jmgPostStandardSystem.addJob(_job, regParams, jmgStampJournalTrans);
            jmgPostStandardSystem.postTime();
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>createUpdateJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates registration journal by using the <c>JmgTermReg</c> record.
    /// </summary>
    void createUpdateJournal()
    {
        JmgStampJournalTrans    journalTrans;
        JmgStampJournalTable    jmgStamJournalTable = JmgStampJournalTable::find(this.Worker, this.ProfileDate);

        // Check whether journal line should be created in timecardtrans
        if (JmgEmployee::find(this.Worker).UseTimecard == NoYes::Yes)
        {
            this.createUpdateTimecardTrans();
        }

        if (jmgStamJournalTable && jmgStamJournalTable.Calculated == NoYes::Yes)
        {
            return;
        }

        // Create journalrecord for START signind, and init STOP time and state
        if (this.RegType == JmgTermRegType::JobStart || this.RegType == JmgTermRegType::BrkFlowStart)
        {
            this.createJournalSignIn(this);
        }
        else if (this.RegType == JmgTermRegType::JobStop || this.RegType == JmgTermRegType::BrkFlowStop)
        {
            // if STOP time is matched, init stop time and update finishedQty
            this.journalInitStop(this);
        }
        else if (this.RegType == JmgTermRegType::EventCode)
        {
            this.updateEventCode();
        }
        else
        {
            select firstonly forupdate journalTrans where
                journalTrans.TermRegStartRecID  == this.RecId;

            this.createUpdateJournalInit(journalTrans, this.JobId,this.JobIdAbs);

            journalTrans.Worker             = this.Worker;
            journalTrans.ProfileDate        = this.ProfileDate;
            journalTrans.StartDate          = this.getUserPreferredDate(this.RegDateTime);
            journalTrans.StartTime          = this.getUserPreferredTime(this.RegDateTime);
            journalTrans.JobIDAbs           = this.JobIdAbs;
            journalTrans.WorkerPilot        = this.WorkerPilot;
            journalTrans.WrkCtrIdPilot      = this.WrkCtrIdPilot;
            journalTrans.Active             = this.JobActive;
            journalTrans.WrkCtrId           = this.ResNo;
            journalTrans.JobFinished        = (this.FinishedCode == 2) ? 1 : 0;
            journalTrans.TermRegStartRecID  = this.RecId;
            journalTrans.TermRegStopRecID   = this.RecId;
            journalTrans.StopDate           = this.getUserPreferredDate(this.RegDateTime);
            journalTrans.StopTime           = this.getUserPreferredTime(this.RegDateTime);
            journalTrans.TermStart          = this.TerminalId;
            journalTrans.TermStop           = this.TerminalId;

            // Check for creating planned absence until next clock-in
            this.checkCreatePlannedAbs(journalTrans);

            // Create / Update journal
            journalTrans.write();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createUpdateJournalInit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a journal registration by using the <c>JmgTermReg</c> record.
    /// </summary>
    /// <param name="_journalTrans">
    /// The journal registration that is initialized
    /// </param>
    /// <param name="_jobId">
    /// The job ID that is associated with the journal registration.
    /// </param>
    /// <param name="_absJobId">
    /// The absence job ID that is associated with the journal registration.
    /// </param>
    void createUpdateJournalInit(JmgStampJournalTrans _journalTrans, JmgJobId _jobId, JmgJobId _absJobId)
    {
        if (this.RegType == JmgTermRegType::ClockIn)
        {
            _jobId = JmgIpcActivity::findSignInJobId();
        }
        else if (this.RegType == JmgTermRegType::ClockOut)
        {
            _jobId = JmgIpcActivity::findSignOutJobId();
        }

        _journalTrans.JobId     = _jobId;
        _journalTrans.setJournalTransTypes(JmgTermJob::construct(_jobId).sourceData());
        _journalTrans.JobIDAbs  = _absJobId;
        _journalTrans.OnCallActivity = this.OnCallActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createUpdateTimecardTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates a <c>JmgTimecardTrans</c> table by using the <c>JmgTermReg</c> record.
    /// </summary>
    private void createUpdateTimecardTrans()
    {
        JmgTimecardTrans    jmgTimecardTrans;
        JmgTermReg          matchReg;
        boolean             mustWrite = true;

        switch (this.RegType)
        {
            case JmgTermRegType::JobStart:
            case JmgTermRegType::BrkFlowStart:
                select firstonly matchReg
                    where matchReg.MatchRecIdStartStop == this.RecId;
                jmgTimecardTrans = this.initTimecardTransMatch(matchReg);
                break;
            case JmgTermRegType::JobStop:
            case JmgTermRegType::BrkFlowStop:
                select firstonly matchReg
                    where matchReg.MatchRecIdStartStop == this.RecId;

                if (matchReg)
                {
                    jmgTimecardTrans = matchReg.initTimecardTransMatch(this);
                }
                else
                {
                    // This can happen if the update is as part of the matching after insert of stop registration
                    // where the start registration has not been updated yet.
                    mustWrite = false;
                }
                break;
            case JmgTermRegType::BrkCancelAll:
            case JmgTermRegType::BrkCancelOne:
            case JmgTermRegType::ClockIn:
            case JmgTermRegType::ClockOut:
            case JmgTermRegType::FinishQty:
            case JmgTermRegType::TeamStart:
            case JmgTermRegType::TeamStop:
                jmgTimecardTrans = this.initTimecardTransNoMatch();
                break;
            case JmgTermRegType::EventCode:
                // Handled in createUpdateJournal method.
                break;
            default:
                break;
        }

        if (mustWrite)
        {
            jmgTimecardTrans.write();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a <c>JmgTermReg</c> record from the database.
    /// </summary>
    public void delete()
    {
        JmgTermReg updateJob;

        super();

        // Update Stop/Start MatchRecid
        if (this.RegType == JmgTermRegType::JobStart     ||
            this.RegType == JmgTermRegType::TeamStart    ||
            this.RegType == JmgTermRegType::JobStop      ||
            this.RegType == JmgTermRegType::TeamStop     ||
            this.RegType == JmgTermRegType::BrkFlowStart ||
            this.RegType == JmgTermRegType::BrkFlowStop)
        {
            if (this.MatchRecIdStartStop)
            {
                select firstonly forupdate updateJob
                    where updateJob.RecId == this.MatchRecIdStartStop;

                if (updateJob)
                {
                    updateJob.MatchRecIdStartStop = 0;
                    updateJob.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssistantJobId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the job ID to use on registration, which is copied from a pilot to an assistant.
    /// </summary>
    /// <param name="_assistant">
    /// The ID of the worker currently working as an assistant.
    /// </param>
    /// <param name="_pilotJob">
    /// The job ID that is associated with the pilot registration.
    /// </param>
    /// <returns>
    /// The job ID to use when the assistant registration is created.
    /// </returns>
    private JmgJobId getAssistantJobId(JmgWorkerRecId _assistant, JmgJobId _pilotJob)
    {
        JmgJobId        ret;
        JmgTermJob      pilotJob;
        JmgTermJob_Prod prodJob;
        ProdRoute       pilotOperation;
        ProdRoute       assistantOperation;
        ProdRouteJob    prodRouteJob;
        ProdRouteJob    pilotProdRouteJob;
        ProdRouteJob    assistantProdRouteJob;
        WrkCtrTable     wrkCtrTable;
        pilotJob = JmgTermJob::construct(_pilotJob);
        if (pilotJob.module() == JmgModuleEnum::PROD)
        {
            prodJob = pilotJob;
            if (JmgProdParametersDim::find(prodJob.siteInventDimId()).AssistantsUseSecondaryOperations == NoYes::Yes)
            {
                if (JmgProdParameters::find().StampLevel    == JmgStampLevel::Route)
                {
                    pilotOperation = prodJob.prodRoute();

                    // Find a secondary operation of type Personnel
                    select firstonly assistantOperation
                        order by OprPriority
                        where assistantOperation.ProdId         == pilotOperation.ProdId            &&
                              assistantOperation.OprNum         == pilotOperation.OprNum            &&
                              assistantOperation.OprPriority    != pilotOperation.OprPriority
                        exists join  prodRouteJob
                        where prodRouteJob.ProdId               == assistantOperation.ProdId        &&
                              prodRouteJob.OprNum               == assistantOperation.OprNum        &&
                              prodRouteJob.OprPriority          == assistantOperation.OprPriority
                        exists join  wrkCtrTable
                        where wrkCtrTable.WrkCtrId              == prodRouteJob.WrkCtrId            &&
                              wrkCtrTable.WrkCtrType            == WrkCtrType::Personnel;

                    if (assistantOperation && prodJob.jourRegType() == JmgJourRegTypeEnum::MrpSetup)
                    {
                        ret = assistantOperation.JobIdSetup;
                    }
                    else if (assistantOperation && prodJob.jourRegType() == JmgJourRegTypeEnum::MrpProcess)
                    {
                        ret = assistantOperation.JobIdProcess;
                    }
                }
                else
                {
                    pilotProdRouteJob   = prodJob.prodRouteJob();

                    // Find a secondary operation of type Personnel. Use the secondary job planned on a work center,
                    // which is associated to the assistant. If such a job does not exist, use the job with the highest
                    // priority.
                    while select assistantProdRouteJob
                        order by OprPriority
                        where assistantProdRouteJob.ProdId      == pilotProdRouteJob.ProdId     &&
                              assistantProdRouteJob.OprNum      == pilotProdRouteJob.OprNum     &&
                              assistantProdRouteJob.JobType     == pilotProdRouteJob.JobType    &&
                              assistantProdRouteJob.JobId       != pilotProdRouteJob.JobId
                        join  WrkCtrId, Worker
                        from  wrkCtrTable
                        where wrkCtrTable.WrkCtrId              == assistantProdRouteJob.WrkCtrId
                    {
                        if (!ret)
                        {
                            ret = assistantProdRouteJob.JobId;
                        }
                        else if (wrkCtrTable.Worker             == _assistant)
                        {
                            ret = assistantProdRouteJob.JobId;
                        }
                    }
                }
            }
        }

        if (!ret)
        {
            ret = _pilotJob;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUserPreferredDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the date part of the specified date time value on which the user preferred time zones have
    /// been applied.
    /// </summary>
    /// <param name="_jmgDateTime">
    /// The date time value to retrieve the date from.
    /// </param>
    /// <returns>
    /// The date part of the specified date time value.
    /// </returns>
    private JmgDate getUserPreferredDate(JmgDateTime _jmgDateTime)
    {
        return DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(_jmgDateTime, DateTimeUtil::getUserPreferredTimeZone()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUserPreferredTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the time part of the specified date time value on which the user preferred time zones has
    /// been applied.
    /// </summary>
    /// <param name="_jmgDateTime">
    /// The date time value to retrieve the time from.
    /// </param>
    /// <returns>
    /// The time part of the specified date time value.
    /// </returns>
    private JmgTime getUserPreferredTime(JmgDateTime _jmgDateTime)
    {
        return DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(_jmgDateTime, DateTimeUtil::getUserPreferredTimeZone()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTimecardTransCommon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>JmgTimecardTrans</c> record by using the <c>JmgTermReg</c> record.
    /// </summary>
    /// <param name="_jmgTimecardTrans">
    /// The <c>JmgTimecardTrans</c> record to initialize.
    /// </param>
    /// <remarks>
    /// This method initializes the common fields regardless of the job type.
    /// </remarks>
    private void initTimecardTransCommon(JmgTimecardTrans _jmgTimecardTrans)
    {
        JmgTermJob job;
        job = JmgTermJob::construct(this.JobId);

        _jmgTimecardTrans.Worker        = this.Worker;
        _jmgTimecardTrans.ProfileDate   = this.ProfileDate;
        _jmgTimecardTrans.JobId         = this.JobId;
        _jmgTimecardTrans.JobRef        = job.jobRef();
        _jmgTimecardTrans.JourRegType   = job.jourRegType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTimecardTransMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>JmgTimecardTrans</c> record by using the <c>JmgTermReg</c> record.
    /// </summary>
    /// <param name="_stopReg">
    /// The stop registration record that is used in the initialization.
    /// </param>
    /// <returns>
    /// An initialized <c>JmgTimecardTrans</c> record.
    /// </returns>
    /// <remarks>
    /// This method initializes the fields on timecard transactions in which a matching raw registration is
    /// expected.
    /// </remarks>
    private JmgTimecardTrans initTimecardTransMatch(JmgTermReg _stopReg)
    {
        JmgTimecardTrans jmgTimecardTrans;
        jmgTimecardTrans = JmgTimecardTrans::findTermRegStartRecId(this.RecId, true);

        this.initTimecardTransCommon(jmgTimecardTrans);

        jmgTimecardTrans.StartDateTime      = this.RegDateTime;
        jmgTimecardTrans.JobIDAbs           = this.JobIdAbs;
        jmgTimecardTrans.WorkerPilot        = this.WorkerPilot;
        jmgTimecardTrans.WrkCtrIdPilot      = this.WrkCtrIdPilot;
        jmgTimecardTrans.JobActive          = this.JobActive;
        jmgTimecardTrans.JobFinished        = (this.FinishedCode == 2) ? 1 : 0;
        jmgTimecardTrans.WrkCtrId           = this.ResNo;
        jmgTimecardTrans.TermRegStartRecID  = this.RecId;
        jmgTimecardTrans.TermRegStopRecID   = _stopReg.RecId;
        jmgTimecardTrans.ProjCategory       = this.CostCategory;
        jmgTimecardTrans.OnCallActivity     = this.OnCallActivity;

        if (_stopReg)
        {
            jmgTimecardTrans.StopDateTime       = _stopReg.RegDateTime;
            jmgTimecardTrans.Seconds            = str2int(int642str(DateTimeUtil::getDifference(_stopReg.RegDateTime,this.RegDateTime)));
        }
        else
        {
            jmgTimecardTrans.StopDateTime       = DateTimeUtil::minValue();
            jmgTimecardTrans.Seconds            = 0;
        }
        return jmgTimecardTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTimecardTransNoMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>JmgTimecardTrans</c> record by using the <c>JmgTermReg</c> record.
    /// </summary>
    /// <returns>
    /// An initialized <c>JmgTimecardTrans</c> record.
    /// </returns>
    /// <remarks>
    /// This method initializes the fields on timecard transactions where no matching raw registration is
    /// expected.
    /// </remarks>
    private JmgTimecardTrans initTimecardTransNoMatch()
    {
        JmgTimecardTrans jmgTimecardTrans;
        jmgTimecardTrans = JmgTimecardTrans::findTermRegStartRecId(this.RecId, true);

        this.initTimecardTransCommon(jmgTimecardTrans);

        jmgTimecardTrans.StartDateTime      = this.RegDateTime;
        jmgTimecardTrans.StopDateTime       = this.RegDateTime;
        jmgTimecardTrans.Seconds            = 0;
        jmgTimecardTrans.JobIDAbs           = this.JobIdAbs;
        jmgTimecardTrans.WorkerPilot        = this.WorkerPilot;
        jmgTimecardTrans.WrkCtrIdPilot      = this.WrkCtrIdPilot;
        jmgTimecardTrans.JobActive          = this.JobActive;
        jmgTimecardTrans.JobFinished        = (this.FinishedCode == 2) ? 1 : 0;
        jmgTimecardTrans.WrkCtrId           = this.ResNo;
        jmgTimecardTrans.TermRegStartRecID  = this.RecId;
        jmgTimecardTrans.TermRegStopRecID   = this.RecId;
        jmgTimecardTrans.ProjCategory       = this.CostCategory;
        jmgTimecardTrans.OnCallActivity     = this.OnCallActivity;

        return jmgTimecardTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();

        this.GoodItems              = 0;
        this.ScrapItems             = 0;
        this.Error                  = NoYesCombo::No;
        this.ErrorTxt               = '';
        this.FinishedCode           = 0;
        this.JobActive              = NoYes::No;
        this.MatchRecIdStartStop    = 0;
        this.TmpGoodItems           = 0;
        this.TmpScrapItems          = 0;
        this.TmpStartItems          = 0;
        this.StartItems             = 0;
        this.ErrorSpecification     = '';

        this.PdsCWGoodItems         = 0;
        this.PdsCWScrapItems        = 0;
        this.PdsCWStartItems        = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a <c>JmgTermReg</c> record in the database.
    /// </summary>
    /// <remarks>
    /// During insertion the <c>JmgTermReg</c> record is matched to another <c>JmgTermReg</c> record
    /// and a journal registration is created.
    /// </remarks>
    public void insert()
    {
        this.preProcessRegistrationMatch();

        this.setQtyError();

        super();

        if (this.RegType == JmgTermRegType::ClockIn)
        {
            this.assignProfileDate();
            this.stopPlannedAbsence();
        }
        else
        {
            this.matchRegistrations();
        }

        if (this.mustCreateUpdateJournalWithManufacturingExecutionWorkloadEnabled())
        {
            this.createUpdateJournal();
        }
        // SaveTeams : activateAssistance
        JmgAssistance::activateAssistance(this);

        this.updateJmgJobReportedFinished();
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the description of the job that is associated with the <c>JmgTermReg</c> record.
    /// </summary>
    /// <returns>
    /// The description of the job that is associated with the <c>JmgTermReg</c> record.
    /// </returns>
    public display JmgDescription jobDescription()
    {
        JmgTermJob  termjob = JmgTermJob::construct(this.JobId);
        return termjob.jobDescription();
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the reference ID of the job that is associated with the <c>JmgTermReg</c> record.
    /// </summary>
    /// <returns>
    /// The reference ID of the job that is associated with the <c>JmgTermReg</c> record.
    /// </returns>
    public display JmgJobRef jobRef()
    {
        JmgTermJob  termjob = JmgTermJob::construct(this.JobId);
        return termjob.jobRef();
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalInitStop</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a journal registration based on the <c>JmgTermReg</c> record.
    /// </summary>
    /// <param name="_termReg">
    /// The <c>JmgTermReg</c> record for which a journal registration is created.
    /// </param>
    void journalInitStop(JmgTermReg _termReg)
    {
        // if STOP time is matched, init stop time and update finishedQty
        JmgStampJournalTrans    journalRefStart;
        JmgTermReg              termJobStart;

        if (_termReg.MatchRecIdStartStop)
        {
            select firstonly termJobStart where
                termJobStart.RecId == _termReg.MatchRecIdStartStop;

            if (termJobStart)
            {
                select  forupdate firstonly journalRefStart where
                    journalRefStart.TermRegStartRecID == termJobStart.RecId;

                if (journalRefStart)
                {
                    journalRefStart.Active      = termJobStart.JobActive;
                    journalRefStart.StopDate    = this.getUserPreferredDate(_termReg.RegDateTime);
                    journalRefStart.StopTime    = this.getUserPreferredTime(_termReg.RegDateTime);

                    // set good, Error and finished code from start stamp                    
                    journalRefStart.QtyGood     = termJobStart.GoodItems;
                    journalRefStart.QtyError    = termJobStart.ScrapItems;                    
                    journalRefStart.PdsCWQtyGood     = termJobStart.PdsCWGoodItems;
                    journalRefStart.PdsCWQtyError    = termJobStart.PdsCWScrapItems;
                    journalRefStart.JobFinished = (termJobStart.FinishedCode == 2) ? 1 : 0;
                    journalRefStart.ErrorSpecification = termJobStart.ErrorSpecification;

                    // set good, Error and finished code from stop stamp

                    journalRefStart.QtyGood    += _termReg.GoodItems;
                    journalRefStart.QtyError   += _termReg.ScrapItems;
                    journalRefStart.PdsCWQtyGood    += _termReg.PdsCWGoodItems;
                    journalRefStart.PdsCWQtyError   += _termReg.PdsCWScrapItems;

                    journalRefStart.JobFinished = (_termReg.FinishedCode == 2) ? 1 : journalRefStart.JobFinished;
                    journalRefStart.ErrorSpecification = journalRefStart.ErrorSpecification + _termReg.ErrorSpecification;
                    journalRefStart.TermStop    = _termReg.TerminalId;

                    journalRefStart.write();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchingStopTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves date and time of the matching stop job.
    /// </summary>
    /// <returns>
    /// The matching end date and time.
    /// </returns>
    public display EndDateTime matchingStopTime()
    {
        JmgTermReg termReg;
        select RegDateTime from termReg where termReg.RecId == this.MatchRecIdStartStop
            && (termReg.RegType == JmgTermRegType::JobStop ||
                termReg.RegType == JmgTermRegType::TeamStop ||
                termReg.RegType == JmgTermRegType::BrkFlowStop ||
                termReg.RegType == JmgTermRegType::ClockOut);

        return termReg.RegDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchRegistrations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Matches registrations with when <c>JmgTermReg</c> records are inserted.
    /// </summary>
    /// <remarks>
    /// Start job registrations are matched to stop job registrations.Start break registrations are matched
    /// to stop break registrations.Start team registrations are matched to stop team registrations.Other
    /// types of registrations are not matched.
    /// </remarks>
    private void matchRegistrations()
    {
        JmgTermReg      commonJob,startJob,stopJob;
        JmgDateTime     dbMatchLoopFromDateTime;
        JmgDateTime     dbMatchLoopToDateTime;
        JmgTermRegType  dbMatchLoopRegType;
        JmgJobId        dbMatchLoopRegJobID;
        JmgJobId        dbMatchLoopRegJobIDTeamStop;
        JmgJobId        dbMatchLoopRegJobIDBreakStop;

        ttsbegin;
        dbMatchLoopRegJobIDTeamStop     = JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StopTeam);
        dbMatchLoopRegJobIDBreakStop    = JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StopBreak);

        if (this.RegType    == JmgTermRegType::JobStart
            || this.RegType == JmgTermRegType::JobStop
            || this.RegType == JmgTermRegType::TeamStart
            || this.RegType == JmgTermRegType::TeamStop
            || this.RegType == JmgTermRegType::BrkFlowStart
            || this.RegType == JmgTermRegType::BrkFlowStop)
        {
            if (this.Worker)
            {
                // Set search limits - search from latest ClockOut registration
                select firstonly RegDateTime
                    from  commonJob
                    order by RegDateTime desc
                    where commonJob.Worker          == this.Worker
                        && commonJob.RegType        == JmgTermRegType::ClockOut
                        && commonJob.RegDateTime    <= this.RegDateTime;
            }
            else
            {
                // Set search limits - search from first active registration
                select firstonly RegDateTime
                    from  commonJob
                    order by RegDateTime asc
                    where commonJob.WrkCtrIdPilot   == this.WrkCtrIdPilot
                        && commonJob.JobActive      == NoYes::Yes;
            }
            dbMatchLoopFromDateTime = commonJob.RegDateTime;

            // Set search limits - search to ??
            dbMatchLoopToDateTime = DateTimeUtil::maxValue();

            // Now loop and match all JOB START and CO-ASSISTENT START registrations
            while select forupdate startJob  order by RegDateTime,RegType
                where (startJob.Worker          == this.Worker
                    || (startJob.Worker         == 0
                    &&  startJob.WrkCtrIdPilot  == this.WrkCtrIdPilot))
                    && startJob.RegDateTime     >= dbMatchLoopFromDateTime
                    && startJob.RegDateTime     <= dbMatchLoopToDateTime
                    && (startJob.RegType        == JmgTermRegType::JobStart
                    ||  startJob.RegType        == JmgTermRegType::TeamStart
                    ||  startJob.RegType        == JmgTermRegType::BrkFlowStart)
            {
                // Set search parameters for search of STOP registrations
                dbMatchLoopRegType  = (startJob.RegType == JmgTermRegType::JobStart) ? JmgTermRegType::JobStop  :
                                      (startJob.RegType == JmgTermRegType::TeamStart) ? JmgTermRegType::TeamStop : JmgTermRegType::BrkFlowStop;

                dbMatchLoopRegJobID = (startJob.RegType == JmgTermRegType::JobStart) ? startJob.JobId :
                                      (startJob.RegType == JmgTermRegType::TeamStart)? dbMatchLoopRegJobIDTeamStop : dbMatchLoopRegJobIDBreakStop;

                // Search STOP registrations and optimize and perform match
                while select forupdate stopJob order by RegDateTime
                    where (stopJob.Worker           == startJob.Worker
                        || (stopJob.Worker          == 0
                        &&  stopJob.WrkCtrIdPilot   == startJob.WrkCtrIdPilot))
                        && stopJob.RegType          == dbMatchLoopRegType
                        && stopJob.JobId            == dbMatchLoopRegJobID
                        && stopJob.RegDateTime      >= startJob.RegDateTime
                {
                    // If matched already then BREAK loop
                    if (stopJob.MatchRecIdStartStop == startJob.RecId && stopJob.RecId == startJob.MatchRecIdStartStop)
                    {
                        break;
                    }
                    else
                    {
                        // If stop not matched then perform match
                        if (stopJob.MatchRecIdStartStop == 0)
                        {
                            if (startJob.MatchRecIdStartStop)
                            {
                                select firstonly forupdate commonJob
                                    where commonJob.RecId == startJob.MatchRecIdStartStop;
                                if (commonJob)
                                {
                                    commonJob.MatchRecIdStartStop = 0;
                                    commonJob.update();
                                }
                            }
                            stopJob.MatchRecIdStartStop = startJob.RecId;
                            startJob.MatchRecIdStartStop = stopJob.RecId;
                            stopJob.update();
                            startJob.update();
                            break;
                        }
                        else
                        {
                            // If stop already matched then test match and perform new match
                            select firstonly forupdate commonJob
                                where commonJob.RecId == stopJob.MatchRecIdStartStop;

                            if (commonJob && commonJob.RegDateTime > startJob.RegDateTime)
                            {
                                commonJob.MatchRecIdStartStop = 0;
                                commonJob.update();
                                stopJob.MatchRecIdStartStop  = startJob.RecId;
                                startJob.MatchRecIdStartStop = stopJob.RecId;
                                stopJob.update();
                                startJob.update();
                                break;
                            }
                        }
                    }
                }
                //while Stop job
            }
            // while startJob
        }
        ttscommit;

        if (FormDataUtil::getFormDataSource(this))
        {
            commonJob.data(this);
            FormDataUtil::getFormDataSource(this).research();
            FormDataUtil::getFormDataSource(this).findRecord(commonJob);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pilotName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the name of the pilot that is associated with the <c>JmgTermReg</c> record.
    /// </summary>
    /// <returns>
    /// The name of the pilot that is associated with the <c>JmgTermReg</c> record.
    /// </returns>
    public display DirPartyName pilotName()
    {
        return HcmWorker::worker2Name(this.WorkerPilot);
    }

]]></Source>
			</Method>
			<Method>
				<Name>preProcessRegistrationMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values on matching registrations.
    /// </summary>
    void preProcessRegistrationMatch()
    {
        JmgProfileSeconds   profileSec = new JmgProfileSeconds();

        JmgTermReg          termReg;
        JmgTermReg          termRegAssistance;
        JmgAssistance       jmgAssistance;

        if (this.JobId == '0')
            this.JobId = '';

        if (this.JobIdAbs == '0')
            this.JobIdAbs = '';

        // Set active code on the registration
        if (this.RegType == JmgTermRegType::JobStart || this.RegType == JmgTermRegType::TeamStart || this.RegType == JmgTermRegType::BrkFlowStart)
        {
            this.JobActive = this.MatchRecIdStartStop ? 0 : 1;
        }
        else
        {
            this.JobActive = 0;
        }

        // When a ClockIn registration is inserted - perform AutoProfileSearch
        if (! this.RecId)
        {
            if (!this.ProfileDate)
            {
                this.ProfileDate = JmgTermReg::calcProfileDate(this.RegType,JmgEmployee::find(this.Worker),this.RegDateTime);
            }

            if (this.RegType != JmgTermRegType::ClockIn)
            {
                // If JobStart registration - set WorkCenter
                if (this.RegType == JmgTermRegType::JobStart)
                {
                    this.ResNo = JmgJobTable::find(this.JobId).WrkCtrId;
                }

                // At clock-out stop jobs that haven't been stopped by a STOP registration
                if (this.RegType == JmgTermRegType::ClockOut)
                {
                    while select termReg order by JobActive, FinishedCode
                        where (termReg.Worker           == this.Worker
                            || (termReg.Worker          == 0
                            &&  termReg.WrkCtrIdPilot   == this.WrkCtrIdPilot))
                            && termReg.JobActive        == NoYes::Yes
                            && termReg.RegDateTime      <= this.RegDateTime
                            && (termReg.RegType         == JmgTermRegType::JobStart
                            ||  termReg.RegType         == JmgTermRegType::TeamStart
                            ||  termReg.RegType         == JmgTermRegType::BrkFlowStart)
                    {
                        termReg.RecId   = 0;
                        termReg.ProfileDate = dateNull();
                        termReg.RegDateTime = this.RegDateTime;

                        switch (termReg.RegType)
                        {
                            case JmgTermRegType::TeamStart:
                                termReg.RegType = JmgTermRegType::TeamStop;
                                termReg.RegDateTime = this.RegDateTime;
                                termReg.JobId   = JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StopTeam);
                                break;

                            case JmgTermRegType::BrkFlowStart:
                                termReg.RegType     = JmgTermRegType::BrkFlowStop;
                                termReg.JobId       = JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StopBreak);
                                break;

                            default:
                                termReg.RegType             = JmgTermRegType::JobStop;
                                termReg.GoodItems           = 0;
                                termReg.ScrapItems          = 0;
                                termReg.PdsCWGoodItems      = 0;
                                termReg.PdsCWScrapItems     = 0;
                                termReg.FinishedCode        = 1; // {No}
                                termReg.TmpGoodItems        = 0;
                                termReg.TmpScrapItems       = 0;
                                break;
                        }

                        termReg.insert();
                    }
                    // while termReg

                    // SaveTeams : If employee is pilot insert StopTeam on co-assistants
                    while select termRegAssistance
                        where termRegAssistance.RegType         == JmgTermRegType::TeamStart
                            && termRegAssistance.WorkerPilot    == this.Worker
                            && termRegAssistance.JobActive      == NoYes::Yes
                            && termRegAssistance.RegDateTime    <= this.RegDateTime
                    {
                        termRegAssistance.RegType   = JmgTermRegType::TeamStop;
                        termRegAssistance.RegDateTime = this.RegDateTime;
                        termRegAssistance.JobId     = JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StopTeam);
                        termRegAssistance.insert();
                    }
                    // SaveTeams : Delete teams if employee has broken out of team
                    select firstonly RegType from termRegAssistance
                        order RegDateTime desc, RegType desc
                        where termRegAssistance.Worker          == this.Worker
                            && termRegAssistance.RegDateTime    <= this.RegDateTime
                            && termRegAssistance.RegType        <  JmgTermRegType::BrkFlowStop;

                    if (termRegAssistance
                        && termRegAssistance.RegType    != JmgTermRegType::TeamStart
                        && termRegAssistance.RegType    != JmgTermRegType::TeamStop)
                    {
                        delete_from jmgAssistance
                                where jmgAssistance.WorkerAssistant == this.Worker;
                    }
                }
            }
            //else
        }
        // if (this.recid)
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total reported error quantity for the job that is associated with the
    /// <c>JmgTermReg</c> record.
    /// </summary>
    /// <returns>
    /// The total reported error quantity for the job that is associated with the <c>JmgTermReg</c> record.
    /// </returns>
    public display ProdReportedError qtyError()
    {
        return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateErrorQty(this.JobId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyGood</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total reported good quantity for the job that is associated with the
    /// <c>JmgTermReg</c> record.
    /// </summary>
    /// <returns>
    /// The total reported good quantity for the job that is associated with the <c>JmgTermReg</c> record.
    /// </returns>
    public display ProdReportedGood qtyGood()
    {
        return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateGoodQty(this.JobId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQtyError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>ScrapItems</c> and <c>PdsCWScrapItems</c> fields based on the value of the <c>ErrorSpecification</c> field.
    /// </summary>
    private void setQtyError()
    {
        this.ScrapItems = JmgErrorSpecificationForm::getTotalErrorQuantity(this.ErrorSpecification);
        this.PdsCWScrapItems = JmgErrorSpecificationForm::getTotalPdsCWErrorQuantity(this.ErrorSpecification);
    }

]]></Source>
			</Method>
			<Method>
				<Name>stopPlannedAbsence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stops the planned absence of a worker when the worker clocks in.
    /// </summary>
    private void stopPlannedAbsence()
    {
        JmgAbsenceCalendar absenceCalendar;

        select firstonly forupdate absenceCalendar
            where absenceCalendar.FromDateTime      <= this.RegDateTime &&
                  absenceCalendar.ToDateTime        >= this.RegDateTime &&
                  absenceCalendar.Worker            == this.Worker  &&
                  absenceCalendar.Disabled          == NoYes::No    &&
                  absenceCalendar.DisableAtSigning  == NoYes::Yes;

        if (absenceCalendar)
        {
            absenceCalendar.Disabled = NoYes::Yes;
            absenceCalendar.ToDateTime   = this.RegDateTime;
            absenceCalendar.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>termregrecid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the Record id of the <c>JmgTermReg</c> record.
    /// </summary>
    /// <returns>
    /// the Record id of the <c>JmgTermReg</c> record.
    /// </returns>
    public display JmgRecId termregrecid()
    {
        return (0+this.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>JmgTermReg</c> record in the database.
    /// </summary>
    /// <remarks>
    /// Registrations are matched and the associated journal registrations are updated when a
    /// <c>JmgTermReg</c> record is updated.
    /// </remarks>
    public void update()
    {
        boolean     origMatched = (this.orig().MatchRecIdStartStop != 0);
        boolean     origActive  = (this.orig().JobActive == NoYes::Yes);

        this.TmpStartItems      = this.StartItems - this.orig().StartItems;
        this.TmpPdsCWStartItems = this.PdsCWStartItems - this.orig().PdsCWStartItems;

        this.preProcessRegistrationMatch();

        if (this.ErrorSpecification != this.orig().ErrorSpecification)
        {
            this.setQtyError();
        }

        super();

        if (this.mustCreateUpdateJournalWithManufacturingExecutionWorkloadEnabled())
        {
			this.createUpdateJournal();
		}

        this.createTeamRegPilote(origMatched);
        this.createTeamRegCoAss(origMatched);

        // SaveTeams : deactivateAssistance
        JmgAssistance::deactivateAssistance(this,origActive);

        this.updateJmgJobReportedFinished();

        if (FormDataUtil::getFormDataSource(this))
        {
            FormDataUtil::getFormDataSource(this).research();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateUpdateJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if registration journal must be created/updated.
    /// </summary>
    /// <returns>true if registration journal should be created; otherwise, false.</returns>
    protected boolean mustCreateUpdateJournal()
    {
        return this.Worker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateUpdateJournalManufacturingExecution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if registration journal must be created/updated for <c>JmgTermRegPostSyncProcessor</c>.
    /// </summary>
    /// <returns>true if registration journal should be created; otherwise, false.</returns>
    internal boolean mustCreateUpdateJournalManufacturingExecution()
    {
        return this.mustCreateUpdateJournal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateUpdateJournalWithManufacturingExecutionWorkloadEnabled</Name>
				<Source><![CDATA[
    private boolean mustCreateUpdateJournalWithManufacturingExecutionWorkloadEnabled()
    {
        return this.mustCreateUpdateJournal() && !JmgManufacturingExecutionWorkloadConfigurationProvider::isJobDeployedOnSpoke(JmgJobTable::find(this.JobId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasJobRegistrationError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if registration has an error.
    /// </summary>
    public boolean hasJobRegistrationError()
    {
        return this.ScrapItems || this.PdsCWScrapItems;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEventCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates a switch code journal registration.
    /// </summary>
    void updateEventCode()
    {
        JmgEventCtrl jmgEventCtrl;

        if (this.RegType == JmgTermRegType::EventCode)
        {
            select forupdate jmgEventCtrl where jmgEventCtrl.TermRegRecID == this.RecId;
            jmgEventCtrl.EventCode      = JmgIpcActivity::findJobId(this.JobId).Activity;
            jmgEventCtrl.Worker         = this.Worker;
            jmgEventCtrl.ProfileDate    = this.ProfileDate;
            jmgEventCtrl.TerminalId     = this.TerminalId;
            jmgEventCtrl.TermRegRecID   = this.RecId;
            if (jmgEventCtrl.Worker && jmgEventCtrl.EventCode && jmgEventCtrl.ProfileDate)
            {
                jmgEventCtrl.write();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJmgJobReportedFinished</Name>
				<Source><![CDATA[
    private void updateJmgJobReportedFinished()
    {
        if (JmgManufacturingExecutionWorkloadConfigurationProvider::isJobDeployedOnSpoke(JmgJobTable::find(this.JobId)) &&
            this.RegType == JmgTermRegType::JobStop &&
            this.FinishedCode == 2 &&
            this.MatchRecIdStartStop)
        {
            JmgJobTable::updateReportedFinished(this.JobId, true);
        }
        else
        {
            JmgTermReg  jmgTermReg;

            if (this.RegType == JmgTermRegType::JobStop &&
            !this.Worker &&
            this.FinishedCode == 2 &&
            this.MatchRecIdStartStop)
            {
                select Worker, WorkerPilot, WrkCtrIdPilot from jmgTermReg where
                   jmgTermReg.RecId == this.MatchRecIdStartStop;

                if (jmgTermReg.RecId &&
                !jmgTermReg.Worker &&
                !jmgTermReg.WorkerPilot &&
                jmgTermReg.WrkCtrIdPilot)
                {
                    // Resource assist job gets finished, we need to set the
                    // finished flag on the original job manually.
                    JmgJobTable::updateReportedFinished(this.JobId, true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcProfileDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the profile date, which will be assigned to registrations made by the specified worker
    /// at the specified time.
    /// </summary>
    /// <param name="_regType">
    /// The type of registration for which to calculate the profile date.
    /// </param>
    /// <param name="_emplTbl">
    /// The worker who is making the registration.
    /// </param>
    /// <param name="_regDateTime">
    /// The date and time of the registration.
    /// </param>
    /// <returns>
    /// The calculated profile date to assign to the registration.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// No profile can be found for the specified worker.
    /// </exception>
    static JmgProfileDate calcProfileDate(JmgTermRegType _regType, JmgEmployee _emplTbl, utcdatetime _regDateTime)
    {
        JmgProfileDay   jmgProfileDay;
        JmgProfileDate  ret;
        JmgTermReg      termReg;
        JmgTermReg      termRegClockIn;
        JmgTermReg      termRegClockOut;
        JmgDate         regDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(_regDateTime,DateTimeUtil::getUserPreferredTimeZone()));
        JmgTime         regTime = DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(_regDateTime,DateTimeUtil::getUserPreferredTimeZone()));

        if (!isConfigurationkeyEnabled(configurationKeyNum(Jmg)))
        {
            return DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        if (_regType == JmgTermRegType::ClockIn)
        {
            jmgProfileDay   = JmgProfileDay::find(_emplTbl.profileId(regDate, regTime),
                                                  JmgProfiles::date2DayId(regDate));
            if (!jmgProfileDay)
                throw error(strFmt("@SYS38525",HcmWorker::find(_emplTbl.Worker).PersonnelNumber));

            if (jmgProfileDay.StartTime
                && jmgProfileDay.StartTime      <= regTime
                && jmgProfileDay.PushProfile    == NoYes::No)
            {
                ret = regDate + 1;
            }
            else if (jmgProfileDay.StartTime
                && jmgProfileDay.StartTime      >= regTime
                && jmgProfileDay.PushProfile    == NoYes::Yes)
            {
                ret = regDate - 1;
            }
            else
            {
                ret = regDate;
            }
        }
        else
        {
            select maxof(ProfileDate) from termReg
                    where termReg.Worker        == _emplTbl.Worker
                        && termReg.RegType      == JmgTermRegType::ClockIn
                        && termReg.RegDateTime  <= _regDateTime;
            if (termReg)
            {
                select maxof(RegDateTime) from termRegClockIn
                    where termRegClockIn.Worker         == _emplTbl.Worker
                        && termRegClockIn.RegType       == JmgTermRegType::ClockIn
                        && termRegClockIn.ProfileDate   == termReg.ProfileDate;
            }
            if (termReg && termRegClockIn)
            {
                // try to find the last clockout after the last clockin
                select maxof(ProfileDate) from termRegClockOut
                    where termRegClockOut.Worker        == _emplTbl.Worker
                        && termRegClockOut.RegType      == JmgTermRegType::ClockOut
                        && termRegClockOut.RegDateTime  >= termRegClockIn.RegDateTime
                        && termRegClockOut.RegDateTime  <= _regDateTime;
                if (termRegClockOut)
                    ret = regDate;
                else
                    ret = termReg.ProfileDate;
            }
            else
            {
                ret = regDate;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurSignInTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the current clock in time for the specified worker
    /// </summary>
    /// <param name="_worker">
    /// The ID of the worker to retrieve the clock in time for.
    /// </param>
    /// </param>
    /// <param name="_sysDateTime">
    /// The system datetime.
    /// <returns>
    /// the current clock in time for the specified worker.
    /// </returns>
    /// <remarks>
    /// If the worker is not currently clocked in, 0 is returned.
    /// </remarks>
    static JmgSeconds getCurSignInTime(JmgWorkerRecId _worker, utcdatetime _sysDateTime = utcDateTimeNull())
    {
        JmgSeconds  ret;

        JmgDateTime signInDateTime = JmgTermReg::getCurSignInUTCTime(_worker, _sysDateTime);

        if (!signInDateTime)
        {
            ret = 0;
        }
        else
        {
            ret = new JmgProfileSeconds(DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(signInDateTime,DateTimeUtil::getUserPreferredTimeZone())),
                                        DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(signInDateTime,DateTimeUtil::getUserPreferredTimeZone()))).profileSeconds();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurSignInUTCTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the current clock-in time for the specified worker.
    ///     Note: If JmgParameters.GetRegistration is set to JmgGetRegistrationTimeFrom::AOSServer
    ///     then this method does not return a UTC value but legal entity time with the user preferred time zone removed.
    /// </summary>
    /// <param name="_worker">
    ///     The ID of the worker to check.
    /// </param>
    /// <param name="_sysDateTime">
    ///     The system datetime.
    /// </param>
    /// <returns>
    ///     An utcDateTime value or 0 if the worker is not clocked in.
    /// </returns>
    static utcDateTime getCurSignInUTCTime(JmgWorkerRecId _worker, utcdatetime _sysDateTime = utcDateTimeNull())
    {
        JmgDateTime currentTime = _sysDateTime == utcDateTimeNull() ?
            JmgProfileSeconds::getJmgTermRegCurrentTime() :
            DateTimeUtil::removeTimeZoneOffset(_sysDateTime, DateTimeUtil::getUserPreferredTimeZone());

        JmgDateTime signInDateTime  = (select maxof(RegDateTime) from jmgTermReg
                                            where jmgTermReg.Worker     == _worker                  &&
                                                jmgTermReg.RegType      == JmgTermRegType::ClockIn  &&
                                                jmgTermReg.RegDateTime  <= currentTime).RegDateTime;

        JmgDateTime signOutDateTime = (select maxof(RegDateTime) from jmgTermReg
                                            where jmgTermReg.Worker     == _worker                  &&
                                                jmgTermReg.RegType      == JmgTermRegType::ClockOut &&
                                                jmgTermReg.RegDateTime  <= currentTime).RegDateTime;

        utcDateTime ret;
        if (signInDateTime > signOutDateTime)
        {
            ret = signInDateTime;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleStartStart</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and updates <c>JmgTermReg</c> records to perform rematching of records when registrations
    /// are not inserted in date and time sequence.
    /// </summary>
    /// <param name="_jmgTermReg">
    /// The <c>JmgTermReg</c> record to insert.
    /// </param>
    public static void handleStartStart(JmgTermReg _jmgTermReg)
    {
        JmgTermReg previousStartReg;
        JmgTermReg stopReg;
        if (JmgParameters::find().TerminalInsertMode == JmgTerminalInsertMode::StartStart &&
            (_jmgTermReg.RegType == JmgTermRegType::JobStart ||
             _jmgTermReg.RegType == JmgTermRegType::TeamStart) )
        {
            // Find previous started jobs/teams/breaks for the employee in JmgTermReg,
            // and insert a matching stop registrations.
            ttsbegin;
            while select Worker, RegType, JobId, JobIdAbs, WorkerPilot, WrkCtrIdPilot, FinishedCode
                from  previousStartReg
                where previousStartReg.Worker   == _jmgTermReg.Worker &&
                      (previousStartReg.RegType == JmgTermRegType::JobStart ||
                       previousStartReg.RegType == JmgTermRegType::BrkFlowStart ||
                       previousStartReg.RegType == JmgTermRegType::TeamStart) &&
                      previousStartReg.RegDateTime < _jmgTermReg.RegDateTime &&
                      previousStartReg.JobActive == NoYes::Yes
            {
                // Set common values
                stopReg.clear();
                stopReg.initValue();
                stopReg.Worker = previousStartReg.Worker;
                stopReg.RegDateTime = _jmgTermReg.RegDateTime;

                // Set type dependant fields:
                switch (previousStartReg.RegType)
                {
                    case JmgTermRegType::JobStart:
                        // Create matching job stop reg.
                        stopReg.RegType = JmgTermRegType::JobStop;
                        stopReg.JobId = previousStartReg.JobId;
                        stopReg.JobIdAbs = previousStartReg.JobIdAbs;
                        stopReg.WorkerPilot = previousStartReg.WorkerPilot;
                        stopReg.WrkCtrIdPilot = previousStartReg.WrkCtrIdPilot;
                        stopReg.StartItems = 0; // Always 0 on JobStop registrations
                        stopReg.GoodItems = _jmgTermReg.GoodItems;
                        stopReg.ScrapItems = _jmgTermReg.ScrapItems;
                        stopReg.PdsCWStartItems = 0;
                        stopReg.PdsCWGoodItems  = _jmgTermReg.PdsCWGoodItems;
                        stopReg.ErrorSpecification = _jmgTermReg.ErrorSpecification;

                        stopReg.FinishedCode = previousStartReg.FinishedCode;

                        // GoodItems and ScrapItems should always be 0 on JobStart registrations.
                        // (Handling of Start/Start mode with quantity feedback.)
                        _jmgTermReg.GoodItems = 0;
                        _jmgTermReg.ScrapItems = 0;

                        _jmgTermReg.PdsCWGoodItems = 0;
                        _jmgTermReg.PdsCWScrapItems = 0;
                        _jmgTermReg.ErrorSpecification = '';

                        break;
                    case JmgTermRegType::BrkFlowStart:
                        // Create break stop reg
                        stopReg.RegType = JmgTermRegType::BrkFlowStop;
                        stopReg.JobId = JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StopBreak);
                        break;
                    case JmgTermRegType::TeamStart:
                        // Create team stop reg
                        stopReg.RegType = JmgTermRegType::TeamStop;
                        stopReg.JobId = JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StopTeam);
                        break;
                }
                // Insert the stop registration
                stopReg.insert();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>JmgTermReg</c> table.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the <c>JmgTermReg</c> table to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>JmgTermReg</c> table; otherwise, an empty record.
    /// </returns>
    public static JmgTermReg find(
        RecId   _recId,
        boolean _forUpdate = false)
    {
        JmgTermReg jmgTermReg;

        if (_recId)
        {
            jmgTermReg.selectForUpdate(_forUpdate);

            select firstonly jmgTermReg
                where jmgTermReg.RecId == _recId;
        }

        return jmgTermReg;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTeamJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Update the seconds of the team registration lines with the specified allocation ratio.
    /// </summary>
    /// <param name="_ratio">
    ///  The allocation ratio value. Optional; default value is 1.
    /// </param>
    public void updateTeamJournal(real _ratio = 1)
    {
        if (this.MatchRecIdStartStop
            && (this.RegType == JmgTermRegType::TeamStop || (this.RegType == JmgTermRegType::JobStop && !this.WorkerPilot)))
        {
            this.updateJmgStampJournalTrans(this.RegType, _ratio);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFeedbackData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates feedback data in the record.
    /// </summary>
    /// <param name = "_registrationParameters">
    /// An instance of the <c>JmgRegistrationParameters</c> class that contains feedback data.
    /// </param>
    [Wrappable(true)]
    internal void updateFeedbackData(JmgRegistrationParameters _registrationParameters)
    {
        this.GoodItems = _registrationParameters.goodQuantity();
        this.PdsCWGoodItems = _registrationParameters.pdsCWGoodQuantity();
        this.ErrorSpecification = _registrationParameters.errorSpecification();
        this.FinishedCode = (_registrationParameters.reportAsFinished() == JmgFeedbackStatus::Completed ? 2 : 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSeconds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the time consumption in seconds in the record.
    /// </summary>
    /// <param name = "_seconds">
    /// Value to be updated in the record.
    /// </param>
    [Wrappable(true)]
    internal void updateSeconds(JmgSeconds _seconds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRegistrationParametersForAssistant</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>JmgRegistrationParameters</c> class for the assistant.
    /// </summary>
    /// <param name = "_job">
    /// An instance of <c>JmgTermJob</c> created for the job.
    /// </param>
    /// <param name = "_teamStartReg">
    /// The start registration record for the team.
    /// </param>
    /// <param name = "_pilotStartReg">
    /// The start registration record for the pilot.
    /// </param>
    /// <param name = "_seconds">
    /// Time in seconds to be assigned to the parameters.
    /// </param>
    /// <returns>
    /// An instance of <c>JmgRegistrationParameters</c>.
    /// </returns>
    [Wrappable(true)]
    internal JmgRegistrationParameters createRegistrationParametersForAssistant(JmgTermJob _job, JmgTermReg _teamStartReg, JmgTermReg _pilotStartReg, JmgSeconds _seconds)
    {
        JmgRegistrationParameters regParams = _job.module() == JmgModuleEnum::PROJ  ? JmgRegistrationParameters::newFromJmgTermReg(_pilotStartReg) : new JmgRegistrationParameters();
        regParams.jobPilot(_teamStartReg.WorkerPilot);
        regParams.parmWrkCtrIdPilot(_teamStartReg.WrkCtrIdPilot);

        return regParams;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJmgStampJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Update registration lines with the specified ratio for a kind of registration type.
    /// </summary>
    /// <param name="_regType">
    ///  The registration type of the lines which will be updated.
    /// </param>
    /// <param name="_ratio">
    ///  The allocation ratio value. Optional; default value is 1.
    /// </param>
    private void updateJmgStampJournalTrans(JmgTermRegType  _regType,
                                            real            _ratio = 1)

    {
        JmgStampJournalTrans        jmgStampJournalTrans;
        JmgTermReg                  jmgTermReg;
        JmgDateTime                 startDateTime;
        jmgTermReg                  startJmgTermReg;
        Set                         touchJmgStampJournalTable = new Set(Types::Container);
        SetEnumerator               setEnumerator;
        JmgWorkerRecId              workerLocal;
        JmgProfileDate              profileDateLocal;
        JmgWorkerRecId              workerId;
        JmgJobId                    jobId;

        if (_regType != JmgTermRegType::TeamStop && _regType != JmgTermRegType::JobStop)
        {
            return;
        }

        // Find the match start JmgTermReg record.
        select firstOnly RegDateTime, Worker, WrkCtrIdPilot from startJmgTermReg
            order by RegType, Worker, JobActive, RegDateTime
                where startJmgTermReg.RecId == this.MatchRecIdStartStop;

        if (startJmgTermReg)
        {
            // Loop all start JmgTermReg record per _regType.
            while select JobId, RegDateTime, Worker from jmgTermReg
                where (  (_regType == JmgTermRegType::TeamStop
                          && jmgTermReg.RegType == JmgTermRegType::JobStart
                          && ((jmgTermReg.Worker == startJmgTermReg.Worker) || (jmgTermReg.Worker == 0 && jmgTermReg.WrkCtrIdPilot == startJmgTermReg.WrkCtrIdPilot)))
                      || (_regType == JmgTermRegType::JobStop
                          && jmgTermReg.RegType == JmgTermRegType::TeamStart
                          && ((jmgTermReg.WorkerPilot == this.Worker) || (jmgTermReg.Worker == 0 && jmgTermReg.WrkCtrIdPilot == this.WrkCtrIdPilot))))
                      && jmgTermReg.JobActive
                      && jmgTermReg.RegDateTime <=  this.RegDateTime
            {
                if (_regType == JmgTermRegType::TeamStop)
                {
                    startDateTime   = max(startJmgTermReg.RegDateTime, jmgTermReg.RegDateTime);
                    workerId        = startJmgTermReg.Worker;
                    jobId           = jmgTermReg.JobId;
                }
                else
                {
                    startDateTime   = max(jmgTermReg.RegDateTime, startJmgTermReg.RegDateTime);
                    workerId        = jmgTermReg.Worker;
                    jobId           = this.JobId;
                }

                select forupdate firstonly jmgStampJournalTrans
                    where  jmgStampJournalTrans.Worker      == workerId
                        && jmgStampJournalTrans.JobId       == this.getAssistantJobId(workerId, jobId)
                        && jmgStampJournalTrans.StartDate   == this.getUserPreferredDate(startDateTime)
                        && jmgStampJournalTrans.StartTime   == this.getUserPreferredTime(startDateTime)
                        && jmgStampJournalTrans.StopDate    == this.getUserPreferredDate(this.RegDateTime)
                        && jmgStampJournalTrans.StopTime    == this.getUserPreferredTime(this.RegDateTime);

                if(jmgStampJournalTrans)
                {
                    jmgStampJournalTrans.updateOriginalTransaction();
                    jmgStampJournalTrans.Seconds = real2int(DateTimeUtil::getDifference(this.RegDateTime, startDateTime) * _ratio);
                    jmgStampJournalTrans.doUpdate();
                    JmgCalcApproveForm::construct().transactionUpdated(jmgStampJournalTrans);
                    touchJmgStampJournalTable.add([jmgStampJournalTrans.Worker, jmgStampJournalTrans.ProfileDate]);
                }
            }

            if (touchJmgStampJournalTable.elements())
            {
                setEnumerator = touchJmgStampJournalTable.getEnumerator();
                while (setEnumerator.moveNext())
                {
                    [workerLocal, profileDateLocal] = setEnumerator.current();
                    JmgTransaction::postChangesForSpecifiedWorkerAndDate(workerLocal, profileDateLocal);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRegTypeStart</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if it is a start registration.
    /// </summary>
    /// <returns>true if it is a start registration; otherwise false.</returns>
    internal boolean isRegTypeStart()
    {
        switch (this.RegType)
        {
            case JmgTermRegType::BrkFlowStart:
            case JmgTermRegType::TeamStart:
            case JmgTermRegType::JobStart:
                return true;
        }

        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>JmgRegistrationEmployees</ConfigurationKey>
	<DeveloperDocumentation>@SYS317309</DeveloperDocumentation>
	<Label>@SYS39346</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>Worker</TitleField1>
	<TitleField2>RegDateTime</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>EmplTypeTimeIdx</ClusteredIndex>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>ProductionControl</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Worker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RegType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JobId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JobIdAbs</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkerPilot</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StartItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GoodItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ScrapItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FinishedCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RegDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Feedback</Name>
			<Label>@SYS22522</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>StartItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWStartItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GoodItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWGoodItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ScrapItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWScrapItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FinishedCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS53631</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Worker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProfileDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Registration</Name>
			<Label>@SYS38390</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RegType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProfileDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RegDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkerPilot</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WrkCtrIdPilot</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JobId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JobIdAbs</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>termregrecid</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MatchRecIdStartStop</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JobActive</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>RetailTerminal</Name>
			<Label>@RET3232</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RetailTerminalId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Startup</Name>
			<Label>@SYS12531</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CostCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OnCallActivity</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>System</Name>
			<Label>@SYS4278</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AutoStamp</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Error</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ErrorTxt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ResNo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SysMrpUpdateRequest</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RegDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TmpStartItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TmpGoodItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TmpScrapItems</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TmpPdsCWStartItems</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Terminal</Name>
			<Label>@SYS39201</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TerminalId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AutoStamp</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS11318</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CostCategory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Error</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS8500</Label>
			<EnumType>NoYesCombo</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ErrorSpecification</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgErrorSpecification</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ErrorTxt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ErrorTxt</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>FinishedCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgTermFinishedCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>GoodItems</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProductQuantity</ExtendedDataType>
			<Label>@SYS4638</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>JobActive</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS3043</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>JobId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgJobId</ExtendedDataType>
			<Label>@SYS1066</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>JobIdAbs</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgJobId</ExtendedDataType>
			<Label>@SYS39179</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>MatchRecIdStartStop</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS39421</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OnCallActivity</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgIpcActivityIdOnCall</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PdsCWGoodItems</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsCWBatchGood</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PdsCWScrapItems</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsCWBatchErr</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PdsCWStartItems</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsCWBatchStup</ExtendedDataType>
			<Label>@PDS1557</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ProfileDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgProfileDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>RegDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RegType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>JmgTermRegType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ResNo</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>WrkCtrId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RetailTerminalId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailTerminalId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ScrapItems</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProductQuantity</ExtendedDataType>
			<Label>@SYS2083</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>StartItems</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProductQuantity</ExtendedDataType>
			<Label>@SYS15063</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SysMrpUpdateRequest</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgTermSysMrpUpdateRequest</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TerminalId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgTerminalId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TmpGoodItems</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgTermTmpGoodItems</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TmpScrapItems</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgTermTmpScrapItems</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TmpStartItems</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgTermTmpStartItems</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Worker</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>JmgWorkerRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>WorkerPilot</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>JmgWorkerRecId_JobPilot</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WrkCtrIdPilot</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>JmgWrkCtrIdPilot</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TmpPdsCWStartItems</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgTermTmpPdsCWStartItems</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>HcmWorkerPilotIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkerPilot</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>EmplTimeTypeIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Worker</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RegDateTime</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RegType</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>EmplTypeTimeIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Worker</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RegType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RegDateTime</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ActFinishIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Worker</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JobActive</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>FinishedCode</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PiloteIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>RegType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkerPilot</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JobActive</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RegDateTime</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CoAssistIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>RegType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Worker</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JobActive</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RegDateTime</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>EmplIdJobIdJobActiveIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Worker</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JobId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JobActive</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>JobIdJobActiveIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>JobId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JobActive</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>RegDateTimeIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>RegDateTime</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JobId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>JmgTermRegArchiveMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>MatchRecIdStartStop</MapField>
					<MapFieldTo>MatchRecIdStartStop</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TermRegRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>RegDateTime</MapField>
					<MapFieldTo>RegDateTime</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Worker</MapField>
					<MapFieldTo>Worker</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>WorkerPilot</MapField>
					<MapFieldTo>WorkerPilot</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>RegType</MapField>
					<MapFieldTo>RegType</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ProfileDate</MapField>
					<MapFieldTo>ProfileDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JobId</MapField>
					<MapFieldTo>JobId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JobIdAbs</MapField>
					<MapFieldTo>JobIdAbs</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JobActive</MapField>
					<MapFieldTo>JobActive</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ResNo</MapField>
					<MapFieldTo>ResNo</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>StartItems</MapField>
					<MapFieldTo>StartItems</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>GoodItems</MapField>
					<MapFieldTo>GoodItems</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FinishedCode</MapField>
					<MapFieldTo>FinishedCode</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ErrorSpecification</MapField>
					<MapFieldTo>ErrorSpecification</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ScrapItems</MapField>
					<MapFieldTo>ScrapItems</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TmpGoodItems</MapField>
					<MapFieldTo>TmpGoodItems</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TmpScrapItems</MapField>
					<MapFieldTo>TmpScrapItems</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SysMrpUpdateRequest</MapField>
					<MapFieldTo>SysMrpUpdateRequest</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Error</MapField>
					<MapFieldTo>Error</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ErrorTxt</MapField>
					<MapFieldTo>ErrorTxt</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TmpStartItems</MapField>
					<MapFieldTo>TmpStartItems</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>AutoStamp</MapField>
					<MapFieldTo>AutoStamp</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CostCategory</MapField>
					<MapFieldTo>CostCategory</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>OnCallActivity</MapField>
					<MapFieldTo>OnCallActivity</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TerminalId</MapField>
					<MapFieldTo>TerminalId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PdsCWStartItems</MapField>
					<MapFieldTo>PdsCWStartItems</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PdsCWGoodItems</MapField>
					<MapFieldTo>PdsCWGoodItems</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PdsCWScrapItems</MapField>
					<MapFieldTo>PdsCWScrapItems</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>HcmWorker</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>HcmWorker_JmgTermReg</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Worker</Name>
					<Field>Worker</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>HcmWorkerPilot</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>HcmWorker_1_JmgTermReg</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkerPilot</Name>
					<Field>WorkerPilot</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>HRMAbsenceCode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>HRMAbsenceCode</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>AbsenceCode</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>RawRegistration</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobIdAbs</Name>
					<Field>JobIdAbs</Field>
					<RelatedField>JmgJobId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>JmgEmployee</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>JmgEmployee</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Worker</Name>
					<Field>Worker</Field>
					<RelatedField>Worker</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>JmgJobTable</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>JmgJobTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>JmgTermReg</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>JmgTermReg</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ReferenceRawRegistration</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>RawRegistration</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MatchRecIdStartStop</Name>
					<Field>MatchRecIdStartStop</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>OnCallJmgIpcActivity</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>JmgIpcActivity</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OnCallJmgIpcActivity</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JmgTermReg</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OnCallActivity</Name>
					<Field>OnCallActivity</Field>
					<RelatedField>Activity</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Type_Extern</Name>
					<RelatedField>Type</RelatedField>
					<ValueStr>JmgStampTypeEnum::OnCall</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ActIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CostCategory</Name>
					<Field>CostCategory</Field>
					<RelatedField>CategoryId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CategoryIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ResourcePilotWrkCtrTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WrkCtrTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ResourcePilotWrkCtrTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JmgTermReg</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WrkCtrIdPilot</Name>
					<Field>WrkCtrIdPilot</Field>
					<RelatedField>WrkCtrId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>IsIndividualResource_Extern</Name>
					<RelatedField>IsIndividualResource</RelatedField>
					<Value>1</Value>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>WrkCtrIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ResourceWrkCtrTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WrkCtrTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ResourceWrkCtrTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JmgTermReg</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ResNo</Name>
					<Field>ResNo</Field>
					<RelatedField>WrkCtrId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>IsIndividualResource_Extern</Name>
					<RelatedField>IsIndividualResource</RelatedField>
					<Value>1</Value>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>WrkCtrIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RetailTerminalTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>RetailTerminalTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RetailTerminalId</Name>
					<SourceEDT>RetailTerminalId</SourceEDT>
					<Field>RetailTerminalId</Field>
					<RelatedField>terminalId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>terminalIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>