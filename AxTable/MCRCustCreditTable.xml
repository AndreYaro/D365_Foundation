<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MCRCustCreditTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class MCRCustCreditTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>copyCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copys the credit information to the <c>mcrCustCreditTable_return</c> record.
    /// </summary>
    /// <returns>
    /// A record in the <c>mcrCustCreditTable_return</c> table.
    /// </returns>
    MCRCustCreditTable copyCredit()
    {
        MCRCustCreditTable mcrCustCreditTable_return;

        mcrCustCreditTable_return.CustAccount = this.CustAccount;

        mcrCustCreditTable_return.LineNum       = MCRCustCreditTable::lastLineNum(this.OrigSalesID) + 1;
        mcrCustCreditTable_return.TotalCredit   = this.TotalCredit;

        mcrCustCreditTable_return.OrigSalesID   = this.OrigSalesID;
        mcrCustCreditTable_return.OrderCurrency = this.OrderCurrency;

        mcrCustCreditTable_return.RetailInfocodeId      = this.RetailInfocodeId;
        mcrCustCreditTable_return.ReasonCode            = this.ReasonCode;
        mcrCustCreditTable_return.ReasonCodeDescription = this.ReasonCodeDescription;

        mcrCustCreditTable_return.ItemId        = this.ItemId;
        mcrCustCreditTable_return.InventTransID = this.InventTransID;
        mcrCustCreditTable_return.NewPrice      = this.NewPrice;

        mcrCustCreditTable_return.OrigPaymID = this.OrigPaymID;
        mcrCustCreditTable_return.CreditType = this.CreditType;
        //Return an exact copy of the calling record.
        return mcrCustCreditTable_return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a credit based on the <c>salesTable</c> record passed in.
    /// </summary>
    /// <param name="_salesTable">
    ///     The <c>SalesTable</c> record for which this method creates
    ///     a credit.
    /// </param>
    /// <param name="_retailInfocodeId">
    ///     The reason code infocode ID used to justify the creation of the credit.
    /// </param>
    /// <param name="_mcromcReasonCode">
    ///     The reason code used to justify the creation of the credit.
    /// </param>
    /// <param name="_amount">
    ///     The amount for which the credit will be created.
    /// </param>
    /// <param name="_salesLine">
    ///     The <c>SalesLine</c> record for which this method creates a credit; optional.
    /// </param>
    /// <param name="_onAcctOverride">
    ///     The <c>Boolean</c> to determine whether or not to use On Account payment method;
    ///     optional.
    /// </param>
    /// <param name="_origPayment">
    ///     The original method of payment; optional.
    /// </param>
    /// <remarks>
    ///     If itemID has a value that means this is a price match
    ///         this.AppliedPaymID - Gets assinged when the customer uses their credit.
    ///         this.AppliedSalesID - Gets assigned when the customer uses their credit.
    ///         this.Voucher - Gets set in the insert method, this is the voucher number of the custTrans
    ///             record of the original credit posting (not the number of the payment using the credit).
    ///         this.JournalNum - Gets set in the insert method, this is the journal number of the
    ///             original credit posting (not the number of the payment using the credit).
    ///         this.ccSettlementRecID - For credit card credits, need in case of a declined settlement request.
    ///         this.OrigPaymID - OrigPaymID normally points to the original payment
    ///             record, from which all credit posting information
    ///             is drawn.  However, in the case of OnAccount override
    ///             this is not true.  To indicate this, OrigPaymID will be blank.
    ///
    ///     There is a MCRCustPaymTable record associated w/ each credit, to get that record need
    ///         to do a find on the payment table by this credit's RecID and TableID.
    ///     CustCreditStatus is an enum with 4 values
    ///          Open (Default) - This means that the credit is available for use (only applies to onAccount).
    ///          Applied - This means that the credit has been applied to a sales order (only applies to onAccount).
    ///          Pending - This means that the credit is pending (why it's pending is based on the credit type).
    ///                  In the case of credit cards it is awaiting settlement.
    ///          Successful - This means that the credit has been given to the customer (all payments except onAccount).
    ///          Failed     - This means that something went wrong when trying to credit the customer.
    /// </remarks>
    void createCredit(  SalesTable                  _salesTable,
                        RetailInfocodeId            _retailInfocodeId,
                        RetailInformationSubcodeId  _mcromcReasonCode,
                        AmountCur                   _amount,
                        SalesLine                   _salesLine = null,
                        boolean                     _onAcctOverride = false,
                        MCRCustPaymTable            _origPayment = null)
    {
        if (_salesTable)
        {
            this.LineNum            = MCRCustCreditTable::lastLineNum(_salesTable.SalesId) + 1;
            this.TotalCredit        = _amount;

            this.OrigSalesID        = _salesTable.SalesId;
            this.OrderCurrency      = _salesTable.CurrencyCode;
            if (_mcromcReasonCode)
            {
                this.ReasonCode     = _mcromcReasonCode;
                this.RetailInfocodeId = _retailInfocodeId;
                this.ReasonCodeDescription = RetailInformationSubcodeTable::find(_retailInfocodeId, _mcromcReasonCode).displaySubcodeDescription();
            }
            this.ItemId             = _salesLine.ItemId;
            this.InventTransID      = _salesLine.InventTransId;
            this.CustAccount        = _salesTable.InvoiceAccount;

            this.setPaymentValues(_origPayment, _onAcctOverride);
        }
        else
        {
            error(strFmt("@SYS22828", funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInsertPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the credit, inserts it and then
    ///         posts to the correct tables.
    /// </summary>
    /// <param name="_onAcctOverride">
    ///     A <c>Boolean</c> that determines on account status for credit.
    /// </param>
    /// <param name="_create">
    ///     A <c>Boolean</c> that determines creation status; optional.
    /// </param>
    /// <remarks>
    ///     If the credit type is credit card need to be sure
    ///          that more than one card doesn't exist.  If it does
    ///          must credit each card a portion of the amount.
    /// </remarks>
    void createInsertPost(boolean _onAcctOverride, boolean _create = true)
    {
        SalesTable          salesTable;
        SalesLine           salesLine;
        MCRCustomerCredits  mcrCustomerCredits;

        if (MCRCustomerCredits::validateTotalCreditAmt(this))
        {
            salesTable = SalesTable::find(this.OrigSalesID);
            salesLine = SalesLine::findInventTransId(this.InventTransID);

            if (_create)
            {
                this.createCredit(salesTable, this.RetailInfocodeId, this.ReasonCode, this.TotalCredit, salesLine, _onAcctOverride);
            }

            //  If more than one credit card has been used to pay
            //      for the sales order.  Need to credit each card.
            if (!_onAcctOverride
                && this.CreditType == MCRCustPaymType::CreditCard
                && salesTable.hasMultipleCreditCardsAssociatedWithPayment())
            {
                mcrCustomerCredits = MCRCustomerCredits::construct(this);
                mcrCustomerCredits.insertMultipleCredits();
            }
            else
            {
                ttsbegin;
                if (!this.CreditID)
                {
                    this.CreditID = NumberSeq::newGetNum(CustParameters::MCRNumRefCreditTableID()).num();
                }

                if (this.validateWrite())
                {
                    this.insert();
                    this.postCredit();
                }
                else
                {
                    throw error("@SYS104318");
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCreditedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the qty used for customer credit calculation.
    /// </summary>
    /// <returns>
    /// The customer credit quantity.
    /// </returns>
    display SalesInvoicedQty displayCreditedQty()
    {
        MCRCustCreditTable       creditTable;

        if (this.InventTransID)
        {
            select sum(CreditQty) from creditTable
                where creditTable.InventTransID == this.InventTransID;
            return creditTable.CreditQty;
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayInvoicedQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the invoiced quantity.
    /// </summary>
    /// <returns>
    ///     The invoiced qty for the line being
    ///         price matched.
    /// </returns>
    /// <remarks>
    ///     An inventTransID is required.
    /// </remarks>
    display SalesInvoicedQty displayInvoicedQty()
    {
        SalesInvoicedQty        invoicedQty;

        if (this.InventTransID)
        {
            invoicedQty = SalesLine::findInventTransId(this.InventTransID).invoicedInTotal();
            return invoicedQty;
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPriceMatchAvail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the quantity available for customer credit calcualtion.
    /// </summary>
    /// <returns>
    /// The quantity available for customer credit calcualtion.
    /// </returns>
    display InventQty displayPriceMatchAvail()
    {
        return this.priceMatchAvail();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayRemainingAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds and calculates the remaining credit.
    /// </summary>
    /// <returns>
    ///     The amount that is available for use.
    /// </returns>
    /// <remarks>
    ///     Remaining credit is not stored but calculated on the fly.
    /// </remarks>
    display AmountCur displayRemainingAmount()
    {
        CustTrans           custTrans;
        AmountCur           remainingCredit;

        select firstonly AmountCur, SettleAmountCur from custTrans
                where    custTrans.Voucher == this.Voucher;

        remainingCredit = abs(custTrans.AmountCur) - abs(custTrans.SettleAmountCur);

        return remainingCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateMiscCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the misc charge and applies it to the returned line. This ensures
    ///     the customer does not get more money than they should.
    /// </summary>
    /// <param name="_returnTransID">
    ///     The <c>InventTransID</c> of the return order.
    /// </param>
    /// <param name="_origTransID">
    ///     The <c>InventTransID</c> of the original order.
    /// </param>
    /// <param name="_displayWarning">
    ///     The <c>Boolean</c> determining whether or not to show warnings; optional.
    /// </param>
    /// <remarks>
    ///     MarkupCategory is always based on pcs when implemented via this method.
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///     Error describing the nature of the problem.
    /// </exception>
    void generateMiscCharge(InventTransId _returnTransID, InventTransId _origTransID, boolean _displayWarning = true)
    {
        var message = this.generateMiscChargeAndGetMessage(_returnTransID, _origTransID);

        if (_displayWarning && message != '')
        {
            info(message);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateMiscChargeAndGetMessage</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the misc charge and applies it to the returned line. This ensures
    ///     the customer does not get more money than they should.
    /// </summary>
    /// <param name="_returnTransID">
    ///     The <c>InventTransID</c> of the return order.
    /// </param>
    /// <param name="_origTransID">
    ///     The <c>InventTransID</c> of the original order.
    /// </param>
    /// <remarks>
    ///     MarkupCategory is always based on pcs when implemented via this method.
    /// </remarks>
    /// <returns>
    ///     The message about the price changing.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     Error describing the nature of the problem.
    /// </exception>
    internal str generateMiscChargeAndGetMessage(InventTransId _returnTransID, InventTransId _origTransID)
    {
        MarkupTrans markupTrans;
        MarkupCode  markupCode;
        SalesLine   returnSalesLine;
        SalesTable  originalSalesTable;
        SalesLine   originalSalesLine;
        AmountCur   oldPrice;

        if (!this || !_returnTransID || !_origTransID)
        {
            return '';
        }

        markupCode = MCROrderParameters::find().PriceMatchMarkupCode;
        returnSalesLine = SalesLine::findInventTransId(_returnTransID);
        originalSalesLine = SalesLine::findInventTransId(_origTransID);
        originalSalesTable = SalesTable::find(originalSalesLine.SalesId);
        oldPrice = (originalSalesLine.LineAmount/originalSalesLine.SalesQty);

        markupTrans.initFromMarkupTable(MarkupTable::find(MarkupModuleType::Cust, markupCode));
        markupTrans.initFromSalesLine(returnSalesLine);
        markupTrans.MarkupCode = markupCode;

        markupTrans.Value = (oldPrice * (1 - originalSalesTable.DiscPercent)) - this.NewPrice;
        markupTrans.MarkupCategory = MarkupCategory::Pcs;
        markupTrans.LineNum = MarkupTrans::lastLineNum(markupTrans.TransTableId, markupTrans.TransRecId)+1;

        markupTrans.Keep = NoYes::Yes;

        if (markupTrans.validateWrite())
        {
            markupTrans.insert();
        }
        else
        {
            throw error("@SYS104318");
        }

        return strFmt("@MCR26316",returnSalesLine.ItemId, this.NewPrice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the payment record that the credit information
    ///         will come from.
    /// </summary>
    /// <returns>
    ///     The <c>MCRCustPaymTable</c> record containing payment information.
    /// </returns>
    /// <remarks>
    ///     Does not take OnAccount override in to account.
    ///     Credit card record is returned first.
    /// </remarks>
    MCRCustPaymTable getPayment()
    {
        MCRCustPaymTable mcrCustPaymTable_Return;

        // If the original payment has not been set already
        if (!this.OrigPaymID)
        {
            // Must have the original sales order to find anything
            if (this.OrigSalesID)
            {
                mcrCustPaymTable_Return = MCRCustCreditTable::getOrigPayment(this.OrigSalesID);
            }
        }
        else
        {
            mcrCustPaymTable_Return = MCRCustPaymTable::findByRecID(this.OrigPaymID);
        }

        return mcrCustPaymTable_Return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts the credit in to the credit table and posts.
    /// </summary>
    /// <remarks>
    ///     How the credit is posted (to what tables) is determined
    ///         by the creditType.
    ///     The origSalesID field must be set for this
    ///         method to work.
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///     Error describing the nature of the problem.
    /// </exception>
    public void insert()
    {
        if (this.TotalCredit > 0)
        {
            this.CreditID = NumberSeq::newGetNum(CustParameters::MCRNumRefCreditTableID()).num();
            super();
        }
        else
        {
            throw error("@MCR25875");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts the credit to the correct tables using the
    ///          <c>MCRCustomerCredit</c> class.
    /// </summary>
    /// <remarks>
    ///     Which child object is created is based on the
    ///          creditType of the credit.
    /// </remarks>
    void postCredit()
    {
        MCRCustomerCredits mcrCustomerCredits;
        MCROrderEventTable mcrOrderEventTable;

        mcrCustomerCredits = MCRCustomerCredits::construct(this);
        mcrCustomerCredits.post();

        this.reread();
        // Creation of the LedgerJournalTable or LedgerJournalTrans
        //      failed, so remove the credit record.
        if (this.validateDelete()
            && (!this.JournalNum
                || !this.Voucher))
        {
            ttsbegin;
            this.delete();
            ttscommit;
        }
        else
        {
            if (this.InventTransID)
            {
                // Create credit created event - Price match.
                // ValidateWrite called inside insertOrderCreditEvent.
                mcrOrderEventTable.insertOrderCreditEvent(MCROrderEventType::PriceMatch,
                                                          SalesTable::find(this.OrigSalesID),
                                                          strFmt("@MCR26290", this.TotalCredit),
                                                          this.ReasonCode);
            }
            else
            {
                // Create credit created event - Header credit.
                // ValidateWrite called inside insertOrderCreditEvent.
                mcrOrderEventTable.insertOrderCreditEvent(MCROrderEventType::OrderCreditCreated,
                                                          SalesTable::find(this.OrigSalesID),
                                                          strFmt("@MCR26290", this.TotalCredit),
                                                          this.ReasonCode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceDiff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the per unit credit price.
    /// </summary>
    /// <returns>
    /// The per unit credit price.
    /// </returns>
    display SalesLineAmount priceDiff()
    {
        if (this.CreditQty)
        {
            return (this.TotalCredit/this.CreditQty);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceMatchAvail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calcuates the quantity available for price match.
    /// </summary>
    /// <returns>
    /// The quantity available for price match.
    /// </returns>
    Qty priceMatchAvail()
    {
        return this.CreditQty - this.CreditedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the payment values to the passed
    ///         record, otherwise get the first one
    ///         associated with the sales order.
    /// </summary>
    /// <param name="_mcrCustPaymTable">
    ///     The <c>MCRCustPaymTable</c> record for which payment method is retrieved; optional.
    /// </param>
    /// <param name="_onAcctOverride">
    ///     The <c>Boolean</c> to determine whether or not to use OnAcct payment method; optional.
    /// </param>
    /// <remarks>
    ///     If _mcrCustPaymTable is null, instantiate via this.getPayment method.
    /// </remarks>
    void setPaymentValues(MCRCustPaymTable _mcrCustPaymTable = null, boolean _onAcctOverride = false)
    {
        MCRCustPaymTable    mcrCustPaymTable = _mcrCustPaymTable;
        if (_onAcctOverride)
        {
            this.CreditType = MCRCustPaymType::OnAccount;
            this.OrigPaymID = 0;
        }
        // If OrigPaymID and creditType are not set means that createSkeleton
        //  was never called.  So determine them from the sales order.
        else if (!this.OrigPaymID)
        {
            // Brand new record, set payment type and payment ID.
            if (!this.CreditType)
            {
                if (!mcrCustPaymTable)
                {
                    mcrCustPaymTable = this.getPayment();
                }
                this.OrigPaymID = mcrCustPaymTable.RecId;
                this.CreditType = mcrCustPaymTable.CustPaymType;
            }
            // If no payment ID set credit type to OnAccount.
            else
            {
                //Decided that if the payment type is set but there is no
                //      payment ID.  Going to force OnAccount credit types.
                this.CreditType = MCRCustPaymType::OnAccount;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the current record is valid and ready to be
    ///         written to the database.
    /// </summary>
    /// <returns>
    ///     true if the record is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     Uses the class MCRCustomerCredits
    ///          to determine if the credit is valid
    /// </remarks>
    public boolean validateWrite()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            ret = MCRCustomerCredits::validateTotalCreditAmt(this);
        }

        ret = ret && RetailInformationSubcodeTable::mcrValidate(this.RetailInfocodeId,this.ReasonCode);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSkeleton</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a display only credit record.In order to insert it into
    ///          the table, an amount is required.
    /// </summary>
    /// <param name="_salesTable">
    ///     The <c>SalesTable</c> record of the original sales order.
    /// </param>
    /// <param name="_salesLine">
    ///     The <c>SalesLine</c> record of the original sales order; optional.
    /// </param>
    /// <param name="_onAccountOverride">
    ///     Indicates if this credit is being forced to be of time on account.
    /// </param>
    /// <returns>
    ///     The <c>MCRCustCreditTable</c> record containing cust credit information pertaining
    ///         to the sales order.
    /// </returns>
    static MCRCustCreditTable createSkeleton(SalesTable _salesTable,
                                                SalesLine _salesLine = null,
                                                boolean _onAccountOverride = MCROrderParameters::find().CustCreditOnAccount)
    {
        MCRCustCreditTable mcrCustCreditTable;
        MCRCustPaymTable   mcrCustPaymTable;

        mcrCustCreditTable.CustAccount = _salesTable.InvoiceAccount;
        mcrCustCreditTable.OrigSalesID = _salesTable.SalesId;
        mcrCustCreditTable.OrderCurrency = _salesTable.CurrencyCode;
        if (_salesLine)
        {
            mcrCustCreditTable.ItemId = _salesLine.ItemId;
            mcrCustCreditTable.InventTransID = _salesLine.InventTransId;
        }
        mcrCustPaymTable = MCRCustCreditTable::getOrigPayment(mcrCustCreditTable.OrigSalesID);
        mcrCustCreditTable.OrigPaymID = mcrCustPaymTable.RecId;
        if (_onAccountOverride)
        {
            mcrCustCreditTable.CreditType = MCRCustPaymType::OnAccount;
        }
        else
        {
            mcrCustCreditTable.CreditType = MCRCustCreditTable::determineCreditType(mcrCustPaymTable.CustPaymType);
        }

        return mcrCustCreditTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineCreditType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the credit type based on what credit types are available.
    /// </summary>
    /// <param name="_origPaymType">
    ///     The <c>MCRCustPaymType</c> enum used to determine plan of action.
    /// </param>
    /// <returns>
    ///     The <c>MCRCustPaymType</c> enum set based on param _origPaymType.
    /// </returns>
    /// <remarks>
    ///     Only 'credit card' and 'on account' credit types are available.
    /// </remarks>
    static MCRCustPaymType determineCreditType(MCRCustPaymType _origPaymType)
    {
        MCRCustPaymType retType;

        switch (_origPaymType)
        {
            case MCRCustPaymType::CreditCard :
                retType = MCRCustPaymType::CreditCard;
                break;
            case MCRCustPaymType::OnAccount  :
            case MCRCustPaymType::Cash       :
            case MCRCustPaymType::Check      :
                retType = MCRCustPaymType::OnAccount;
                break;
            default :
                retType = MCRCustPaymType::OnAccount;
                break;
        }
        return retType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByCreditId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>MCRCustCreditTable</c> record by the credit Id.
    /// </summary>
    /// <param name="_creditID">
    /// The credit Id used to find the <c>MCRCustCreditTable</c> record.
    /// </param>
    /// <returns>
    /// A record in the <c>MCRCustCreditTable</c> table found by a given credit Id.
    /// </returns>
    static MCRCustCreditTable findByCreditId(MCRCreditTableID _creditID)
    {
        MCRCustCreditTable creditTable;

        if (_creditID)
        {
            select firstonly creditTable where creditTable.CreditID == _creditID;
        }

        return creditTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByInventTransID</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the <c>MCRCustCreditTable</c> record based on the passed in <c>InventTransID</c>.
    /// </summary>
    /// <param name="_inventTransId">
    ///     The <c>InventTransID</c> used to find the applicable <c>MCRCustCreditTable</c> record.
    /// </param>
    /// <returns>
    ///     The <c>MCRCustCreditTable</c> that the passed line is related to.
    /// </returns>
    static MCRCustCreditTable findByInventTransID(InventTransId _inventTransId)
    {
        MCRCustCreditTable mcrCustCreditTable;

        if (_inventTransId)
        {
            select firstonly mcrCustCreditTable
                where mcrCustCreditTable.InventTransID == _inventTransId;
        }

        return mcrCustCreditTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByOrigSalesID</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the <c>MCRCustCreditTable</c> record based on the original sales ID.
    /// </summary>
    /// <param name="_salesId">
    ///     The <c>SalesID</c> used to find the applicable <c>MCRCustCreditTable</c> record; optional.
    /// </param>
    /// <returns>
    ///     The <c>MCRCustCreditTable</c> that was created for the passed <c>SalesID</c>.
    /// </returns>
    /// <remarks>
    ///     Does not return
    ///         the credit for the sales order that a
    ///         credit was applied to.
    /// </remarks>
    static MCRCustCreditTable findByOrigSalesID(SalesId _salesId = "")
    {
        MCRCustCreditTable mcrCustCreditTable;

        if (_salesId)
        {
            select firstonly mcrCustCreditTable
                where mcrCustCreditTable.OrigSalesID == _salesId;
        }
        return mcrCustCreditTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByOrigSalesIDTransID</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the applicable <c>MCRCustCreditTable</c> based on the passed <c>SalesID</c> and <c>InventTransID</c>.
    /// </summary>
    /// <param name="_salesId">
    ///     The <c>SalesID</c> of the sales order for which a customer credit was applied.
    /// </param>
    /// <param name="_inventTransId">
    ///     The <c>InventTransID</c> of the sales order for which a customer credit was applied.
    /// </param>
    /// <returns>
    ///     The price match record that was created
    ///         for the passed sales ID and inventTransID.  Does not return
    ///         the credit for the sales order that a
    ///         credit was applied to.
    /// </returns>
    static MCRCustCreditTable findByOrigSalesIDTransID(SalesId _salesId, InventTransId _inventTransId)
    {
        MCRCustCreditTable mcrCustCreditTable;

        if (_salesId && _inventTransId)
        {
            select firstonly mcrCustCreditTable
                where mcrCustCreditTable.OrigSalesID == _salesId
                &&    mcrCustCreditTable.InventTransID == _inventTransId;
        }
        return mcrCustCreditTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecID</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the <c>MCRCustCreditTable</c> record based on the <c>SalesTable</c> RecID.
    /// </summary>
    /// <param name="_recId">
    ///     The <c>SalesTable</c> RecID to find the applicable <c>MCRCustCreditTable</c> record.
    /// </param>
    /// <param name="_forUpdate">
    ///     The <c>Boolean</c> used to determine if the record is selected for update; optional.
    /// </param>
    /// <returns>
    ///     The credit record that was created
    ///         for the passed sales ID.
    /// </returns>
    /// <remarks>
    ///     Does not return
    ///     the credit for the sales order that a
    ///     credit was applied to.
    /// </remarks>
    static MCRCustCreditTable findByRecID(RecId _recId, boolean _forUpdate)
    {
        MCRCustCreditTable mcrCustCreditTable;

        if (_recId)
        {
            mcrCustCreditTable.selectForUpdate(_forUpdate);

            select firstonly mcrCustCreditTable
                where mcrCustCreditTable.RecId == _recId;
        }
        return mcrCustCreditTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the applicable <c>MCRCustCreditTable</c> record based on the sales order's <c>Voucher</c> number.
    /// </summary>
    /// <param name="_voucher">
    ///     The <c>Voucher</c> record used to find the applicable <c>MCRCustCreditTable</c> record.
    /// </param>
    /// <param name="_forUpdate">
    ///     The <c>Boolean</c> used to determine if the record is selected for update.
    /// </param>
    /// <returns>
    ///     Returns the credit record that was created
    ///         for the passed voucher.
    /// </returns>
    /// <remarks>
    ///     Does not return
    ///         the credit for the sales order that a
    ///         credit was applied to.
    /// </remarks>
    static MCRCustCreditTable findByVoucher(Voucher _voucher, boolean _forUpdate)
    {
        MCRCustCreditTable mcrCustCreditTable;

        if (_voucher)
        {
            mcrCustCreditTable.selectForUpdate(_forUpdate);

            select firstonly mcrCustCreditTable
                where mcrCustCreditTable.Voucher == _voucher;
        }
        return mcrCustCreditTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateRemainingCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates remaining credit based on the entire invoice if the order was partially invoiced before.
    /// </summary>
    /// <param name="_inventTransId">
    ///     The <c>InventTransID</c> of the order for which credits were applied.
    /// </param>
    /// <param name="_oldQty">
    ///     The <c>SalesInvoicedQty</c> quantity that was invoiced in part.
    /// </param>
    /// <remarks>
    ///     When an order is partially invoiced we only credit them
    ///         based on how much was invoiced.  So when the order is
    ///         invoiced again we need to generate the remaining credit.
    /// </remarks>
    static void generateRemainingCredit(InventTransId _inventTransId, SalesInvoicedQty _oldQty)
    {
        MCRCustCreditTable mcrCustCreditTable_orig;
        MCRCustomerCredits mcrCustomerCredits;
        MCRCustCreditTable mcrCustCreditTable;

        mcrCustCreditTable_orig = MCRCustCreditTable::findByInventTransID(_inventTransId);
        mcrCustCreditTable = mcrCustCreditTable_orig.copyCredit();
        mcrCustomerCredits = MCRCustomerCredits::construct(mcrCustCreditTable);
        mcrCustCreditTable.TotalCredit = mcrCustomerCredits.calculatePriceMatchAmount(mcrCustCreditTable.NewPrice, _oldQty);
        //ValidateWrite called within the createInsertPost method.
        mcrCustCreditTable.createInsertPost(false, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrigPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the orginal payment method for the passed sales order.
    /// </summary>
    /// <param name="_origSalesID">
    ///     The <c>SalesID</c> of the sales order for which this method is finding the payment method.
    /// </param>
    /// <returns>
    ///     The payment record associated with the passed <c>SalesID</c>
    ///     based on a pre-determined hierarchy.
    /// </returns>
    /// <remarks>
    ///     Used to determine the hierarchy of the credit types
    ///     1. Credit card
    ///     2. OnAccount
    /// </remarks>
    static MCRCustPaymTable getOrigPayment(SalesId _origSalesID)
    {
        MCRCustPaymTable    mcrCustPaymTable;
        RecId               salesRecID;

        salesRecID = SalesTable::find(_origSalesID).RecId;
        mcrCustPaymTable = MCRCustPaymTable::selectFirstByIDAndType(salesRecID, tableNum(SalesTable), MCRCustPaymType::CreditCard);
        if (mcrCustPaymTable)
        {
            return mcrCustPaymTable;
        }
        mcrCustPaymTable = MCRCustPaymTable::findByRefRecIDRefTableID(salesRecID, tableNum(SalesTable));
        if (mcrCustPaymTable)
        {
            return mcrCustPaymTable;
        }

        return mcrCustPaymTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the last <c>LineNum</c> of the sales order.
    /// </summary>
    /// <param name="_salesId">
    ///     The <c>SalesID</c> for which this method finds the last line.
    /// </param>
    /// <returns>
    ///     The last <c>LineNum</c> used for the passed sales order.
    /// </returns>
    /// <remarks>
    ///     This method is used when inserting new records.
    /// </remarks>
    static LineNum lastLineNum(SalesId _salesId)
    {
        return (select maxof(LineNum) from mcrCustCreditTable
                    where mcrCustCreditTable.OrigSalesID == _salesId).LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderCreditNotificationMessageIfExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks and returns message if sales order has credit
    /// </summary>
    /// <param name = "_salesId">The sales id.</param>
    /// <returns>
    ///     The order credit notification message.
    /// </returns>
    internal static str getOrderCreditNotificationMessageIfExists(SalesId _salesId)
    {
        var result = '';

        if (!_salesId)
        {
            return result;
        }

        MCRCustCreditTable mcrCustCreditTable;
        
        select sum(TotalCredit) from mcrCustCreditTable
            where mcrCustCreditTable.OrigSalesID == _salesId
            && mcrCustCreditTable.ItemId == '';

        if (mcrCustCreditTable.TotalCredit > 0)
        {
            result = strFmt("@MCR:SalesOrderHasOrderCredit", mcrCustCreditTable.TotalCredit);
        }
        
        return result;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>MCRPayment</ConfigurationKey>
	<DeveloperDocumentation>@MCR25713</DeveloperDocumentation>
	<Label>@MCR25713</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>OrigSalesID</TitleField1>
	<TitleField2>ItemId</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>CreditID</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<Modules>Payments</Modules>
	<PrimaryIndex>CreditID</PrimaryIndex>
	<ReplacementKey>CreditID</ReplacementKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OrigSalesID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TotalCredit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReasonCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReasonCodeDescription</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CreditID</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@SYS80094</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReasonCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RetailInfocodeId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditedQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrigSalesID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TotalCredit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReasonCodeDescription</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrigPaymID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ccSettlementRecID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentCreditId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustCreditStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BatchId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>creditType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NewPrice</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GridGroup</Name>
			<Label>@MCR25747</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CreditID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TotalCredit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>creditType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReasonCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReasonCodeDescription</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BatchId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventBatchId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<IsObsolete>Yes</IsObsolete>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ccSettlementRecID</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@MCR25793</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CreditedQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Qty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CreditID</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>MCRCreditTableID</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CreditQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Qty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>creditType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS23988</Label>
			<EnumType>MCRCustPaymType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustAccount</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>CustAccount</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CustCreditStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS80127</Label>
			<EnumType>MCRCustCreditStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDefault</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransID</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>InventTransId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>JournalNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LineNum</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LineNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>NewPrice</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@MCR26169</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OrderCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OrigPaymID</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>MCRCustPaymTableRefRecId</ExtendedDataType>
			<Label>@SYS11443</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OrigSalesID</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>SalesIdBase</ExtendedDataType>
			<Label>@MCR26133</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ParentCreditId</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>MCRCustCreditID</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReasonCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailInformationSubcodeId</ExtendedDataType>
			<Label>@SYS63086</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReasonCodeDescription</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Description</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RetailInfocodeId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailInfocodeId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TotalCredit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@MCR25236</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Voucher</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Voucher</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>CreditID</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>CreditID</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventTransID</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransID</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>CreditCardAuthTrans</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>CreditCardAuthTrans</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ccSettlementRecID</Name>
					<Field>ccSettlementRecID</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderCurrency</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>OrderCurrency</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustTable</Name>
			<Cardinality>OneMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustAccount</Name>
					<SourceEDT>CustAccount</SourceEDT>
					<Field>CustAccount</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustTrans</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>CustTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Voucher</Name>
					<Field>Voucher</Field>
					<RelatedField>Voucher</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DimensionAttributeValueSet</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<SourceEDT>ItemId</SourceEDT>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ItemIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOrigin</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransID</Name>
					<SourceEDT>InventTransId</SourceEDT>
					<Field>InventTransID</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventTransIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>LedgerJournalTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JournalNum</Name>
					<SourceEDT>LedgerJournalId</SourceEDT>
					<Field>JournalNum</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TypeNumIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LedgerJournalTrans</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>LedgerJournalTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JournalNum</Name>
					<Field>JournalNum</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>MCRCustPaymTableOrig</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>MCRCustPaymTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>RecIdForOrigPaymId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>MCRCustCreditTable</Role>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrigPaymID</Name>
					<Field>OrigPaymID</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ReasonCode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>RetailInformationSubcodeTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RetailInfocodeId</Name>
					<SourceEDT>RetailInfocodeId</SourceEDT>
					<Field>RetailInfocodeId</Field>
					<RelatedField>infocodeId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReasonCode</Name>
					<SourceEDT>RetailInformationSubcodeId</SourceEDT>
					<Field>ReasonCode</Field>
					<RelatedField>subcodeId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SalesTableOrig</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>SalesTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>SalesIdForOrigSalesId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>MCRCustCreditTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrigSalesID</Name>
					<SourceEDT>SalesIdBase</SourceEDT>
					<Field>OrigSalesID</Field>
					<RelatedField>SalesId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>SalesIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>