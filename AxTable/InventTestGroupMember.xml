<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventTestGroupMember</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class InventTestGroupMember extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustInt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the appropriate value that is based on attribute type.
    /// </summary>
    private void adjustInt()
    {
        if (this.pdsBatchAttrib().PdsBatchAttribType == PdsBatchAttribType::Integer
            || InventTestTable::find(this.TestId).TestType == InventTestType::Integer)
        {
            this.StandardValue  = round(this.StandardValue,1);
            this.LowerLimit     = round(this.LowerLimit,1);
            this.UpperLimit     = round(this.UpperLimit,1);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>aosValidateInsert</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs addition date validation.
    /// </summary>
    /// <returns>
    ///    true if the validation succeeded; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method overrides the standard <c>aosValidateInsert</c> method.
    /// </remarks>
    public boolean aosValidateInsert()
    {
        boolean ret;

        ret = super();
        ret = ret && this.validateDateSequenceOverlap();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>aosValidateUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs addition date validation.
    /// </summary>
    /// <returns>
    ///    true if the validation succeeded; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method overrides the standard <c>aosValidateUpdate</c> method.
    /// </remarks>
    public boolean aosValidateUpdate()
    {
        boolean ret;

        ret = super();
        ret = ret && this.validateDateSequenceOverlap();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLowerLimit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the <c>LowerLimit</c> field has a valid value.
    /// </summary>
    /// <returns>
    ///    true if the value is valid; otherwise, false.
    /// </returns>
    public boolean checkLowerLimit()
    {
        if (this.StandardValue < this.LowerLimit)
        {
            return checkFailed(strFmt("@SYS113787", fieldId2pname(this.TableId, fieldNum(InventTestGroupMember, LowerLimit)),
                                                    fieldId2pname(this.TableId, fieldNum(InventTestGroupMember, StandardValue))));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpperLimit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the <c>UpperLimit</c> field has a valid value.
    /// </summary>
    /// <returns>
    ///    true if the value is valid; otherwise, false.
    /// </returns>
    public boolean checkUpperLimit()
    {
        if (this.StandardValue > this.UpperLimit)
        {
            return checkFailed(strFmt("@SYS113786", fieldId2pname(this.TableId, fieldNum(InventTestGroupMember, UpperLimit)),
                                                    fieldId2pname(this.TableId, fieldNum(InventTestGroupMember, StandardValue))));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventTestTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the record based on the specified <c>InventTestTable</c> record.
    /// </summary>
    /// <param name="_inventTestTable">
    ///    The <c>InventTestTable</c> record from which to initialize.
    /// </param>
    public void initFromInventTestTable(InventTestTable _inventTestTable)
    {
        if (_inventTestTable)
        {
            this.TestId             = _inventTestTable.TestId;
            this.TestInstrumentId   = _inventTestTable.TestInstrumentId;
            this.TestUnitId         = _inventTestTable.TestUnitId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPdsBatchAttrib</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the record that is based on the specified <c>PdsBatchAttrib</c> record.
    /// </summary>
    /// <param name="_pdsBatchAttrib">
    /// The <c>PdsBatchAttrib</c> record from which to initialize.
    /// </param>
    public void initFromPdsBatchAttrib(PdsBatchAttrib _pdsBatchAttrib)
    {
        if (_pdsBatchAttrib)
        {
            this.LowerLimit         = _pdsBatchAttrib.PdsBatchAttribMin;
            this.UpperLimit         = _pdsBatchAttrib.PdsBatchAttribMax;
            this.StandardValue      = str2num(_pdsBatchAttrib.PdsBatchAttribTarget);
            this.setUpperTolerance();
            this.setLowerTolerance();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Overrides the standard <c>initValue</c> method.
    /// </summary>
    public void initValue()
    {
        this.CertificateOfAnalysis  = NoYes::Yes;
        this.AcceptableQualityLevel = 100;
        this.ValidToDateTime        = DateTimeUtil::maxValue();
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Overrides the standard insert method.
    /// </summary>
    public void insert()
    {
        if (!this.AcceptableQualityLevel)
        {
            this.AcceptableQualityLevel = 100;
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtension</Name>
				<Source><![CDATA[
    public TableExtension getExtension()
    {
        return SysTableExtension::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultingDependencies</Name>
				<Source><![CDATA[
    public container getDefaultingDependencies()
    {
        return
        [
            // [field that needs defaulting,
            //      [fields that affect the default value]]
            [fieldNum(InventTestGroupMember, TestUnitId),
                [fieldNum(InventTestGroupMember, TestInstrumentId)]],
            [fieldNum(InventTestGroupMember, TestInstrumentId),
                [fieldNum(InventTestGroupMember, TestId)]],
            [fieldNum(InventTestGroupMember, UpperTolerance),
                [fieldNum(InventTestGroupMember, StandardValue), fieldNum(InventTestGroupMember, UpperLimit), fieldnum(InventTestGroupMember, PdsBatchAttribId)]],
            [fieldNum(InventTestGroupMember, LowerTolerance),
                [fieldNum(InventTestGroupMember, StandardValue), fieldNum(InventTestGroupMember, LowerLimit), fieldnum(InventTestGroupMember, PdsBatchAttribId)]],
            [fieldNum(InventTestGroupMember, UpperLimit),
                [fieldNum(InventTestGroupMember, StandardValue), fieldNum(InventTestGroupMember, UpperTolerance), fieldnum(InventTestGroupMember, PdsBatchAttribId)]],
            [fieldNum(InventTestGroupMember, LowerLimit),
                [fieldNum(InventTestGroupMember, StandardValue), fieldNum(InventTestGroupMember, LowerTolerance), fieldnum(InventTestGroupMember, PdsBatchAttribId)]]
        ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    public void defaultField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(InventTestGroupMember, TestUnitId):
                if (this.TestInstrumentId)
                {
                    this.TestUnitId = InventTestInstrument::find(this.TestInstrumentId).Unit;
                }
                else if (this.TestId)
                {
                    this.TestUnitId = InventTestTable::find(this.TestId).TestUnitId;
                }
                break;
            case fieldNum(InventTestGroupMember, TestInstrumentId):
                if (this.TestId)
                {
                    this.initFromInventTestTable(InventTestTable::find(this.TestId));
                }
                break;
            case fieldNum(InventTestGroupMember, UpperTolerance):
                this.setUpperTolerance();
                this.defaultTestLimitsFromBatchAttribute();
                this.adjustInt();
                break;
            case fieldNum(InventTestGroupMember, LowerTolerance):
                this.setLowerTolerance();
                this.defaultTestLimitsFromBatchAttribute();
                this.adjustInt();
                break;
            case fieldNum(InventTestGroupMember, UpperLimit):
                this.setUpperLimit();
                this.defaultTestLimitsFromBatchAttribute();
                this.adjustInt();
                break;
            case fieldNum(InventTestGroupMember, LowerLimit):
                this.setLowerLimit();
                this.defaultTestLimitsFromBatchAttribute();
                this.adjustInt();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTestLimitsFromBatchAttribute</Name>
				<Source><![CDATA[
    private void defaultTestLimitsFromBatchAttribute()
    {
        // Only default if we have not specified the fields explicitly
        if (this.PdsBatchAttribId && !this.LowerLimit && !this.UpperLimit && !this.StandardValue)
        {
            PdsBatchAttrib attrib = this.pdsBatchAttrib();
            if (attrib.PdsBatchAttribType == PdsBatchAttribType::Integer
                || attrib.PdsBatchAttribType == PdsBatchAttribType::Realnumber)
            {
                this.initFromPdsBatchAttrib(attrib);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Overrides the standard <c>modifiedField</c> method.
    /// </summary>
    /// <param name="_fieldId">
    ///    The ID of the field that has been modified.
    /// </param>
    public void modifiedField(fieldId _fieldId)
    {
        PdsBatchAttrib      attrib;

        switch (_fieldId)
        {
            case fieldnum(InventTestGroupMember, PdsBatchAttribId):
                attrib = this.pdsBatchAttrib();
                if (attrib.PdsBatchAttribType == PdsBatchAttribType::Integer
                    || attrib.PdsBatchAttribType == PdsBatchAttribType::Realnumber)
                {
                    if (this.LowerLimit > 0
                        || this.UpperLimit > 0
                        || this.StandardValue > 0)
                        {
                            if (Box::yesNo("@PDS1547", DialogButton::No))
                            {
                                this.initFromPdsBatchAttrib(attrib);
                            }
                        }
                    else
                    {
                        this.initFromPdsBatchAttrib(attrib);
                    }
                }
                break;
        }

        super(_fieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsBatchAttrib</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>PdsBatchAttrib</c> record that corresponds to current record.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to select the record for update; optional.
    /// </param>
    /// <returns>
    /// Gets the corresponding <c>PdsBatchAttrib</c> record to current record.
    /// </returns>
    public PdsBatchAttrib pdsBatchAttrib(boolean _forUpdate = false)
    {
        return PdsBatchAttrib::find(this.PdsBatchAttribId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCheckQualityOrderOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if an open quality order exists for the test group member.
    /// </summary>
    /// <returns>true if a quality order exists; otherwise, false</returns>
    public boolean pdsCheckQualityOrderOpen()
    {
        InventQualityOrderLine      orderLine;
        InventQualityOrderTable     inventQualityOrderTable;

        select firstonly RecId from orderLine
            where  orderLine.TestId       == this.TestId
                && orderLine.TestSequence == this.TestSequence
            exists join inventQualityOrderTable
            where inventQualityOrderTable.QualityOrderId == orderLine.QualityOrderId
               && inventQualityOrderTable.TestGroupId    == this.TestGroupId
               && inventQualityOrderTable.OrderStatus    == InventTestOrderStatus::Open;

        return orderLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCheckTestType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the test type and attribute type values are the same.
    /// </summary>
    /// <returns>
    /// true if the value is appropriate for the test type; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Use a post-method handler to add validation in case of extending the <c>InventTestType</c> enum.
    /// </remarks>
    public boolean pdsCheckTestType()
    {
        InventTestTable     test    = InventTestTable::find(this.TestId);
        PdsBatchAttrib      attrib  = this.pdsBatchAttrib();
        boolean             ret = true;

        if (attrib.RecId != 0
            && test.RecId != 0)
        {
            switch (test.TestType)
            {
                case InventTestType::Fraction:
                    if (attrib.PdsBatchAttribType != PdsBatchAttribType::Realnumber)
                    {
                        ret = checkFailed(strfmt("@PDS1548",test.TestType,enum2str(PdsBatchAttribType::Realnumber)));
                    }
                    break;
                case InventTestType::Integer:
                    if (attrib.PdsBatchAttribType != PdsBatchAttribType::Integer)
                    {
                        ret = checkFailed(strfmt("@PDS1548",test.TestType,enum2str(PdsBatchAttribType::Integer)));
                    }
                    break;
                case InventTestType::Option:
                    if (attrib.PdsBatchAttribType != PdsBatchAttribType::Enumerate)
                    {
                        ret = checkFailed(strfmt("@PDS1548",test.TestType,enum2str(PdsBatchAttribType::Enumerate)));
                    }
                    break;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCheckTestTypeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the value is valid for a particular test type.
    /// </summary>
    /// <param name="_value">
    /// The value to validate.
    /// </param>
    /// <returns>
    /// true if the value is appropriate for the test type; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Use a post-method handler to add validation in case of extending the <c>InventTestType</c> enum.
    /// </remarks>
    public boolean pdsCheckTestTypeValue(
        PdsAttribValue  _value)
    {
        InventTestTable test = InventTestTable::find(this.TestId);
        boolean         ret = true;

        switch (test.TestType)
        {
            case InventTestType::Fraction:
                ret = PdsBatchAttrib::str2NumOk(_value);
                break;
            case InventTestType::Integer:
                ret = PdsBatchAttrib::str2IntOk(_value);
                break;
            case InventTestType::Option:
                ret = InventTestVariableOutcome::exist(
                            this.VariableId,
                            _value);
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCheckTestValueDetermination</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the test group member's test value determination setting is valid.
    /// </summary>
    /// <returns>true if the setting is valid; otherwise, false</returns>
    public boolean pdsCheckTestValueDetermination()
    {
        boolean ret = true;

        if (this.pdsCheckTestResultValueDerivation()
            && InventTestTable::find(this.TestId).TestType
                == InventTestType::Option)
        {
            ret = checkFailed("@PDS1021");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCheckTestResultValueDerivation</Name>
				<Source><![CDATA[
    protected boolean pdsCheckTestResultValueDerivation()
    {
        return (this.PdsTestResultValueDerivation
                    == PdsTestResultValueDerivation::Average
                || this.PdsTestResultValueDerivation
                        == PdsTestResultValueDerivation::Maximum
                || this.PdsTestResultValueDerivation
                        == PdsTestResultValueDerivation::Minimum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCheckValidAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a valid batch attribute is assigned to the test group member.
    /// </summary>
    /// <returns>true if the batch attribute is valid; otherwise, false</returns>
    public boolean pdsCheckValidAttribute()
    {
        boolean                 ret = true;
        InventTestGroupMember   member;

        if (this.PdsBatchAttribId)
        {
            // Find another test group member within the same test group with overlapping validity period
            // and the same batch attribute
            select firstonly member
                where  member.TestGroupId       == this.TestGroupId
                    && member.PdsBatchAttribId  == this.PdsBatchAttribId
                    && member.RecId             != this.RecId
                    && ((member.ValidFromDateTime <= this.ValidToDateTime
                         && member.ValidToDateTime >= this.ValidToDateTime) ||
                        (member.ValidFromDateTime <= this.ValidFromDateTime
                         && member.ValidToDateTime >= this.ValidFromDateTime));

            if (member)
            {
                ret = checkFailed(strfmt("@PDS1022", this.PdsBatchAttribId, member.TestGroupId));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCheckVariableOutcomeOptions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the associated test variable output is a subset of the assigned batch enumeration
    /// values of the attribute.
    /// </summary>
    /// <returns>
    /// true if the associated batch attribute enumeration has enumeration values; otherwise, false.
    /// </returns>
    public boolean pdsCheckVariableOutcomeOptions()
    {
        boolean                     ret                         = true;
        PdsBatchAttrib              pdsBatchAttrib              = this.pdsBatchAttrib();
        InventTestVariable          testVar;
        InventTestVariableOutcome   testVarOutcome;

        if (pdsBatchAttrib.RecId != 0
            && pdsBatchAttrib.PdsBatchAttribType == PdsBatchAttribType::Enumerate)
        {
            select firstOnly recId, VariableId
                from testVar
                    where (testVar.VariableId == this.VariableId);

            if (testVar.RecId != 0)
            {
                while select VariableId, VariableOutcomeId from testVarOutcome
                    where (testVarOutcome.VariableId == this.VariableId)
                {
                    if (!PdsBatchAttribEnumValues::exist(
                                            pdsBatchAttrib.PdsBatchAttribId,
                                            testVarOutcome.VariableOutcomeId))
                    {
                        ret = checkFailed("@PDS1546");
                        return ret;
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDecimal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the standard values and limits based on the test unit ID.
    /// </summary>
    /// <returns>
    /// Test unit's decimal precision.
    /// </returns>
    public UnitOfMeasureDecimalPrecision setDecimal()
    {
        UnitOfMeasureDecimalPrecision decimalPrecision = UnitOfMeasure::unitOfMeasureDecimalPrecision(
            UnitOfMeasure::unitOfMeasureIdBySymbol(this.TestUnitId));

        if (decimalPrecision)
        {
            this.StandardValue  = decRound(this.StandardValue, decimalPrecision);
            this.LowerLimit     = decRound(this.LowerLimit, decimalPrecision);
            this.UpperLimit     = decRound(this.UpperLimit, decimalPrecision);
        }

        return decimalPrecision;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLowerLimit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the lower limit based on the <c>StandardValue</c> and <c>LowerTolerance</c> fields.
    ///    If <c>StandardValue</c> is 0, do not change the <c>LowerLimit</c> based on the <c>LowerTolerance</c>.
    /// </summary>
    public void setLowerLimit()
    {
        if (this.StandardValue < 0)
        {
            this.LowerLimit = this.StandardValue * (100 + this.LowerTolerance) / 100;
        }
        else if (this.StandardValue > 0)
        {
            this.LowerLimit = this.StandardValue * (100 - this.LowerTolerance) / 100;
        }
        else if (this.StandardValue < this.LowerLimit)
        {
            this.LowerLimit = this.StandardValue;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLowerTolerance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>LowerTolerance</c> field based on the <c>StandardValue</c> and <c>LowerLimit</c> fields.
    /// </summary>
    public void setLowerTolerance()
    {
        if (!this.StandardValue || this.StandardValue <= this.LowerLimit)
        {
            this.LowerTolerance = 0;
        }
        else
        {
            this.LowerTolerance = 100 * (abs(this.StandardValue - this.LowerLimit) / abs(this.StandardValue));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUpperLimit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>UpperLimit</c> based on the <c>StandardValue</c> and <c>UpperTolerance</c> fields.
    ///    If <c>StandardValue</c> is 0, do not change the <c>UpperLimit</c> based on the <c>UpperTolerance</c>.
    /// </summary>
    public void setUpperLimit()
    {
        if (this.StandardValue < 0)
        {
           this.UpperLimit = this.StandardValue * (100 - this.UpperTolerance) / 100;
        }
        else if (this.StandardValue > 0)
        {
           this.UpperLimit = this.StandardValue * (100 + this.UpperTolerance) / 100;
        }
        else if (this.StandardValue > this.UpperLimit)
        {
            this.UpperLimit = this.StandardValue;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUpperTolerance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>UpperTolerance</c> field based on the <c>StandardValue</c> and <c>UpperLimit</c> fields.
    /// </summary>
    public void setUpperTolerance()
    {
        if (!this.StandardValue || this.UpperLimit <= this.StandardValue)
        {
            this.UpperTolerance = 0;
        }
        else
        {
            this.UpperTolerance = 100 * (abs(this.UpperLimit - this.StandardValue) / abs(this.StandardValue));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDateSequenceOverlap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the to and from dates do not overlap with dates on other <c>InventTestGroupMember</c>
    ///    records for the same test group and test sequence.
    /// </summary>
    /// <returns>
    ///    true if validation succeeded; otherwise, false.
    /// </returns>
    public boolean validateDateSequenceOverlap()
    {
        InventTestGroupMember   inventTestGroupMemberOther;

        while select inventTestGroupMemberOther
            where   inventTestGroupMemberOther.TestGroupId  == this.TestGroupId
                 && inventTestGroupMemberOther.TestSequence == this.TestSequence
                 && inventTestGroupMemberOther.RecId        != this.RecId
        {
            if (!InventTestGroupMember::checkDateOverlap(this, inventTestGroupMemberOther))
            {
                return false;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean ret;

        ret = super();

        if (ret && #PdsBatchAttribEnabled)
        {
            if (this.pdsCheckQualityOrderOpen())
            {
                ret = checkFailed("@PDS1023");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean ret;

        ret = super(_fieldIdToCheck);

        if (_fieldIdToCheck == fieldNum(InventTestGroupMember, AcceptableQualityLevel))
        {
            ret =  checkPercentage(this.AcceptableQualityLevel);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldValue</Name>
				<Source><![CDATA[
    public boolean validateFieldValue(fieldName _fieldName, int _arrayIndex = 1)
    {
        boolean ret;

        ret = super(_fieldName, _arrayIndex);

        switch (_fieldName)
        {
            case fieldstr(InventTestGroupMember, TestId):
                ret = ret && this.pdsCheckTestType();
            break;

            case fieldstr(InventTestGroupMember, PdsBatchAttribId):
                ret = ret && this.pdsCheckTestType() && this.pdsCheckVariableOutcomeOptions();
            break;

            case fieldstr(InventTestGroupMember, VariableId):
                ret = ret && this.pdsCheckVariableOutcomeOptions();
            break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean                 ret = super();
        InventTestGroupMember   inventTestGroupMember;

        if (ret)
        {
            if (this.ValidToDateTime <= this.ValidFromDateTime)
            {
                ret = checkFailed(strFmt("@SYS117831",
                  fieldPName(InventTestGroupMember, ValidToDateTime),
                  fieldPName(InventTestGroupMember, ValidFromDateTime)));
            }
        }

        if (ret)
        {
            while select inventTestGroupMember
                where   inventTestGroupMember.TestGroupId   == this.TestGroupId     &&
                        inventTestGroupMember.TestSequence  == this.TestSequence    &&
                        inventTestGroupMember.RecId         != this.RecId
            {
                if (!InventTestGroupMember::checkDateOverlap(this, inventTestGroupMember))
                    return false;
            }
        }

        if (InventTestTable::find(this.TestId).TestType != InventTestType::Option)
        {
            this.VariableId = '';
            this.VariableOutcomeIdStandard = '';
        }
        else
        {
            this.StandardValue = 0;
            this.LowerLimit = 0;
            this.UpperLimit = 0;
            this.LowerTolerance = 0;
            this.UpperTolerance = 0;

            if (ret && !InventTestVariableOutcome::exist(this.VariableId, this.VariableOutcomeIdStandard))
            {
                return checkFailed("@SYS113780");
            }
        }
        ret = ret && this.checkLowerLimit();
        ret = ret && this.checkUpperLimit();

        if (ret && #PdsBatchAttribEnabled)
        {
            if (this.pdsCheckQualityOrderOpen())
            {
                ret = checkFailed("@PDS1024");
            }

            if (ret)
            {
                ret = this.pdsCheckTestValueDetermination();
            }

            if (ret)
            {
                ret = this.pdsCheckValidAttribute();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDateOverlap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the to and from dates on two <c>InventTestGroupMember</c> records overlap.
    /// </summary>
    /// <param name="_inventTestGroupMemberCur">
    ///    The first <c>InventTestGroupMember</c> record.
    /// </param>
    /// <param name="_inventTestGroupMemberOther">
    ///    The second <c>InventTestGroupMember</c> record.
    /// </param>
    /// <returns>
    ///    true if dates do not overlap; otherwise, false.
    /// </returns>
    static public boolean checkDateOverlap(
        InventTestGroupMember   _inventTestGroupMemberCur,
        InventTestGroupMember   _inventTestGroupMemberOther)
    {
        if  (_inventTestGroupMemberCur.ValidToDateTime   > _inventTestGroupMemberOther.ValidFromDateTime
         &&  _inventTestGroupMemberCur.ValidFromDateTime < _inventTestGroupMemberOther.ValidToDateTime)
        {
            return checkFailed("@SYS114358");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTestUsed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the specified test ID is used in any test group member record.
    /// </summary>
    /// <param name="_inventTestId">
    ///    The test group ID to check.
    /// </param>
    /// <returns>
    ///    true if the test ID is not used; otherwise, false.
    /// </returns>
    static public boolean checkTestUsed(InventTestId _inventTestId)
    {
        InventTestGroupMember   inventTestGroupMember;

        if (_inventTestId)
        {
            select firstonly inventTestGroupMember
                  where   inventTestGroupMember.TestId == _inventTestId;
            if (inventTestGroupMember)
            {
                return checkFailed("@SYS113778");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCurrentActiveTest</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>InventTestGroupMember</c> record that is currently valid for the specified test group
    ///    and sequence.
    /// </summary>
    /// <param name="_inventTestGroupId">
    ///    The test group ID to check.
    /// </param>
    /// <param name="_inventTestId">
    ///    The test ID to check.
    /// </param>
    /// <returns>
    ///    The currently active <c>InventTestGroupMember</c> record; otherwise an empty record.
    /// </returns>
    static public InventTestGroupMember findCurrentActiveTest(
        InventTestGroupId   _inventTestGroupId,
        InventTestId        _inventTestId)
    {
        InventTestGroupMember   inventTestGroupMember;
        utcdatetime             createdTime = DateTimeUtil::getSystemDateTime();

        if (_inventTestGroupId && _inventTestId)
        {
            select firstonly inventTestGroupMember
                where       inventTestGroupMember.TestGroupId           == _inventTestGroupId
                        &&  inventTestGroupMember.TestId                == _inventTestId
                        &&  inventTestGroupMember.ValidFromDateTime     <=  createdTime
                        &&  inventTestGroupMember.ValidToDateTime       >   createdTime;
        }
        return inventTestGroupMember;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupMatchingAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and shows a lookup form for the batch attribute ID field that has the same test type as this
    /// </summary>
    /// <param name="_ctrl">
    /// The calling form control.
    /// </param>
    /// <param name="_inventTestGroupMember">
    /// The Batch Attribute ID for which the outcomes should be shown.
    /// </param>
    public static void lookupMatchingAttributes(
        FormStringControl       _ctrl,
        InventTestGroupMember   _inventTestGroupMember)
    {
        PdsBatchAttribType attribType = PdsBatchAttrib::testType2AttribType(InventTestTable::find(_inventTestGroupMember.TestId).TestType);

        PdsBatchAttrib::lookupForPdsBatchAttribMatchingTypes(_ctrl, '', [attribType]);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>InventQualityManagement</ConfigurationKey>
	<DeveloperDocumentation>@SYS124041</DeveloperDocumentation>
	<FormRef>InventTestGroup</FormRef>
	<Label>@SYS113779</Label>
	<SingularLabel>@SYS113782</SingularLabel>
	<TableGroup>Group</TableGroup>
	<TitleField1>TestGroupId</TitleField1>
	<TitleField2>TestId</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>Found</CacheLookup>
	<ClusteredIndex>TestGroupSequenceIdx</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Inventory</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<ReplacementKey>TestGroupSequenceIdx</ReplacementKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StandardValue</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LowerLimit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UpperLimit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UpperTolerance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LowerTolerance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidFromDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidToDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VariableId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VariableOutcomeIdStandard</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CertificateOfAnalysis</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActionOnFailure</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestInstrumentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestUnitId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidFromDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidToDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ActionOnFailure</Name>
			<Label>@SYS113751</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ActionOnFailure</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AcceptableQualityLevel</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dates</Name>
			<Label>@SYS30081</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ValidFromDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidToDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@SYS9039</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidFromDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidToDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PdsAttribAssociation</Name>
			<Label>@PDS1042</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PdsBatchAttribId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsUpdateBatchAttributes</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PdsResultEvaluation</Name>
			<Label>@PDS1043</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PdsTestResultValueDerivation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PdsUpdateBatchAttributes</Name>
			<Label>@PRO1588</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PdsUpdateBatchAttributes</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ResultAnalysis</Name>
			<Label>@SYS113783</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CertificateOfAnalysis</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Sequence</Name>
			<Label>@SYS21731</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestSequence</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>System</Name>
			<Label>@SYS4278</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TestInstrument</Name>
			<Label>@SYS113673</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestInstrumentId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TestMeasurementValues</Name>
			<Label>@SYS113784</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>StandardValue</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LowerLimit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UpperLimit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LowerTolerance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UpperTolerance</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TestUnit</Name>
			<Label>@SYS113785</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestUnitId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Variables</Name>
			<Label>@SYS113648</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VariableId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VariableOutcomeIdStandard</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AcceptableQualityLevel</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventAcceptableQualityLevel</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ActionOnFailure</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>InventTestActionOnFailure</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CertificateOfAnalysis</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventCertificateOfAnalysisReport</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LowerLimit</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestLowerLimit</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LowerTolerance</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestLowerTolerance</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PdsBatchAttribId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>PdsBatchAttribId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PdsTestResultValueDerivation</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<Label>@PDS617</Label>
			<EnumType>PdsTestResultValueDerivation</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PdsUpdateBatchAttributes</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>PdsUpdateInvBatchAttributes</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>StandardValue</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestStandardValue</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TestGroupId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestGroupId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TestId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TestInstrumentId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestInstrumentId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>TestSequence</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestSequence</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TestUnitId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>UnitOfMeasureSymbol</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>UpperLimit</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestUpperLimit</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>UpperTolerance</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestUpperTolerance</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ValidFromDateTime</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ValidFromDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ValidToDateTime</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ValidToDateTime</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VariableId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestVariableId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VariableOutcomeIdStandard</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestVariableOutcomeIdStandard</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TestGroupSequenceIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>TestGroupId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TestSequence</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TestId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValidFromDateTime</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValidToDateTime</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTestGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTestGroup</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Composition</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TestGroupId</Name>
					<Field>TestGroupId</Field>
					<RelatedField>TestGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TestGroupIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTestInstrument</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTestInstrument</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TestInstrumentId</Name>
					<Field>TestInstrumentId</Field>
					<RelatedField>TestInstrumentId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TestInstrumentIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTestTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTestTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TestId</Name>
					<Field>TestId</Field>
					<RelatedField>TestId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TestIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTestVariable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTestVariable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VariableId</Name>
					<Field>VariableId</Field>
					<RelatedField>VariableId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>VariableIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTestVariableOutcome</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124042</EntityRelationshipRole>
			<RelatedTable>InventTestVariableOutcome</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VariableId</Name>
					<Field>VariableId</Field>
					<RelatedField>VariableId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VariableOutcomeIdStandard</Name>
					<SourceEDT>InventTestVariableOutcomeIdStandard</SourceEDT>
					<Field>VariableOutcomeIdStandard</Field>
					<RelatedField>VariableOutcomeId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PdsBatchAttrib</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>PdsBatchAttrib</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PdsBatchAttribId</Name>
					<Field>PdsBatchAttribId</Field>
					<RelatedField>PdsBatchAttribId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PdsBatchAttribEnumValues</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>PdsBatchAttribEnumValues</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VariableOutcomeIdStandard</Name>
					<Field>VariableOutcomeIdStandard</Field>
					<RelatedField>PdsAttribEnumValue</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PdsBatchAttribId</Name>
					<Field>PdsBatchAttribId</Field>
					<RelatedField>PdsBatchAttribId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>UnitOfMeasure</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UnitOfMeasure</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TestUnitId</Name>
					<Field>TestUnitId</Field>
					<RelatedField>Symbol</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>