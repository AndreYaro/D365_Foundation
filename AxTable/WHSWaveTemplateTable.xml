<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWaveTemplateTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class WHSWaveTemplateTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>determinePostMethodNameToBeAddedOnBaseWaveTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the post wave method that will be added in the base wave template based on the passed wave post method.
    /// </summary>
    /// <param name = "_basePostMethodName"> A base post wave method.
    /// </param>
    /// <returns> The name of the post method that will be added in the base wave template </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true)]
    internal WHSPostMethodName determinePostMethodNameToBeAddedOnBaseWaveTemplate(WHSPostMethodName _basePostMethodName)
    {              
        return _basePostMethodName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBaseMethods</Name>
				<Source><![CDATA[
	/// <summary>
	/// Initializes base methods of the template.
	/// </summary>
    void initBaseMethods()
    {
        WHSWaveTemplateLine     templateLine;
        WHSPostMethod           postMethod;
        int                     i;

        ttsbegin;

        while select postMethod
            order by postMethod.PostMethodPos asc
            where postMethod.WaveTemplateType == this.WaveTemplateType
        {
            if (postMethod.isBaseMethod() && !postMethod.isOptionalMethod())
            {
                WHSPostMethodName postMethodName = this.determinePostMethodNameToBeAddedOnBaseWaveTemplate(postMethod.PostMethodName);

                select firstonly RecId from templateLine
                    where templateLine.WaveTemplateName  == this.WaveTemplateName &&
                          templateLine.PostMethodName    == postMethodName;

                if (templateLine.RecId == 0)
                {
                    ++i;

                    templateLine.WaveTemplateName    = this.WaveTemplateName;
                    templateLine.PostMethodName      = postMethodName;
                    templateLine.WaveStep            = i;
                    templateLine.insert();
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQuery</Name>
				<Source><![CDATA[
	/// <summary>
	/// Initializes wave template query.
	/// </summary>
    void initQuery()
    {
        QueryRun queryRun = this.defaultWaveTemplateQueryRun();
        
        if (queryRun)
        {
            this.WaveTemplateQuery = queryRun.pack();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultWaveTemplateQueryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the default wave template query run.
    /// </summary>
    /// <returns>The wave template query run.</returns>
    public QueryRun defaultWaveTemplateQueryRun()
    {
        switch (this.WaveTemplateType)
        {
            case WHSWaveTemplateType::Shipping:
                return new QueryRun(queryStr(WHSWaveTemplateShipping));

            case WHSWaveTemplateType::Production:
                return new QueryRun(queryStr(WHSWaveTemplateProd));

            case WHSWaveTemplateType::Kanban:
                return new QueryRun(queryStr(WHSWaveTemplateKanban));
        }

        return null;    
    }

]]></Source>
			</Method>
			<Method>
				<Name>applicableShippingWorkTransTypesRangeStr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a query string of the <c>WHSWorkTransTypes</c> types that are applicable for a shipping wave that can be used as value on a query range.
    /// </summary>
    /// <returns>A query string of the <c>WHSWorkTransTypes</c> types that are applicable shipping wave.</returns>
    public static str applicableShippingWorkTransTypesRangeStr()
    {
        return WhsWorkTransactionType::workTransTypesForOutboundShipmentQueryRangeStr();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        this.setWarehouseSelection();

        using (var activityContext = WHSInstrumentationLogger::createLoggerForTable(this).configuration().changeEventForWarehouse(funcName(), this, this.InventLocationId))
        {
            super();
        }        

        this.initBaseMethods();
        this.reread();

        this.clearCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldValue</Name>
				<Source><![CDATA[
	/// <summary>
	/// Method to be executed after a field is modified.
	/// </summary>
	/// <param name="_fieldName">
	/// Name of the modified field.
	/// </param>
	/// <param name="_arrayIndex">
	/// Array index of the modified field.
	/// </param>
    public void modifiedFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        super(_fieldName, _arrayIndex);

        switch (_fieldName)
        {
            case fieldStr(WHSWaveTemplateTable, InventLocationId):
                this.InventStorageDimMap::modifiedField(fieldNum(InventStorageDimMap, InventLocationId));
                break;
            case fieldStr(WHSWaveTemplateTable, InventSiteId):
                this.InventStorageDimMap::modifiedField(fieldNum(InventStorageDimMap, InventSiteId));
                break;
            case fieldStr(WHSWaveTemplateTable, WarehouseGroupAll):
                this.setWarehouseSelection();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        using (var activityContext = WHSInstrumentationLogger::createLoggerForTable(this).configuration().changeEventForWarehouse(funcName(), this, this.InventLocationId))
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        this.setWarehouseSelection();

        using (var activityContext = WHSInstrumentationLogger::createLoggerForTable(this).configuration().changeEventForWarehouse(funcName(), this, this.InventLocationId))
        {
            super();
        }

        if (this.Valid != this.validateTemplate())
        {
            ttsbegin;
            this.Valid = !this.Valid;
            this.update();
            ttscommit;
        }

        this.clearCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean         ret;
        WHSWaveTable    waveTable;

        ret = super();

        select firstonly waveTable
            where waveTable.WaveTemplateName == this.WaveTemplateName &&
                  waveTable.WaveStatus       <  WHSWaveStatus::Held;
        if (waveTable)
        {
            ret = checkFailed("@WAX3173");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean ret = super(_fieldIdToCheck);

        if (ret)
        {
            switch (_fieldIdToCheck)
            {
                case fieldNum(WHSWaveTemplateTable, InventLocationId):
                    if (this.InventLocationId || !WHSWaveTemplateTableInventLocationIdValidationFlight::instance().isEnabled())
                    {
                        ret = this.InventStorageDimMap::validateField(fieldNum(InventStorageDimMap, InventLocationId))
                          && this.InventLocationId && this.inventLocation().checkIsWHSEnabled();
                    }                    
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWaveMethodRepetition</Name>
				<Source><![CDATA[
    private boolean validateWaveMethodRepetition(boolean _showInfo)
    {
        boolean ret = true;

        WHSWaveTemplateLine     templateLine;
        WHSWaveTemplateLine     templateLine2;
        WHSPostMethod           repeatablePostMethod;

        select firstonly templateLine
            where templateLine.WaveTemplateName == this.WaveTemplateName
            exists join templateLine2
                where templateLine2.PostMethodName      == templateLine.PostMethodName
                    && templateLine2.WaveTemplateName   == this.WaveTemplateName
                    && templateLine2.WaveStep           < templateLine.WaveStep
            exists join repeatablePostMethod
                where repeatablePostMethod.PostMethodName     == templateLine2.PostMethodName
                    && repeatablePostMethod.WaveTemplateType  == this.WaveTemplateType
                    && !repeatablePostMethod.RepeatableStep;

        if (templateLine)
        {
            ret = this.validationError(_showInfo, strFmt("@WAX3170", templateLine.WaveStep));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTemplate</Name>
				<Source><![CDATA[
	/// <summary>
	/// Validates the wave template record.
	/// </summary>
	/// <param name="_showInfo">
	/// Boolean indicating that errors are shown in case of failure.
	/// </param>
	/// <returns>
	/// True if the the record is validated, false otherwise.
	/// </returns>
    boolean validateTemplate(boolean _showInfo = false)
    {
        WHSWaveTemplateLine     templateLine;
        WHSPostMethod           postMethod;
        boolean                 ret = true;

        // Check to make sure all base methods are in template
        while select postMethod
            where postMethod.WaveTemplateType == this.WaveTemplateType
        {
            if (postMethod.isBaseMethod() && !postMethod.isOptionalMethod())
            {
                select RecId from templateLine
                    where templateLine.WaveTemplateName  == this.WaveTemplateName &&
                          templateLine.PostMethodName    == postMethod.PostMethodName;

                if (!templateLine)
                {
                    if (!this.checkForPostMethodReplacement(postMethod.PostMethodName))
                    {
                        ret = this.validationError(_showInfo, strFmt("@WAX3171", postMethod.PostMethodName));
                    }
                }
            }
        }

        // Check to make sure all wave steps are valid post methods
        select firstonly templateLine
            where templateLine.WaveTemplateName  == this.WaveTemplateName
            notexists join postMethod
                where postMethod.PostMethodName     == templateLine.PostMethodName   
                    && postMethod.WaveTemplateType  == this.WaveTemplateType;

        if (templateLine)
        {
            ret = this.validationError(_showInfo, strFmt("@WAX3170", templateLine.WaveStep));
        }

        if (ret)
        {
            ret = this.validateWaveMethodRepetition(_showInfo);
        }

        if (ret)
        {
            ret = this.validateTemplateLines(_showInfo);
        }

        if (_showInfo && ret)
        {
            info("@WAX1600");
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForPostMethodReplacement</Name>
				<Source><![CDATA[
    private boolean checkForPostMethodReplacement(WHSPostMethodName _postMethodName)
    {
        WHSWaveTemplateLine waveTemplateLine;

        while select PostMethodName from waveTemplateLine
            where waveTemplateLine.WaveTemplateName == this.WaveTemplateName
                && waveTemplateLine.PostMethodName != _postMethodName
        {
            if (WHSCustomWaveStepMethod::isReplacementForBaseMethod(_postMethodName, waveTemplateLine.PostMethodName))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validationError</Name>
				<Source><![CDATA[
    private boolean validationError(boolean _showInfo, str _error)
    {
        if (_showInfo)
        {
            error(_error);
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTemplateLines</Name>
				<Source><![CDATA[
    private boolean validateTemplateLines(boolean _showInfo = false)
    {
        WHSWaveTemplateLine waveTemplateLine;

        while select waveTemplateLine
            order by waveTemplateLine.SequenceNum
            where waveTemplateLine.WaveTemplateName == this.WaveTemplateName
        {
            if (!waveTemplateLine.validateTemplateLine(_showInfo))
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret = super();

        if (ret && this.InventSiteId && this.InventLocationId)
        {
            InventLocation inventLocation = InventLocation::find(this.InventLocationId);

            if (inventLocation.InventSiteId != this.InventSiteId)
            {
                ret = checkFailed(strFmt("@WAX4606", this.InventSiteId, this.InventLocationId));
            }
        }

        if (ret)
        {
            ret = this.validateTemplateLines();
        }

        if (ret)
        {
            ret = this.validateWarehouseGroupAll();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWarehouseGroupAll</Name>
				<Source><![CDATA[
    private boolean validateWarehouseGroupAll()
    {
        switch (this.WarehouseGroupAll)
        {
            case WhsWarehouseGroupAll::Warehouse:
                if (!this.InventLocationId || !this.InventSiteId)
                {
                    return checkFailed("@WAX:WaveTemplateMissingSiteOrWarehouse");
                }
                break;

            case WhsWarehouseGroupAll::Group:
                if (!this.WarehouseGroupId)
                {
                    return checkFailed("@WAX:WaveTemplateMissingWarehouseGroup");
                }
                break;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWarehouse</Name>
				<Source><![CDATA[
    private static boolean validateWarehouse(
        WHSWaveTemplateType  _whsWaveTemplateType,
        WHSWaveTemplateTable _waveTemplate,
        WHSWaveTable         _waveTable,
        str                  _identification,
        boolean              _showError)
    {
        boolean result = WHSWaveTemplateTable::validateWarehouseForTemplateType(_whsWaveTemplateType, _waveTemplate,  _waveTable, _identification);

        if (!result && _showError)
        {
            error("@WAX1874");
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWarehouseForTemplateType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the warehouse matches for the given wave and wave template, based on the wave template type.
    /// </summary>
    /// <param name = "_whsWaveTemplateType">The wave template type.</param>
    /// <param name = "_waveTemplate">The wave template to validate.</param>
    /// <param name = "_waveTable">The wave to validate.</param>
    /// <param name = "_identification">The corresponding transaction id for the wave.</param>
    /// <returns>true if the warehouse is valid; otherwise, false.</returns>
    protected static boolean validateWarehouseForTemplateType(
        WHSWaveTemplateType  _whsWaveTemplateType,
        WHSWaveTemplateTable _waveTemplate,
        WHSWaveTable         _waveTable,
        str                  _identification)
    {
        InventDim               inventDim;
        InventTrans             inventTrans;
        boolean                 result;

        switch (_whsWaveTemplateType)
        {
            case WHSWaveTemplateType::Shipping:
                WHSShipmentTable shipmentTable = WHSShipmentTable::find(_identification);
                result =    !shipmentTable
                         || !_waveTable.InventLocationId
                         || _waveTable.InventLocationId == shipmentTable.InventLocationId;
                result =    result
                         && (!shipmentTable
                         ||  !_waveTemplate
                         ||  _waveTemplate.validateWaveTemplateWarehouseMatches(shipmentTable.InventLocationId));
                break;

            case WHSWaveTemplateType::Production:
                ProdBOM prodBOM = ProdBOM::findTransId(_identification);
                inventDim = prodBOM.inventDim();
                result =    !prodBOM
                         || !_waveTable.InventLocationId
                         || _waveTable.InventLocationId == inventDim.InventLocationId;
                result =    result
                         && (!prodBOM
                         ||  !_waveTemplate
                         ||  _waveTemplate.validateWaveTemplateWarehouseMatches(inventDim.InventLocationId));
                break;

            case WHSWaveTemplateType::Kanban:
                KanbanJobPickingList kanbanJobPickingList = KanbanJobPickingList::findInventTransId(_identification, inventTrans.DataAreaId);
                inventDim            = kanbanJobPickingList.inventDim();
                result =    !kanbanJobPickingList
                         || !_waveTable.InventLocationId
                         || _waveTable.InventLocationId == inventDim.InventLocationId;
                result =    result
                         && (!kanbanJobPickingList
                         ||  !_waveTemplate
                         ||  _waveTemplate.validateWaveTemplateWarehouseMatches(inventDim.InventLocationId));
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWaveTemplateWarehouseMatches</Name>
				<Source><![CDATA[
    private boolean validateWaveTemplateWarehouseMatches(InventLocationId _warehouseId)
    {
        switch (this.WarehouseGroupAll)
        {
            case WhsWarehouseGroupAll::Warehouse:
                return this.InventLocationId == _warehouseId;

            case WhsWarehouseGroupAll::Group:
                return WhsWarehouseGroup::containsWarehouse(this.WarehouseGroupId, _warehouseId);

            case WhsWarehouseGroupAll::All:
                return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
	/// <summary>
	/// Checks if a specific <c>whsWaveTemplateTable</c> record exists.
	/// </summary>
	/// <param name="_waveTemplateName">
	/// Name of the wave template.
	/// </param>
	/// <returns>
	/// True if the record exists.
	/// </returns>
    public static boolean exist(WHSWaveTemplateName _waveTemplateName)
    {
        return whsWaveTemplateTable::find(_waveTemplateName).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
	/// <summary>
	/// Finds a specific <c>WHSWaveTemplateTable</c> record with given parameters.
	/// </summary>
	/// <param name="_waveTemplateName">
	/// Name of the wave template.
	/// </param>
	/// <param name="_forupdate">
	/// Determines whether the record is selected for update.
	/// </param>
	/// <returns>
	/// The record that is searched for.
	/// </returns>
    public static WHSWaveTemplateTable find(WHSWaveTemplateName _waveTemplateName, boolean _forupdate = false)
    {
        WHSWaveTemplateTable waveTemplateTable;

        if (_waveTemplateName)
        {
            waveTemplateTable.selectForUpdate(_forupdate);

            select firstonly waveTemplateTable
                where waveTemplateTable.WaveTemplateName == _waveTemplateName;
        }

        return waveTemplateTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific <c>WHSWaveTemplateTable</c> record with given rec id.
    /// </summary>
    /// <param name="_waveTemplateTableRecId">
    /// RecId of the wave template.
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    public static WHSWaveTemplateTable findByRecId(WHSWaveTemplateTableRecId _waveTemplateTableRecId, boolean _forupdate = false)
    {
        WHSWaveTemplateTable waveTemplateTable;

        if (_waveTemplateTableRecId)
        {
            waveTemplateTable.selectForUpdate(_forupdate);

            select firstOnly WaveTemplateType from waveTemplateTable
                where waveTemplateTable.RecId == _waveTemplateTableRecId;
        }

        return waveTemplateTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupWaveTemplatesByType</Name>
				<Source><![CDATA[
	/// <summary>
	/// Performs form lookup on <c>WHSWaveTemplateTable</c> by wave template type.
	/// </summary>
	/// <param name="_ctrl">
	/// Form control that lookup belongs to.
	/// </param>
	/// <param name="_templateType">
	/// Type of the wave template.
	/// </param>
    public static void lookupWaveTemplatesByType(
        FormStringControl   _ctrl,
        WHSWaveTemplateType _templateType)
    {
        SysTableLookup          sysTableLookup;
        Query                   query;
        QueryBuildDataSource    qbds;

        sysTableLookup      = SysTableLookup::newParameters(tableNum(WHSWaveTemplateTable), _ctrl);
        query               = new Query();
        qbds                = query.addDataSource(tableNum(WHSWaveTemplateTable));

        sysTableLookup.addLookupfield(fieldNum(WHSWaveTemplateTable, WaveTemplateName));
        sysTableLookup.addLookupfield(fieldNum(WHSWaveTemplateTable, WaveTemplateDesc));
        qbds.addRange(fieldNum(WHSWaveTemplateTable, WaveTemplateType)).value(SysQuery::value(_templateType));

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupWaveTemplatesByTypeAndWarehouse</Name>
				<Source><![CDATA[
	/// <summary>
	/// Performs form lookup on <c>WHSWaveTemplateTable</c> by wave template type and warehouse id.
	/// </summary>
	/// <param name="_ctrl">
	/// Form control that lookup belongs to.
	/// </param>
	/// <param name="_templateType">
	/// Type of the wave template.
	/// </param>
	/// <param name="_inventSiteId">
	/// Site of the warehouse.
	/// </param>
	/// <param name="_inventLocationId">
	/// Id of the warehouse.
	/// </param>
    public static void lookupWaveTemplatesByTypeAndWarehouse(FormStringControl      _ctrl,
                                                             WHSWaveTemplateType    _templateType,
                                                             InventSiteId           _inventSiteId,
                                                             InventLocationId       _inventLocationId)
    {
        SysTableLookup          sysTableLookup;
        Query                   query;
        QueryBuildDataSource    qbds;

        sysTableLookup      = SysTableLookup::newParameters(tableNum(WHSWaveTemplateTable), _ctrl);
        query               = new Query();
        qbds                = query.addDataSource(tableNum(WHSWaveTemplateTable));

        sysTableLookup.addLookupfield(fieldNum(WHSWaveTemplateTable, WaveTemplateName));
        sysTableLookup.addLookupfield(fieldNum(WHSWaveTemplateTable, WaveTemplateDesc));
        qbds.addRange(fieldNum(WHSWaveTemplateTable, WaveTemplateType)).value(SysQuery::value(_templateType));
        qbds.addRange(fieldNum(WHSWaveTemplateTable, InventSiteId)).value(SysQuery::value(_inventSiteId));
        qbds.addRange(fieldNum(WHSWaveTemplateTable, InventLocationId)).value(SysQuery::value(_inventLocationId));

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAllTemplates</Name>
				<Source><![CDATA[
	/// <summary>
	/// Validates all wave templates.
	/// </summary>
    [SysObsolete('Method is replaced by validateandUpdateAllTemplatesValidValue', false, 04\05\2022)]
    public static void validateAllTemplates()
    {
        WHSWaveTemplateTable    templateTable;

        ttsbegin;

        while select forupdate templateTable
        {
            templateTable.Valid = templateTable.validateTemplate();
            
            if (!templateTable.validateWrite())
            {
                throw error(strFmt("@WAX:WHSCannotUpdateRecordInTable", tablePName(WHSWaveTemplateTable)));
            }
            else
            {
                templateTable.update();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAndUpdateAllTemplatesValidValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates all wave templates and updates the Valid field if it is changed.
    /// </summary>
    [Hookable(false)]
    internal static void validateAndUpdateAllTemplatesValidValue()
    {
        WHSWaveTemplateTable    templateTable;

        ttsbegin;

        while select forupdate templateTable
        {
            boolean originalTemplateTableValid = templateTable.Valid;
            
            templateTable.Valid = templateTable.validateTemplate();

            if (originalTemplateTableValid != templateTable.Valid)
            {
                if (!templateTable.validateWrite())
                {
                    throw error(strFmt("@WAX:WHSCannotUpdateRecordInTable", tablePName(WHSWaveTemplateTable)));
                }
                else
                {
                    templateTable.update();
                }
            }

            if (!templateTable.Valid)
            {
                warning(strFmt("@WAX:InvalidWaveTemplateMessage", templateTable.WaveTemplateName));
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWaveTemplate</Name>
				<Source><![CDATA[
	/// <summary>
	/// Validates the template of a wave.
	/// </summary>
	/// <param name="_whsWaveTemplateType">
	/// Type of the template.
	/// </param>
	/// <param name="_waveTable">
	/// Wave record of the template.
	/// </param>
	/// <param name="_identification">
	/// Id of the underlying transaction of the wave.
	/// </param>
	/// <param name="_showError">
	/// Boolean indicating that errors are shown in case of failure.
	/// </param>
	/// <returns>
	/// True if the template is validated.
	/// </returns>
    public static boolean validateWaveTemplate(
        WHSWaveTemplateType _whsWaveTemplateType,
        WHSWaveTable        _waveTable,
        str                 _identification,
        boolean             _showError = false)
    {
        boolean result = true;

        WHSWaveTemplateTable waveTemplate = WHSWaveTemplateTable::find(_waveTable.WaveTemplateName);

        // Make sure waveTemplate is valid
        if (   waveTemplate
            && !waveTemplate.Valid)
        {
            result = false;

            if (_showError)
            {
                error("@WAX3162");
            }
        }

        // Make sure wave template is selected if wave already has one shipment, production BOM or kanban picking list line
        if (   _waveTable.InventLocationId
            && !waveTemplate)
        {
            result = false;

            if (_showError)
            {
                error ("@WAX3254");
            }
        }

        // Validate warehouse
        result =    result
            && WHSWaveTemplateTable::validateWarehouse(_whsWaveTemplateType,waveTemplate,_waveTable,_identification,_showError);

        if (   _waveTable.InventLocationId
            && !waveTemplate.validateWaveTemplateWarehouseMatches(_waveTable.InventLocationId)
            && _waveTable.displayTotalLines())
        {
            result = false;

            if (_showError)
            {
                error("@WAX3255");
            }
        }
		
        if (_waveTable.overThreshold(_showError))
        {
            result = false;
            // Error message generated in called Method
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLocation</Name>
				<Source><![CDATA[
    public InventLocation inventLocation(InventLocation _relatedTable = null)
    {
        if (prmIsDefault(_relatedTable))
        {
            return this.setLink('InventLocation');
        }
        else
        {
            return this.setLink('InventLocation', _relatedTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clear object cache related to the <c>WHSWaveTemplateTable</c> table.
    /// </summary>
    public void clearCache()
    {
        WHSWaveTemplateCachedQuery::newFromCacheKey(WHSWaveTemplateCachedQuery::createCacheKeyForCompany(this.WaveTemplateType, this.InventLocationId, this.InventSiteId, this.company())).expireCache(true);
        WHSWaveTableBuildWaveQueryCache::newFromCacheKey(WHSWaveTableBuildWaveQueryCache::createCacheKeyForCompany(this.WaveTemplateName, this.company())).expireCache(true);
        WHSWaveTemplateValidateAssignmentCache::newFromCacheKey(WHSWaveTemplateValidateAssignmentCache::createCacheKeyForCompany(this.WaveTemplateName, this.company())).expireCache(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWaveAssignment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates wheter a shipment, production or kanban can be assigned to a given wave.
    /// </summary>
    /// <param name="_whsWaveTemplateType">
    /// The type of the wave template.
    /// </param>
    /// <param name="_waveTable">
    /// A buffer of the <c>WHSWaveTable</c> table.
    /// </param>
    /// <param name="_identification">
    /// An ID of the kanban, production or shipment subject to wave assignment.
    /// </param>
    /// <returns>
    /// true if the shipment, production or kanban can be assigned to the wave otherwise; false.
    /// </returns>
    public static boolean validateWaveAssignment(
        WHSWaveTemplateType _whsWaveTemplateType,
        WHSWaveTable        _waveTable,
        str                 _identification)
    {
        WHSWaveTemplateValidateAssignmentCache    assignmentCache =  WHSWaveTemplateValidateAssignmentCache::newFromCacheKey(WHSWaveTemplateValidateAssignmentCache::createCacheKeyForCompany(_waveTable.WaveTemplateName, _waveTable.company()));
        container                                 cacheValue;
        boolean                 ret;

        if (!assignmentCache.hasExpired())
        {
            cacheValue = assignmentCache.cacheValue();
            if (conFind(cacheValue, _waveTable.RecId))
            {
                return false;
            }
        }

        ret = WHSWaveTemplateTable::validateWaveTemplate(_whsWaveTemplateType, _waveTable, _identification);

        if (!ret)
        {
            cacheValue += [_waveTable.RecId];
            assignmentCache.markInCache(cacheValue);
        }

        if (ret)
        {
            ret = _waveTable.validateWaveAssignment(_identification);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWaveAssignment_RemoveIDFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes a record ID frm the cache of waves validated not to be assignable.
    /// </summary>
    /// <param name="_whsWaveTemplateName">
    /// The name of the wave template.
    /// </param>
    /// <param name="_recId">
    /// The record ID to remove from the cache.
    /// </param>
    public static void validateWaveAssignment_RemoveIDFromCache(
        WHSWaveTemplateName _whsWaveTemplateName,
        RefRecId            _recId)
    {
        WHSWaveTemplateValidateAssignmentCache  assignmentCache =  WHSWaveTemplateValidateAssignmentCache::newFromCacheKey(WHSWaveTemplateValidateAssignmentCache::createCacheKeyForCompany(_whsWaveTemplateName));
        container                               cacheValue;
        int                                     conPosition;

        if (!assignmentCache.hasExpired())
        {
            cacheValue = assignmentCache.cacheValue();
            conPosition = conFind(cacheValue, _recId);

            if (conPosition)
            {
                cacheValue = conDel(cacheValue, conPosition, 1);
                assignmentCache.markInCache(cacheValue);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>waveTemplateCachedQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Caches a <c>List</c> object containing wave template quires and other properties used for wave assignment.
    /// </summary>
    /// <param name="_waveTemplateType">
    /// The type of the wave template.
    /// </param>
    /// <param name="_inventLocationId">
    /// The inventory location of the wave template.
    /// </param>
    /// <param name="_inventSiteId">
    /// The inventory site of the wave template.
    /// </param>
    /// <returns>
    /// A <c>List</c> object.
    /// </returns>
    public static List waveTemplateCachedQuery(
        WHSWaveTemplateType     _waveTemplateType,
        InventLocationId        _inventLocationId,
        InventSiteId            _inventSiteId)
    {
        WHSWaveTemplateCachedQuery waveTemplateCachedQuery = WHSWaveTemplateCachedQuery::newFromCacheKey(WHSWaveTemplateCachedQuery::createCacheKeyForCompany(_waveTemplateType, _inventLocationId, _inventSiteId));

        if (!waveTemplateCachedQuery.hasExpired())
        {
            List list = List::create(waveTemplateCachedQuery.cacheValue());
            return list;
        }

        List list = new List(Types::Container);

        WHSWaveTemplateTable waveTemplate;

        while select waveTemplate
            order by waveTemplate.WaveTemplateSequence asc
            where ((waveTemplate.WarehouseGroupAll == WhsWarehouseGroupAll::Warehouse && waveTemplate.InventSiteId == _inventSiteId && waveTemplate.InventLocationId  == _inventLocationId)
                    || (waveTemplate.WarehouseGroupAll == WhsWarehouseGroupAll::Group)
                    || (waveTemplate.WarehouseGroupAll == WhsWarehouseGroupAll::All))
                && waveTemplate.WaveTemplateType   == _waveTemplateType
                &&  (waveTemplate.AutoCreateWave   == NoYes::Yes
                     || waveTemplate.AssignableWave == NoYes::Yes)
                && waveTemplate.Valid              == true
        {
            if (waveTemplate.WarehouseGroupAll == WhsWarehouseGroupAll::Group
                && !WhsWarehouseGroup::containsWarehouse(waveTemplate.WarehouseGroupId, _inventLocationId))
            {
                continue;
            }

            list.addEnd([waveTemplate.WaveTemplateName, waveTemplate.AssignableWave, waveTemplate.WaveTemplateQuery]);
        }

        waveTemplateCachedQuery.markInCache(list.pack());

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasReplenishmentStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current Wave template contains a step for replenishment.
    /// </summary>
    /// <returns>
    /// true if the wave template includes a step for replenishment; otherwise, false.
    /// </returns>
    public boolean hasReplenishmentStep()
    {
        // Check based on the template type in the subclasses
        return WHSWaveTemplate::newFromWaveTemplateTable(this).hasReplenishmentStep();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasGrouping</Name>
				<Source><![CDATA[
    private boolean hasGrouping()
    {
        return (select firstOnly RecId from WHSWaveTemplateGroup
					where WHSWaveTemplateGroup.WaveTemplate == this.RecId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWaveTemplateGrouping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether a shipment can be added to a wave based on the grouping setup on the wave template.
    /// </summary>
    /// <param name="_waveTable">
    /// A wave used to find a the shipment record to compare against.
    /// </param>
    /// <param name="_shipmentId">
    /// A Shipment Id of a shipment to compare against the shipments on a wave.
    /// </param>
    /// <returns>
    /// True if the shipment can be assigned to the wave, otherwise; false
    /// </returns>
    internal static boolean validateWaveTemplateGrouping(
        WHSWaveTable	    _waveTable,
        WHSShipmentId	    _shipmentId)
    {
        boolean validWave = true;
        WHSWaveTemplateTable    waveTemplateTable = _waveTable.waveTemplate();

        if (waveTemplateTable.WaveTemplateType != WHSWaveTemplateType::Shipping)
        {
            return validWave;
        }

        if (!_shipmentId)
        {
            return validWave;
        }

        boolean hasGrouping = waveTemplateTable.hasGrouping();

        WHSInstrumentationLogger instrumentationLogger = WHSInstrumentationLogger::createLogger(tableStr(WHSWaveTemplateTable));

        using (var activityContext = instrumentationLogger.waveAssignmentActivities().validateWaveTemplateGrouping(hasGrouping))
        {
            Counter lineCounter;

            instrumentationLogger.logRecordInformation(waveTemplateTable);

            if (hasGrouping)
            {
                // Get existing shipment from wave to compare break fields
                WHSShipmentTable    existingShipmentTable;
                WHSWaveLine         waveLine;

                select firstOnly existingShipmentTable
                    exists join waveLine
                    where waveLine.ShipmentId   == existingShipmentTable.ShipmentId &&
                          waveLine.WaveId       == _waveTable.WaveId;
    
                // Loop through break fields and compare with existing shipment on wave (only if existing wave line)
                if (existingShipmentTable.RecId)
                {
                    WHSWaveTemplateGroup    waveTemplateGroup;
                    WHSShipmentTable        newShipmentTable = WHSShipmentTable::find(_shipmentId);

                    Query templateQuery = new Query(waveTemplateTable.WaveTemplateQuery);

                    lineCounter = WHSWaveTemplateTable::addGroupingsToQuery(templateQuery, waveTemplateTable.RecId, existingShipmentTable.RecId, newShipmentTable.RecId);

                    if (lineCounter)
                    {
                        QueryRun queryRun = new QueryRun(templateQuery);
                        queryRun.next();
                        //if 2 shipments were not grouped
                        if (queryRun.get(tableNum(WHSShipmentTable)).RecId == 1)
                        {
                            validWave = false;
                        }
                    }
                }
            }

            instrumentationLogger.waveAssignmentActivities().validatedWaveTemplateGrouping(activityContext, validWave, lineCounter);
        }
   
        return validWave;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addGroupingsToQuery</Name>
				<Source><![CDATA[
    private static Counter addGroupingsToQuery(
        Query _templateQuery, 
        RefRecId _waveTemplateTableRecId, 
        RefRecId _existingShipmentTableRecId,
        RefRecId _newShipmentTableRecId)
    {     
        QueryBuildDataSource shipmentQBDS = _templateQuery.dataSourceTable(tableNum(WHSShipmentTable));

        if (!shipmentQBDS)
        {
            throw error("@SYS104799");
        }

        shipmentQBDS.addRange(fieldNum(WHSShipmentTable, RecId)).value(queryValue(_existingShipmentTableRecId));
        shipmentQBDS.addRange(fieldNum(WHSShipmentTable, RecId)).value(queryValue(_newShipmentTableRecId));

        shipmentQBDS.addSelectionField(fieldNum(WHSShipmentTable, RecId), SelectionField::Count);

        WHSWaveTemplateGroup waveTemplateGroup;
        Counter lineCounter;

        while select GroupFieldId, GroupTableId from waveTemplateGroup
            order by waveTemplateGroup.LineNumber
            where waveTemplateGroup.WaveTemplate == _waveTemplateTableRecId
                && waveTemplateGroup.WaveGroupBy == NoYes::Yes
        {
            lineCounter++;

            _templateQuery.dataSourceTable(waveTemplateGroup.GroupTableId).addGroupByField(waveTemplateGroup.GroupFieldId);
        }

        return lineCounter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    [Hookable(false)]
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSequenceNumber</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void initSequenceNumber()
    {
        WHSWaveTemplateTable waveTemplate;

        select maxof(WaveTemplateSequence) from waveTemplate
            where waveTemplate.WaveTemplateType == this.WaveTemplateType;

        this.WaveTemplateSequence = waveTemplate.WaveTemplateSequence + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWarehouseSelection</Name>
				<Source><![CDATA[
    private void setWarehouseSelection()
    {
        switch (this.WarehouseGroupAll)
        {
            case WhsWarehouseGroupAll::All:
                this.InventLocationId = '';
                this.InventSiteId = '';
                this.WarehouseGroupId = '';
                break;

            case WhsWarehouseGroupAll::Group:
                this.InventLocationId = '';
                this.InventSiteId = '';
                break;

            case WhsWarehouseGroupAll::Warehouse:
                this.WarehouseGroupId = '';
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();

        this.WarehouseGroupAll = WhsWarehouseGroupAll::All;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>WHSandTMS</ConfigurationKey>
	<DeveloperDocumentation>@WAX4478</DeveloperDocumentation>
	<FormRef>WHSWaveTemplateTable</FormRef>
	<Label>@WAX3059</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>WaveTemplateSequence</TitleField1>
	<TitleField2>WaveTemplateName</TitleField2>
	<CacheLookup>FoundAndEmpty</CacheLookup>
	<ClusteredIndex>TemplateNameIdx</ClusteredIndex>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Inventory</Modules>
	<PrimaryIndex>TemplateNameIdx</PrimaryIndex>
	<ReplacementKey>TemplateNameIdx</ReplacementKey>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>WHSWaveTemplateLine</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>WHSWaveTemplateLine</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateDesc</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoReleaseWave</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventSiteId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveAttributeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveMaxWeight</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateQuery</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Valid</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoExecuteWaveAtLoadPost</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoCreateWave</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveShipmentLimit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveLineThreshold</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoExecuteWaveAtThreshold</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AssignableWave</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoReleaseReplenWork</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCreateOnReservationFailure</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateName</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@WAX2277</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateDesc</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoReleaseWave</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventSiteId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveAttributeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveMaxWeight</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateQuery</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Valid</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoExecuteWaveAtLoadPost</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoCreateWave</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveShipmentLimit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveLineThreshold</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoExecuteWaveAtThreshold</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AssignableWave</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoReleaseReplenWork</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCreateOnReservationFailure</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Notifications</Name>
			<Label>@WAX:WaveExecutionNotifications</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WaveNotificationPolicy</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AssignableWave</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSAssignableWave</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AutoCreateWave</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSAutoCreateWave</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AutoExecuteWaveAtLoadPost</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSAutoExecuteWaveAtLoadPost</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AutoExecuteWaveAtThreshold</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSAutoExecuteWaveAtThreshold</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AutoReleaseReplenWork</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSAutoReleaseReplenWork</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AutoReleaseWave</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSAutoReleaseWave</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventLocationId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventLocationId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventSiteId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventSiteId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Valid</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Valid</ExtendedDataType>
			<EnumType>boolean</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WaveAttributeCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveAttributeCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>WaveLineThreshold</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveLineThreshold</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>WaveMaxWeight</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveMaxWeight</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>WaveShipmentLimit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveShipmentLimit</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WaveTemplateDesc</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveTemplateDesc</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WaveTemplateName</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveTemplateName</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldContainer">
			<Name>WaveTemplateQuery</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveTemplateQuery</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>WaveTemplateSequence</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveTemplateSequence</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WaveTemplateType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<Mandatory>Yes</Mandatory>
			<EnumType>WHSWaveTemplateType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkCreateOnReservationFailure</Name>
			<ExtendedDataType>WHSWorkCreateOnReservationFailure</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>WaveNotificationPolicy</Name>
			<ExtendedDataType>WhsWaveNotificationPolicyRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WarehouseGroupAll</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>WhsWarehouseGroupAll</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WarehouseGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WhsWarehouseGroupId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TemplateSequenceTypeIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>WaveTemplateType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WaveTemplateSequence</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TemplateNameIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>WaveTemplateName</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WarehouseGroupIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>WarehouseGroupId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>InventStorageDimMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>InventSiteId</MapField>
					<MapFieldTo>InventSiteId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventLocationId</MapField>
					<MapFieldTo>InventLocationId</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventLocation</Name>
			<Cardinality>ZeroMore</Cardinality>
			<CreateNavigationPropertyMethods>Yes</CreateNavigationPropertyMethods>
			<EDTRelation>Yes</EDTRelation>
			<NavigationPropertyMethodNameOverride>inventLocation</NavigationPropertyMethodNameOverride>
			<RelatedTable>InventLocation</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>InventLocation</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventLocationId</Name>
					<SourceEDT>InventLocationId</SourceEDT>
					<Field>InventLocationId</Field>
					<RelatedField>InventLocationId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventLocationIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventSite</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventSite</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventSiteId</Name>
					<SourceEDT>InventSiteId</SourceEDT>
					<Field>InventSiteId</Field>
					<RelatedField>SiteId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>SiteIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WaveAttributeCode1</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWaveAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute1</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveAttributeCode</Name>
					<Field>WaveAttributeCode[1]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WaveAttributeCode2</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWaveAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code2</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute2</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveAttributeCode</Name>
					<Field>WaveAttributeCode[2]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WaveAttributeCode3</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWaveAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code3</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute3</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveAttributeCode</Name>
					<Field>WaveAttributeCode[3]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WaveAttributeCode4</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWaveAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code4</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute4</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveAttributeCode</Name>
					<Field>WaveAttributeCode[4]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WhsWaveNotificationPolicy</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WhsWaveNotificationPolicy</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveNotificationPolicy</Name>
					<Field>WaveNotificationPolicy</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WhsWarehouseGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>WhsWarehouseGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WarehouseGroupId</Name>
					<Field>WarehouseGroupId</Field>
					<RelatedField>WarehouseGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>