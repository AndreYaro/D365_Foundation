<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSProdTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class WHSProdTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        if (!WHSProdTable::exist(this.ProdId))
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickReservedQuantity</Name>
				<Source><![CDATA[
    protected static InventHandlingQty pickReservedQuantity(InventTable   _rawMaterialInventTable,
                                                          InventDim     _inventDim,
                                                          ProdBOM       _prodBOM,
                                                          InventQty     _qtyToPick,
                                                          boolean       _isCWItem)
    {
        InventHandlingQty         runningQty = _qtyToPick;
        InventDimParm             inventDimParmCriteria;
                
        inventDimParmCriteria.initFromInventDim(_inventDim);
        
        InventTransOriginId inventTransOriginId = InventTransOriginProdBOM::findInventTransOriginId(_prodBOM.DataAreaId, _prodBOM.InventTransId);
        List reservationHierarchyPartList = WhsReservationHierarchyProvider::construct().getDimListAllFromInventTable(_rawMaterialInventTable, WHSReservationHierarchySortOrder::BottomUp);
        InventTrans inventTrans;
        InventDim inventDimForReservedQty;

        boolean reservedQtyExists = _prodBOM.qtyInventReserved();

        while select Qty, PdsCWQty from inventTrans
            where inventTrans.InventTransOrigin  == inventTransOriginId
                && inventTrans.StatusIssue       == StatusIssue::ReservPhysical
                && inventTrans.StatusReceipt     == StatusReceipt::None
            #InventDimInnerJoin(inventTrans.inventDimId, inventDimForReservedQty, _inventDim, inventDimParmCriteria)
        {
            boolean inventTransHasAllDimsOfHierarchy =
                !WhsReservationHierarchyInventDimUtil::inventDimHasNotAllowedBlankValues(
                    inventDimForReservedQty,
                    reservationHierarchyPartList,
                    InventDimGroupSetup::newInventTable(_rawMaterialInventTable));
            if (inventTransHasAllDimsOfHierarchy)
            {
                // qty on the inventTrans is negative
                InventHandlingQty tmpInventHandlingQty;
                
                using (var context = WhsInventPickingContext::newSkipPickIdAllocation())
                {
                    if (_isCWItem)
                    {
                        tmpInventHandlingQty = min(runningQty, -1 * inventTrans.PdsCWQty);
                        InventQty weightToPickCW = WHSCatchWeightHelper::calculateAverageWeight(tmpInventHandlingQty, abs(inventTrans.PdsCWQty), abs(inventTrans.Qty), InventTable::inventDecimals(_prodBOM.ItemId));

                        InventDimParm inventDimParmForReservedQty;

                        inventDimParmForReservedQty.initFromInventDim(inventDimForReservedQty);

                        WHSInvent::pickQuantities(_prodBOM, inventDimForReservedQty.InventDimId, weightToPickCW, tmpInventHandlingQty, inventDimParmForReservedQty);
                     
                    }
                    else
                    {
                        tmpInventHandlingQty = min(runningQty, -1 * inventTrans.Qty);
                    
                        
                        InventDimParm inventDimParmForReservedQty;

                        inventDimParmForReservedQty.initFromInventDim(inventDimForReservedQty);

                        WHSInvent::pickQuantities(_prodBOM, inventDimForReservedQty.InventDimId, tmpInventHandlingQty, 0, inventDimParmForReservedQty);
                      
                    }
                }
                runningQty -= tmpInventHandlingQty;
            }
        }

        if (reservedQtyExists && runningQty != 0)
        {
            WHSProdTable::checkReservedQuantityCouldNotBePicked(_prodBOM);
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReservedQuantityCouldNotBePicked</Name>
				<Source><![CDATA[
    private static void checkReservedQuantityCouldNotBePicked(ProdBOM _prodBOM)
    {
        WHSRunningFromRAFContext context = WHSRunningFromRAFContext::current();

        if (context
            && _prodBOM.inventDim().inventLocation().WHSProdOrderBackflushMustUseReservedQty
            && _prodBOM.qtyInventReserved())
        {
            error ("@WAX:WHSProdOrderBackflushQtyCannotBePicked");
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickNotReservedQuantities</Name>
				<Source><![CDATA[
    private static void pickNotReservedQuantities(
        WHSInventOnHandCollectionEnumerator _onHandCollectionEnumerator,
        InventTable                         _rawMaterialInventTable,
        ProdBOM                             _prodBOM,
        InventQty                           _qtyToPick,
        boolean                             _allowNegative,
        boolean                             _isCWItem,
        CreatedTransactionId                _ttsId)
    {
        InventHandlingQty runningQty = _qtyToPick;
        InventDimParm     inventDimParmAboveLocation;

        while (runningQty > 0 && _onHandCollectionEnumerator.moveNext())
        {
            WHSInventOnHandData whsInventOnHandData = _onHandCollectionEnumerator.current();
            InventDim inventDim = inventDim::findOrCreate(whsInventOnHandData.parmInventDim());
            InventHandlingQty workCenterAvailQty;

            // Negative items only need to consider batch level inventory
            if (_allowNegative)
            {
                workCenterAvailQty = whsInventOnHand::getPhysicalAvailHandlingQty(_rawMaterialInventTable.ItemId,
                                                                                inventDim,
                                                                                true,
                                                                                false);
            }
            else    // Non-negative items need to look for location level reservation as well.
            {
                InventHandlingQty maxAvailQty, maxOrderedQty;
                [maxAvailQty, maxOrderedQty] = WHSInventOnHand::getReserveAvailHandlingQtyIncludeDelta(_rawMaterialInventTable.ItemId,
                                                                                                    inventDim,
                                                                                                    _ttsId,
                                                                                                    false,
                                                                                                    false);
                workCenterAvailQty = maxAvailQty;
            }
            
            InventHandlingQty tmpInventHandlingQty;

            if (workCenterAvailQty > runningQty)
            {
                tmpInventHandlingQty = runningQty;
                runningQty = 0;
            }
            else
            {
                tmpInventHandlingQty = workCenterAvailQty;
                runningQty -= tmpInventHandlingQty;
            }

            // Pick
            using (var context = WhsInventPickingContext::newSkipPickIdAllocation())
            {
                if (_isCWItem)
                {
                    InventQty weightToPickCW = WHSCatchWeightHelper::calculateAverageWeight(tmpInventHandlingQty, whsInventOnHandData.parmCWAvailPhysical(), whsInventOnHandData.parmAvailPhysical(), InventTable::inventDecimals(_prodBOM.ItemId));
                    WHSInvent::pickQuantities(_prodBOM, inventDim.InventDimId, weightToPickCW, tmpInventHandlingQty, inventDimParmAboveLocation);
                }
                else
                {
                    WHSInvent::pickQuantities(_prodBOM, inventDim.InventDimId, tmpInventHandlingQty, 0, inventDimParmAboveLocation);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickTrackingDimensionQuantities</Name>
				<Source><![CDATA[
    private static void pickTrackingDimensionQuantities(
        WHSInventOnHandCollectionEnumerator _onHandCollectionEnumerator,
        InventTable                         _rawMaterialInventTable,
        InventDim                           _inventDim,
        ProdBOM                             _prodBOM,
        InventQty                           _qtyToPick,
        boolean                             _allowNegative,
        CreatedTransactionId                _ttsId)
    {
        if (_qtyToPick <= 0)
        {
            return;
        }

        boolean isCWItem = PdsGlobal::pdsIsCWItem(_rawMaterialInventTable.ItemId);

        InventHandlingQty runningQty = WHSProdTable::pickReservedQuantity(_rawMaterialInventTable,
                                                                         _inventDim,
                                                                         _prodBOM,
                                                                         _qtyToPick,
                                                                         isCWItem);

        if (runningQty <= 0)
        {
            return;
        }

        WHSProdTable::pickNotReservedQuantities(_onHandCollectionEnumerator,
                                                _rawMaterialInventTable,
                                                _prodBOM,
                                                runningQty,
                                                _allowNegative,
                                                isCWItem,
                                                _ttsId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickBatchQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks the batch quantities to be consumed from physical inventory.
    /// </summary>
    /// <param name = "_rawMaterialInventTable">The raw material.</param>
    /// <param name = "_inventDim">The inventory dimensions</param>
    /// <param name = "_prodBOM">The production bill of material.</param>
    /// <param name = "_qtyToPick">The quantity to pick.</param>
    /// <param name = "_allowNegative">A Boolean value indicating if negative inventory is allowed.</param>
    [Hookable(false)]
    public static void pickBatchQuantities(
        InventTable             _rawMaterialInventTable,
        InventDim               _inventDim,
        ProdBOM                 _prodBOM,
        InventQty               _qtyToPick,
        boolean                 _allowNegative)
    {
        CreatedTransactionId ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();
        var onHandCollectionMgt = ProdWhsInventBatchOnHandCollectionManagement::newFromParameters(_rawMaterialInventTable, _inventDim, ttsId);
        WHSInventOnHandCollectionEnumerator whsInventOnHandCollectionEnumerator = onHandCollectionMgt.getEnumeratorForDeepestHierarchyLevel();

        WHSProdTable::pickTrackingDimensionQuantities(whsInventOnHandCollectionEnumerator,
                                                        _rawMaterialInventTable,
                                                        _inventDim,
                                                        _prodBOM,
                                                        _qtyToPick,
                                                        _allowNegative,
                                                        ttsId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickOwnerQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks the owner quantities to be consumed from physical inventory.
    /// </summary>
    /// <param name = "_rawMaterialInventTable">The raw material.</param>
    /// <param name = "_inventDim">The inventory dimensions</param>
    /// <param name = "_prodBOM">The production bill of material.</param>
    /// <param name = "_qtyToPick">The quantity to pick.</param>
    /// <param name = "_allowNegative">A Boolean value indicating if negative inventory is allowed.</param>
    internal static void pickOwnerQuantities(
        InventTable             _rawMaterialInventTable,
        InventDim               _inventDim,
        ProdBOM                 _prodBOM,
        InventQty               _qtyToPick,
        boolean                 _allowNegative)
    {
        CreatedTransactionId ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();
        var onHandCollectionMgt = ProdWhsInventOwnerOnHandCollectionManagement::newFromParameters(_rawMaterialInventTable, _inventDim, ttsId);
        WHSInventOnHandCollectionEnumerator whsInventOnHandCollectionEnumerator = onHandCollectionMgt.getEnumeratorForDeepestHierarchyLevel();

        WHSProdTable::pickTrackingDimensionQuantities(whsInventOnHandCollectionEnumerator,
                                                        _rawMaterialInventTable,
                                                        _inventDim,
                                                        _prodBOM,
                                                        _qtyToPick,
                                                        _allowNegative,
                                                        ttsId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickSerialQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks the serial quantities to be consumed from physical inventory.
    /// </summary>
    /// <param name = "_rawMaterialInventTable">The raw material.</param>
    /// <param name = "_inventDim">The inventory dimensions</param>
    /// <param name = "_prodBOM">The production bill of material.</param>
    /// <param name = "_qtyToPick">The quantity to pick.</param>
    /// <param name = "_allowNegative">A Boolean value indicating if negative inventory is allowed.</param>
    internal static void pickSerialQuantities(
        InventTable             _rawMaterialInventTable,
        InventDim               _inventDim,
        ProdBOM                 _prodBOM,
        InventQty               _qtyToPick,
        boolean                 _allowNegative)
    {
        CreatedTransactionId ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();
        var onHandCollectionMgt = ProdWhsInventSerialOnHandCollectionManagement::newFromParameters(_rawMaterialInventTable, _inventDim, ttsId);
        WHSInventOnHandCollectionEnumerator whsInventOnHandCollectionEnumerator = onHandCollectionMgt.getEnumeratorForDeepestHierarchyLevel();

        WHSProdTable::pickTrackingDimensionQuantities(whsInventOnHandCollectionEnumerator,
                                                        _rawMaterialInventTable,
                                                        _inventDim,
                                                        _prodBOM,
                                                        _qtyToPick,
                                                        _allowNegative,
                                                        ttsId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromProdTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a <c>WHSProdTable</c> record.
    /// </summary>
    /// <param name="_prodTable">
    /// The <c>ProdTable</c> record.
    /// </param>
    /// <returns>
    /// The created <c>WHSProdTable</c> record.
    /// </returns>
    public static WHSProdTable createFromProdTable(ProdTable _prodTable)
    {
        WHSProdTable    whsProdTable;

        if (_prodTable.RecId != 0 && !WHSProdTable::exist(_prodTable.ProdId) && WHSInventEnabled::exist(_prodTable.ItemId))
        {
            ttsbegin;

            whsProdTable.ProdId     = _prodTable.ProdId;
            whsProdTable.ProdQty    = WHSInventTable::find(_prodTable.ItemId).ProdQty;
            whsProdTable.insert();

            ttscommit;
        }

        return whsProdTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a specific <c>WHSProdTable</c> record exists.
    /// </summary>
    /// <param name="_prodId">
    /// Id of the record.
    /// </param>
    /// <returns>
    /// True if the record exists.
    /// </returns>
    static boolean exist(ProdId _prodId)
    {
        WHSProdTable whsProdTable;

        // isTmp() call on the buffer is used to check if the table
        // configuration key is enabled.
        return  _prodId && !whsProdTable.isTmp() &&
                (select firstonly whsProdTable
                 where whsprodTable.ProdId == _prodId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific <c>WHSProdTable</c> record with given parameters.
    /// </summary>
    /// <param name="_prodId">
    /// Id of the record.
    /// </param>
    /// <param name="_forUpdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    static WHSProdTable find(ProdId      _prodId,
                             boolean     _forUpdate = false)
    {
        WHSProdTable whsProdTable;

        // isTmp() call on the buffer is used to check if the table
        // configuration key is enabled.
        if (_prodId && !whsProdTable.isTmp())
        {
            whsProdTable.selectForUpdate(_forUpdate);

            select firstonly whsProdTable
                where whsProdTable.ProdId == _prodId;
        }

        return whsProdTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkCenterFromProdId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resource for a production or batch order and operation
    /// </summary>
    /// <param name="_prodId">
    /// Id of the production or batch order
    /// </param>
    /// <param name="_oprNum">
    /// Operation no. for which resource should be found; optional
    /// </param>
    /// <returns>
    /// Resource record for the given parameters
    /// </returns>
    public static WrkCtrTable getWorkCenterFromProdId(ProdId _prodId, OprNum _oprNum = 0)
    {
        ProdRoute       prodRoute;
        WrkCtrTable     wrkCtrTable;

        if (_oprNum == 0)
        {
            select firstonly prodRoute
                where prodRoute.ProdId      == _prodId  &&
                      prodRoute.OprPriority == RouteOprPriority::Primary;
        }
        else
        {
            select firstonly prodRoute
                where prodRoute.ProdId      == _prodId  &&
                      prodRoute.OprNum      == _oprNum  &&
                      prodRoute.OprPriority == RouteOprPriority::Primary;
        }

        wrkCtrTable = prodRoute.getResource(true, false, dateNull(), maxDate(), ProdTable::find(_prodId).inventDim().InventSiteId, false, true);

        return wrkCtrTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkCenterWMSLocationFromProdId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resource location table for a production or batch order and operation
    /// </summary>
    /// <param name="_prodId">
    /// Id of the production or batch order
    /// </param>
    /// <param name="_oprNum">
    /// Operation no. for which resource location should be found; optional
    /// </param>
    /// <param name="_inventDimId">
    /// Inventory dimension for which resource location should be found; optional
    /// </param>
    /// <returns>
    /// Resource record for the given parameters
    /// </returns>
    /// <remarks>
    /// If no resource is found, or the resource does not have input location, then the warehouse production input location is returned
    /// </remarks>
    public static WMSLocation getWorkCenterWMSLocationFromProdId(ProdId _prodId, OprNum _oprNum = 0, InventDimId _inventDimId = '')
    {
        ProdRoute        prodRoute;
        WrkCtrTable      wrkCtrTable;
        
        [wrkCtrTable, prodRoute] = WHSProdTable::getWrkCtrTableAndProdRouteFromProdId(_prodId, _oprNum);
        WMSLocation wmsLocation = wrkCtrTable.inputWMSLocation(prodRoute.FromDate ? prodRoute.FromDate :  DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        if (!wmsLocation)
        {
            InventLocationId inventLocationId = InventDim::find(_inventDimId).InventLocationId;
            WMSLocationId wmsLocationId = InventLocation::find(inventLocationId).DefaultProductionInputLocation;
            wmsLocation = WMSLocation::find(wmsLocationId, inventLocationId);
        }

        return wmsLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWrkCtrTableAndProdRouteFromProdId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resource for a production or batch order and operation
    /// </summary>
    /// <param name = "_prodId">
    /// Id of the production or batch order
    /// </param>
    /// <param name = "_oprNum">
    /// Operation no. for which resource should be found; optional
    /// </param>
    /// <returns>
    /// Resource record and prodroute for the given parameters
    /// </returns>
    public static container getWrkCtrTableAndProdRouteFromProdId(ProdId _prodId, OprNum _oprNum = 0)
    {
        ProdRoute   prodRoute;

        if (_oprNum == 0)
        {
            select firstonly prodRoute
                where prodRoute.ProdId      == _prodId  &&
                      prodRoute.OprPriority == RouteOprPriority::Primary;
        }
        else
        {
            select firstonly prodRoute
                where prodRoute.ProdId      == _prodId  &&
                      prodRoute.OprNum      == _oprNum  &&
                      prodRoute.OprPriority == RouteOprPriority::Primary;
        }

        WrkCtrTable wrkCtrTable = prodRoute.getResource(true, false, dateNull(), maxDate(), ProdTable::find(_prodId).inventDim().InventSiteId, false, true);
        
        return [wrkCtrTable, prodRoute];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkCenterLocationFromProdId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resource location for a production or batch order and operation
    /// </summary>
    /// <param name="_prodId">
    /// Id of the production or batch order
    /// </param>
    /// <param name="_oprNum">
    /// Operation no. for which resource location should be found; optional
    /// </param>
    /// <param name="_inventDimId">
    /// Inventory dimension for which resource location should be found; optional
    /// </param>
    /// <returns>
    /// Resource record for the given parameters
    /// </returns>
    /// <remarks>
    /// If no resource is found, or the resource does not have input location, then the warehouse production input location is returned
    /// </remarks>
    public static WMSLocationId getWorkCenterLocationFromProdId(ProdId _prodId, OprNum _oprNum = 0, InventDimId _inventDimId = '')
    {
        ProdRoute       prodRoute;
        WrkCtrTable     wrkCtrTable;

        [WrkCtrTable, prodRoute] = WHSProdTable::getWrkCtrTableAndProdRouteFromProdId(_prodId, _oprNum);

        if (!wrkCtrTable.RecId && prodRoute.RecId)
        {
            wrkCtrTable = prodRoute.getResource(true, true, dateNull(), maxDate(), ProdTable::find(_prodId).inventDim().InventSiteId, false, true);
        }

        InventDim inventDim;
        if (_inventDimId)
        {
            inventDim = InventDim::find(_inventDimId);
        }
        else
        {
            inventDim = ProdTable::find(_prodId).inventDim();
        }

        WMSLocation    inputWMSLocation = wrkCtrTable.inputWMSLocation(prodRoute.FromDate ? prodRoute.FromDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        InventLocation warehouse = inventDim.inventLocation();
        WMSLocationId  wmsLocationId;

        if (inputWMSLocation && (!warehouse || inputWMSLocation.inventLocationId == warehouse.InventLocationId))
        {
            wmsLocationId = inputWMSLocation.wmsLocationId;
        }
        else
        {
            wmsLocationId = warehouse.DefaultProductionInputLocation;
        }

        return wmsLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkCompleteForProdOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether all work items for a production order pick are completed or not.
    /// </summary>
    /// <param name="_orderNum">
    /// The parameter of type <c>WHSOrderNum</c>.
    /// </param>
    /// <returns>
    /// True if all work items for a production order are completed.
    /// </returns>
    static boolean isWorkCompleteForProdOrder(WHSOrderNum _orderNum)
    {
        WHSWorkTable        workTable;

        if (_orderNum)
        {
            select firstonly RecId from workTable
                where workTable.OrderNum         == _orderNum                    &&
                      workTable.WorkTransType    == WHSWorkTransType::ProdPick   &&
                      workTable.WorkStatus       <  WHSWorkStatus::Closed;
        }

        return workTable.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCanPickMore</Name>
				<Source><![CDATA[
    private static boolean checkCanPickMore(
        ProdBOM     _prodBom,
        InventDim   _inventDimWorkCenter,
        InventQty   _inventQtyToPick,
        ProdId      _prodId)
    {
        boolean result = true;
        boolean limitOnHandCheckToDimensionsBelowLocation = false;
        boolean mustDoOnHandCheck = true;

        boolean isCWItem = PdsGlobal::pdsIsCWItem(_prodBom.ItemId);

        //if the prodBom is set to autoreserve the update we did of the extra quantity will have triggered a reservation. So we need to determine if we need to do the on-hand check and on which dimensions to do it on.
        if (_prodBom.mustBeAutoReserved())
        {
            InventDim inventDimProdBom = _prodBom.inventDim();

            if (!inventDimProdBom.wmsLocationId)
            {
                //the prodbom does not have location so its reservation will be on higher levels so we just need check on-hand on the location and below
                limitOnHandCheckToDimensionsBelowLocation = true;
            }
            else
            {
                //Settings on inventLocation or customizations can have caused the reservation to be done on warehouse level even though the location was specified.
                //Hence we just go directly to inventtrans to see if we have full reservation
                InventDimParm inventDimParm;
                inventDimParm.initFromInventDim(inventDimProdBom);
                //no need to do on-hand check if we have full reservation
                InventTransIdSum inventTransIdSum = InventTransIdSum::newTransOriginIdDimension(InventTransOriginProdBOM::findInventTransOriginId(_prodBom.dataAreaId, _prodBom.InventTransId), inventDimProdBom, inventDimParm);
                InventHandlingQty qtyReserved;
                if (isCWItem)
                {
                    qtyReserved = -inventTransIdSum.pdsCWReservPhysical();
                }
                else
                {
                    qtyReserved = -inventTransIdSum.reservPhysical();
                }

                if (_inventQtyToPick == qtyReserved)
                {
                    mustDoOnHandCheck = false;
                }
            }
        }

        if (mustDoOnHandCheck)
        {
            InventTrans         nonPickedInventTrans;
            InventTransOrigin   inventTransOrigin;

            // Get Qty that has been physically reserved at the work center
            // This is specific to a backflushing scenario where the warehouse policy is set to reserve raw material at input location and pick/put work was generated
            select sum(Qty), sum(PdsCWQty) from nonPickedInventTrans
                    join ReferenceId from inventTransOrigin
                    where nonPickedInventTrans.InventTransOrigin     == inventTransOrigin.RecId
                        && nonPickedInventTrans.StatusIssue          == StatusIssue::ReservPhysical
                        && nonPickedInventTrans.InventDimId          == _inventDimWorkCenter.InventDimId
                        && nonPickedInventTrans.ItemId               == _prodBom.ItemId
                        && inventTransOrigin.ReferenceId             == _prodId;

            InventHandlingQty workCenterAvailQty = WHSInventOnHand::getPhysicalAvailHandlingQty(_prodBOM.ItemId, _inventDimWorkCenter, true, limitOnHandCheckToDimensionsBelowLocation);
            
            if ((isCWItem 
                && -nonPickedInventTrans.PdsCWQty + workCenterAvailQty < _inventQtyToPick)
                || -nonPickedInventTrans.Qty + workCenterAvailQty < _inventQtyToPick)
            {
                result = false;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickMoreHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluates if item is a WHS CW item and chooses the correct method calls that, Picks the quantities in addition to what was picked before for a production order, based on the new finished goods quantity.
    /// </summary>
    /// <param name = "_prodId">The production order id</param>
    /// <param name = "_handlingQty">The handling quantity being Reported as Finished, supports catch weight.</param>
    /// <param name = "_fromOprNum">The operation number from where the reporting as finished starts</param>
    /// <param name = "_toOprNum">The operation number where the reporting as finished ends</param>
    /// <param name = "_pickPerFlushingPrinciple">Flag to guide if the picking needs to be made according to the flushing principle of the <c>ProdBOM</c> record</param>
    /// <param name = "_endJob">'End job' parameter is needed for the 'Physical reduction' dependency</param>
    /// <param name = "_flushingPrinciple">The flushing principle against which the item should be consumed</param>
    /// <param name = "_postNow">Determines if the picking list journal should be posted.</param>
    /// <returns>True if extra quantities were picked; false otherwise.</returns>
    [Hookable(false)]
    public static boolean pickMoreHandlingQty(
                ProdId                  _prodId,
                InventHandlingQty       _handlingQty,
                OprNumFrom              _fromOprNum = 0,
                OprNumTo                _toOprNum   = 0,
                boolean                 _pickPerFlushingPrinciple = true,
                boolean                 _endJob = false,
                ProdFlushingPrincipBOM  _flushingPrinciple = ProdFlushingPrincipBOM::Finish,
                boolean					_postNow = true)
    {
        ProdTable prodTable = ProdTable::find(_prodId);

        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), prodTable.ItemId))
        {
            return WHSProdTable::pickMoreQuantities(_prodId,
                                        _handlingQty,
                                        _fromOprNum,
                                        _toOprNum,
                                        _pickPerFlushingPrinciple,
                                        _endJob,
                                        _flushingPrinciple,
                                        _postNow);
        }
        else
        {
            return WHSProdTable::pickMore(_prodId, 
                                    _handlingQty,
                                    _fromOprNum, 
                                    _toOprNum, 
                                    _pickPerFlushingPrinciple, 
                                    _endJob, 
                                    _flushingPrinciple, 
                                    _postNow);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickMore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks the quantities in addition to what was picked before for a production order, based on the new finished goods quantity.
    /// </summary>
    /// <param name = "_prodId">The production order id</param>
    /// <param name = "_inventQty">The quantity being Reported as Finished</param>
    /// <param name = "_fromOprNum">The operation number from where the reporting as finished starts</param>
    /// <param name = "_toOprNum">The operation number where the reporting as finished ends</param>
    /// <param name = "_pickPerFlushingPrinciple">Flag to guide if the picking needs to be made according to the flushing principle of the <c>ProdBOM</c> record</param>
    /// <param name = "_endJob">'End job' parameter is needed for the 'Physical reduction' dependency</param>
    /// <param name = "_flushingPrinciple">The flushing principle against which the item should be consumed</param>
    /// <param name = "_postNow">Determines if the picking list journal should be posted.</param>
    /// <returns>True if extra quantities were picked; false otherwise.</returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the pickMoreHandlingQty method. Extenders should move their logic to wrap or override the pickMoreQuantities method.', false, 30\9\2019)]
    public static boolean pickMore(
        ProdId                  _prodId,
        InventQty               _inventQty,
        OprNumFrom              _fromOprNum = 0,
        OprNumTo                _toOprNum   = 0,
        boolean                 _pickPerFlushingPrinciple = true,
        boolean                 _endJob = false,
        ProdFlushingPrincipBOM  _flushingPrinciple = ProdFlushingPrincipBOM::Finish,
		boolean					_postNow = true)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), ProdTable::find(_prodId).ItemId);

        return WHSProdTable::pickMoreQuantities(_prodId,
                                _inventQty,
                                _fromOprNum,
                                _toOprNum,
                                _pickPerFlushingPrinciple,
                                _endJob,
                                _flushingPrinciple,
                                _postNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickMoreQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluates if item is a WHS CW item and chooses the correct method calls that, Picks the quantities in addition to what was picked before for a production order, based on the new finished goods quantity.
    /// </summary>
    /// <param name = "_prodId">The production order id</param>
    /// <param name = "_handlingQty">The handling quantity being Reported as Finished, supports catch weight.</param>
    /// <param name = "_fromOprNum">The operation number from where the reporting as finished starts</param>
    /// <param name = "_toOprNum">The operation number where the reporting as finished ends</param>
    /// <param name = "_pickPerFlushingPrinciple">Flag to guide if the picking needs to be made according to the flushing principle of the <c>ProdBOM</c> record</param>
    /// <param name = "_endJob">'End job' parameter is needed for the 'Physical reduction' dependency</param>
    /// <param name = "_flushingPrinciple">The flushing principle against which the item should be consumed</param>
    /// <param name = "_postNow">Determines if the picking list journal should be posted.</param>
    /// <returns>True if extra quantities were picked; false otherwise.</returns>
    /// <remarks>
    /// The method is an extension and is not meant to be called directly. Callers should call the pickMoreHandlingQty method.
    /// </remarks>
    [Wrappable(true)]
    protected static boolean pickMoreQuantities(
        ProdId                  _prodId,
        InventHandlingQty       _handlingQty,
        OprNumFrom              _fromOprNum,
        OprNumTo                _toOprNum,
        boolean                 _pickPerFlushingPrinciple,
        boolean                 _endJob,
        ProdFlushingPrincipBOM  _flushingPrinciple,
        boolean					_postNow)
    {
        ProdBOM                     prodBOM;
        InventQty                   bomInventQty;
        InventQty                   inventQtyRAF;
        InventHandlingQty           inventHandlingQtyRAF;
        WHSWorkExecute              workExecute = WhsWorkExecute::construct();
        InventTable                 inventTable;
        ProdFlushingPrincipBOM      flushingPrinciple;
        ProdTable                   prodTable = ProdTable::find(_prodId);
        boolean                     pickMore;
        InventTrans                 inventTrans;
        InventTransOrigin           inventTransOrigin;
       
        OprNumFrom                  fromOprNum = _fromOprNum;
        OprNumFrom                  toOprNum = _toOprNum;

        if (!WHSInventEnabled::exist(prodTable.ItemId))
        {
            return false;
        }

        if (!_postNow)
        {
            return false;
        }

        if (!fromOprNum && !toOprNum)
        {
            fromOprNum = (select minof(OprNum) from prodBOM
                               where prodBOM.ProdId == prodTable.ProdId).OprNum;
            toOprNum = (select maxof(OprNum) from prodBOM
                             where prodBOM.ProdId == prodTable.ProdId).OprNum;
        }

        ttsbegin;

        Query prodBOMQuery =  WHSProdTable::buildProdBOMQuery(prodTable, fromOprNum, toOprNum);
        QueryRun queryRun = new QueryRun(prodBOMQuery);

        while(queryRun.next())
        {
            prodBOM = queryRun.get(tableNum(ProdBOM));

            boolean isCWItem = PdsGlobal::pdsIsCWItem(prodBOM.ItemId);

            inventTable = InventTable::find(prodBOM.ItemId);

            if (_pickPerFlushingPrinciple)
            {
                // Determine Flushing Principle
                flushingPrinciple = prodBOM.flushingPrinciple();

                // Picked flushing principle should be treated as Start when starting a production order.
                if (_flushingPrinciple == ProdFlushingPrincipBOM::Start
                &&  flushingPrinciple  == ProdFlushingPrincipBOM::Picked)
                {
                    flushingPrinciple = ProdFlushingPrincipBOM::Start;
                }

                if (flushingPrinciple != _flushingPrinciple)
                {
                    continue;
                }
            }

            // Initialize some values.
            bomInventQty = 0;

            // Recalculate raw material consumption quantity to include this percentage
            Percent accError = ProdRoute::accError(prodBOM.ProdId, prodBOM.OprNum);

            var context = WHSReportFinishedHandlingQtyContext::current();
            if (context && !isCWItem)
            {
                _handlingQty = context.parmInventoryQty();
            }

            // Data based on quantity being started / reported as finished
            BOMCalcData			calcBOMData         = BOMCalcData::newProdTable(_handlingQty, prodTable);
            BOMCalcConsumption	calcBOMConsumption  = BOMCalcConsumption::construct(prodBOM.Formula, calcBOMData);
            Qty bomQtyRAF = calcBOMConsumption.calcConsumption(prodBOM, accError ? accError : 1, !prodBOM.ConstantReleased);

            if (isCWItem)
            {
                inventHandlingQtyRAF = WHSCatchWeightHelper::convertInventQuantity(prodBOM.ItemId,
                                                                            prodBOM.pdsCWUnitId(),
                                                                            bomQtyRAF,
                                                                            prodBOM.InventDimId);
            }
            else
            {
                // Convert to invent unit.
                EcoResProductUnitConverter ecoResProductUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(inventTable.ItemId,
                                                                                                        prodBOM.InventDimId,
                                                                                                        prodBOM.UnitId,
                                                                                                        prodBOM.inventUnit(),
                                                                                                        NoYes::No);
                inventHandlingQtyRAF = ecoResProductUnitConverter.convertValue(bomQtyRAF);
            }
            // Get the quantity that is already allocated for consumption.
            if (WHSInventTable::isSerialCapturedDuringPackingAndRegisteredAtConsumption(prodBOM.ItemId))
            {
                // If serials are being captured and registered prior to consumption, then get the quantity
                // of the item that is reserved, as picking itself would require specific serial number.
                select sum(Qty), sum(PdsCWQty) from inventTrans
                    join  inventTransOrigin
                    where inventTrans.InventTransOrigin     == inventTransOrigin.RecId
                       && inventTrans.StatusIssue           == StatusIssue::ReservPhysical
                       && inventTrans.StatusReceipt         == StatusReceipt::None
                       && inventTrans.ItemId                == prodBOM.ItemId
                       && inventTransOrigin.ReferenceId     == prodTable.ProdId
                       && inventTransOrigin.InventTransId   == prodBOM.InventTransId;
            }
            else
            {
                if (ProdAvailOnLocationStartNoOverconsumptionFlight::instance().isEnabled() &&
                    _flushingPrinciple == ProdFlushingPrincipBOM::Start              &&
                    prodBOM.flushingPrinciple() == ProdFlushingPrincipBOM::Picked)
                {
                    InventTransIdSum inventTransIdSum = InventTransIdSum::newTransOriginId(InventTransOrigin::findByInventTransId(prodBOM.InventTransId).RecId);
                
                    inventTrans.Qty = inventTransIdSum.picked() + inventTransIdSum.deducted();
                    inventTrans.PdsCWQty = inventTransIdSum.pdsCWPicked() + inventTransIdSum.pdsCWDeducted();
                }
                else
                {
                    // Get the quantity picked.
                    select sum(Qty), sum(PdsCWQty) from inventTrans
                    join  inventTransOrigin
                    where inventTrans.InventTransOrigin     == inventTransOrigin.RecId
                       && inventTrans.StatusIssue           == StatusIssue::Picked
                       && inventTrans.StatusReceipt         == StatusReceipt::None
                       && inventTrans.ItemId                == prodBOM.ItemId
                       && inventTransOrigin.ReferenceId     == prodTable.ProdId
                       && inventTransOrigin.InventTransId   == prodBOM.InventTransId;
                }
            }

            if (isCWItem)
            {
                // Legacy catch weight items that are tracked, can not be auto picked
                // at production start, in a nonWHS warehosue.
                if (-inventTrans.PdsCWQty < inventHandlingQtyRAF
                    && !prodBOM.inventDim().inventLocation().WHSEnabled
                    && (inventTable.whsBatchActive()
                    ||  inventTable.isItemSerialNumberActivated()))
                {
                    throw error(strFmt("@WAX:ErrorTrackedCWProdStart", inventTable.ItemId));
                }

                if (inventTrans.PdsCWQty)
                {
                    inventHandlingQtyRAF -= abs(inventTrans.PdsCWQty);
                }
            }
            else if (inventTrans.Qty)
            {
                inventHandlingQtyRAF -= abs(inventTrans.Qty);
            }

            // If we have enough already picked, continue.
            if (inventHandlingQtyRAF <= 0)
            {
                continue;
            }

            // Over-producing finished goods, however raw material consumption remains the same so do not over pick
            if (_endJob
                && inventHandlingQtyRAF > 0
                && ProdParameters::find().bomJournalReducePhysical)
            {
                continue;
            }

            if (!prodBOM.canPickSubProductionDemand(inventHandlingQtyRAF))
            {
                continue;
            }

            // Check that any serialized items have registered serials
            if (!ProdJournalBOM::checkSerialRegisteredAtConsumption(prodBOM.ItemId, prodBOM.InventTransId, inventHandlingQtyRAF))
            {
                throw error(strFmt("@SCM:RegisteredSerialConsumptionCheckMessage", prodBOM.ItemId));
            }

            WHSProdTable::adjustMaterialDemandForOverpick(prodBOM, inventHandlingQtyRAF);
            WHSProdTable::pickMaterial(prodTable, prodBOM, inventHandlingQtyRAF, _flushingPrinciple);

            pickMore = true;
        }

        ttscommit;
        
        return pickMore;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustMaterialDemandForOverpick</Name>
				<Source><![CDATA[
    /// <summary>Adjusts <c>ProdBOM</c> material's physical remainders for overpick</summary>
    /// <param name = "prodBOM">The production order's material</param>
    /// <param name = "inventHandlingQtyRAF">The quantity to pick in inventory unit</param>
    public static void adjustMaterialDemandForOverpick(ProdBOM             prodBOM,
                                                         InventHandlingQty inventHandlingQtyRAF)
    {
        InventTransOrigin inventTransOrigin;
        InventTrans       nonPickedInventTrans;
        boolean           isCWItem = PdsGlobal::pdsIsCWItem(prodBOM.ItemId);

        // Get Qty that is has not been picked yet.
        select sum(Qty), sum(PdsCWQty) from nonPickedInventTrans
                join ReferenceId from inventTransOrigin
                where nonPickedInventTrans.InventTransOrigin    == inventTransOrigin.RecId
                   && nonPickedInventTrans.StatusIssue          >  StatusIssue::Picked
                   && nonPickedInventTrans.ItemId               == prodBOM.ItemId
                   && inventTransOrigin.ReferenceId             == prodBOM.ProdId
                   && inventTransOrigin.InventTransId           == prodBOM.InventTransId;

        // Increase prodBOM quantities by the amount that we are over producing for
        // Remember Qty is negative on the inventTrans record.
        if (isCWItem && inventHandlingQtyRAF > -nonPickedInventTrans.PdsCWQty)
        {
            PdsCWInventQty increaseCWQtyRemain = inventHandlingQtyRAF + nonPickedInventTrans.PdsCWQty;

            prodBOM.PdsCWRemainPhysical  += increaseCWQtyRemain;
            prodBOM.RemainInventPhysical += WHSCatchWeightHelper::convertInventQuantity(prodBOM.ItemId,
                                                                                    prodBOM.pdsCWUnitId(),
                                                                                    increaseCWQtyRemain,
                                                                                    prodBOM.InventDimId);
                
            prodBOM.RemainBOMPhysical = WHSCatchWeightHelper::convertInventQuantity(prodBOM.ItemId,
                                                                                prodBOM.pdsCWUnitId(),
                                                                                prodBOM.RemainInventPhysical,
                                                                                prodBOM.InventDimId);
            prodBOM.updateMaterial();
        }
        else if (inventHandlingQtyRAF > -nonPickedInventTrans.Qty)
        {
            prodBOM.RemainInventPhysical += inventHandlingQtyRAF + nonPickedInventTrans.Qty;

            EcoResProductUnitConverter ecoResProductUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(prodBOM.ItemId,
                                                                                                        prodBOM.InventDimId,
                                                                                                        prodBOM.inventUnit(),
                                                                                                        prodBOM.UnitId,
                                                                                                        NoYes::No);
            prodBOM.RemainBOMPhysical = ecoResProductUnitConverter.convertValue(prodBOM.RemainInventPhysical);
            prodBOM.updateMaterial();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickMaterial</Name>
				<Source><![CDATA[
    /// <summary>Picks <c>ProdBOM</c> material from warehouse</summary>
    /// <param name = "_prodTable">The production order</param>
    /// <param name = "_prodBOM">The production order's material</param>
    /// <param name = "_inventHandlingQtyRAF">The quantity to pick in inventory unit of measure</param>
    /// <param name = "_flushingPrinciple">The material's flushing principle</param>
    /// <param name = "_throwCheckFailed">Indicates whether the error is thrown if there is nothing on-hand</param>
    [Hookable(false)]
    internal static void pickMaterial(ProdTable              _prodTable,
                                      ProdBOM                _prodBOM,
                                      InventHandlingQty      _inventHandlingQtyRAF,
                                      ProdFlushingPrincipBOM _flushingPrinciple,
                                      boolean                _throwCheckFailed = true)
    {
        InventTable     inventTable = InventTable::find(_prodBOM.ItemId);
        InventDim       tmpInventDim = InventDim::find(_prodBOM.InventDimId);
        WMSLocationId   workCenterLocationId = WHSProdTable::getWorkCenterLocationFromProdId(_prodTable.ProdId, _prodBOM.OprNum, _prodBOM.InventDimId);
        boolean         isCWItem = PdsGlobal::pdsIsCWItem(_prodBOM.ItemId);
        InventDimParm   inventDimParmAboveLocation = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(inventTable);
        boolean         allowNegative;
        InventQty       runningQty;

        // If location is specified on prodBOM
        if (tmpInventDim.wmsLocationId)
        {
            allowNegative = tmpInventDim.whsAllowPhysNeg(inventTable.whsAllowPhysNeg());
        }
        else
        {
            // Create dim using work center location
            tmpInventDim.wmsLocationId = workCenterLocationId;
            tmpInventDim = InventDim::findOrCreate(tmpInventDim);

            allowNegative = tmpInventDim.whsAllowPhysNeg(inventTable.whsAllowPhysNeg())
                                && WHSInventTable::find(_prodBOM.ItemId).PickWCNeg;
        }

        // For items with tracking dimensions that do not have these dimensions specified.
        // In case of several tracking dimensions enabled any of these methods takes care about other dimensions
        // Starting with batch because sorting is applied there
        if (   !tmpInventDim.InventBatchId
                && inventTable.whsBatchActive())
        {
            runningQty = _inventHandlingQtyRAF;

            // Loop over batch with physical inventory to determine what gets consumed
            // Order by production date for batch
            WHSProdTable::pickBatchQuantities(inventTable, tmpInventDim, _prodBOM, runningQty, allowNegative);
        }
        else if (!tmpInventDim.InventOwnerId_RU
                  && inventTable.isItemInventoryOwnerActivated())
        {
            runningQty = _inventHandlingQtyRAF;

            // Loop over owner with physical inventory to determine what gets consumed
            // Order by production date for batch
            WHSProdTable::pickOwnerQuantities(inventTable, tmpInventDim, _prodBOM, runningQty, allowNegative);
        }
        else if (!tmpInventDim.inventSerialId
                  && inventTable.isItemSerialNumberActivated())
        {
            runningQty = _inventHandlingQtyRAF;

            // Loop over serial with physical inventory to determine what gets consumed
            // Order by production date for batch
            WHSProdTable::pickSerialQuantities(inventTable, tmpInventDim, _prodBOM, runningQty, allowNegative);
        }
        else // For full dims
        {
            // We don't throw and pick for non-batch enabled items to allow the scenario where there is nothing on-hand
            if (_flushingPrinciple != ProdFlushingPrincipBOM::Start)
            {
                if (!allowNegative
                        && !WHSProdTable::checkCanPickMore(_prodBOM, tmpInventDim, _inventHandlingQtyRAF, _prodTable.ProdId))
                {
                    if (_throwCheckFailed)
                    {
                        throw error(strFmt("@WAX2522", _prodBOM.ItemId));
                    }
                    else
                    {
                        error(strFmt("@WAX2522", _prodBOM.ItemId));
                        return;
                    }
                }

                InventDimParm inventDimParmAboveOrInLocation = isCWItem ? WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(_prodBOM.ItemId)) : inventDimParmAboveLocation;
                if (workCenterLocationId
                        && !inventDimParmAboveOrInLocation.WMSLocationIdFlag)
                {
                    // Added location flag for the <c>InventDimParm</c> if has the work center locationId.
                    inventDimParmAboveOrInLocation.WMSLocationIdFlag = NoYes::Yes;
                }

                using (var context = WhsInventPickingContext::newSkipPickIdAllocation())
                {
                    if (isCWItem)
                    {
                        // For catch weight items we must take the average weight based on inventory and use that average weight when picking against the prodBOM.
                        InventOnHandQty inventOnHandQty = InventOnHandQty::newParameters(_prodBOM.ItemId,  tmpInventDim);
                        InventQty       weightToPick = WHSCatchWeightHelper::calculateDefaultWeightForPick(_prodBOM.ItemId, InventDim::find(_prodBOM.InventDimId), _inventHandlingQtyRAF);
                        
                        WHSInvent::pickQuantities(_prodBOM, tmpInventDim.InventDimId, weightToPick, _inventHandlingQtyRAF, inventDimParmAboveOrInLocation);
                    }
                    else
                    {
                        // Pick
                        WHSInvent::pickQuantities(_prodBOM, tmpInventDim.InventDimId, _inventHandlingQtyRAF, 0, inventDimParmAboveOrInLocation);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildProdBOMQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query to pick qty for each <c>ProdBOM</c>.
    /// </summary>
    /// <param name = "_prodTable">
    /// <c>ProdTable</c> record.
    /// </param>
    /// <param name = "_fromOprNum">
    /// The operation number from where the reporting as finished starts.
    /// </param>
    /// <param name = "_toOprNum">
    /// The operation number where the reporting as finished ends.
    /// </param>
    /// <returns>
    /// A <c>Query</c> object.
    /// </returns>
    protected static Query buildProdBOMQuery(ProdTable _prodTable, OprNumFrom _fromOprNum, OprNumTo _toOprNum)
    {
        Query query = new Query();

        QueryBuildDataSource prodBomDataSource = query.addDataSource(tableNum(ProdBOM));
        prodBomDataSource.update(true);
        prodBomDataSource.addRange(fieldNum(ProdBOM, ProdId)).value(queryValue(_prodTable.ProdId));
        prodBomDataSource.addRange(fieldNum(ProdBOM, bomQty)).value(SysQuery::valueNot(0));
        prodBomDataSource.addRange(fieldNum(ProdBOM, bomQtySerie)).value(SysQuery::valueNot(0));
        prodBomDataSource.addRange(fieldNum(ProdBOM, OprNum)).value(queryRangeConcat((queryRange(_fromOprNum, _toOprNum)), 0));

        QueryBuildDataSource whsInventEnabledDataSource = prodBomDataSource.addDataSource(tableNum(WHSInventEnabled));
        whsInventEnabledDataSource.joinMode(JoinMode::ExistsJoin);
        whsInventEnabledDataSource.addLink(fieldNum(ProdBOM, ItemId), fieldNum(WHSInventEnabled, ItemId));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeStop</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates stopped info a <c>WHSProdTable</c> record.
    /// </summary>
    /// <param name="_prodId">
    /// Id of the production order.
    /// </param>
    /// <param name="_whsUserId">
    /// Current user id of the activity owner.
    /// </param>
    public static void removeStop(ProdId _prodId, WHSUserId _whsUserId = '')
    {
        WHSProdTable whsProdTable;

        ttsbegin;

        whsProdTable = WHSProdTable::find(_prodId, true);

        if (whsProdTable)
        {
            whsProdTable.Stopped = false;
            whsProdTable.update();
        }

        if (strLen(_whsUserId) > 0)
        {
            WHSMobileDeviceActivityLogger::newStandard(_whsUserId, WHSWorkExecuteMode::ProdLastPallet)
                .append(#WHSLabelFromEDT(ProdId), _prodId)
                .save();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetProdStatusCleanUp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets a production order status.
    /// </summary>
    /// <param name="_prodId">
    /// Id of the production order.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when the production order has in process work or on an executing wave.
    /// </exception>
    public static void resetProdStatusCleanUp(ProdId _prodId)
    {
        ProdBOM             prodBOM;
        WHSWorkTable        workTable;
        WHSWorkLine         workLine;

        ttsbegin;

        // Check to see if there is any in process work for production order
        select firstonly prodBOM
            join workLine
            where workLine.InventTransId == prodBOM.InventTransId &&
                  prodBOM.ProdId         == _prodId
                join workTable
                where workTable.WorkId       == workLine.WorkId &&
                      workTable.WorkStatus   == WHSWorkStatus::InProcess;

        if (prodBOM.RecId)
        {
            throw error("@WAX3336");
        }

        // Cancel all open work Headers/Lines for the production order
        while select WorkId from workTable
            where workTable.OrderNum     == _prodId &&
                  workTable.WorkStatus   == WHSWorkStatus::Open
        {
            WHSWorkTable::cancelWork(workTable.WorkId);
        }

        WHSProdWaveLine     prodWaveLine;
        WHSWaveTable        waveTable;

        while select forupdate prodWaveLine
            where prodWaveLine.ProdId == _prodId
            join waveTable
            where waveTable.WaveId       == prodWaveLine.WaveId &&
                  waveTable.WaveStatus   <  WHSWaveStatus::Held
        {
            // Check to see if any in batch or executing waves for the production order.
            if (waveTable.WaveStatus == WHSWaveStatus::Executing || waveTable.inBatch())
            {
                throw error("@WAX3337");
            }

            // No need to call validate delete because it is only checking to make sure wave isn't in batch
            prodWaveLine.delete();
        }

        while select ProdId from prodBOM
            join WorkId,InventQtyWork,ItemId,LineNum from workLine
            where prodBOM.ProdId            == _prodId                  &&
                  workLine.InventTransId    == prodBOM.InventTransId    &&
                  workLine.WorkStatus    == WHSWorkStatus::Open
        {
            WHSWorkLine::cancelLine(workLine.WorkId, workLine.LineNum, workLine.InventQtyWork, workLine.ItemId);
        }

        // Delete ProdBOMPool records

        WHSProdBOMPool prodBOMPool;

        delete_from prodBOMPool
            where prodBOMPool.ProdId == _prodId;

        WHSWorkFrozen workFrozen;

        delete_from workFrozen
            exists join prodBOM
                where prodBOM.InventTransId == workFrozen.InventTransId
                   && prodBOM.ProdId        == _prodId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>stop</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates stopped info of a <c>WHSProdTable</c> record to true.
    /// </summary>
    public static void stop(ProdId _prodId)
    {
        WHSProdTable whsProdTable;

        ttsbegin;

        whsProdTable = WHSProdTable::find(_prodId, true);

        if (whsProdTable)
        {
            whsProdTable.Stopped = true;
            whsProdTable.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUnpickAndUnreserveQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query to select the production BOMs to unpick and unreserve.
    /// </summary>
    /// <param name = "_prodId">A production order id.</param>
    /// <returns>A query object.</returns>
    protected static Query buildUnpickAndUnreserveQuery(ProdId _prodId)
    {
        Query query = new Query();

        QueryBuildDataSource prodBomDataSource = query.addDataSource(tableNum(ProdBOM));
        prodBomDataSource.addRange(fieldNum(ProdBOM, ProdId)).value(queryValue(_prodId));
        prodBomDataSource.addRange(fieldNum(ProdBOM, RemainBOMPhysical)).value(strFmt('(%1.%2 > 0)', prodBomDataSource.name(), fieldStr(ProdBOM, RemainBOMPhysical)));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>stopAndUnpick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stops and unpicks the items in the production order.
    /// </summary>
    /// <param name="_prodId">
    /// Id of the production order.
    /// </param>
    public static void stopAndUnpick(ProdId _prodId)
    {
        ProdBOM                 prodBOM;
        InventDim               inventDim;
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;
        InventTrans             unReserveInventTrans;
        InventTransOrigin       unReserveInventTransOrigin;
        InventMovement          movement;
        InventDimParm           inventDimParm;
        InventDimParm           inventDimParmFixed;
        InventDim               reserveInventDim;
        InventQty               qty;
        InventUpd_Picked        picked;
        InventUpd_Reservation   reservation;

        // Stop the Production Order.
        WHSProdTable::stop(_prodId);

        // Unpick and Unreserve all inventory that has not been consumed.
        Query prodBOMQuery =  WHSProdTable::buildUnpickAndUnreserveQuery(_prodId);
        QueryRun queryRun = new QueryRun(prodBOMQuery);

        while(queryRun.next())
        {
            prodBOM = queryRun.get(tableNum(ProdBOM));
            // For catch weight items, the buffer could be updated when updating the pick transactions if adjustments are made.
            prodBOM.selectForUpdate(true);

            movement = InventMovement::construct(prodBOM);
            movement.inventDimGroupSetup().inventDimParmActive(inventDimParm);
            inventDimParmFixed.initFromInventDim(movement.inventdim());

            // Picked quantity might still be locked by an open picking list, 
			// therefore consider child references in order to let downstream production update validate the order.
            while select inventTrans
                join  InventTransId from inventTransOrigin
                where inventTrans.InventTransOrigin     == inventTransOrigin.RecId      &&
                      inventTrans.TransChildType        == movement.transChildType()    &&
                      inventTrans.TransChildRefId       == movement.transChildRefId()   &&
                      inventTransOrigin.InventTransId   == prodBOM.InventTransId        &&                            
                      (inventTrans.StatusIssue          == StatusIssue::Picked          ||
                       inventTrans.StatusIssue          == StatusIssue::ReservPhysical  ||
                       inventTrans.StatusIssue          == StatusIssue::ReservOrdered)
            {
                PdsCWQty cwQty;
                qty = 0;
                inventDim   = inventTrans.inventDim();
                reserveInventDim = WHSInvent::adjustDimsForProdPick(inventDim, inventTrans.ItemId);

                if (inventTrans.StatusIssue == StatusIssue::Picked)
                {
                    if (PdsGlobal::pdsIsCWItem(prodBOM.ItemId))
                    {
                        cwQty = abs(inventTrans.PdsCWQty) < prodBOM.PdsCWRemainPhysical ? abs(inventTrans.PdsCWQty) : prodBOM.PdsCWRemainPhysical;
                    }
                    
                    qty = abs(inventTrans.Qty) < prodBOM.RemainInventPhysical ? abs(inventTrans.Qty) : prodBOM.RemainInventPhysical;
                    
                    picked = InventUpd_Picked::newParameters(movement,
                                                             inventDim,
                                                             inventDimParm,
                                                             inventDim,
                                                             inventDimParm,
                                                             qty,
                                                             '',
                                                             cwQty);
                    picked.updateNow();
                }

                if (InventLocation::find(inventDim.InventLocationId).ProdReserveOnlyWhse)
                {
                    // Update the inventTrans to be reserved at the correct level after being unpicked.
                    while select forupdate unReserveInventTrans
                        join unReserveInventTransOrigin
                        where unReserveInventTrans.InventTransOrigin             == unReserveInventTransOrigin.RecId &&
                              unReserveInventTransOrigin.InventTransId  == prodBOM.InventTransId            &&
                              unReserveInventTrans.StatusIssue          == StatusIssue::ReservPhysical      &&
                              unReserveInventTrans.InventDimId          != reserveInventDim.InventDimId
                    {
                        unReserveInventTrans.InventDimId = reserveInventDim.InventDimId;
                        unReserveInventTrans.update();
                    }
                }

                // This is used to unreserve the qty after we unpicked it or for any inventTrans that started out reserved.
                reservation = InventUpd_Reservation::newParameters(movement,
                                                                   reserveInventDim,
                                                                   inventDimParm,
                                                                   InventDimFixedClass::inventDimParm2InventDimFixed(inventDimParmFixed),
                                                                   qty ? qty : abs(inventTrans.Qty),
                                                                   false,
                                                                   false,
                                                                   cwQty,
                                                                   true);
                reservation.updateNow();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkActiveForProdOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether there is an active work item for a production order.
    /// </summary>
    /// <param name="_orderNum">
    /// Production order number.
    /// </param>
    /// <returns>
    /// True if there is an active work item for the production order.
    /// </returns>
    static boolean isWorkActiveForProdOrder(WHSOrderNum _orderNum)
    {
        WHSWorkTable        workTable;

        if (_orderNum)
        {
            select firstonly RecId from workTable
                where workTable.OrderNum         == _orderNum                    &&
                      workTable.WorkTransType    == WHSWorkTransType::ProdPick   &&
                      workTable.WorkStatus       <  WHSWorkStatus::Skipped;
        }

        return workTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    [Hookable(false)]
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>WHSandTMS</ConfigurationKey>
	<DeveloperDocumentation>@WAX3099</DeveloperDocumentation>
	<FormRef>ProdTable</FormRef>
	<Label>@WAX2899</Label>
	<SingularLabel>@SYS89639</SingularLabel>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>ProdId</TitleField1>
	<TitleField2>Stopped</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>ProdIdx</ClusteredIndex>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Inventory</Modules>
	<PrimaryIndex>ProdIdx</PrimaryIndex>
	<ReplacementKey>ProdIdx</ReplacementKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProdId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Stopped</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProdQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LastPallet</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProdId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@WAX2277</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProdId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Stopped</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProdQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LastPallet</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CrossDock</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CrossDock</Name>
			<Label>@SYS6437</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CrossDock</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CrossDock</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSCrossDock</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LastPallet</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLastPallet</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProdId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProdId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ProdQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSProdQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Stopped</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSStopped</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>ProdIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ProdId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>ProdTable</Name>
			<Cardinality>ZeroOne</Cardinality>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Composition</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProdId</Name>
					<SourceEDT>ProdId</SourceEDT>
					<Field>ProdId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>