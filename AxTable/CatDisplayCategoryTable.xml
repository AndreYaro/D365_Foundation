<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CatDisplayCategoryTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CatDisplayCategoryTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>ancestorCategoryNameToCollapseTo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the name of the ancestor navigation category to which this category collapses.
    /// </summary>
    /// <returns>
    ///    A <c>Name</c> enumeration value.
    /// </returns>
    display Name ancestorCategoryNameToCollapseTo()
    {
        Name ret = this.Name;
        CatDisplayCategoryTable tblAncestorCategoryToCollapseTo;

        if (this.isCollapsedToAncestor())
        {
            select firstonly Name from tblAncestorCategoryToCollapseTo
                where tblAncestorCategoryToCollapseTo.RecId == this.AncestorCategoryToCollapseTo;

            if (tblAncestorCategoryToCollapseTo)
            {
                ret = tblAncestorCategoryToCollapseTo.Name;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeImmediateChildOfPerNSL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Uses the nested set values to determine if the this record can be an immediate child of the given <paramref>_parentCategoryFromDB</paramref> record.
    /// </summary>
    /// <param  name='_parentCategoryFromDB'>
    /// The record as the candidate parent of the this record.
    /// </param>
    /// <returns>
    /// <c>true</c> if the this record can be an immediate child of the given <paramref>_parentCategoryFromDB</paramref> record; otherwise, <c>false</c>.
    /// </returns>
    /// <remarks>
    /// The <c>ParentCategory</c> field on the this record must not be used for the checking since it might have been changed.
    /// The <c>TreeLevel</c>, <c>NestedSetLeft</c> and <c>NestedSetRight</c> fields on the this record still have valid values and can be used for checking.
    /// </remarks>
    boolean canBeImmediateChildOfPerNSL(CatDisplayCategoryTable _parentCategoryFromDB)
    {
        boolean rtv;

        ;

        // OK if the new parent is anyone but a node within the subtree rooted at the this node.
        // (ie, OK if _parentCategoryFromDB is neither this nor a descendant of this.)
        rtv = ( ! (_parentCategoryFromDB.isDescendantOfPerNSL(this)))
                && (_parentCategoryFromDB.RecId != this.RecId);

        return rtv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if it is OK to delete the record.
    /// </summary>
    /// <returns>
    ///    true if it is OK to delete the record; otherwise, false.
    /// </returns>
    boolean canDelete()
    {
        // OK to delete iff
        // - the node is an alias, or
        // - the node is one without ProcureCategory counterpart (in which case it might have child nodes - still OK)
        // - (the node isn't the DisplayCategory root node - but the root node doesn't fit either of above, hence this is implied)

        boolean rtv;
        CatDisplayCategorySharedInfo tblSharedData;

        ;

        rtv = (this.TargetCategory != 0);
        // contintue checking if not alias
        if ( ! rtv)
        {
            select firstonly Category from tblSharedData
                where tblSharedData.RecId == this.SharedData;
            // has no ProcureCategory counterpart?
            rtv = ( ! tblSharedData.Category);
        }

        return rtv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cloneRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new record of the <c>CatDisplayCategoryTable</c> table by duplicating this record.
    /// </summary>
    /// <param  name='_tblSharedData'>
    /// The <c>CatDisplayCategorySharedInfo</c> record the cloned <c>CatDisplayCategoryTable</c> record will point to.
    /// </param>
    /// <param  name='_targetCategory'>
    /// The record id of the target category for the cloned record.
    /// </param>
    /// <returns>
    /// The cloned instance of the <c>CatDisplayCategoryTable</c> data type.
    /// </returns>
    /// <remarks>
    /// The cloned record is not inserted into the database.
    /// </remarks>
    public CatDisplayCategoryTable cloneRecord(CatDisplayCategorySharedInfo _tblSharedData = null, RecId _targetCategory = 0)
    {
        CatDisplayCategoryTable tblDisplayCategoryDup;
        CatDisplayCategoryTable targetCatDisplayCategoryTable;

        tblDisplayCategoryDup.clear();
        tblDisplayCategoryDup.Catalog = this.Catalog;
        tblDisplayCategoryDup.TargetCategory = _targetCategory;
        tblDisplayCategoryDup.AncestorCategoryToCollapseTo = this.AncestorCategoryToCollapseTo;
        tblDisplayCategoryDup.Name = this.Name;
        tblDisplayCategoryDup.NestedSetLeft = this.NestedSetLeft;
        tblDisplayCategoryDup.NestedSetRight = this.NestedSetRight;
        tblDisplayCategoryDup.ParentCategory = this.ParentCategory;
        if (_tblSharedData)
        {
            tblDisplayCategoryDup.SharedData = _tblSharedData.RecId;
        }
        else
        {
            tblDisplayCategoryDup.SharedData = this.SharedData;

            // if tblDisplayCategoryDup has the same SharedData as this, then tblDisplayCategoryDup must be an alias/shortcut of
            //  either this (if this isn't an alias/shortcut)
            //  or the target of this
            select firstonly targetCatDisplayCategoryTable
                where targetCatDisplayCategoryTable.SharedData == this.SharedData
                    && targetCatDisplayCategoryTable.TargetCategory == 0
            ;

            tblDisplayCategoryDup.TargetCategory = targetCatDisplayCategoryTable.RecId;
            // this assumes the target has been saved in the database (unlike the cloned):
            Debug::assert(targetCatDisplayCategoryTable.RecId);
            Debug::assert((!_targetCategory) || (_targetCategory==targetCatDisplayCategoryTable.RecId));
        }
        tblDisplayCategoryDup.TreeLevel = this.TreeLevel;
        tblDisplayCategoryDup.UpdateType = this.UpdateType;

        return tblDisplayCategoryDup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the delete related logic.
    /// </summary>
    /// <remarks>
    ///    The records to delete include the following: all records that are an alias of this record, the
    ///    <c>CatDisplayCategorySharedInfo</c> record for this record if this is not an alias, this record,
    ///    and each descendant of this record.
    /// </remarks>
    public void delete()
    {
        /// NOTE: what if some node not in the subtree is an alias pointing to someone in the subtree, such nodes will be deleted as well.

        CatDisplayCategoryTable tblAlias, tblSubtree, tblSubRoot;
        CatDisplayCategorySharedInfo tblSharedData;
        CatDisplayCategoryTable thisFromDB;

        ttsbegin;
            //********************************************************************************
            // (actual) order of delete using set-based operation
            // - delete all DisplayCategory records outside of the subtree that (1) is alias and (2) is alias of a node within the subtree with the "this" record as the root
            // - delete all SharedData records pointed to by any one within the subtree with the "this" record as the root
            // - delete the SharedData record the "this" record points to if "this" isn't an alias
            // - delete all DisplayCategory records within the subtree with the "this" record as the root
            //********************************************************************************
            // (theoretical) order of delete using recursion (slow)
            // - make recursive call on each immediate child node of the "this" record
            // - delete all alias nodes pointing to the "this" record
            // - delete the SharedData record for the "this" record

            //********************************************************************************
            //**** algorithm: ****************************************************************
            // -Delete all nodes that are alias for someone in the subtree
            // -- Such nodes may be either outside of subtree or inside the subtree
            // -- all outside alias nodes pointing to the subtree will be returned
            // -- all inside alias nodes pointing to the subtree will be returned
            // -- all inside alias nodes pointing to outside the subtree will ***NOT*** be returned
            // -Delete alias nodes inside the subtree (after above sstep, these alias nodes must point outside the tree)
            // -Delete whole subtree and relevant records
            // -- Delete all SharedData records for the whole subtree (after above steps, we can be sure these SharedData records are neither used by other alias nor 'owned' by an outside node)
            // -- Delete the whole subtree except root - let super() do that
            // -- call super() to delete the subtree root
            //********************************************************************************
            select forupdate firstonly * from thisFromDB
                where thisFromDB.RecId == this.RecId;
            if ( ! thisFromDB.TargetCategory)
            {
                delete_from tblAlias
                    where tblAlias.Catalog == this.Catalog
                        && tblAlias.TargetCategory != 0
                    exists join tblSubtree
                        where tblSubtree.Catalog == tblAlias.Catalog
                            && tblSubtree.SharedData == tblAlias.SharedData
                            && tblSubtree.TargetCategory == 0
                    join tblSubRoot
                        where tblSubRoot.RecId == this.RecId
                            && tblSubRoot.Catalog == tblSubtree.Catalog
                            && tblSubRoot.NestedSetLeft <= tblSubtree.NestedSetLeft
                            && tblSubRoot.NestedSetLeft < tblSubtree.NestedSetRight
                            && tblSubtree.NestedSetRight <= tblSubRoot.NestedSetRight
                ;
                delete_from tblSubtree
                    where tblSubtree.Catalog == this.Catalog
                        && tblSubtree.TargetCategory != 0
                    exists join tblSubRoot
                        where tblSubRoot.RecId == this.RecId
                            && tblSubRoot.Catalog == tblSubtree.Catalog
                            && tblSubRoot.NestedSetLeft <= tblSubtree.NestedSetLeft
                            && tblSubRoot.NestedSetLeft < tblSubtree.NestedSetRight
                            && tblSubtree.NestedSetRight <= tblSubRoot.NestedSetRight
                ;

                // SD.delete calls DC.delete (this method); thus we must skipDeleteMethod on SD to avoid infinite recursion.
                tblSharedData.skipDeleteMethod(true);
                delete_from tblSharedData
                    exists join tblSubtree
                        where tblSubtree.Catalog == this.Catalog
                            && tblSubtree.SharedData == tblSharedData.RecId
                    join tblSubRoot
                        where tblSubRoot.RecId == this.RecId
                            && tblSubRoot.Catalog == tblSubtree.Catalog
                            && tblSubRoot.NestedSetLeft <= tblSubtree.NestedSetLeft
                            && tblSubRoot.NestedSetLeft < tblSubtree.NestedSetRight
                            && tblSubtree.NestedSetRight <= tblSubRoot.NestedSetRight
                ;
                // NOTE: we assume records in other relevant tables will be deleted by cascade-action
                // critical - do NOT use "<=" to include the subtree root - super() takes care of it
                delete_from tblSubtree
                    where tblSubtree.Catalog == this.Catalog
                    exists join tblSubRoot
                        where tblSubRoot.RecId == this.RecId
                            && tblSubRoot.Catalog == tblSubtree.Catalog
                            && tblSubRoot.NestedSetLeft < tblSubtree.NestedSetLeft
                            && tblSubRoot.NestedSetLeft < tblSubtree.NestedSetRight
                            && tblSubtree.NestedSetRight < tblSubRoot.NestedSetRight
                ;

                /** code using recursion
                    // make recursive call on immediate child nodes
                    while select forupdate RecId from immediateChild
                        join thisFromDB
                            where thisFromDB.RecId == this.RecId
                                && immediateChild.ParentCategory == thisFromDB.RecId
                    {
                        immediateChild.delete();
                    }

                    // delete all alias nodes of the "this" record
                    while select forupdate RecId from aliasNode
                        join RecId from thisFromDB
                            where thisFromDB.RecId == this.RecId
                                && aliasNode.TargetCategory != 0
                                && aliasNode.SharedData == thisFromDB.SharedData
                    {
                        aliasNode.delete();
                    }

                    // delete the SharedData record for the "this" record
                    select firstonly forupdate RecId from sdFromDB
                        where sdFromDB.RecId == thisFromDB.SharedData;
                    sdFromDB.delete();
                **/
            }

            // critical - must call super *last* - otherwise with this record deleted, above query won't find much to delete!
            super();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doDiffParentSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the nested set values for the whole subtree rooted at the this record due to change of the parent.
    /// </summary>
    /// <param  name='_thisFromDB'>
    /// The same as the this record but it's refreshed from the database.
    /// </param>
    /// <param  name='_newParentCategoryFromDB'>
    /// The new parent for the this record, refreshed from the database.
    /// </param>
    /// <remarks>
    /// The fields to update include
    /// (1) TreeLevel
    /// (2) NestedSetLeft
    /// (3) NestedSetRight
    ///
    /// This method will set the nested set values without checking if the resulted nested set values may violate "nested set" integrity.
    /// The caller is responsible for the checking.
    /// This method does not persist anything to the database.
    /// </remarks>
    void doDiffParentSet(CatDisplayCategoryTable _thisFromDB, CatDisplayCategoryTable _newParentCategoryFromDB)
    {
        /// PRE:        this.ParentCategory is set to one different from what it was
        ///             (ie, the ParentCategory value of the cached this is different from that of the this in DB).
        ///             it's OK to make the this node a child of the new parent (this.ParentCategory).
        /// POST:       TreeLevel, NestedSetLeft and NestedSetRight for this node and all its descendants will be reset
        ///             - but not persisted to the db - caller is expected to do so.
        ///             NestedSet values may not be valid - *caller* is responsible for checking if rebuild is needed, and actually does that.

        CatProcureCatalogTable theCatalog;
        CatDisplayCategoryTable allDisplayCategory;
        CatDisplayCategoryTable subtree, subroot;
        CatDisplayCategoryTable nNodes;
        container lr;
        real nlv, nrv; // new Left usable value and Right usable value
        real oldGap, newGap, misc;

        ;

        // refresh and lock the Catalog and all of its DisplayCategory nodes so that no two user would be updating the tree simultaneously
        select forupdate RecId from theCatalog
            where theCatalog.RecId == this.Catalog;
        // refresh and lock the records
        select forupdate RecId from allDisplayCategory
            where allDisplayCategory.Catalog == this.Catalog;

        select count(RecId) from nNodes
            where nNodes.Catalog == this.Catalog
                && nNodes.TreeLevel >= this.TreeLevel
                && this.NestedSetLeft <= nNodes.NestedSetLeft
                && this.NestedSetLeft < nNodes.NestedSetRight
                && nNodes.NestedSetRight <= this.NestedSetRight;

        lr = CatDisplayCategoryTable::doConvertNestedSetBoundsToUsable(_newParentCategoryFromDB.doFindNestedSetBounds(nNodes.RecId));
        [nlv, nrv] = lr;
        // ***FORMULA***:
        // assuming [olv, orv] and [nlv, nrv], then
        // for any oXv (within [olv, orv]), to find the nXv (within [nlv, nrv]), this "proportional relationship" must be satisfied:
        //     (nrv - nXv) / (nXv - nlv) == (orv - oXv) / (oXv - olv)
        // ==>
        //     (nrv - nXv) * (oXv - olv) == (orv - oXv) * (nXv - nlv)
        // ==>
        //     *********************************
        //       LHS        ==         RHS
        //     *********************************
        //      nrv * oXv   ||         nXv * orv
        //     -nrv * olv   ||        -nlv * orv
        //     -nXv * oXv   ||        -nXv * oXv
        //      nXv * olv   ||         nlv * oXv
        // ==>
        //     LHS:
        //            - (nlv * oXv)
        //            + (nrv * oXv)
        //            - (nrv * olv)
        //            + (nlv * orv)
        //     RHS:
        //            - (nXv * olv)
        //            + (nXv * orv)
        // ==>
        //     nXv = (((oXv * (nrv - nlv)) + ((nlv * orv) - (nrv * olv))) / (orv - olv))
        oldGap = (_thisFromDB.NestedSetRight - _thisFromDB.NestedSetLeft);
        newGap = (nrv - nlv);
        misc = ((nlv * _thisFromDB.NestedSetRight) - (nrv * _thisFromDB.NestedSetLeft));
        // ==>
        //     nXv = (((oXv * newGap) + misc) / oldGap)
        //

        // NOTE: we cannot update "this" (ie, subroot) record in the update_recordset statement
        //   -- that cause caller (update method) to fail when it calls super because AutoRecVersion is set to off
        //   (which can be done via: Administration->System->Concurrency model configuration, "Skip updating record version automatically").
        // Hence we update "this" differently.

        // oldGap is guaranteed to be non-zero since otherwise it violates the "nested set" integrity
        this.NestedSetLeft  = (((this.NestedSetLeft  * newGap) + misc) / oldGap);
        this.NestedSetRight = (((this.NestedSetRight * newGap) + misc) / oldGap);
        this.TreeLevel      = (1 + _newParentCategoryFromDB.TreeLevel);

        subtree.skipDataMethods(true);
        update_recordset subtree
        setting
            NestedSetLeft  = (((subtree.NestedSetLeft  * newGap) + misc) / oldGap),
            NestedSetRight = (((subtree.NestedSetRight * newGap) + misc) / oldGap),
            TreeLevel      = (subtree.TreeLevel - subroot.TreeLevel) + (1 + _newParentCategoryFromDB.TreeLevel)
        join subroot
        where subroot.Catalog == _thisFromDB.Catalog
            && subroot.RecId == _thisFromDB.RecId
            && subtree.Catalog == subroot.Catalog
            && subroot.NestedSetLeft < subtree.NestedSetLeft
            && subroot.NestedSetLeft < subtree.NestedSetRight
            && subtree.NestedSetRight < subroot.NestedSetRight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doFindNestedSetBounds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds an appropriate gap of the nested set values under the this record so a subtree with given number of nodes can be added under the this record.
    /// </summary>
    /// <param  name='_nNodes'>
    /// The number of nodes the subtree has to add under the this record.
    /// </param>
    /// <returns>
    /// A <c>container</c> of two real values, the first being the left boundary value and the second the right boundary value.
    /// </returns>
    /// <remarks>
    /// The gap found is just the boundary values that are already in use by existing nodes.
    /// Hence caller must not use the gap directly.
    /// Instead, values that are properly within the gap may be used.
    /// That is, values greater than the left boundary value and less than the right boundary values may be used.
    /// Note that the returned gap is not guaranteed to be sufficiently large enough for a subtree with the given number of nodes.
    /// </remarks>
    container doFindNestedSetBounds(int64 _nNodes)
    {
        container rtv;
        container currCon;
        List allGaps = new List(Types::Container);
        ListEnumerator litor;
        CatDisplayCategoryTable thisDisplayCategory, childDisplayCategory;
        real currLV, currRV; // current Left value and current Right value

        real prevRV; // previous Right value
        real prevGapSize = -1;

        ;

        Debug::assert(this.RecId); // cannot be called by a new record
        select forupdate firstonly NestedSetLeft, NestedSetRight from thisDisplayCategory
            where thisDisplayCategory.RecId == this.RecId;

        prevRV = thisDisplayCategory.NestedSetLeft;

        while
            select forupdate NestedSetLeft, NestedSetRight from childDisplayCategory
                order by childDisplayCategory.NestedSetLeft
                where childDisplayCategory.Catalog == this.Catalog
                    // we must find only the *immediate* children
                    && childDisplayCategory.TreeLevel == (1+this.TreeLevel)
                    && this.NestedSetLeft < childDisplayCategory.NestedSetLeft
                    && this.NestedSetLeft < childDisplayCategory.NestedSetRight
                    && childDisplayCategory.NestedSetRight < this.NestedSetRight
        {
            allGaps.addEnd([prevRV, childDisplayCategory.NestedSetLeft]);
            prevRV = childDisplayCategory.NestedSetRight;
        }

        allGaps.addEnd([prevRV, (childDisplayCategory ? childDisplayCategory.NestedSetRight : thisDisplayCategory.NestedSetRight)]);

        // the List is guaranteed to be non-empty because of above - hence the WHILE below will execute at least once.
        // each found gap in the List is guaranteed to have non-negative (could be 0 though) value
        //  - hence we initialize prevGapSize to some negative number so that the IF inside the WHILE below will be executed at least once as well,
        //  -- guaranteeing the rtv will be set (at least once.)

        // now, all available gaps are in the List
        // find the one appropriate to hold the subtree with given number of nodes
        // for now, let's just find the largest gap
        litor = allGaps.getEnumerator();
        while (litor.moveNext())
        {
            currCon = litor.current();

            [currLV, currRV] = currCon;
            if ((currRV - currLV) > prevGapSize)
            {
                prevGapSize = (currRV - currLV);
                rtv = currCon;
            }
        }

        return rtv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAliasesOutsideSubtree</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds all records that are aliases and are outside the subtree rooted at this record.
    /// </summary>
    /// <returns>
    ///    A set of record IDs of the alias records found.
    /// </returns>
    public Set getAliasesOutsideSubtree()
    {
        Set  recIdOfAliasOutsideSubtree = new Set(Types::Int64);
        CatDisplayCategoryTable thisFromDB;
        CatDisplayCategoryTable aliasOutsideSubtree;
        CatDisplayCategoryTable subtreeNode;

        while select RecId from aliasOutsideSubtree
            join RecId from thisFromDB
                where thisFromDB.Catalog == aliasOutsideSubtree.Catalog
                    && thisFromDB.RecId == this.RecId
                    && ( ! (
                        thisFromDB.NestedSetLeft <= aliasOutsideSubtree.NestedSetLeft
                        && thisFromDB.NestedSetLeft < aliasOutsideSubtree.NestedSetRight
                        && aliasOutsideSubtree.NestedSetRight <= thisFromDB.NestedSetRight
                        ) )
                    && aliasOutsideSubtree.TargetCategory != 0
            join RecId from subtreeNode
                where thisFromDB.Catalog == subtreeNode.Catalog
                    // subtreeNode includes the "this" record
                    && thisFromDB.NestedSetLeft <= subtreeNode.NestedSetLeft
                    && thisFromDB.NestedSetLeft < subtreeNode.NestedSetRight
                    && subtreeNode.NestedSetRight <= thisFromDB.NestedSetRight
                    && subtreeNode.SharedData == aliasOutsideSubtree.SharedData
        {
            recIdOfAliasOutsideSubtree.add(aliasOutsideSubtree.RecId);
        }
        return recIdOfAliasOutsideSubtree;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodeType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the node type of this record.
    /// </summary>
    /// <returns>
    ///    An Integer value that indicates the node type.
    /// </returns>
    public int getNodeType()
    {
        #CatDisplayCategory
        int rtv;
        CatDisplayCategorySharedInfo tblSharedData;

        ;

        if (this.TargetCategory)
        {
            rtv = #CatDisplayCategory_NodeType_Alias;
        }
        else
        {
            select firstonly Category from tblSharedData
                where tblSharedData.RecId == this.SharedData;
            if (tblSharedData.Category)
            {
                rtv = #CatDisplayCategory_NodeType_WithPC;
            }
            else
            {
                rtv = #CatDisplayCategory_NodeType_Manual;
            }
        }

        return rtv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWebMenuItemUrlName</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the name of the web menu item of url type for this display category.
    /// </summary>
    /// <returns>
    ///   The name of the web menu item of url type for this display category.
    /// </returns>
    public display Name getWebMenuItemUrlName()
    {
        Name webMenuItemUrlName;
        CatDisplayCategorySharedInfo sharedData;

        if (this.ParentCategory) // non-root
        {
            sharedData = CatDisplayCategorySharedInfo::findByRecId(this.SharedData);
            switch (sharedData.DefaultView)
            {
                case CatProcurementView::ExternalCatalog:
                    webMenuItemUrlName = webUrlItemStr(CatExternalCatalogSearch);
                    break;
                case CatProcurementView::Product:
                    webMenuItemUrlName = webUrlItemStr(CatProductSearch);
                    break;
                case CatProcurementView::Vendor:
                    webMenuItemUrlName = webUrlItemStr(CatVendorSearch);
                    break;
            }
        }
        else // root
        {
            webMenuItemUrlName = webUrlItemStr(CatWelcome);
        }

        return webMenuItemUrlName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValueWithSharedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes data by using the specified information.
    /// </summary>
    /// <param name="_sharedData">
    /// The <c>CatDisplayCategorySharedInfo</c> record to reference.
    /// </param>
    /// <remarks>
    /// The specified <c>CatDisplayCategorySharedInfo</c> record must have been inserted.This record must
    /// not have been inserted.
    /// </remarks>
    void initValueWithSharedData(CatDisplayCategorySharedInfo _sharedData)
    {
        this.SharedData = _sharedData.RecId;
        // default value for IsDescriptiveDataSynchronized
        this.IsDescriptiveDataSynchronized = (_sharedData.Category ? NoYes::Yes : NoYes::No);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the necessary actions before and after the insert.
    /// </summary>
    /// <remarks>
    ///    Finds the correct values to use, and sets them to the <c>NestedSetLeft</c>, <c>NestedSetRight</c>,
    ///    and <c>TreeLevel</c> fields.Checks if the rebuild of the nested set values is necessary after the
    ///    insert is performed, and performs the rebuild if it is necessary.
    /// </remarks>
    public void insert()
    {
        #CatDisplayCategory
        container lr;
        real lv, rv; // Left usable value and Right usable value
        int tl; // TreeLevel
        CatDisplayCategoryTable parent;
        CatDisplayCategoryTranslation catDisplayCategoryTranslation;

        ttsbegin;
            select forupdate firstonly * from parent
                where parent.RecId == this.ParentCategory;
            if (parent)
            {
                lr = CatDisplayCategoryTable::doConvertNestedSetBoundsToUsable(parent.doFindNestedSetBounds(1));
                [lv, rv] = lr;
                tl = (1+parent.TreeLevel);
            }
            else
            {
                lv = #CatDisplayCategory_NestedSet_Root_Left;
                rv = #CatDisplayCategory_NestedSet_Root_Right;
                tl = CatDisplayCategoryTable::treeLevelForRoot();
            }

            this.NestedSetLeft = lv;
            this.NestedSetRight = rv;
            this.TreeLevel = tl;

            super();

            if (CatDisplayCategoryTable::checkNestedSetForRebuild(this.Catalog))
            {
                CatDisplayCategoryTable::rebuildNestedSet(this.Catalog);
            }
        ttscommit;

        //insert data in the translation table in primary language
        catDisplayCategoryTranslation.insertDisplayCategoryTranslation(this.RecId, this.Name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCollapsedToAncestor</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the navigation category is collapsed to an ancestor.
    /// </summary>
    /// <returns>
    ///    true if the navigation category is collapsed to an ancestor category; otherwise, false.
    /// </returns>
    public boolean isCollapsedToAncestor()
    {
        boolean ret = false;

        if (this.AncestorCategoryToCollapseTo != 0 &&
            this.AncestorCategoryToCollapseTo != this.RecId)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDescendantOfPerNSL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Uses the nested set values to determine if the this record is a descendant of the given <paramref>_parentCategoryFromDB</paramref> record.
    /// </summary>
    /// <param  name='_parentCategoryFromDB'>
    /// The record as the candidate parent of the this record.
    /// </param>
    /// <returns>
    /// <c>true</c> if the this record is a descendant of the given <paramref>_parentCategoryFromDB</paramref> record; otherwise, <c>false</c>.
    /// </returns>
    /// <remarks>
    /// The <c>ParentCategory</c> field on the this record must not be used for the checking since it might have been changed.
    /// The <c>TreeLevel</c>, <c>NestedSetLeft</c> and <c>NestedSetRight</c> fields on the this record still have valid values and can be used for checking.
    /// </remarks>
    boolean isDescendantOfPerNSL(CatDisplayCategoryTable _parentCategoryFromDB)
    {
        boolean rtv;

        ;

        // TreeLevel grows larger starting from the root
        rtv = (this.TreeLevel > _parentCategoryFromDB.TreeLevel)
                && (_parentCategoryFromDB.NestedSetLeft < this.NestedSetLeft)
                && (this.NestedSetRight < _parentCategoryFromDB.NestedSetRight);

        return rtv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isImmediateChildOfPerNSL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the this record is an immediate child of the given <paramref>_parentCategoryFromDB</paramref> record using only nested set values.
    /// </summary>
    /// <param  name='_parentCategoryFromDB'>
    /// The record as the candidate parent of the this record.
    /// </param>
    /// <returns>
    /// <c>true</c> if the this record is an immediate child of the given <paramref>_parentCategoryFromDB</paramref> record; otherwise, <c>false</c>.
    /// </returns>
    /// <remarks>
    /// The <c>ParentCategory</c> field on the this record must not be used for the checking since it might have been changed.
    /// The <c>TreeLevel</c>, <c>NestedSetLeft</c> and <c>NestedSetRight</c> fields on the this record still have valid values and can be used for checking.
    /// </remarks>
    boolean isImmediateChildOfPerNSL(CatDisplayCategoryTable _parentCategoryFromDB)
    {
        boolean rtv;

        ;

        rtv = ((this.TreeLevel) == (1+_parentCategoryFromDB.TreeLevel));
        rtv = rtv && this.isDescendantOfPerNSL(_parentCategoryFromDB);

        return rtv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentCategoryChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Compares the <c>ParentCategory</c> field between the cached copy and the database copy of the this record to see if they are different.
    /// </summary>
    /// <param  name='_thisFromDB'>
    /// The buffer (which is considered not initialized, hence will not be read in this method until this method fills it with data)
    /// this method will fill with information from the database using the this record.
    /// This is in effect an output parameter.
    /// </param>
    /// <returns>
    /// The database copy of the parent record if the <c>ParentCategory</c> has changed; otherwise, an empty buffer.
    /// </returns>
    CatDisplayCategoryTable parentCategoryChanged(CatDisplayCategoryTable _thisFromDB)
    {
        CatDisplayCategoryTable newParentCategoryFromDB;

        select forupdate firstonly ParentCategory from _thisFromDB
            where _thisFromDB.RecId == this.RecId;

        // ParentCategory changed?
        if ((this.ParentCategory != _thisFromDB.ParentCategory) && (this.ParentCategory))
        {
            // cannot change from non-root to root (ie, ParentCategory=0):
            if ( ! this.ParentCategory)
            {
                throw error(strfmt("@SYS329936", _thisFromDB.RecId, _thisFromDB.Name));
            }

            // it's critical to use "this.ParentCategory" instead of "_thisFromDB.ParentCategory"
            select forupdate firstonly * from newParentCategoryFromDB
                where newParentCategoryFromDB.RecId == this.ParentCategory;
        }

        return newParentCategoryFromDB;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentCategoryName</Name>
				<Source><![CDATA[
    display Name parentCategoryName()
    {
        Name rtv;
        CatDisplayCategoryTable tblParentCategory;

        if (this.ParentCategory)
        {
            select firstonly Name from tblParentCategory
                where tblParentCategory.RecId == this.ParentCategory;

            if (tblParentCategory)
            {
                rtv = tblParentCategory.Name;
            }
        }

        return rtv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAncestorToCollapseToForSubTree</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the ancestor to collapse for the instance navigation category and all the descendant
    ///    navigation categories.
    /// </summary>
    /// <param name="_isCollapsing">
    ///    A Boolean value that indicates whether the subtree is collapsing.
    /// </param>
    /// <remarks>
    ///    The validation logic will not be executed.
    /// </remarks>
    public void setAncestorToCollapseToForSubTree(NoYes _isCollapsing)
    {
        CatDisplayCategoryTable subtree;
        RecId ancestorCategoryToCollapseTo = (_isCollapsing ? this.RecId : 0);

        ttsbegin;
            subtree.skipDataMethods(true);

            update_recordset subtree
            setting
                AncestorCategoryToCollapseTo = ancestorCategoryToCollapseTo
            where subtree.Catalog == this.Catalog
                && this.NestedSetLeft <= subtree.NestedSetLeft
                && subtree.NestedSetRight <= this.NestedSetRight
            ;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCategoryStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the visibility of the descendants and ancestors of a <c>CatDisplayCategoryTable</c> table.
    /// </summary>
    /// <param name="_isHidden">
    /// A <c>NoYes</c> enumeration value that indicates whether to hide the descendants and ancestors.
    /// </param>
    /// <remarks>
    /// Validation logic will not be executed. The current node will not be included. Do not make this
    /// method public because the user must call the <c>CatDisplayCategoryTable.update</c> or the
    /// <c>CatDisplayCategoryTable.setIsHidden</c> method instead.
    /// </remarks>
    private void setCategoryStatus(NoYes _isHidden)
    {
        CatDisplayCategoryTable subtree;
        CatDisplayCategoryTable ancestor;

        ttsbegin;

        this.reread();

        subtree.skipDataMethods(true);
            // To update the status of the descendants
            update_recordset subtree
            setting
                IsHidden = _isHidden
            where subtree.Catalog == this.Catalog
                && this.NestedSetLeft < subtree.NestedSetLeft
                && this.NestedSetLeft < subtree.NestedSetRight
                && subtree.NestedSetRight < this.NestedSetRight
                && subtree.IsHidden != _isHidden
            ;

            // to update the status of the ascendants only when user wants to active a category, then all the ascendants status should be set to active
            if (_isHidden == NoYes::No)
            {
                ancestor.skipDataMethods(true);

                update_recordset ancestor
                setting
                    IsHidden = _isHidden
                where ancestor.Catalog == this.Catalog
                    && ancestor.NestedSetLeft < this.NestedSetLeft
                    && ancestor.NestedSetLeft < this.NestedSetRight
                    && this.NestedSetRight < ancestor.NestedSetRight
                    && ancestor.IsHidden != _isHidden
                ;
            }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDisplayCategoryName</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Sets this record's name field to given value, or its variant if there is conflict.
    /// </summary>
    /// <param  name='_name'>
    ///   The potential value to set the name field to.
    /// </param>
    /// <remarks>
    ///   This method doesn't
    ///     - check if record is new or existing
    ///     - call update or insert
    ///     - have its own transaction scope.
    /// </remarks>
    public void setDisplayCategoryName(
        EcoResCategoryName  _name
    )
    {
        this.Name = CatDisplayCategoryTable::findNonExistNameInCatalog(this.Catalog, _name, this.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIsHidden</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the category to be hidden or not to be hidden.
    /// </summary>
    /// <param name="_isHidden">
    /// A Boolean value that indicates whether to hide or not to hide this category.
    /// </param>
    /// <param name="_unhideSubTree">
    /// A Boolean value that indicates whether not to hide the sub-tree or only this category.
    /// </param>
    /// <remarks>
    /// When a category is hidden, all of the descendants of the category are also hidden. This includes
    /// the sub-tree.When a category is not hidden, all of the ancestors of the category are also un-hidden.
    /// </remarks>
    public void setIsHidden(NoYes _isHidden, boolean _unhideSubTree = false)
    {
        // if IsHidden NO -->YES,                     set IsHidden to YES for the whole subtree
        // if IsHidden YES--> NO, and _unhideSubTree, set IsHidden to NO  for the whole subtree
        // if IsHidden YES--> NO,                     set IsHidden to YES for all ancestors

        ttsbegin;
            this.reread(); // must do this so that caller doesn't have to refresh data before calling setIsHidden
            this.selectForUpdate(true);
            this.IsHidden = _isHidden;
            if (this.validateWrite())
            {
                this.update();

                if (_unhideSubTree && (_isHidden==NoYes::No))
                {
                    this.setCategoryStatus(_isHidden);
                }
            }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeDescriptiveData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes the descriptive data of this display category to that of the corresponding
    /// <c>EcoResCategory</c> record.
    /// </summary>
    /// <remarks>
    /// This method assumes that this record already exists.This method has its own transaction
    /// scope.Handle both this display category and its translation records.
    /// </remarks>
    void synchronizeDescriptiveData()
    {
        CatDisplayCategorySharedInfo    sharedData;
        EcoResCategory                  erCategory;
        EcoResCategoryTranslation       ercTranslation;

        if (this.IsDescriptiveDataSynchronized == NoYes::Yes)
        {
            sharedData = CatDisplayCategorySharedInfo::findByRecId(this.SharedData);
            erCategory = EcoResCategory::find(sharedData.Category);
            if (erCategory)
            {
                ttsBegin;
                this.selectForUpdate(true);
                this.setDisplayCategoryName(erCategory.Name);
                this.update();

                while select ercTranslation
                    where ercTranslation.Category == erCategory.RecId
                {
                    ercTranslation.synchronizeToDisplayCategoryTranslation(this.RecId);
                }
                ttsCommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the necessary actions before and after the actual update.
    /// </summary>
    /// <remarks>
    ///    The actions performed before an update include verifying that the <c>IsHidden</c> field and the
    ///    alias status have not been changed and checking whether the parent category has changed. If the
    ///    parent category has changed, the necessary actions are performed.
    /// </remarks>
    public void update()
    {
        // **************************************************************************
        // TABLE of prohibited modifications
        // --------------------------------------------------------------------------
        //           alias    manual    WithPC
        // hidden    NA       NA        h_r
        // visible   v_a      v_m       v_r
        // --------------------------------------------------------------------------
        // ALL:
        //     - TreeLevel (etc.)
        // v_a (OK: SharedData, alias status, ParentCategory):
        //     - IsHidden
        //     - UpdateType
        // v_m (OK: alias status, ParentCategory):
        //     - IsHidden
        //     - UpdateType
        //     - SharedData
        // WithPC  (v_r h_r) (OK: IsHidden, UpdateType):
        //     - ParentCategory
        //     - alias status
        //     - SharedData
        //
        // behind-scene processing if any of the following changes:
        //     - ParentCategory
        //     - alias status
        //     - UpdateType
        // **************************************************************************
        CatDisplayCategoryTable         newParentCategoryFromDB;
        CatDisplayCategoryTable         thisFromDB;
        CatDisplayCategorySharedInfo    tblSharedData;
        CatDisplayProductCategory       tblHidden;
        EcoResCategory                  tblERCategory;

        ttsbegin;
            // different parent selected/set?
            if (this.parentCategoryChanged(thisFromDB))
            {
                select forupdate firstonly * from newParentCategoryFromDB
                    where newParentCategoryFromDB.RecId == this.ParentCategory;

                this.doDiffParentSet(thisFromDB, newParentCategoryFromDB);
            }

            // if non-alias-->alias, delete orig SharedData record, and all associated records
            // if alias-->non-alias, create new SharedData record
            if (   ((   thisFromDB.TargetCategory) && ( ! this.TargetCategory))
                || (( ! thisFromDB.TargetCategory) && (   this.TargetCategory)) )
            {
                if (0 != this.TargetCategory)
                {
                    select forupdate firstonly RecId from tblSharedData
                        where tblSharedData.RecId == thisFromDB.SharedData; // critical not to use "this"
                    // NOTE: CatDisplayCategorySharedInfo's cascade action will delete records in relevant tables.
                    // NOTE: SD.delete calls DC.delete (this method), which is NOT what we want.
                    tblSharedData.doDelete();
                }
                else // non-alias
                {
                    tblSharedData.clear();
                    tblSharedData.initValue();
                    // use the un-initialized tblERCategory since alias-->non-alias means this node is one without EcoResCategory counterpart
                    tblSharedData.initMore(this.UpdateType, tblERCategory);
                    tblSharedData.insert();

                    this.SharedData = tblSharedData.RecId;
                }
            }

            // if UpdateType changed, update and delete records in relevant tables.
            if (0 == this.TargetCategory)
            {
                if (thisFromDB.UpdateType != this.UpdateType)
                {
                    select forupdate firstonly * from tblSharedData
                        where tblSharedData.RecId == this.SharedData; // critical to use "this"
                    tblSharedData.setLastSyncTime(this.UpdateType);
                    tblSharedData.update();

                    // dynamic category cannot have manually hidden products
                    if (this.UpdateType == UpdateType::Dynamic)
                    {
                        delete_from tblHidden
                            where tblHidden.SharedData == tblSharedData.RecId
                                && tblHidden.Origin == CatDisplayOrigin::ManuallyHidden
                        ;
                    }
                }
            }

            super();

            if (CatDisplayCategoryTable::checkNestedSetForRebuild(this.Catalog))
            {
                CatDisplayCategoryTable::rebuildNestedSet(this.Catalog);
            }

            if (thisFromDB.IsHidden != this.IsHidden)
            {
                // NOTE: don't call this.setIsHidden which calls this.update - cirular call and danger of infinite loop!
                // Here is how it's designed to work so that caller can call either update or setIsHidden - but NEVER setCategoryStatus:
                // update():
                //      this
                //      setCategoryStatus()
                // setIsHidden():
                //      update()
                //      setCategoryStatus ()

                // HIDE must cascade-down
                // UN-HIDE must cascade-up and must cascade-down

                // update this node (super() above does it)
                this.setCategoryStatus(this.IsHidden);
            }

            if (thisFromDB.AncestorCategoryToCollapseTo != this.AncestorCategoryToCollapseTo)
            {
                this.setAncestorToCollapseToForSubTree(this.AncestorCategoryToCollapseTo != 0);
            }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
        public boolean validateDelete()
    {
        boolean ret;
        CatDisplayCategoryTable tblDisplayCategory;
        CatDisplayCategorySharedInfo tblSharedData;

        ;

        ret = super();

        if (ret)
        {
            select firstonly forupdate RecId from tblDisplayCategory
                where tblDisplayCategory.RecId == this.RecId
                    && tblDisplayCategory.TargetCategory == 0
                join RecId from tblSharedData
                    where tblSharedData.RecId == tblDisplayCategory.SharedData
                        && tblSharedData.Category != 0
            ;
            if (tblDisplayCategory)
            {
                info(strfmt("@SYS134936", this.RecId, this.Name));
                ret = false;
            }
            else
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the necessary validation before the record is written to the database.
    /// </summary>
    /// <returns>
    ///    true if it is OK to write the record; otherwise, false.
    /// </returns>
    public boolean validateWrite()
    {
        #CatDisplayCategory
        boolean ret;
        CatDisplayCategoryTable thisFromDB;
        CatDisplayCategoryTable tmpDisplayCategory, tmpDisplayCategory2;
        CatDisplayCategorySharedInfo tmpSharedData, tmpSharedData2;
        CatProcureCatalogTable tmpCatalog;
        CatDisplayCategoryTable newParentCategoryFromDB;
        boolean notNewRecord = (this.RecId);
        boolean existRecordAliasYes2No; // an existing record changed from alias to non-alias?

        ;

        ret = super();

        if (ret)
        {
            if (notNewRecord)
            {
                select forupdate firstonly * from thisFromDB
                    where thisFromDB.RecId == this.RecId;
            }
            existRecordAliasYes2No = ((notNewRecord) && (thisFromDB.TargetCategory != 0) && (this.TargetCategory == 0));

            if (this.TargetCategory)
            {
                // the node cannot be root
                if ( ! this.ParentCategory)
                {
                    info(strfmt("@SYS136926", this.Name));
                    return false;
                }

                // alias canot have children:
                if (notNewRecord)
                {
                    tmpDisplayCategory.clear();
                    select firstonly forupdate RecId from tmpDisplayCategory
                        where tmpDisplayCategory.Catalog == this.Catalog
                            && tmpDisplayCategory.ParentCategory == this.RecId
                    ;
                    if (tmpDisplayCategory)
                    {
                        info(strfmt("@SYS136927", this.Name));
                        return false;
                    }
                }

                // the SharedData record must have exactly one DC that's (not this) and (not alias)
                tmpDisplayCategory.clear();
                select count(RecId) from tmpDisplayCategory
                    where tmpDisplayCategory.Catalog == this.Catalog
                        && tmpDisplayCategory.SharedData == this.SharedData
                        && tmpDisplayCategory.RecId != this.RecId
                        && tmpDisplayCategory.TargetCategory == 0
                ;
                if (1 != tmpDisplayCategory.RecId)
                {
                    info(strfmt("@SYS136928", this.Name, tmpDisplayCategory.RecId));
                    return false;
                }

                // this node must not have an alias:
                // - the old SharedData record must not have any DC associated with it
                tmpDisplayCategory.clear();
                select firstonly Name from tmpDisplayCategory
                    where tmpDisplayCategory.Catalog == this.Catalog
                        && tmpDisplayCategory.SharedData == thisFromDB.SharedData // do NOT use this.SharedData
                        && tmpDisplayCategory.RecId != this.RecId
                        && tmpDisplayCategory.TargetCategory != 0
                ;
                if (tmpDisplayCategory.RecId)
                {
                    info(strfmt("@SYS138711", this.Name, tmpDisplayCategory.RecId, tmpDisplayCategory.Name));
                    return false;
                }

                // Parent must be non-alias
                tmpDisplayCategory.clear();
                select firstonly forupdate Name from tmpDisplayCategory
                    where tmpDisplayCategory.Catalog == this.Catalog
                        && tmpDisplayCategory.RecId == this.ParentCategory
                        && tmpDisplayCategory.TargetCategory != 0
                ;
                if (tmpDisplayCategory)
                {
                    info(strfmt("@SYS136929", this.Name, tmpDisplayCategory.Name));
                    return false;
                }
            }
            else
            {
                // this check can only be performed if the record is
                // - either a new record,
                // - or an existing record with TargetCategory unchanged (non-alias).
                // this check cannot be performed if the record is existing with changed from alias to non-alias
                // - SharedData still has old value which is now invalid,
                // - update() method, called *after* this method is called, will set SharedData correctly.
                if ( ! existRecordAliasYes2No)
                {
                    // the SharedData record must have no corresponding DC that's (not this) and (not alias)
                    tmpDisplayCategory.clear();
                    select firstonly forupdate Name from tmpDisplayCategory
                        where tmpDisplayCategory.Catalog == this.Catalog
                            && tmpDisplayCategory.SharedData == this.SharedData
                            && tmpDisplayCategory.RecId != this.RecId
                            && tmpDisplayCategory.TargetCategory == 0
                    ;
                    if (tmpDisplayCategory)
                    {
                        info(strfmt("@SYS136930", this.Name, tmpDisplayCategory.Name));
                        return false;
                    }
                }
            }

            newParentCategoryFromDB = this.parentCategoryChanged(thisFromDB);

            // its ParentCategory must not be hidden
            if ( (NoYes::No == this.IsHidden) && newParentCategoryFromDB.RecId && (newParentCategoryFromDB.IsHidden == NoYes::Yes))
            {
                info(strfmt("@SYS136933", this.Name, newParentCategoryFromDB.Name));
                return false;
            }

            // if Catalog's UpdateType is not Both, then this node's UpdateType must match that of the Catalog's
            tmpCatalog.clear();
            select firstonly forupdate Name, UpdateType from tmpCatalog
                where tmpCatalog.RecId == this.Catalog
                    && tmpCatalog.UpdateType != CatProcureCatalogUpdateType::Static;

            if ((tmpCatalog.UpdateType != CatProcureCatalogUpdateType::Both)
                        && (this.UpdateType != tmpCatalog.toDisplayCategoryUpdateType()))
            {
                info(strfmt("@SYS136934", this.RecId, this.Name, this.UpdateType, tmpCatalog.RecId, tmpCatalog.Name, tmpCatalog.UpdateType));

                return false;
            }

            // cannot change SharedData except in above scenarios (an alias, or changed from alias to non-alias)
            // ie, cannot change SharedData if was and still is non-alias.
            if (notNewRecord)
            {
                if ((0 == this.TargetCategory) && (0 == thisFromDB.TargetCategory))
                {
                    if (this.SharedData != thisFromDB.SharedData)
                    {
                        info(strfmt("@SYS136935", this.Name, thisFromDB.SharedData, this.SharedData));
                        return false;
                    }
                }
            }

            // this check cannot be performed if the record is existing with TargetCategory changed from non-0 to 0 (ie, alias to non-alias)
            // - SharedData still has old value which is now invalid,
            // - update() method, called *after* this method is called, will set SharedData correctly.
            if ( ! existRecordAliasYes2No)
            {
                // If this.SharedData.Category<>0, then parent's SharedData.Category must be non-0 as well (ie, a Manual node cannot have a WithPC child)
                select firstonly forupdate Name from tmpDisplayCategory
                    where tmpDisplayCategory.Catalog == this.Catalog
                        && tmpDisplayCategory.RecId == this.RecId
                    join tmpSharedData
                        where tmpSharedData.RecId == tmpDisplayCategory.SharedData
                            && tmpSharedData.Category != 0
                    join tmpDisplayCategory2
                        where tmpDisplayCategory2.RecId == tmpDisplayCategory.ParentCategory
                    join tmpSharedData2
                        where tmpSharedData2.RecId == tmpDisplayCategory2.SharedData
                            && tmpSharedData2.Category == 0
                ;
                if (tmpDisplayCategory)
                {
                    info(strfmt("@SYS136936", this.Name, tmpDisplayCategory.Name));
                    return false;
                }
            }

            // if parent<>0,
            //     - parent's NodeType cannot be an alias
            //     - if this isn't a new record, it must not be the root (ie, cannot change a/the root node to non-root)
            // else, cannot have any existing record with the same (Catalog, Parent)  values (ie, double root)
            tmpDisplayCategory.clear();
            if (this.ParentCategory)
            {
                select firstonly forupdate Name from tmpDisplayCategory
                    where tmpDisplayCategory.Catalog == this.Catalog
                        && tmpDisplayCategory.RecId == this.ParentCategory
                        && tmpDisplayCategory.TargetCategory != 0
                ;
                if (tmpDisplayCategory)
                {
                    info(strfmt("@SYS136929", this.Name, tmpDisplayCategory.Name));
                    return false;
                }

                if (notNewRecord)
                {
                    if ( ! thisFromDB.ParentCategory)
                    {
                        info(strfmt("@SYS136937", this.Name));
                        return false;
                    }
                }
            }
            else
            {
                select firstonly forupdate Name from tmpDisplayCategory
                    where tmpDisplayCategory.Catalog == this.Catalog
                        && tmpDisplayCategory.RecId != this.RecId
                        && tmpDisplayCategory.ParentCategory == 0
                ;
                if (tmpDisplayCategory)
                {
                    info(strfmt("@SYS136938", this.Name, tmpDisplayCategory.Name));
                    return false;
                }
            }

            // different parent selected/set?
            if (newParentCategoryFromDB)
            {
                // is the new Parent the same as the old Parent?
                // NOTE: this shouldn't be possible after above IF?
                // if ( ! (this.isImmediateChildOfPerNSL(newParentCategoryFromDB)))
                ret = (this.canBeImmediateChildOfPerNSL(newParentCategoryFromDB));
            }
        }

        if ( ! ret)
        {
            info(strfmt("@SYS134935", this.RecId));
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a record that matches the given <paramref>_catalog</paramref> of type <c>RefRecId</c> and <paramref>_name</paramref> of type <c>Name</c> exists.
    /// </summary>
    /// <param  name='_catalog'>
    /// An instance of the <c>RefRecId</c> data type.
    /// </param>
    /// <param  name='_name'>
    /// An instance of the <c>Name</c> data type.
    /// </param>
    /// <returns>
    /// <c>true</c> if the record was found; otherwise, <c>false</c>.
    /// </returns>
    public static boolean checkExist(RefRecId _catalog, Name _name)
    {
        if (!CatDisplayCategoryTable::exist(_catalog, _name))
        {
            return checkFailed(strfmt(CatDisplayCategoryTable::txtNotExist(), _catalog, _name));
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNestedSetForRebuild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the nested set values for the given catalog to see if a rebuild is necessary.
    /// </summary>
    /// <param  name='_catalog'>
    /// The <c>RecId</c> of the catalog to check.
    /// </param>
    /// <returns>
    /// A boolean value that indicates whether rebuild is needed.
    /// </returns>
    /// <remarks>
    /// A rebuild is necessary when the nested set values violate their integrity, which includes the following
    /// - a child node's left and right values are properly within that of its parent node,
    /// - two sibling nodes' left and right values properly do not overlap.
    ///
    /// Note: the caller should wrap the call to this method inside a transaction context (ttsbegin and ttscommit).
    /// </remarks>
    static boolean checkNestedSetForRebuild(RecId _catalog)
    {
        // ********************************************************************************
        // **** This is the SQL query to verify child-parent NestedSet values integrity ***
        // **** (child l-r properly within that of parent) ********************************
        // ********************************************************************************
        // SELECT c1.Catalog AS Catalog,
        // 	c1.Name AS c1Name, c1.RecID AS c1ID,
        // 	c1.ParentCategory AS c1Parent,
        // 	me.RecID AS pID, me.Name AS pName,
        // 	me.NestedSetLeft meLEFT,
        // 	c1.NestedSetLeft c1LEFT,
        // 	c1.NestedSetRight c1RGHT,
        // 	me.NestedSetRight meRGHT
        // FROM	CatDisplayCategoryTable (NOLOCK)	c1
        // 	JOIN	CatDisplayCategoryTable (NOLOCK) 	me
        // 		ON	c1.ParentCategory = me.RecID
        // 			AND	me.Catalog = c1.Catalog
        // 			AND
        // 			(
        // 				NOT
        // 					(
        // 						(me.NestedSetLeft < c1.NestedSetLeft )
        // 					AND	(me.NestedSetLeft < c1.NestedSetRight)
        // 					AND	(c1.NestedSetRight< me.NestedSetRight)
        // 					AND	(c1.NestedSetLeft < c1.NestedSetRight)
        // 					)
        // 			)
        // ********************************************************************************
        // **** This is the SQL query to verify child-child NestedSet values integrity ****
        // **** (properly non-overlapping) ************************************************
        // ********************************************************************************
        // SELECT C1.Catalog	AS Catalog,
        // 	C1.Name	AS c1Name, C2.Name	AS c2Name,
        // 	C1.RecID AS c1ID, C2.RecID	AS c2ID,
        // 	C1.NestedSetLeft	AS c1Left, C1.NestedSetRight	AS c1Right,
        // 	C2.NestedSetLeft	AS c2Left, C2.NestedSetRight	AS c2Right
        // FROM CatDisplayCategoryTable	c1
        // 	JOIN CatDisplayCategoryTable	c2
        // 		ON c1.Catalog = c2.Catalog
        // 			AND c1.ParentCategory = c2.ParentCategory
        // WHERE	C1.RecID <> C2.RecID
        // 	AND
        // 		(
        // 			(	C1.NestedSetLeft <= C2.NestedSetLeft
        // 			AND	C2.NestedSetLeft <= C1.NestedSetRight
        // 			)
        // 			OR
        // 			(	C2.NestedSetLeft <= C1.NestedSetLeft
        // 			AND	C1.NestedSetLeft <= C2.NestedSetRight
        // 			)
        // 		)
        // ********************************************************************************

        CatDisplayCategoryTable parent;
        CatDisplayCategoryTable child1;
        CatDisplayCategoryTable child2;

        select firstonly RecId from parent
            join child1
                where child1.ParentCategory == parent.RecId
                    && parent.Catalog == _catalog
                    && ( !
                        (
                            // child's [l,r] is fully within parent's [l,r]:
                            (parent.NestedSetLeft < child1.NestedSetLeft)
                            && (parent.NestedSetLeft < child1.NestedSetRight)
                            && (child1.NestedSetRight < parent.NestedSetRight)

                            && (child1.TreeLevel == (1+parent.TreeLevel))

                            // child's [l,r] satisfies l<r:
                            && (child1.NestedSetLeft < child1.NestedSetRight)
                        )
                    );
        if (parent.RecId)
        {
            return true;
        }
        else
        {
            select firstonly RecId from child1
                    where child1.Catalog == _catalog
                join RecId from child2
                    where child2.Catalog == _catalog
                        && child2.ParentCategory == child1.ParentCategory
                        && (child1.RecId != child2.RecId)
                        // two sibling's [l,r] don't overlap (overlap condition: one's l is within the other's [l,r]):
                        && (
                            (
                                (child1.NestedSetLeft <= child2.NestedSetLeft)
                                && (child2.NestedSetLeft <= child1.NestedSetRight)
                            )
                            || (
                                (child2.NestedSetLeft <= child1.NestedSetLeft)
                                && (child1.NestedSetLeft <= child2.NestedSetRight)
                            )
                        );
            return (child1.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDisplayCategoryTree</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new DisplayCategory tree for the given catalog by copying the Procure Category tree.
    /// </summary>
    /// <param name='_catalog'>
    /// The catalog the new DisplayCategory tree is for.
    /// </param>
    /// <param name='_procureHierarchy'>
    /// The procurement hierarchy object.
    /// </param>
    /// <remarks>
    /// This method will lock the ProcureCategory to prevent its tree structure from being modified
    /// All nodes of the new DisplayCategory tree will be persisted.
    /// The given <paramref>_catalog</paramref> must have non-null RecId.
    /// </remarks>
    public static void createDisplayCategoryTree(CatProcureCatalogTable _catalog, EcoResCategoryHierarchy _procureHierarchy)
    {
        EcoResCategory tblERCategory, tblERCategoryRoot;
        CatDisplayCategorySharedInfo tblSharedData;
        CatDisplayCategoryTable tblDCategory, parent;
        Map erCategoryRecID_DCategory = new Map(Types::Int64, Types::Record);
        Map erCategoryRecID_nextChildIndex = new Map(Types::Int64, Types::Integer);
        int childIndex;
        Description displayCategoryDescription;
        UpdateType  displayCategoryUpdateType = CatProcureCatalogTable::catalogToDisplayCategoryUpdateType(_catalog.UpdateType);
        #EcoResCategoryDefaults

        ttsbegin;
        // lock the ProcureCategory root to prevent its tree structure from being modified
        select pessimisticlock firstonly RecId from tblERCategoryRoot
            where tblERCategoryRoot.CategoryHierarchy== _procureHierarchy.RecId
                && tblERCategoryRoot.NestedSetLeft   == #ECORESROOTNESTEDLEFTVALUE;

        while select forupdate * from tblERCategory
            // important for processing to start from root due to Map
            order by tblERCategory.Level asc
            where tblERCategory.CategoryHierarchy == _procureHierarchy.RecId
        {
            parent.clear();
            if (tblERCategory.ParentCategory)
            {
                parent = erCategoryRecID_DCategory.lookup(tblERCategory.ParentCategory);
                childIndex = erCategoryRecID_nextChildIndex.lookup(tblERCategory.ParentCategory);
                // alas: Map doesn't have API to *update* value for given key. "remove+insert" is in effect "update".
                erCategoryRecID_nextChildIndex.remove(tblERCategory.ParentCategory);
                erCategoryRecID_nextChildIndex.insert(tblERCategory.ParentCategory, 1+childIndex);
                if ( ! parent.RecId)
                {
                    error(strfmt("@SYS340007", tblERCategory.RecId, tblERCategory.Name));
                }
            }
            else
            {
                childIndex = 1; // 1 for root
            }

            {
                tblSharedData.clear();
                tblSharedData.initValue();
                tblSharedData.initMore(displayCategoryUpdateType, tblERCategory);
                tblSharedData.insert();
            }
            {
                tblDCategory = CatDisplayCategoryTable::initDisplayCategory(_catalog, tblERCategory.Name, parent, tblSharedData, displayCategoryUpdateType, tblERCategory);
                displayCategoryDescription = EcoResCategoryTranslation::find(tblERCategory.RecId, LanguageTable::defaultLanguage()).Description;
                // insert method will take care of setting NestedSet values and TreeLevel
                tblDCategory.insert();
            }
            erCategoryRecID_DCategory.insert(tblERCategory.RecId, tblDCategory);
            erCategoryRecID_nextChildIndex.insert(tblERCategory.RecId, 1);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultNameForNewCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default name to use for a new display category.
    /// </summary>
    /// <returns>
    /// The default name to use for a new display category.
    /// </returns>
    public static Name defaultNameForNewCategory()
    {
        return "@SYS343525";
    }

]]></Source>
			</Method>
			<Method>
				<Name>doConvertNestedSetBoundsToUsable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the given nested set boundary values to usable nested set values.
    /// </summary>
    /// <param  name='_lrb'>
    /// A <c>container</c> of two real values, the first being the left boundary value and the second the right boundary value.
    /// </param>
    /// <returns>
    /// A <c>container</c> of two real values, the first being the left usable value and the second the right usable value.
    /// </returns>
    /// <remarks>
    /// The nested set boundary values cannot be immediately used without violating the integrity since existing nodes are already using them.
    /// This method converts the given boundary values to nested set values that can be immediately used without violating the integrity.
    /// </remarks>
    static container doConvertNestedSetBoundsToUsable(container _lrb)
    {
        container rtv;
        real lb, rb;
        real lu, ru;

        ;

        [lb, rb] = _lrb;
        // we use a simply algorithm: just half of (lb, rb)
        lu = lb + 0.25*(rb - lb);
        ru = lb + 0.75*(rb - lb);
        rtv = [lu, ru];

        return rtv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a record that matches the given <paramref>_catalog</paramref> of type <c>RefRecId</c> and <paramref>_name</paramref> of type <c>Name</c> exists.
    /// </summary>
    /// <param  name='_catalog'>
    /// An instance of the <c>RefRecId</c> data type.
    /// </param>
    /// <param  name='_name'>
    /// An instance of the <c>Name</c> data type.
    /// </param>
    /// <returns>
    /// <c>true</c> if the record was found; otherwise, <c>false</c>.
    /// </returns>
    public static boolean exist(RefRecId _catalog, Name _name)
    {
        return (CatDisplayCategoryTable::find(_catalog, _name).RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the record that matches the given <paramref>_catalog</paramref> of type <c>RefRecId</c> and <paramref>_name</paramref> of type <c>Name</c>.
    /// </summary>
    /// <param  name='_catalog'>
    /// An instance of the <c>RefRecId</c> data type.
    /// </param>
    /// <param  name='_name'>
    /// An instance of the <c>Name</c> data type.
    /// </param>
    /// <param  name='_forUpdate'>
    /// An instance of the boolean data type.
    /// </param>
    /// <returns>
    /// An instance of the <c>CatDisplayCategoryTable</c> data type.
    /// </returns>
    public static CatDisplayCategoryTable find(RefRecId _catalog, Name _name, boolean _forUpdate = false)
    {
        CatDisplayCategoryTable tblCatDisplayCategoryTable;

        ;

        if (_catalog && _name)
        {
            tblCatDisplayCategoryTable.selectForUpdate(_forUpdate);

            select firstonly * from tblCatDisplayCategoryTable
                where tblCatDisplayCategoryTable.Catalog == _catalog
                    && tblCatDisplayCategoryTable.Name == _name;
        }

        return tblCatDisplayCategoryTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCategoryForVendorOnSite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds any active display category the given vendor is associated with.
    /// </summary>
    /// <param  name='_vendorDataAreaId'>
    /// The data area of the vendor to find display category for.
    /// </param>
    /// <param  name='_vendorAccountNum'>
    /// The account number of the vendor to find display category for.
    /// </param>
    /// <param  name='_displayCategoryRecId'>
    /// The record id of any display category which points to the catalog record under which to
    /// look for a display category associated with the given vendor.
    /// </param>
    /// <returns>
    /// Record id of the first display category that is both under the catalog the given display category points to
    /// and is associated with the given vendor.
    /// </returns>
    public static RefRecId findCategoryForVendorOnSite(dataAreaId _vendorDataAreaId, VendAccount _vendorAccountNum, RefRecId _displayCategoryRecId)
    {
        CatDisplayCategoryTable catDisplayCategoryTableThis;
        CatDisplayCategoryTable catDisplayCategoryTable;
        CatDisplayVendorSiteAll catDisplayVendorSiteAll;
        VendCategory   vendCategory;
        RefRecId                result;

        if (_displayCategoryRecId && _vendorAccountNum && _vendorDataAreaId)
        {
            select firstonly RecId from catDisplayCategoryTable
                join RecId from catDisplayCategoryTableThis
                    where catDisplayCategoryTableThis.RecId == _displayCategoryRecId
                        && catDisplayCategoryTableThis.Catalog == catDisplayCategoryTable.Catalog
                        && catDisplayCategoryTable.IsHidden == NoYes::No
                join RecId from catDisplayVendorSiteAll
                    where catDisplayVendorSiteAll.SharedDataRecId == catDisplayCategoryTable.SharedData
                join RecId from vendCategory
                    where  vendCategory.Category == catDisplayVendorSiteAll.ProcurementCategory
                        && vendCategory.VendorAccount == _vendorAccountNum
                        && vendCategory.VendorDataArea == _vendorDataAreaId
            ;
            result = catDisplayCategoryTable.RecId;
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNonExistNameInCatalog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds a name that does not match any existing <c>CatDisplayCategoryTable</c> record in the given catalog.
    /// </summary>
    /// <param name="_catalogRecId">
    ///    The catalog record ID.
    /// </param>
    /// <param name="_strValueExactMatch">
    ///    The exact value to match the <c>Name</c> field.
    /// </param>
    /// <param name="_excludedRecId">
    ///    The record ID to exclude in search for non-exist name.
    /// </param>
    /// <returns>
    ///    A string that would not conflict with any existing <c>CatDisplayCategoryTable</c> record's name column in the given catalog.
    /// </returns>
    /// <remarks>
    ///    An exception is thrown if we cannot find one after exhausting all possibilities.
    /// </remarks>
    public static Name findNonExistNameInCatalog(
        RefRecId    _catalogRecId,
        Name        _strValueExactMatch = CatDisplayCategoryTable::defaultNameForNewCategory(),
        recId       _excludedRecId = 0
    )
    {
        // The string value formatter to use when exact match for the <c>Name</c> field already exists.
        // eg: @SYS332074="%1 - %2", and _strValueExactMatch="New node"
        //  - after this statement:
        //      strValueFormatter="New node - %1"
        //  - after EcoResCategory::findNonExistByString:
        //      result="New node - 4"
        str  strValueFormatter  = strFmt("@SYS332074", _strValueExactMatch, '%1');

        return EcoResCategory::findNonExistByString(
            tablenum(CatDisplayCategoryTable),
            fieldnum(CatDisplayCategoryTable, Catalog),
            _catalogRecId,
            fieldnum(CatDisplayCategoryTable, Name),
            extendedtypenum(Name),
            _strValueExactMatch, strValueFormatter,
            _excludedRecId
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRootForCatalog</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Finds the root display category record of a given catalog.
    /// </summary>
    /// <param  name='_catalogRecId'>
    ///   The record ID of a catalog to find root for.
    /// </param>
    /// <returns>
    ///   The root display category record of the given catalog.
    /// </returns>
    public static CatDisplayCategoryTable findRootForCatalog(recId _catalogRecId)
    {
        CatDisplayCategoryTable rootDisplayCategory;

        if (_catalogRecId)
        {
            select firstOnly * from rootDisplayCategory
                where  rootDisplayCategory.Catalog == _catalogRecId
                    && rootDisplayCategory.TreeLevel== CatDisplayCategoryTable::treeLevelForRoot()
            ;
        }

        return rootDisplayCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRootForCategory</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Finds the root display category record of a given catalog.
    /// </summary>
    /// <param  name='_displayCategoryRecId'>
    ///   The record ID of any display category node in a catalog to find root for.
    /// </param>
    /// <returns>
    ///   The root display category record of the given catalog.
    /// </returns>
    public static CatDisplayCategoryTable findRootForCategory(recId _displayCategoryRecId)
    {
        CatDisplayCategoryTable rootDisplayCategory, givenDisplayCategory;

        if (_displayCategoryRecId)
        {
            select firstOnly * from rootDisplayCategory
                join recId from givenDisplayCategory
                    where  givenDisplayCategory.Catalog == rootDisplayCategory.Catalog
                        && givenDisplayCategory.RecId   == _displayCategoryRecId
                        && rootDisplayCategory.TreeLevel== CatDisplayCategoryTable::treeLevelForRoot()
            ;
        }

        return rootDisplayCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSingleGridPageSize</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the page size to be used while displaying records in EP
    /// </summary>
    /// <param  name='_displayCategoryRecId'>
    /// recId of <c>CatDisplaCategoryTable</c> table.
    /// </param>
    /// <returns>
    /// <c>int</c> Returns the page size to be displayed in EP based on active catalog settings
    /// </returns>
    public static int getSingleGridPageSize(recId _displayCategoryRecId)
    {
        CatProcureCatalogTable procureCatalogTable;
        CatDisplayCategoryTable  displayCategoryTable;

        select recId, SingleGridPageSize from procureCatalogTable
            join recId, Catalog from displayCategoryTable
                where displayCategoryTable.Catalog == procureCatalogTable.RecId
                    && displayCategoryTable.RecId == _displayCategoryRecId;

        return procureCatalogTable.SingleGridPageSize;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDisplayCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>CatDisplayCategoryTable</c> record and initializes it with the given data.
    /// </summary>
    /// <param  name='_catalog'>
    /// The <c>CatProcureCatalogTable</c> record this <c>CatDisplayCategoryTable</c> record is for.
    /// </param>
    /// <param  name='_name'>
    /// An instance of the <c>Name</c> data type, as the name for the <c>CatDisplayCategoryTable</c> record.
    /// </param>
    /// <param  name='_parent'>
    /// The <c>CatDisplayCategoryTable</c> record this <c>CatDisplayCategoryTable</c> record should be be a child node of.
    /// </param>
    /// <param  name='_sharedData'>
    /// The <c>CatDisplayCategorySharedInfo</c> record this <c>CatDisplayCategoryTable</c> record should be associated with.
    /// </param>
    /// <param  name='_updateType'>
    /// The update type for the display category.
    /// </param>
    /// <param  name='_erCategory'>
    /// The <c>EcoResCategory</c> record this node is for.
    /// </param>
    /// <returns>
    /// An instance of the <c>CatDisplayCategoryTable</c> data type, initializes with the given data, but not persisted.
    /// </returns>
    /// <remarks>
    /// The <c>CatProcureCatalogTable</c> record is not persisted.
    /// Default value for UpdateType will be (1) if the given parent is available, the parent category's update type, (2) otherwise, the given catalog's update type.
    /// </remarks>
    public static CatDisplayCategoryTable initDisplayCategory(CatProcureCatalogTable _catalog,
                                                              Name _name,
                                                              CatDisplayCategoryTable _parent,
                                                              CatDisplayCategorySharedInfo _sharedData,
                                                              UpdateType _updateType = (_parent ? _parent.UpdateType : _catalog.toDisplayCategoryUpdateType()),
                                                              EcoResCategory _erCategory = null
                                                             )
    {
        CatDisplayCategoryTable tblDCategory;
        NoYes isHidden;

        // added node will be (in this order)
        //   if no EcoResCategory couterpart
        //     inherit from parent
        //   else
        //     if (parent is non-hidden) && (couterpart IsActive)
        //       non-hidden
        //     else
        //       hidden
        if ( ! _erCategory)
        {
            isHidden = _parent.IsHidden;
        }
        else if ((_erCategory.IsActive == NoYes::Yes) && (_parent.IsHidden == NoYes::No))

        {
            isHidden = NoYes::No;
        }
        else
        {
            isHidden = NoYes::Yes;
        }

        tblDCategory.clear();
        tblDCategory.initValue();
        tblDCategory.initValueWithSharedData(_sharedData);
        tblDCategory.Catalog = _catalog.RecId;
        tblDCategory.Name = _name;
        tblDCategory.ParentCategory = _parent.RecId;
        tblDCategory.UpdateType = _updateType;
        tblDCategory.TargetCategory = 0;
        tblDCategory.AncestorCategoryToCollapseTo = _parent.AncestorCategoryToCollapseTo;
        tblDCategory.IsHidden = isHidden;
        return tblDCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildNestedSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rebulids the nested set values for all nodes of the given catalog.
    /// </summary>
    /// <param  name='_catalog'>
    /// The <c>RecId</c> of the catalog to rebuild.
    /// </param>
    /// <remarks>
    /// The <c>ParentCategory</c> fields in the nodes must have been properly set.
    /// Note: the caller should wrap the call to this method inside a transaction context (ttsbegin and ttscommit).
    /// </remarks>
    static void rebuildNestedSet(RecId _catalog)
    {
        #CatDisplayCategory
        CatDisplayCategoryTable root;

        select forupdate * from root
            where root.Catalog == _catalog
                && root.TreeLevel == CatDisplayCategoryTable::treeLevelForRoot();
        CatDisplayCategoryTable::rebuildNestedSetForNode(root, #CatDisplayCategory_NestedSet_Root_Left);
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildNestedSetForNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rebulids the nested set values for the whole subtree rooted at the given node.
    /// </summary>
    /// <param  name='_currNode'>
    /// The root node of the subtree to rebuild.
    /// </param>
    /// <param  name='_lv4curr'>
    /// The left value to use in the rebuild for the root node of the subtree to rebuild.
    /// </param>
    /// <returns>
    /// The right value used in the rebuild for the root node of the subtree during the rebuild.
    /// </returns>
    /// <remarks>
    /// The <c>ParentCategory</c> fields in the nodes must have been properly set.
    /// Note: the caller should wrap the call to this method inside a transaction context (ttsbegin and ttscommit).
    /// If this method is called by the <c>insert</c> method, then <c>insert</c> must have called <c>super</c>
    /// so that the records are already in the database.
    ///
    /// <c>doUpdate</c> is called on all nodes as part of the build.
    /// </remarks>
    static real rebuildNestedSetForNode(CatDisplayCategoryTable _currNode, real _lv4curr)
    {
        #CatDisplayCategory
        real rv;
        CatDisplayCategoryTable immediateChild;

        ;

        _currNode.NestedSetLeft = _lv4curr;

            rv = #CatDisplayCategory_NestedSet_StepSize + _lv4curr;
            while select forupdate * from immediateChild
                where immediateChild.ParentCategory == _currNode.RecId
            {
                rv = #CatDisplayCategory_NestedSet_StepSize + CatDisplayCategoryTable::rebuildNestedSetForNode(immediateChild, rv);
            }

        _currNode.NestedSetRight = rv;
        _currNode.doUpdate(); // IMPORTANT: don't call write()|insert()|update() - they call this method.
        return rv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeLevelForRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tree level for the root node of any display category tree.
    /// </summary>
    /// <returns>
    /// The root node's tree level for any display category tree.
    /// </returns>
    public static int treeLevelForRoot()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
        public static str txtNotExist()
    {
        return "@SYS131155";
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>ProcCatalog</ConfigurationKey>
	<DeveloperDocumentation>@SYS130975</DeveloperDocumentation>
	<Label>@SYS131173</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>Name</TitleField1>
	<TitleField2>Catalog</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>FoundAndEmpty</CacheLookup>
	<Modules>ProcurementAndSourcing</Modules>
	<ReplacementKey>CatalogNameIdx</ReplacementKey>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Catalog</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TargetCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NestedSetLeft</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NestedSetRight</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SharedData</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TreeLevel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UpdateType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsHidden</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsDescriptiveDataSynchronized</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Default</Name>
			<Label>@SYS26467</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Catalog</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TargetCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NestedSetLeft</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NestedSetRight</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SharedData</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TreeLevel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UpdateType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsHidden</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsDescriptiveDataSynchronized</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>DisplaySetting</Name>
			<Label>@SYS312287</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AncestorCategoryToCollapseTo</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>General</Name>
			<Label>@SYS19924</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsHidden</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Options</Name>
			<Label>@SYS132118</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>UpdateType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TargetCategory</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>AncestorCategoryToCollapseTo</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS312284</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Catalog</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsDescriptiveDataSynchronized</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS345149</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsHidden</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS54478</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Name</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>NestedSetLeft</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RealBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>NestedSetRight</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RealBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ParentCategory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SharedData</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TargetCategory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS134847</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>TreeLevel</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Integer</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UpdateType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Mandatory>Yes</Mandatory>
			<EnumType>UpdateType</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes>
		<AxTableFullTextIndex>
			<Name>FullTextIdx</Name>
			<Fields>
				<AxTableIndexField>
					<DataField>Name</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableFullTextIndex>
	</FullTextIndexes>
	<Indexes>
		<AxTableIndex>
			<Name>CatalogNameIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>Catalog</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ParentCategory</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Name</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>NestedSetLeft</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>NestedSetRight</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CatalogLeftRightIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Catalog</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>NestedSetLeft</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>NestedSetRight</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SharedDataIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>SharedData</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Catalog</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TargetCategory</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AncestorCategoryToCollapseTo</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CatDisplayCategoryTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CatDisplayCategoryTable_2</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CatDisplayCategoryTable_2_CatDisplayCategoryTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AncestorCategoryToCollapseTo</Name>
					<Field>AncestorCategoryToCollapseTo</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CatDisplayCategorySharedInfo</Name>
			<Cardinality>OneMore</Cardinality>
			<RelatedTable>CatDisplayCategorySharedInfo</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>CatDisplayCategorySharedInfo</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>CatDisplayCategorySharedInfo_CatDisplayCategoryTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SharedData</Name>
					<Field>SharedData</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CatDisplayCategoryTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CatDisplayCategoryTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CatDisplayCategoryTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CatDisplayCategoryTable_CatDisplayCategoryTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ParentCategory</Name>
					<Field>ParentCategory</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CatProcureCatalogTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CatProcureCatalogTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>CatProcureCatalogTable</RelatedTableRole>
			<RelationshipType>Composition</RelationshipType>
			<Role>CatProcureCatalogTable_CatDisplayCategoryTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Catalog</Name>
					<Field>Catalog</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TargetCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CatDisplayCategoryTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CatDisplayCategoryTable_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CatDisplayCategoryTable_1_CatDisplayCategoryTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TargetCategory</Name>
					<Field>TargetCategory</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>