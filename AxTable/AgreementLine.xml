<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AgreementLine</Name>
	<SourceCode>
		<Declaration><![CDATA[
public abstract class AgreementLine extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>agreementHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>AgreementHeader</c> record from the current <c>AgreementLine</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The <c>AgreementHeader</c> record.
    /// </returns>
    public AgreementHeader agreementHeader(boolean _forUpdate = false)
    {
        return AgreementHeader::find(this.Agreement, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementHeaderDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>AgreementHeaderDefault</c> record from the current <c>AgreementLine</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The <c>AgreementHeaderDefault</c> record.
    /// </returns>
    public AgreementHeaderDefault agreementHeaderDefault(boolean _forUpdate = false)
    {
        return AgreementHeaderDefault::findAgreementHeader(this.Agreement, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementLineDefault</Name>
				<Source><![CDATA[
    public AgreementLineDefault agreementLineDefault(boolean  _forupdate = false)
    {
        AgreementLineDefault agreementLineDefault;

        if (this.RecId)
        {
            agreementLineDefault.selectForUpdate(_forupdate);

            select agreementLineDefault
                where agreementLineDefault.AgreementLine == this.RecId;
        }

        return agreementLineDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementModuleType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the type of the agreement.
    /// </summary>
    /// <returns>
    ///    Either the purchase or sales type.
    /// </returns>
    /// <remarks>
    ///    This method uses the non-polymorphic method of the <c>AgreementHeader</c> class.
    /// </remarks>
    ModuleSalesPurch agreementModuleType()
    {
        AgreementHeader agreementHeader = this.agreementHeader();
        return agreementHeader.getModuleType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAgreementRemansOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the remains for an instance of the <c>AgreementLine</c> class and returns them in a
    ///    container.
    /// </summary>
    /// <returns>
    ///    A container that includes the remaining, invoiced, delivered-but-not-invoiced, and
    ///    released-but-neither-invoiced-nor-delivered quantities or amounts for the instance of the
    ///    <c>AgreementLine</c> class.
    /// </returns>
    public container calculateAgreementRemansOnServer()
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the agreement line can be deleted.
    /// </summary>
    /// <returns>
    ///     true if the agreement line can be deleted; otherwise, false.
    /// </returns>
    public boolean canDeleteAgreementLine()
    {
        return !this.isReleased() && !this.isDerivedAgreement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLinkTo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified order line can be associated with the current agreement line.
    /// </summary>
    /// <param name="_salesPurchLine">
    ///    The <c>SalesLine</c> or <c>PurchLine</c> record to check.
    /// </param>
    /// <returns>
    ///    true if the specified record can be associated with the agreement line; otherwise, false.
    /// </returns>
    public boolean canLinkTo(SalesPurchLine _salesPurchLine)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryChanged</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the values in the <c>AgreementLine</c> record when the category has been changed.
    /// </summary>
    public void categoryChanged()
    {
        InventDim       inventDim;
        InventDimParm   inventDimParm;

        if (this.Category)
        {
            inventDim = this.inventDim();
            inventDimParm.setActiveSiteAndWarehouseDimensions();
            inventDim.clearNotSelectedDim(inventDimParm);
            this.setInventDimId(inventDim.InventDimId, InventDim::findOrCreate(inventDim));

            this.ItemId = '';
        }

        this.setCommitment();
        this.setLineProduct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchInventProfile_RU</Name>
				<Source><![CDATA[
    private boolean checkPurchInventProfile_RU(InventDim _inventDim = this.inventDim())
    {
        boolean ok = true;
        PurchAgreementHeaderExt_RU purchAgreementHeaderExt = PurchAgreementHeaderExt_RU::findByPurchAgreementHeader(this.Agreement);

        if (! _inventDim.InventProfileId_RU)
        {
            return ok;
        }

        if (purchAgreementHeaderExt.InventProfileType &&
            purchAgreementHeaderExt.InventProfileType != InventProfile_RU::find(_inventDim.InventProfileId_RU).InventProfileType)
        {
            ok = checkFailed(strFmt("@GLS220558",
                                    _inventDim.InventProfileId_RU,
                                    purchAgreementHeaderExt.InventProfileType));
        }
        if (purchAgreementHeaderExt.InventProfileId &&
            purchAgreementHeaderExt.InventProfileId != _inventDim.InventProfileId_RU)
        {
            ok = checkFailed(strFmt("@GLS220559",
                                    _inventDim.InventProfileId_RU,
                                    purchAgreementHeaderExt.InventProfileId));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRemaining</Name>
				<Source><![CDATA[
    public boolean checkRemaining(RealBase _q)
    {
        if (this.IsMaxEnforced && this.remainingQueried() < _q)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSalesInventProfile_RU</Name>
				<Source><![CDATA[
    private boolean checkSalesInventProfile_RU(InventDim _inventDim = this.inventDim())
    {
        boolean     ok = true;
        InventProfile_RU inventProfile;
        SalesAgreementHeaderExt_RU salesAgreementHeaderExt;

        if (! _inventDim.InventProfileId_RU)
        {
            return ok;
        }

        salesAgreementHeaderExt = SalesAgreementHeaderExt_RU::findBySalesAgreementHeader(this.Agreement);

        if (salesAgreementHeaderExt.InventProfileType &&
            salesAgreementHeaderExt.InventProfileType != InventProfile_RU::find(_inventDim.InventProfileId_RU).InventProfileType)
        {
            ok = checkFailed(strfmt("@GLS220562",
                                    _inventDim.InventProfileId_RU,
                                    salesAgreementHeaderExt.InventProfileType));
        }
        if (salesAgreementHeaderExt.InventProfileId &&
            salesAgreementHeaderExt.InventProfileId != _inventDim.InventProfileId_RU)
        {
            ok = checkFailed(strfmt("@GLS220561",
                                    _inventDim.InventProfileId_RU,
                                    salesAgreementHeaderExt.InventProfileId));
        }

        if (salesAgreementHeaderExt.SalesInvoicePostingType == SalesInvoicePostingType_RU::GoodsInRoute)
        {
            inventProfile = InventProfile_RU::find(_inventDim.InventProfileId_RU);

            ok = ok && InventProfile_RU::checkGITProfileType(inventProfile.InventProfileType);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts currency dependable fields when currency code has been changed according to exchange rates
    /// between old and new currencies.
    /// </summary>
    /// <param name="_fromCurrencyCode">
    /// The old currency that is used by <c>Agreement</c>.
    /// </param>
    /// <param name="_toCurrencyCode">
    /// The new currency that will be used by <c>Agreement</c>.
    /// </param>
    /// <param name="_exchRateDate">
    /// The date to pick for a correct exchange rate.
    /// </param>
    void convertCurrencyCode( CurrencyCode           _fromCurrencyCode,
                                     CurrencyCode           _toCurrencyCode,
                                     TransDate              _exchRateDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        if (_fromCurrencyCode && _toCurrencyCode && (_fromCurrencyCode != _toCurrencyCode))
        {
            // Perform recalculations only if both currency codes are specified and they are not the same
            // Convert agreed release amounts
            // MAX...
            if (this.AgreedReleaseLineMaxAmount)
            {
                this.AgreedReleaseLineMaxAmount = CurrencyExchangeHelper::curAmount2CurAmount(this.AgreedReleaseLineMaxAmount, _fromCurrencyCode, _toCurrencyCode, _exchRateDate);
                if (this.IsModified != NoYes::Yes)
                {
                    this.IsModified = NoYes::Yes;
                }
            }

            // ...min
            if (this.AgreedReleaseLineMinAmount)
            {
                this.AgreedReleaseLineMinAmount = CurrencyExchangeHelper::curAmount2CurAmount(this.AgreedReleaseLineMinAmount, _fromCurrencyCode, _toCurrencyCode, _exchRateDate);
                if (this.IsModified != NoYes::Yes)
                {
                    this.IsModified = NoYes::Yes;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </summary>
    /// <param name="_defaultDimension">
    /// A dimension set to apply to the <c>defaultDimension</c> field on this table.
    /// </param>
    /// <param name="_dimensionCopy">
    /// A <c>dimensionCopy</c> object that was instantiated with the current buffer; optional.
    /// </param>
    /// <returns>
    /// A dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are not overwritten.
    /// </remarks>
    public DimensionDefault copyDimension(
        DimensionDefault _defaultDimension,
        DimensionCopy    _dimensionCopy = DimensionCopy::newFromTable(
            this,
            this.agreementHeader().getLegalEntity().RecId)
        )
    {
        return _dimensionCopy.copy(_defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the currency that is used for the agreement.
    /// </summary>
    /// <returns>
    ///    The currency code.
    /// </returns>
    public CurrencyCode currencyCode()
    {
        return this.agreementHeader().Currency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the records in the <c>AgreementLine</c> table and subtype tables.
    /// </summary>
    /// <remarks>
    /// For more information, see the <see cref="T:AgreementLine" />, <see
    /// cref="T:AgreementLineVolumeCommitment" />, <see cref="T:AgreementLineQuantityCommitment" />.
    /// </remarks>
    public void  delete()
    {
        if (CLMIntegrationFeature::isEnabled() && this.IsIntegration != PurchAgreementIntegrationType::CLM)
        {
            PurchAgreementHeader header = PurchAgreementHeader::find(this.Agreement);
            if (header && header.CLMIntegrationPurchAgreementOwnership == CLMIntegrationPurchaseAgreementOwnershipType::CLM)
            {
                throw error(strFmt("@CLMIntegration:ErrorWhenDeleteCLMIntegrationPurchAgreementLine", header.PurchNumberSequence));
            }
        }
            
        AgreementHeaderRecId   headerRecId = this.Agreement;
        // <GEERU>
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (this.IntraCompanySkipUpdate_RU == InterCompanySkipUpdate::No)
            {
                this.deleteIntracompanyAgreementLine_RU();
            }
        }
        // </GEERU>

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            this.markCurrentTaxDocumentTaxStatusDirty();
        }
        // </GTE>

        if (this.InterCompanySkipUpdate == InterCompanySkipUpdate::No)
        {
            this.deleteIntercompanyAgreementLine();
        }

        if (this.historyExists())
        {
            this.softDelete();
        }
        else
        {
            if (AgreementLineCallSuperInOverriddenMethodsFlight::instance().isEnabled())
            {
                super();
            }
            else
            {
                this.doDelete();
            }
        }

        this.updateHeaderDates(headerRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteIntercompanyAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the related intercompany agreement line and reference.
    /// </summary>
    public void deleteIntercompanyAgreementLine()
    {
        AgreementLine           intercompanyAgreementLine;
        AgreementLineReference  agreementLineReference;
        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // <GEERU>
        if (countryRegion_RU)
        {
            select forupdate agreementLineReference
                where (agreementLineReference.DerivedAgreementLine == this.RecId
                       || agreementLineReference.SourceAgreementLine  == this.RecId)
                   && !agreementLineReference.IsIntraCompany_RU;
        }
        else
        {
            // </GEERU>
            select forupdate agreementLineReference
                where agreementLineReference.DerivedAgreementLine == this.RecId
                   || agreementLineReference.SourceAgreementLine  == this.RecId;
            // <GEERU>
        }
        // </GEERU>

        if (agreementLineReference.RecId)
        {
            ttsbegin;
            select forupdate intercompanyAgreementLine
                where (intercompanyAgreementLine.RecId == agreementLineReference.SourceAgreementLine
                   ||  intercompanyAgreementLine.RecId == agreementLineReference.DerivedAgreementLine)
                   && intercompanyAgreementLine.RecId  != this.RecId;

            intercompanyAgreementLine.InterCompanySkipUpdate = InterCompanySkipUpdate::Internal;

            intercompanyAgreementLine.delete();
            agreementLineReference.delete();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteIntracompanyAgreementLine_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deletes the related intracompany agreement line and reference.
    /// </summary>
    public void deleteIntracompanyAgreementLine_RU()
    {
        AgreementLine           intercompanyAgreementLine;
        AgreementLineReference  agreementLineReference;

        select forupdate agreementLineReference
            where (agreementLineReference.DerivedAgreementLine == this.RecId
                    || agreementLineReference.SourceAgreementLine  == this.RecId)
                && agreementLineReference.IsIntraCompany_RU;

        if (agreementLineReference.RecId)
        {
            ttsbegin;
            select forupdate intercompanyAgreementLine
                where (intercompanyAgreementLine.RecId == agreementLineReference.SourceAgreementLine
                   ||  intercompanyAgreementLine.RecId == agreementLineReference.DerivedAgreementLine)
                   && intercompanyAgreementLine.RecId  != this.RecId;

            intercompanyAgreementLine.IntraCompanySkipUpdate_RU = InterCompanySkipUpdate::Internal;

            intercompanyAgreementLine.delete();
            agreementLineReference.delete();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayAgreementHeaderSequence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the sequence number of a associated purchase agreement.
    /// </summary>
    /// <returns>
    /// A <c>PurchAgreementId</c> that indicates the sequence number of associated purchase agreement.
    /// </returns>
    public display PurchAgreementId displayAgreementHeaderSequence()
    {
        return this.getPurchAgreementId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchAgreementId</Name>
				<Source><![CDATA[
    public PurchAgreementId getPurchAgreementId()
    {
        return PurchAgreementHeader::find(this.Agreement).PurchNumberSequence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>historyExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the history records exist for the agreement line.
    /// </summary>
    /// <returns>
    ///    true if the history records exist; otherwise, false.
    /// </returns>
    public boolean historyExists()
    {
        return (select firstonly RecId from agreementLineHistory
                where agreementLineHistory.AgreementLine == this.RecId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleSalesPurch</Name>
				<Source><![CDATA[
    private ModuleSalesPurch moduleSalesPurch()
    {
        return this.agreementHeader().getModuleType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCategoryFromAgreementLineType</Name>
				<Source><![CDATA[
    private void initCategoryFromAgreementLineType(ModuleSalesPurch _moduleType = this.moduleSalesPurch())
    {
        if (this.AgreementLineType == CommitmentType::ProductRootCategory)
        {
            this.Category = this.deriveCategory().RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeriveCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the category value can be uniquely derived from other field values.
    /// </summary>
    /// <returns></returns>
    private boolean canDeriveCategory()
    {
        return this.AgreementLineType != CommitmentType::ProductCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deriveCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the product category when it can be uniquely dervied from other field values.
    /// </summary>
    /// <param name="_moduleType">The module of the agreement line</param>
    /// <returns>The <c>EcoResCategory</c> record, if it can be derived; otherwise, null.</returns>
    private EcoResCategory deriveCategory(ModuleSalesPurch _moduleType = this.moduleSalesPurch())
    {
        EcoResCategory derivedCategory;

        if (this.AgreementLineType == CommitmentType::ProductRootCategory)
        {
            // For "Category-ALL" lines default the category with root specific for module:
            EcoResCategoryNamedHierarchyRole categoryHierarchyRole = (_moduleType == ModuleSalesPurch::Sales) ? EcoResCategoryNamedHierarchyRole::Sales : EcoResCategoryNamedHierarchyRole::Procurement;
            return EcoResCategory::getRoot(EcoResCategoryHierarchyRole::getHierarchiesByRole(categoryHierarchyRole).CategoryHierarchy);
        }

        return derivedCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCategorySameAsDerived</Name>
				<Source><![CDATA[
    /// <summary>
    /// When category can be derived from other fields, determines whether the specified category is valid.
    /// Otherwise, returns false.
    /// </summary>
    /// <returns>true, if category can be derived from other fields and the specified category is valid; otherwise, false.</returns>
    public boolean isCategorySameAsDerived()
    {
        return this.canDeriveCategory() && this.Category == this.deriveCategory().RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromAgreementHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the default value for the <c>AgreementLine</c> record from the <c>AgreementHeader</c> record.
    /// </summary>
    /// <param name="_agreementHeader">
    ///    The <c>AgreementHeader</c> record from which to initialize.
    /// </param>
    public void initFromAgreementHeader(AgreementHeader _agreementHeader)
    {
        // <GEERU>
        #ISOCountryRegionCodes
        InventDim inventDim;
        AgreementHeaderExt_RU agreementHeaderExt;
        // </GEERU>
        AgreementHeaderDefault              agreementHeaderDefault = AgreementHeaderDefault::findAgreementHeader(_agreementHeader.RecId);
        EcoResCategoryNamedHierarchyRole    categoryHierarchyRole;

        this.Agreement          = _agreementHeader.RecId;

        this.ProjectProjId      = agreementHeaderDefault.Project;
        this.ProjectDataAreaId  = agreementHeaderDefault.ProjectDataAreaId;

        this.EffectiveDate      = _agreementHeader.DefaultAgreementLineEffectiveDate;
        this.ExpirationDate     = _agreementHeader.DefaultAgreementLineExpirationDate;

        this.AgreementLineType  = _agreementHeader.DefaultAgreementLineType;

        this.Currency = _agreementHeader.Currency;

        this.initCategoryFromAgreementLineType(_agreementHeader.getModuleType());

        this.setLineProduct();
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            inventDim = this.inventDim();
            agreementHeaderExt = AgreementHeaderExt_RU::findByAgreementHeader(_agreementHeader.RecId);

            if (agreementHeaderExt.InventProfileId &&
                ! inventDim.InventProfileId_RU)
            {
                inventDim.InventProfileId_RU = agreementHeaderExt.InventProfileId;
                inventDim.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;
                this.setInventDimId(inventDim.InventDimId);
            }
        }
        // </GEERU>

        this.DefaultDimension = this.copyDimension(_agreementHeader.DefaultDimension);

        if (PurchParameters::find().IsSupplierShipmentDatesEnabled
            && _agreementHeader is PurchAgreementHeader)
        {
            PurchAgreementHeader purchAgreementHeader = _agreementHeader as PurchAgreementHeader;
            this.ShipCalendarId = purchAgreementHeader.ShipCalendarId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>AgreementLine</c> record from the <c>InventTable</c> table.
    /// </summary>
    /// <param name="_inventTable">
    ///    The <c>InventTable</c> record from which to initialize.
    /// </param>
    public void initFromInventTable(InventTable _inventTable = null)
    {
        this.ItemDataAreaId = appl.company().dataArea(tableNum(InventTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the default values for the <c>AgreementLine</c> record.
    /// </summary>
    public void initValue()
    {
        this.AgreementLineType    = CommitmentType::ProductQuantity;
        this.AgreementLineProduct = AgreementLineProduct::Item;
        this.IsModified           = NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the records into the <c>AgreementLine</c> table and subtype tables.
    /// </summary>
    /// <remarks>
    /// For more information, see the <see cref="T:AgreementLine" />, <see
    /// cref="T:AgreementLineVolumeCommitment" />, and <see cref="T:AgreementLineQuantityCommitment" />.
    /// </remarks>
    public void  insert()
    {
        if (CLMIntegrationFeature::isEnabled() && this.IsIntegration != PurchAgreementIntegrationType::CLM)
        {
            PurchAgreementHeader header = PurchAgreementHeader::find(this.Agreement);
            if (header && header.CLMIntegrationPurchAgreementOwnership == CLMIntegrationPurchaseAgreementOwnershipType::CLM)
            {
                throw error(strFmt("@CLMIntegration:ErrorWhenInsertCLMIntegrationPurchAgreementLine", header.PurchNumberSequence));
            }
        }

        this.setLineProduct();
        this.setCommitment();

        if (!this.LineNumber)
        {
            this.LineNumber = AgreementLine::lastLineNum(this.Agreement) + 1.0;
        }

        this.IsModified           = NoYes::Yes;

        if (AgreementLineCallSuperInOverriddenMethodsFlight::instance().isEnabled())
        {
            super();
        }
        else
        {
            this.doInsert();
        }

        this.updateHeaderDates(this.Agreement, true);

        var purchAgreementHeader = this.agreementHeader() as PurchAgreementHeader;

        if (purchAgreementHeader
            && purchAgreementHeader.mustUpdateWorkflowStatusOnLineChange_PSN())
        {
            purchAgreementHeader.updateWorkflowStatusForEdit_PSN();
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            this.markCurrentTaxDocumentTaxStatusDirty();
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the intercompany agreement line record that relates to the <c>AgreementLine</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>AgreementLine</c> table; otherwise, an empty record.
    /// </returns>
    public AgreementLine intercompanyAgreementLine(boolean _forUpdate = false)
    {
        AgreementLine           intercompanyAgreementLine;
        AgreementLineReference  agreementLineReference;
        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        select firstonly DerivedAgreementLine from agreementLineReference
            where agreementLineReference.SourceAgreementLine == this.RecId
                // <GEERU>
                && (!countryRegion_RU || !agreementLineReference.IsIntraCompany_RU)
                // </GEERU>
                ;

        if (agreementLineReference.DerivedAgreementLine)
        {
            intercompanyAgreementLine = AgreementLine::find(agreementLineReference.DerivedAgreementLine,_forUpdate);
        }

        if (!intercompanyAgreementLine.RecId)
        {
            select firstonly SourceAgreementLine from agreementLineReference
                where agreementLineReference.DerivedAgreementLine == this.RecId
                // <GEERU>
                && (!countryRegion_RU || !agreementLineReference.IsIntraCompany_RU)
                // </GEERU>
                ;

            if (agreementLineReference.SourceAgreementLine)
            {
                intercompanyAgreementLine = AgreementLine::find(agreementLineReference.SourceAgreementLine,_forUpdate);
            }
        }
        return intercompanyAgreementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyLinkExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether an intercompany link for the agreement line quantity exists.
    /// </summary>
    /// <returns>
    /// true if there exists an intercompany link; otherwise, false.
    /// </returns>
    public boolean intercompanyLinkExist()
    {
        // <GEERU>
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            return (select firstonly RecId from agreementLineReference
                where (  agreementLineReference.SourceAgreementLine == this.RecId
                      || agreementLineReference.DerivedAgreementLine == this.RecId)
                   && !agreementLineReference.IsIntraCompany_RU).RecId != 0 ;
        }
        else
        {
            // </GEERU>
            return (select firstonly RecId from agreementLineReference where agreementLineReference.SourceAgreementLine == this.RecId
            || agreementLineReference.DerivedAgreementLine == this.RecId).RecId != 0 ;
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyOriginDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a string that specifies how the agreement line is created by using regard to intercompany
    /// agreements.
    /// </summary>
    /// <returns>
    /// A string that specifies how the agreement line is created by using regard to intercompany
    /// agreements.
    /// </returns>
    display AgreementIntercompanyOrigin intercompanyOriginDisplay()
    {
        AgreementIntercompanyOrigin     agreementIntercompanyOrigin;
        DictEnum                        dictEnum = new DictEnum(enumNum(InterCompanyOrigin));

        if (AgreementLineReference::existSourceAgreementLine(this.RecId))
        {
            agreementIntercompanyOrigin = dictEnum.value2Name(InterCompanyOrigin::Source);
        }
        if (AgreementLineReference::existDerivedAgreementLine(this.RecId))
        {
            agreementIntercompanyOrigin = dictEnum.value2Name(InterCompanyOrigin::Derived);
        }
        return agreementIntercompanyOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intracompanyAgreementLine_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the intracompany agreement line record that relates to the <c>AgreementLine</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    ///     A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///     A record in the <c>AgreementLine</c> table; otherwise, an empty record.
    /// </returns>
    public AgreementLine intracompanyAgreementLine_RU(boolean _forUpdate = false)
    {
        AgreementLine           intracompanyAgreementLine;
        AgreementLineReference  agreementLineReference;

        select firstonly DerivedAgreementLine from agreementLineReference
            where agreementLineReference.SourceAgreementLine == this.RecId
                && agreementLineReference.IsIntraCompany_RU;

        if (agreementLineReference.DerivedAgreementLine)
        {
            intracompanyAgreementLine = AgreementLine::find(agreementLineReference.DerivedAgreementLine,_forUpdate);
        }

        if (!intracompanyAgreementLine.RecId)
        {
            select firstonly SourceAgreementLine from agreementLineReference
                where agreementLineReference.DerivedAgreementLine == this.RecId
                    && agreementLineReference.IsIntraCompany_RU;

            if (agreementLineReference.SourceAgreementLine)
            {
                intracompanyAgreementLine = AgreementLine::find(agreementLineReference.SourceAgreementLine,_forUpdate);
            }
        }
        return intracompanyAgreementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intracompanyLinkExist_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether an intracompany link for the agreement line quantity exists.
    /// </summary>
    /// <returns>
    ///     true if there exists an intracompany link; otherwise, false.
    /// </returns>
    public boolean intracompanyLinkExist_RU()
    {
        return (select firstonly RecId from agreementLineReference
            where (  agreementLineReference.SourceAgreementLine == this.RecId
                    || agreementLineReference.DerivedAgreementLine == this.RecId)
                && agreementLineReference.IsIntraCompany_RU).RecId != 0 ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>InventDim</c> record for the current agreement line.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// The  <c>InventDim</c> record.
    /// </returns>
    InventDim inventDim(boolean  _forUpdate = false)
    {
        return InventDim::find(this.InventDimId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>InventTable</c> record for the current blanket order line.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// The <c>InventTable</c> record.
    /// </returns>
    InventTable inventTable(boolean   _forUpdate = false)
    {
        return InventTable::find(this.ItemId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the invoice journal transaction records exist for the agreement line.
    /// </summary>
    /// <returns>
    ///    true if the invoice journal transaction records exist; otherwise, false.
    /// </returns>
    public boolean invoiceExists()
    {
        AgreementLineReleasedLine   agreeementLineReleasedLine;
        CustInvoiceTrans            custInvoiceTrans;
        VendInvoiceTrans            vendInvoiceTrans;
        boolean                     ret = false;
        PurchAgreementHeader        purchAgreementHeader;

        if (this.RecId)
        {
            if (isConfigurationkeyEnabled(configurationkeynum(PublicSector)) && (this.agreementHeader() is PurchAgreementHeader))
            {
                purchAgreementHeader = this.agreementHeader() as PurchAgreementHeader;
            }

            if (purchAgreementHeader && purchAgreementHeader.AgreementClassification
                && (AgreementClassification::find(purchAgreementHeader.AgreementClassification).DirectInvoiceEnable_PSN == NoYes::Yes))
            {
                select firstOnly RecId from agreeementLineReleasedLine
                    where agreeementLineReleasedLine.ReferenceRelationType == tableNum(VendInvoiceTrans)
                        && agreeementLineReleasedLine.AgreementLine == this.RecId
                        && !agreeementLineReleasedLine.IsDeleted
                    exists join vendInvoiceTrans
                        where vendInvoiceTrans.RecId == agreeementLineReleasedLine.VendInvoiceTrans;
            }
            else if (this.agreementHeader() is SalesAgreementHeader)
            {
                select firstonly RecId from agreeementLineReleasedLine
                    where agreeementLineReleasedLine.ReferenceRelationType == tableNum(SalesLine)
                       && agreeementLineReleasedLine.SalesLineDataAreaId == appl.company().dataArea(tableNum(SalesLine))
                       && agreeementLineReleasedLine.AgreementLine == this.RecId
                    exists join custInvoiceTrans
                        where custInvoiceTrans.InventTransId == agreeementLineReleasedLine.SalesLineInventTransId;
            }
            else
            {
                select firstonly RecId from agreeementLineReleasedLine
                    where agreeementLineReleasedLine.ReferenceRelationType == tableNum(PurchLine)
                       && agreeementLineReleasedLine.PurchLineDataAreaId == appl.company().dataArea(tableNum(PurchLine))
                       && agreeementLineReleasedLine.AgreementLine == this.RecId
                    exists join vendInvoiceTrans
                        where vendInvoiceTrans.InventTransId == agreeementLineReleasedLine.PurchLineInventTransId;
            }

            ret = agreeementLineReleasedLine.RecId ? true : false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCategoryBased</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the current <c>AgreementLine</c> record is category based.
    /// </summary>
    /// <returns>
    ///    true if the <c>AgreementLine</c> record is category based; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <c>AgreementLine</c> record is category based when the <c>Category</c> field is filled in.
    /// </remarks>
    public boolean isCategoryBased()
    {
        return this.Category ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDerivedAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the agreement line is a derived intercompany agreement line.
    /// </summary>
    /// <returns>
    /// true if the agreement line is a derived intercompany agreement line; otherwise, false.
    /// </returns>
    public boolean isDerivedAgreement()
    {
        // <GEERU>
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            return AgreementLineReference::existDerivedAgreementLine(this.RecId) ||
                AgreementLineReference::existDerivedAgreementLine(this.RecId, true);
        }
        // </GEERU>
        return AgreementLineReference::existDerivedAgreementLine(this.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemBased</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the current <c>AgreementLine</c> record is item based.
    /// </summary>
    /// <returns>
    ///    true if the <c>AgreementLine</c> record is item based; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <c>AgreementLine</c> record is item based if the <c>Item</c> field is filled in.
    /// </remarks>
    public boolean isItemBased()
    {
        return this.ItemId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLinkValid</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the specified order line fits for the current agreement line.
    /// </summary>
    /// <param name="_salesPurchLine">
    ///    The <c>SalesLine</c> or <c>PurchLine</c> record to check.
    /// </param>
    /// <param name="_showInfolog">
    ///    A Boolean value that indicates whether to print the errors in the Infolog; optional.
    /// </param>
    /// <returns>
    ///    true if the link between the specified record and the agreement line is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    If the <paramref name="_showInfolog" /> parameter is true then the information about all fields
    ///    that do not fit to the agreement criteria will be printed in the Infolog.
    /// </remarks>
    public boolean isLinkValid(SalesPurchLine _salesPurchLine, boolean _showInfolog = true)
    {
        boolean             ret = true;
        SalesPurchLineInterface salesPurchLineInterface = _salesPurchLine.salesPurchLineInterface();

        InventDim           salesPurchLineInventDim;
        InventDim           agreementLineInventDim;
        InventDimParm       inventDimParm;
        ModuleSalesPurch    module = _salesPurchLine.TableId == tableNum(SalesLine) ? ModuleSalesPurch::Sales : ModuleSalesPurch::Purch;
        SalesLine           salesLine;
        PurchLine           purchLine;
        PurchReqLine        purchReqLine;
        TransDate           dateForValidation;
        boolean             isPurchReqLine = _salesPurchLine.TableId == tableNum(PurchReqLine) ? true : false;
        boolean             isReturnLine;

        if (_showInfolog)
        {
            this.validateAmount(_salesPurchLine);
        }

        if (module == ModuleSalesPurch::Sales)
        {
            salesLine = _salesPurchLine;
            isReturnLine = salesLine.returnItem();
            if (_showInfolog)
            {
                setPrefix("@SYS134353");
                setPrefix("@SYS134355");
            }
        }
        else
        {
            if (isPurchReqLine)
            {
                purchReqLine = _salesPurchLine;
            }
            else
            {
                purchLine = _salesPurchLine;
                isReturnLine = purchLine.PurchaseType == PurchaseType::ReturnItem;
            }

            if (_showInfolog)
            {
                setPrefix("@SYS134354");
                setPrefix("@SYS134356");
            }
        }

        if (this.isItemBased() && salesPurchLineInterface.parmItemId() != this.ItemId)
        {
            if (_showInfolog)
            {
                if (module == ModuleSalesPurch::Sales)
                {
                    ret = checkFailed(#PreFixField(salesLine,ItemId));
                }
                else
                {
                    if (isPurchReqLine)
                    {
                        ret = checkFailed(#PreFixField(purchReqLine,ItemId));
                    }
                    else
                    {
                        ret = checkFailed(#PreFixField(purchLine,ItemId));
                    }
                }
            }
            else
            {
                return false;
            }
        }

        if (module == ModuleSalesPurch::Sales)
        {
            if (this.intercompanyLinkExist())
            {
                dateForValidation = salesLine.ReceiptDateRequested;
            }
            else
            {
                dateForValidation = salesLine.ShippingDateRequested;
            }

            if (
                !isReturnLine && (
                dateForValidation < this.EffectiveDate ||
                dateForValidation > this.ExpirationDate)
                )
            {
                if (_showInfolog)
                {
                    ret = checkFailed(#PreFixField(salesLine,ShippingDateRequested));
                }
                else
                {
                    return false;
                }
            }
        }
        else
        {
            if (isPurchReqLine)
            {
                dateForValidation = purchReqLine.RequiredDate;
            }
            else
            {
                dateForValidation = purchLine.DeliveryDate;
            }

            if (
                !isReturnLine && (
                dateForValidation < this.EffectiveDate ||
                dateForValidation > this.ExpirationDate)
                )
            {
                if (_showInfolog)
                {
                    if (isPurchReqLine)
                    {
                        ret = checkFailed(#PreFixField(purchReqLine,RequiredDate));
                    }
                    else
                    {
                        ret = checkFailed(#PreFixField(purchLine,DeliveryDate));
                    }
                }
                else
                {
                    return false;
                }
            }
        }

        if (this.IsPriceInformationMandatory)
        {
            boolean isRetailSales = false;

            if (module == ModuleSalesPurch::Sales)
            {
                SalesTable salesTable = SalesTable::find(salesLine.SalesId);
                if (salesTable && salesTable.isRetailSale())
                {
                    isRetailSales = true;
                }
            }

            // Retail sales use pricing engine to calcualte sales agreement.
            // It modes sales agreement price as final calculated price, then might be different from the value in agreement line.
            real targetDiscountPercent = isRetailSales ? 0.0 : this.LineDiscountPercent;
            if (salesPurchLineInterface.parmLineDiscPercent() != targetDiscountPercent)
            {
                if (_showInfolog)
                {
                    if (module == ModuleSalesPurch::Sales)
                    {
                        ret = checkFailed(#PreFixField(salesLine,LinePercent));
                    }
                    else
                    {
                        if (isPurchReqLine)
                        {
                            ret = checkFailed(#PreFixField(purchReqLine,LinePercent));
                        }
                        else
                        {
                            ret = checkFailed(#PreFixField(purchLine,LinePercent));
                        }
                    }
                }
                else
                {
                    return false;
                }
            }
        }

        salesPurchLineInventDim = salesPurchLineInterface.inventDim();
        agreementLineInventDim = this.inventDim();
        inventDimParm.initFromInventDim(agreementLineInventDim);
        // For Return lines Storage dimensions should be ignored:
        if (isReturnLine)
        {
            salesPurchLineInventDim.InventSiteId = agreementLineInventDim.InventSiteId;
            salesPurchLineInventDim.InventLocationId = agreementLineInventDim.inventLocationId;
        }

        if (!InventDim::isInventDimParmEqual(agreementLineInventDim, salesPurchLineInventDim, inventDimParm, _showInfolog))
        {
            return false;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isQuantityBased</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the current agreement line is quantity based.
    /// </summary>
    /// <returns>
    ///    true if the agreement line is quantity based; otherwise, false.
    /// </returns>
    public boolean isQuantityBased()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReleased</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the agreement line has been released.
    /// </summary>
    /// <returns>
    ///    true if the agreement line has been released; otherwise, false.
    /// </returns>
    public boolean isReleased()
    {
        if (this.RecId)
        {
            return (select firstonly RecId from agreementLineReleasedLine
                    where  agreementLineReleasedLine.AgreementLine == this.RecId
                        && agreementLineReleasedLine.IsDeleted     == NoYes::No).RecId;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemIdChanged</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the values in the <c>AgreementLine</c> record when the item ID has been changed.
    /// </summary>
    public void itemIdChanged()
    {
        if (this.ItemId)
        {
            this.initFromInventTable();
            this.Category = 0;
        }

        this.setCommitment();
        this.setLineProduct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkInventDim2Dimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the default inventory dimension values of the <c>AgreementLine</c> record by using the values
    ///    in the <c>InventDim</c> record buffer.
    /// </summary>
    /// <param name="_newInventDim">
    ///    The <c>InventDim</c> record buffer linked to the current <c>AgreementLine</c> record buffer.
    /// </param>
    /// <param name="_oldInventDim">
    ///    The <c>InventDim</c> record buffer that was previously linked to the current <c>AgreementLine</c>
    ///    record buffer.
    /// </param>
    public void linkInventDim2Dimension(InventDim _newInventDim, InventDim _oldInventDim)
    {
        _newInventDim.setInventSiteFromParentIfModified(this, _oldInventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </summary>
    /// <param name="_defaultDimensionNew">
    /// A financial dimension that is used in merge.
    /// </param>
    /// <param name="_defaultDimensionOld">
    /// A financial dimension that is used in merge.
    /// </param>
    /// <param name="_dimensionMerge">
    /// A dimension merge object used in merge.
    /// </param>
    /// <returns>
    /// A dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are merged.
    /// </remarks>
    public DimensionDefault mergeDimension(
        DimensionDefault _defaultDimensionNew,
        DimensionDefault _defaultDimensionOld,
        DimensionMerge   _dimensionMerge = DimensionMerge::newFromTable(
            this,
            this.agreementHeader().getLegalEntity().RecId)
        )
    {
        return _dimensionMerge.merge(_defaultDimensionNew, _defaultDimensionOld);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies when a field is modified on the <c>AgreementLine</c> record.
    /// </summary>
    /// <param name="_fieldId">
    ///    A field ID that has been modified.
    /// </param>
    public void modifiedField(fieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(AgreementLine, Category):
                this.categoryChanged();
                break;

            case fieldNum(AgreementLine, ItemId):
                this.itemIdChanged();
                break;

            case fieldNum(AgreementLine, ProjectProjId):
                this.DefaultDimension  = this.copyDimension(this.projTable().DefaultDimension);
                if (this.ItemId)
                {
                    this.DefaultDimension  = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(this.DefaultDimension, this.inventTable().DefaultDimension);
                }

                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>name</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the name of the item or category for the current agreement line.
    /// </summary>
    /// <returns>
    ///    A string that contains the item or category name.
    /// </returns>
    public display AgreementItemCategoryName name()
    {
        Name        ret;

        if (this.isItemBased())
        {
            ret = InventTable::name(this.ItemId, InventDim::find(this.InventDimId));
        }
        else if (this.isCategoryBased())
        {
            ret = EcoResCategory::find(this.Category).Name;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQuantityCheckRemaining</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified quantity in catch weight can be covered by the agreement line.
    /// </summary>
    /// <param name="_catchWeightQuantity">
    /// A real value that represents a catch weight quantity.
    /// </param>
    /// <param name="_silent">
    /// A Boolean value that indicates whether the check should be performed silent; optional.
    /// </param>
    /// <returns>
    /// true if the specified quantity can be covered by the current agreement line; otherwise, false.
    /// </returns>
    public boolean pdsCWQuantityCheckRemaining(
        PdsCWInventQty      _catchWeightQuantity,
        boolean             _silent = true)
    {
        if (   this.IsMaxEnforced
            && this.pdsCWQuantityRemainingQueried() < _catchWeightQuantity)
        {
            if (_silent)
            {
                return false;
            }
            else if (this.agreementModuleType() == ModuleSalesPurch::Sales)
            {
                return checkFailed("@SYS305734");
            }
            else
            {
                return checkFailed("@SYS305736");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQuantityRemainingQueried</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets data and calculates the remaining quantity for the line in catch weight.
    /// </summary>
    /// <returns>
    /// The quantity that remains for the <c>AgreementLine</c> object.
    /// </returns>
    public RealBase pdsCWQuantityRemainingQueried()
    {
        #AgreementsRemains
        container       fulfillmentValues;
        PdsCWInventQty  remaining;

        fulfillmentValues = AgreementLine::calculateFulfillmentForLine(this);

        remaining = conpeek(fulfillmentValues, #PdsCWRemainingIndex);

        return remaining;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQuantityRemainingRelease</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the remaining catch weight quantity to be released.
    /// </summary>
    /// <returns>
    /// The remaining quantity to be released.
    /// </returns>
    display PdsCWInventQty pdsCWQuantityRemainingRelease()
    {
        return this.pdsCWQuantityRemainingQueried();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSameLot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the value of the same lot reservation parameter.
    /// </summary>
    /// <returns>
    /// true if the item must be reserved according to same lot logic; otherwise, false.
    /// </returns>
    public display PdsSameLot pdsSameLot()
    {
        return this.inventTable().pdsCheckSameLot();
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchAgreementHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>PurchAgreementHeader</c> record from the current <c>AgreementLine</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The <c>PurchAgreementHeader</c> record.
    /// </returns>
    public PurchAgreementHeader purchAgreementHeader(boolean _forUpdate = false)
    {
        return PurchAgreementHeader::find(this.Agreement, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>quantityRemainingRelease</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates quantity that remains for the line.
    /// </summary>
    /// <returns>
    ///    The quantity reminder for the <c>AgreementLine</c> object.
    /// </returns>
    /// <remarks>
    ///    This method is introduced by the release subsystem.
    /// </remarks>
    display ProductQuantity quantityRemainingRelease()
    {
        return this.remainingQueried();
    }

]]></Source>
			</Method>
			<Method>
				<Name>relatedObjectExistanceFlags</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates that an invoice exists and releases the records that are associated with the current
    /// <c>AgreementLine</c> record.
    /// </summary>
    /// <returns>
    /// A container that has Boolean flags which are associated with invoices and releases records which
    /// are associated with the current agreement.
    /// </returns>
    /// <remarks>
    /// This method is executed on the server and fills the requirement to minimize the number of
    /// client-server calls when an environment discovery is made by UI forms regarding the current
    /// agreement line.
    /// </remarks>
    container relatedObjectExistanceFlags()
    {
        container c;

        c = conIns(c, AgreementLine::posReleasesExist(), (this.isReleased())   );
        c = conIns(c, AgreementLine::posInvoicesExist(), (this.invoiceExists()));
        c = conIns(c, AgreementLine::posCanDeleteAgreementLine(), (this.canDeleteAgreementLine()));

        return c;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainingQueried</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Queries data and calculates the remaining quantity for the line.
    /// </summary>
    /// <returns>
    ///    The quantity that remains for the <c>AgreementLine</c> object.
    /// </returns>
    public RealBase remainingQueried()
    {
        #AgreementsRemains
        container fulfillmentValues;
        RealBase  remaining;

        fulfillmentValues = AgreementLine::calculateFulfillmentForLine(this);
        remaining = conPeek(fulfillmentValues, #RemainingIndex);
        return remaining;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesAgreementHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>SalesAgreementHeader</c> record from the current <c>AgreementLine</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The <c>SalesAgreementHeader</c> record.
    /// </returns>
    public SalesAgreementHeader salesAgreementHeader(boolean _forUpdate = false)
    {
        return SalesAgreementHeader::find(this.Agreement, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCommitment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>CommitmentType</c> enumeration value in the <c>AgreementLine</c> record.
    /// </summary>
    public void setCommitment()
    {
        if (this.isQuantityBased())
        {
            this.AgreementLineType = CommitmentType::ProductQuantity;
        }
        else if (this.isItemBased())
        {
            this.AgreementLineType = CommitmentType::ProductVolume;
        }
        else
        {
            if (EcoResCategory::find(this.Category).isRoot())
            {
                this.AgreementLineType = CommitmentType::ProductRootCategory;
            }
            else
            {
                this.AgreementLineType = CommitmentType::ProductCategory;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Applies the <c>InventDim</c> parameter to the <c>InventDimId</c> field of the <c>AgreementLine</c>
    ///    record and sets the default values by using the new inventory dimensions.
    /// </summary>
    /// <param name="_inventDimId">
    ///    The value to apply to the <c>InventDimId</c> field.
    /// </param>
    /// <param name="_inventDim">
    ///    The <c>InventDim</c> record buffer that is related to the <paramref name="_inventDimId" />
    ///    parameter; optional.
    /// </param>
    public void setInventDimId(InventDimId _inventDimId, InventDim _inventDim = InventDim::find(_inventDimId))
    {
        InventDim   currentInventDim = this.InventDimId == _inventDimId ? _inventDim : this.inventDim();

        this.InventDimId = _inventDimId;
        this.linkInventDim2Dimension(_inventDim, currentInventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLineProduct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the line product in the <c>AgreementLine</c> record.
    /// </summary>
    public void setLineProduct()
    {
        this.AgreementLineProduct = this.isItemBased()? AgreementLineProduct::Item :
                                                        AgreementLineProduct::Category;
    }

]]></Source>
			</Method>
			<Method>
				<Name>softDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Marks the <c>AgreementLine</c> record as deleted.
    /// </summary>
    /// <remarks>
    ///    This method does not physically delete the <c>AgreementLine</c> records.It only sets the
    ///    <c>IsDeleted</c> field of the <c>AgreementLine</c> tables to an enumeration value of <c>Yes</c>.
    /// </remarks>
    private void softDelete()
    {
        if (this.IsDeleted != NoYes::Yes)
        {
            this.IsDeleted = NoYes::Yes;
            this.IsModified = NoYes::Yes;
            this.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>type</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>AgreementCommitment</c> class by using the current record in the
    ///    <c>AgreementLine</c> table.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>AgreementCommitment</c> class.
    /// </returns>
    private AgreementCommitment type()
    {
        return AgreementCommitment::newAgreementCommitment(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>AgreementLine</c> table and subtype table records.
    /// </summary>
    /// <remarks>
    /// For more information, see the <see cref="T:AgreementLine" />, <see
    /// cref="T:AgreementLineVolumeCommitment" />, <see cref="T:AgreementLineQuantityCommitment" />.
    /// </remarks>
    void  update()
    {
        if (this.agreementModuleType() == ModuleSalesPurch::Purch && this.needCheckCLMIntegrationFields())
        {
            this.checkCLMIntegrationFields();
        }

        boolean updateDates;

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
            && this.SalesPurchJournalLine::taxRecalculationNeeded())
        {
            this.markCurrentTaxDocumentTaxStatusDirty();
        }
        // </GTE>

        this.IsModified = NoYes::Yes;

        if (this.ExpirationDate != this.orig().ExpirationDate || this.EffectiveDate != this.orig().EffectiveDate)
        {
            updateDates = true;
        }
        this.setLineProduct();
        this.setCommitment();
        
        if (AgreementLineCallSuperInOverriddenMethodsFlight::instance().isEnabled())
        {
            super();
        }
        else
        {
            this.doUpdate();
        }

        if (updateDates)
        {
            this.updateHeaderDates(this.Agreement);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCLMIntegrationFields</Name>
				<Source><![CDATA[
    private void checkCLMIntegrationFields()
    {
        str fieldName;

        FieldId modifiedField = CLMIntegrationPurchAgreementDataProvider::getCLMIntegrationAgreementLineModifiedField(this);
        if (modifiedField)
        {
            fieldName = fieldId2Name(tableNum(AgreementLine), modifiedField);
        }
        else
        {
            if(this is AgreementLineQuantityCommitment)
            {
                AgreementLineQuantityCommitment currentAgreementLineQuantityCommitment = this;
                    
                modifiedField = CLMIntegrationPurchAgreementDataProvider::getCLMIntegrationAgreementLineQuantityCommitmentModifiedField(currentAgreementLineQuantityCommitment);
                if (modifiedField)
                {
                    fieldName = fieldId2Name(tableNum(AgreementLineQuantityCommitment), modifiedField);
                }
            }
            else if(this is AgreementLineVolumeCommitment)
            {
                AgreementLineVolumeCommitment currentAgreementLineVolumeCommitment = this;
                    
                modifiedField = CLMIntegrationPurchAgreementDataProvider::getCLMIntegrationAgreementLineVolumeCommitmentModifiedField(currentAgreementLineVolumeCommitment);
                if (modifiedField)
                {
                    fieldName = fieldId2Name(tableNum(AgreementLineVolumeCommitment), modifiedField);
                }
            }
        }

        if (modifiedField)
        {
            throw error(strFmt("@CLMIntegration:ErrorWhenCLMIntegrationFieldModifiedOnPurchAgreement", fieldName));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates line financial dimensions.
    /// </summary>
    /// <param name="_defaultDimension">
    /// The new financial dimensions that will be used by <c>AgreementLine</c>.
    /// </param>
    public void updateDefaultDimension(DimensionDefault _defaultDimension)
    {
        if (_defaultDimension && !DimensionDefaultFacade::areEqual(this.DefaultDimension, _defaultDimension))
        {
            this.DefaultDimension   = this.mergeDimension(_defaultDimension, this.DefaultDimension);
            this.IsModified         = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateHeaderDates</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>LatestLineExpirationDate</c> and <c>EarliestLineEffectiveDate</c> fields of the
    ///    header table
    /// </summary>
    /// <param name="_agreementHeaderRecId">
    ///    The record ID of the agreement header to update.
    /// </param>
    /// <param name="_useCurrentLineOnly">
    ///    A Boolean value that indicates whether to use the current record only for update; optional.
    /// </param>
    private void updateHeaderDates(AgreementHeaderRecId _agreementHeaderRecId, boolean _useCurrentLineOnly = false)
    {
        AgreementHeader agreementHeader = AgreementHeader::find(_agreementHeaderRecId, true);
        AgreementLine   agreementLine;
        boolean         updateIsNeeded;
        // <GEERU>
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (!agreementHeader.RecId)
            {
                return;
            }
        }
        // </GEERU>

        if (_useCurrentLineOnly)
        {
            if (this.ExpirationDate > agreementHeader.LatestLineExpirationDate)
            {
                agreementHeader.LatestLineExpirationDate = this.ExpirationDate;
                updateIsNeeded = true;
            }
            if (this.EffectiveDate < agreementHeader.EarliestLineEffectiveDate
                || agreementHeader.EarliestLineEffectiveDate == dateNull())
            {
                agreementHeader.EarliestLineEffectiveDate = this.EffectiveDate;
                updateIsNeeded = true;
            }
        }
        else
        {
            select maxof(ExpirationDate), minof(EffectiveDate) from agreementLine
            where  agreementLine.Agreement == _agreementHeaderRecId
                && agreementLine.IsDeleted == NoYes::No;

            if (agreementLine.ExpirationDate != agreementHeader.LatestLineExpirationDate)
            {
                agreementHeader.LatestLineExpirationDate = agreementLine.ExpirationDate;
                updateIsNeeded = true;
            }
            if (agreementLine.EffectiveDate != agreementHeader.EarliestLineEffectiveDate)
            {
                agreementHeader.EarliestLineEffectiveDate = agreementLine.EffectiveDate;
                updateIsNeeded = true;
            }
        }

        if (updateIsNeeded)
        {
            agreementHeader.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether the specified order line amount fits the current agreement line.
    /// </summary>
    /// <param name="_salesPurchLine">
    ///    The <c>SalesLine</c> or <c>PurchLine</c> record to validate.
    /// </param>
    public void validateAmount(SalesPurchLine _salesPurchLine)
    {
        SalesPurchLineInterface salesPurchLineInterface = _salesPurchLine.salesPurchLineInterface();
        AmountCur amount;

        if (this.AgreedReleaseLineMinAmount || this.AgreedReleaseLineMaxAmount)
        {
            if (_salesPurchLine.RecId && (salesPurchLineInterface.parmLineAmount() != salesPurchLineInterface.origInstance().parmLineAmount()))
            {
                amount = salesPurchLineInterface.parmLineAmount();
            }
            else
            {
                // For category based lines SalesPurchQty might be not set (while LineAmount could be set) by user.
                // The "forced" LineAmount calculation for such lines will return 0. It would be missleading to use 0 value in the message.
                // So, instead of calculating LineAmount with SalesPurchQty not being set for not-yet-saved lines
                // we should try to use LineAmount value "as it is".
                amount = (salesPurchLineInterface.parmQty()) ? _salesPurchLine.salesPurchLineInterface().calcLineAmountForced() : salesPurchLineInterface.parmLineAmount();
            }

            if (this.AgreedReleaseLineMinAmount && this.AgreedReleaseLineMinAmount > amount)
            {
                if (_salesPurchLine.TableId == tableNum(PurchLine))
                {
                    checkFailed(strFmt("@SYS329992", amount, this.AgreedReleaseLineMinAmount));
                }
                else
                {
                    checkFailed(salesPurchLineInterface.parmItemId() ? strFmt("@SCM:ItemReleasedAmountIsLowerThanMinReleaseAmountOnSalesAgreementLine", salesPurchLineInterface.parmItemId(), amount, this.AgreedReleaseLineMinAmount)
                        :strFmt("@SCM:CategoryReleasedAmountIsLowerThanMinReleaseAmountOnSalesAgreementLine", EcoResCategory::find(salesPurchLineInterface.parmCategoryId()).Name, amount, this.AgreedReleaseLineMinAmount));
                }
            }

            if (this.AgreedReleaseLineMaxAmount && this.AgreedReleaseLineMaxAmount < amount)
            {
                if (_salesPurchLine.TableId == tableNum(PurchLine))
                {
                    checkFailed(strFmt("@SYS329993", amount, this.AgreedReleaseLineMaxAmount));
                }
                else
                {
                    checkFailed(salesPurchLineInterface.parmItemId() ? strFmt("@SCM:ItemReleasedAmountExceedsMaxReleaseAmountOnSalesAgreementLine", salesPurchLineInterface.parmItemId(), amount, this.AgreedReleaseLineMaxAmount)
                    :strFmt("@SCM:CategoryReleasedAmountExceedsMaxReleaseAmountOnSalesAgreementLine", EcoResCategory::find(salesPurchLineInterface.parmCategoryId()).Name, amount, this.AgreedReleaseLineMaxAmount));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether the <c>AgreementLine</c> record can be deleted.
    /// </summary>
    /// <returns>
    ///    true if the <c>AgreementLine</c> record can be deleted; otherwise, false.
    /// </returns>
    public boolean validateDelete()
    {
        boolean ret;

        AgreementLine aLine;
        VendInvoiceInfoLine vendInvoiceInfoLine;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            select firstOnly RecId, AgreementLine_PSN from vendInvoiceInfoLine
                join recId from aLine
                    where vendInvoiceInfoLine.AgreementLine_PSN == aLine.RecId
                       && vendInvoiceInfoLine.ParmId == ''
                       && aLine.RecId == this.RecId;

            if (!vendInvoiceInfoLine)
            {
                ret = super();

                if (ret && this.isReleased())
                {
                    if (this.agreementModuleType() == ModuleSalesPurch::Sales)
                    {
                        ret = checkFailed("@SYS302946");
                    }
                    else
                    {
                        ret = checkFailed("@SYS302947");
                    }
                }

                if (ret && this.isDerivedAgreement())
                {
                    ret = checkFailed("@SYS334944");
                }
            }
            else
            {
                warning("@SPS2385");
                ret = false;
            }

            return ret;
        }
        else
        {
            ret = super();

            if (ret && this.isReleased())
            {
                if (this.agreementModuleType() == ModuleSalesPurch::Sales)
                {
                    ret = checkFailed("@SYS302946");
                }
                else
                {
                    ret = checkFailed("@SYS302947");
                }
            }

            if (ret && this.isDerivedAgreement())
            {
                ret = checkFailed("@SYS334944");
            }
            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a field in the <c>AgreementLine</c> table.
    /// </summary>
    /// <param name="_fieldIdToCheck">
    /// The field ID of the field to validate.
    /// </param>
    /// <returns>
    /// true if the value in the field is valid; otherwise, false.
    /// </returns>
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean         ret;
        AgreementLine   lineOrig;

        ret = super(_fieldIdToCheck);

        if (ret)
        {
            switch (_fieldIdToCheck)
            {
                case fieldNum(AgreementLine, ExpirationDate),
                     fieldNum(AgreementLine, EffectiveDate) :
                    if (!AgreementHeader::validatePeriod(this.EffectiveDate, this.ExpirationDate))
                    {
                        ret = false;
                    }
                    break;

                case fieldNum(AgreementLine, IsPriceInformationMandatory):
                    if (this.isReleased())
                    {
                        if (this.IsPriceInformationMandatory == NoYes::Yes)
                        {
                            ret = checkFailed("@SYS302942");
                        }
                        else if (FormDataUtil::isFormDataSource(this))
                        {
                            ret = Box::okCancel("@SYS137222", DialogButton::Cancel) == DialogButton::Ok;
                        }
                        else
                        {
                            ret = checkFailed("@SCM:CannotDisableFixedPriceAndDiscountRequirementWhenAgreementLineIsReleased");
                        }
                    }
                    break;

                case fieldNum(AgreementLine, LineDiscountPercent):
                    if (this.IsPriceInformationMandatory == NoYes::Yes && this.isReleased())
                    {
                        ret = checkFailed("@SYS137221");
                    }
                    break;
                // Validate the item against customer/vendor filters.
                case fieldNum(AgreementLine, ItemId):
                    if (WHSInventEnabled::exist(this.ItemId))
                    {
                        switch (this.agreementModuleType())
                        {
                            case ModuleSalesPurch::Purch:
                                if (!WHSFilter::vendFilterMatch(this.purchAgreementHeader().VendAccount, this.ItemId))
                                {
                                    ret = checkFailed("@WAX1003");
                                }
                                break;
                            case ModuleSalesPurch::Sales:
                                if (!WHSFilter::custFilterMatch(this.salesAgreementHeader().CustAccount, this.ItemId))
                                {
                                    ret = checkFailed(strFmt("@WAX:CustomerFiltersMatchingMessage", this.ItemId));
                                }
                                break;
                            default:
                                break;
                        }
                    }
                    break;
            }

            if (!ret)
            {
                lineOrig = this.orig();
                this.(_fieldIdToCheck) = lineOrig.(_fieldIdToCheck);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useBundlesOnSalesAgreement</Name>
				<Source><![CDATA[
    protected boolean useBundlesOnSalesAgreement()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateModifyInventDim_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the inventory dimension can be changed.
    /// </summary>
    /// <param name="_inventDim">
    ///     The changed record of the <c>InventDim</c> table.
    /// </param>
    /// <param name="_dimFieldId">
    ///     The changed inventory dimension field.
    /// </param>
    /// <returns>
    ///     true if changes can be processed; otherwise, false.
    /// </returns>
    public boolean validateModifyInventDim_RU(
        InventDim           _inventDim,
        FieldId             _dimFieldId)
    {
        boolean ok = true;

        if (_dimFieldId == fieldnum(InventDim, InventProfileId_RU))
        {
            switch (this.agreementModuleType())
            {
                case ModuleSalesPurch::Sales:
                    ok = this.checkSalesInventProfile_RU(_inventDim) && ok;
                    break;
                case ModuleSalesPurch::Purch:
                    ok = this.checkPurchInventProfile_RU(_inventDim) && ok;
                    break;
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRelease</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether the <c>agreementLine</c> record can be associated with the record in a table corresponding to <c>SalesPurchLine</c> map.
    /// </summary>
    /// <param name = '_salesPurchLine'>
    ///    Record in a table corresponding to <c>SalesPurchLine</c> map.
    /// </param>
    /// <param name = '_warningReportList'>
    ///    A list holding warning messages that can later be displayed to the user.
    /// </param>
    /// <returns>
    ///    true if the line can be associated; otherwise, false.
    /// </returns>
    private boolean validateRelease(SalesPurchLine _salesPurchLine, List _warningReportList = null)
    {
        SalesPurchLineInterface salesPurchLineInterface = _salesPurchLine.salesPurchLineInterface();

        if (!this.checkRemaining(this.isQuantityBased() ? salesPurchLineInterface.parmQty() : salesPurchLineInterface.parmLineAmount()))
        {
            if (_warningReportList)
            {
                switch (_salesPurchLine.TableId)
                {
                    case tableNum(SalesLine):
                        _warningReportList.addStart(strFmt('@SCM:QuantityOrValueExceedingMaxSpecifiedOnSalesAgreementLine', salesPurchLineInterface.parmItemId(), salesPurchLineInterface.parmQty()));
                        break;
                    case tableNum(PurchLine):
                        if (this.isQuantityBased())
                        {
                            _warningReportList.addStart('@SYS135461');
                        }
                        else
                        {
                            _warningReportList.addStart('@SYS305711');
                        }
                        break;
                }
            }
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReleaseMinMaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the release maximum or minimum amount setup of the <c>AgreementLine</c> record.
    /// </summary>
    /// <returns>
    ///    true if the setup is valid; otherwise, false.
    /// </returns>
    public boolean validateReleaseMinMaxAmount()
    {
        boolean     ok = true;

        if (this.AgreedReleaseLineMaxAmount < 0 || this.AgreedReleaseLineMinAmount < 0)
        {
            ok = checkFailed("@SYS303514");
        }

        if (this.AgreedReleaseLineMinAmount > this.AgreedReleaseLineMaxAmount)
        {
            ok = checkFailed("@SYS303515");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ok;
        PdsApprovedVendorListCheck avl;

        ok = super();

        if (this.canEditItemId() && !this.ItemId)
        {
            ok = checkFailed("@SYS25157");
        }
        else if (this.canEditCategory() && !this.Category)
        {
            ok = checkFailed(strFmt("@SYS26332", fieldPName(AgreementLine, Category)));
        }
        else if (!this.ItemId && !this.Category)
        {
            ok = checkFailed("@SYS134349");
        }

        if (this.AgreedReleaseLineMaxAmount || this.AgreedReleaseLineMinAmount)
        {
            ok = ok && this.validateReleaseMinMaxAmount();
        }

        if (this.agreementModuleType() == ModuleSalesPurch::Purch)
        {
            avl = PdsApprovedVendorListCheck::newFromTable(this);
            avl.parmIgnoreError(true);
            ok = ok && avl.validateCheck();
        }

        ok = ok & this.validateProject();
        ok = ok && this.validateNetAmount();

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needCheckCLMIntegrationFields</Name>
				<Source><![CDATA[
    private boolean needCheckCLMIntegrationFields()
    {
        if (this.RecId && this.IsIntegration != PurchAgreementIntegrationType::CLM && CLMIntegrationFeature::isEnabled())
        {
            PurchAgreementHeader purchAgreementHeader = PurchAgreementHeader::find(this.Agreement);

            return purchAgreementHeader.RecId
                && purchAgreementHeader.CLMIntegrationPurchAgreementOwnership == CLMIntegrationPurchaseAgreementOwnershipType::CLM;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the project information for the agreement line.
    /// </summary>
    /// <param name = "_agreementHeaderDefault">The <c>AgreementHeaderDefault</c> record for the agreement line; optional.</param>
    /// <returns>true, if the project information is valid; otherwise, false.</returns>
    public boolean validateProject(AgreementHeaderDefault _agreementHeaderDefault = this.agreementHeaderDefault())
    {
        boolean ret = true;

        if (_agreementHeaderDefault.Project)
        {
            if (this.ProjectProjId)
            {
                ret = ProjTable::find(this.ProjectProjId).status().validateWritePurchTable();
            }
            else
            {
                ret = checkFailed("@SYS50152");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateFulfillmentForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates the calculations of fulfillment numbers for the line.
    /// </summary>
    /// <param name="_line">
    /// A called instance of the <c>AgreementLine</c> object.
    /// </param>
    /// <returns>
    /// A container with fulfillment numbers.
    /// </returns>
    /// <remarks>
    /// This method is used by forms to query all fulfillment numbers at the same time.
    /// </remarks>
    public static container calculateFulfillmentForLine (AgreementLine    _line)
    {
        return _line.calculateAgreementRemansOnServer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsByAgreementHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a record exists for the specified value of the <c>PurchAgreementHeader</c> table
    /// record.
    /// </summary>
    /// <param name="_agreementHeader">
    /// The record ID of the <c>PurchAgreementHeader</c> table record ID.
    /// </param>
    /// <returns>
    /// true if the record is found; otherwise, false.
    /// </returns>
    public static boolean existsByAgreementHeader(recId _agreementHeader)
    {
        AgreementLine agreementLine;

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            select RecId from agreementLine
                where agreementLine.Agreement == _agreementHeader;
        }

        return agreementLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>AgreementLine</c> table.
    /// </summary>
    /// <param name="_agreementLineRecId">
    ///    The record ID of the <c>AgreementLine</c> record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>AgreementLine</c> table; otherwise, an empty record.
    /// </returns>
    public static AgreementLine find(AgreementLineRecId _agreementLineRecId,
                                     boolean            _forUpdate = false)
    {
        AgreementLine agreementLine;

        if (_agreementLineRecId)
        {
            if (_forUpdate)
            {
                agreementLine.selectForUpdate(_forUpdate);
            }

            select agreementLine
                where agreementLine.RecId == _agreementLineRecId;
        }

        return agreementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the record in the <c>AgreementLine</c> table by using the specified record ID of a
    ///    <c>CustInvoiceTrans</c> record.
    /// </summary>
    /// <param name="_refRecId">
    ///    The record ID of the <c>CustInvoiceTrans</c> record that is linked to the <c>AgreementLine</c>
    ///    record to find.
    /// </param>
    /// <returns>
    ///    A record in the <c>AgreementLine</c> table; otherwise, an empty record.
    /// </returns>
    static AgreementLine findCustInvoiceTrans(RefRecId _refRecId)
    {
        AgreementLine             agreementLine;
        AgreementLineReleasedLine agreementLineReleasedLine;
        tableId                   relationType = tableNum(CustInvoiceTrans);

        if (_refRecId)
        {
            select firstonly agreementLine
                where !agreementLine.IsDeleted
                exists join agreementLineReleasedLine
                where agreementLineReleasedLine.CustInvoiceTrans      == _refRecId
                   && agreementLineReleasedLine.ReferenceRelationType == relationType
                   && !agreementLineReleasedLine.IsDeleted
                   && agreementLineReleasedLine.AgreementLine         == agreementLine.RecId;
        }

        return agreementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAgreementLineFromEnumerator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns agreement line (with super- and sub-type data) based on the RecId of AgreementLine record stored in the enumerator.
    /// </summary>
    /// <param name="_agreementLineEnumerator">
    /// The agreement line enumerator of the agrement line record list.
    /// </param>
    /// <returns>
    /// The agreement line found based on the RecId.
    /// </returns>
    private static AgreementLine getAgreementLineFromEnumerator(ListEnumerator _agreementLineEnumerator)
    {
        AgreementLine restoredAgreementLine = _agreementLineEnumerator.current();
        return AgreementLine::find(restoredAgreementLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLineForAutoMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the best agreement line to associate with the sales or purchase line.
    /// </summary>
    /// <param name="_salesPurchLine">
    /// The sales or purchase line to find the agreement lines for.
    /// </param>
    /// <param name="_matchingAgreement">
    /// The record ID of the agreement header.
    /// </param>
    /// <param name="_checkLimits">
    /// A Boolean value that indicates whether to check the agreed maximum and minimum amounts and remaining quantity or amount; optional.
    /// </param>
    /// <param name="_warningReportList">
    /// A List containing value that indicates whether to report warning that agreementLine exceeds the maximum limits; optional.
    /// </param>
    /// <returns>
    /// The best agreement line among the lines of the scpecified agreement for the sales or purchase line.
    /// </returns>
    public static AgreementLine findLineForAutoMatch(SalesPurchLine       _salesPurchLine,
                                                            AgreementHeaderRecId _matchingAgreement,
                                                            boolean              _checkLimits = false,
                                                            List                 _warningReportList = null)
    {
        SalesPurchLineInterface salesPurchLineInterface = _salesPurchLine.salesPurchLineInterface();
        AgreementLine           bestPossibleAgreementLineMatch;
        AgreementHeader         agreementHeader;
        List                    contendersList;
        ListEnumerator          contendersListEnumerator;

        // Input check.
        if (!salesPurchLineInterface.parmItemId() && !salesPurchLineInterface.parmCategoryId())
        {
            return bestPossibleAgreementLineMatch;
        }

        // Find header...
        if (_matchingAgreement)
        {
            agreementHeader = AgreementHeader::find(_matchingAgreement,false);
            if (!agreementHeader.RecId || agreementHeader.AgreementState != AgreementState::Effective)
            {
                // AgreementHeader doesn't exist.
                return bestPossibleAgreementLineMatch;
            }
        }

        contendersList = AgreementLine::getContendersList(_salesPurchLine, _matchingAgreement, _checkLimits);

        // If match is possible for provided matching criterias, contendersList shouldn't be empty
        if (contendersList.empty())
        {
            return bestPossibleAgreementLineMatch;
        }

        if (contendersList.elements() == 1)
        {
            // There is only a single candidate identified...
            contendersListEnumerator = contendersList.getEnumerator();
            if ( contendersListEnumerator.moveNext())
            {
                bestPossibleAgreementLineMatch = AgreementLine::getAgreementLineFromEnumerator(contendersListEnumerator);
            }
            if (!_checkLimits && bestPossibleAgreementLineMatch.IsMaxEnforced == NoYes::No)
            {
                // We don't need to check if agreement has enough quantity (amount) for release,
                // so single candidate agreement lins is a winner:
                return bestPossibleAgreementLineMatch;
            }
        }

        // More than one candidate for possible match has been identified
        // or single candidate requires validation of released quantity (amount).
        // Now we need to refine the list and pick up the best match if any exists
        return AgreementLine::findTheBestAgreementLine(contendersList, _salesPurchLine, _checkLimits, _warningReportList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContendersList</Name>
				<Source><![CDATA[
    protected static List getContendersList(SalesPurchLine _salesPurchLine,
                                     AgreementHeaderRecId _matchingAgreement,
                                     boolean              _checkLimits = false)
    {
        using (var activityContext = AgreementInstrumentationLogger::createLogger(tableStr(AgreementLine)).agreement().getContendersList(_salesPurchLine.TableId, _matchingAgreement != 0, _checkLimits))
        {
            List contendersList;

            if (_salesPurchLine.TableId != tableNum(PurchReqLine))
            {
                contendersList = AgreementLine::getAgreementLinesForOrderLine(_salesPurchLine, _matchingAgreement, _checkLimits /*get all candidats if check limits*/);
            }
            else
            {
                contendersList = AgreementLine::getAgreementLinesForPurchReqLine(_salesPurchLine);
            }

            return contendersList;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProjInvoiceItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the record in the <c>AgreementLine</c> table by using the specified record ID of a
    ///    <c>ProjInvoiceItem</c> record.
    /// </summary>
    /// <param name="_refRecId">
    ///    The record ID of a <c>ProjInvoiceItem</c> record that is linked to the <c>AgreementLine</c> record
    ///    to find.
    /// </param>
    /// <returns>
    ///    A record in the <c>AgreementLine</c> table; otherwise, an empty record.
    /// </returns>
    static AgreementLine findProjInvoiceItem(RefRecId _refRecId)
    {
        AgreementLine             agreementLine;
        AgreementLineReleasedLine agreementLineReleasedLine;
        tableId                   relationType = tableNum(ProjInvoiceItem);

        if (_refRecId)
        {
            select firstonly agreementLine
                where !agreementLine.IsDeleted
                exists join agreementLineReleasedLine
                where agreementLineReleasedLine.ProjInvoiceItem       == _refRecId
                   && agreementLineReleasedLine.ReferenceRelationType == relationType
                   && !agreementLineReleasedLine.IsDeleted
                   && agreementLineReleasedLine.AgreementLine         == agreementLine.RecId;
        }

        return agreementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTheBestAgreementLine</Name>
				<Source><![CDATA[
    private static AgreementLine findTheBestAgreementLine(List           _contendersList,
                                                                 SalesPurchLine _salesPurchLine,
                                                                 boolean        _checkLimits = false,
                                                                 List           _warningReportList = null)

    {
        InventDim       releaseLineInventDim;
        AgreementLine   bestMatchingAgreementLine;
        AgreementLine   curAgreementLine;
        ListEnumerator  contendersListEnumerator;
        List            refinedList;
        List            inventDimFieldList;
        
        //************** LOCAL METHOD
        //               Selects all candidate lines that are compatible by dimension fields,
        //               specified by inventDimFieldList                                     *********************************************
        void dimensionMatch()
        {
            contendersListEnumerator = _contendersList.getEnumerator();
            while (contendersListEnumerator.moveNext())
            {
                curAgreementLine = AgreementLine::getAgreementLineFromEnumerator(contendersListEnumerator);
                if (InventDim::isInventDimEqual(releaseLineInventDim, InventDim::find(curAgreementLine.InventDimId), inventDimFieldList))
                {
                    refinedList.addEnd(curAgreementLine);
                }
            }
        }
        //*******************************************************************************************************************************

        if (_contendersList.empty())
        {
            return bestMatchingAgreementLine;
        }

        releaseLineInventDim = _salesPurchLine.salesPurchLineInterface().inventDim();

        refinedList = new List(Types::Record);
        contendersListEnumerator = _contendersList.getEnumerator();

        // Refine the contendersList first by InventDim...
        // Try to find exact match for all specified dimensions
        while (contendersListEnumerator.moveNext())
        {
            curAgreementLine = AgreementLine::getAgreementLineFromEnumerator(contendersListEnumerator);
            if (curAgreementLine.InventDimId == releaseLineInventDim.InventDimId)
            {
                refinedList.addEnd(curAgreementLine);
            }
        }

        if (refinedList.empty())
        {
            // There were no agreement lines among candidates with exact match on InventDimId.
            // Try to look into matching agreement lines with wildcard dimensions...
            inventDimFieldList = AgreementLine::getDimFieldList(releaseLineInventDim);
            while (inventDimFieldList.elements() && refinedList.empty())
            {
                dimensionMatch();
                // remove the last element from the list
                ListIterator fieldListIterator = new ListIterator(inventDimFieldList);
                Counter x = inventDimFieldList.elements();
                fieldListIterator.begin();
                while (x > 1)
                {
                    fieldListIterator.next();
                    x--;
                }
                fieldListIterator.delete();
            }
        }

        // Verify results...
        if (refinedList.empty())
        {
            // If initial list was not empty but refined list is this could mean that all
            // provided candidates were wildcard-only-dimensions agreement lines.
            refinedList = _contendersList;
        }

        ListEnumerator refinedListEnumerator = refinedList.getEnumerator();

        // Here we know the list can't be empty...
        // Choosing THE ONE...

        SalesPurchLine  localSalesPurchline;
        PurchLine       emptyPurchLineBuffer;
        SalesLine       emptySalesLineBuffer;
        PurchReqLine    emptyPurchReqLineBuffer;
        if (_checkLimits)
        {
            // Prepare local map instance.
            // Need to initialize it with a proper TableId first:
            switch (_salesPurchLine.TableId)
            {
                case tableNum(SalesLine):
                    SalesLine       localSalesLine = _salesPurchLine;
                    // Initialize the main data to calculate line amount:
                    emptySalesLineBuffer.data(localSalesLine);
                    emptySalesLineBuffer.setPriceDisc(releaseLineInventDim);
                    localSalesPurchline = emptySalesLineBuffer;
                    break;

                case tableNum(PurchLine):
                    PurchLine       localPurchLine = _salesPurchLine;
                    // Initialize the main data to calculate line amount:
                    emptyPurchLineBuffer.data(localPurchLine);
                    emptyPurchLineBuffer.setPriceDisc(releaseLineInventDim);
                    localSalesPurchline = emptyPurchLineBuffer;
                    break;

                case tableNum(PurchReqLine):
                    PurchReqLine    localPurchReqLine = _salesPurchLine;
                    // Initialize the main data to calculate line amount:
                    emptyPurchReqLineBuffer.data(localPurchReqLine);
                    emptyPurchReqLineBuffer.setPriceDisc(releaseLineInventDim);
                    localSalesPurchline = emptyPurchReqLineBuffer;
                    break;
            }
        }

        ProjId projectId = emptyPurchLineBuffer.ProjId ? emptyPurchLineBuffer.ProjId : emptyPurchReqLineBuffer.ProjId;

        AgreementLine salesPurchMatchingAgreementLine;
        if (refinedList.elements() > 1)
        {
            salesPurchMatchingAgreementLine = AgreementLine::findMatchingAgreementLine(_salesPurchLine);
        }
        
        while (refinedListEnumerator.moveNext())
        {
            curAgreementLine = AgreementLine::getAgreementLineFromEnumerator(refinedListEnumerator);

            if (_checkLimits)
            {
                SalesPurchLineInterface localSalesPurchLineInterface = localSalesPurchline.salesPurchLineInterface();

                localSalesPurchLineInterface.initFromAgreementLine(curAgreementLine);

                // Calculate line amount to be used in limits check
                localSalesPurchLineInterface.calcLineAmount();

                if (!curAgreementLine.validateRelease(localSalesPurchline, _warningReportList))
                {
                    continue;
                }
            }

            if (!bestMatchingAgreementLine.RecId)
            {
                bestMatchingAgreementLine = curAgreementLine;
                continue;
            }

            if ((curAgreementLine.Category != bestMatchingAgreementLine.Category))
            {
                if (curAgreementLine.Category == _salesPurchLine.salesPurchLineInterface().parmCategoryId())
                {
                    bestMatchingAgreementLine = curAgreementLine;
                }

                continue;
            }

            // Purchase Agreements with project are preferred...
            if ((curAgreementLine.ProjectProjId != bestMatchingAgreementLine.ProjectProjId) && projectId)
            {
                if (!curAgreementLine.ProjectProjId)
                {
                    continue;
                }
                if (curAgreementLine.ProjectProjId == projectId)
                {
                    bestMatchingAgreementLine = curAgreementLine;
                    continue;
                }
            }

            // Earliest EffectiveDate wins...
            if (bestMatchingAgreementLine.EffectiveDate != curAgreementLine.EffectiveDate)
            {
                if (curAgreementLine.EffectiveDate < bestMatchingAgreementLine.EffectiveDate)
                {
                    bestMatchingAgreementLine = curAgreementLine;
                }
                continue;
            }

            // Quantity based line wins
            if (bestMatchingAgreementLine.InstanceRelationType != curAgreementLine.InstanceRelationType)
            {
                if (curAgreementLine is AgreementLineQuantityCommitment)
                {
                    bestMatchingAgreementLine = curAgreementLine;
                }
                continue;
            }

            // Agreement line that has been created first wins
            if (curAgreementLine.CreatedDateTime < bestMatchingAgreementLine.CreatedDateTime)
            {
                bestMatchingAgreementLine = curAgreementLine;
                continue;
            }

            // Agreement line that linked to the SalesPurchLine wins
            if (curAgreementLine.RecId == salesPurchMatchingAgreementLine.RecId)
            {
                bestMatchingAgreementLine = curAgreementLine;
            }
        }

        // We have a winner...
        return bestMatchingAgreementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMatchingAgreementLine</Name>
				<Source><![CDATA[
    protected static AgreementLine findMatchingAgreementLine(SalesPurchLine _salesPurchLine)
    {
        AgreementLine salesPurchMatchingAgreementLine;

        switch (_salesPurchLine.TableId)
        {
            case tableNum(SalesLine):
                SalesLine localSalesLine = _salesPurchLine;
                salesPurchMatchingAgreementLine = AgreementLine::find(localSalesLine.MatchingAgreementLine);
                break;

            case tableNum(PurchLine):
                PurchLine localPurchLine = _salesPurchLine;
                salesPurchMatchingAgreementLine = AgreementLine::find(localPurchLine.MatchingAgreementLine);
                break;
        }

        return salesPurchMatchingAgreementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVendInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the record in the <c>AgreementLine</c> table by using the specified record ID of a
    ///    <c>VendInvoiceTrans</c> record.
    /// </summary>
    /// <param name="_refRecId">
    ///    The record ID of the <c>VendInvoiceTrans</c> record that is linked to the <c>AgreementLine</c>
    ///    record to find.
    /// </param>
    /// <returns>
    ///    A record in the <c>AgreementLine</c> table; otherwise, an empty record.
    /// </returns>
    static AgreementLine findVendInvoiceTrans(RefRecId _refRecId)
    {
        AgreementLine             agreementLine;
        AgreementLineReleasedLine agreementLineReleasedLine;
        tableId                   relationType = tableNum(VendInvoiceTrans);

        if (_refRecId)
        {
            select firstonly agreementLine
                where !agreementLine.IsDeleted
                exists join agreementLineReleasedLine
                where agreementLineReleasedLine.VendInvoiceTrans      == _refRecId
                   && agreementLineReleasedLine.ReferenceRelationType == relationType
                   && !agreementLineReleasedLine.IsDeleted
                   && agreementLineReleasedLine.AgreementLine         == agreementLine.RecId;
        }

        return agreementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByPurchaseNumberAndLineNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the record from the <c>AgreementLine</c> table based on the specific information.
    /// </summary>
    /// <param name = "_buyingLegalEntity">
    /// The record ID of a <c>CompanyInfo</c> record for the purchase agreement.
    /// </param>
    /// <param name = "_agreementId">
    /// The purchase agreement number sequence.
    /// </param>
    /// <param name = "_lineNumber">
    /// The detail line number of the purchase agreement.
    /// </param>
    /// <returns>
    /// The record buffer of the <c>AgreementLine</c> table for the specific information matched; otherwise, an empty buffer.
    /// </returns>
    public static AgreementLine findByPurchaseNumberAndLineNumber(RefRecId _buyingLegalEntity,
        PurchAgreementId _agreementId,
        AgreementLineNumber_PSN _lineNumber)
    {
        AgreementLine agreementLine;
        PurchAgreementHeader purchAgreementHeader;
        
        if (_buyingLegalEntity && _agreementId != "" && _lineNumber > 0)
        {
            select firstonly agreementLine
                exists join purchAgreementHeader
                    where agreementLine.Agreement == purchAgreementHeader.RecId
                        && purchAgreementHeader.PurchNumberSequence == _agreementId
                        && purchAgreementHeader.BuyingLegalEntity == _buyingLegalEntity
                        && agreementLine.LineNumber == _lineNumber
                        && agreementLine.IsDeleted == NoYes::No;
        }
        
        return agreementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAgreementLinesForOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the list of the agreement lines that match to the sales or purchase line.
    /// </summary>
    /// <param name="_salesPurchLine">
    ///    The sales or purchase line for which to find the agreement lines.
    /// </param>
    /// <param name="_matchingAgreement">
    ///    The record ID of the agreement header.
    /// </param>
    /// <param name="_getAll">
    ///    A Boolean value that indicates whether to retrieve all agreement lines that match; optional.
    /// </param>
    /// <returns>
    ///    The list of the found agreement lines.
    /// </returns>
    /// <remarks>
    ///    If the <paramref name="_getAll" /> parameter is false, the optimization will be done. The agreement
    ///    lines will not be added to the list if they have lower priority than the lines already added to the
    ///    list. The item based agreement lines have more priority than the category based agreement lines.If
    ///    the <paramref name="_getAll" /> parameter is true, all found agreement lines will be added to the
    ///    list.
    /// </remarks>
    [Replaceable]
    public static List getAgreementLinesForOrderLine(SalesPurchLine       _salesPurchLine,
                                                     AgreementHeaderRecId _matchingAgreement,
                                                     boolean              _getAll = false)
    {
        SalesLine                        salesLine;
        PurchLine                        purchLine;
        date                             expDate;
        ProjId                           projId;

        AgreementLineQuantityCommitment  agreementLineQuantity;
        AgreementLineVolumeCommitment    agreementLineVolume;
        AgreementHeader                  agreementHeader;
        PurchAgreementHeader             purchAgreementHeader;
        SalesAgreementHeader             salesAgreementHeader;
        Common                           salesPurchAgreementHeader;
        fieldId                          custVendAccountFieldId;
        CustVendAC                       custVendAccount;
        InventDim                        inventDim;
        SalesPurchLineInterface          salesPurchLineInterface = _salesPurchLine.salesPurchLineInterface();
        InventDim                        salesPurchLineInventDim = salesPurchLineInterface.inventDim();

        EcoResCategoryId                 category = salesPurchLineInterface.parmCategoryId();
        EcoResCategoryId                 rootCategory;
        EcoResCategoryNamedHierarchyRole hierarchyRole;

        List                             resultList       = new List(Types::Record);
        List                             categoryList     = new List(Types::Record);
        List                             rootCategoryList = new List(Types::Record);

        #localmacro.AgreementLineSelect
    //%1 AgreementLine subtype table
    select %1
        where (!_matchingAgreement || %1.Agreement       == _matchingAgreement)
            && %1.IsDeleted              == NoYes::No
            && %1.expirationDate         >= expDate
            && %1.effectiveDate          <= expDate
            && ((_salesPurchLine.TableId == tablenum(PurchLine) && (%1.ProjectProjId == projId || %1.ProjectProjId == ''))
             || (_salesPurchLine.TableId == tablenum(SalesLine) && %1.ProjectProjId == projId))
            && %1.InventDimDataAreaId    == appl.company().dataArea(tablenum(InventDim))
            && ((salesPurchLineInterface.parmItemId()
                    && %1.ItemId         == salesPurchLineInterface.parmItemId()
                    && %1.ItemDataAreaId == appl.company().dataArea(tablenum(InventTable)))
                || (!%1.ItemId
                    && category
                    && (%1.Category      == category
                        || %1.Category   == rootCategory)))
    #endmacro

        #localmacro.AgreementLineQuantityCommitmentCondition
             (salesPurchLineInterface.parmLineDeliveryType() != LineDeliveryType::OrderLineWithMultipleDeliveries
                || AgreementLineQuantity.IsMaxEnforced == NoYes::No
                || AgreementLineQuantity.ProductUnitOfMeasure == salesPurchLineInterface.parmUnitId())
    #endmacro

        #localmacro.AgreementLineHeaderExistsJoin
    //%1 AgreementLine subtype table
        exists join agreementHeader
        where agreementHeader.RecId == %1.Agreement
            && agreementHeader.IsDeleted == NoYes::No
            && agreementHeader.AgreementState == AgreementState::Effective
    #endmacro

        #localmacro.AgreementVendCustAccountExistsJoin
    //%1 - AgreementLine subtype table
                exists join salesPurchAgreementHeader
                    where salesPurchAgreementHeader.RecId == %1.Agreement
                        && (_matchingAgreement || (salesPurchAgreementHeader.(custVendAccountFieldId) == custVendAccount))
    #endmacro

        void addToList(AgreementLine _aLine)
        {
            if (_getAll)
            {
                resultList.addEnd(_aLine);
            }
            else
            {
                if (_aLine.ItemId)
                {
                    resultList.addEnd(_aLine);
                }
                else if (resultList.empty()) //do not add the category agreement lines if item agreement lines are already found
                {
                    if (_aLine.Category != rootCategory)
                    {
                        categoryList.addEnd(_aLine);
                    }
                    else if (categoryList.empty()) //do not add the root category agreement lines if category agreement lines are already found
                    {
                        rootCategoryList.addEnd(_aLine);
                    }
                }
            }
        }

        if (_salesPurchLine.TableId == tableNum(SalesLine)
            && AgreementLineSysDaBuilderFlight::instance().isEnabled())
        {
            return AgreementLineSysDaBuilder::newSalesPurchLine(_salesPurchLine, _matchingAgreement, _getAll).getAgreementLinesForOrderLine();
        }

        using (var activityContext = AgreementInstrumentationLogger::createLogger(tableStr(AgreementLine)).useSelect().getLinesForOrderLine(_salesPurchLine.TableId, _matchingAgreement != 0, _getAll))
        {
            switch (_salesPurchLine.TableId)
            {
                case tableNum(SalesLine):
                    salesLine                 = _salesPurchLine;
                    expDate                   = salesLine.ShippingDateRequested ? salesLine.ShippingDateRequested : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    projId                    = salesLine.ProjId;
                    hierarchyRole             = EcoResCategoryNamedHierarchyRole::Sales;
                    salesPurchAgreementHeader = salesAgreementHeader;
                    custVendAccount           = salesLine.CustAccount;
                    custVendAccountFieldId    = fieldNum(SalesAgreementHeader, CustAccount);
                    break;
                case tableNum(PurchLine):
                    purchLine                 = _salesPurchLine;
                    expDate                   = purchLine.DeliveryDate ? purchLine.DeliveryDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    projId                    = purchLine.ProjId;
                    hierarchyRole             = EcoResCategoryNamedHierarchyRole::Procurement;
                    salesPurchAgreementHeader = purchAgreementHeader;
                    custVendAccount           = purchLine.VendAccount;
                    custVendAccountFieldId    = fieldNum(PurchAgreementHeader, VendAccount);
                    break;
            }

            if (!category)
            {
                category = EcoResProductCategory::findByItemIdCategoryHierarchyRole(salesPurchLineInterface.parmItemId(), hierarchyRole).Category;
            }

            rootCategory = EcoResCategory::getRoot(EcoResCategoryHierarchyRole::getHierarchiesByRole(hierarchyRole).CategoryHierarchy).RecId;

            while #AgreementLineSelect(AgreementLineQuantity)
                    && #AgreementLineQuantityCommitmentCondition
                    #AgreementInventDimExistsJoin(AgreementLineQuantity.InventDimId, inventDim, salesPurchLineInventDim)
            #AgreementLineHeaderExistsJoin(AgreementLineQuantity)
            && (agreementLineQuantity.IsPriceInformationMandatory == NoYes::No
                    || agreementHeader.Currency == salesPurchLineInterface.parmCurrencyCode())
                    #AgreementVendCustAccountExistsJoin(AgreementLineQuantity)
            {
                addToList(agreementLineQuantity);
            }

            while #AgreementLineSelect(AgreementLineVolume)
                    #AgreementInventDimExistsJoin(agreementLineVolume.InventDimId, inventDim, salesPurchLineInventDim)
            #AgreementLineHeaderExistsJoin(AgreementLineVolume)
            && agreementHeader.Currency == salesPurchLineInterface.parmCurrencyCode()
                    #AgreementVendCustAccountExistsJoin(AgreementLineVolume)
            {
                addToList(agreementLineVolume);
            }

            if (_getAll || !resultList.empty())
            {
                return resultList;
            }

            if (!categoryList.empty())
            {
                return categoryList;
            }

            return rootCategoryList;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAgreementLinesForPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the list of the agreement lines that match to the purchase line.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase line for which to find the agreement lines.
    /// </param>
    /// <param name="_matchingAgreement">
    /// The record ID of the agreement header.
    /// </param>
    /// <returns>
    /// The list of the found agreement lines.
    /// </returns>
    public static List getAgreementLinesForPurchLine(PurchLine _purchLine, AgreementHeaderRecId  _matchingAgreement)
    {
        return AgreementLine::getAgreementLinesList(_matchingAgreement, _purchLine, _purchLine.DeliveryDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAgreementLinesForPurchReqLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the list of the agreement lines that match the sales or purchase line.
    /// </summary>
    /// <param name="_purchReqLine">
    /// The purchase requisition line for which to find the agreement lines.
    /// </param>
    /// <returns>
    /// The list of the found agreement lines.
    /// </returns>
    public static List getAgreementLinesForPurchReqLine(PurchReqLine _purchReqLine)
    {
        AgreementLineQuantityCommitment  agreementLineQuantity;
        AgreementLineVolumeCommitment    agreementLineVolume;
        AgreementHeader                  agreementHeader;
        PurchAgreementHeader             purchAgreementHeader;
        Common                           salesPurchAgreementHeader;
        FieldId                          custVendAccountFieldId;
        CustVendAC                       custVendAccount;
        InventDim                        inventDim;
        InventDim                        purchReqLineInventDim = _purchReqLine.inventDim();
        EcoResCategoryId                 rootCategory;
        List                             resultList       = new List(Types::Record);
        List                             categoryList     = new List(Types::Record);
        List                             rootCategoryList = new List(Types::Record);
        PurchReqLine                     purchReqLineValidate;
        EcoResCategory                   ecoResCategory, ecoResCategoryChildren;
        DataAreaId                       companyId = appl.company().dataArea(tablenum(InventDim));
        AgreementClassification          agreementClassification;

        
        void addToList(AgreementLine _aLine)
        {
            
            if (PurchRetrieveAgreementLinesForPurchReqLineFlight::instance().isEnabled())
            {
                if (!purchReqLineValidate)
                {
                    purchReqLineValidate.setTmp();
                    buf2Buf(_purchReqLine, purchReqLineValidate);
                    purchReqLineValidate.setPriceDisc(purchReqLineValidate.inventDim());
                    purchReqLineValidate.doInsert();
                }
                else
                {
                    purchReqLineValidate.reread();
                }
            }
            else
            {
                buf2Buf(_purchReqLine, purchReqLineValidate);
                purchReqLineValidate.setPriceDisc(purchReqLineValidate.inventDim());
            }

            purchReqLineValidate.initFromAgreementLine(_aLine);
            
            // Calculate line amount to be used in limits check
            purchReqLineValidate.calcLineAmount();

            if (_aLine.validateRelease(purchReqLineValidate))
            {
                if (_aLine.ItemId)
                {
                    resultList.addEnd(_aLine);
                }
                else if (resultList.empty()) //do not add the category agreement lines if item agreement lines are already found
                {
                    if (_aLine.Category != rootCategory)
                    {
                        categoryList.addEnd(_aLine);
                    }
                    else if (categoryList.empty()) //do not add the root category agreement lines if category agreement lines are already found
                    {
                        rootCategoryList.addEnd(_aLine);
                    }
                }
            }
        }

        using (var activityContext = AgreementInstrumentationLogger::createLogger(tableStr(AgreementLine)).useSelect().getAgreementLinesForPurchReqLine(_purchReqLine.TableId))
        {
            salesPurchAgreementHeader = purchAgreementHeader;
            custVendAccount           = _purchReqLine.VendAccount;
            custVendAccountFieldId    = fieldNum(PurchAgreementHeader, VendAccount);

            rootCategory = EcoResCategory::getRoot(EcoResCategoryHierarchyRole::getHierarchiesByRole(EcoResCategoryNamedHierarchyRole::Procurement).CategoryHierarchy).RecId;

            InventDimParm inventDimParmAllowBlank = InventDimParm::allProductDim();
            inventDimParmAllowBlank.InventSiteIdFlag = NoYes::Yes;
            inventDimParmAllowBlank.InventLocationIdFlag = NoYes::Yes;

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && _purchReqLine.LineType == PurchReqLineType::Category)
            {
                while Select RecId from ecoResCategory order by ecoResCategory.Level desc
                    join agreementLineQuantity where
                        ( ecoResCategory.RecId == agreementLineQuantity.Category
                        && agreementLineQuantity.RecId               == _purchReqLine.PurchAgreement || !_purchReqLine.PurchAgreement)
                        && agreementLineQuantity.IsDeleted           == NoYes::No
                        && agreementLineQuantity.ExpirationDate      >= _purchReqLine.RequiredDate
                        && agreementLineQuantity.EffectiveDate       <= _purchReqLine.RequiredDate
                        && agreementLineQuantity.InventDimDataAreaId == companyId
                        &&  (_purchReqLine.LineType == PurchReqLineType::Category &&
                            (agreementLineQuantity.Category == _purchReqLine.ProcurementCategory || agreementLineQuantity.Category == rootCategory)
                            )
                        && (agreementLineQuantity.ProjectProjId == _purchReqLine.ProjId || agreementLineQuantity.ProjectProjId == '')
                    exists join ParentCategory, RecId from ecoResCategoryChildren
                        where ecoResCategoryChildren.CategoryHierarchy == ecoResCategory.CategoryHierarchy
                            && ecoResCategoryChildren.NestedSetLeft >= ecoResCategory.NestedSetLeft
                            && ecoResCategoryChildren.NestedSetRight <= ecoResCategory.NestedSetRight
                            && (ecoResCategory.RecId == _purchReqLine.ProcurementCategory || ecoResCategoryChildren.RecId == _purchReqLine.ProcurementCategory)
                    #inventDimExistsJoinAllowBlank(agreementLineQuantity.InventDimId, inventDim, purchReqLineInventDim, inventDimParmAllowBlank, inventDimParmAllowBlank)
                exists join agreementHeader
                        where agreementHeader.RecId == agreementLineQuantity.Agreement
                            && agreementHeader.IsDeleted == NoYes::No
                            && agreementHeader.AgreementState == AgreementState::Effective
                    exists join salesPurchAgreementHeader
                        where salesPurchAgreementHeader.RecId == agreementLineQuantity.Agreement
                            && (!_purchReqLine.VendAccount  || (salesPurchAgreementHeader.(custVendAccountFieldId) == custVendAccount))
                {
                    addToList(agreementLineQuantity);
                }
            }
            else
            {
                while select agreementLineQuantity where
                      (  agreementLineQuantity.RecId               == _purchReqLine.PurchAgreement || !_purchReqLine.PurchAgreement)
                      && agreementLineQuantity.IsDeleted           == NoYes::No
                      && agreementLineQuantity.ExpirationDate      >= _purchReqLine.RequiredDate
                      && agreementLineQuantity.EffectiveDate       <= _purchReqLine.RequiredDate
                      && agreementLineQuantity.InventDimDataAreaId == appl.company().dataArea(tableNum(InventDim))
                      &&  (
                           (
                               _purchReqLine.LineType == PurchReqLineType::Item
                               && agreementLineQuantity.ItemId         == _purchReqLine.ItemId
                               && agreementLineQuantity.ItemDataAreaId == appl.company().dataArea(tableNum(InventTable))
                           )
                           ||
                           (_purchReqLine.LineType == PurchReqLineType::Category &&
                            (agreementLineQuantity.Category == _purchReqLine.ProcurementCategory || agreementLineQuantity.Category == rootCategory)
                           )
                          )
                      && (agreementLineQuantity.ProjectProjId      == _purchReqLine.ProjId || agreementLineQuantity.ProjectProjId == '')
                    #inventDimExistsJoinAllowBlank(agreementLineQuantity.InventDimId, inventDim, purchReqLineInventDim, inventDimParmAllowBlank, inventDimParmAllowBlank)
                exists join agreementHeader
                   where agreementHeader.RecId == agreementLineQuantity.Agreement
                      && agreementHeader.IsDeleted == NoYes::No
                      && agreementHeader.AgreementState == AgreementState::Effective
                  exists join salesPurchAgreementHeader
                   where salesPurchAgreementHeader.RecId == agreementLineQuantity.Agreement
                      && (!_purchReqLine.VendAccount  || (salesPurchAgreementHeader.(custVendAccountFieldId) == custVendAccount))
                {
                    addToList(agreementLineQuantity);
                }
            }

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && _purchReqLine.LineType == PurchReqLineType::Category)
            {
                while select RecId from ecoResCategory order by ecoResCategory.Level desc
                    join agreementLineVolume
                        where ecoResCategory.RecId == agreementLineVolume.Category
                            && agreementLineVolume.IsDeleted == NoYes::No
                            && agreementLineVolume.InventDimDataAreaId == companyId
                            && agreementLineVolume.ExpirationDate >= (_purchReqLine.RequiredDate)
                            && agreementLineVolume.EffectiveDate  <= (_purchReqLine.RequiredDate)
                            && (agreementLineVolume.ProjectProjId  == _purchReqLine.ProjId || agreementLineVolume.ProjectProjId == '')
                            && _purchReqLine.TableId == tableNum(PurchReqLine)
                    exists join ParentCategory, RecId from ecoResCategoryChildren
                        where ecoResCategoryChildren.CategoryHierarchy == ecoResCategory.CategoryHierarchy
                            && ecoResCategoryChildren.NestedSetLeft  >= ecoResCategory.NestedSetLeft
                            && ecoResCategoryChildren.NestedSetRight <= ecoResCategory.NestedSetRight
                            && (ecoResCategory.RecId == _purchReqLine.ProcurementCategory || ecoResCategoryChildren.RecId == _purchReqLine.ProcurementCategory)
                    #inventDimExistsJoinAllowBlank(agreementLineVolume.InventDimId, inventDim, purchReqLineInventDim, inventDimParmAllowBlank, inventDimParmAllowBlank)
                exists join agreementHeader
                        where agreementHeader.RecId == agreementLineVolume.Agreement
                            && agreementHeader.IsDeleted == NoYes::No
                            && agreementHeader.AgreementState == AgreementState::Effective
                            exists join agreementClassification
                                where agreementHeader.AgreementClassification == agreementClassification.RecId
                                    && agreementClassification.DirectInvoiceEnable_PSN != 1
                    exists join salesPurchAgreementHeader
                        where salesPurchAgreementHeader.RecId == agreementLineVolume.Agreement
                            && (!_purchReqLine.VendAccount  || (salesPurchAgreementHeader.(custVendAccountFieldId) == custVendAccount))
                {
                    addToList(agreementLineVolume);
                }
            }
            else
            {
                while select agreementLineVolume where
                      (  agreementLineVolume.RecId           == _purchReqLine.PurchAgreement || !_purchReqLine.PurchAgreement)
                      && agreementLineVolume.IsDeleted           == NoYes::No
                      && agreementLineVolume.ExpirationDate      >= _purchReqLine.RequiredDate
                      && agreementLineVolume.EffectiveDate       <= _purchReqLine.RequiredDate
                      && agreementLineVolume.InventDimDataAreaId == appl.company().dataArea(tableNum(InventDim))
                      &&  (
                           (
                               _purchReqLine.LineType == PurchReqLineType::Item
                               && agreementLineVolume.ItemId         == _purchReqLine.ItemId
                               && agreementLineVolume.ItemDataAreaId == appl.company().dataArea(tableNum(InventTable))
                           )
                           ||
                           (_purchReqLine.LineType == PurchReqLineType::Category &&
                            (agreementLineVolume.Category == _purchReqLine.ProcurementCategory || agreementLineVolume.Category == rootCategory)
                           )
                          )
                      && (agreementLineVolume.ProjectProjId     == _purchReqLine.ProjId || agreementLineVolume.ProjectProjId == '')
                    #inventDimExistsJoinAllowBlank(agreementLineVolume.InventDimId, inventDim, purchReqLineInventDim, inventDimParmAllowBlank, inventDimParmAllowBlank)
                exists join agreementHeader
                   where agreementHeader.RecId == agreementLineVolume.Agreement
                      && agreementHeader.IsDeleted == NoYes::No
                      && agreementHeader.AgreementState == AgreementState::Effective
                  exists join salesPurchAgreementHeader
                   where salesPurchAgreementHeader.RecId == agreementLineVolume.Agreement
                      && (!_purchReqLine.VendAccount || (salesPurchAgreementHeader.(custVendAccountFieldId) == custVendAccount))
                {
                    addToList(agreementLineVolume);
                }
            }

            if (!resultList.empty())
            {
                return resultList;
            }

            if (!categoryList.empty())
            {
                return categoryList;
            }

            return rootCategoryList;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAgreementLinesForVendInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the list of the agreement lines that match to the vendor invoice line.
    /// </summary>
    /// <param name="_vendInvoiceInfoLine">
    /// The vendor invoice line for which to find the agreement lines.
    /// </param>
    /// <returns>
    /// The list of the found agreement lines.
    /// </returns>
    public static List getAgreementLinesForVendInvoiceLine(VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable = _vendInvoiceInfoLine.vendInvoiceInfoTable();

        return AgreementLine::getAgreementLinesList(vendInvoiceInfoTable.PurchAgreementHeader_PSN, _vendInvoiceInfoLine, vendInvoiceInfoTable.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAgreementLinesList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the list of the agreement lines that match to the vendor invoice line or purchase line.
    /// </summary>
    /// <param name="_matchingAgreement">
    /// The record ID of the agreement header.
    /// </param>
    /// <param name="_salesPurchLine">
    /// The sales or purchase line for which to find the agreement lines.
    /// </param>
    /// <param name="_deliveryDate">
    /// The transaction or delivery date used to verify the availability of agreement line.
    /// </param>
    /// <returns>
    /// The list of the found agreement lines packed into the list.
    /// </returns>
    private static List getAgreementLinesList(AgreementHeaderRecId _matchingAgreement, SalesPurchLine _salesPurchLine, PurchLineDlvDate _deliveryDate)
    {
        using (var activityContext = AgreementInstrumentationLogger::createLogger(tableStr(AgreementLine)).useSelect().getAgreementLinesList(_salesPurchLine.TableId, _matchingAgreement != 0))
        {
            SalesPurchLineInterface salesPurchLineInterface = _salesPurchLine.salesPurchLineInterface();
            EcoResCategory          ecoResCategory, ecoResCategoryChildren;
            AgreementLine           agreementLine;
            PurchAgreementHeader    purchAgreementHeader;
            List                    resultList = new List(Types::Record);
            DataAreaId              companyId  = appl.company().dataArea(tablenum(InventDim));

            while select RecId from ecoResCategory order by ecoResCategory.Level
                join Category from agreementLine
                    where ecoResCategory.RecId == agreementLine.Category
                        && agreementLine.Agreement == _matchingAgreement
                        && agreementLine.IsDeleted == NoYes::No
                        && agreementLine.InventDimDataAreaId == companyId
                        && agreementLine.ExpirationDate >= (_deliveryDate ? _deliveryDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
                        && agreementLine.EffectiveDate  <= (_deliveryDate ? _deliveryDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
                        && (_salesPurchLine.TableId == tableNum(PurchLine) ||
                            _salesPurchLine.TableId == tableNum(VendInvoiceInfoLine))
                exists join ParentCategory, RecId from ecoResCategoryChildren
                    where ecoResCategoryChildren.CategoryHierarchy == ecoResCategory.CategoryHierarchy
                        && ecoResCategoryChildren.NestedSetLeft  >= ecoResCategory.NestedSetLeft
                        && ecoResCategoryChildren.NestedSetRight <= ecoResCategory.NestedSetRight
                        && (ecoResCategory.RecId == salesPurchLineInterface.parmCategoryId() || ecoResCategoryChildren.RecId == salesPurchLineInterface.parmCategoryId())
                exists join purchAgreementHeader
                    where purchAgreementHeader.RecId == agreementLine.Agreement
                        && purchAgreementHeader.IsDeleted == NoYes::No
                        && purchAgreementHeader.AgreementState == AgreementState::Effective
                        && purchAgreementHeader.Currency == salesPurchLineInterface.parmCurrencyCode()
            {
                resultList.addEnd(agreementLine);
            }

            return resultList;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimFieldList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a list of field IDs that match the set fields in the table buffer of the <c>InventDim</c>
    ///    with the <c>AgreementDimensionsPrioritized</c> field group.
    /// </summary>
    /// <param name="_inventDim">
    ///    A buffer of the <c>InventDim</c> table.
    /// </param>
    /// <returns>
    ///    A list of field IDs.
    /// </returns>
    public static List getDimFieldList(InventDim _inventDim)
    {
        List            fieldGroup = InventDim::dimAgreementFieldList();
        ListEnumerator  enumerator  = fieldGroup.getEnumerator();
        fieldId         dimFieldId;
        List            inventDimFieldList = new List(Types::Integer);

        while (enumerator.moveNext())
        {
            dimFieldId = enumerator.current();
            if (_inventDim.(dimFieldId))
            {
                inventDimFieldList.addEnd(dimFieldId);
            }
        }
        return inventDimFieldList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the last line number that is used for the current agreement.
    /// </summary>
    /// <param name="_agreementHeaderRecId">
    ///    The record ID of agreement header.
    /// </param>
    /// <returns>
    ///    The maximum line number.
    /// </returns>
    static public LineNum  lastLineNum(AgreementHeaderRecId  _agreementHeaderRecId)
    {
        return (select maxof(LineNumber) from agreementLine
                    where agreementLine.Agreement == _agreementHeaderRecId).LineNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCanDeleteAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the release existence value in a result container that is returned by the
    /// <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    /// The position of the release existence value in a result container that is returned by the
    /// <c>relatedObjectExistanceFlags</c> method.
    /// </returns>
    /// <remarks>
    /// This method is used by the <c>relatedObjectExistanceFlags</c> method and its consumers.
    /// </remarks>
    static int posCanDeleteAgreementLine()
    {
        return 3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posInvoicesExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns position of invoice existence flag in a result container returned by
    /// <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    /// The position of invoice existence flag in a result container returned by
    /// <c>relatedObjectExistanceFlags</c> method.
    /// </returns>
    /// <remarks>
    /// Used by <c>relatedObjectExistanceFlags</c> method and its consumers.
    /// </remarks>
    static int posInvoicesExist()
    {
        return 2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posReleasesExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the release existence value in a result container that is returned by the
    /// <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    /// The value of the release existence value in a result container that is returned by the
    /// <c>relatedObjectExistanceFlags</c> method.
    /// </returns>
    /// <remarks>
    /// This method is used by the <c>relatedObjectExistanceFlags</c> method and its consumers.
    /// </remarks>
    static int posReleasesExist()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTableIdFromCommitmentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the ID of the table in the <c>AgreementLine</c> table hierarchy
    /// that corresponds to the specified commitment type.
    /// </summary>
    /// <param name = "_commitmentType">The commitment type.</param>
    /// <returns>The ID of the table.</returns>
    public static TableId getTableIdFromCommitmentType(CommitmentType _commitmentType)
    {
        if (_commitmentType == CommitmentType::ProductQuantity)
        {
            return tableNum(AgreementLineQuantityCommitment);
        }

        return tableNum(AgreementLineVolumeCommitment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditItemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether item number can be edited.
    /// </summary>
    /// <returns>
    ///    true if item number can be edited; otherwise, false.
    /// </returns>
    public boolean canEditItemId()
    {
        return !this.RecId && this.AgreementLineType == CommitmentType::ProductVolume || this.AgreementLineType == CommitmentType::ProductQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditCategory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether category can be edited.
    /// </summary>
    /// <returns>
    ///    true if category can be edited; otherwise, false.
    /// </returns>
    public boolean canEditCategory()
    {
        // For CommitmentType::ProductRootCategory we do not allow edit of Category field:
        // it will be defaulted during values initialization to the root category and should not be changed by user.

        return !this.RecId && this.AgreementLineType == CommitmentType::ProductCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtension</Name>
				<Source><![CDATA[
    public TableExtension getExtension()
    {
        return new SysTableExtension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultingDependencies</Name>
				<Source><![CDATA[
    public container getDefaultingDependencies()
    {
        return [
            // [field that needs defaulting,
            //  [fields that the default value depends on]]
            [fieldNum(AgreementLine, InventDimDataAreaId),
                [fieldNum(AgreementLine, InventDimId)]],

            [fieldNum(AgreementLine, ItemDataAreaId),
                [fieldNum(AgreementLine, ItemId)]],

            [fieldNum(AgreementLine, ProjectDataAreaId),
                [fieldNum(AgreementLine, ProjectProjId)]],

            [fieldNum(AgreementLine, Category),
                [fieldNum(AgreementLine, AgreementLineType)]]
        ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    public void defaultField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(AgreementLine, InventDimDataAreaId):
                this.InventDimDataAreaId = this.InventDimId && !this.InventDimDataAreaId ? curExt() : this.InventDimDataAreaId;
                break;

            case fieldNum(AgreementLine, ItemDataAreaId):
                this.ItemDataAreaId = this.ItemId && !this.ItemDataAreaId ? curExt() : this.ItemDataAreaId;
                break;

            case fieldNum(AgreementLine, ProjectDataAreaId):
                this.ProjectDataAreaId = this.ProjectProjId && !this.ProjectDataAreaId ? curExt() : this.ProjectDataAreaId;
                break;

            case fieldNum(AgreementLine, Category):
                if (!this.Category && this.isFieldSet(fieldNum(AgreementLine, AgreementLineType)))
                {
                    this.initCategoryFromAgreementLineType();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>editabilityDataProvider</Name>
				<Source><![CDATA[
    public AgreementLineFieldEditabilityDataProvider editabilityDataProvider()
    {
        return AgreementLineFieldEditabilityDataProvider::newFromAgreementLine(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a table buffer of the <c>ProjTable</c> based on the parameters.
    /// </summary>
    /// <param name = "projId">A project id.</param>
    /// <param name = "update">A Boolean value that determines whether the record should be selected for update.</param>
    /// <returns>A <c>ProjTable</c> record.</returns>
    ProjTable projTable(
        ProjId     projId = this.ProjectProjId,
        boolean    update = false)
    {
        return ProjTable::find(projId, update);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markCurrentTaxDocumentTaxStatusDirty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark current tax status of <c> SalesQuotationTable </c> to dirty
    /// </summary>
    private void markCurrentTaxDocumentTaxStatusDirty()
    {
        // <GTE>
        TaxableDocumentDescriptor   descriptor;
        ITaxableDocument            taxableDocument;

        if (this.salesAgreementHeader())
        {
            descriptor= TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(this.salesAgreementHeader());
        }
        else
        {
            descriptor= TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(this.purchAgreementHeader());
        }

        taxableDocument = TaxableDocumentObject::construct(descriptor);
        TaxBusinessService::markTaxDocumentTaxStatus(taxableDocument, TaxDocumentCalculationLevel::Dirty);
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxRecalculationNeeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a change to the <c>AgreementLine</c> table will update the Tax
    /// </summary>
    /// <param name="_origTransactionTable">
    /// The <c>Transaction table</c> record, optional.
    /// </param>
    /// <returns>True if current line tax should be recalculated, otherwise false </returns>
    public boolean taxRecalculationNeeded(Common _origTransactionTable = this.orig())
    {
        // <GTE>
        boolean         updateNeeded;
        AgreementLine   agreementLine_Orig = _origTransactionTable ? _origTransactionTable : this.orig();

        updateNeeded =
            (
            (this.Currency                      != agreementLine_Orig.Currency) ||
            (this.InventDimId                   != agreementLine_Orig.InventDimId)  ||
            (this.ItemId                        != agreementLine_Orig.ItemId)||
            (this.EffectiveDate                 != agreementLine_Orig.EffectiveDate) ||
            (this.ExpirationDate                != agreementLine_Orig.ExpirationDate) ||
            (this.LineDiscountPercent           != agreementLine_Orig.LineDiscountPercent)||
            (this.LineNumber                    != agreementLine_Orig.LineNumber)||
            (this.AgreedReleaseLineMaxAmount    != agreementLine_Orig.AgreedReleaseLineMaxAmount)||
            (this.AgreedReleaseLineMinAmount    != agreementLine_Orig.AgreedReleaseLineMinAmount)||
            (this.AgreementLineType             != agreementLine_Orig.AgreementLineType)||
            (this.AgreementLineProduct          != agreementLine_Orig.AgreementLineProduct)||
            (this.ProjectProjId                 != agreementLine_Orig.ProjectProjId) ||
            !DimensionDefaultFacade::areEqual(this.DefaultDimension, agreementLine_Orig.DefaultDimension)
            );

        return updateNeeded;
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAgreementLineIsDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the agreement line is deleted.
    /// </summary>
    /// <param name = "_itemId">
    /// The value of item id.
    /// </param>
    /// <param name = "_dataAreaId">
    /// The value of data area id.
    /// </param>
    /// <returns>
    /// True if the agreement line is deleted; otherwise, false.
    /// </returns>
    public static boolean validateAgreementLineIsDeleted(ItemId _itemId, DataAreaId _dataAreaId)
    {
        AgreementLine agreementLine;
        boolean ret = true;
    
        select firstonly RecId from agreementLine
            index hint InventTableIdx
                    where agreementLine.ItemId == _itemId
                    && agreementLine.ItemDataAreaId == _dataAreaId
                    && agreementLine.IsDeleted == NoYes::No;
    
        if (agreementLine)
        {
            ret = checkFailed(strFmt("@SYS128564","@SYS50258","@SYS184156"));
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNetAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the net-amount value for the agreement results in a negative fulfillment-remaining value or not
    /// </summary>
    /// <returns>
    /// True if the amount does not result in a negative fulfillment-remaining value; otherwise, false.
    /// </returns>
    public boolean validateNetAmount()
    {
        boolean ret = true;

        if (!this.isQuantityBased())
        {
            ret = this.validateField(fieldNum(AgreementLineVolumeCommitment, CommitedAmount));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPurchLineInterface</Name>
				<Source><![CDATA[
    public SalesPurchLineInterface salesPurchLineInterface()
    {
        return this.SalesPurchLine::salesPurchLineInterface();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>TradeBlanketOrder</ConfigurationKey>
	<DeveloperDocumentation>@SYS318715</DeveloperDocumentation>
	<Label>@SYS184156</Label>
	<TableGroup>WorksheetLine</TableGroup>
	<TitleField1>ItemId</TitleField1>
	<TitleField2>Category</TitleField2>
	<Abstract>Yes</Abstract>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<InstanceRelationType>InstanceRelationType</InstanceRelationType>
	<Modules>ProcurementAndSourcing</Modules>
	<ReplacementKey>AgreementHeaderIdx</ReplacementKey>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<SupportInheritance>Yes</SupportInheritance>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AgreementLineType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Category</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Agreement</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Category</Name>
			<Label>@SYS69410</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Category</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimension</Name>
			<Label>@SYS342338</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Discount</Name>
			<Label>@SYS11829</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LineDiscountPercent</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Item</Name>
			<Label>@SYS14428</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Line</Name>
			<Label>@SYS70473</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LineNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AgreementLineType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AgreementLineProduct</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>LineNumber</Name>
			<Label>@SYS40505</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LineNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Price</Name>
			<Label>@SYS11865</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IsPriceInformationMandatory</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Project</Name>
			<Label>@SYS80304</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjectProjId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Quantity</Name>
			<Label>@SYS59970</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IsMaxEnforced</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReleaseLimit</Name>
			<Label>@SYS302524</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AgreedReleaseLineMinAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AgreedReleaseLineMaxAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ValidityPeriod</Name>
			<Label>@SYS95282</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>EffectiveDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpirationDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AgreedReleaseLineMaxAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementMaximumReleaseAmount</ExtendedDataType>
			<RelationContext>Currency</RelationContext>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AgreedReleaseLineMinAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementMinimumReleaseAmount</ExtendedDataType>
			<RelationContext>Currency</RelationContext>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Agreement</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementHeaderRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AgreementLineProduct</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>AgreementLineProduct</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AgreementLineType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CommitmentType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Category</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS135189</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDefaultDimensionValueSet</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>EffectiveDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EffectiveDate</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ExpirationDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExpirationDate</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InstanceRelationType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RelationType</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InterCompanySkipUpdate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
			<EnumType>InterCompanySkipUpdate</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IntraCompanySkipUpdate_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
			<EnumType>InterCompanySkipUpdate</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimDataAreaId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>DataAreaId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsDeleted</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsMaxEnforced</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>IsMaxEnforced</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsModified</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsPriceInformationMandatory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>IsPriceInfoMandatory</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemDataAreaId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>DataAreaId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LineDiscountPercent</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementDiscPercent</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LineNumber</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementLineNum_PSN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjectDataAreaId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>DataAreaId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjectProjId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Currency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PublicSector</ConfigurationKey>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ShipCalendarId</Name>
			<AssetClassification>Customer content</AssetClassification>
			<ExtendedDataType>PurchVendorShipCalendarId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CLMIntegrationExternalContractLineId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CLMIntegration</ConfigurationKey>
			<ExtendedDataType>CLMIntegrationExternalContractLineId</ExtendedDataType>
			<FeatureClass>CLMIntegrationFeature</FeatureClass>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsIntegration</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
			<EnumType>PurchAgreementIntegrationType</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>EcoResCategoryIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Category</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventTableIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemDataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventDimIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimDataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>AgreementHeaderIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>Agreement</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNumber</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ProjTableIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjectProjId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ProjectDataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>AgreementLineInventDimIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Agreement</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>IsDeleted</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ExpirationDate</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>EffectiveDate</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemDataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimDataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Category</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CLMIntegrationExternalContractLineIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CLMIntegrationExternalContractLineId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>AgreementLineMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>AgreedReleaseLineMaxAmount</MapField>
					<MapFieldTo>AgreedReleaseLineMaxAmount</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>AgreedReleaseLineMinAmount</MapField>
					<MapFieldTo>AgreedReleaseLineMinAmount</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>AgreementLineProduct</MapField>
					<MapFieldTo>AgreementLineProduct</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>AgreementLineType</MapField>
					<MapFieldTo>AgreementLineType</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Category</MapField>
					<MapFieldTo>Category</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EffectiveDate</MapField>
					<MapFieldTo>EffectiveDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExpirationDate</MapField>
					<MapFieldTo>ExpirationDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventDimDataAreaId</MapField>
					<MapFieldTo>InventDimDataAreaId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventDimId</MapField>
					<MapFieldTo>InventDimId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>IsMaxEnforced</MapField>
					<MapFieldTo>IsMaxEnforced</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>IsPriceInformationMandatory</MapField>
					<MapFieldTo>IsPriceInformationMandatory</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemDataAreaId</MapField>
					<MapFieldTo>ItemDataAreaId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemId</MapField>
					<MapFieldTo>ItemId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineDiscountPercent</MapField>
					<MapFieldTo>LineDiscountPercent</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineNumber</MapField>
					<MapFieldTo>LineNumber</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ProjectDataAreaId</MapField>
					<MapFieldTo>ProjectDataAreaId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ProjectProjId</MapField>
					<MapFieldTo>ProjectProjId</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>DimensionDefaultMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>DefaultDimension</MapField>
					<MapFieldTo>DefaultDimension</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalLine</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>CategoryId</MapField>
					<MapFieldTo>Category</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
					<MapFieldTo>Currency</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryLocation</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryState</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventDimId</MapField>
					<MapFieldTo>InventDimId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventTransId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemId</MapField>
					<MapFieldTo>ItemId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineNum</MapField>
					<MapFieldTo>LineNumber</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchQty</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchUnit</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>TableId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxItemGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TransDate</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SalesPurchLine</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>Category</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ConfirmedDlv</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DefaultDimension</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryType</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExternalItemId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventDimId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventTransId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemBOMId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemRouteId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineDeliveryType</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineDisc</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineNum</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LinePercent</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Markup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>MCRCustVendAC</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>MCROrderLine2PriceHistoryRef</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>MCRReceiptDate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>MCRShipDate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>OrderAccount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PDSCalculationId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PdsCWSalesPurchQty</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Price</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PriceUnit</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PurchSalesUnit</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>QtyOrdered</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>RequiredDate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>RetailVariantId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchQty</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceDocumentLine</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>StockedProduct</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SystemEntrySource</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxItemGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>UnitOfMeasure</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AgreementHeader</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>AgreementHeader</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>AgreementHeader_1</RelatedTableRole>
			<RelationshipType>Composition</RelationshipType>
			<Role>AgreementHeader_1_AgreementLine</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Agreement</Name>
					<Field>Agreement</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Category</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>EcoResCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>EcoResCategory</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>EcoResCategory_AgreementLine</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Category</Name>
					<Field>Category</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DimensionAttributeValueSet</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DimensionAttributeValueSet_AgreementLine</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>InventDim_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>InventDim_1_AgreementLine</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimId</Name>
					<Field>InventDimId</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimDataAreaId</Name>
					<Field>InventDimDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventTable_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>InventTable_1_AgreementLine</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<SourceEDT>ItemId</SourceEDT>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemDataAreaId</Name>
					<Field>ItemDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ItemIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjTable_AgreementLine</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjectDataAreaId</Name>
					<Field>ProjectDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjectProjId</Name>
					<SourceEDT>ProjId</SourceEDT>
					<Field>ProjectProjId</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ProjectIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>Currency</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>Currency_AgreementLine</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Currency</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>Currency</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>