<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MCRTmpPickingWorkbenchTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class MCRTmpPickingWorkbenchTrans extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>formatString</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Removes returns and spaces from the string.
    /// </summary>
    /// <param name="_formatString">
    /// The string that should be formatted.
    /// </param>
    /// <returns>
    /// The formatted string.
    /// </returns>
    str formatString(str _formatString)
    {
        str result = _formatString;
        // The following numbers are ascii numbers 10 = new line feed, // 13 = carriage return, 32 = space
        result = strReplace(result, num2char(13), num2char(32));
        result = strReplace(result, num2char(10), num2char(32));

        if (result == "")
        {
            result = "..";
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMcrCustPayTotalsForSalesId</Name>
				<Source><![CDATA[
    private MCRCustPaymTotals getMcrCustPayTotalsForSalesId(SalesId _salesId, Map _salesId2McrCustPaymTotals)
    {
        MCRCustPaymTotals mcrCustPaymTotals;

        if (_salesId2McrCustPaymTotals.exists(_salesId))
        {
            mcrCustPaymTotals = _salesId2McrCustPaymTotals.lookup(_salesId);
        }
        else
        {
            mcrCustPaymTotals = MCRCustPaymTotals::construct(tableNum(SalesTable), SalesTable::find(_salesId).RecId);
            _salesId2McrCustPaymTotals.insert(_salesId, mcrCustPaymTotals);
        }

        return mcrCustPaymTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromContinuityItemPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the picking workbench transaction using the continuity item prompt as a driver.
    /// </summary>
    /// <param name="_sessionId">
    /// The session ID of the picking session to use to create the picking workbench transactions.
    /// </param>
    /// <param name="_formatString">
    /// The query string to use to find the picking lines.
    /// </param>
    /// <param name="_displayWarnings">
    /// Indicates whether to display warnings if they occur.
    /// </param>
    /// <remarks>
    /// The continuity item is on a parent
    ///     sales order, so the method needs to get the child orders associated with those parent orders.
    /// </remarks>
    void initFromContinuityItemPrompt(MCRPickingSession _sessionId,
                                      str               _formatString,
                                      boolean           _displayWarnings = false)
    {
        Query                       query;
        QueryRun                    queryRun;
        QueryBuildDataSource        qbdSalesLine;
        QueryBuildDataSource        qbdInventTrans;
        QueryBuildDataSource        qbdInventTransOrigin;
        QueryBuildDataSource        qbdContCustLine;
        QueryBuildDataSource        qbdInventTable;
        QueryBuildDataSource        queryBuildDataSourceMCRSalesLineDropShipment;
        QueryBuildDataSource        queryBuildDataSourceMCRSalesLine;
        QueryBuildLink              qlQueryLink;
        QueryBuildLink              qlQueryLinkCustLine;
        SalesLine                   salesLine;
        InventTable                 inventTable;
        MCRPickingWorkbenchSession  pickingSession;
        boolean                     lineOnOrderPosted = false;
        SalesId                     prevSalesID = '';
        int                         orderCount;
        int                         orderLineProcessed;
        Map                         salesId2McrCustPaymTotals = new Map(Types::String, Types::Class);
        MCRCustPaymTotals           currentMcrCustPaymTotals;

        // make sure temp table is empty
        delete_from this;

        // Read the picking Session
        pickingSession = MCRPickingWorkbenchSession::find(_sessionId);

        // Using InventTrans as the driver since we really need the child orders of the parent.
        // InventTrans has the item ID on it, so it can be used with selection criteria.
        query = new Query();
        qbdInventTrans = query.addDataSource(tableNum(InventTrans));

        // use value returned from prompt as value for query
        qbdInventTrans.addRange(fieldNum(InventTrans, ItemId)).value(_formatString);

        // Add the Continuity Cust Line to the query to pick up child orders.
        qbdInventTransOrigin = qbdInventTrans.addDataSource(tableNum(InventTransOrigin));
        qbdInventTransOrigin.joinMode(JoinMode::InnerJoin);
        qlQueryLink = qbdInventTransOrigin.addLink(fieldNum(InventTrans, InventTransOrigin), fieldNum(InventTransOrigin, RecId));
        qbdContCustLine = qbdInventTransOrigin.addDataSource(tableNum(MCRContinuityCustLine));
        qbdContCustLine.joinMode(JoinMode::InnerJoin);
        qlQueryLink = qbdContCustLine.addLink(fieldNum(InventTransOrigin, InventTransId), fieldNum(MCRContinuityCustLine, InventTransId));

        // Only include open lines
        qbdSalesLine = qbdContCustLine.addDataSource(tableNum(SalesLine));
        qbdSalesLine.joinMode(JoinMode::InnerJoin);
        qlQueryLinkCustLine = qbdSalesLine.addLink(fieldNum(MCRContinuityCustLine, InventTransIDChild), fieldNum(SalesLine, InventTransId));
        qbdSalesLine.addRange(fieldNum(SalesLine, SalesStatus)).value(queryValue(SalesStatus::Backorder));
        qbdSalesLine.addRange(fieldNum(SalesLine, LineDeliveryType)).value('!' + queryValue(LineDeliveryType::OrderLineWithMultipleDeliveries));

        queryBuildDataSourceMCRSalesLineDropShipment = qbdSalesLine.addDataSource(tableNum(MCRSalesLineDropShipment));
        queryBuildDataSourceMCRSalesLineDropShipment.relations(true);
        queryBuildDataSourceMCRSalesLineDropShipment.joinMode(JoinMode::NoExistsJoin);
        queryBuildDataSourceMCRSalesLineDropShipment.addRange(fieldNum(MCRSalesLineDropShipment, DropShipment)).value(queryValue(NoYes::yes));

        // Skip continuity items.
        queryBuildDataSourceMCRSalesLine = qbdSalesLine.addDataSource(tableNum(MCRSalesLine));
        queryBuildDataSourceMCRSalesLine.joinMode(JoinMode::NoExistsJoin);
        queryBuildDataSourceMCRSalesLine.relations(true);
        queryBuildDataSourceMCRSalesLine.addRange(fieldNum(MCRSalesLine, ContinuityScheduleId)).value(SysQuery::valueNotEmptyString());

        // Join inventory table.
        qbdInventTable = qbdSalesLine.addDataSource(tableNum(InventTable));
        qbdInventTable.addLink(fieldNum(SalesLine, ItemId), fieldNum(InventTable, ItemId));
        qbdSalesLine.addSortField(fieldNum(SalesLine, CreatedDateTime));

        // Process the sales lines to be picked.
        queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            salesLine = queryRun.get(tableNum(SalesLine));
            inventTable = queryRun.get(tableNum(InventTable));

            // need to keep track of how many total sales orders found in case there was a limit
            // set by session profile.  Flag is set when a line from a salesorder is inserted into
            // temp table.
            if (prevSalesID != salesLine.SalesId)
            {
                prevSalesID = salesLine.SalesId;
                if (lineOnOrderPosted)
                {
                    lineOnOrderPosted = false;
                    orderCount++;
                    // If at the max order count, exit.
                    if ((pickingSession.MaxOrders != 0)
                        && (orderCount >= pickingSession.MaxOrders))
                    {
                        break;
                    }
                }

                currentMcrCustPaymTotals = this.getMcrCustPayTotalsForSalesId(salesLine.SalesId, salesId2McrCustPaymTotals);
            }

            // Insert the line into the temp table.  Not passing warehouse, since not used
            // when selecting by continuity item.
            if (this.insertTransAndReserve("", salesLine, inventTable, _displayWarnings, currentMcrCustPaymTotals))
            {
                lineOnOrderPosted = true;
                orderLineProcessed ++;

                // If max lines specified, check to see if we have gotten to the max.
                if ((pickingSession.MaxLinesPerOrder != 0)
                    && (orderLineProcessed >= pickingSession.MaxLinesPerOrder))
                {
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromItemPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates picking workbench transaction records by prompting for a list of item IDs.
    /// </summary>
    /// <param name="_sessionId">
    /// The session ID of the picking session to use to create the picking workbench transactions.
    /// </param>
    /// <param name="_formatString">
    /// The list of item ID's used to create the picking workbench transaction records.
    /// </param>
    /// <param name="_displayWarnings">
    /// Indicates whether to display warnings if they occur.
    /// </param>
    /// <remarks>
    /// Value of prompt can either be a comma separated list
    ///     or a single range.  Or any value valid for a query build range.
    /// </remarks>
    void initFromItemPrompt(MCRPickingSession _sessionId,
                           str                _formatString,
                           boolean            _displayWarnings = false)
    {
        Query                       query;
        QueryRun                    queryRange;
        QueryBuildDataSource        qbdSalesLine;
        QueryBuildDataSource        qbdInventTable;
        QueryBuildDataSource        queryBuildDataSourceMCRSalesLineDropShipment;
        QueryBuildDataSource        queryBuildDataSourceMCRSalesLine;
        SalesLine                   salesLine;
        SalesTable                  salesTable;
        InventTable                 inventTable;
        boolean                     lineOnOrderPosted = false;
        SalesId                     prevSalesID = '';
        int                         orderCount;
        int                         orderLineProcessed;
        Map                         salesId2McrCustPaymTotals = new Map(Types::String, Types::Class);
        MCRCustPaymTotals           currentMcrCustPaymTotals;
        MCRPickingWorkbenchSession  pickingSession;

        // make sure temp table is empty
        delete_from this;

        // Read the picking Session
        pickingSession = MCRPickingWorkbenchSession::find(_sessionId);

        // build query on SalesLine sorted by createdDate
        query = new Query();
        qbdSalesLine = query.addDataSource(tableNum(SalesLine));

        // use value returned from prompt as value for query
        qbdSalesLine.addRange(fieldNum(SalesLine, ItemId)).value(_formatString);

        // Only include open lines
        qbdSalesLine.addRange(fieldNum(SalesLine, SalesStatus)).value(queryValue(SalesStatus::Backorder));
        qbdSalesLine.addRange(fieldNum(SalesLine, LineDeliveryType)).value('!' + queryValue(LineDeliveryType::OrderLineWithMultipleDeliveries));

        queryBuildDataSourceMCRSalesLineDropShipment = qbdSalesLine.addDataSource(tableNum(MCRSalesLineDropShipment));
        queryBuildDataSourceMCRSalesLineDropShipment.addLink(fieldNum(SalesLine, RecId), fieldNum(MCRSalesLineDropShipment, SalesLine));
        queryBuildDataSourceMCRSalesLineDropShipment.joinMode(JoinMode::NoExistsJoin);
        queryBuildDataSourceMCRSalesLineDropShipment.addRange(fieldNum(MCRSalesLineDropShipment, DropShipment)).value(queryValue(NoYes::yes));

        // skip continuity items.
        queryBuildDataSourceMCRSalesLine = qbdSalesLine.addDataSource(tableNum(MCRSalesLine));
        queryBuildDataSourceMCRSalesLine.joinMode(JoinMode::NoExistsJoin);
        queryBuildDataSourceMCRSalesLine.relations(true);
        queryBuildDataSourceMCRSalesLine.addRange(fieldNum(MCRSalesLine, ContinuityScheduleId)).value(SysQuery::valueNotEmptyString());

        qbdInventTable = qbdSalesLine.addDataSource(tableNum(InventTable));
        qbdInventTable.addLink(fieldNum(SalesLine, ItemId), fieldNum(InventTable, ItemId));

        // Sort in FIFO
        qbdSalesLine.addSortField(fieldNum(SalesLine, CreatedDateTime));

        queryRange = new QueryRun(query);
        while (queryRange.next())
        {
            salesLine = queryRange.get(tableNum(SalesLine));
            inventTable = queryRange.get(tableNum(InventTable));

            // Need to make sure the sales table status is correct
            salesTable = SalesTable::find(salesLine.SalesId);

            // need to keep track of how many total sales orders found in case there was a limit
            // set by session profile.  Flag is set when a line from a salesorder is inserted into
            // temp table.
            if (prevSalesID != salesTable.SalesId)
            {
                prevSalesID = salesTable.SalesId;
                if (lineOnOrderPosted)
                {
                    lineOnOrderPosted = false;
                    orderCount++;
                    // If at the max order count, exit.
                    if ((pickingSession.MaxOrders != 0)
                        && (orderCount >= pickingSession.MaxOrders))
                    {
                        break;
                    }
                }

                currentMcrCustPaymTotals = this.getMcrCustPayTotalsForSalesId(salesTable.SalesId, salesId2McrCustPaymTotals);
            }

            if (salesTable.MCROrderStopped == NoYes::Yes)
            {
                continue;
            }

            // Insert the line into the temp table.  Not passing warehouse, since not used
            // when selecting by item id.
            if (this.insertTransAndReserve("", salesLine, inventTable, _displayWarnings, currentMcrCustPaymTotals))
            {
                lineOnOrderPosted = true;
                orderLineProcessed ++;

                // If max lines specified, check to see if we have gotten to the max.
                if ((pickingSession.MaxLinesPerOrder != 0)
                    && (orderLineProcessed >= pickingSession.MaxLinesPerOrder))
                {
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSalesIdPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates picking workbench transaction records for a list of sales orders.
    /// </summary>
    /// <param name="_sessionId">
    /// The session ID of the picking session to use to create the picking workbench transactions.
    /// </param>
    /// <param name="_formatString">
    /// The list of sales ID's used to create the picking workbench transaction records.
    /// </param>
    /// <param name="_displayWarnings">
    /// Indicates whether to display warnings if they occur.
    /// </param>
    /// <remarks>
    /// Value of prompt can either be a comma
    ///     separated list or a single range.  Or any value valid for a query build range.
    /// </remarks>
    void initFromSalesIdPrompt(MCRPickingSession _sessionId,
                               str               _formatString,
                               boolean           _displayWarnings = false)
    {
        Query                       query;
        QueryRun                    queryRun;
        QueryBuildDataSource        queryBuildDataSource;

        SalesTable                  salesTable;
        SalesLine                   salesLine;
        InventTable                 inventTable;

        boolean                     lineOnOrderPosted = false;
        SalesId                     prevSalesID = '';
        int                         orderCount, orderLineProcessed;
        MCRSalesLineDropShipment    mcrSalesLineDropShipment;
        MCRSalesLine                mcrSalesLine;
        Map                         salesId2McrCustPaymTotals = new Map(Types::String, Types::Class);
        MCRCustPaymTotals           currentMcrCustPaymTotals;

        MCRPickingWorkbenchSession  pickingSession;

        // make sure temp table is empty
        delete_from this;

        // Read the picking Session
        pickingSession = MCRPickingWorkbenchSession::find(_sessionId);

        // build query on SalesTable sorted by createdDate
        query = new Query();
        queryBuildDataSource = query.addDataSource(tableNum(SalesTable));

        // only choose sales orders that need to be picked.
        queryBuildDataSource.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(SalesStatus::Backorder));
        queryBuildDataSource.addRange(fieldNum(SalesTable, MCROrderStopped)).value(enum2str(NoYes::No));

        // use value of prompt for value on query
        queryBuildDataSource.addRange(fieldNum(SalesTable, SalesId)).value(_formatString);

        // sort FIFO order
        queryBuildDataSource.addSortField(fieldNum(SalesTable, CreatedDateTime));

        queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            salesTable = queryRun.get(tableNum(SalesTable));

            // need to keep track of how many total sales orders found in case there was a limit
            // set by session profile.  Flag is set when a line from a sales order is inserted into
            // temp table.
            if (prevSalesID != salesTable.SalesId)
            {
                prevSalesID = salesTable.SalesId;
                if (lineOnOrderPosted)
                {
                    lineOnOrderPosted = false;
                    orderCount++;
                    // If at the max order count, exit.
                    if ((pickingSession.MaxOrders != 0)
                        && (orderCount >= pickingSession.MaxOrders))
                    {
                        break;
                    }
                }

                currentMcrCustPaymTotals = this.getMcrCustPayTotalsForSalesId(salesTable.SalesId, salesId2McrCustPaymTotals);
            }

            // search for valid lines on an order that can be picked
            while select salesLine
                where salesLine.SalesId == salesTable.SalesId
                    && salesLine.SalesStatus == SalesStatus::Backorder
                    && salesLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries
                join inventTable
                where inventTable.ItemId == salesLine.ItemId
                notexists join RecId from mcrSalesLineDropShipment
                where mcrSalesLineDropShipment.SalesLine == salesLine.RecId
                    && mcrSalesLineDropShipment.DropShipment == NoYes::Yes
                notexists join mcrSalesLine
                where mcrSalesLine.SalesLine == salesLine.RecId
                    && mcrSalesLine.ContinuityScheduleId
            {
                // Insert the line into the temp table.  Not passing warehouse, since not used
                // when selecting by sales order.
                // Performance change to check during line processing.
                // Added max orders/lines checking
                if (this.insertTransAndReserve("", salesLine, inventTable, _displayWarnings, currentMcrCustPaymTotals))
                {
                    lineOnOrderPosted = true;
                    orderLineProcessed ++;

                    // If max lines specified, check to see if we have gotten to the max.
                    if (pickingSession.MaxLinesPerOrder != 0
                        && orderLineProcessed >= pickingSession.MaxLinesPerOrder)
                    {
                        return;   // break out of both while select and outer query
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSessionCriteriaQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query for the session profile search criteria to create picking workbench transaction records.
    /// </summary>
    /// <param name="_pickingSession">
    /// The session of the picking session to use to create the picking workbench transactions.
    /// </param>
    /// <returns>The query</returns>
    protected Query buildSessionCriteriaQuery(MCRPickingWorkbenchSession _pickingSession)
    {

        // build query on SalesTable using session profile/selection criteria
        Query querySalesTable = new Query();
        QueryBuildDataSource qbdSalesTable = querySalesTable.addDataSource(tableNum(SalesTable));
        qbdSalesTable.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(SalesStatus::Backorder));
        qbdSalesTable.addRange(fieldNum(SalesTable, SalesType)).value(enum2str(SalesType::Sales));
        qbdSalesTable.addRange(fieldNum(SalesTable, MCROrderStopped)).value(enum2str(NoYes::No));

        if (MCRPickingWorkbenchSortSalesOrderByPriorityFlight::instance().isEnabled())
        {
            QueryBuildDataSource queryBuildDataSourceMCRSalesTableSort = qbdSalesTable.addDataSource(tableNum(MCRSalesTable));
            queryBuildDataSourceMCRSalesTableSort.addLink(fieldNum(SalesTable, RecId), fieldNum(MCRSalesTable, SalesTable));
            queryBuildDataSourceMCRSalesTableSort.fetchMode(QueryFetchMode::One2One);

            // Records with the "Low - 10" priority do not exist in the MCRSalesTable by design, the Outer join is used below to select them
            queryBuildDataSourceMCRSalesTableSort.joinMode((_pickingSession.soAllocLowPriority == MCRSOAllocPriority::AllocationPriority10)
                                                                ? JoinMode::OuterJoin : JoinMode::InnerJoin);

            // sort by priority
            queryBuildDataSourceMCRSalesTableSort.addOrderByField(fieldNum(MCRSalesTable, SOAllocPriority), SortOrder::Descending);
            // sort by FIFO
            qbdSalesTable.addOrderByField(fieldNum(SalesTable, CreatedDateTime), SortOrder::Ascending);
            qbdSalesTable.addOrderByField(fieldNum(SalesTable, SalesId), SortOrder::Ascending);
        }
        else
        {
            // sort by FIFO
            qbdSalesTable.addSortField(fieldNum(SalesTable, CreatedDateTime));
            qbdSalesTable.addSortField(fieldNum(SalesTable, SalesId));
        }

        // If range of all not chosen (defaults)
        if (_pickingSession.soAllocHighPriority != MCRSOAllocPriority::AllocationPriority1
            || _pickingSession.soAllocLowPriority != MCRSOAllocPriority::AllocationPriority10)
        {
            QueryBuildDataSource queryBuildDataSourceMCRSalesTable = qbdSalesTable.addDataSource(tableNum(MCRSalesTable));
            queryBuildDataSourceMCRSalesTable.addLink(fieldNum(SalesTable, RecId), fieldNum(MCRSalesTable, SalesTable));
            queryBuildDataSourceMCRSalesTable.joinMode(JoinMode::NoExistsJoin);
            queryBuildDataSourceMCRSalesTable.fetchMode(QueryFetchMode::One2One);

            //Set ranges as an OR. Increased/Decreased value by 1 to include the current range in valid result set since not exists join.
            queryBuildDataSourceMCRSalesTable.addRange(fieldNum(MCRSalesTable, SOAllocPriority)).value(
                SysQuery::range('', SysQuery::value(_pickingSession.SOAllocLowPriority - 1)));
            queryBuildDataSourceMCRSalesTable.addRange(fieldNum(MCRSalesTable, SOAllocPriority)).value(
                SysQuery::range(SysQuery::value(_pickingSession.soAllocHighPriority + 1), ''));
        }

        QueryBuildDataSource qbdSalesLine = qbdSalesTable.addDataSource(tableNum(SalesLine));
        qbdSalesLine.addLink(fieldNum(SalesTable, SalesId), fieldNum(SalesLine, SalesId));
        qbdSalesLine.fetchMode(QueryFetchMode::One2One);
        qbdSalesLine.addRange(fieldNum(SalesLine, SalesStatus)).value(queryValue(SalesStatus::Backorder));
        qbdSalesLine.addRange(fieldNum(SalesLine, LineDeliveryType)).value(SysQuery::valueNot(LineDeliveryType::OrderLineWithMultipleDeliveries));
        // Only lines with positive quantities
        qbdSalesLine.addRange(fieldNum(SalesLine, QtyOrdered)).value('>0');

        QueryBuildDataSource queryBuildDataSourceMCRSalesLineDropShipment = qbdSalesLine.addDataSource(tableNum(MCRSalesLineDropShipment));
        queryBuildDataSourceMCRSalesLineDropShipment.addLink(fieldNum(SalesLine, RecId), fieldNum(MCRSalesLineDropShipment, SalesLine));
        queryBuildDataSourceMCRSalesLineDropShipment.fetchMode(QueryFetchMode::One2One);
        queryBuildDataSourceMCRSalesLineDropShipment.joinMode(JoinMode::OuterJoin);

        QueryBuildDataSource queryBuildDataSourceMCRSalesLine = qbdSalesLine.addDataSource(tableNum(MCRSalesLine));
        queryBuildDataSourceMCRSalesLine.addLink(fieldNum(SalesLine, RecId), fieldNum(MCRSalesLine, SalesLine));
        queryBuildDataSourceMCRSalesLine.fetchMode(QueryFetchMode::One2One);

        if (_pickingSession.MCRExpedite)
        {
            //If expedite is being used as a criteria, then the MCRSalesLine record must exist (inner join).
            queryBuildDataSourceMCRSalesLine.joinMode(JoinMode::InnerJoin);
            queryBuildDataSourceMCRSalesLine.addRange(fieldNum(MCRSalesLine, ContinuityScheduleId)).value(SysQuery::valueEmptyString());
            queryBuildDataSourceMCRSalesLine.addRange(fieldNum(MCRSalesLine, Expedite)).value(queryValue(_pickingSession.MCRExpedite));
        }
        else
        {
            queryBuildDataSourceMCRSalesLine.joinMode(JoinMode::NoExistsJoin);
            queryBuildDataSourceMCRSalesLine.addRange(fieldNum(MCRSalesLine, ContinuityScheduleId)).value(SysQuery::valueNotEmptyString());
        }

        // If delivery mode is not blank, add range.
        if (_pickingSession.DlvMode)
        {
            qbdSalesLine.addRange(fieldNum(SalesLine, DlvMode)).value(_pickingSession.DlvMode);
        }

        // If a delivery date is set, update query to be prior to that date, otherwise searches for all sales orders prior to or equal to today's date.
        if (_pickingSession.DlvDate != dateNull())
        {
            qbdSalesLine.addRange(fieldNum(SalesLine, ConfirmedDlv)).value('..' + queryValue(_pickingSession.DlvDate));
        }
        else
        {
            qbdSalesLine.addRange(fieldNum(SalesLine, ConfirmedDlv)).value('..' + queryValue(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())));
        }

        if (_pickingSession.ItemIdQuery)
        {
            qbdSalesLine.addRange(fieldNum(SalesLine, ItemId)).value(this.formatString(_pickingSession.ItemIdQuery));
        }

        // Join invent dim table if using site or warehouse as criteria.
        if (_pickingSession.Warehouse || _pickingSession.InventSiteId)
        {
            QueryBuildDataSource qbdInventDim = qbdSalesLine.addDataSource(tableNum(InventDim));
            qbdInventDim.addLink(fieldNum(SalesLine, InventDimId), fieldNum(InventDim, InventDimId));
            qbdInventDim.fetchMode(QueryFetchMode::One2One);

            if (_pickingSession.Warehouse)
            {
                qbdInventDim.addRange(fieldNum(InventDim, InventLocationId)).value(_pickingSession.Warehouse);
            }
            else
            {
                qbdInventDim.addRange(fieldNum(InventDim, InventSiteId)).value(_pickingSession.InventSiteId);
            }
        }
        
        return querySalesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSessionCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Uses session profile search criteria to create picking workbench transaction records.
    /// </summary>
    /// <param name="_sessionId">
    /// The session ID of the picking session to use to create the picking workbench transactions.
    /// </param>
    /// <param name="_displayWarnings">
    /// Indicates whether to display warnings if they occur.
    /// </param>
    void initFromSessionCriteria(MCRPickingSession _sessionId,
                                 boolean           _displayWarnings = false)
    {
        boolean                     lineOnOrderPosted = false;
        int                         numTotalSOLines;
        SalesLine                   salesLineCount;
        Map                         salesId2McrCustPaymTotals = new Map(Types::String, Types::Class);
        MCRCustPaymTotals           currentMcrCustPaymTotals;

        // make sure temp table is empty
        delete_from this;

        // initializations
        int orderCount = 0;
        int orderLineRead = 0;
        int orderLineProcessed = 0;
        SalesId prevSalesID = '';

        // Read the picking session.
        MCRPickingWorkbenchSession pickingSession = MCRPickingWorkbenchSession::find(_sessionId);

        // Read the sales lines that match the criteria.
        QueryRun qrSalesTable = new QueryRun(this.buildSessionCriteriaQuery(pickingSession));

        while (qrSalesTable.next())
        {
            SalesTable salesTable = qrSalesTable.get(tableNum(SalesTable));

            // Retrieve the sales order lines.
            SalesLine salesLine = qrSalesTable.get(tableNum(SalesLine));
            MCRSalesLineDropShipment mcrSalesLineDropShipment = qrSalesTable.get(tableNum(mcrSalesLineDropShipment));

            // outer joined, however if record was not found, default value will be false, and still accurate test.
            if (mcrSalesLineDropShipment.DropShipment)
            {
                //Skip drop shipment lines.
                continue;
            }

            orderLineRead ++;

            // need to keep track of how many total sales orders found in case there was a limit
            // set by session profile.  Flag is set when a line from a salesorder is inserted into
            // temp table.
            if (prevSalesID != salesTable.SalesId)
            {
                prevSalesID = salesTable.SalesId;
                if (lineOnOrderPosted)
                {
                    lineOnOrderPosted = false;
                    orderCount++;
                    // If at the max order count, exit.
                    if ((pickingSession.MaxOrders != 0)
                        && (orderCount >= pickingSession.MaxOrders))
                    {
                        break;
                    }
                }

                currentMcrCustPaymTotals = this.getMcrCustPayTotalsForSalesId(salesTable.SalesId, salesId2McrCustPaymTotals);
            }

            // if session criteria has matching set by paymmode, 
            // check if the sales order has at least partial payment by that payment mode
            if (pickingSession.TenderTypeId)
            {
                if (!salesTable.mcrHasTender(pickingSession.TenderTypeId))
                {
                    continue;
                }
            }

            if (pickingSession.CustGroupId)
            {
                if (CustTable::find(salesTable.CustAccount).CustGroup != pickingSession.CustGroupId)
                {
                    continue;
                }
            }

            if (pickingSession.OnlySingleLineOrders)
            {
                select count(RecId) from salesLineCount
                    where   salesLineCount.SalesId == salesTable.SalesId
                        && salesLineCount.SalesStatus != SalesStatus::Canceled
                        && salesLineCount.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries;
                numTotalSOLines = int642int(salesLineCount.RecId);
                if (numTotalSOLines > 1)
                {
                    continue;
                }
            }

            InventTable inventTable = InventTable::find(salesLine.ItemId);

            // Reserve and insert the line into the temp table.  Returns true if one was inserted.
            if (this.insertTransAndReserve(pickingSession.Warehouse, salesLine, inventTable, _displayWarnings, currentMcrCustPaymTotals))
            {
                lineOnOrderPosted = true;
                orderLineProcessed ++;

                // If max lines specified, check to see if we have gotten to the max.
                if ((pickingSession.MaxLinesPerOrder != 0) && (orderLineProcessed >= pickingSession.MaxLinesPerOrder))
                {
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransAndReserve</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the transaction, reserves, then creates picking workbench transaction record.
    /// </summary>
    /// <param name="_sessionWarehouse">
    /// The session warehouse of the picking session to use to create the picking workbench transactions.
    /// </param>
    /// <param name="_salesLine">
    /// The sales line record that should be reserved.
    /// </param>
    /// <param name="_inventTable">
    /// The item record of the item that should be reserved.
    /// </param>
    /// <param name="_displayWarnings">
    /// Indicates whether to display warnings if they occur.
    /// </param>
    /// <param name="_mcrCustPaymTotals">The <c>MCRCustPaymTotals</c> class to use; optional.</param>
    /// <returns>
    /// true if the sales order items were able to be reserved; otherwise false.
    /// </returns>
    /// <remarks>
    /// Issue appropriate warning message if an authorization was stale and therefore a sales order
    ///     could not be picked.
    /// </remarks>
    boolean insertTransAndReserve(InventLocationId  _sessionWarehouse,
                                  SalesLine         _salesLine,
                                  InventTable       _inventTable,
                                  boolean           _displayWarnings = false,
                                  MCRCustPaymTotals _mcrCustPaymTotals = null)
    {
        InventTrans                     inventTrans;
        InventDim                       inventDim;
        boolean                         orderFound = false;
        container                       warehouseContainer;
        InventTransId                   inventTransID_sub;
        InventTransOrigin               inventTransOrigin;
        SalesTable                      salesTable = _salesLine.salesTable();
        SalesLine                       salesLine = _salesLine;
        InventTable                     inventTable = _inventTable;
        MCRCustPaymTotals               mcrCustPaymTotals;

        salesTable.reread();
        if (inventTransID_sub)
        {
            // Alternate made, so reset the line to process.
            salesLine = SalesLine::findInventTransId(inventTransID_sub);
            inventTable = InventTable::find(salesLine.ItemId);
        }

        // Attempt to reserve the line, if returns true (item can be picked)
        // insert into temp table
        // Insert into temp table by warehouse.
        if (MCRPickingWorkBench::checkAndReserveLine(salesLine, salesLine.InventTransId))
        {
            // insert into temp table
            warehouseContainer = conNull();

            // need to split up the sales line by the warehouses picked from during reservation
            // The inventtrans table holds the inventDim Ids of where the item was actually picked
            // Add condition to allow the picking of gift cards that are set as a service item.
            while select StatusIssue from inventTrans
                where (inventTrans.StatusIssue == StatusIssue::ReservPhysical || inventTrans.StatusIssue == StatusIssue::OnOrder)
                    && inventTrans.StatusReceipt  == StatusReceipt::None
                    && inventTrans.TransChildType == InventTransChildType::None
                    && inventTrans.StatusIssue != StatusIssue::OnOrder
                join RecId from inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                    && inventTransOrigin.ReferenceId == salesLine.SalesId
                join InventLocationId from inventDim
                where inventTrans.InventDimId == inventDim.InventDimId
                    && (_sessionWarehouse == "" || inventDim.InventLocationId == _sessionWarehouse)
            {
                this.InventLocationId = inventDim.InventLocationId;

                // need to keep track of which warehouses have already had lines in the temp table created.
                if (!conFind(warehouseContainer, this.InventLocationId) )
                {
                    warehouseContainer += this.InventLocationId;
                    this.SalesId = salesLine.SalesId;
                    this.InventTransId = salesLine.InventTransId;
                    this.ItemId = salesLine.ItemId;
                    this.InventDimId = salesLine.InventDimId;
                    this.SalesLineRecId = salesLine.RecId;
                    this.Name = salesLine.DeliveryName;
                    this.Address = salesLine.deliveryAddress().Address;
                    this.DlvMode = salesLine.DlvMode;
                    this.MCRShipAlone = inventTable.mcrInventTable().ShipAlone;
                    orderFound = true;
                    if (this.validateWrite())
                    {
                        this.insert();
                    }
                    else
                    {
                        throw error("@SYS104318");
                    }
                }
            }
        }
        // Only display the error message if the StatusIssue != Picked
        else if (InventTrans::findTransId(salesLine.InventTransId).StatusIssue != StatusIssue::Picked
            && InventTrans::findTransId(salesLine.InventTransId).TransChildType != InventTransChildType::WMSOrder)
        {
            // Different error message for auth stale or declined payments.
            if (_mcrCustPaymTotals)
            {
                mcrCustPaymTotals = _mcrCustPaymTotals;
            }
            else
            {
                mcrCustPaymTotals = MCRCustPaymTotals::construct(tableNum(SalesTable), SalesTable::find(salesLine.SalesId).RecId);
            }
            if (!mcrCustPaymTotals.allPaymentsApproved())
            {
                warning(strFmt("@MCR30983", salesLine.SalesId));
            }
            else
            {
                // Give warning that order could not be picked.  (reservation failed, or other)
                warning(strFmt("@MCR23447", salesLine.ItemId, salesLine.SalesId));
            }
        }

        return orderFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveDims</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the active dimensions in use for the picking workbench.
    /// </summary>
    /// <returns>
    /// The active dimensions in use for the picking workbench.
    /// </returns>
    public static container getActiveDims()
    {
        container conDims;

        // Add 'Division' dimension.
        conDims += 1;

        return conDims;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LogisticsBasic</ConfigurationKey>
	<Label>@MCR22959</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>PickWaveReferenceId</TitleField1>
	<TitleField2>ItemId</TitleField2>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>RecId</ClusteredIndex>
	<PrimaryIndex>RecId</PrimaryIndex>
	<TableType>InMemory</TableType>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Split</Name>
			<Label>@SYS10133</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MCRShipAlone</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SalesId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Address</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Addressing</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DlvMode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustDlvModeId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventLocationId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventLocationId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemIdSmall</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MCRExpedite</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>MCRExpedite</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>MCRShipAlone</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>MCRShipAlone</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Name</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PickWaveReferenceId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>MCRPickingWave</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SalesId</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>SalesIdBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SalesLineRecId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SalesLineRefRecId</ExtendedDataType>
			<Label>@MCR11335</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>PickWaveIDX</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>PickWaveReferenceId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>Sort</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>InventLocationId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>MCRShipAlone</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DlvMode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>SalesId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Name</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Address</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DlvMode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>DlvMode</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DlvMode</Name>
					<SourceEDT>CustDlvModeId</SourceEDT>
					<Field>DlvMode</Field>
					<RelatedField>Code</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimId</Name>
					<SourceEDT>InventDimId</SourceEDT>
					<Field>InventDimId</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventLocation</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventLocation</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventLocationId</Name>
					<SourceEDT>InventLocationId</SourceEDT>
					<Field>InventLocationId</Field>
					<RelatedField>InventLocationId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventLocationIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<SourceEDT>ItemIdSmall</SourceEDT>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ItemIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOrigin</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransId</Name>
					<SourceEDT>InventTransId</SourceEDT>
					<Field>InventTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventTransIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>MCRExpediteTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>MCRExpediteTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MCRExpedite</Name>
					<SourceEDT>MCRExpedite</SourceEDT>
					<Field>MCRExpedite</Field>
					<RelatedField>MCRExpedite</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ExpediteIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>MCRPickingWorkbenchWave</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>MCRPickingWorkbenchWave</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PickWaveReferenceId</Name>
					<SourceEDT>MCRPickingWave</SourceEDT>
					<Field>PickWaveReferenceId</Field>
					<RelatedField>WaveReferenceId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>WaveIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>SalesLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SalesLineRecId</Name>
					<SourceEDT>SalesLineRefRecId</SourceEDT>
					<Field>SalesLineRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SalesTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>SalesTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SalesId</Name>
					<SourceEDT>SalesIdBase</SourceEDT>
					<Field>SalesId</Field>
					<RelatedField>SalesId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>SalesIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>