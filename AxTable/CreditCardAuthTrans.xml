<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CreditCardAuthTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
using RetailConst = Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

public class CreditCardAuthTrans extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>creditCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the credit card number.
    /// </summary>
    /// <returns>
    /// The credit card number; otherwise, an empty string.
    /// </returns>
    public display CreditCardNumber creditCard()
    {
        CreditCardPaymentProperty property = CreditCardPaymentProperties::fromXmlString(this.CardTokenRequest).find(Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(), Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_Last4Digits());

        return property ? property.parmStringValue() : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayProcessorsName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the processor.
    /// </summary>
    /// <returns>
    /// The processor's human readable identification.
    /// </returns>
    public display CreditCardProcessorsName displayProcessorsName()
    {
        return (select creditCardProcessors where creditCardProcessors.RecId == this.CreditCardProcessors).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        if (this.LineNum == 0)
        {
            if (this.SalesId)
            {
                this.LineNum = CreditCardAuthTrans::lastLineNum(this.SalesId) + 1;
            }
            else if (this.MCRInvoiceId)
            {
                this.LineNum = CreditCardAuthTrans::lastLineNum(this.MCRInvoiceId) + 1;
            }
            else if (this.MCRJournalNum)
            {
                this.LineNum = CreditCardAuthTrans::lastLineNum(this.MCRJournalNum) + 1;
            }
            else
            {
                // Fall back to using sales Id unconditionally if non of above is applicable.
                this.LineNum = CreditCardAuthTrans::lastLineNum(this.SalesId) + 1;
            }
        }

        if (this.OrigSalesId == '')
        {
            this.OrigSalesId = this.SalesId;
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDisplayRelatedOrderID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the order ID
    ///     of the record the payment is related to.
    /// </summary>
    /// <returns>
    /// The order ID
    ///     of the record the payment is related to.
    /// </returns>
    public display Num mcrDisplayRelatedOrderID()
    {
        MCRCustPaymTable mcrCustPaymTable = MCRCustPaymTable::findByRecID(this.MCRPaymRecId);

        if (mcrCustPaymTable.RefTableId == tableNum(SalesTable))
        {
            return mcrCustPaymTable.salesTable().SalesId;
        }
        else if (this.MCRInvoiceId)
        {
            return CustInvoiceTable::findRecId(mcrCustPaymTable.RefRecId).InvoiceId;
        }
        else if (this.MCRJournalNum)
        {
            return LedgerJournalTrans::findRecId(mcrCustPaymTable.RefRecId, false).JournalNum;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrManuallyAuthorize</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates this record to indicate that it has been manually authorized.
    /// </summary>
    /// <param name="_creditCardAuthorization">
    /// The authorization code obtained from the credit
    ///     card processor, typically through the phone.
    /// </param>
    public void mcrManuallyAuthorize(CreditCardAuthorization _creditCardAuthorization)
    {
        ttsBegin;
        this.selectForUpdate(true);
        this.Authorization = _creditCardAuthorization;
        this.ApprovedDateTime = DateTimeUtil::getSystemDateTime();
        this.ProcessorStatus = CreditCardProcessorStatus::Approved;
        this.update();
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrManuallyDecline</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates this record to indicate that it has been manually declined.
    /// </summary>
    /// <param name="_creditCardAuthorization">
    /// The decline code obtained from the credit
    ///     card processor, typically through the phone.
    /// </param>
    public void mcrManuallyDecline(CreditCardAuthorization _creditCardAuthorization)
    {
        ttsBegin;
        this.selectForUpdate(true);
        this.Authorization = _creditCardAuthorization;
        this.ApprovedDateTime = DateTimeUtil::getSystemDateTime();
        this.ProcessorStatus = CreditCardProcessorStatus::Declined;
        this.update();
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPaymentOperationAndStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if this payment transaction has the required operation and status.
    /// </summary>
    /// <param name = "_operation">The required operation.</param>
    /// <param name = "_status">The required processor status.</param>
    /// <returns>
    ///    true if CreditCardAuthTran operation and status match the passed parameters; otherwise, false.
    /// </returns>
    internal boolean hasPaymentOperationAndStatus(CreditCardOperation _operation, CreditCardProcessorStatus _status)
    {
        return this.ProcessorStatus == _status && this.ApprovalType == _operation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>supportsIncrementCapture</Name>
				<Source><![CDATA[
    internal boolean supportsIncrementCapture()
    {
        CreditCardPaymentProperty property = CreditCardPaymentProperties::fromXmlString(this.CardTokenResult).find(Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_AuthorizationResponse(), Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.AuthorizationResponseProperties::get_SupportsMultipleCaptures());

        return property ? strLwr(property.parmStringValue()) == 'true' : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified record exists in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_recId">
    ///    The record ID of the credit card authorization transaction to check.
    /// </param>
    /// <returns>
    ///    true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean checkExist(RecId _recId)
    {
        boolean found = true;

        if (!CreditCardAuthTrans::exist(_recId))
        {
            found = checkFailed(strFmt(CreditCardAuthTrans::txtNotExist(), _recId));
        }

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreapprovalDurationDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the preapproval period length in days for the authorization transaction. The function tries to determine the preapproval period length
    /// based on the credit card type and the period length defined in the card settings in payment methods configuration in the retail channel associated with the transaction
    /// or falls back to the account receivable setting.
    /// </summary>
    /// <returns>Preapproval period in days.</returns>
    [Replaceable(true)]
    public CreditCardPreapprovalLastNoOfDays getPreapprovalDurationDays()
    {
        if (!RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return CustParameters::find().CreditCardPreapprovalLastNoOfDays;
        }

        RefRecId retailChannel = this.getRetailChannel(true);

        RetailStoreTenderTypeCardTable retailStoreTenderTypeCardTable =
                RetailStoreTenderTypeCardTable::findByChannelAndCardType(retailChannel, this.CreditCardTypeName);

        if (retailStoreTenderTypeCardTable && retailStoreTenderTypeCardTable.PreapprovalDurationDays)
        {
            return retailStoreTenderTypeCardTable.PreapprovalDurationDays;
        }
        else
        {
            return CustParameters::find().CreditCardPreapprovalLastNoOfDays;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailChannel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get retail channel associated with the authorization transaction.
    /// </summary>
    /// <param name = "_shouldDefaultToCurrentCallCenter">If true and the associated sales order is not mapped to a retail channel, the function returns a call center channel which is associated to the current user is returned </param>
    /// <returns>Retail channel id or 0 if no retail channel can be detrmined</returns>
    internal RefRecId getRetailChannel(boolean _shouldDefaultToCurrentCallCenter)
    {
        SalesTable salesOrder = SalesTable::find(this.SalesId);

        if (!salesOrder && this.MCRPaymRecId)
        {
            MCRCustPaymTable mcrCustPaymTable = MCRCustPaymTable::findByRecID(this.MCRPaymRecId);

            if (mcrCustPaymTable.RefTableId == tableNum(SalesTable))
            {
                salesOrder = mcrCustPaymTable.salesTable();
            }
        }

        RefRecId retailChannel;
        if (salesOrder && salesOrder.retailSalesTable())
        {
            retailChannel = salesOrder.retailSalesTable().RetailChannel;
        }
        else
        {
            // if we cannot find retail channel associated with the order and the current user is call center user use the call center associated with the user
            // to get the channel settings
            if (_shouldDefaultToCurrentCallCenter)
            {
                MCRChannelUser callCenterUser = MCRChannelUser::find();
                if (callCenterUser)
                {
                    retailChannel = callCenterUser.Channel;
                }
            }
        }

        return retailChannel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>CreditCardAuthTrans</c> table exists.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the credit card transaction to check for existence.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean exist(RecId _recId)
    {
        return (select creditCardAuthTrans
                where creditCardAuthTrans.RecId == _recId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the credit card transaction record to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when it reads the record; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    public static CreditCardAuthTrans find(RecId _recId,
                                     boolean _forUpdate = false,
                                     ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        if (_forUpdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            creditCardAuthTrans.concurrencyModel(_concurrencyModel);
        }

        creditCardAuthTrans.selectForUpdate(_forUpdate);

        if (_recId)
        {
            creditCardAuthTrans.selectLocked(_forUpdate);

            select creditCardAuthTrans
                where creditCardAuthTrans.RecId == _recId;
        }

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID of the record to find.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans findCharge(SalesId _salesId)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        select creditCardAuthTrans
            where creditCardAuthTrans.SalesId == _salesId &&
                (creditCardAuthTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize || creditCardAuthTrans.ApprovalType == CreditCardOperation::AuthorizeAndCapture) &&
                creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findChargeByInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID of the record to find.
    /// </param>
    /// <param name="_salesInvoiceId">
    /// The sales invoice ID of the record to find.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans findChargeByInvoice(SalesId _salesId, SalesInvoiceId _salesInvoiceId)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        select creditCardAuthTrans
            where creditCardAuthTrans.SalesId == _salesId &&
                creditCardAuthTrans.SalesInvoiceId == _salesInvoiceId &&
                (creditCardAuthTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize || creditCardAuthTrans.ApprovalType == CreditCardOperation::AuthorizeAndCapture) &&
                creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFinalizedPreApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID of the record to find.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans findFinalizedPreApproval(SalesId _salesId)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        select creditCardAuthTrans
            where creditCardAuthTrans.SalesId == _salesId &&
                creditCardAuthTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize &&
                creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLatest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table, where TransactionType == CreditCardTransactionType::Transactional.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID of the record to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans findLatest(SalesId _salesId, boolean _forUpdate = false)
    {
        return CreditCardAuthTrans::findLatestTransactional(_salesId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLatestTransactional</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table, where TransactionType == CreditCardTransactionType::Transactional.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID of the record to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    [Hookable(false)]
    internal static CreditCardAuthTrans findLatestTransactional(SalesId _salesId, boolean _forUpdate = false)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        if (_salesId)
        {
            creditCardAuthTrans.selectForUpdate(_forUpdate);
            creditCardAuthTrans.selectLocked(_forUpdate);

            select firstonly creditCardAuthTrans
                order by LineNum desc
                where creditCardAuthTrans.SalesId == _salesId
                    && creditCardAuthTrans.TransactionType == CreditCardTransactionType::Transactional;
        }

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindTotalCapturedAmount</Name>
				<Source><![CDATA[
    /// <summary>
        /// Finds the total captured amount for the passed <c>MCRCustPaymTable</c>.
    /// </summary>
    /// <param name = "_mcrCustPaymRecid">
        /// The <c>MCRCustPaymTable</c> record identifier.
    /// </param>
    /// <returns>
    /// The total amount for incremental captures.
    /// </returns>
    [Hookable(false)]
    internal static AmountCur mcrFindTotalCapturedAmount(RecId _mcrCustPaymRecid)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        if (_mcrCustPaymRecId)
        {
            select sum(ApprovalAmountCur) from creditCardAuthTrans
                where creditCardAuthTrans.MCRPaymRecId == _mcrCustPaymRecId &&
                    (creditCardAuthTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize
                    || creditCardAuthTrans.ApprovalType == CreditCardOperation::AuthorizeAndCapture)
                    && creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;
        }

        return creditCardAuthTrans.ApprovalAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsIncrementalCaptureAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a non-zero amount was incrementally captured.
    /// </summary>
    /// <param name = "_mcrCustPaymTableRecId">The <c>MCRCustPaymTable</c> record identifier.</param>
    /// <returns>True if there is a non-zero amount captured incrementally. Otherwise, false.</returns>
    internal static boolean existsIncrementalCaptureAmount(MCRCustPaymTableRecID _mcrCustPaymTableRecId)
    {
        return RetailIncrementalCaptureFeatureExposure::isEnabled()
            && CreditCardAuthTrans::mcrFindTotalCapturedAmount(_mcrCustPaymTableRecId) != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRefundCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID of the record to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans findRefundCharge(SalesId _salesId, boolean _forUpdate = false)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        creditCardAuthTrans.selectForUpdate(_forUpdate);

        select creditCardAuthTrans
            where creditCardAuthTrans.SalesId == _salesId &&
                creditCardAuthTrans.RefundStatus == CreditCardRefundStatus::Marked &&
                (creditCardAuthTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize || creditCardAuthTrans.ApprovalType == CreditCardOperation::AuthorizeAndCapture) &&
                creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findValidPreApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID of the record to find.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans findValidPreApproval(SalesId _salesId)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        CreditCardAuthTrans::updateExpiredApproval(_salesId);

        select creditCardAuthTrans
            where creditCardAuthTrans.SalesId == _salesId &&
                creditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize &&
                !creditCardAuthTrans.ApprovalExpired &&
                !creditCardAuthTrans.ApprovalVoid &&
                creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getServiceAccountIdFromCardTokenResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the service account id used for the given credit card transaction
    /// </summary>
    /// <param name = "_creditCardAuthTrans">The <c>CreditCardAuthTrans</c> table buffer of the credit card operation.</param>
    /// <returns>A string containing the ServiceAccount Id used to process the transaction.</returns>
    static str getServiceAccountIdFromCardTokenResult(CreditCardAuthTrans _creditCardAuthTrans)
    {
        CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_creditCardAuthTrans.CardTokenResult);
        
        return (CreditCard::getPaymentAccountId(properties));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAuthorizedAndApproved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the latest credit card transaction is authorized and approved.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID for which to obtain the latest credit card transaction.
    /// </param>
    /// <returns>
    /// true if the latest credit card transaction is charged; otherwise, false.
    /// </returns>
    static boolean isAuthorizedAndApproved(SalesId _salesId)
    {
        CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::findLatest(_salesId);

        return (creditCardAuthTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize || creditCardAuthTrans.ApprovalType == CreditCardOperation::AuthorizeAndCapture) &&
                creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last line number of the credit card transaction.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID of the line number to find.
    /// </param>
    /// <returns>
    /// The line number.
    /// </returns>
    static LineNum lastLineNum(SalesId _salesId)
    {
        return (select maxof(LineNum) from creditCardAuthTrans
            where creditCardAuthTrans.SalesId == _salesId).LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markRefundProcessed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates record in <c>CreditCardAuthTrans</c> table to indicate that refund has been processed.
    /// </summary>
    /// <param name = "_authTransRecId"> The record ID of the credit card transaction record to update. </param>
    public static void markRefundProcessed(RefRecId _authTransRecId)
    {
        UserConnection connection = new UserConnection();

        try
        {
            CreditCardAuthTrans authTrans;

            authTrans.setConnection(connection);

            connection.ttsbegin();

            select firstonly forupdate authTrans
                where authTrans.RecId == _authTransRecId;

            if (authTrans)
            {
                authTrans.RefundStatus = CreditCardRefundStatus::Processed;
                authTrans.update();
            }
            connection.ttscommit();
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateAuthorizationForOutstandingFunds</Name>
				<Source><![CDATA[
    /// <summary>
    /// If funds are outstanding on the authorization its status will be changed from settled to authorized.
    /// </summary>
    /// <param name = "_latestTransaction">The authorization transaction to be activated.</param>
    /// <param name = "_outstandingSettlement">The outstanding fund avialable on the authorization.</param>
    /// <returns>True if funds are outstanding on the authorization; otherwise, false.</returns>
    internal static boolean activateAuthorizationForOutstandingFunds(CreditCardAuthTrans _latestTransaction, AmountCur _outstandingSettlement)
    {
        CreditCardAuthTrans authTrans;

        if (_outstandingSettlement > 0)
        {
            // Change auth from settled 99 to approved 1 and return true
            authTrans = CreditCardAuthTrans::findReferencedSettledAuthorization(_latestTransaction.SalesId, _latestTransaction.Authorization, true);

            UserConnection connection = new UserConnection();
        
            if (authTrans)
            {
                if (RetailPaymentChangePaymentStatusUpdateBehaviorFlight::instance().isEnabled())
                {
                    try
                    {
                        authTrans.setConnection(connection);

                        connection.ttsbegin();
                
                        authTrans.ProcessorStatus = CreditCardProcessorStatus::Approved;
                        authTrans.update();
                        connection.ttscommit();
                    }
                    finally
                    {
                        connection.finalize();
                    }
                }
                else
                {
                    ttsbegin;
                    authTrans.ProcessorStatus = CreditCardProcessorStatus::Approved;
                    authTrans.update();
                    ttscommit;
                }
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCreditCardAuthTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the amount and status on the required CreditCardAuthTrans
    /// </summary>
    /// <param name = "_recId">The RecId for the row to be updated.</param>
    /// <param name = "_amount">The amount to be updated.</param>
    /// <param name = "status">The status to be updated.</param>
    internal static void updateCreditCardAuthTrans(RecId _recId, AmountCur _amount, CreditCardProcessorStatus status)
    {
        CreditCardAuthTrans authTrans = CreditCardAuthTrans::find(_recId, true);
        
        if (authTrans)
        {
            if (RetailPaymentChangePaymentStatusUpdateBehaviorFlight::instance().isEnabled())
            {
                UserConnection connection = new UserConnection();
                try
                {
                    authTrans.setConnection(connection);

                    connection.ttsbegin();
                
                    authTrans.ApprovalAmountCur = _amount;
                    authTrans.ProcessorStatus = status;
                    authTrans.update();
                    connection.ttscommit();
                }
                finally
                {
                    connection.finalize();
                }
            }
            else
            {
                ttsbegin;
                authTrans.ApprovalAmountCur = _amount;
                authTrans.ProcessorStatus = status;
                authTrans.update();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearVoidOnCreditCardAuthTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets credit card transactions void flag.
    /// </summary>
    /// <param name = "_recId">The RecId for the row to be updated.</param>
    internal static void clearVoidOnCreditCardAuthTrans(RecId _recId)
    {
        CreditCardAuthTrans authTrans = CreditCardAuthTrans::find(_recId, true);
        
        if (authTrans)
        {
            if (RetailPaymentChangePaymentStatusUpdateBehaviorFlight::instance().isEnabled())
            {
                UserConnection connection = new UserConnection();
                try
                {
                    authTrans.setConnection(connection);

                    connection.ttsbegin();

                    authTrans.ApprovalVoid = NoYes::No;
                    authTrans.update();
                    connection.ttscommit();
                }
                finally
                {
                    connection.finalize();
                }
            }
            else
            {
                ttsbegin;
                authTrans.ApprovalVoid = false;
                authTrans.update();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_mcrCustPaymRecId">
    /// The customer payment record.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    public static CreditCardAuthTrans mcrFindCharge(RecId _mcrCustPaymRecId)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        if (_mcrCustPaymRecId)
        {
            select creditCardAuthTrans
                where creditCardAuthTrans.MCRPaymRecId == _mcrCustPaymRecId &&
                    (creditCardAuthTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize
                        || creditCardAuthTrans.ApprovalType == CreditCardOperation::AuthorizeAndCapture)
                        && creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;
        }

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindLatest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table, where TransactionType == CreditCardTransactionType::Transactional.
    /// </summary>
    /// <param name="_mcrCustPaymRecId">
    /// The record ID of the payment record to find an authorization.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans mcrFindLatest(RecId _mcrCustPaymRecId,
                                             boolean _forUpdate = false)
    {
        return CreditCardAuthTrans::mcrFindLatestTransactional(_mcrCustPaymRecId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindLatestTransactional</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table, where TransactionType == CreditCardTransactionType::Transactional.
    /// </summary>
    /// <param name="_mcrCustPaymRecId">
    /// The record ID of the payment record to find an authorization.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    [Hookable(false)]
    public static CreditCardAuthTrans mcrFindLatestTransactional(RecId _mcrCustPaymRecId,
                                             boolean _forUpdate = false)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        if (_mcrCustPaymRecId)
        {
            creditCardAuthTrans.selectForUpdate(_forUpdate);
            creditCardAuthTrans.selectLocked(_forUpdate);

            select firstonly creditCardAuthTrans
                order by LineNum desc
                where creditCardAuthTrans.MCRPaymRecId == _mcrCustPaymRecId
                    && creditCardAuthTrans.TransactionType == CreditCardTransactionType::Transactional;
        }
        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindLatestOffsetTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the latest authorization or void record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_referencedAuthorization">
    /// The credit card authorization transaction.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    [Hookable(false)]
    internal static CreditCardAuthTrans mcrFindLatestOffsetTransaction(CreditCardAuthTrans _referencedAuthorization)
    {
        CreditCardAuthTrans voidCreditCardAuthTrans;

        if (_referencedAuthorization.RecId)
        {
            select firstonly voidCreditCardAuthTrans
                order by LineNum desc
                where voidCreditCardAuthTrans.MCRPaymRecId == _referencedAuthorization.MCRPaymRecId
                    && voidCreditCardAuthTrans.ApprovalType == CreditCardOperation::Void
                    && voidCreditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
                    && voidCreditCardAuthTrans.OrigAuthRecId == _referencedAuthorization.RecId;
        }

        return voidCreditCardAuthTrans.RecId != 0 ? voidCreditCardAuthTrans : _referencedAuthorization;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindRefundCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_mcrCustPaymRecId">
    /// The Rec ID used to find the original capture.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans mcrFindRefundCharge(RecId _mcrCustPaymRecId, boolean _forUpdate = false)
    {
        CreditCardAuthTrans creditCardAuthTrans, creditCardAuthTransEmpty;

        boolean isRefundsOverMultipleCaptureEnabled = RetailTransactionPaymentsHelper::isRefundsOverMultipleCapturesEnabled();

        creditCardAuthTrans.selectForUpdate(_forUpdate);
        creditCardAuthTransEmpty.selectForUpdate(_forUpdate);

        if (_mcrCustPaymRecId)
        {
            while select creditCardAuthTrans
                order by creditCardAuthTrans.LineNum
                where creditCardAuthTrans.MCRPaymRecId == _mcrCustPaymRecId &&
                    (creditCardAuthTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize
                        || creditCardAuthTrans.ApprovalType == CreditCardOperation::AuthorizeAndCapture) &&
                    creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
            {
                if (!isRefundsOverMultipleCaptureEnabled)
                {
                    return creditCardAuthTrans;
                }

                AmountCur refundableAmount = creditCardAuthTrans::getRefundableAmount(creditCardAuthTrans);

                if (refundableAmount > 0)
                {
                    return creditCardAuthTrans;
                }
            }
        }
        return creditCardAuthTransEmpty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRefundableAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the refundable amount for a given capture record in <c>CreditCardAuthTrans</c>.
    /// </summary>
    /// <param name = "_creditcardAuthTrans">The capture record.</param>
    /// <returns>The refundable amount</returns>
    public static AmountCur getRefundableAmount(CreditCardAuthTrans _creditcardAuthTrans)
    {
        return conPeek(RetailTransactionServiceOrders::calculateLinkedRefundProperties(_creditCardAuthTrans.RecId, false), 4);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRefundedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the refundaed amount for a given capture record in <c>CreditCardAuthTrans</c>.
    /// </summary>
    /// <param name = "_creditcardAuthTrans">The capture record.</param>
    /// <returns>The refunded amount.</returns>
    public static AmountCur getRefundedAmount(CreditCardAuthTrans _creditcardAuthTrans)
    {
        return conPeek(RetailTransactionServiceOrders::calculateLinkedRefundProperties(_creditCardAuthTrans.RecId, true), 4);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindValidPreApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_mcrCustPaymRecId">
    /// The customer payment record ID to find if available; otherwise, zero.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans mcrFindValidPreApproval(RecId _mcrCustPaymRecId)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        if (_mcrCustPaymRecId)
        {
            CreditCardAuthTrans::mcrUpdateExpiredApproval(_mcrCustPaymRecId);

            select creditCardAuthTrans
                where creditCardAuthTrans.MCRPaymRecId == _mcrCustPaymRecId
                        && creditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize
                        && !creditCardAuthTrans.ApprovalExpired
                        && !creditCardAuthTrans.ApprovalVoid
                        && creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;
        }

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindAvailablePreApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table ignoring ApprovalExpired property.
    /// </summary>
    /// <param name="_mcrCustPaymRecId">
    /// The customer payment record ID to find if available; otherwise, zero.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans mcrFindAvailablePreApproval(RecId _mcrCustPaymRecId)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        if (_mcrCustPaymRecId)
        {
            CreditCardAuthTrans::mcrUpdateExpiredApproval(_mcrCustPaymRecId);

            select creditCardAuthTrans
                where creditCardAuthTrans.MCRPaymRecId == _mcrCustPaymRecId
                        && creditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize
                        && !creditCardAuthTrans.ApprovalVoid
                        && creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;
        }

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindLatestVoidedApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table.
    /// </summary>
    /// <param name="_mcrCustPaymRecId">
    /// The record ID of the payment record to find the latest voided authorization.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.
    /// </returns>
    static CreditCardAuthTrans mcrFindLatestVoidedApproval(RecId _mcrCustPaymRecId, boolean _forUpdate = false)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        if (_mcrCustPaymRecId)
        {
            creditCardAuthTrans.selectForUpdate(_forUpdate);
            creditCardAuthTrans.selectLocked(_forUpdate);

            select firstonly creditCardAuthTrans
                order by LineNum desc
                where creditCardAuthTrans.MCRPaymRecId == _mcrCustPaymRecId
                   && creditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize
                   && creditCardAuthTrans.ApprovalVoid;
        }

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrUpdateExpiredApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the credit card approval expiration for the specified sales ID.
    /// </summary>
    /// <param name = "_mcrCustPaymRecId">The customer payment record to set the expiration of the credit card approval.</param>
    /// <exception cref="Exception::Error">
    /// RecID of <c>MCRCustPaymTable</c> required; throw error if not provided.
    /// </exception>
    [Replaceable] 
    static void mcrUpdateExpiredApproval(RecId _mcrCustPaymRecId)
    {
        UserConnection connection;
        CreditCardAuthTrans authTrans;
        CommerceHQEventSource eventWriter = CommerceHQEventSource::Log;

        if (_mcrCustPaymRecId)
        {
            connection = new UserConnection();

            try
            {
                authTrans.setConnection(connection);
                connection.ttsbegin();
                while select forupdate authTrans
                    where authTrans.MCRPaymRecId == _mcrCustPaymRecId &&
                        authTrans.ApprovalType == CreditCardOperation::Authorize &&
                        !authTrans.ApprovalExpired &&
                        authTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
                {
                    if (CreditCardAuthTrans::checkApprovalCanExpire(authTrans, true))
                    {
                        CreditCardPreapprovalLastNoOfDays preapprovalDuration = authTrans.getPreapprovalDurationDays();
                        if (DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) - DateTimeUtil::date(authTrans.ApprovedDateTime) > preapprovalDuration)
                        {
                            eventWriter.EventWriteUpdatePaymentLineAuthorizationToExpired(_mcrCustPaymRecId, authTrans.RecId);
                            authTrans.ApprovalExpired = true;
                            authTrans.update();
                        }
                    }
                }
                connection.ttscommit();
            }
            finally
            {
                connection.finalize();
            }
        }
        else
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settlePreapprovalTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the credit card transaction.
    /// </summary>
    /// <param name="_authTransRecId">
    /// The credit card history record for which to set the status as settled.
    /// </param>
    /// <param name="_custInvoiceId">
    /// The customer invoice ID to close; optional.
    /// </param>
    static void settlePreapprovalTransaction(RefRecId _authTransRecId, CustInvoiceId _custInvoiceId = '')
    {
        UserConnection connection = new UserConnection();
        CreditCardAuthTrans authTrans;

        try
        {
            authTrans.setConnection(connection);

            connection.ttsbegin();

            select firstonly forupdate authTrans
                where authTrans.RecId == _authTransRecId;

            if (authTrans)
            {
                authTrans.ProcessorStatus = CreditCardProcessorStatus::Settled;
                authTrans.SalesInvoiceId = _custInvoiceId;
                authTrans.update();
            }

            connection.ttscommit();
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVoidApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Voids the preapproval of credit card transactions.
    /// </summary>
    /// <param name="_authTransRecId">
    /// The credit card history record to mark as voided.
    /// </param>
    static void setVoidApproval(RefRecId _authTransRecId)
    {
        UserConnection connection = new UserConnection();
        CreditCardAuthTrans authTrans;

        try
        {
            authTrans.setConnection(connection);

            connection.ttsbegin();

            select firstonly forupdate authTrans
                where authTrans.RecId == _authTransRecId;

            if (authTrans)
            {
                authTrans.ApprovalVoid = NoYes::Yes;
                authTrans.update();
            }

            connection.ttscommit();
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    public static TxtNotExist txtNotExist()
    {
        return "@SYS102169";
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExpiredApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the credit card approval expiration for the specified sales ID.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID to set the credit card approval expiration for.
    /// </param>
    [Replaceable(true)]
    public static void updateExpiredApproval(SalesId _salesId)
    {
        UserConnection connection = new UserConnection();
        CreditCardAuthTrans authTrans;

        try
        {
            authTrans.setConnection(connection);

            connection.ttsbegin();

            while select forupdate authTrans
                where authTrans.SalesId == _salesId &&
                    authTrans.ApprovalType == CreditCardOperation::Authorize &&
                    !authTrans.ApprovalExpired &&
                    authTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
            {
                if (CreditCardAuthTrans::checkApprovalCanExpire(authTrans, true))
                {
                    CreditCardPreapprovalLastNoOfDays preapprovalDuration = authTrans.getPreapprovalDurationDays();
                    if (DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) - DateTimeUtil::date(authTrans.ApprovedDateTime) > preapprovalDuration)
                    {
                        authTrans.ApprovalExpired = true;
                        authTrans.update();
                    }
                }
            }

            connection.ttscommit();
        }
        finally
        {
            connection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAuthorizationExpired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the credit card approval expiration to TRUE for the specified creditCardAuthTrans authorization.
    /// </summary>
    /// <param name="_authTransToExpireRecId">The RecId for the CreditCardAuthTrans to expire.</param>
    /// <returns>A boolean with the rersult (True/false) of the operation.</returns>
    static boolean setAuthorizationExpired(RefRecId _authTransToExpireRecId)
    {
        UserConnection connection = new UserConnection();
        CreditCardAuthTrans authTrans;
        boolean retVal = false;
        CommerceHQEventSource eventWriter = CommerceHQEventSource::Log;
        
        try
        {
            authTrans.setConnection(connection);

            connection.ttsbegin();

            select firstonly forupdate authTrans
                where authTrans.RecId == _authTransToExpireRecId &&
                    authTrans.ApprovalType == CreditCardOperation::Authorize &&
                    !authTrans.ApprovalExpired &&
                    authTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;

            if (authTrans)
            {
                if (CreditCardAuthTrans::checkApprovalCanExpire(authTrans, false))
                {
                    eventWriter.EventWriteUpdatePaymentAuthorizationToExpired(authTrans.RecId);
                    ttsbegin;
                    authTrans.ApprovalExpired = true;
                    authTrans.update();
                    ttscommit;

                    retVal = true;
                }
                else
                {
                    retVal = false;
                }
            }
            else
            {
                retVal = false;
            }

            connection.ttscommit();
        }
        finally
        {
            connection.finalize();
        }

        return (retVal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrphanOrDuplicateCreditCardAuthTransCaptureRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find Orphan or duplicate captures for the given sales id.
    /// </summary>
    /// <param name="_salesId">The Sales Id.</param>
    /// <param name="_custInvoiceJour">The CustInvoiceJour.</param>
    /// <param name="_amount">Optional amount to capture. If 0, capture remaining balance for the invoice.</param>
    /// <returns>The <c>CreditCardAuthTrans</c> record for the orphan / duplicate capture, if it is found.</returns>
    internal static CreditCardAuthTrans findOrphanOrDuplicateCreditCardAuthTransCaptureRecord(SalesId _salesId, CustInvoiceJour _custInvoiceJour, Amount _amount = 0)
    {
        CreditCardAuthTrans duplicateOrOrphanCaptureRecord;
        boolean ret = true;

        if (CreditCardAuthTrans::isPaymentDuplicationProtectionFeatureEnabled())
        {
            Amount amountToCapture = (_amount > 0 ? _amount : _custInvoiceJour.remainAmountToBePaid());

            duplicateOrOrphanCaptureRecord = CreditCardAuthTrans::findDuplicateCreditCardAuthTrans(_salesId, _custinvoicejour.InvoiceId, amountToCapture);
            
            if (!duplicateOrOrphanCaptureRecord.RecId)
            {
                duplicateOrOrphanCaptureRecord = CreditCardAuthTrans::findOrphanCreditCardAuthTrans(_salesId, amountToCapture);
            }

            // Validate the orphan / duplicate record
            if (duplicateOrOrphanCaptureRecord)
            {
                SalesTable salesTable = SalesTable::find(_salesId);
                MCRCustPaymTable mcrCustPaymTable = MCRCustPaymTable::findByRecID(duplicateOrOrphanCaptureRecord.MCRPaymRecId);
                CreditCardCust tokenFromOrphanCapture, tokenFromCurrentCapture;

                // Find the credit card tokens used in both transactions (Current and orphan)
                tokenFromOrphanCapture = CreditCardCust::findByUniqueCardId(duplicateOrOrphanCaptureRecord.UniqueCardId);

                // Use MCRCustPaymentTable if found
                if (mcrCustPaymTable.PaymInfoRecId)
                {
                    tokenFromCurrentCapture = CreditCardCust::find(mcrCustPaymTable.PaymInfoRecId);
                }
                else
                {
                    // Otherwise fallback to reference from sales table
                    tokenFromCurrentCapture = CreditCardCust::find(salesTable.CreditCardCustRefId);
                }

                // Validate Requirements for an orphan / duplicate record
                ret = (duplicateOrOrphanCaptureRecord.ApprovalAmountCur == amountToCapture) &&
                      (tokenFromOrphanCapture.RecId == tokenFromCurrentCapture.RecId);
            }
            else
            {
                ret = false;
            }

        }

        return (ret ? duplicateOrOrphanCaptureRecord : null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentDuplicationProtectionFeatureEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check to see if duplication protection is enabled or not.
    /// </summary>
    /// <returns>True if <c>DisableCreditCardPaymentDuplicationProtectionFlight</c> is enabled, if not then check for retail duplication protection feature.</returns>
    public static boolean isPaymentDuplicationProtectionFeatureEnabled()
    {
        // DisableCreditCardPaymentDuplicationProtectionFlight should be enabled by default (PublicPreview)
        if (DisableCreditCardPaymentDuplicationProtectionFlight::isEnabled())
        {
            return true;
        }

        // Test if feature is disabled and abort duplication protection in case it is positive
        return RetailPaymentsFeatureControl::isApplyRetailPaymentsDuplicationProtectionOnInvoicingFeatureEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrphanCreditCardAuthTrans</Name>
				<Source><![CDATA[
    internal static CreditCardAuthTrans findOrphanCreditCardAuthTrans(SalesId _salesId, Amount _amount)
    {
        CreditCardAuthTrans orphanCaptureRecord;
        CustInvoiceJour custInvoiceJour;

        // Find capture records for given SalesId where the InvoiceId doesn't exist on the custInvoiceJour table
        select firstonly forupdate orphanCaptureRecord
                order by orphanCaptureRecord.RecId desc
                where    orphanCaptureRecord.SalesId == _salesId &&
                         orphanCaptureRecord.SalesInvoiceId != '' &&
                         orphanCaptureRecord.ApprovalAmountCur == _amount &&
                         (orphanCaptureRecord.ApprovalType == CreditCardOperation::AuthorizeAndCapture ||
                          orphanCaptureRecord.ApprovalType == CreditCardOperation::CaptureAfterAuthorize) &&
                          orphanCaptureRecord.ProcessorStatus == CreditCardProcessorStatus::Approved
                notexists join SalesId, InvoiceId from custinvoicejour
                where orphanCaptureRecord.SalesId == custInvoiceJour.SalesId
                   && orphanCaptureRecord.SalesInvoiceId == custinvoicejour.InvoiceId;

        return orphanCaptureRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDuplicateCreditCardAuthTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for duplicate credit card authorization transactions for a sales order, invoice and amount
    /// </summary>
    /// <param name = "_salesId">The sales identifier.</param>
    /// <param name = "_invoiceId">The invoice identifier.</param>
    /// <param name = "_amount">The amount.</param>
    /// <returns>The duplicate credit card authorization transaction if found!</returns>
    internal static CreditCardAuthTrans findDuplicateCreditCardAuthTrans(SalesId _salesId, SalesInvoiceId _invoiceId, Amount _amount)
    {
        CreditCardAuthTrans duplicateCaptureRecord;

        // Find duplicate capture record for given SalesId and InvoiceId
        select firstonly forupdate RecId, SalesId, SalesInvoiceId, ApprovalAmountCur, UniqueCardId, MCRPaymRecId from duplicateCaptureRecord
                order by duplicateCaptureRecord.RecId desc
                where    duplicateCaptureRecord.SalesId == _salesId &&
                         duplicateCaptureRecord.SalesInvoiceId == _invoiceId &&
                         duplicateCaptureRecord.ApprovalAmountCur == _amount &&
                         (duplicateCaptureRecord.ApprovalType == CreditCardOperation::AuthorizeAndCapture ||
                          duplicateCaptureRecord.ApprovalType == CreditCardOperation::CaptureAfterAuthorize);

        // Edge case, there might be two or more authorizations for the same amount or more which has not been captured yet.
        if (duplicateCaptureRecord)
        {
            CreditCardAuthTrans unsettledAuthorizationRecord;

            // Are all the authorizations for this amount have a status of settled
            select firstonly RecId from unsettledAuthorizationRecord
                where unsettledAuthorizationRecord.SalesId == _salesId &&
                    unsettledAuthorizationRecord.SalesInvoiceId == '' &&
                    unsettledAuthorizationRecord.ApprovalAmountCur >= _amount &&
                    unsettledAuthorizationRecord.ApprovalType == CreditCardOperation::Authorize &&
                    unsettledAuthorizationRecord.ProcessorStatus == CreditCardProcessorStatus::Approved &&
                    unsettledAuthorizationRecord.ApprovalVoid == NoYes::No;

            if (unsettledAuthorizationRecord)
            {
                CommerceHQEventSource eventSource = CommerceHQEventSource::Log;
                eventSource.EventWritePaymentsClearedDuplicateCreditCardAuthTrans(duplicateCaptureRecord.RecId, unsettledAuthorizationRecord.RecId);

                // Oustanding authorization that needs to be captured
                duplicateCaptureRecord.clear();
            }
        }

        return duplicateCaptureRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalReferencedAuthorizations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the total authorization approved amount for the SalesId and Authorization reference identifier.
    /// </summary>
    /// <param name = "_salesId">The sales id.</param>
    /// <param name = "_referenceId">The authorization reference Id.</param>
    /// <returns>The total approved amount for the sales order and authorization reference.</returns>
    internal static AmountCur totalReferencedAuthorizations(SalesId _salesId, CreditCardAuthorization _referenceId)
    {
        CreditCardAuthTrans authTrans;

        select sum(ApprovalAmountCur) from authTrans
            where authTrans.SalesId == _salesId
                && authTrans.Authorization == _referenceId
                && authTrans.ApprovalType == CreditCardOperation::Authorize
                && ( authTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
                    || authTrans.ProcessorStatus == CreditCardProcessorStatus::Settled);

        return authTrans.ApprovalAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalReferencedCaptureAndVoids</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the total capture/void approved amount for the SalesId and Authorization reference identifier.
    /// </summary>
    /// <param name = "_salesId">The sales id.</param>
    /// <param name = "_originalAuthRecId">The original authorization RecId.</param>
    /// <returns>The total approved amount for the sales order and authorization reference.</returns>
    internal static AmountCur totalReferencedCaptureAndVoids(SalesId _salesId, RecId _originalAuthRecId)
    {
        CreditCardAuthTrans authTrans;

        if (_originalAuthRecId != 0)
        {
            select sum(ApprovalAmountCur) from authTrans
            where authTrans.SalesId == _salesId
                && authTrans.OrigAuthRecId == _originalAuthRecId
                && ( authTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize
                    || authTrans.ApprovalType == CreditCardOperation::Void)
                && ( authTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
                    || authTrans.ProcessorStatus == CreditCardProcessorStatus::Settled);
        }

        return authTrans.ApprovalAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalReferencedCaptures</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the total capture approved amount for the SalesId and Authorization reference identifier.
    /// </summary>
    /// <param name = "_salesId">The sales id.</param>
    /// <param name = "_referenceId">The authorization reference Id.</param>
    /// <returns>The total approved amount for the sales order and authorization reference.</returns>
    internal static AmountCur totalReferencedCaptures(SalesId _salesId, CreditCardAuthorization _referenceId)
    {
        CreditCardAuthTrans authTrans;

        select sum(ApprovalAmountCur) from authTrans
            where authTrans.SalesId == _salesId
                && authTrans.Authorization == _referenceId
                && authTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize
                && authTrans.ProcessorStatus == CreditCardProcessorStatus::Approved;

        return authTrans.ApprovalAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReferencedSettledAuthorization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find transactions that are for a sales order and have been settled and have the correct reference identifier.
    /// </summary>
    /// <param name = "_salesId">The sales identifier.</param>
    /// <param name = "_referenceId">The reference identifier.</param>
    /// <param name="_forUpdate">A Boolean value that indicates whether to read the record for update; optional.</param>
    /// <returns>A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.</returns>
    internal static CreditCardAuthTrans findReferencedSettledAuthorization(SalesId _salesId, CreditCardAuthorization _referenceId, boolean _forUpdate = false)
    {
        CreditCardAuthTrans authTrans;
        authTrans.selectForUpdate(_forUpdate);
        authTrans.selectLocked(_forUpdate);

        select firstonly forupdate authTrans
            where authTrans.SalesId == _salesId
                && authTrans.ApprovalType == CreditCardOperation::Authorize
                && authTrans.Authorization == _referenceId
                && authTrans.ApprovalVoid == NoYes::No
                && authTrans.ApprovalExpired == NoYes::No
                && authTrans.ProcessorStatus == CreditCardProcessorStatus::Settled;

        return authTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkApprovalCanExpire</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the indicator for skipping approval expiration.
    /// </summary>
    /// <param name = "_creditcardAuthTrans">The <c>CreditCardAuthTrans</c> table buffer of the credit card operation.</param>
    /// <param name = "_byLastNoOfDays">A Boolean value that indicates if the expiration is callled mannually or reach the expiration date.</param>
    /// <returns>True if the specified record can expire; otherwise, false.</returns>
    [Replaceable(true)]
    public static boolean checkApprovalCanExpire(CreditCardAuthTrans _creditcardAuthTrans, boolean _byLastNoOfDays)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLatestAuthorization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table,
    /// where TransactionType == CreditCardTransactionType::Transactional and ApprovalType = CreditCardOperation::Authorize.
    /// </summary>
    /// <param name = "_mcrPaymRecId">RecId in McrCustPaymTable.</param>
    /// <param name="_forUpdate">A Boolean value that indicates whether to read the record for update; optional.</param>
    /// <returns>A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.</returns>
    internal static CreditCardAuthTrans findLatestAuthorization(RefRecId _mcrPaymRecId, boolean _forUpdate = false)
    {
        CreditCardAuthTrans creditCardAuthTransLocal;

        if (_mcrPaymRecId)
        {
            creditCardAuthTransLocal.selectForUpdate(_forUpdate);

            select firstonly creditCardAuthTransLocal
                order by LineNum desc
                where creditCardAuthTransLocal.MCRPaymRecId == _mcrPaymRecId
                    && creditCardAuthTransLocal.TransactionType == CreditCardTransactionType::Transactional
                    && (creditCardAuthTransLocal.ApprovalType == CreditCardOperation::Authorize
                    || creditCardAuthTransLocal.ApprovalType == CreditCardOperation::AuthorizeAndCapture);
        }

        return creditCardAuthTransLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFinalAuthorizationStatusForIncrementalCapture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the status of last authorization line for a call center sales order.
    /// </summary>
    /// <param name = "_mcrCustPaymTable"> McrCustPaymTable buffer. </param>
    public static void setFinalAuthorizationStatusForIncrementalCapture(MCRCustPaymTable _mcrCustPaymTable)
    {
        if (RetailIncrementalCaptureFeatureExposure::isEnabled()
            && FeatureStateProvider::isFeatureEnabled(RetailPaymentsAdvancedDeclinedAuthorizationsFeature::instance())
            && FeatureStateProvider::isFeatureEnabled(RetailPaymentsAdvancedDeclinedAuthorizationsDuringPickAndPackFeature::instance())
            && (_mcrCustPaymTable.Amount - _mcrCustPaymTable.PostedAmount == 0)
            )
        {
            CreditCardAuthTrans creditCardAuthTransDeclined;
            CreditCardAuthTrans lastCreditCardAuthTrans;

            // Retrieve original declined authorization/post authorization
            select firstonly creditCardAuthTransDeclined
                order by LineNum desc
                where creditCardAuthTransDeclined.MCRPaymRecId == _mcrCustPaymTable.RecId
                    && (creditCardAuthTransDeclined.ApprovalType == CreditCardOperation::Authorize
                    || creditCardAuthTransDeclined.ApprovalType == CreditCardOperation::AuthorizeAndCapture)
                    && creditCardAuthTransDeclined.ProcessorStatus == CreditCardProcessorStatus::Declined;

            select forupdate lastCreditCardAuthTrans
                order by LineNum desc
                where lastCreditCardAuthTrans.MCRPaymRecId == _mcrCustPaymTable.RecId
                    && lastCreditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize
                    && lastCreditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
                    && lastCreditCardAuthTrans.ApprovalVoid == NoYes::No;

            if (lastCreditCardAuthTrans.supportsIncrementCapture() && creditCardAuthTransDeclined)
            {
                lastCreditCardAuthTrans.ProcessorStatus = CreditCardProcessorStatus::Settled;

                lastCreditCardAuthTrans.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settlePreapprovalTransactionWithUserConnection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the credit card transaction with a given user connection.
    /// </summary>
    /// <param name = "_authTransRecId">The credit card history record for which to set the status as settled.</param>
    /// <param name = "_userConnection">The given user connection</param>
    /// <param name = "_custInvoiceId">The customer invoice ID to close; optional.</param>
    internal static void settlePreapprovalTransactionWithUserConnection(RefRecId _authTransRecId, UserConnection _userConnection, CustInvoiceId _custInvoiceId = '')
    {        
        CreditCardAuthTrans authTrans;

        authTrans.setConnection(_userConnection);

        select firstonly forupdate authTrans
            where authTrans.RecId == _authTransRecId;

        if (authTrans)
        {
            authTrans.ProcessorStatus = CreditCardProcessorStatus::Settled;
            authTrans.SalesInvoiceId = _custInvoiceId;
            authTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findValidCaptureOrRefundFromInvoice</Name>
				<Source><![CDATA[
    internal static CreditCardAuthTrans findValidCaptureOrRefundFromInvoice(SalesId _salesId, InvoiceId _invoiceId)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        select firstonly creditCardAuthTrans
            where creditCardAuthTrans.SalesInvoiceId == _invoiceId
                && creditCardAuthTrans.SalesId == _salesId
                && creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
                && (creditCardAuthTrans.ApprovalType == CreditCardOperation::AuthorizeAndCapture
                    || creditCardAuthTrans.ApprovalType == CreditCardOperation::CaptureAfterAuthorize
                    || creditCardAuthTrans.ApprovalType == CreditCardOperation::Refund);

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustomerOrderCreditPaymentRecordLinkRestored</Name>
				<Source><![CDATA[
    /// <summary>
    /// Detects any missing customer payment records corresponding to order credit(s) for the sales order.
    /// If a missing record is detected, then the customer payment record is restored.
    /// </summary>
    /// <param name = "_mcrCustCreditTable">The order credit.</param>
    /// <param name = "_salesTable">The sales order.</param>
    /// <returns>True if a customer payment record was restored; otherwise, false.</returns>
    internal static boolean isCustomerOrderCreditPaymentRecordLinkRestored(McrCustCreditTable _mcrCustCreditTable, SalesTable _salesTable)
    {
        boolean isPaymentRecordRestored;

        if (_mcrCustCreditTable.RecId != 0
            && _salesTable.RecId != 0
            && !RetailPaymentsOrderCreditsMissingPaymentRecordFlight::instance().isEnabled())
        {
            return isPaymentRecordRestored;
        }

        CreditCardAuthTrans successfulRefundRecord;
        McrCustCreditTable orderCreditRecord;
        McrCustPaymTable customerPaymentRecord;

        // Check if a refund transaction is linked to the customer order credit and the customer payment record.
        while select SalesId, ApprovalType, ProcessorStatus, SalesInvoiceId, McrPaymRecId, ApprovalAmountCur from successfulRefundRecord
            order by LineNum desc
            where successfulRefundRecord.SalesId == _salesTable.SalesId
                && successfulRefundRecord.ApprovalType == CreditCardOperation::Refund
                && successfulRefundRecord.ProcessorStatus == CreditCardProcessorStatus::Approved
                && successfulRefundRecord.SalesInvoiceId == ''
            join OrigSalesId, CreditId, TotalCredit, CcSettlementRecId, OrigPaymId from orderCreditRecord
            where orderCreditRecord.OrigSalesId == _salesTable.SalesId
                && orderCreditRecord.CreditId != _mcrCustCreditTable.CreditId
                && abs(orderCreditRecord.TotalCredit) == abs(successfulRefundRecord.ApprovalAmountCur)
                && (orderCreditRecord.CcSettlementRecId == successfulRefundRecord.RecId || orderCreditRecord.CcSettlementRecId == 0)
                && orderCreditRecord.OrigPaymId != 0
            notexists join customerPaymentRecord
            where customerPaymentRecord.RefRecId == _salesTable.RecId
                && customerPaymentRecord.RecId == successfulRefundRecord.McrPaymRecId
        {
            // A credit card refund transaction exists for a customer order credit. However, the customer payment record is missing.
            // Create a customer payment record.
            McrCustPaymTable McrCustPaymTableForCorrection = McrCustPaymTable::findByRecId(orderCreditRecord.OrigPaymId);
            McrCustPaymTableForCorrection.OrigRefundRecId = orderCreditRecord.OrigPaymId;
            McrCustPaymTableForCorrection.Amount = successfulRefundRecord.ApprovalAmountCur;
            McrCustPaymTableForCorrection.PostedAmount = successfulRefundRecord.ApprovalAmountCur;
            McrCustPaymTableForCorrection.Status = McrCustPaymStatus::Posted;

            ttsbegin;
            McrCustPaymTableForCorrection.insert();
            McrCustPaymTableForCorrection.reread();

            // Link the credit card refund transaction to the newly created customer payment record.
            CreditCardAuthTrans creditCardAuthTransForCorrection;
            update_recordset creditCardAuthTransForCorrection
                setting McrPaymRecId = McrCustPaymTableForCorrection.RecId
                where creditCardAuthTransForCorrection.RecId == successfulRefundRecord.RecId;
            ttscommit;

            // Ensure the link the between card transaction and customer credit exists.
            if (orderCreditRecord.ccSettlementRecId == 0)
            {
                orderCreditRecord.ccSettlementRecId = successfulRefundRecord.RecId;
            }

            isPaymentRecordRestored = true;
        }

        return isPaymentRecordRestored;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLatestReauthorization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds latest reauthorization record.
    /// </summary>
    /// <param name = "_mcrPaymRecId">The record ID of the payment.</param>
    /// <returns>A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.</returns>
    internal static CreditCardAuthTrans findLatestReauthorization(MCRCustPaymTableRecID _mcrPaymRecId)
    {
        CreditCardAuthTrans creditCardAuthTrans;

        // we should only look for auth adjustments that were created after the last authorization
        CreditCardAuthTrans lastestAuth = CreditCardAuthTrans::findLatestAuthorization(_mcrPaymRecId);

        select firstonly creditCardAuthTrans
            order by ApprovedDateTime desc
            where creditCardAuthTrans.MCRPaymRecId == _mcrPaymRecId &&
                creditCardAuthTrans.ApprovalType == CreditCardOperation::Reauthorize &&
                creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved &&
                creditCardAuthTrans.ApprovedDateTime > lastestAuth.ApprovedDateTime;

        return creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLatestValidAuthorization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CreditCardAuthTrans</c> table,
    /// where TransactionType == CreditCardTransactionType::Transactional and ApprovalType = CreditCardOperation::Authorize
    /// and has not yet expired or voided.
    /// </summary>
    /// <param name = "_mcrPaymRecId">RecId in McrCustPaymTable.</param>
    /// <param name="_forUpdate">A Boolean value that indicates whether to read the record for update; optional.</param>
    /// <returns>A record in the <c>CreditCardAuthTrans</c> table; otherwise, an empty record.</returns>
    internal static CreditCardAuthTrans findLatestValidAuthorization(MCRCustPaymTableRecID _mcrPaymRecId, boolean _forUpdate = false)
    {
        CreditCardAuthTrans creditCardAuthTransLocal;

        if (_mcrPaymRecId)
        {
            creditCardAuthTransLocal.selectForUpdate(_forUpdate);

            select firstonly creditCardAuthTransLocal
                order by LineNum desc
                where creditCardAuthTransLocal.MCRPaymRecId == _mcrPaymRecId
                    && creditCardAuthTransLocal.TransactionType == CreditCardTransactionType::Transactional
                    && creditCardAuthTransLocal.ApprovalType == CreditCardOperation::Authorize
                    && (creditCardAuthTransLocal.ProcessorStatus == CreditCardProcessorStatus::Settled
                    || creditCardAuthTransLocal.ProcessorStatus == CreditCardProcessorStatus::Approved)
                    && !creditCardAuthTransLocal.ApprovalExpired
                    && !creditCardAuthTransLocal.ApprovalVoid;
        }

        return creditCardAuthTransLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCapturedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates captured amount for payment.
    /// </summary>
    /// <param name = "_mcrPaymRecId">RecId in McrCustPaymTable.</param>
    /// <returns>A captured amount for payment.</returns>
    internal static AmountCur calculateCapturedAmount(MCRCustPaymTableRecID _mcrPaymRecId)
    {
        CreditCardAuthTrans capturedPayment;
        select sum(ApprovalAmountCur) from capturedPayment
                where (capturedPayment.ApprovalType == CreditCardOperation::CaptureAfterAuthorize
                || capturedPayment.ApprovalType == CreditCardOperation::AuthorizeAndCapture)
                && capturedPayment.MCRPaymRecId == _mcrPaymRecId
                && capturedPayment.ProcessorStatus == CreditCardProcessorStatus::Approved;

        return capturedPayment.ApprovalAmountCur;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>CreditCard</ConfigurationKey>
	<DeveloperDocumentation>@SYS126885</DeveloperDocumentation>
	<Label>@SYS101657</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>SalesId</TitleField1>
	<TitleField2>ApprovalType</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>RecId</ClusteredIndex>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<Modules>AccountsReceivable</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SalesId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrigSalesId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Authorization</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovedDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalExpired</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalAmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProcessorStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalVoid</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SalesInvoiceId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Other</Name>
			<Label>@SYS1284</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SalesInvoiceId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTypeName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardProcessors</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@SYS9039</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OrigSalesId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProcessorStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Authorization</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovedDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalAmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AddressVerificationResult</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CVCResult</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalExpired</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalVoid</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SalesInvoiceId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>displayProcessorsName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProcessorReference</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProcessorPayment</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PaymInfo</Name>
			<Label>@SYS100269</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MCRInvoiceId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MCRJournalNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MCRPaymRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MCRCustPaymSchedName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrigAuthRecId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PaymentArchive</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IsPaymentDataArchived</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovedDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AddressVerificationResult</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CreditCardAddressVerificationResult</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ApprovalAmountCur</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SYS6928</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ApprovalExpired</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS107504</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ApprovalType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CreditCardOperation</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ApprovalVoid</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS6127</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ApprovedDateTime</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ApprovedDateTime</ExtendedDataType>
			<Label>@SYS7402</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Authorization</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CreditCardAuthorization</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CardTokenRequest</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CreditCardPaymentCardToken</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CardTokenResult</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CreditCardPaymentCardToken</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CreditCardNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CreditCardNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CreditCardProcessors</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CreditCardProcessorsId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CreditCardTypeName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CreditCardTypeName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencyCode</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CVCResult</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CreditCardMSCVCResultCode</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Description</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CreditCardApprovalRejectReason</ExtendedDataType>
			<Label>@SYS6303</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LineNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LineNum</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MCRCustPaymSchedName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustPaymSchedId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MCRInvoiceId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>MCRPayment</ConfigurationKey>
			<ExtendedDataType>CustInvoiceId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MCRJournalNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>MCRPayment</ConfigurationKey>
			<ExtendedDataType>LedgerJournalId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>MCRPaymRecId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>MCRCustPaymTableRecID</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProcessorStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CreditCardProcessorStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RefundStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>CreditCardRefundStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SalesId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SalesId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SalesInvoiceId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SalesInvoiceId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>UniqueCardId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CreditCardUniqueCardId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OrigSalesId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SalesId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OrigAuthRecId</Name>
			<ExtendedDataType>CreditCardAuthTransRefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TransactionType</Name>
			<HelpText>@Retail:CreditCardTransactionTypeHelpText</HelpText>
			<Label>@SYS21201</Label>
			<EnumType>CreditCardTransactionType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MCRTrackingId</Name>
			<ExtendedDataType>MCRPaymentTrackingId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProcessorReference</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailProcessorReference</ExtendedDataType>
			<Label>@Retail:ProcessorReference</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ApprovalCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailApprovalCode</ExtendedDataType>
			<Label>@Retail:ApprovalCode</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProcessorPayment</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailProcessorPaymentMethod</ExtendedDataType>
			<Label>@Retail:ProcessorPayment</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsPaymentDataArchived</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>NoYes</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>SalesCCApprovalIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>SalesId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ApprovalType</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SalesApprovalDateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>SalesId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ApprovedDateTime</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>MCRPaymRecIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>MCRPaymRecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SalesUniqueCardIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>MCRPayment</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>SalesId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>UniqueCardId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ApprovalType</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ApprovedDateIsArchivedIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ApprovedDateTime</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>IsPaymentDataArchived</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CreditCardProcessors</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS67903</EntityRelationshipRole>
			<RelatedTable>CreditCardProcessors</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CreditCardProcessors</Name>
					<Field>CreditCardProcessors</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CurrencyCode</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>CurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>MCRCustInvoiceId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustInvoiceTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MCRInvoiceId</Name>
					<Field>MCRInvoiceId</Field>
					<RelatedField>InvoiceId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>MCRCustPaymTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>MCRCustPaymTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MCRPaymRecId</Name>
					<Field>MCRPaymRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>MCRLedgerJournalTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LedgerJournalTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MCRJournalNum</Name>
					<SourceEDT>LedgerJournalId</SourceEDT>
					<Field>MCRJournalNum</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>MCRPaymSched</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PaymSched</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MCRCustPaymSchedName</Name>
					<SourceEDT>CustPaymSchedId</SourceEDT>
					<Field>MCRCustPaymSchedName</Field>
					<RelatedField>Name</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesInvoice</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>CustInvoiceJour</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>SalesInvoice</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SalesInvoiceId</Name>
					<SourceEDT>SalesInvoiceId</SourceEDT>
					<Field>SalesInvoiceId</Field>
					<RelatedField>InvoiceId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS126887</EntityRelationshipRole>
			<RelatedTable>SalesTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>SalesTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CreditCardAuthTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SalesId</Name>
					<SourceEDT>SalesId</SourceEDT>
					<Field>SalesId</Field>
					<RelatedField>SalesId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CreditCardAuthTrans</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CreditCardAuthTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrigAuthRecId</Name>
					<Field>OrigAuthRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>