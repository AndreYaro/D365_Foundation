<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjGroup</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ProjGroup extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accruedCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets, the ledger account for accrued loss that will be used by projects in this project
    /// group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that when set to true sets the ledger account for accrued loss to the value of the
    /// _<paramref name="ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for accrued loss.
    /// </param>
    /// <returns>
    /// The ledger account for accrued loss.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and _<paramref name="set" /> will be true if the user has entered anything in the
    /// control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountEst accruedCost(boolean _set,LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::AccruedCost);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedRevenueOnAccount</Name>
				<Source><![CDATA[
    edit ProjLedgerDimensionDefaultAccountFP accruedRevenueOnAccount(
        boolean       _set,
        LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::AccruedRevenueOnAccount);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedTurnoverProd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for accrued revenue minus production that will be
    /// used by projects in a project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for accrued revenue minus
    /// production to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for accrued revenue minus production.
    /// </param>
    /// <returns>
    /// The ledger account for accrued revenue minus production.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and the <paramref name="_set" /> value will be true if the user has entered
    /// anything in the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountFP accruedTurnoverProd(boolean       _set,
                                           LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::AccruedTurnoverProd);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedTurnoverProfit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for accrued revenue minus profit that will be used
    /// by projects in a project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for Accrued revenue minus profit
    /// to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for Accrued revenue minus Profit.
    /// </param>
    /// <returns>
    /// The ledger account for accrued revenue minus profit.
    /// </returns>
    /// <remarks>
    /// When tied to a control on a form, this method is automatically called every time that the form is
    /// redrawn, and the <paramref name="_set" /> value will be true if the user has entered anything in
    /// the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountFP accruedTurnoverProfit(boolean       _set,
                                             LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::AccruedTurnoverProfit);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedTurnoversalesValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for accrued revenue minus sales value that will be
    /// used by projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that when set to true sets the ledger account for accrued revenue minus sales value
    /// to the value of the _<paramref name="ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for Accrued revenue minus sales value.
    /// </param>
    /// <returns>
    /// The ledger account for accrued revenue minus sales value.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and _<paramref name="set" /> will be true if the user has entered anything in the
    /// control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountWIP accruedTurnoversalesValue(boolean       _set,
                                                 LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::SalesValue);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditDataGroupFixedPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the fixed price data group.
    /// </summary>
    /// <returns>
    /// true if the data group can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditDataGroupFixedPrice()
    {
        boolean ret;

        switch (this.ProjType)
        {
            case ProjType::TimeMaterial:
                ret = false;
                break;

            case ProjType::FixedPrice:
                ret = true;
                break;

            case ProjType::Investment:
                ret = false;
                break;

            case ProjType::Cost:
                ret = false;
                break;

            case ProjType::Internal:
                ret = false;
                break;

            case ProjType::Time:
                ret = false;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditDataGroupJournalizing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the journalizing data group.
    /// </summary>
    /// <returns>
    /// true if the data group can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditDataGroupJournalizing()
    {
        boolean ret;

        switch (this.ProjType)
        {
            case ProjType::TimeMaterial:
                ret = true;
                break;

            case ProjType::FixedPrice:
                ret = true;
                break;

            case ProjType::Investment:
                ret = true;
                break;

            case ProjType::Cost:
                ret = false;
                break;

            case ProjType::Internal:
                ret = true;
                break;

            case ProjType::Time:
                ret = false;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditDataGroupTimeMaterial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the time and materials data group.
    /// </summary>
    /// <returns>
    /// true if the data group can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in project group form
    /// </remarks>
    public boolean allowEditDataGroupTimeMaterial()
    {
        boolean ret;

        switch (this.ProjType)
        {
            case ProjType::TimeMaterial:
                ret = true;
                break;

            case ProjType::FixedPrice:
                ret = false;
                break;

            case ProjType::Investment:
                ret = false;
                break;

            case ProjType::Cost:
                ret = false;
                break;

            case ProjType::Internal:
                ret = false;
                break;

            case ProjType::Time:
                ret = false;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditDataGroupWipDefaults</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the WIPDefaults data group.
    /// </summary>
    /// <returns>
    /// true if the data group can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditDataGroupWipDefaults()
    {
        boolean ret;

        switch (this.ProjType)
        {
            case ProjType::TimeMaterial:
                ret = false;
                break;

            case ProjType::FixedPrice:
                ret = true;
                break;

            case ProjType::Investment:
                ret = true;
                break;

            case ProjType::Cost:
                ret = false;
                break;

            case ProjType::Internal:
                ret = false;
                break;

            case ProjType::Time:
                ret = false;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditDataMethodCostTransCostMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the post costs expense field
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditDataMethodCostTransCostMethod()
    {
        boolean ret;

        if (this.CostTransTurnover == NoYes::No)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditDataMethodItemTransCostMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the post costs item field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditDataMethodItemTransCostMethod()
    {
        boolean ret;

        if (this.ItemTransTurnover == NoYes::No)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldAccruedCostCategoryId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the accrued loss category ID field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldAccruedCostCategoryId()
    {
        boolean ret;

        if ((((this.ProjType == ProjType::FixedPrice)
            && (this.CompletePrincip == ProjCompletePrincip::CompletedContract))
            || (this.ProjType == ProjType::Investment))
            && (this.ForeseablesLosses)
            && (!this.AccruedCostCategoryId))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldCostTransTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the accrue revenue expense field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldCostTransTurnover()
    {
        boolean ret = true;

        if (this.CostTransCost == ProjLedgerStatus::BalanceSheet)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldEmplTransCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the post costs hour field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldEmplTransCost()
    {
        boolean ret;

        if (this.EmplTransTurnover == NoYes::No)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldEmplTransTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the accrue revenue hour field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldEmplTransTurnover()
    {
        boolean ret = true;

        if (this.EmplTransCost == ProjLedgerStatus::BalanceSheet ||
            this.EmplTransCost == ProjLedgerStatus::None)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldForeseablesLosses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the foreseeable losses field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldForeseablesLosses()
    {
        boolean ret;

        if (((this.ProjType == ProjType::FixedPrice) &&
                ((this.CompletePrincip == ProjCompletePrincip::CompletedContract) ||
                    (this.CompletePrincip == ProjCompletePrincip::CompletedPercentage)) &&
                    (this.SalesPriceMatchingPrincip == ProjSalesPriceMatchingPrincip::None)) ||
            ((this.ProjType == ProjType::Investment) &&
                (this.CompletePrincip == ProjCompletePrincip::None)))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldInvoicePosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the on-account invoicing field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldInvoicePosting()
    {
        boolean ret;

        switch (this.ProjType)
        {
            case ProjType::TimeMaterial:
                ret = true;
                break;

            case ProjType::FixedPrice:
                if ((this.CompletePrincip == ProjCompletePrincip::CompletedPercentage) &&
                    (this.SalesPriceMatchingPrincip == ProjSalesPriceMatchingPrincip::MarkupPercentTotal || this.SalesPriceMatchingPrincip == ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine) &&
                    (this.MatchingPrincip == ProjMatchingPrincip::SalesValue))
                {
                    ret = false;
                }
                else if (this.CompletePrincip == ProjCompletePrincip::CompletedContract ||
                    this.CompletePrincip == ProjCompletePrincip::CompletedPercentage)
                {
                    ret = true;
                }
                break;

            case ProjType::Investment:
                ret = false;
                break;

            case ProjType::Cost:
                ret = false;
                break;

            case ProjType::Internal:
                ret = false;
                break;

            case ProjType::Time:
                ret = false;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldItemTransTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the accrue revenue item field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldItemTransTurnover()
    {
        boolean ret = true;

        if (this.ItemTransCost == ProjLedgerStatus::BalanceSheet)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldMatchingPrincip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the matching principle field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldMatchingPrincip()
    {
        boolean ret = true;

        switch (this.CompletePrincip)
        {
            case ProjCompletePrincip::None:
            case ProjCompletePrincip::NoWIP:
                ret = false;
                break;

            case ProjCompletePrincip::CompletedContract:
            case ProjCompletePrincip::CompletedPercentage:
                ret = (this.SalesPriceMatchingPrincip == ProjSalesPriceMatchingPrincip::None ? true : false);
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldProductionCategoryIdExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements <c>ProjGroup::allowEditFieldProductionCategoryId</c> when matching principle has been extended.
    /// </summary>
    /// <param name = "_matchingPrincip">Extended value of matching principle.</param>
    /// <returns>true if the users can modify the production category ID field; otherwise, false.</returns>
	[Replaceable]
	protected boolean allowEditFieldProductionCategoryIdExt(ProjMatchingPrincip _matchingPrincip)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldProductionCategoryId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the production category ID field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldProductionCategoryId()
    {
        boolean ret = true;

        switch (this.MatchingPrincip)
        {
            case ProjMatchingPrincip::None:
                ret = false;
                break;

            case ProjMatchingPrincip::SalesValue:
                ret = false;
                break;

            case ProjMatchingPrincip::ProductionProfit:
                ret = true;
                break;

            case ProjMatchingPrincip::NoMatching:
                ret = false;
                break;

            default:
                ret = this.allowEditFieldProductionCategoryIdExt(this.MatchingPrincip);
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldProfitCategoryIdExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements <c>ProjGroup::allowEditFieldProfitCategoryId</c> when matching principle has been extended.
    /// </summary>
    /// <param name = "_matchingPrincip">Extended value of matching principle.</param>
    /// <returns>true if the user can modify the profit category ID field; otherwise, false.</returns>
    [Replaceable]
	protected boolean allowEditFieldProfitCategoryIdExt(ProjMatchingPrincip _matchingPrincip)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldProfitCategoryId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the profit category ID field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldProfitCategoryId()
    {
        boolean ret = true;

        switch (this.MatchingPrincip)
        {
            case ProjMatchingPrincip::None  :
                ret = false;
                break;

            case ProjMatchingPrincip::SalesValue:
                ret = false;
                break;

            case ProjMatchingPrincip::ProductionProfit:
                ret = true;
                break;

            case ProjMatchingPrincip::NoMatching:
                ret = false;
                break;

            default:
                ret = this.allowEditFieldProfitCategoryIdExt(this.MatchingPrincip);
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldSalesValueCategoryIdExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements <c>ProjGroup::allowEditFieldSalesValueCategoryId</c> when matching principle has been extended.
    /// </summary>
    /// <param name = "_matchingPrincip">Extended value of matching principle.</param>
    /// <returns>true if the users can modify the sales value category ID field; otherwise, false.</returns>
    [Replaceable]
    protected boolean allowEditFieldSalesValueCategoryIdExt(ProjMatchingPrincip _matchingPrincip)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditFieldSalesvalueCategoryId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether users can modify the sales value category ID field.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used in the project group form.
    /// </remarks>
    public boolean allowEditFieldSalesvalueCategoryId()
    {
        boolean ret = true;

        switch (this.MatchingPrincip)
        {
            case ProjMatchingPrincip::None:
                ret = false;
                break;

            case ProjMatchingPrincip::SalesValue:
                ret = true;
                break;

            case ProjMatchingPrincip::ProductionProfit:
                ret = false;
                break;

            case ProjMatchingPrincip::NoMatching:
                ret = false;
                break;

            default:
                ret = this.allowEditFieldSalesValueCategoryIdExt(this.MatchingPrincip);
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canceledInvoiceRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for canceld invoiced revenue that will be used by projects
    /// in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that when set to true sets the ledger account for invoiced revenue to the value of
    /// the _<paramref name="ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for canceled invoiced revenue.
    /// </param>
    /// <returns>
    /// The ledger account for canceled invoiced revenue.
    /// </returns>
    /// <remarks>
    /// When tied to a control on a form, this method is automatically called every time that the form is
    /// redrawn, and the <paramref name="_set" /> value will be true if the user has entered anything in
    /// the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountTM canceledInvoiceRevenue(boolean _set, LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::InvoiceCancelRevenueAccount);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see whether this is a valid project group and displays warning messages if it is not.
    /// </summary>
    /// <returns>
    /// true if this is a valid project group; otherwise,, false.
    /// </returns>
    public boolean checkValid()
    {
        boolean         ok = true;

        if (!this.ProjGroupId)
        {
            ok = checkFailed("@SYS50011");
        }

        if (!this)
        {
            ok = checkFailed(strFmt(ProjGroup::txtNotExist(), this.ProjGroupId) );
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for cost that will be used by projects in this
    /// project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for cost to the value of the
    /// <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for cost.
    /// </param>
    /// <returns>
    /// The ledger account for Cost.
    /// </returns>
    /// <remarks>
    /// When tied to a control on a form, this method is automatically called every time that the form is
    /// redrawn, and <paramref name="_set" /> will be true if the user has entered anything in the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountCost costAccount(boolean     _set,
                                   LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::CostAccount);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>costTransCostMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger status for expense costs that will be used by projects in
    /// this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that can be set to true to set the ledger status for posting costs to the value of
    /// the _<paramref name="projLedgerStatusCost" /> parameter.
    /// </param>
    /// <param name="_projLedgerStatusCost">
    /// A <c>ProjLedgerStatusCost</c> enumeration value, either BalanceSheet or Operations.
    /// </param>
    /// <returns>
    /// The location in the general ledger (ledger status) for posting costs from expense journals.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and _<paramref name="set" /> will be true if the user has entered anything in the
    /// control.
    /// </remarks>
    edit ProjLedgerStatusCost costTransCostMethod(
        boolean                _set,
        ProjLedgerStatusCost _projLedgerStatusCost)
    {
        ProjLedgerStatusCost projLedgerStatusCost = _projLedgerStatusCost;

        if (_set)
        {
            this.CostTransCost = ProjGroup::cost2LedgerStatus(projLedgerStatusCost);
        }

        return ProjGroup::ledgerStatus2cost(this.CostTransCost);
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        // Check to see if the associated dimension attribute value has been used
        // in a way that would prevent deletion.
        if (!DimensionValidation::canDeleteEntityValue(this))
        {
            throw error(strFmt("@SYS134392", this.ProjGroupId));
        }

        ttsbegin;

        // Update the associated dimension attribute value.
        DimensionAttributeValue::updateForEntityValueDelete(this);

        super();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromProjType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the project group information, based on project type.
    /// </summary>
    protected void initFromProjType()
    {
        this.LedgerPosting          = ProjLedgerPosting::Categories;
        this.ProjLinePropertySearch = ProjLinePropertySearch::Project;

        switch (this.ProjType)
        {
            case ProjType::TimeMaterial                 :
                this.CostTransCost          = ProjLedgerStatus::Operations;
                this.ItemTransCost          = ProjLedgerStatus::Operations;
                this.EmplTransCost          = ProjLedgerStatus::Operations;
                this.InvoicePosting         = ProjLedgerStatusOnAcc::BalanceSheet;

                this.CostTransTurnover      = false;
                this.ItemTransTurnover      = false;
                this.EmplTransTurnover      = false;
                this.RevenueTransTurnover   = false;

                this.CompletePrincip        = ProjCompletePrincip::None;
                this.SalesPriceMatchingPrincip = ProjSalesPriceMatchingPrincip::None;
                this.MatchingPrincip        = ProjMatchingPrincip::None;
                this.AccruedCostCategoryId  = '';
                this.ForeseablesLosses      = false;
                this.ProductionCategoryId   = '';
                this.ProfitCategoryId       = '';
                this.SalesvalueCategoryId   = '';
                break;

            case ProjType::FixedPrice   :
                this.CostTransCost          = ProjLedgerStatus::Operations;
                this.ItemTransCost          = ProjLedgerStatus::Operations;
                this.EmplTransCost          = ProjLedgerStatus::Operations;
                this.InvoicePosting         = ProjLedgerStatusOnAcc::Operations;

                this.CostTransTurnover      = false;
                this.ItemTransTurnover      = false;
                this.EmplTransTurnover      = false;
                this.RevenueTransTurnover   = false;

                this.CompletePrincip        = ProjCompletePrincip::NoWIP;
                this.SalesPriceMatchingPrincip = ProjSalesPriceMatchingPrincip::None;
                this.MatchingPrincip        = ProjMatchingPrincip::NoMatching;
                break;

            case ProjType::Investment   :
                this.CostTransCost          = ProjLedgerStatus::Operations;
                this.ItemTransCost          = ProjLedgerStatus::Operations;
                this.EmplTransCost          = ProjLedgerStatus::Operations;
                this.InvoicePosting         = ProjLedgerStatusOnAcc::None;

                this.CostTransTurnover      = false;
                this.ItemTransTurnover      = false;
                this.EmplTransTurnover      = false;
                this.RevenueTransTurnover   = false;

                this.CompletePrincip        = ProjCompletePrincip::None;
                this.SalesPriceMatchingPrincip = ProjSalesPriceMatchingPrincip::None;
                this.MatchingPrincip        = ProjMatchingPrincip::None;
                break;

            case ProjType::Cost:
                this.CostTransCost          = ProjLedgerStatus::Operations;
                this.ItemTransCost          = ProjLedgerStatus::Operations;
                this.EmplTransCost          = ProjLedgerStatus::Operations;
                this.InvoicePosting         = ProjLedgerStatusOnAcc::None;
                this.CostTransTurnover      = false;
                this.ItemTransTurnover      = false;
                this.EmplTransTurnover      = false;
                this.RevenueTransTurnover   = false;

                this.CompletePrincip        = ProjCompletePrincip::None;
                this.SalesPriceMatchingPrincip = ProjSalesPriceMatchingPrincip::None;
                this.MatchingPrincip        = ProjMatchingPrincip::None;
                this.AccruedCostCategoryId  = '';
                this.ForeseablesLosses      = false;
                this.ProductionCategoryId   = '';
                this.ProfitCategoryId       = '';
                this.SalesvalueCategoryId   = '';
                break;

            case ProjType::Internal  :
                this.CostTransCost          = ProjLedgerStatus::Operations;
                this.ItemTransCost          = ProjLedgerStatus::Operations;
                this.EmplTransCost          = ProjLedgerStatus::Operations;
                this.InvoicePosting         = ProjLedgerStatusOnAcc::None;

                this.ItemTransTurnover      = false;
                this.CostTransTurnover      = false;
                this.EmplTransTurnover      = false;
                this.RevenueTransTurnover   = false;

                this.CompletePrincip        = ProjCompletePrincip::None;
                this.SalesPriceMatchingPrincip = ProjSalesPriceMatchingPrincip::None;
                this.MatchingPrincip        = ProjMatchingPrincip::None;
                this.AccruedCostCategoryId  = '';
                this.ForeseablesLosses      = false;
                this.ProductionCategoryId   = '';
                this.ProfitCategoryId       = '';
                this.SalesvalueCategoryId   = '';
                break;

            case ProjType::Time  :
                this.CostTransCost          = ProjLedgerStatus::Operations;
                this.ItemTransCost          = ProjLedgerStatus::Operations;
                this.EmplTransCost          = ProjLedgerStatus::Never;
                this.InvoicePosting         = ProjLedgerStatusOnAcc::None;

                this.ItemTransTurnover      = false;
                this.CostTransTurnover      = false;
                this.EmplTransTurnover      = false;
                this.RevenueTransTurnover   = false;

                this.CompletePrincip        = ProjCompletePrincip::None;
                this.SalesPriceMatchingPrincip = ProjSalesPriceMatchingPrincip::None;
                this.MatchingPrincip        = ProjMatchingPrincip::None;
                this.AccruedCostCategoryId  = '';
                this.ForeseablesLosses      = false;
                this.ProductionCategoryId   = '';
                this.ProfitCategoryId       = '';
                this.SalesvalueCategoryId   = '';
                break;
        }

        this.setForeseablesLosses();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes values.
    /// </summary>
    /// <remarks>
    ///    This method calls the <c>super</c> method to assign the default values set using the record template, and then calls the <c>ProjGroup.InitFromProjType</c> method to set additional defaults based on
    ///    the project type. It is called automatically from forms when a new record is added.
    /// </remarks>
    public void initValue()
    {
        super();

        this.initFromProjType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for invoiced revenue that will be used by projects
    /// in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that when set to true sets the ledger account for invoiced revenue to the value of
    /// the _<paramref name="ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for invoiced revenue.
    /// </param>
    /// <returns>
    /// The ledger account for invoiced revenue.
    /// </returns>
    /// <remarks>
    /// When tied to a control on a form, this method is automatically called every time that the form is
    /// redrawn, and the <paramref name="_set" /> value will be true if the user has entered anything in
    /// the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountTM invoiceTurnover(boolean       _set,
                                       LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::RevenueAccount);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemTransCostMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger status for item costs that will be used by projects in
    /// this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger status for posting costs to the value of
    /// the _ <paramref name="projLedgerStatusItem" /> parameter.
    /// </param>
    /// <param name="_projLedgerStatusItem">
    /// A <c>ProjLedgerStatusItem</c> enumeration value, either BalanceSheet or Operations.
    /// </param>
    /// <returns>
    /// The location in the general ledger (ledger status) for posting costs from item journals.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and <paramref name="_set" /> will be true if the user has entered anything in the
    /// control.
    /// </remarks>
    edit ProjLedgerStatusItem itemTransCostMethod(
        boolean                _set,
        ProjLedgerStatusItem _projLedgerStatusItem)
    {
        ProjLedgerStatusItem projLedgerStatusItem = _projLedgerStatusItem;

        if (_set)
        {
            this.ItemTransCost = ProjGroup::item2LedgerStatus(projLedgerStatusItem);
        }

        return ProjGroup::ledgerStatus2Item(this.ItemTransCost);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates project group data when certain fields are modified.
    /// </summary>
    /// <param name="_fieldId">
    ///    The field ID of the modified field.
    /// </param>
    /// <remarks>
    ///    This method is automatically called from forms when any field is modified.
    /// </remarks>
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(ProjGroup, EmplTransCost) :
                switch (this.EmplTransCost)
                {
                    case ProjLedgerStatus::Operations  :
                        this.EmplTransTurnover = false;
                        break;

                    case ProjLedgerStatus::BalanceSheet:
                        this.EmplTransTurnover = false;
                        break;
                }
                break;

            case fieldNum(ProjGroup, EmplTransTurnover) :
                switch (this.EmplTransTurnover)
                {
                    default  :
                        if (this.EmplTransCost == ProjLedgerStatus::Operations ||
                            this.EmplTransCost == ProjLedgerStatus::Never ||
                            this.EmplTransCost == ProjLedgerStatus::Deferred)
                        {
                            break;
                        }
                        else
                        {
                            this.EmplTransCost = ProjLedgerStatus::Operations;
                        }
                        break;
                }
                break;

            case fieldNum(ProjGroup, CostTransTurnover) :
                switch (this.CostTransTurnover)
                {
                    default  :
                        if (this.CostTransCost == ProjLedgerStatus::Operations ||
                            this.CostTransCost == ProjLedgerStatus::Never ||
                            this.CostTransCost == ProjLedgerStatus::Deferred)
                        {
                            break;
                        }
                        else
                        {
                            this.CostTransCost = ProjLedgerStatus::Operations;
                        }
                        break;
                }
                break;

            case fieldNum(ProjGroup, CostTransCost) :
                switch (this.CostTransCost)
                {
                    case ProjLedgerStatus::Operations  :
                        this.CostTransTurnover = false;
                        break;

                    case ProjLedgerStatus::BalanceSheet:
                        this.CostTransTurnover = false;
                        break;
                }
                break;

            case fieldNum(ProjGroup, CompletePrincip) :
                switch (this.CompletePrincip)
                {
                    case ProjCompletePrincip::None  :
                        this.SalesPriceMatchingPrincip  = ProjSalesPriceMatchingPrincip::None;
                        this.MatchingPrincip        = ProjMatchingPrincip::NoMatching;
                        this.ProductionCategoryId   = '';
                        this.ProfitCategoryId       = '';
                        this.SalesvalueCategoryId   = '';
                        switch (this.ProjType)
                        {
                            case ProjType::TimeMaterial:
                                this.InvoicePosting = ProjLedgerStatusOnAcc::BalanceSheet;
                                break;

                            case ProjType::FixedPrice:
                                this.InvoicePosting = ProjLedgerStatusOnAcc::Operations;
                                break;

                            case ProjType::Investment:
                                this.InvoicePosting = ProjLedgerStatusOnAcc::None;
                                break;

                            case ProjType::Cost:
                                this.InvoicePosting = ProjLedgerStatusOnAcc::None;
                                break;

                            case ProjType::Internal:
                                this.InvoicePosting = ProjLedgerStatusOnAcc::None;
                                break;

                            case ProjType::Time:
                                this.InvoicePosting = ProjLedgerStatusOnAcc::None;
                                break;
                        }
                        break;

                    case ProjCompletePrincip::NoWIP  :
                        this.SalesPriceMatchingPrincip  = ProjSalesPriceMatchingPrincip::None;
                        this.MatchingPrincip        = ProjMatchingPrincip::NoMatching;
                        this.ProductionCategoryId   = '';
                        this.ProfitCategoryId       = '';
                        this.SalesvalueCategoryId   = '';
                        this.InvoicePosting         = ProjLedgerStatusOnAcc::Operations;
                        break;

                    case ProjCompletePrincip::CompletedContract:
                        this.SalesPriceMatchingPrincip  = ProjSalesPriceMatchingPrincip::None;
                        this.MatchingPrincip        = ProjMatchingPrincip::SalesValue;
                        this.ProductionCategoryId   = '';
                        this.ProfitCategoryId       = '';
                        this.InvoicePosting         = ProjLedgerStatusOnAcc::BalanceSheet;
                        break;

                    case ProjCompletePrincip::CompletedPercentage:
                        this.SalesPriceMatchingPrincip  = ProjSalesPriceMatchingPrincip::None;
                        this.MatchingPrincip        = ProjMatchingPrincip::ProductionProfit;
                        this.SalesvalueCategoryId   = '';
                        this.InvoicePosting         = ProjLedgerStatusOnAcc::BalanceSheet;
                        break;
                }
                this.setForeseablesLosses();
                break;

            case fieldNum(ProjGroup, SalesPriceMatchingPrincip) :
                switch (this.SalesPriceMatchingPrincip)
                {
                    case ProjSalesPriceMatchingPrincip::None:
                        switch (this.CompletePrincip)
                        {
                            case ProjCompletePrincip::NoWIP  :
                                this.MatchingPrincip        = ProjMatchingPrincip::NoMatching;
                                this.ProductionCategoryId   = '';
                                this.ProfitCategoryId       = '';
                                this.SalesvalueCategoryId   = '';
                                break;

                            case ProjCompletePrincip::CompletedContract:
                                this.MatchingPrincip        = ProjMatchingPrincip::SalesValue;
                                this.ProductionCategoryId   = '';
                                this.ProfitCategoryId       = '';
                                this.InvoicePosting         = ProjLedgerStatusOnAcc::BalanceSheet;
                                break;

                            case ProjCompletePrincip::CompletedPercentage:
                                this.MatchingPrincip        = ProjMatchingPrincip::ProductionProfit;
                                this.SalesvalueCategoryId   = '';
                                this.InvoicePosting         = ProjLedgerStatusOnAcc::BalanceSheet;
                                break;
                        }
                        break;

                    case ProjSalesPriceMatchingPrincip::MarkupPercentTotal:
                        this.MatchingPrincip        = ProjMatchingPrincip::SalesValue;
                        this.ProductionCategoryId   = '';
                        this.ProfitCategoryId       = '';
                        this.ForeseablesLosses      = false;
                        this.InvoicePosting         = ProjLedgerStatusOnAcc::BalanceSheet;
                        break;

                    case ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine:
                        this.MatchingPrincip        = ProjMatchingPrincip::SalesValue;
                        this.ProductionCategoryId   = '';
                        this.ProfitCategoryId       = '';
                        this.ForeseablesLosses      = false;
                        this.InvoicePosting         = ProjLedgerStatusOnAcc::BalanceSheet;
                        break;

                    case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
                        this.MatchingPrincip        = ProjMatchingPrincip::ProductionProfit;
                        this.SalesvalueCategoryId   = '';
                        this.ForeseablesLosses      = false;
                        this.InvoicePosting         = ProjLedgerStatusOnAcc::BalanceSheet;
                        break;

                    case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:
                        this.MatchingPrincip        = ProjMatchingPrincip::ProductionProfit;
                        this.SalesvalueCategoryId   = '';
                        this.ForeseablesLosses      = false;
                        this.InvoicePosting         = ProjLedgerStatusOnAcc::BalanceSheet;
                        break;
                }
                this.setForeseablesLosses();
                break;

            case fieldNum(ProjGroup, ProjType) :
                this.initFromProjType();
                break;

            case fieldNum(ProjGroup, ItemTransCost) :
                switch (this.ItemTransCost)
                {
                    case ProjLedgerStatus::Operations  :
                        this.ItemTransTurnover = false;
                        break;

                    case ProjLedgerStatus::BalanceSheet:
                        this.ItemTransTurnover = false;
                        break;
                }
                break;

            case fieldNum(ProjGroup, ItemTransTurnover) :
                switch (this.ItemTransTurnover)
                {
                    default :
                        if (this.ItemTransCost == ProjLedgerStatus::Operations ||
                            this.ItemTransCost == ProjLedgerStatus::Never ||
                            this.ItemTransCost == ProjLedgerStatus::Deferred)
                        {
                            break;
                        }
                        else
                        {
                            this.ItemTransCost = ProjLedgerStatus::Operations;
                        }
                        break;
                }
                break;

            case fieldNum(ProjGroup, MatchingPrincip) :
                switch (this.MatchingPrincip)
                {
                    case ProjMatchingPrincip::None  :
                        if (this.ProjType == ProjType::FixedPrice || this.ProjType == ProjType::Investment)
                        {
                            this.AccruedCostCategoryId   = this.AccruedCostCategoryId;
                        }
                        else
                        {
                            this.AccruedCostCategoryId   = '';
                        }
                        this.ProductionCategoryId    = '';
                        this.ProfitCategoryId        = '';
                        this.SalesvalueCategoryId    = '';
                        break;

                    case ProjMatchingPrincip::SalesValue:
                        if (this.ProjType == ProjType::FixedPrice || this.ProjType == ProjType::Investment)
                        {
                            this.AccruedCostCategoryId   = this.AccruedCostCategoryId;
                        }
                        else
                        {
                            this.AccruedCostCategoryId   = '';
                        }
                        this.ProductionCategoryId    = '';
                        this.ProfitCategoryId        = '';
                        break;

                    case ProjMatchingPrincip::ProductionProfit:
                        if (this.ProjType == ProjType::FixedPrice || this.ProjType == ProjType::Investment)
                        {
                            this.AccruedCostCategoryId   = this.AccruedCostCategoryId;
                        }
                        else
                        {
                            this.AccruedCostCategoryId   = '';
                        }
                        this.SalesvalueCategoryId    = '';
                        break;

                    case ProjMatchingPrincip::NoMatching:
                        if (this.ProjType == ProjType::FixedPrice || this.ProjType == ProjType::Investment)
                        {
                            this.AccruedCostCategoryId   = this.AccruedCostCategoryId;
                        }
                        else
                        {
                            this.AccruedCostCategoryId   = '';
                        }
                        this.ProductionCategoryId    = '';
                        this.ProfitCategoryId        = '';
                        this.SalesvalueCategoryId    = '';
                        break;
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for the cost minus item that will be used by the
    /// projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value. Set to true to set the ledger account for the cost minus item to the value of the
    /// <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for the cost minus item.
    /// </param>
    /// <returns>
    /// The ledger account for the cost minus item.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and _<paramref name="set" /> will be true if the user has entered anything in the
    /// control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountWIP offsetAccountItem(boolean       _set,
                                           LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::OffsetAccountItem);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onAccountAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for Invoiced revenue minus On account that will be
    /// used by projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for invoiced revenue minus on
    /// account to the value of the <paramref name="ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for invoiced revenue minus on account.
    /// </param>
    /// <returns>
    /// The ledger account for invoiced revenue minus on account.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and the <paramref name="_set" /> value will be true if the user has entered
    /// anything in the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountOnAcc onAccountAccount(boolean       _set,
                                        LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::OnAccountAccount);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>payrollAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for payroll allocation that will be used by
    /// projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for payroll allocation to the
    /// value of the <paramref name="ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for payroll allocation.
    /// </param>
    /// <returns>
    /// The ledger account for payroll allocation.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and the <paramref name="_set" /> value will be true if the user has entered
    /// anything in the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountHour payrollAllocation(boolean       _set,
                                         LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::PayrollAllocation);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLinePropertyId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the default line property for projects in a project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that indicates whether to set the line property ID to the value of the value of the
    /// <paramref name="_projLinePropertyId" /> parameter.
    /// </param>
    /// <param name="_projGroup">
    /// A Project group for which to set the line property.
    /// </param>
    /// <param name="_projLinePropertyId">
    /// A line property ID.
    /// </param>
    /// <returns>
    /// The line property ID of the default line property for projects in the project group.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and the value of the <paramref name="_set" /> parameter will be true if the user
    /// has entered anything in the control.
    /// </remarks>
    edit ProjLinePropertyId projLinePropertyId(boolean               _set,
                                               ProjGroup             _projGroup,
                                               ProjLinePropertyId    _projLinePropertyId)
    {
        ProjLinePropertyId projLinePropertyId = '';

        if (_set && (!_projLinePropertyId || ProjLineProperty::checkExist(_projLinePropertyId)))
        {
            ProjLinePropertySetup::updateLinePropertyProj(_projGroup.ProjGroupId, _projLinePropertyId, TableGroupAll::GroupId, _set);
            projLinePropertyId = _projLinePropertyId;
        }
        else
        {
            projLinePropertyId = (select projLinePropertySetup where projLinePropertySetup.ProjCode          == TableGroupAll::GroupId  &&
                                                                     projLinePropertySetup.ProjRelation     == _projGroup.ProjGroupId &&
                                                                     projLinePropertySetup.CategoryCode     == TableGroupAll::All     &&
                                                                     projLinePropertySetup.CategoryRelation == '').LinePropertyId;
        }

        return projLinePropertyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>renamePrimaryKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Renames the foreign keys in other tables according to the change of the corresponding primary key
    /// value in this table.
    /// </summary>
    public void renamePrimaryKey()
    {
        DimensionValueRenameV2 rename = DimensionValueRenameV2::construct(this, this.orig());
        rename.syncRenamedValuePreSuper();

        super();

        rename.syncRenamedValuePostSuper();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setForeseablesLosses</Name>
				<Source><![CDATA[
    private void setForeseablesLosses()
    {
        if (this.allowEditFieldForeseablesLosses())
        {
            if ((this.CompletePrincip != ProjCompletePrincip::CompletedContract)
                && (this.CompletePrincip != ProjCompletePrincip::None))
            {
                this.AccruedCostCategoryId = '';
            }
        }
        else
        {
            this.ForeseablesLosses = NoYes::No;
            this.AccruedCostCategoryId = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns and optionally sets a ledger account that will be used by projects in a project group.
    /// </summary>
    /// <param name="set">
    /// A Boolean value that specifies whether to set the ledger account to the value of the <paramref
    /// name="ledgerAccount" /> parameter.
    /// </param>
    /// <param name="ledgerAccount">
    /// A ledger account.
    /// </param>
    /// <param name="accountType">
    /// The account type of the ledger account.
    /// </param>
    /// <returns>
    /// The ledger account.
    /// </returns>
    private LedgerDimensionDefaultAccount setLedgerAccount(boolean             set,
                                   LedgerDimensionDefaultAccount       ledgerAccount,
                                   ProjAccountType   accountType)
    {
        if (set)
        {
            ProjPosting::createTrans(ledgerAccount,accountType,TableGroupAll::GroupId,this.ProjGroupId,TableGroupAll::All,'');
            return ledgerAccount;
        }

        return ProjPosting::find(accountType,TableGroupAll::GroupId,this.ProjGroupId,TableGroupAll::All,'').LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>smaAccrueRevenueSubscription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for accrued revenue minus subscription that will
    /// be used by projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for accrued revenue minus
    /// subscription to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for accrued revenue minus subscription.
    /// </param>
    /// <returns>
    /// The ledger account for accrued revenue minus subscription.
    /// </returns>
    /// <remarks>
    /// When tied to a control on a form, this method is automatically called every time that the form is
    /// redrawn, and the <paramref name="_set" /> value will be true if the user has entered anything in
    /// the control.
    /// </remarks>
    edit SMAAccruedRevenueSubscriptionLedDimDefAc smaAccrueRevenueSubscription(boolean _set,LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::AccruedRevenueSubscription);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>smawipSubscription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for WIP minus subscription that will be used by
    /// projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for WIP minus subscription to the
    /// value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for WIP minus subscription.
    /// </param>
    /// <returns>
    /// The ledger account for WIP minus subscription.
    /// </returns>
    /// <remarks>
    /// When tied to a control on a form, this method is automatically called every time that the form is
    /// redrawn, and the <paramref name="_set" /> value will be true if the user has entered anything in
    /// the control.
    /// </remarks>
    edit SMAWIPSubscriptionLedDimDefAc smawipSubscription(boolean _set,LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::WIPSubscription);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>statusAccountItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for WIP minus cost value minus item that will be
    /// used by projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that when set to true sets the ledger account for WIP minus cost value minus item
    /// to the value of the _<paramref name="ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for WIP minus cost value minus item.
    /// </param>
    /// <returns>
    /// The ledger account for WIP minus cost value minus item.
    /// </returns>
    /// <remarks>
    /// When tied to a control on a form, this method is automatically called every time that the form is
    /// redrawn, and _<paramref name="set" /> will be true if the user has entered anything in the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountWIP statusAccountItem(boolean       _set,
                                           LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::StatusAccountItem);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>type</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the project group type. The project group type determines the project
    /// type for projects in this group.
    /// </summary>
    /// <param name="set">
    /// A Boolean value that specifies whether to set the project group type to the value of the <paramref
    /// name="projGroupType" /> parameter.
    /// </param>
    /// <param name="projGroupType">
    /// A <c>ProjGroupType</c> enumeration value.
    /// </param>
    /// <returns>
    /// The project group type.
    /// </returns>
    /// <remarks>
    /// The value that is stored is actually the project type, that is, one of the values from the
    /// <c>ProjType</c> enumeration, that corresponds to the project group type. The
    /// <c>ProjGroup.GetProjGroupForProjType</c> method is used to convert the project type to the group type and
    /// <c>ProjGroup.GetProjTypeForProjGroup</c> method is used to convert the group type to the project type.
    /// </remarks>
    public edit ProjGroupType type(boolean           set,
                                   ProjGroupType     projGroupType)
    {
        if (set)
        {
            this.ProjType  = ProjGroup::getProjTypeForProjGroup(projGroupType);
        }

        return ProjGroup::getProjGroupForProjType(this.ProjType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether the project group can be deleted.
    /// </summary>
    /// <returns>
    ///    true if the project group can be deleted; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <c>validateDelete</c> method does not do any additional validation beyond the related record validation done by the parent method. The <c>validateDelete</c> method must be called before a record
    ///    is deleted. It is automatically called from forms when the user tries to delete the record.
    /// </remarks>
    public boolean validateDelete()
    {
        boolean ret;

        ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the specified field.
    /// </summary>
    /// <param name="field">
    ///    The field ID to validate.
    /// </param>
    /// <returns>
    ///    true if the value in the specified field is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <c>validateField</c> method validates that the category types for the categories that can be used for estimate transactions are correct. It also validates that the categories are set up to use
    ///    for estimates. It is automatically called from forms with the field ID of the field that must be validated whenever a user leaves a field.
    /// </remarks>
    boolean validateField(FieldId field)
    {
        ProjCategory    projCategory;
        boolean ret;

        ret = super(field);

        if (ret)
        {
            switch (field)
            {
                case fieldNum(ProjGroup, AccruedCostCategoryId):
                    if (this.AccruedCostCategoryId)
                    {
                        projCategory    = ProjCategory::find(this.AccruedCostCategoryId);
                        if (projCategory.CategoryType != ProjCategoryType::Cost)
                        {
                            ret = checkFailed(strFmt("@SYS54897", this.AccruedCostCategoryId));
                        }

                        if (ret && (! projCategory.SetupEstimate))
                        {
                            ret = checkFailed("@SYS90449");
                        }
                    }
                    break;

                case fieldNum(ProjGroup, ProductionCategoryId):
                    if (this.ProductionCategoryId)
                    {
                        projCategory    = ProjCategory::find(this.ProductionCategoryId);

                        if (projCategory.CategoryType != ProjCategoryType::Revenue)
                        {
                            ret = checkFailed(strFmt("@SYS54897", this.ProductionCategoryId));
                        }

                        if (ret && (! projCategory.SetupEstimate))
                        {
                            ret = checkFailed("@SYS90449");
                        }
                    }
                    break;

                case fieldNum(ProjGroup, ProfitCategoryId):
                    if (this.ProfitCategoryId)
                    {
                        projCategory    = ProjCategory::find(this.ProfitCategoryId);

                        if (projCategory.CategoryType != ProjCategoryType::Revenue)
                        {
                            ret = checkFailed(strFmt("@SYS54897", this.ProfitCategoryId));
                        }

                        if (ret && (! projCategory.SetupEstimate))
                        {
                            ret = checkFailed("@SYS90449");
                        }
                    }
                    break;

                case fieldNum(ProjGroup, SalesvalueCategoryId):
                    if (this.SalesvalueCategoryId)
                    {
                        projCategory    = ProjCategory::find(this.SalesvalueCategoryId);

                        if (projCategory.CategoryType != ProjCategoryType::Revenue)
                        {
                            ret = checkFailed(strFmt("@SYS54897", this.SalesvalueCategoryId));
                        }

                        if (ret && (! projCategory.SetupEstimate))
                        {
                            ret = checkFailed("@SYS90449");
                        }
                    }
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSalesPriceMatchingPrincip</Name>
				<Source><![CDATA[
    private boolean validateSalesPriceMatchingPrincip()
    {
        boolean ret = true;

        if (this.CompletePrincip != ProjCompletePrincip::CompletedPercentage &&
            this.CompletePrincip != ProjCompletePrincip::CompletedContract &&
            this.SalesPriceMatchingPrincip != ProjSalesPriceMatchingPrincip::None)
        {
            ret = checkFailed("@SYS6144");
        }

        if (this.CompletePrincip == ProjCompletePrincip::CompletedPercentage &&
            this.MatchingPrincip == ProjMatchingPrincip::SalesValue &&
            this.InvoicePosting == ProjLedgerStatusOnAcc::Operations &&
            this.SalesPriceMatchingPrincip != ProjSalesPriceMatchingPrincip::None)
        {
            ret = checkFailed("@SYS6144");
        }

        if ((this.MatchingPrincip == ProjMatchingPrincip::SalesValue) &&
            (this.SalesPriceMatchingPrincip == ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent ||
            this.SalesPriceMatchingPrincip == ProjSalesPriceMatchingPrincip::ValueAddedHourRate))
        {
            ret = checkFailed("@SYS6144");
        }

        if ((this.MatchingPrincip == ProjMatchingPrincip::ProductionProfit) &&
            (this.SalesPriceMatchingPrincip == ProjSalesPriceMatchingPrincip::MarkupPercentTotal ||
            this.SalesPriceMatchingPrincip == ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine))
        {
            ret = checkFailed("@SYS6144");
        }

        if (this.SalesPriceMatchingPrincip != ProjSalesPriceMatchingPrincip::None &&
            this.ForeseablesLosses)
        {
            ret = checkFailed("@SYS6144");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the project group.
    /// </summary>
    /// <returns>
    ///    true if the activity is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    In addition to mandatory field validation performed by the parent method, this method validates some other fields based on default project type, matching principle, foreseeable losses, and
    ///    configuration keys. It must be called before a record is written to the database. It is automatically called from forms when the user tries to save the record.
    /// </remarks>
    boolean validateWrite()
    {
        boolean ret = super();

        if (this.SalesPriceMatchingPrincip != ProjSalesPriceMatchingPrincip::None)
        {
            info("@SYS308783");
        }

        switch (this.ProjType)
        {
            case ProjType::FixedPrice:
                if (this.InvoicePosting == ProjLedgerStatusOnAcc::None)
                {
                    ret = checkFailed("@SYS55323");
                }

                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    if (this.MatchingPrincip == ProjMatchingPrincip::None)
                    {
                        ret = checkFailed("@SYS76872");
                    }

                    if (this.CompletePrincip == ProjCompletePrincip::None)
                    {
                        ret = checkFailed("@SYS76876");
                    }

                    if ((this.CompletePrincip == ProjCompletePrincip::NoWIP)
                        && (this.EmplTransCost == ProjLedgerStatus::None
                            || this.EmplTransCost == ProjLedgerStatus::BalanceSheet
                            || this.CostTransCost == ProjLedgerStatus::BalanceSheet
                            || this.ItemTransCost == ProjLedgerStatus::BalanceSheet))
                    {
                        ret = checkFailed("@SYS107848");
                    }

                    if ((this.CompletePrincip == ProjCompletePrincip::CompletedPercentage  ||
                        this.CompletePrincip == ProjCompletePrincip::CompletedContract)   &&
                        this.MatchingPrincip == ProjMatchingPrincip::NoMatching)
                    {
                        ret = checkFailed("@SYS76872");
                    }

                    if (this.MatchingPrincip == ProjMatchingPrincip::ProductionProfit)
                    {
                        if (this.ProfitCategoryId && (this.ProfitCategoryId == this.ProductionCategoryId))
                        {
                            ret = checkFailed("@SYS90793");
                        }
                    }

                    ret = ret && this.validateSalesPriceMatchingPrincip();
                }
                break;

            case ProjType::TimeMaterial:
                if (this.InvoicePosting == ProjLedgerStatusOnAcc::None)
                {
                    ret = checkFailed("@SYS55323");
                }
                break;

            case ProjType::Cost:

            case ProjType::Internal:

            case ProjType::Investment:

            case ProjType::Time:
                if (this.InvoicePosting != ProjLedgerStatusOnAcc::None)
                {
                    ret = checkFailed(strFmt("@SYS90830",this.ProjType));
                }
                break;
        }

        switch (this.MatchingPrincip)
        {
            case ProjMatchingPrincip::SalesValue:
                if (! this.SalesvalueCategoryId)
                {
                    ret = checkFailed(strFmt("@SYS78453",this.MatchingPrincip));
                }
                break;

            case ProjMatchingPrincip::ProductionProfit:
                if (! this.ProductionCategoryId)
                {
                    ret = checkFailed(strFmt("@SYS78455",this.MatchingPrincip));
                }
                if (! this.ProfitCategoryId)
                {
                    ret = checkFailed(strFmt("@SYS78454",this.MatchingPrincip));
                }
                break;
        }

        if (this.ForeseablesLosses)
        {
            if (this.CompletePrincip != ProjCompletePrincip::CompletedPercentage)
            {
                if (!this.AccruedCostCategoryId)
                {
                    ret = checkFailed("@SYS90833");
                }
            }
        }

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            DictField dictField = new DictField(tableNum(ProjGroup), fieldNum(ProjGroup, CostTransCost));

            if (!this.CostTransCost && isConfigurationkeyEnabled(dictField.configurationKeyId()))
            {
                return checkFailed("@SYS76874");
            }

            dictField = new DictField(tableNum(ProjGroup), fieldNum(ProjGroup, ItemTransCost));

            if (!this.ItemTransCost && isConfigurationkeyEnabled(dictField.configurationKeyId()))
            {
                return checkFailed("@SYS76874");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for WIP minus accrued loss that will be used by
    /// projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for WIP minus accrued loss to the
    /// value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for WIP minus accrued loss.
    /// </param>
    /// <returns>
    /// The ledger account for WIP minus accrued loss.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and _ <paramref name="set" /> will be true if the user has entered anything in the
    /// control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountEst wipCostAccrued(boolean _set,LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::WIPCostAccruals);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for WIP minus cost value that will be used by
    /// projects in a project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for WIP minus cost value to the
    /// value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for WIP minus Cost value.
    /// </param>
    /// <returns>
    /// The ledger account for WIP minus cost value.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and the <paramref name="_set" /> parameter will be true if the user has entered
    /// anything in the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountWIP wipCostValue(boolean       _set,
                                    LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::StatusAccount);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipInvoicedOnAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for WIP minus invoiced minus on account that will
    /// be used by projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for WIP minus invoiced minus on
    /// account to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for WIP minus invoiced minus on account.
    /// </param>
    /// <returns>
    /// The ledger account for WIP minus invoiced minus on account.
    /// </returns>
    /// <remarks>
    /// When tied to a control on a form, this method is automatically called when the form is redrawn, and
    /// the <paramref name="_set" /> parameter will be true if the user has entered anything in the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountOnAcc wipInvoicedOnAccount(
        boolean       _set,
        LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::WIPInvoicedOnAccount);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipProduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for WIP minus Production that will be used by
    /// projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for WIP minus production to the
    /// value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for WIP minus production.
    /// </param>
    /// <returns>
    /// The ledger account for WIP minus production.
    /// </returns>
    /// <remarks>
    /// When tied to a control on a form, this method is automatically called every time that the form is
    /// redrawn, and the <paramref name="_set" /> parameter will be true if the user has entered anything
    /// in the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountFP wipProduction(boolean       _set,
                                     LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::WIPProduction);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipProfit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for work in progress (WIP) minus profit that will
    /// be used by projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that can be set to true to set the ledger account for WIP minus profit to the value
    /// of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for WIP minus profit.
    /// </param>
    /// <returns>
    /// The ledger account for WIP minus profit.
    /// </returns>
    /// <remarks>
    /// When associated with a control on a form, this method is automatically called every time that the
    /// form is redrawn, and the <paramref name="_set" /> parameter will be true if the user has entered
    /// anything in the control.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountFP wipProfit(boolean       _set,
                                 LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::WIPProfit);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipSalesvalue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns, and optionally sets, the ledger account for WIP minus sales value that will be used by
    /// projects in this project group.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for WIP minus sales value to the
    /// value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// A ledger account for WIP minus sales value.
    /// </param>
    /// <returns>
    /// The ledger account for WIP minus sales value.
    /// </returns>
    edit ProjLedgerDimensionDefaultAccountWIP wipSalesvalue(boolean       _set,
                                     LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::SalesOffsetAccount);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks to see whether the specified project group exists and writes a message to the InfoLog if it does not.
    /// </summary>
    /// <param name="projGroupId">
    ///    The ID of the project group to check.
    /// </param>
    /// <returns>
    ///    true if the project group exists; otherwise, false.
    /// </returns>
    static boolean checkExist(ProjGroupId projGroupId)
    {
        if (projGroupId && ! ProjGroup::exist(projGroupId))
        {
            return checkFailed(strFmt(ProjGroup::txtNotExist(),projGroupId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cost2LedgerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>ProjLedgerStatus</c> enumeration values that are based on a post costs minus expense
    /// enumeration value.
    /// </summary>
    /// <param name="_projLedgerStatusCost">
    /// The value of post costs minus expense.
    /// </param>
    /// <returns>
    /// The ledger status value that corresponds to the post costs minus expense value.
    /// </returns>
    /// <remarks>
    /// If no valid mapping between the values exists, an error is thrown.
    /// </remarks>
    private static ProjLedgerStatus cost2LedgerStatus(
        ProjLedgerStatusCost  _projLedgerStatusCost)
    {
        ProjLedgerStatus projLedgerStatus;

        switch (_projLedgerStatusCost)
        {
            case ProjLedgerStatusCost::BalanceSheet:
                projLedgerStatus = ProjLedgerStatus::BalanceSheet;
                break;

            case ProjLedgerStatusCost::Operations:
                projLedgerStatus = ProjLedgerStatus::Operations;
                break;

            case ProjLedgerStatusCost::Deferred:
                projLedgerStatus = ProjLedgerStatus::Deferred;
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        return projLedgerStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a project group that has the given ID exists.
    /// </summary>
    /// <param name="projGroupId">
    /// The ID of the project group.
    /// </param>
    /// <returns>
    /// true if the project group exists; otherwise, false.
    /// </returns>
    public static boolean exist(ProjGroupId projGroupId)
    {
        return projGroupId && (select projGroup where projGroup.ProjGroupId == projGroupId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the project group that has the given ID.
    /// </summary>
    /// <param name="_projGroupId">
    ///    The ID of the project group.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that determines whether the record should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    The desired project group. Returns null if the project group does not exist.
    /// </returns>
    public static ProjGroup find(ProjGroupId _projGroupId, boolean _forUpdate = false)
    {
        ProjGroup projGroup = null;

        projGroup.selectForUpdate(_forUpdate);

        if (_projGroupId)
        {
            select firstOnly projGroup where projGroup.ProjGroupId == _projGroupId;
        }

        return projGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjTypeForProjGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a <c>ProjType</c> enumeration value, depending on a <c>ProjGroupType</c> enumeration value.
    /// </summary>
    /// <param name="_projGroupType">
    ///    A project group type value.
    /// </param>
    /// <returns>
    ///    The <c>ProjType</c> enumeration value that corresponds to the <c>ProjGroupType</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    If no valid mapping between the values exists, an error is thrown.
    /// </remarks>
    private static ProjType getProjTypeForProjGroup(ProjGroupType  _projGroupType)
    {
        ProjType projType;

        switch (_projGroupType)
        {
            case ProjGroupType::TimeMaterial:
                projType = ProjType::TimeMaterial;
                break;

            case ProjGroupType::FixedPrice:
                projType = ProjType::FixedPrice;
                break;

            case ProjGroupType::Investment:
                projType = ProjType::Investment;
                break;

            case ProjGroupType::Cost:
                projType = ProjType::Cost;
                break;

            case ProjGroupType::Internal:
                projType = ProjType::Internal;
                break;

            case ProjGroupType::Time:
                projType = ProjType::Time;
                break;

            default:
                projType = ProjGroup::handleUnmappedProjectGroupType(_projGroupType);
        }

        return projType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleUnmappedProjectGroupType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieve the additional value based on the <c>ProjGroupType</c> enum.
    /// </summary>
    /// <param name="_projGroupType">
    ///    A project group type value.
    /// </param>
    /// <returns>
    ///    Throw error if the additional value is not specified.
    /// </returns>
    [Replaceable]
    protected static ProjType handleUnmappedProjectGroupType(ProjGroupType  _projGroupType)
    {
        throw error(strFmt("@SYS22828", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>item2LedgerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>ProjLedgerStatus</c> enumeration value that is based on the post costs minus the item
    /// enumeration value.
    /// </summary>
    /// <param name="_projLedgerStatusItem">
    /// A post costs minus item value.
    /// </param>
    /// <returns>
    /// The ledger status value that corresponds to the post costs minus item value.
    /// </returns>
    /// <remarks>
    /// If no valid mapping between the values exists, an error is thrown.
    /// </remarks>
    private static ProjLedgerStatus item2LedgerStatus(
        ProjLedgerStatusItem  _projLedgerStatusItem)
    {
        ProjLedgerStatus projLedgerStatus;

        switch (_projLedgerStatusItem)
        {
            case ProjLedgerStatusItem::BalanceSheet:
                projLedgerStatus = ProjLedgerStatus::BalanceSheet;
                break;

            case ProjLedgerStatusItem::Operations:
                projLedgerStatus = ProjLedgerStatus::Operations;
                break;

            case ProjLedgerStatusItem::Deferred:
                projLedgerStatus = ProjLedgerStatus::Deferred;
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        return projLedgerStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatus2cost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a post costs minus expense enumeration value, depending on a ledger status enumeration value.
    /// </summary>
    /// <param name="_projLedgerStatus">
    ///    A ledger status value.
    /// </param>
    /// <returns>
    ///    The post costs minus expense value that corresponds to the ledger status value.
    /// </returns>
    private static ProjLedgerStatusCost ledgerStatus2cost(
        ProjLedgerStatus  _projLedgerStatus)
    {
        ProjLedgerStatusCost projLedgerStatusCost;

        switch (_projLedgerStatus)
        {
            case ProjLedgerStatus::BalanceSheet:
                projLedgerStatusCost = ProjLedgerStatusCost::BalanceSheet;
                break;

            case ProjLedgerStatus::Operations:
                projLedgerStatusCost = ProjLedgerStatusCost::Operations;
                break;

            case ProjLedgerStatus::Deferred:
                projLedgerStatusCost = ProjLedgerStatusCost::Deferred;
                break;
        }

        return projLedgerStatusCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatus2Item</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a post costs minus the item enumeration data type value based on a ledger status enumeration
    /// value.
    /// </summary>
    /// <param name="_projLedgerStatus">
    /// A Ledger status value.
    /// </param>
    /// <returns>
    /// The post costs minus item value that corresponds to the ledger status value.
    /// </returns>
    private static ProjLedgerStatusItem ledgerStatus2Item(
        ProjLedgerStatus  _projLedgerStatus)
    {
        ProjLedgerStatusItem projLedgerStatusItem;

        switch (_projLedgerStatus)
        {
            case ProjLedgerStatus::BalanceSheet:
                projLedgerStatusItem = ProjLedgerStatusItem::BalanceSheet;
                break;

            case ProjLedgerStatus::Operations:
                projLedgerStatusItem = ProjLedgerStatusItem::Operations;
                break;

            case ProjLedgerStatus::Deferred:
                projLedgerStatusItem = ProjLedgerStatusItem::Deferred;
                break;
        }

        return projLedgerStatusItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatus2periodic</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a <c>ProjLedgerStatusPeriodic</c> enumeration value, depending on a <c>ProjLedgerStatus</c> enumeration value.
    /// </summary>
    /// <param name="_projLedgerStatus">
    ///    A ledger status value.
    /// </param>
    /// <returns>
    ///    The post costs value that corresponds to the ledger status value.
    /// </returns>
    /// <remarks>
    ///    If no valid mapping between the values exists, an error is thrown.
    /// </remarks>
    public static ProjLedgerStatusPeriodic ledgerStatus2periodic(ProjLedgerStatus _projLedgerStatus)
    {
        ProjLedgerStatusPeriodic projLedgerStatusPeriodic;

        switch (_projLedgerStatus)
        {
            case ProjLedgerStatus::None:
                projLedgerStatusPeriodic = ProjLedgerStatusPeriodic::None;
                break;

            case ProjLedgerStatus::BalanceSheet:
                projLedgerStatusPeriodic = ProjLedgerStatusPeriodic::BalanceSheet;
                break;

            case ProjLedgerStatus::Operations:
                projLedgerStatusPeriodic = ProjLedgerStatusPeriodic::Operations;
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        return projLedgerStatusPeriodic;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a dialog box that has a list from which the user can select a project group.
    /// </summary>
    /// <param name="_ctrl">
    /// The field that will hold the selected project group ID.
    /// </param>
    /// <param name="_projType">
    /// A project type value that is used to filter project groups in the list. Only project groups that
    /// have matching project type will be displayed.
    /// </param>
    public static void lookupGroup(FormStringControl _ctrl, ProjType _projType)
    {
        Args        args;
        FormRun     formRun;

        args = new Args();
        args.name(formStr(ProjGroupLookup));
        args.caller(_ctrl);

        args.parmEnum(_projType);

        formRun = classfactory.formRunClass(args);
        formRun.init();
        _ctrl.performFormLookup(formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodic2ledgerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a <c>ProjLedgerStatus</c> enumeration value, depending on a post costs enumeration value.
    /// </summary>
    /// <param name="_projLedgerStatusPeriodic">
    ///    A post costs value.
    /// </param>
    /// <returns>
    ///    The ledger status value that corresponds to the post costs value.
    /// </returns>
    /// <remarks>
    ///    If no valid mapping between the values exists, an error is thrown.
    /// </remarks>
    public static ProjLedgerStatus periodic2ledgerStatus(ProjLedgerStatusPeriodic  _projLedgerStatusPeriodic)
    {
        ProjLedgerStatus projLedgerStatus;

        switch (_projLedgerStatusPeriodic)
        {
            case ProjLedgerStatusPeriodic::None:
                projLedgerStatus = ProjLedgerStatus::None;
                break;

            case ProjLedgerStatusPeriodic::BalanceSheet:
                projLedgerStatus = ProjLedgerStatus::BalanceSheet;
                break;

            case ProjLedgerStatusPeriodic::Operations:
                projLedgerStatus = ProjLedgerStatus::Operations;
                break;

            default:
                throw error(strFmt("@SYS22828", funcName()));
        }

        return projLedgerStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjGroupForProjType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a project group type value, based on a specified project type value.
    /// </summary>
    /// <param name="_projType">
    ///    A project type value.
    /// </param>
    /// <returns>
    ///    The project group type value that corresponds to the specified project type value.
    /// </returns>
    /// <remarks>
    ///    If no valid mapping between the values exists, an error is thrown.
    /// </remarks>
    private static ProjGroupType getProjGroupForProjType(ProjType _projType)
    {
        ProjGroupType projGroupType;

        switch (_projType)
        {
            case ProjType::TimeMaterial:
                projGroupType = ProjGroupType::TimeMaterial;
                break;

            case ProjType::FixedPrice:
                projGroupType = ProjGroupType::FixedPrice;
                break;

            case ProjType::Investment:
                projGroupType = ProjGroupType::Investment;
                break;

            case ProjType::Cost:
                projGroupType = ProjGroupType::Cost;
                break;

            case ProjType::Internal:
                projGroupType = ProjGroupType::Internal;
                break;

            case ProjType::Time:
                projGroupType = ProjGroupType::Time;
                break;

            default:
                projGroupType = ProjGroup::handleUnmappedProjectType(_projType);
        }
        
        return projGroupType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleUnmappedProjectType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieve the additional value based on the <c>ProjType</c> enum.
    /// </summary>
    /// <param name="_projType">
    ///    A project type value.
    /// </param>
    /// <returns>
    ///    Throw error if the additional value is not specified.
    /// </returns>
    [Replaceable]
    protected static ProjGroupType handleUnmappedProjectType(ProjType _projType)
    {
        throw error(strFmt("@SYS22828",funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the message to display when a project group does not exist.
    /// </summary>
    /// <returns>
    ///    A string that is the message to display when a project group does not exist.
    /// </returns>
    private static str 80 txtNotExist()
    {
        return "@SYS14690";
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvestmentProjGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to check if project group is of type investment.
    /// With multiple contract line feature investment projects are not supported
    /// so this method will return false if feature is turned on.
    /// </summary>
    /// <param name="_multipleContractLineFeatureEnabled">Multiple contract line feature flag.</param>
    /// <returns>true if meets investment project criteria, otherwise false.</returns>
	public final boolean isInvestmentProjGroup(boolean _multipleContractLineFeatureEnabled)
    {
        return this.ProjType == ProjType::Investment && !_multipleContractLineFeatureEnabled;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Project</ConfigurationKey>
	<DeveloperDocumentation>@SYS124896</DeveloperDocumentation>
	<FormRef>ProjGroup</FormRef>
	<Label>@SYS15509</Label>
	<TableGroup>Group</TableGroup>
	<TitleField1>ProjGroupId</TitleField1>
	<TitleField2>projType</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>EntireTable</CacheLookup>
	<ClusteredIndex>GroupIdx</ClusteredIndex>
	<DataSharingType>Duplicate</DataSharingType>
	<Modules>ProjectManagementAndAccounting</Modules>
	<PrimaryIndex>GroupIdx</PrimaryIndex>
	<ReplacementKey>GroupIdx</ReplacementKey>
	<TableContents>DefaultData</TableContents>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EmplTransCost</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EmplTransTurnover</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>costTransCost</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostTransTurnover</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerPosting</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Cost</Name>
			<Label>@SYS4249</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>EmplTransCost</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>costTransCost</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemTransCost</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CostControl</Name>
			<Label>@SYS107921</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CheckBudget</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Description</Name>
			<Label>@SYS6303</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>EstimateCategory</Name>
			<Label>@SYS78407</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SalesvalueCategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProductionCategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProfitCategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccruedCostCategoryId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>FixedPrice</Name>
			<Label>@SYS3237</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CompletePrincip</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SalesPriceMatchingPrincip</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MatchingPrincip</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ForeseablesLosses</Name>
			<Label>@SYS78457</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ForeseablesLosses</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>projType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Invoicing</Name>
			<Label>@SYS5779</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InvoicePosting</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Journalizing</Name>
			<Label>@SYS58509</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>EmplTransCost</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>costTransCostMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>itemTransCostMethod</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Project</Name>
			<Label>@SYS4534</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerPosting</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjLinePropertySearch</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TimeMaterial</Name>
			<Label>@SYS53874</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>EmplTransTurnover</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostTransTurnover</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemTransTurnover</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RevenueTransTurnover</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WIPDefaults</Name>
			<Label>@PSA242</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PeriodId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ControlId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccruedCostCategoryId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryCostId</ExtendedDataType>
			<Label>@SYS78380</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CheckBudget</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS153311</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CompletePrincip</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjCompletePrincip</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ControlId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjControlId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>costTransCost</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS53212</Label>
			<EnumType>ProjLedgerStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CostTransTurnover</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjActivateTrans</ExtendedDataType>
			<Label>@SYS62481</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>EmplTransCost</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS50268</Label>
			<EnumType>ProjLedgerStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>EmplTransTurnover</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjActivateTrans</ExtendedDataType>
			<Label>@SYS62480</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ForeseablesLosses</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjForeseablesLosses</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InvoicePosting</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS4236</Label>
			<EnumType>ProjLedgerStatusOnAcc</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ItemTransCost</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LogisticsBasic</ConfigurationKey>
			<Label>@SYS69924</Label>
			<EnumType>ProjLedgerStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ItemTransTurnover</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LogisticsBasic</ConfigurationKey>
			<ExtendedDataType>ProjActivateTrans</ExtendedDataType>
			<Label>@SYS69926</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LedgerPosting</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjLedgerPosting</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>MatchingPrincip</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjMatchingPrincip</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Name</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PeriodId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjPeriodId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProductionCategoryId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
			<Label>@SYS10657</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProfitCategoryId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
			<Label>@SYS20010</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjGroupId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjGroupId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjLinePropertySearch</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjLinePropertySearch</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>projType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RevenueTransTurnover</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjActivateTrans</ExtendedDataType>
			<Label>@SYS62482</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SalesPriceMatchingPrincip</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjSalesPriceMatchingPrincip</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SalesvalueCategoryId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
			<Label>@SYS50058</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>GroupIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjGroupId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjCategory_AccruedCost</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjCategory_AccruedCost</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjGroup</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccruedCostCategoryId</Name>
					<SourceEDT>ProjCategoryCostId</SourceEDT>
					<Field>AccruedCostCategoryId</Field>
					<RelatedField>CategoryId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CategoryIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjCategory_Production</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjCategory_Production</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjGroup</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProductionCategoryId</Name>
					<SourceEDT>ProjCategoryId</SourceEDT>
					<Field>ProductionCategoryId</Field>
					<RelatedField>CategoryId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CategoryIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjCategory_Profit</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjCategory_Profit</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjGroup</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProfitCategoryId</Name>
					<SourceEDT>ProjCategoryId</SourceEDT>
					<Field>ProfitCategoryId</Field>
					<RelatedField>CategoryId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CategoryIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjCategory_SalesValue</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjCategory_SalesValue</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjGroup</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SalesvalueCategoryId</Name>
					<SourceEDT>ProjCategoryId</SourceEDT>
					<Field>SalesvalueCategoryId</Field>
					<RelatedField>CategoryId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CategoryIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjControl</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjControl</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ControlId</Name>
					<SourceEDT>ProjControlId</SourceEDT>
					<Field>ControlId</Field>
					<RelatedField>ControlId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjPeriodID</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjPeriodTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PeriodId</Name>
					<SourceEDT>ProjPeriodId</SourceEDT>
					<Field>PeriodId</Field>
					<RelatedField>PeriodId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>