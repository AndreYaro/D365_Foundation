<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AgreementHeader</Name>
	<SourceCode>
		<Declaration><![CDATA[
public abstract class AgreementHeader extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>agreementClassification_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the <c>AgreementClassification</c> record from the current <c>AgreementHeader</c> record.
    /// </summary>
    /// <returns>
    ///     A table buffer that contains the <c>AgreementClassification</c> record.
    /// </returns>
    public AgreementClassification agreementClassification_RU()
    {
        return AgreementClassification::find(this.AgreementClassification);
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementDate_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the agreement date from the <c>AgreementHeaderExt_RU</c> record.
    /// </summary>
    /// <returns>
    ///     The agreement date.
    /// </returns>
    [SysClientCacheDataMethodAttribute]
    display public AgreementDate_RU agreementDate_RU()
    {
        return AgreementHeaderExt_RU::findByAgreementHeader(this.RecId).AgreementDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementHeaderDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the default <c>AgreementHeader</c> record from the current <c>AgreementHeader</c> record.
    /// </summary>
    /// <param name="_forupdate">
    ///    A Boolean value that indicates whether the default <c>AgreementHeader</c> record is selected for
    ///    update; optional.
    /// </param>
    /// <returns>
    ///    A table buffer that contains the default <c>AgreementHeader</c> record.
    /// </returns>
    public AgreementHeaderDefault agreementHeaderDefault(boolean  _forupdate = false)
    {
        AgreementHeaderDefault agreementHeaderDefault;

        if (this.RecId)
        {
            agreementHeaderDefault.selectForUpdate(_forupdate);

            select firstonly agreementHeaderDefault
                where agreementHeaderDefault.AgreementHeader == this.RecId;
        }

        return agreementHeaderDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementValidityPeriodText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a string the explains the validity period when intercompany agreements are enabled.
    /// </summary>
    /// <returns>
    /// The validity period when intercompany agreements are enabled.
    /// </returns>
    display AgreementValidityPeriod agreementValidityPeriodText()
    {
        return "@SYS334943";
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowCurrencyChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method detemines whether or not a change to <c>CurrencyCode</c> is permitted.
    /// If for any <c>AgreementLine</c> exists released line associated with it, change of <c>CurrencyCode</c> is not allowed.
    /// </summary>
    /// <param name="_giveWarning">
    /// When set to TRUE user will be notified that change of <c>CurrencyCode</c> is not allowed.
    /// </param>
    /// <returns>
    /// True if change of <c>CurrencyCode</c> is allowed.
    /// </returns>
    public boolean allowCurrencyChange (boolean _giveWarning = true)
    {
        boolean ok = true;

        if (this.isReleased())
        {
            // When releases exist for any of agreement lines changes of Currency code is prohibited.
            ok = false;
            if (_giveWarning)
            {
                ok = checkFailed("@SYS345146");
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddLinesToAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether the lines can be added to the agreement or not.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    public boolean canAddLinesToAgreement()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAuthorizeFinancialDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether a financial dimension can be authorized.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    public boolean canAuthorizeFinancialDimension()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeIntercompanyAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether the agreement can be an intercompany agreement.
    /// </summary>
    /// <returns>
    /// true if the agreement can be an intercompany agreement; otherwise, false.
    /// </returns>
    public boolean canBeIntercompanyAgreement()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAgreementUsingActiveIntercompanyPartner</Name>
				<Source><![CDATA[
    public boolean isAgreementUsingActiveIntercompanyPartner()
    {
        return this.canBeIntercompanyAgreement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canChangeContractor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether a contractor can be changed.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    public boolean canChangeContractor()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateChildAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether a child agreement can be created.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    public boolean canCreateChildAgreement()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateIntercompanyAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the agreement can be used for creating an intercompany agreement.
    /// </summary>
    /// <returns>
    /// true if the agreement can be used for creating an intercompany agreement; otherwise, false.
    /// </returns>
    public boolean canCreateIntercompanyAgreement()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateIntracompanyAgreement_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the agreement can be used for creating an intracompany agreement.
    /// </summary>
    /// <returns>
    ///     Always returns false.
    /// </returns>
    public boolean canCreateIntracompanyAgreement_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the agreement can be deleted.
    /// </summary>
    /// <returns>
    /// true if the agreement can be deleted; otherwise, false.
    /// </returns>
    public boolean canDeleteAgreement()
    {
        // <GEERU>
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            return !this.isReleaseOrderMatched() && this.AgreementState != AgreementState::Effective;
        }
        else
        {
            // </GEERU>
            return !this.isDerivedAgreement() && !this.isReleaseOrderMatched();
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReleaseAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether if the agreement can be released.
    /// </summary>
    /// <param name="_agreementDate">
    /// Valid agreement date.
    /// </param>
    /// <returns>
    /// true if the agreement can be deleted; otherwise, false.
    /// </returns>
    public boolean canReleaseAgreement(
        TransDate _agreementDate = dateNull()
    )
    {
        // <GEERU>
        #ISOCountryRegionCodes
        boolean ret;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && _agreementDate)
        {
            ret = this.AgreementState == AgreementState::Effective;

            ret = ret &&
                  (_agreementDate <= this.DefaultAgreementLineExpirationDate || !this.DefaultAgreementLineExpirationDate) &&
                  _agreementDate >= this.DefaultAgreementLineEffectiveDate;

            return ret;
        }
        // </GEERU>
        return this.AgreementState == AgreementState::Effective;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllLinesHaveCompleteCommitments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that all lines associated with the current agreement header are referenced by at least one commitment line with a header document state of complete.
    /// </summary>
    /// <returns>
    /// true if all agreement lines associated with the current agreement header are referenced by at least one commitment line with a header document state of complete; otherwise, false.
    /// </returns>
    public boolean checkAllLinesHaveCompleteCommitments()
    {
        AgreementLine               agreementLine;
        PurchCommitmentLine_PSN     purchCommitmentLine;
        PurchCommitmentHeader_PSN   purchCommitmentHeader;
        boolean                     checkPassed = true;

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            // find any agreement line not associated with a commitment.
            select firstOnly RecId from agreementLine
                where agreementLine.Agreement   == this.RecId
            notexists join recId from purchCommitmentLine
                where purchCommitmentLine.AgreementLine == agreementLine.RecId;

            if (agreementLine)
            {
                checkPassed = false;
            }

            if (checkPassed)
            {
                // find any agreement line associated only with commitments that don't have a status of complete
                select firstOnly RecId from agreementLine
                    where agreementLine.Agreement   == this.RecId
                join recId from purchCommitmentLine
                    where purchCommitmentLine.AgreementLine == agreementLine.RecId
                notExists join recId from purchCommitmentHeader
                    where purchCommitmentHeader.RecId       == purchCommitmentLine.PurchCommitmentHeader_PSN
                        && purchCommitmentHeader.DocumentStatus == PurchCommitmentDocumentStatus_PSN::Complete;

                if (agreementLine)
                {
                    checkPassed = false;
                }
            }

            if (!checkPassed)
            {
                error("@SPS2496");
            }
        }

        return checkPassed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventOwner_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether it is possible to change agreement document title in case of related inventory owner.
    /// </summary>
    /// <returns>
    ///     true if there is no inventory owner or user accepts document title changing; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     Throws this exception if this method is not overriden in the subtype table.
    /// </exception>
    public boolean checkInventOwner_RU()
    {
        throw error(error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearAgreementReference_RU</Name>
				<Source><![CDATA[
    private void clearAgreementReference_RU(AgreementHeaderRecId _agreementHeaderRecId)
    {
        AgreementReference  agreementReference;
        boolean isRefExists;

        ttsbegin;

        while select forUpdate agreementReference
            where agreementReference.DerivedAgreement == _agreementHeaderRecId
               || agreementReference.SourceAgreement  == _agreementHeaderRecId
        {
            agreementReference.delete();
            isRefExists = true;
        }

        ttsCommit;

        if (isRefExists)
        {
            info("@GLS220564");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes <c>CurrencyCode</c> used by <c>AgreementHeader</c> and updates all <c>AgreementLines</c> recalculating their fields depedable on currency.
    /// </summary>
    /// <param name="_toCurrencyCode">
    /// New <c>CurrencyCode</c> to be used by <c>AgreementHeader</c>
    /// </param>
    /// <param name="_exchRateDate">
    /// The date to use when exchange rate between old and new currencies is calculated.
    /// </param>
    public void convertCurrencyCode(
        CurrencyCode    _toCurrencyCode,
        TransDate       _exchRateDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        AgreementLine agreementLine;

        if (_toCurrencyCode)
        {
            ttsBegin;

            while select forUpdate agreementLine
                where agreementLine.Agreement == this.RecId
                   && !agreementLine.IsDeleted
            {
                agreementLine.convertCurrencyCode(this.Currency, _toCurrencyCode, _exchRateDate);
                agreementLine.Currency = _toCurrencyCode;
                agreementLine.update();
            }

            this.Currency = _toCurrencyCode;

            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </summary>
    /// <param name="_defaultDimension">
    /// A dimension set to apply to the <c>defaultDimension</c> field on this table.
    /// </param>
    /// <param name="_dimensionCopy">
    /// A <c>dimensionCopy</c> object that was instantiated with the current buffer; optional.
    /// </param>
    /// <returns>
    /// A dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are not overwritten.
    /// </remarks>
    public DimensionDefault copyDimension(
        DimensionDefault _defaultDimension,
        DimensionCopy    _dimensionCopy = DimensionCopy::newFromTable(this, this.getLegalEntity().RecId)
        )
    {
        return _dimensionCopy.copy(_defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAgreementReleaseHeaderMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates instance of <c>AgreementReleaseHeaderMatch</c> linking Agreement header with Release order header.
    /// </summary>
    /// <param name="_releaseOrderHeader">
    /// Valid buffer of persisted Release order header.
    /// </param>
    /// <returns>
    /// Instance of <c>AgreementReleaseHeaderMatch</c> that links Agreement header with Release order header.
    /// </returns>
    /// <remarks>
    /// Release order header should have initialized PK fields values.
    /// This method should be overridden in the subtype tables. For more information, see the <see
    /// cref="T:PurchAgreementHeader" />, <see cref="T:SalesAgreementHeader" />.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Throws this exception if this method is not overriden in the subtype table.
    /// </exception>
    public AgreementReleaseHeaderMatch createAgreementReleaseHeaderMatch(Common _releaseOrderHeader)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the records from the <c>AgreementHeader</c> table and subtype tables.
    /// </summary>
    /// <remarks>
    /// For more information, see the <see cref="T:AgreementHeader" />, <see
    /// cref="T:AgreementHeaderDefault" />, <see cref="T:SalesAgreementHeader" />, <see
    /// cref="T:PurchAgreementHeader" />, <see cref="T:SalesAgreementHeaderDefault" />, <see
    /// cref="T:PurchAgreementHeaderDefault" />.
    /// </remarks>
    public void  delete()
    {
        AgreementHeaderRecId agreementHeaderRecId;
        // <GEERU>
        #ISOCountryRegionCodes
        AgreementHeaderExt_RU agreementHeaderExt;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ttsBegin;
            agreementHeaderRecId = this.RecId;

            select firstOnly forUpdate agreementHeaderExt
                where agreementHeaderExt.AgreementHeader == agreementHeaderRecId;

            if (agreementHeaderExt.RecId)
            {
                if (agreementHeaderExt.validateDelete())
                {
                    agreementHeaderExt.delete();
                }
                else
                {
                    throw Exception::Error;
                }
            }

            if (this.historyExists())
            {
                this.softDelete();
            }
            else
            {
                this.doDelete();
            }

            this.clearAgreementReference_RU(agreementHeaderRecId);
            ttsCommit;
        }
        else
        {
            // </GEERU>

            if (TaxIntegrationUtils::isTransitDocumentEnabled())
            {
                this.TransitDocumentTransactionMap_IN::deleteTransitDocumentsForHeader();
            }

            if (this.InterCompanySkipUpdate == InterCompanySkipUpdate::No)
            {
                // Intercompany agreement lines are deleted before the intercompany agreement header.
                agreementHeaderRecId = this.RecId;
            }

            if (this.historyExists())
            {
                this.softDelete();
            }
            else
            {               
                this.doDelete();
            }

            if (agreementHeaderRecId)
            {
                this.deleteIntercompanyAgreementHeader(agreementHeaderRecId);
            }
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteIntercompanyAgreementHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the related intercompany agreement header and the reference.
    /// </summary>
    /// <param name="_agreementHeaderRecId">
    ///    The record ID for the agreement being deleted.
    /// </param>
    /// <remarks>
    ///    Intercompany lines are deleted before the intercompany header.
    /// </remarks>
    private void deleteIntercompanyAgreementHeader(AgreementHeaderRecId _agreementHeaderRecId)
    {
        AgreementHeader     intercompanyAgreementHeader;
        AgreementReference  agreementReference;

        select forupdate agreementReference
            where agreementReference.DerivedAgreement == _agreementHeaderRecId
               || agreementReference.SourceAgreement  == _agreementHeaderRecId;

        if (agreementReference.RecId)
        {
            ttsbegin;
            select forupdate intercompanyAgreementHeader
                where (intercompanyAgreementHeader.RecId == agreementReference.SourceAgreement
                   || intercompanyAgreementHeader.RecId  == agreementReference.DerivedAgreement)
                   && intercompanyAgreementHeader.RecId  != _agreementHeaderRecId;
            intercompanyAgreementHeader.InterCompanySkipUpdate = InterCompanySkipUpdate::Internal;

            intercompanyAgreementHeader.delete();
            agreementReference.delete();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether a field in the <c>AgreementHeader</c> buffer has changed in relation to the
    /// intercompany.
    /// </summary>
    /// <param name="_fieldId">
    /// The field ID for the field to check for changes.
    /// </param>
    /// <returns>
    /// true if the field has changed in relation to the intercompany; otherwise, false.
    /// </returns>
    public boolean  fieldChanged(fieldId  _fieldId)
    {
        boolean  ret = false;

        if (!this.RecId)
        {
            ret = true;
        }

        if (this.orig().(_fieldId) != this.(_fieldId))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttachedDocuments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrives search object for documents attached to agreement.
    /// </summary>
    /// <param name="_docuTypeId">
    /// A type of the document.
    /// </param>
    /// <param name="_restriction">
    /// A restriction of the document.
    /// </param>
    /// <returns>
    /// A <c>DocuRefSearch</c> object.
    /// </returns>
    /// <remarks>
    /// <c>DocuRef</c> attachments are associated with base table instance <c>TableId</c>
    /// </remarks>
    public DocuRefSearch getAttachedDocuments(
        DocuTypeId _docuTypeId,
        DocuRestriction _restriction)
    {
        // 'this' will be of child type. DocuRef is stored referencing base table
        AgreementHeader agreementHeader = AgreementHeader::find(this.RecId);
        return DocuRefSearch::newTypeIdAndRestriction(agreementHeader, _docuTypeId, _restriction);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLegalEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the legal entity for the agreement.
    /// </summary>
    /// <returns>
    /// A <c>CompanyInfo</c>.
    /// </returns>
    /// <remarks>
    /// This method is an abstract method which must be implemented in the derived tables.
    /// It returns buying or selling legal entity, depending on the agreement type: Sales or Purchase.
    /// When called from the instance of type <c>AgreementHeader</c> throws an error.
    /// </remarks>
    public CompanyInfo getLegalEntity()
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModuleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the type of the agreement.
    /// </summary>
    /// <returns>
    /// Either the purchase or sales type.
    /// </returns>
    /// <remarks>
    /// This is the non-polymorphic counterpart of the <c>moduleType</c> method.
    /// </remarks>
    ModuleSalesPurch getModuleType()
    {
        if ( this is SalesAgreementHeader )
        {
            return ModuleSalesPurch::Sales;
        }
        else if ( this is PurchAgreementHeader )
        {
            return ModuleSalesPurch::Purch;
        }

        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>historyExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the history records exist for the agreement.
    /// </summary>
    /// <returns>
    ///    true if the history records exist; otherwise, false.
    /// </returns>
    public boolean historyExists()
    {
        return (select firstonly RecId from agreementHeaderHistory
                where agreementHeaderHistory.AgreementHeader == this.RecId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromAgreementClassification</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the agreement header values from the <c>AgreementClassification</c> record.
    /// </summary>
    /// <param name="_agreementClassification">
    ///    A table buffer that contains the <c>AgreementClassification</c> record.
    /// </param>
    public void initFromAgreementClassification(AgreementClassification _agreementClassification)
    {
        this.AgreementClassification = _agreementClassification.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustVendTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the default value for the <c>AgreemenHeader</c> records from the <c>CustTable</c> or
    ///    <c>VendTable</c> tables.
    /// </summary>
    /// <param name="_custVendTable">
    ///    The record of the <c>CustTable</c> or <c>VendTable</c> table.
    /// </param>
    /// <remarks>
    ///    For more information, see the <see cref="CustVendTable" />, <see cref="AgreementHeader" /> classes.
    /// </remarks>
    public void initFromCustVendTable(CustVendTable _custVendTable)
    {
        #ISOCountryRegionCodes

        this.Currency = _custVendTable.Currency;

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            this.Currency = Ledger::accountingCurrency();
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(this.DefaultDimension, _custVendTable.DefaultDimension);
        }
        else
        {
            // </GEERU>
            this.DefaultDimension = this.copyDimension(_custVendTable.DefaultDimension);
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the default value for the <c>AgreemenHeader</c> record from the project record.
    /// </summary>
    /// <param name="_projTable">
    ///    A table buffer that contains the project data.
    /// </param>
    public void initFromProjTable(ProjTable _projTable)
    {
        this.DefaultDimension = this.copyDimension(_projTable.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current <c>AgreementHeader</c> record with default values.
    /// </summary>
    public void initValue()
    {
        this.AgreementState                      = AgreementState::OnHold;
        this.DefaultAgreementLineType            = CommitmentType::ProductQuantity;
        this.DefaultAgreementLineEffectiveDate   = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        this.Language                            = CompanyInfo::languageId();
        this.Originator                          = DirPersonUser::current().PersonParty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Inserts a new record in the <c>AgreementHeader</c> table.
    /// </summary>
    public void insert()
    {
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (!AgreementHeaderExt_RU::getAgreementDimensionAttribute() &&
                !AgreementParameters_RU::find().DisableAgreementDimension)
            {
                throw error("@GLS220563");
            }
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyErrorAgreementClassification</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Throws an error.
    /// </summary>
    /// <param name="_fromDataAreaId">
    ///    The data area ID where the agreement classification is converted from.
    /// </param>
    /// <param name="_fromExtCodeId">
    ///    The external code that is used in the from data area for converting agreement classification.
    /// </param>
    /// <param name="_toExtCodeId">
    ///    The external code that is used in the to data area for converting agreement classification.
    /// </param>
    /// <remarks>
    ///    To be used when validation of agreement classification fails in intercompany scenarios.
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///   The error is always thrown.
    /// </exception>
    public void intercompanyErrorAgreementClassification(
        CompanyId
        _fromDataAreaId,
        ExtCodeId _fromExtCodeId,
        ExtCodeId _toExtCodeId
        )
    {
        changecompany(_fromDataAreaId)
        {
            throw error(strFmt("@SYS332511",
                ExtCodeValueTable::find(tableNum(AgreementClassification),this.AgreementClassification,_fromExtCodeId).ExtCodeValue,
                _toExtCodeId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyLinkExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether an intercompany link for the agreement exists.
    /// </summary>
    /// <returns>
    /// true if an intercompany link exists; otherwise, false.
    /// </returns>
    public boolean intercompanyLinkExist()
    {
        // <GEERU>
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            return (select firstonly RecId from agreementReference
                where (  agreementReference.SourceAgreement == this.RecId
                      || agreementReference.DerivedAgreement == this.RecId)
                   && !agreementReference.IsIntraCompany_RU).RecId != 0 ;
        }
        else
        {
            // </GEERU>
            return (select firstonly RecId from agreementReference where agreementReference.SourceAgreement == this.RecId
            || agreementReference.DerivedAgreement == this.RecId).RecId != 0 ;
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyOriginDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates how the agreement was created in relation to intercompany agreements.
    /// </summary>
    /// <returns>
    /// A string that indicates how the agreement is created in relation to intercompany agreements.
    /// </returns>
    display AgreementIntercompanyOrigin intercompanyOriginDisplay()
    {
        AgreementIntercompanyOrigin     agreementIntercompanyOrigin;
        DictEnum                        dictEnum = new DictEnum(enumNum(InterCompanyOrigin));

        if (AgreementReference::existSourceAgreement(this.RecId))
        {
            agreementIntercompanyOrigin = dictEnum.value2Name(InterCompanyOrigin::Source);
        }
        if (AgreementReference::existDerivedAgreement(this.RecId))
        {
            agreementIntercompanyOrigin = dictEnum.value2Name(InterCompanyOrigin::Derived);
        }
        return agreementIntercompanyOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyUpdateNow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the intercompany agreement should be updated.
    /// </summary>
    /// <returns>
    ///    true if the intercompany agreement should be updated; otherwise, false.
    /// </returns>
    public boolean  intercompanyUpdateNow()
    {
        #ISOCountryRegionCodes
        boolean  ret;

        if (!this.RecId)
        {
            ret = true;
        }

        if (this.orig().AgreementState                     != this.AgreementState
        ||  this.orig().AgreementClassification            != this.AgreementClassification
        ||  this.orig().DocumentExternalReference          != this.DocumentExternalReference
        ||  this.orig().Currency                           != this.Currency
        ||  this.orig().DocumentTitle                      != this.DocumentTitle
        ||  this.orig().DefaultAgreementLineEffectiveDate  != this.DefaultAgreementLineEffectiveDate
        ||  this.orig().DefaultAgreementLineExpirationDate != this.DefaultAgreementLineExpirationDate
        ||  this.orig().Language                           != this.Language
        ||  (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
            !DimensionDefaultFacade::areEqual(this.orig().DefaultDimension, this.DefaultDimension)))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intracompanyLinkExist_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether an intracompany link for the agreement exists.
    /// </summary>
    /// <returns>
    ///     true if an intracompany link exists; otherwise, false.
    /// </returns>
    public boolean intracompanyLinkExist_RU()
    {
        return (select firstonly RecId from agreementReference
            where (  agreementReference.SourceAgreement   == this.RecId
                   || agreementReference.DerivedAgreement == this.RecId)
               && agreementReference.IsIntraCompany_RU).RecId != 0 ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the invoice journal records exist for the agreement.
    /// </summary>
    /// <returns>
    ///    true if the invoice journal records exists; otherwise, false.
    /// </returns>
    public boolean invoiceExists()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDerivedAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether the agreement is a derived intercompany agreement.
    /// </summary>
    /// <returns>
    /// true if the agreement is an derived intercompany agreement; otherwise, false.
    /// </returns>
    public boolean isDerivedAgreement()
    {
        return AgreementReference::existDerivedAgreement(this.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDirectVendorInvoiceEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether direct vendor invoicing is enabled for the current purchase agreement classification.
    /// </summary>
    /// <returns>
    /// true if direct invoicing is enabled; otherwise, false.
    /// </returns>
    public boolean isDirectVendorInvoiceEnabled()
    {
        AgreementClassification agreementClassification;

        select firstOnly DirectInvoiceEnable_PSN from agreementClassification
            where agreementClassification.RecId == this.AgreementClassification;

        return agreementClassification.DirectInvoiceEnable_PSN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReleased</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the agreement is released.
    /// </summary>
    /// <returns>
    ///    true if any line for an agreemente has been released; otherwise, false.
    /// </returns>
    public boolean isReleased()
    {
        AgreementLineReleasedLine agreementLineReleasedLine;
        AgreementLine agreementLine;

        select firstonly RecId from agreementLineReleasedLine
            where agreementLineReleasedLine.IsDeleted == NoYes::No
                exists join agreementLine
                where  agreementLine.RecId     == agreementLineReleasedLine.AgreementLine
                    && agreementLine.Agreement == this.RecId;

        return agreementLineReleasedLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReleaseOrderMatched</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the agreement has a matched release order.
    /// </summary>
    /// <returns>
    ///    true if the agreement has a matched release order; otherwise, false.
    /// </returns>
    public boolean isReleaseOrderMatched()
    {
        return (select firstonly RecId from agreementReleaseHeaderMatch
                where agreementReleaseHeaderMatch.MatchingReleaseOrderAgreement == this.RecId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </summary>
    /// <param name="_defaultDimensionNew">
    /// A financial dimension that is used in merge.
    /// </param>
    /// <param name="_defaultDimensionOld">
    /// A financial dimension that is used in merge.
    /// </param>
    /// <param name="_dimensionMerge">
    /// A dimension merge object used in merge.
    /// </param>
    /// <returns>
    /// A dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are merged.
    /// </remarks>
    public DimensionDefault mergeDimension(
        DimensionDefault _defaultDimensionNew,
        DimensionDefault _defaultDimensionOld,
        DimensionMerge   _dimensionMerge = DimensionMerge::newFromTable(this, this.getLegalEntity().RecId)
        )
    {
        return _dimensionMerge.merge(_defaultDimensionNew, _defaultDimensionOld);
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the type of the agreement that is either purchase or sales.
    /// </summary>
    /// <returns>
    /// The type of agreement.
    /// </returns>
    /// <remarks>
    /// This method should be overridden in the subtype tables. For more information, see the <see
    /// cref="T:PurchAgreementHeader" />, <see cref="T:SalesAgreementHeader" />.
    /// </remarks>
    ModuleSalesPurch moduleType()
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>originatorName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the originators name for the current <c>AgreementHeader</c> record.
    /// </summary>
    /// <returns>
    ///    A string that contains the name of the originator.
    /// </returns>
    display DirPartyName originatorName()
    {
        return DirPartyTable::findRec(this.Originator).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>relatedObjectExistanceFlags</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether invoices, releases, and hisotry records assiciated with the current agreement
    ///    exist.
    /// </summary>
    /// <returns>
    ///    A container with Boolean values that indicate whether the invoices, releases, and history records
    ///    that are associated with the current agreement exist.
    /// </returns>
    /// <remarks>
    ///    This method is executed on the server and to minimize the number of client-server calls when an
    ///    environment discovery is made by a form regarding the current agreement.
    /// </remarks>
    container relatedObjectExistanceFlags()
    {
        container c;
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        c = conIns(c, AgreementHeader::posReleasesExist(),                  (this.isReleased())   );
        c = conIns(c, AgreementHeader::posConfirmationsExist(),             (this.historyExists()));
        c = conIns(c, AgreementHeader::posInvoicesExist(),                  (this.invoiceExists()));
        c = conIns(c, AgreementHeader::posCanCreateIntercompanyAgreement(), (this.canCreateIntercompanyAgreement()));
        c = conIns(c, AgreementHeader::posCanViewRelatedAgreement(),        (this.intercompanyLinkExist()));
        c = conIns(c, AgreementHeader::posCanDeleteAgreement(),             (this.canDeleteAgreement()));
        c = conIns(c, AgreementHeader::posCanReleaseAgreement(),            (this.canReleaseAgreement()));
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            c = conIns(c, AgreementHeader::posCanCreateIntracompanyAgreement_RU(), (this.canCreateIntracompanyAgreement_RU()));
            c = conIns(c, AgreementHeader::posCanViewRelatedAgreement_RU(),        (this.intracompanyLinkExist_RU()));
            c = conIns(c, AgreementHeader::posCanViewSettled_RU(),                 (this.AgreementState != AgreementState::OnHold));
            c = conIns(c, AgreementHeader::posCanViewNotSettled_RU(),              (this.AgreementState == AgreementState::Effective));
        }
        // </GEERU>

        return c;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAgreementReleaseHeaderMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and deletes instance of <c>AgreementReleaseHeaderMatch</c> that was linking Agreement header
    /// with Release order header.
    /// </summary>
    /// <param name="_releaseOrderHeader">
    /// Valid buffer of persisted Release order header.
    /// </param>
    /// <remarks>
    /// Release order header should have initialized PK fields values.
    /// This method should be overridden in the subtype tables. For more information, see the <see
    /// cref="T:PurchAgreementHeader" />, <see cref="T:SalesAgreementHeader" />.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Throws this exception if this method is not overriden in the subtype table.
    /// </exception>
    public void removeAgreementReleaseHeaderMatch(Common _releaseOrderHeader)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCheckFailedTextAgreementState</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the check failed text for the agreement state field.
    /// </summary>
    public void setCheckFailedTextAgreementState()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>showDocHandIcon</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the document handling icon for the current <c>SalesAgreementHeader</c> record.
    /// </summary>
    /// <returns>
    ///    The icon number to show the document handling icon for the <c>SalesAgreementHeader</c> record.
    /// </returns>
    display smmDocIconNum showDocHandIcon()
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>softDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Marks the agreement as deleted.
    /// </summary>
    /// <remarks>
    ///    This method does not delete the agreement records physically.It only sets the <c>IsDeleted</c>
    ///    field of the <c>AgreementHeader</c> and the <c>AgreementLine</c> tables to a <c>NoYes::Yes</c>
    ///    enumeration value.
    /// </remarks>
    private void softDelete()
    {
        AgreementLine agreementLine;

        ttsbegin;

        this.IsDeleted = NoYes::Yes;
        this.doUpdate();

        update_recordset agreementLine
        setting IsDeleted = NoYes::Yes
        where agreementLine.Agreement == this.RecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes a field value from this <c>AgreementHeader</c> record to another
    /// <c>AgreementHeader</c> record.
    /// </summary>
    /// <param name="_toAgreementHeader">
    /// The <c>AgreementHeader</c> record to which to synchronize the field value.
    /// </param>
    /// <param name="_create">
    /// Specifies whether the synchronization is performed in a creation scenario.
    /// </param>
    /// <param name="_fieldId">
    /// The field ID for the field to synchronize.
    /// </param>
    /// <remarks>
    /// This method is used in intercompany scenarios.
    /// </remarks>
    public void syncField(AgreementHeader _toAgreementHeader, boolean _create, fieldId _fieldId)
    {
        // <GEERU>
        DimensionAttributeValueSetStorage dimAttrValueSetStorage, toDimAttrValueSetStorage;
        int idx;
        // </GEERU>

        if (_create || this.fieldChanged(_fieldId))
        {
            // <GEERU>
            if (_fieldId == fieldNum(AgreementHeader, DefaultDimension))
            {
                dimAttrValueSetStorage   = DimensionAttributeValueSetStorage::find(this.DefaultDimension);
                toDimAttrValueSetStorage = DimensionAttributeValueSetStorage::find(_toAgreementHeader.DefaultDimension);
                for (idx = 1; idx <= dimAttrValueSetStorage.elements(); idx++)
                {
                    if (DimensionAttribute::find(dimAttrValueSetStorage.getAttributeByIndex(idx)).Type == DimensionAttributeType::CustomList)
                    {
                        toDimAttrValueSetStorage.addItem(DimensionAttributeValue::find(dimAttrValueSetStorage.getValueByIndex(idx)));
                    }
                }
                _toAgreementHeader.DefaultDimension = toDimAttrValueSetStorage.save();
            }
            else
            {
                // </GEERU>
                _toAgreementHeader.(_fieldId) = this.(_fieldId);
                // <GEERU>
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLinesDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes <c>DimensionDefault</c> used by <c>AgreementHeader</c>
    /// and updates all <c>AgreementLine</c> financial dimensions.
    /// </summary>
    /// <param name="_defaultDimension">
    /// New <c>DimensionDefault</c> to be used by <c>AgreementLine</c>
    /// </param>
    public void updateLinesDefaultDimension(DimensionDefault _defaultDimension)
    {
        AgreementLine   agreementLine;

        if (_defaultDimension)
        {
            ttsBegin;

            while select forUpdate agreementLine
                where agreementLine.Agreement == this.RecId
                   && !agreementLine.IsDeleted
            {
                agreementLine.updateDefaultDimension(_defaultDimension);
                agreementLine.update();
            }

            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the agreement can be deleted.
    /// </summary>
    /// <returns>
    ///    true if the agreement can be deleted; otherwise, false.
    /// </returns>
    public boolean validateDelete()
    {
        boolean ret;
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        ret = super();

        if (ret && this.isReleaseOrderMatched())
        {
            ret = checkFailed(this.validateDeleteErrorMessage());
        }

        // <GEERU>
        if (! SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        // </GEERU>
        {
            if (ret && this.isDerivedAgreement())
            {
                ret = checkFailed("@SYS334947");
            }
            // <GEERU>
        }
        // </GEERU>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDeleteErrorMessage</Name>
				<Source><![CDATA[
    public str validateDeleteErrorMessage()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates changes to a field in the <c>AgreementHeader</c> record.
    /// </summary>
    /// <param name="_fieldIdToCheck">
    ///    The field ID to validate.
    /// </param>
    /// <returns>
    ///    true if the value in the field change is valid; otherwise, false.
    /// </returns>
    public boolean validateField(fieldId _fieldIdToCheck)
    {
        boolean ret;

        ret = super(_fieldIdToCheck);

        switch (_fieldIdToCheck)
        {
            case fieldNum(AgreementHeader, DefaultAgreementLineExpirationDate),
                 fieldNum(AgreementHeader, DefaultAgreementLineEffectiveDate) :
                ret = AgreementHeader::validatePeriod(this.DefaultAgreementLineEffectiveDate,
                                                      this.DefaultAgreementLineExpirationDate);
                break;

            case fieldNum(AgreementHeader, AgreementState) :
                if (this.AgreementState == AgreementState::Effective && this.isAgreementUsingActiveIntercompanyPartner() && !this.intercompanyLinkExist())
                {
                    this.setCheckFailedTextAgreementState();
                    ret = false;
                }
                else if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    if (this.AgreementState == AgreementState::Effective && PublicSectorUtils::isFrenchRegulatoryEnabled())
                    {
                        ret = this.checkAllLinesHaveCompleteCommitments();
                    }
                }
                break;

            case fieldNum(AgreementHeader, Currency):
                ret = this.allowCurrencyChange();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>AgreementHeader</c> table exists.
    /// </summary>
    /// <param name="_agreementHeaderRecId">
    /// The record ID of the <c>AgreementHeader</c> record.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    static public boolean exist(AgreementHeaderRecId _agreementHeaderRecId)
    {
        if (_agreementHeaderRecId)
        {
            return (select firstonly RecId from agreementHeader
                    where agreementHeader.RecId  == _agreementHeaderRecId).RecId != 0;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>AgreementHeader</c> table.
    /// </summary>
    /// <param name="_agreementHeaderRecId">
    ///    The record ID of the <c>AgreementHeader</c> record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>AgreementHeader</c> table; otherwise, an empty record.
    /// </returns>
    static public AgreementHeader find( AgreementHeaderRecId _agreementHeaderRecId,
                                        boolean              _forUpdate = false)
    {
        AgreementHeader agreementHeader;

        if (_agreementHeaderRecId)
        {
            if (_forUpdate)
            {
                agreementHeader.selectForUpdate(_forUpdate);
            }

            select firstonly agreementHeader
                where agreementHeader.RecId == _agreementHeaderRecId;
        }

        return agreementHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logisticsLocationSelectionLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Looks up a <c>LogisticsPostalAddress</c> record.
    /// </summary>
    /// <param name="_formReferenceControl">
    ///    A reference to the <c>FormReferenceControl</c> object.
    /// </param>
    /// <param name="_entity">
    ///    A record in the <c>Customer</c>, <c>Vendor</c>, or <c>CompanyInfo</c> table.
    /// </param>
    /// <param name="_allowAddAddress">
    ///    The allow new address button.
    /// </param>
    /// <returns>
    ///    The selected <c>LogisticsPostalAddress</c> record.
    /// </returns>
    /// <remarks>
    /// The _allowAddAddress parameter is deprecated.
    /// </remarks>
    public static Common logisticsLocationSelectionLookup(FormReferenceControl _formReferenceControl,
                                                                 Common _entity,
                                                                 boolean _allowAddAddress = false)
    {
        Common ret;
        LogisticsLocationSelectionLookup lookup;

        lookup = LogisticsLocationSelectionLookup::newParameters(_formReferenceControl, _entity);

        lookup.addRoleByType(LogisticsLocationRoleType::Delivery);

        lookup.parmAllowEnhancedSelect(false);
        lookup.parmReturnLocation(false);

        ret = lookup.performFormLookup();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyAgreementsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrives a query for affective party agreements for a certain customer.
    /// </summary>
    /// <param name="_agreementHeaderTableId">
    ///   Sales or purchase agreement header table id.
    /// </param>
    /// <param name="_partyAccountFieldId">
    ///   The party account table field number.
    /// </param>
    /// <param name="_custVendAccount">
    ///   Party account number.
    /// </param>
    /// <param name="_transDate">
    ///   The transaction date.
    /// </param>
    /// <param name="_firstOnly">
    ///   Specifies whether the query should retrieve only the first record.
    /// </param>
    /// <param name="_agreementHeaderExtTableId">
    ///   Sales or purchase extension agreement header table id.
    /// </param>
    /// <returns>
    ///   The query for an effective agreements for a certain users.
    /// </returns>
    public static Query partyAgreementsQuery(tableId _agreementHeaderTableId,
        fieldId _partyAccountFieldId,
        CustVendAC _custVendAccount,
        TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        boolean _firstOnly = false
        ,TableId _agreementHeaderExtTableId = 0
        )
    {
        Query                   query = new Query();
        QueryBuildDataSource    queryBuildDataSource;
        QueryBuildRange         queryBuildRange;
        FieldId                 sellingBuyingLegalEntityFieldId;
        date                    transDate = _transDate ? _transDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // <GEERU>
        if (countryRegion_RU && _agreementHeaderExtTableId)
        {
            queryBuildDataSource = query.addDataSource(_agreementHeaderExtTableId);

            if (_firstOnly)
            {
                queryBuildDataSource.firstOnly(true);
            }

            queryBuildDataSource = queryBuildDataSource.addDataSource(_agreementHeaderTableId);
            queryBuildDataSource.relations(true);
        }
        else
        {
            // </GEERU>
            queryBuildDataSource = query.addDataSource(_agreementHeaderTableId);

            if (_firstOnly)
            {
                queryBuildDataSource.firstOnly(true);
            }
            // <GEERU>
        }
        // </GEERU>

        queryBuildRange = queryBuildDataSource.addRange(_partyAccountFieldId);
        queryBuildRange.value(_custVendAccount);
        queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementHeader, AgreementState));
        queryBuildRange.value(queryValue(AgreementState::Effective));
        queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementHeader, IsDeleted));
        queryBuildRange.value(queryValue(NoYes::No));
        // <GEERU>
        if (countryRegion_RU)
        {
            if (_transDate)
            {
                queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementHeader, DefaultAgreementLineExpirationDate));
                queryBuildRange.value(SysQuery::range(transDate, null)+","+queryValue(dateNull()));
                queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementHeader, DefaultAgreementLineEffectiveDate));
                queryBuildRange.value(SysQuery::range(null, transDate));
            }
        }
        else
        {
            // </GEERU>
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementHeader, EarliestLineEffectiveDate));
            queryBuildRange.value(SysQuery::range(null, transDate));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementHeader, LatestLineExpirationDate));
            queryBuildRange.value(SysQuery::range(transDate, null));
            // <GEERU>
        }
        // </GEERU>

        // Refine resulting query by restricting results to current Selling/Buying Legal Entity:
        switch (_agreementHeaderTableId)
        {
            case tableNum(SalesAgreementHeader):
                sellingBuyingLegalEntityFieldId = fieldNum(SalesAgreementHeader, SellingLegalEntity);
                break;

            case tableNum(PurchAgreementHeader):
                sellingBuyingLegalEntityFieldId = fieldNum(PurchAgreementHeader, BuyingLegalEntity);
                break;
        }

        if (sellingBuyingLegalEntityFieldId)
        {
            queryBuildRange = queryBuildDataSource.addRange(sellingBuyingLegalEntityFieldId);
            queryBuildRange.value(queryValue(CompanyInfo::current()));
        }

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            queryBuildDataSource = queryBuildDataSource.addDataSource(tableNum(AgreementClassification));
            queryBuildDataSource.joinMode(JoinMode::ExistsJoin);
            queryBuildDataSource.relations(true);

            queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementClassification, DirectInvoiceEnable_PSN));
            queryBuildRange.value(queryValue(NoYes::No));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCanCreateIntercompanyAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the release existence flag in the result container that was returned by
    /// the <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    /// The position of the release existence flag in the container.
    /// </returns>
    /// <remarks>
    /// This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posCanCreateIntercompanyAgreement()
    {
        return 4;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCanCreateIntracompanyAgreement_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the position of the release existence flag in the result container that was returned by
    ///     the <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    ///     The position of the release existence flag in the container.
    /// </returns>
    /// <remarks>
    ///     This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posCanCreateIntracompanyAgreement_RU()
    {
        return 8;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCanDeleteAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the history existence flag in the result container that was returned by
    /// the <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    /// The position of the history existence flag in the container.
    /// </returns>
    /// <remarks>
    /// This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posCanDeleteAgreement()
    {
        return 6;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCanReleaseAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the position of the release existence flag in a result container that was returned by the
    ///     <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    ///     The position of the release existence flag in the container.
    /// </returns>
    /// <remarks>
    ///     This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posCanReleaseAgreement()
    {
        return 7;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCanViewNotSettled_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the position of the history existence flag in a result container that was returned by the
    ///     <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    ///     The position of the history existence flag in the container.
    /// </returns>
    /// <remarks>
    ///     This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posCanViewNotSettled_RU()
    {
        return 11;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCanViewRelatedAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the history existence flag in a result container that was returned by the
    /// <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    /// The position of the history existence flag in the container.
    /// </returns>
    /// <remarks>
    /// This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posCanViewRelatedAgreement()
    {
        return 5;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCanViewRelatedAgreement_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the position of the history existence flag in a result container that was returned by the
    ///     <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    ///     The position of the history existence flag in the container.
    /// </returns>
    /// <remarks>
    ///     This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posCanViewRelatedAgreement_RU()
    {
        return 9;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCanViewSettled_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the position of the history existence flag in a result container that was returned by the
    ///     <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    ///     The position of the history existence flag in the container.
    /// </returns>
    /// <remarks>
    ///     This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posCanViewSettled_RU()
    {
        return 10;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posConfirmationsExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the history existence flag in a result container that was returned by the
    /// <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    /// The position of the history existence flag in the container.
    /// </returns>
    /// <remarks>
    /// This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posConfirmationsExist()
    {
        return 2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posInvoicesExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the invoice existence flag in a result container that was returned by the
    /// <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    /// The position of the history existence flag in the container.
    /// </returns>
    /// <remarks>
    /// This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posInvoicesExist()
    {
        return 3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posReleasesExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the release existence flag in a result container that was returned by the
    /// <c>relatedObjectExistanceFlags</c> method.
    /// </summary>
    /// <returns>
    /// The position of the release existence flag in the container.
    /// </returns>
    /// <remarks>
    /// This method is used by the <c>relatedObjectExistanceFlags</c> method and consumers of that method.
    /// </remarks>
    static int posReleasesExist()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates a period from effective date to expirations date.
    /// </summary>
    /// <param name="_effectiveDate">
    ///    The effective date to validate.
    /// </param>
    /// <param name="_expirationDate">
    ///    The expiration date to validate.
    /// </param>
    /// <returns>
    ///    true if the period is valid; otherwise, false.
    /// </returns>
    public static boolean validatePeriod(EffectiveDate  _effectiveDate,
                                         ExpirationDate _expirationDate)
    {
        boolean     ok = true;

        if (_effectiveDate && _expirationDate)
        {
            if (_effectiveDate > _expirationDate)
            {
                ok = checkFailed("@SYS302117");
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findIntercompanyAgreementActionPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and returns an <c>IntercompanyAgreementActionPolicy</c> record.
    /// </summary>
    /// <returns>
    /// An <c>IntercompanyAgreementActionPolicy</c> record.
    /// </returns>
    public IntercompanyAgreementActionPolicy findIntercompanyAgreementActionPolicy()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCurrencyChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompts user about currency code update and agreement lines recalculations.
    /// Performs necessary updates of every <c>AgreementLine</c> when requested by user.
    /// </summary>
    private void handleCurrencyChange()
    {
        AgreementHeader origAgreementHeader = this.orig();

        if (this.Currency != origAgreementHeader.Currency)
        {
            CurrencyCode newCurrencyCode = this.Currency;
            this.Currency = origAgreementHeader.Currency;

            if (!FormDataUtil::isFormDataSource(this)
                || Box::okCancel("@SYS345143", DialogButton::Ok, "@SYS345144") == DialogButton::Ok)
            {
                this.convertCurrencyCode(newCurrencyCode);
            }
            else
            {
                this.fieldState(fieldNum(AgreementHeader, Currency), FieldState::NotSet);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleFinancialDimensionsLinesUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompts user about financial dimensions update and agreement lines update.
    /// Performs necessary updates of every <c>AgreementLine</c> if confirmed by user.
    /// </summary>
    private void handleFinancialDimensionsLinesUpdate()
    {
        if (!DimensionDefaultFacade::areEqual(this.DefaultDimension, this.orig().DefaultDimension))
        {
            boolean mustUpdate = true;
            if (FormDataUtil::isFormDataSource(this))
            {
                mustUpdate = Box::yesNo("@SCM:FinancialDimensionsChanged_UpdateAgreementLinesWithHeaderValues_DialogLabel", DialogButton::Yes, "@SYS4004689") == DialogButton::Yes;
            }

            if (mustUpdate)
            {
                this.updateLinesDefaultDimension(this.DefaultDimension);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        this.handleCurrencyChange();
        this.handleFinancialDimensionsLinesUpdate();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContactPerson</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the specified contact person can be referenced in the agreement.
    /// </summary>
    /// <param name="_contactPersonId">The ID of the contact person.</param>
    /// <returns>true, if the specified contact person can be referenced in the agreement; otherwise, false.</returns>
    public boolean validateContactPerson(ContactPersonId _contactPersonId)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldEditabilityDataProvider</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an instance of the <c>AgreementHeaderFieldEditabilityDataProvider</c> object for the agreement header.
    /// </summary>
    /// <returns>An instance of the <c>AgreementHeaderFieldEditabilityDataProvider</c> object for the agreement header.</returns>
    public AgreementHeaderFieldEditabilityDataProvider fieldEditabilityDataProvider()
    {
        return AgreementHeaderFieldEditabilityDataProvider::newFromAgreementHeader(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the currency code.
    /// </summary>
    /// <returns>
    ///     The currency code.
    /// </returns>
    /// <remarks>
    ///     Used with the <c>CustVendReportingCurrencyFixedExchangeRate</c> map.
    /// </remarks>
    internal CurrencyCode getCurrencyCode()
    {
        return this.Currency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canConfirmAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the agreement can be confirmed.
    /// </summary>
    /// <param name="_agreementState">
    /// Status of the agreement.
    /// </param>
    /// <returns>
    /// true if the agreement can be confirmed; otherwise, false.
    /// </returns>
    [Hookable(false)]
    internal boolean canConfirmAgreement(AgreementState _agreementState = this.AgreementState)
    {
        return _agreementState != AgreementState::Closed;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>TradeBlanketOrder</ConfigurationKey>
	<DeveloperDocumentation>@SYS325319</DeveloperDocumentation>
	<Label>@SYS15240</Label>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>DocumentTitle</TitleField1>
	<TitleField2>AgreementState</TitleField2>
	<Abstract>Yes</Abstract>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<InstanceRelationType>InstanceRelationType</InstanceRelationType>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>ProcurementAndSourcing</Modules>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<SupportInheritance>Yes</SupportInheritance>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>AgreementHeaderDefault</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>AgreementHeaderDefault</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AgreementState</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Currency</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DocumentTitle</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AgreementState</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AgreementClassification</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Originator</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AgreementLineDefaultingPolicy</Name>
			<Label>@SYS190139</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultAgreementLineType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DefaultAgreementLineEffectiveDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DefaultAgreementLineExpirationDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Currency</Name>
			<Label>@SYS7572</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Currency</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Details</Name>
			<Label>@SYS80118</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AgreementClassification</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DocumentTitle</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DocumentExternalReference</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Originator</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Language</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimension</Name>
			<Label>@SYS342338</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Status</Name>
			<Label>@SYS183849</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AgreementState</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ValidityPeriod</Name>
			<Label>@SYS95282</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>EarliestLineEffectiveDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LatestLineExpirationDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>AgreementClassification</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementClassificationRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AgreementState</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>AgreementState</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Currency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DefaultAgreementLineEffectiveDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EffectiveDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DefaultAgreementLineExpirationDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExpirationDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DefaultAgreementLineType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS302526</Label>
			<EnumType>CommitmentType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDefaultDimensionValueSet</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DocumentExternalReference</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementDocumentExternalReference</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DocumentTitle</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementDocumentTitle</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>EarliestLineEffectiveDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EarliestEffectiveDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InstanceRelationType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RelationType</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InterCompanySkipUpdate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
			<EnumType>InterCompanySkipUpdate</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsDeleted</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Language</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LanguageId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>LatestLineExpirationDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LatestExpirationDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Originator</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>AgreementClassificationIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>AgreementClassification</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>OriginatorIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Originator</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CurrencyIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Currency</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>AgreementHeaderMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>AgreementClassification</MapField>
					<MapFieldTo>AgreementClassification</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DocumentTitle</MapField>
					<MapFieldTo>DocumentTitle</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DocumentExternalReference</MapField>
					<MapFieldTo>DocumentExternalReference</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Currency</MapField>
					<MapFieldTo>Currency</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DefaultAgreementLineType</MapField>
					<MapFieldTo>DefaultAgreementLineType</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DefaultAgreementLineEffectiveDate</MapField>
					<MapFieldTo>DefaultAgreementLineEffectiveDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DefaultAgreementLineExpirationDate</MapField>
					<MapFieldTo>DefaultAgreementLineExpirationDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Originator</MapField>
					<MapFieldTo>Originator</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Language</MapField>
					<MapFieldTo>Language</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>DimensionDefaultMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>DefaultDimension</MapField>
					<MapFieldTo>DefaultDimension</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AgreementClassification</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>AgreementClassification</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>AgreementClassification</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>AgreementClassification_AgreementHeader</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AgreementClassification</Name>
					<Field>AgreementClassification</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>Currency</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>Currency_AgreementHeader</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Currency</Name>
					<Field>Currency</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DimensionAttributeValueSet</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DimensionAttributeValueSet_AgreementHeader</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LanguageTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LanguageTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Language</Name>
					<Field>Language</Field>
					<RelatedField>LanguageId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>LabelFile_Extern</Name>
					<RelatedField>LabelFile</RelatedField>
					<Value>1</Value>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Key</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Originator</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DirPerson</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>DirPerson</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DirPerson_AgreementHeader</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Originator</Name>
					<Field>Originator</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>