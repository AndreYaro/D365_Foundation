<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesBookTable_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class SalesBookTable_RU extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>findPurchBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for purch book for the same period as current sales book
    /// </summary>
    /// <returns>
    /// Found purchase book
    /// </returns>
    public PurchBookTable_RU findPurchBook()
    {
        PurchBookTable_RU  purchBookTable, purchBookTableCount;
        SalesBookTable_RU  salesBookTableCount;
        TransDate          toDate;

        select count(RecId) from salesBookTableCount;
        select count(RecId) from purchBookTableCount;

        if (salesBookTableCount.RecId == 1 && purchBookTableCount.RecId == 1)
        {
            select firstonly purchBookTable;
        }
        else
        {
            toDate = this.getToDate();
            while select purchBookTable
            {
                if (purchBookTable.getToDate() == toDate)
                {
                    break;
                }
            }
        }

        return purchBookTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns starting date for sales book
    /// </summary>
    /// <returns>
    /// Starting date for sales book
    /// </returns>
    public TransDate getFromDate()
    {
        return this.SalesPurchBookTable_RU::getFromDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreviousBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns previous sales book
    /// </summary>
    /// <returns>
    /// Previous sales book
    /// </returns>
    public SalesPurchBookTable_RU getPreviousBook()
    {
        return this.SalesPurchBookTable_RU::getPreviousBook();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getToDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns ending date for sales book
    /// </summary>
    /// <returns>
    /// Ending date for sales book
    /// </returns>
    public TransDate getToDate()
    {
        return this.SalesPurchBookTable_RU::getToDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isActiveBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if current book is active
    /// </summary>
    /// <returns>
    /// True if current book is active(not closed); Otherwise false
    /// </returns>
    public boolean isActiveBook()
    {
        return this.ClosingDate == dateNull() ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLastBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if current book is last book
    /// </summary>
    /// <returns>
    /// True if current book is last; Otherwise false
    /// </returns>
    public boolean isLastBook()
    {
        if (this.isActiveBook())
        {
            return true;
        }

        if (SalesBookTable_RU::existActiveBook())
        {
            return false;
        }

        return (select firstonly RecId from salesbookTable_RU
                    index hint ClosingDateIdx
                    where salesbookTable_RU.ClosingDate > this.ClosingDate).RecId ? false : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSortFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds sorting for a given <c>QueryBuildDataSource</c>
    /// </summary>
    /// <param name="_bookRecId">
    /// RecId of sales book
    /// </param>
    /// <param name="_queryBuildDataSource">
    /// <c>QueryBuildDataSource</c> object to be updated
    /// </param>
    public static void addSortFields(SalesPurchBookRecId_RU _bookRecId, QueryBuildDataSource _queryBuildDataSource)
    {
        if (SalesBookTable_RU::find(_bookRecId).Policy == CustTaxation_RU::OnPayment)
        {
            _queryBuildDataSource.addSortField(fieldNum(SalesBookTrans_RU, PaymentDate));
            _queryBuildDataSource.addSortField(fieldNum(SalesBookTrans_RU, FactureDate_External));
            _queryBuildDataSource.addSortField(fieldNum(SalesBookTrans_RU, FactureExternalId));
            _queryBuildDataSource.addSortField(fieldnum(SalesBookTrans_RU, RevisionSeqNumber));
            _queryBuildDataSource.addSortField(fieldnum(SalesBookTrans_RU, Annulment));
        }
        else
        {
            _queryBuildDataSource.addSortField(fieldNum(SalesBookTrans_RU, FactureDate_External));
            _queryBuildDataSource.addSortField(fieldNum(SalesBookTrans_RU, FactureExternalId));
            _queryBuildDataSource.addSortField(fieldnum(SalesBookTrans_RU, RevisionSeqNumber));
            _queryBuildDataSource.addSortField(fieldnum(SalesBookTrans_RU, Annulment));
            _queryBuildDataSource.addSortField(fieldNum(SalesBookTrans_RU, PaymentDate));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>booksInPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container with Purchase books record Ids which were closed in given period,
    /// or, if ending date of period is greater than last closed workbook date, which were closed later than
    /// start date or not closed at all
    /// </summary>
    /// <param name="_bookRecId">
    /// Purchase book record id, added to result if no records were found
    /// </param>
    /// <param name="_fromDate">
    /// Starting date of period
    /// </param>
    /// <param name="_toDate">
    /// Ending date of period
    /// </param>
    /// <returns>
    /// Container with Purchase books record
    /// </returns>
    public static container booksInPeriod(SalesPurchBookRecId_RU _bookRecId,
                                          TransDate              _fromDate  = dateNull(),
                                          TransDate              _toDate    = dateNull())
    {
        SalesBookTable_RU   salesBookTable;
        TransDate           closingDate, bookToDate;
        container           ret;

        if (_fromDate || _toDate)
        {
            closingDate = SalesBookTable_RU::getLastClosedBook().ClosingDate;

            if (closingDate >= _toDate)
            {
                while select RecId from salesBookTable
                    order by BookId
                    where salesBookTable.ClosingDate >= _fromDate &&
                          salesBookTable.ClosingDate <= _toDate
                {
                    ret += salesBookTable.RecId;
                }
            }
            else
            {
                while select * from salesBookTable
                    order by BookId
                    where salesBookTable.ClosingDate >= _fromDate ||
                        ! salesBookTable.ClosingDate
                {
                    bookToDate = salesBookTable.getToDate();

                    if (bookToDate >= _fromDate && bookToDate <= _toDate)
                    {
                        ret += salesBookTable.RecId;
                    }
                }
            }
        }

        if (! ret && _bookRecId)
        {
            ret += _bookRecId;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canProcessDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if purchase book can be closed on specified date
    /// </summary>
    /// <param name="_date">
    /// Date on which book should be closed
    /// </param>
    /// <param name="_closingDate">
    /// Date to be checked, if omitted
    /// </param>
    /// <returns>
    /// True if can be closed; otherwise false
    /// </returns>
    public static boolean canProcessDate(TransDate _date, TransDate _closingDate = dateNull())
    {
        boolean                 ret = true;
        SalesBookClosingDate_RU closingDate = (! prmisDefault(_closingDate)) ? _closingDate : SalesBookTable_RU::getLastClosedBook().ClosingDate;

        if (closingDate && (closingDate >= _date))
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfCanBeSettled_Cust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if customer transactions can be setteled on specified date depending on state of purchase books
    /// </summary>
    /// <param name="_custTransInvoice">
    /// Debet customer transaction
    /// </param>
    /// <param name="_custTransPayment">
    /// Credit customer transaction
    /// </param>
    /// <param name="_settlementDate">
    /// Date of settlement
    /// </param>
    /// <returns>
    /// True if transactions can be settled; otherwise false
    /// </returns>
    public static boolean checkIfCanBeSettled_Cust(CustTrans _custTransInvoice,
                                                          CustTrans _custTransPayment,
                                                          TransDate _settlementDate)
    {
        boolean                    ok = true;
        SalesBookTable_RU          salesBookTable;
        TransDate                  maxTransDate, paymentDate;

        FactureJour_RU             factureJour;
        CustInvoiceJour            custInvoiceJour;
        CustInvoiceJour_RU         custInvoiceJour_RU;
        TaxReportPeriod            facturePeriod, paymentPeriod;
        TaxTable                   taxTable;
        RecordSortedList           sortedList;
        CustTaxation_RU            custTaxation = CustParameters::taxation_RU(_custTransInvoice.TransDate);
        CustVendTransPostingLog_RU postingLog;

        #VATTransitionPeriod_RU

        if ( ! _custTransInvoice || ! _custTransPayment)
        {
            return true;
        }

        //all checks must be performed in invoice company
        changecompany(_custTransInvoice.company())
        {
            if (_custTransInvoice.Invoice)
            {
                custInvoiceJour = CustInvoiceJour::findFromCustTrans(_custTransInvoice.Invoice,
                                                                     _custTransInvoice.TransDate,
                                                                     _custTransInvoice.AccountNum,
                                                                     false,
                                                                     _custTransInvoice.Voucher);
            }

            paymentDate = max(_custTransPayment.TransDate, _settlementDate);

            salesBookTable = SalesBookTable_RU::getLastClosedBook();

            // if invoice has been posted 'on payment' and before transition period
            // system should check possibility of reversing settlement based on existing of posting log record with VATTransit type
            if (custTaxation == CustTaxation_RU::OnDelivery && _custTransInvoice.TransDate <  #TransitionStartDate && _settlementDate <= #TransitionEndDateOld)
            {
                select firstonly RecId from postingLog
                    where (postingLog.TransRecId     == _custTransInvoice.RecId  &&
                           postingLog.TransCompany   == _custTransInvoice.company()  &&
                           postingLog.OffSetRecId    == _custTransPayment.RecId      &&
                           postingLog.OffsetCompany  == _custTransPayment.company()) ||
                          (postingLog.TransRecId     == _custTransPayment.RecId  &&
                           postingLog.TransCompany   == _custTransPayment.company()  &&
                           postingLog.OffSetRecId    == _custTransInvoice.RecId      &&
                           postingLog.OffsetCompany  == _custTransInvoice.company()) &&
                           postingLog.RefTableId     == tableNum(CustTrans)      &&
                           postingLog.PostingLogType == CustVendTransPostingLogType_RU::VATTransit;
            }

            custInvoiceJour_RU = custInvoiceJour.custInvoiceJour_RU();

            if (custTaxation == CustTaxation_RU::OnPayment || custInvoiceJour_RU.VATOnPayment_RU || postingLog)
            {
                if (custTaxation == CustTaxation_RU::OnPayment || custInvoiceJour_RU.VATOnPayment_RU)
                {
                    if (_custTransInvoice.TransDate < #TransitionStartDate && _settlementDate > #TransitionEndDateOld)
                    {
                        return checkFailed(strFmt("@GLS110918",
                                                  _custTransInvoice.AccountNum,
                                                  _custTransInvoice.Invoice,
                                                  _custTransInvoice.TransDate,
                                                  year(#TransitionStartDate),
                                                  year(_settlementDate),
                                                  CustTaxation_RU::OnDelivery));
                    }
                }

                select firstonly TaxPeriod from taxTable
                    where taxTable.TaxType_W == TaxType_W::VAT        ||
                          taxTable.TaxType_W == TaxType_W::VATReduced ||
                          taxTable.TaxType_W == TaxType_W::VATZero;

                if (taxTable.TaxPeriod)
                {
                    paymentPeriod = TaxReportPeriod::find(taxTable.TaxPeriod, paymentDate);

                    if (! paymentPeriod)
                    {
                        error(strFmt("@GLS102560", _custTransPayment.Voucher, _custTransPayment.TransDate, _settlementDate));
                        return checkFailed(strFmt(TaxPeriodHead::txtNotExist(), TaxType_W::VAT));
                    }

                    if (_custTransInvoice.Invoice)
                    {
                        sortedList = custInvoiceJour.factureJourSortedList_RU();

                        while (sortedList.next(factureJour))
                        {
                            maxTransDate = max(factureJour.FactureDate,  _settlementDate);

                            if (salesBookTable && maxTransDate <= salesBookTable.ClosingDate)
                            {
                                return checkFailed(strFmt("@GLS101254", salesBookTable.BookId));
                            }

                            facturePeriod = TaxReportPeriod::find(taxTable.TaxPeriod, factureJour.FactureDate);

                            if ( ! facturePeriod)
                            {
                                error(strFmt("@GLS104865", factureJour.FactureExternalId, factureJour.FactureDate));
                                return checkFailed(strFmt(TaxPeriodHead::txtNotExist(), TaxType_W::VAT));
                            }

                            if (facturePeriod.RecId != paymentPeriod.RecId)
                            {
                                warning("@GLS104858");
                                warning(strFmt("@GLS104864", _custTransPayment.Voucher, factureJour.FactureExternalId));
                            }
                        }
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfCanBeSettled_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if customer or vendor transactions can be setteled on specified date depending on state of purchase books
    /// </summary>
    /// <param name="_custVendTransInvoice">
    /// Invoice customer transaction
    /// </param>
    /// <param name="_custVendTransPayment">
    /// Payment customer transaction
    /// </param>
    /// <param name="_settlementDate">
    /// Date of settlement
    /// </param>
    /// <returns>
    /// True if transactions can be settled; otherwise false
    /// </returns>
    public static boolean checkIfCanBeSettled_RU(CustVendTrans _custVendTransInvoice,
                                                        CustVendTrans _custVendTransPayment,
                                                        TransDate     _settlementDate)
    {
        switch (_custVendTransInvoice.TableId)
        {
            case tableNum(CustTrans) :
                return SalesBookTable_RU::checkIfCanBeSettled_Cust(_custVendTransInvoice, _custVendTransPayment, _settlementDate);
            case tableNum(VendTrans) :
                return SalesBookTable_RU::checkIfCanBeSettled_Vend(_custVendTransInvoice, _custVendTransPayment, _settlementDate);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfCanBeSettled_Vend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the customer transactions can be settled on a specified date that depends on the
    /// state of purchase books.
    /// </summary>
    /// <param name="_vendTransInvoice">
    /// A credit vendor transaction.
    /// </param>
    /// <param name="_vendTransPayment">
    /// A debt vendor transaction.
    /// </param>
    /// <param name="_settlementDate">
    /// The settlement date.
    /// </param>
    /// <returns>
    /// true if the transactions can be settled; otherwise false.
    /// </returns>
    public static boolean checkIfCanBeSettled_Vend(VendTrans _vendTransInvoice,
                                                          VendTrans _vendTransPayment,
                                                          TransDate _settlementDate)
    {
        boolean                             ok = true;
        SalesBookTable_RU                   salesBookTable;
        TransDate                           maxTransDate;
        TaxTable                            taxTable;
        TaxReportPeriod                     taxReportPeriod;
        PurchBookVATProcessLogTrans_RU      purchBookProcessLogTrans;
        PurchBookVATProcessLogTransOper_RU  purchBookProcessLogTransOper;

        // all check must be performed in payment company
        changecompany (_vendTransPayment.company())
        {
            salesBookTable = SalesBookTable_RU::getLastClosedBook();

            select firstonly TaxPeriod from taxTable
                where taxTable.TaxType_W == TaxType_W::VAT        ||
                      taxTable.TaxType_W == TaxType_W::VATReduced ||
                      taxTable.TaxType_W == TaxType_W::VATZero;

            if (taxTable.TaxPeriod)
            {
                maxTransDate = max(max(_vendTransPayment.TransDate, _settlementDate), _vendTransInvoice.TransDate);

                taxReportPeriod = TaxReportPeriod::find(taxTable.TaxPeriod, maxTransDate);

                if (! taxReportPeriod)
                {
                    error(strFmt("@GLS102560", _vendTransPayment.Voucher, _vendTransPayment.TransDate, _settlementDate));
                    return checkFailed(strFmt(TaxPeriodHead::txtNotExist(), TaxType_W::VAT));
                }

                if (salesBookTable && maxTransDate <= salesBookTable.ClosingDate)
                {
                    // invoice transaction is in incoming VAT processing in invoice company
                    changecompany(_vendTransInvoice.company())
                    {
                        select firstonly RecId from purchBookProcessLogTrans
                        exists join purchBookProcessLogTransOper
                            where purchBookProcessLogTrans.RecId                == purchBookProcessLogTransOper.RefRecId &&
                                  purchBookProcessLogTrans.InvoiceRecIdRef      == _vendTransInvoice.RecId               &&
                                  purchBookProcessLogTrans.InvoiceCompany       == _vendTransInvoice.company()           &&
                                  purchBookProcessLogTransOper.CanceledRefRecId == 0                                     &&
                                  purchBookProcessLogTransOper.Blocked          == NoYes::No                             &&
                                  purchBookProcessLogTransOper.BlockedAuto      == NoYes::No;
                    }

                    if (purchBookProcessLogTrans)
                    {
                        select firstonly RecId from purchBookProcessLogTrans
                        exists join purchBookProcessLogTransOper
                            where purchBookProcessLogTrans.RecId                == purchBookProcessLogTransOper.RefRecId &&
                                  purchBookProcessLogTrans.PaymentRecIdRef      == _vendTransPayment.RecId               &&
                                  purchBookProcessLogTrans.PaymentCompany       == _vendTransPayment.company()           &&
                                  purchBookProcessLogTransOper.CanceledRefRecId == 0                                     &&
                                  purchBookProcessLogTransOper.Blocked          == NoYes::No                             &&
                                  purchBookProcessLogTransOper.BlockedAuto      == NoYes::No;

                        if (purchBookProcessLogTrans)
                        {
                            return checkFailed(strFmt("@GLS113567", salesBookTable.BookId));
                        }
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDefaultQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates default query for use in purchase book report.
    /// </summary>
    /// <param name="_bookRecId">
    /// RecId of purch book.
    /// </param>
    /// <param name="_query">
    /// Query which is already initialized.
    /// </param>
    /// <param name="_fromDate">
    /// Start date of period.
    /// </param>
    /// <param name="_toDate">
    /// End date of period.
    /// </param>
    /// <param name="_initBookId">
    /// If true only book table rec id ranges cleared, otherwise all ranges cleared.
    /// </param>
    /// <returns>
    /// Query for use in purchase book report.
    /// </returns>
    #VATTransitionPeriod_RU
    public static Query createDefaultQuery(SalesPurchBookRecId_RU  _bookRecId,
                                           Query           _query      = null,
                                           TransDate       _fromDate   = dateNull(),
                                           TransDate       _toDate     = dateNull(),
                                           boolean         _initBookId = false)
    {
        Query                   query;
        QueryBuildRange         range;
        QueryBuildDataSource    queryBuildDataSource;

        if (_query)
        {
            query                = new Query(_query);
            queryBuildDataSource = query.dataSourceTable(tablenum(SalesBookTrans_RU));

            if (! _initBookId)
            {
                queryBuildDataSource.clearRanges();
                queryBuildDataSource.sortClear();

                queryBuildDataSource = query.dataSourceTable(tablenum(PurchBookTrans_RU));
                queryBuildDataSource.clearRanges();
                queryBuildDataSource.sortClear();
            }
            else
            {
                range = queryBuildDataSource.findRange(fieldnum(SalesBookTrans_RU, SalesBookTable_RU));
                while (range)
                {
                    queryBuildDataSource.clearRange(fieldnum(SalesBookTrans_RU, SalesBookTable_RU));
                    range = queryBuildDataSource.findRange(fieldnum(SalesBookTrans_RU, SalesBookTable_RU));
                }
                range = queryBuildDataSource.findRange(fieldnum(SalesBookTrans_RU, CorrectedSalesBookTable_RU));
                while (range)
                {
                    queryBuildDataSource.clearRange(fieldnum(SalesBookTrans_RU, CorrectedSalesBookTable_RU));
                    range = queryBuildDataSource.findRange(fieldnum(SalesBookTrans_RU, CorrectedSalesBookTable_RU));
                }

                queryBuildDataSource = query.dataSourceTable(tablenum(PurchBookTrans_RU));
                if (queryBuildDataSource)
                {
                    range = queryBuildDataSource.findRange(fieldnum(PurchBookTrans_RU, PurchBookTable_RU));
                    while (range)
                    {
                        queryBuildDataSource.clearRange(fieldnum(PurchBookTrans_RU, PurchBookTable_RU));
                        range = queryBuildDataSource.findRange(fieldnum(PurchBookTrans_RU, PurchBookTable_RU));
                    }
                }
            }

            queryBuildDataSource = query.dataSourceTable(tablenum(SalesBookTrans_RU));
        }
        else
        {
            query = new Query();
            queryBuildDataSource = query.addDataSource(tablenum(SalesBookTrans_RU));
        }

        if ((_toDate ? _toDate : SalesBookTable_RU::find(_bookRecId).getToDate()) < #BookCorrectionDate)
        {
            SalesBookTable_RU::initDefaultQuery_OldBooks(_bookRecId, queryBuildDataSource, _fromDate, _toDate);
        }
        else
        {
            SalesBookTable_RU::initDefaultQuery(_bookRecId, queryBuildDataSource, _fromDate, _toDate, false);

            queryBuildDataSource = query.dataSourceTable(tablenum(PurchBookTrans_RU));

            if (!queryBuildDataSource)
            {
                queryBuildDataSource = query.addDataSource(tablenum(PurchBookTrans_RU));
            }

            SalesBookTable_RU::initDefaultQuery(_bookRecId, queryBuildDataSource, _fromDate, _toDate, false);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates query for sales book
    /// </summary>
    /// <param name="_bookRecId">
    /// RecId of purchase book
    /// </param>
    /// <param name="_query">
    /// Query to be updated; Optional
    /// </param>
    /// <param name="_fromDate">
    /// From date for query
    /// </param>
    /// <param name="_toDate">
    /// To date for query
    /// </param>
    /// <param name="_initBookId">
    /// Determines if ranges on <c>SalesBookTrans_RU</c> should be cleared
    /// </param>
    /// <returns>
    /// Query for later use
    /// </returns>
    #VATTransitionPeriod_RU
    public static Query createQuery(SalesPurchBookRecId_RU  _bookRecId,
                                    Query                   _query      = null,
                                    TransDate               _fromDate   = dateNull(),
                                    TransDate               _toDate     = dateNull(),
                                    boolean                 _initBookId = false)
    {
        Query                   query;

        query = SalesBookTable_RU::createDefaultQuery(_bookRecId, _query, _fromDate, _toDate, _initBookId);

        if ((_toDate ? _toDate : SalesBookTable_RU::find(_bookRecId).getToDate()) >= #BookCorrectionDate)
        {
            SalesBookTable_RU::setExtQueryRanges(query);
        }
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existActiveBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if not closed book exists
    /// </summary>
    /// <returns>
    /// True if not closed book exists; otherwise false
    /// </returns>
    public static boolean existActiveBook()
    {
        return SalesBookTable_RU::findByClosingDate(dateNull()).RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extQueryStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates extended range for query.
    /// </summary>
    /// <param name="_dataSourceName">
    /// Data source name.
    /// </param>
    /// <param name="_fieldName">
    /// Field name.
    /// </param>
    /// <param name="_operator">
    /// SQL operator used in statement.
    /// </param>
    /// <param name="_value">
    /// Value to compare.
    /// </param>
    /// <returns>
    /// The string with extended range.
    /// </returns>
    public static str extQueryStatement(str _dataSourceName, str _fieldName, str _operator, str _value)
    {
        return strfmt('(%1.%2 %3 %4)', _dataSourceName, _fieldName, _operator, _value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>SalesBookTable_RU</c> table.
    /// </summary>
    /// <param name="_recId">
    /// The RecId of the SalesBookTable_RU record to find.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when reading the record; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>SalesBookTable_RU</c> table; otherwise, an empty record.
    /// </returns>
    public static SalesBookTable_RU find(
        recId              _recId,
        boolean            _forupdate = false,
        ConcurrencyModel   _concurrencyModel = ConcurrencyModel::Auto)
    {
        SalesBookTable_RU salesBookTable;

        salesBookTable.selectForUpdate(_forupdate);
        if (_forupdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            salesBookTable.concurrencyModel(_concurrencyModel);
        }

        select firstonly salesBookTable
            where salesBookTable.RecId == _recId;

        return salesBookTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByBookId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds record by specified BookId
    /// </summary>
    /// <param name="_bookId">
    /// BookId to look for
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether record should be selected for update
    /// </param>
    /// <returns>
    /// Found sales book table
    /// </returns>
    public static SalesBookTable_RU findByBookId(SalesBookId_RU _bookId, boolean _forupdate = false)
    {
        SalesBookTable_RU   salesBookTable;

        if (_bookId)
        {
            salesBookTable.selectForUpdate(_forupdate);

            select firstonly firstfast salesBookTable
                where salesBookTable.BookId == _bookId;
        }

        return salesBookTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByClosingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds latest sales book record with date greater that specified
    /// </summary>
    /// <param name="_closingDate">
    /// Date parameter
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether record should be selected for update
    /// </param>
    /// <returns>
    /// Found sales book table
    /// </returns>
    public static SalesBookTable_RU findByClosingDate(SalesBookClosingDate_RU _closingDate,
                                                             boolean                 _forupdate = false)
    {
        SalesBookTable_RU   salesBookTable;

        salesBookTable.selectForUpdate(_forupdate);

        if (_closingDate)
        {
            select reverse firstonly salesBookTable
                index hint ClosingDateIdx
                where salesBookTable.ClosingDate >= _closingDate;
        }
        else
        {
            select firstonly salesBookTable
                index hint ClosingDateIdx
                where ! salesBookTable.ClosingDate;
        }

        return salesBookTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstByClosingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds purchase book record with date greater that specified
    /// </summary>
    /// <param name="_closingDate">
    /// Date parameter
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether record should be selected for update
    /// </param>
    /// <returns>
    /// Found purchase book table
    /// </returns>
    public static SalesBookTable_RU findFirstByClosingDate(SalesBookClosingDate_RU _closingDate,
                                                                  boolean                 _forupdate = false)
    {
        SalesBookTable_RU   salesBookTable;

        salesBookTable.selectForUpdate(_forupdate);

        select firstonly salesBookTable
            order by ClosingDate
            where salesBookTable.ClosingDate >= _closingDate;

        return salesBookTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureRevisionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns revision type for facture.
    /// </summary>
    /// <param name="_factureExternalId">
    /// External id of facture.
    /// </param>
    /// <param name="_factureDate">
    /// Date of facture.
    /// </param>
    /// <param name="_factureId">
    /// Id (internal) of facture.
    /// </param>
    /// <returns>
    /// Facture revision type.
    /// </returns>
    public static FactureRevisionType_RU getFactureRevisionType(FactureExternalId_RU        _factureExternalId,
                                                                FactureDate_RU              _factureDate,
                                                                FactureId_RU                _factureId)
    {
        SalesBookTrans_RU               salesBookTrans;
        FactureRevisionType_RU          revisionType;

        select firstonly TransType from salesBookTrans
        where salesBookTrans.FactureExternalId  == _factureExternalId
            && salesBookTrans.FactureDate       == _factureDate
            && (salesBookTrans.CorrectionType   == FactureCorrectionType_RU::Correction
                || (   salesBookTrans.CorrectionType    == FactureCorrectionType_RU::Unknown
                    && salesBookTrans.CorrectedFactureExternalId))
            && salesBookTrans.FactureId         == _factureId;

        if (salesBookTrans.TransType == SalesPurchBookTransType_RU::CreditNote)
        {
            revisionType = FactureRevisionType_RU::RevisionCorrPurch;
        }
        else
        {
            revisionType = FactureRevisionType_RU::RevisionCorrSales;
        }

        return revisionType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastClosedBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns last closed book
    /// </summary>
    /// <returns>
    /// Last closed book
    /// </returns>
    public static SalesBookTable_RU getLastClosedBook()
    {
        SalesBookTable_RU   salesBookTable;

        select reverse firstonly salesBookTable
            index hint ClosingDateIdx
            where salesBookTable.ClosingDate;

        return salesBookTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpSalesBookTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and fills temporary table with <c>SalesBookTrans_RU</c> records
    /// </summary>
    /// <param name="_queryRun">
    /// QeuryRun used for data selection
    /// </param>
    /// <param name="_groupCorrect">
    /// Determines whether correcting factures should be grouped
    /// </param>
    /// <returns>
    /// Temporary table with <c>SalesBookTrans_RU</c> records
    /// </returns>
    static public SalesBookTrans_RU getTmpSalesBookTrans(QueryRun _queryRun, NoYes _groupCorrect)
    {
        SalesBookTrans_RU salesBookTrans, tmpSalesBookTrans;
        SalesBookTrans_RU salesBookTransCorr, salesBookTransTmp;
        PurchBookTrans_RU purchBookTrans;
        SalesBookTrans_RU salesBookCreditNote;
        FactureJour_RU    factureJour;

        _queryRun.reset();

        tmpSalesBookTrans.setTmp();

        while (_queryRun.next())
        {
            if (_queryRun.changed(tableNum(SalesBookTrans_RU)))
            {
                salesBookTrans = _queryRun.get(tableNum(SalesBookTrans_RU));

                if (salesBookTrans.TransType == SalesPurchBookTransType_RU::SumDiff)
                {
                    select firstonly salesBookCreditNote
                        where salesBookCreditNote.FactureId == salesBookTrans.FactureId &&
                              salesBookCreditNote.TransType == SalesPurchBookTransType_RU::CreditNote;

                    if (salesBookCreditNote && ! salesBookCreditNote.CorrectedFactureExternalId)
                    {
                        continue;
                    }
                }

                tmpSalesBookTrans.data(salesBookTrans);
                tmpSalesBookTrans.doInsert();
            }
            if (_queryRun.changed(tableNum(PurchBookTrans_RU)))
            {
                purchBookTrans = _queryRun.get(tableNum(PurchBookTrans_RU));

                select firstonly forupdate tmpSalesBookTrans
                    where tmpSalesBookTrans.FactureId       == purchBookTrans.FactureId      &&
                          tmpSalesBookTrans.SettlementDate  == purchBookTrans.SettlementDate &&
                          tmpSalesBookTrans.TransType       == purchBookTrans.TransType      &&
                          tmpSalesBookTrans.Annulment       == NoYes::No                     &&
                          purchBookTrans.Annulment          == NoYes::No;

                tmpSalesBookTrans.AmountLiableToVAT10           += - purchBookTrans.AmountLiableToVAT10;
                tmpSalesBookTrans.TaxAmountVAT10                += - purchBookTrans.TaxAmountVAT10;
                tmpSalesBookTrans.AmountNotLiableToVAT          += - purchBookTrans.AmountNotLiableToVAT;
                tmpSalesBookTrans.FactureExternalId             =    purchBookTrans.FactureExternalId;
                tmpSalesBookTrans.AccountName                   =    purchBookTrans.AccountName;
                tmpSalesBookTrans.PaymentDate                   =    purchBookTrans.PaymentDate;
                tmpSalesBookTrans.AmountInclVAT                 += - purchBookTrans.AmountInclVAT;
                tmpSalesBookTrans.AmountLiableToVAT20           += - purchBookTrans.AmountLiableToVAT20;
                tmpSalesBookTrans.TaxAmountVAT20                += - purchBookTrans.TaxAmountVAT20;
                tmpSalesBookTrans.AmountLiableToVAT0            += - purchBookTrans.AmountLiableToVAT0;
                tmpSalesBookTrans.AccountNum                    =    purchBookTrans.AccountNum;
                tmpSalesBookTrans.FactureId                     =    purchBookTrans.FactureId;
                tmpSalesBookTrans.FactureJour_RU                =    purchBookTrans.FactureJour_RU;
                tmpSalesBookTrans.FactureDate                   =    purchBookTrans.FactureDate;
                tmpSalesBookTrans.SettlementDate                =    purchBookTrans.SettlementDate;
                tmpSalesBookTrans.FactureDate_External          =    purchBookTrans.FactureDate_External;
                tmpSalesBookTrans.TransType                     =    purchBookTrans.TransType;
                tmpSalesBookTrans.ReverseDate                   =    purchBookTrans.DeliveryDate;
                tmpSalesBookTrans.CorrectedFactureExternalId    =    purchBookTrans.CorrectedFactureExternalId;
                tmpSalesBookTrans.RefOriginalFacture            =    purchBookTrans.RefOriginalFacture;
                tmpSalesBookTrans.RevisionSeqNumber             =    purchBookTrans.RevisionSeqNumber;
                tmpSalesBookTrans.CorrectionType                =    purchBookTrans.CorrectionType;
                tmpSalesBookTrans.RevisionType                  =    purchBookTrans.RevisionType;
                tmpSalesBookTrans.Annulment                     =    purchBookTrans.Annulment;
                tmpSalesBookTrans.CorrectedFactureDate          =    purchBookTrans.CorrectedFactureDate;
                tmpSalesBookTrans.RefRevisedFacture             =    purchBookTrans.RefRevisedFacture;
                tmpSalesBookTrans.AmountCurInclVAT              =  - purchBookTrans.AmountCurInclVAT;
                tmpSalesBookTrans.CommissionAgent               =    purchBookTrans.CommissionAgent;
                tmpSalesBookTrans.CurrencyCode                  =    purchBookTrans.CurrencyCode;
                tmpSalesBookTrans.OperationTypeCodes            =    purchBookTrans.OperationTypeCodes;
                tmpSalesBookTrans.PaymDocumentNum               =    purchBookTrans.PaymDocumentNum;

                if (purchBookTrans.FactureJour_RU)
                {
                    tmpSalesBookTrans.FactureJour_RU              = purchBookTrans.FactureJour_RU;
                }
                else
                {
                    tmpSalesBookTrans.FactureJour_RU              = FactureJour_RU::find(purchBookTrans.FactureId, purchBookTrans.factureModule()).RecId;
                }

                if (! tmpSalesBookTrans.RecId)
                {
                    tmpSalesBookTrans.doInsert();
                }
                else
                {
                    tmpSalesBookTrans.doUpdate();
                }
            }
        }

        if (_groupCorrect)
        {
            salesBookTransCorr.setTmp();
            salesBookTransCorr.setTmpData(tmpSalesBookTrans);

            salesBookTransTmp.setTmp();
            salesBookTransTmp.setTmpData(tmpSalesBookTrans);

            while select forupdate tmpSalesBookTrans
                where tmpSalesBookTrans.TransType == SalesPurchBookTransType_RU::Invoice &&
                    ! tmpSalesBookTrans.CorrectedFactureExternalId
            {
                factureJour = FactureJour_RU::find(tmpSalesBookTrans.FactureId, tmpSalesBookTrans.factureModule());

                select sum(AmountLiableToVAT10),
                       sum(TaxAmountVAT10),
                       sum(AmountNotLiableToVAT),
                       sum(AmountInclVAT),
                       sum(AmountLiableToVAT20),
                       sum(TaxAmountVAT20),
                       sum(AmountLiableToVAT0),
                       sum(AmountCurInclVAT)
                    from salesBookTransCorr
                 where salesBookTransCorr.RefOriginalFacture == factureJour.RecId                             &&
                    (salesBookTransCorr.CorrectedSalesBookTable_RU    == tmpSalesBookTrans.SalesBookTable_RU ||
                    !salesBookTransCorr.CorrectedSalesBookTable_RU);

                tmpSalesBookTrans.AmountLiableToVAT10   += salesBookTransCorr.AmountLiableToVAT10;
                tmpSalesBookTrans.TaxAmountVAT10        += salesBookTransCorr.TaxAmountVAT10;
                tmpSalesBookTrans.AmountNotLiableToVAT  += salesBookTransCorr.AmountNotLiableToVAT;
                tmpSalesBookTrans.AmountInclVAT         += salesBookTransCorr.AmountInclVAT;
                tmpSalesBookTrans.AmountLiableToVAT20   += salesBookTransCorr.AmountLiableToVAT20;
                tmpSalesBookTrans.TaxAmountVAT20        += salesBookTransCorr.TaxAmountVAT20;
                tmpSalesBookTrans.AmountLiableToVAT0    += salesBookTransCorr.AmountLiableToVAT0;
                tmpSalesBookTrans.AmountCurInclVAT      += salesBookTransCorr.AmountCurInclVAT;

                delete_from salesBookTransCorr
                where salesBookTransCorr.RefOriginalFacture         == factureJour.RecId                   &&
                     (salesBookTransCorr.CorrectedSalesBookTable_RU == tmpSalesBookTrans.SalesBookTable_RU ||
                    ! salesBookTransCorr.CorrectedSalesBookTable_RU);

                if (tmpSalesBookTrans.AmountLiableToVAT10   ||
                    tmpSalesBookTrans.TaxAmountVAT10        ||
                    tmpSalesBookTrans.AmountNotLiableToVAT  ||
                    tmpSalesBookTrans.AmountInclVAT         ||
                    tmpSalesBookTrans.AmountLiableToVAT20   ||
                    tmpSalesBookTrans.TaxAmountVAT20        ||
                    tmpSalesBookTrans.AmountLiableToVAT0    ||
                    tmpSalesBookTrans.AmountCurInclVAT)
                {
                    tmpSalesBookTrans.doUpdate();
                }
                else
                {
                    tmpSalesBookTrans.doDelete();
                }
            }
        }

        return tmpSalesBookTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaultQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates default query for sales book processing
    /// </summary>
    /// <param name="_bookRecId">
    /// RecId of sales book
    /// </param>
    /// <param name="_queryBuildDataSource">
    /// <c>QueryBuildDataSource</c> object to be modified
    /// </param>
    /// <param name="_fromDate">
    /// Starting date for data selection
    /// </param>
    /// <param name="_toDate">
    /// Ending date for data selection
    /// </param>
    /// <param name="_setExtQueryRange">
    /// Determines whether extended range should be set on query; Optional
    /// </param>
    public static void initDefaultQuery(SalesPurchBookRecId_RU  _bookRecId,
                                        QueryBuildDataSource    _queryBuildDataSource,
                                        TransDate               _fromDate  = dateNull(),
                                        TransDate               _toDate    = dateNull(),
                                        boolean                 _setExtQueryRange = true)
    {
        QueryBuildRange         queryRange;
        SalesBookTable_RU       salesBookTable;
        PurchBookTable_RU       purchBookTable;
        SalesPurchBookRecId_RU  bookRecId;
        int                     idx;
        container               bookRecIdCon;
        str                     corrBookRange;
        #macrolib.SalesBook_RU

        bookRecIdCon = SalesBookTable_RU::booksInPeriod(_bookRecId, _fromDate, _toDate);

        switch (_queryBuildDataSource.table())
        {
            case tableNum(SalesBookTrans_RU) :
                queryRange = findOrCreateRange_W(_queryBuildDataSource, fieldnum(SalesBookTrans_RU, TransType));
                queryRange.status(RangeStatus::Hidden);

                corrBookRange = SalesBookTable_RU::extQueryStatement(_queryBuildDataSource.name(), fieldstr(SalesBookTrans_RU, CorrectedSalesBookTable_RU), '==', queryValue(0));

                for (idx = 1; idx <= conLen(bookRecIdCon); idx++)
                {
                    bookRecId = conPeek(bookRecIdCon, idx);
                    queryRange = _queryBuildDataSource.addRange(fieldNum(SalesBookTrans_RU, SalesBookTable_RU));
                    queryRange.value(queryValue(bookRecId));
                    queryRange.status(RangeStatus::Locked);

                    corrBookRange += ' || '
                                  +  SalesBookTable_RU::extQueryStatement(_queryBuildDataSource.name(), fieldstr(SalesBookTrans_RU, CorrectedSalesBookTable_RU), '==', queryValue(bookRecId));
                }

                corrBookRange += ' || '
                              +  '('
                              +  SalesBookTable_RU::extQueryStatement(_queryBuildDataSource.name(), fieldstr(SalesBookTrans_RU, FactureDate_External), '>=', date2StrXpp(#correctionAddListDate))
                              +  ' && '
                              +  SalesBookTable_RU::extQueryStatement(_queryBuildDataSource.name(), fieldstr(SalesBookTrans_RU, CorrectionType), '==', int2str(FactureCorrectionType_RU::Correction))
                              + ')';
                queryRange = findOrCreateRange_W(_queryBuildDataSource, fieldnum(SalesBookTrans_RU, CorrectedSalesBookTable_RU));
                queryRange.value('(' + corrBookRange + ')');                
                queryRange.status(RangeStatus::Hidden);

                break;

            case tableNum(PurchBookTrans_RU) :
                queryRange = findOrCreateRange_W(_queryBuildDataSource, fieldnum(PurchBookTrans_RU, CorrectedPurchBookTable_RU), queryValue(0));
                queryRange.status(RangeStatus::Hidden);

                for (idx = 1; idx <= conLen(bookRecIdCon); idx++)
                {
                    salesBookTable = SalesBookTable_RU::find(conPeek(bookRecIdCon, idx));
                    purchBookTable = salesBookTable.findPurchBook();

                    queryRange = _queryBuildDataSource.addRange(fieldNum(PurchBookTrans_RU, PurchBookTable_RU));
                    queryRange.value(queryValue(purchBookTable.RecId));
                    queryRange.status(RangeStatus::Locked);

                    queryRange = _queryBuildDataSource.addRange(fieldnum(PurchBookTrans_RU, CorrectedPurchBookTable_RU));
                    queryRange.value(queryValue(purchBookTable.RecId));
                    queryRange.status(RangeStatus::Hidden);
                }

                queryRange = findOrCreateRange_W(_queryBuildDataSource, fieldnum(PurchBookTrans_RU, TransType));
                queryRange.status(RangeStatus::Hidden);

                queryRange = findOrCreateRange_W(_queryBuildDataSource, fieldNum(PurchBookTrans_RU, ReverseTrans), queryValue(NoYes::No));
                queryRange.status(RangeStatus::Locked);
                break;
        }

        if (_setExtQueryRange)
        {
            SalesBookTable_RU::setExtQueryRange(_queryBuildDataSource);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaultQuery_OldBooks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>QueryBuildDataSource</c> object with ranges by book rec ids from given period
    /// </summary>
    /// <param name="_bookRecId">
    /// Initial book recId
    /// </param>
    /// <param name="_queryBuildDataSource">
    /// <c>QueryBuildDataSource</c> object to be changed
    /// </param>
    /// <param name="_fromDate">
    /// Starting date of period
    /// </param>
    /// <param name="_toDate">
    /// Ending date of period
    /// </param>
    public static void initDefaultQuery_OldBooks(SalesPurchBookRecId_RU _bookRecId,
                                                 QueryBuildDataSource   _queryBuildDataSource,
                                                 TransDate              _fromDate  = dateNull(),
                                                 TransDate              _toDate    = dateNull())
    {
        int             idx;
        container       bookRecIdCon;
        QueryBuildRange queryRange;

        SalesBookTable_RU::addSortFields(_bookRecId, _queryBuildDataSource);

        bookRecIdCon = SalesBookTable_RU::booksInPeriod(_bookRecId, _fromDate, _toDate);

        for (idx = 1; idx <= conLen(bookRecIdCon); idx++)
        {
            queryRange = _queryBuildDataSource.addRange(fieldNum(SalesBookTrans_RU, SalesBookTable_RU));
            queryRange.value(queryValue(conPeek(bookRecIdCon, idx)));
            queryRange.status(RangeStatus::Locked);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQueryRunOnTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>QueryRun</c> object on temporary tables
    /// </summary>
    /// <param name="_queryRun">
    /// <c>QueryRun</c> object which is source for data selection
    /// </param>
    /// <param name="_bookRecId">
    /// Record id of sales book data selected from
    /// </param>
    /// <param name="_groupCorrect">
    /// Determines whether corrections should be grouped in <c>QueryRun</c> object
    /// </param>
    /// <returns>
    /// Resulting <c>QueryRun</c> object
    /// </returns>
    public static QueryRun initQueryRunOnTmp(QueryRun _queryRun, SalesPurchBookRecId_RU _bookRecId, NoYes _groupCorrect)
    {
        Query                query = new Query();
        QueryRun             queryRun;
        QueryBuildDataSource queryBuildDataSource;
        SalesBookTrans_RU    salesBookTrans = SalesBookTable_RU::getTmpSalesBookTrans(_queryRun, _groupCorrect);

        queryBuildDataSource = query.addDataSource(tableNum(SalesBookTrans_RU));

        SalesBookTable_RU::addSortFields(_bookRecId, queryBuildDataSource);

        queryRun = new QueryRun(query);
        queryRun.setCursor(salesBookTrans);

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if <c>SalesBookTrans_RU</c> record is Credit-Note
    /// </summary>
    /// <param name="_salesBookTrans">
    /// <c>PurchBookTrans_RU</c> record to be checked
    /// </param>
    /// <param name="_isOldBook">
    /// Determines if book is in VAT Transition period
    /// </param>
    /// <returns>
    /// True if book transaction is credit note; Otherwise false
    /// </returns>
    public static boolean isCreditNote(SalesBookTrans_RU _salesBookTrans, boolean _isOldBook)
    {
        return _salesBookTrans.TransType == SalesPurchBookTransType_RU::CreditNote &&
               ! _salesBookTrans.CorrectedFactureExternalId                        &&
               ! _isOldBook;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesBookTrans2PurchBookTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts <c>SalesBookTrans_RU</c> record to <c>SalesBookTrans_RU</c> record
    /// </summary>
    /// <param name="_salesBookTrans">
    /// <c>PurchBookTrans_RU</c> record to be converted
    /// </param>
    /// <param name="_isOldBook">
    /// Determines if book is in VAT transition period
    /// </param>
    /// <returns>
    /// Buffer of <c>PurchBookTrans_RU</c> record
    /// </returns>
    public static PurchBookTrans_RU salesBookTrans2PurchBookTrans(SalesBookTrans_RU _salesBookTrans, boolean _isOldBook)
    {
        PurchBookTrans_RU purchBookTrans;

        if (SalesBookTable_RU::isCreditNote(_salesBookTrans, _isOldBook))
        {
            purchBookTrans.DeliveryDate        = _salesBookTrans.ReverseDate ? _salesBookTrans.ReverseDate : _salesBookTrans.FactureDate_External;
            purchBookTrans.TransType           = _salesBookTrans.TransType;
            purchBookTrans.FactureId           = _salesBookTrans.FactureId;
            purchBookTrans.FactureJour_RU      = _salesBookTrans.FactureJour_RU;
            purchBookTrans.AmountLiableToVAT20 = _salesBookTrans.AmountLiableToVAT20;
            purchBookTrans.TaxAmountVAT20      = _salesBookTrans.TaxAmountVAT20;
            purchBookTrans.FactureJour_RU      = _salesBookTrans.FactureJour_RU;
        }

        return purchBookTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExtQueryRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets extended query range on given datasource.
    /// </summary>
    /// <param name="_queryBuildDataSource">
    /// <c>QueryBuildDatasource</c> recod to be updated.
    /// </param>
    public static void setExtQueryRange(QueryBuildDataSource    _queryBuildDataSource)
    {
        QueryBuildRange    queryRange;

        str salesTransTypeValue = 
            '('                 +
            '('                 +
                '(\%1.'         + fieldstr(SalesBookTrans_RU, TransType)                +
                    '!='        + int2str(SalesPurchBookTransType_RU::CreditNote)       +
                ')'             +
                ' || (\%1.'     + fieldstr(SalesBookTrans_RU, RevisionType)             +
                    '=='        + int2str(FactureRevisionType_RU::RevisionOriginal)     +
                ')'             +
                ' || (\%1.'     + fieldstr(SalesBookTrans_RU, RevisionType)             +
                    '=='        + int2str(FactureRevisionType_RU::RevisionCorrSales)    +
                ')'             +
            ')'                 +
            ' && (\%1.'         + fieldstr(SalesBookTrans_RU, RevisionType)             +
                '!='            + int2str(FactureRevisionType_RU::RevisionCorrPurch)    +
            ') '                +
            ' && ('             +
                '(\%1.'         + fieldstr(SalesBookTrans_RU, AmountInclVAT)            +
                    '>=0'       +
                ')'             +
                ' || (\%1.'     + fieldstr(SalesBookTrans_RU, TransType)                +
                    '!='        + int2str(SalesPurchBookTransType_RU::Prepayment)       +
                ')'             +
            ')'                 +
            ')';

        str purchTransTypeValue = 
            '('                 +
            '('                 +
                '('                 +
                    '(\%1.'         + fieldstr(PurchBookTrans_RU, TransType)                +
                        '=='        + int2str(SalesPurchBookTransType_RU::CreditNote)       +
                    ')'             +
                    ' && (\%1.'     + fieldstr(PurchBookTrans_RU, RevisionType)             +
                        '!='        + int2str(FactureRevisionType_RU::RevisionOriginal)     +
                    ')'             +
                ')'                 +
                ' || (\%1.'         + fieldstr(PurchBookTrans_RU, RevisionType)             +
                    '=='            + int2str(FactureRevisionType_RU::RevisionCorrSales)    +
                ')'                 +
            ')'                 +
            ' && (\%1.'         + fieldstr(PurchBookTrans_RU, RevisionType)             +
                '!='            + int2str(FactureRevisionType_RU::RevisionCorrPurch)    +
            ') '                +
            ')';

        switch (_queryBuildDataSource.table())
        {
            case tablenum(SalesBookTrans_RU) :
                queryRange = findOrCreateRange_W(_queryBuildDataSource, fieldnum(SalesBookTrans_RU, TransType));
                queryRange.value(strfmt(salesTransTypeValue, _queryBuildDataSource.name()));
                queryRange.status(RangeStatus::Hidden);
                break;

            case tablenum(PurchBookTrans_RU) :
                queryRange = findOrCreateRange_W(_queryBuildDataSource, fieldnum(PurchBookTrans_RU, TransType));
                queryRange.value(strfmt(purchTransTypeValue,_queryBuildDataSource.name()));
                queryRange.status(RangeStatus::Hidden);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExtQueryRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets extended query ranges for all datasources in the query.
    /// </summary>
    /// <param name="_query">
    /// <c>Query</c> to be updated.
    /// </param>
    public static void setExtQueryRanges(Query _query)
    {
        QueryBuildDataSource queryBuildDataSource;

        queryBuildDataSource = _query.dataSourceTable(tablenum(SalesBookTrans_RU));
        SalesBookTable_RU::setExtQueryRange(queryBuildDataSource);

        queryBuildDataSource = _query.dataSourceTable(tablenum(PurchBookTrans_RU));

        if (queryBuildDataSource)
        {
            SalesBookTable_RU::setExtQueryRange(queryBuildDataSource);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes given <c>QueryRun</c> object to use grouping and aggregation by several fields
    /// </summary>
    /// <param name="_queryRun">
    /// <c>QueryRun</c> object to be modified
    /// </param>
    /// <param name="_groupByFactures">
    /// Determines whether grouping should be applied
    /// </param>
    public static void updateQuery(QueryRun _queryRun, NoYes _groupByFactures)
    {
        QueryBuildDataSource    queryDataSource;

        if (! _groupByFactures)
        {
            return;
        }

        queryDataSource = _queryRun.query().dataSourceTable(tableNum(SalesBookTrans_RU));
        queryDataSource.sortClear();

        queryDataSource.orderMode(OrderMode::GroupBy);
        queryDataSource.addSortField(fieldNum(SalesBookTrans_RU, PaymentDate));
        queryDataSource.addSortField(fieldNum(SalesBookTrans_RU, FactureDate_External));
        queryDataSource.addSortField(fieldNum(SalesBookTrans_RU, FactureExternalId));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, RevisionSeqNumber));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, Annulment));
        queryDataSource.addSortField(fieldNum(SalesBookTrans_RU, FactureId));
        queryDataSource.addSortField(fieldNum(SalesBookTrans_RU, TransType));
        queryDataSource.addSortField(fieldNum(SalesBookTrans_RU, AccountNum));
        queryDataSource.addSortField(fieldNum(SalesBookTrans_RU, AccountName));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, CorrectedFactureExternalId));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, RefOriginalFacture));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, CorrectionType));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, RevisionType));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, CorrectedFactureDate));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, FactureJour_RU));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, CurrencyCode));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, CommissionAgent));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, OperationTypeCodes));
        queryDataSource.addSortField(fieldnum(SalesBookTrans_RU, PaymDocumentNum));
        
        queryDataSource.addSelectionField(fieldNum(SalesBookTrans_RU, AmountInclVAT), SelectionField::Sum);
        queryDataSource.addSelectionField(fieldNum(SalesBookTrans_RU, AmountCurInclVAT), SelectionField::Sum);
        queryDataSource.addSelectionField(fieldNum(SalesBookTrans_RU, AmountLiableToVAT20), SelectionField::Sum);
        queryDataSource.addSelectionField(fieldNum(SalesBookTrans_RU, AmountLiableToVAT10), SelectionField::Sum);
        queryDataSource.addSelectionField(fieldNum(SalesBookTrans_RU, AmountLiableToVAT0), SelectionField::Sum);
        queryDataSource.addSelectionField(fieldNum(SalesBookTrans_RU, AmountNotLiableToVAT), SelectionField::Sum);
        queryDataSource.addSelectionField(fieldNum(SalesBookTrans_RU, TaxAmountVAT20), SelectionField::Sum);
        queryDataSource.addSelectionField(fieldNum(SalesBookTrans_RU, TaxAmountVAT10), SelectionField::Sum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return super() || SalesEnforceConcurrentDeletesFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasicSalesTax</ConfigurationKey>
	<CountryRegionCodes>RU</CountryRegionCodes>
	<DeveloperDocumentation>@GLS64332</DeveloperDocumentation>
	<Label>@GLS101251</Label>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>BookId</TitleField1>
	<TitleField2>Name</TitleField2>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>BookIdIdx</ClusteredIndex>
	<Modules>RSalesPurchBooks</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<ReplacementKey>BookIdIdx</ReplacementKey>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>SalesBookTrans_RU</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>SalesBookTrans_RU</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BookId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ClosingDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BookId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LastUpdateDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ClosingDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BookId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AccountingPeriod</Name>
			<Label>@SYS4646</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LastUpdateDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ClosingDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Policy</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>History</Name>
			<Label>@SYS10575</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Log</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BookId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BookId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SalesBookId_RU</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ClosingDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SalesBookClosingDate_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>LastUpdateDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS16686</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Log</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Log</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SalesBookName_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Policy</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CustTaxation_RU</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>BookIdIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>BookId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ClosingDateIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ClosingDate</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SalesPurchBookTable_RU</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>LastUpdateDate</MapField>
					<MapFieldTo>LastUpdateDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ClosingDate</MapField>
					<MapFieldTo>ClosingDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>BookId</MapField>
					<MapFieldTo>BookId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Name</MapField>
					<MapFieldTo>Name</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Policy</MapField>
					<MapFieldTo>Policy</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Log</MapField>
					<MapFieldTo>Log</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations />
	<StateMachines />
</AxTable>