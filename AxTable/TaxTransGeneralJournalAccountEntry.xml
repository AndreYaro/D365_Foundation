<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxTransGeneralJournalAccountEntry</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class TaxTransGeneralJournalAccountEntry extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record ID for the <c>LedgerDimensionAccount</c> record that is associated with this record.
    /// </summary>
    /// <param name="_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> record; optional.
    /// </param>
    /// <returns>
    /// A record ID of the <c>LedgerDimensionAccount</c> record that is associated with this record.
    /// </returns>
    public LedgerDimensionAccount getLedgerDimension(GeneralJournalAccountEntry _generalJournalAccountEntry = null)
    {
        LedgerDimensionAccount ledgerDimension;

        if (this.GeneralJournalAccountEntry)
        {
            if (!_generalJournalAccountEntry)
            {
                ledgerDimension = GeneralJournalAccountEntry::find(this.GeneralJournalAccountEntry).LedgerDimension;
            }
            else
            {
                ledgerDimension = _generalJournalAccountEntry.LedgerDimension;
            }
        }
        else
        {
            ledgerDimension = this.LedgerDimension;
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record ID for the <c>MainAccount</c> record.
    /// </summary>
    /// <returns>
    /// The record ID of the <c>MainAccount</c> record that is associated with this record.
    /// </returns>
    public RefRecId getMainAccount()
    {
        LedgerDimensionAccount ledgerDimension;
        if (this.GeneralJournalAccountEntry)
        {
            ledgerDimension = GeneralJournalAccountEntry::find(this.GeneralJournalAccountEntry).LedgerDimension;
        }
        else
        {
            ledgerDimension = this.LedgerDimension;
        }

        return LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(ledgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initToTaxTransSubledgerJournalAccEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>TaxTransSubledgerJournalAccountEntry</c> record based on the current <c>TaxTransGeneralJournalAccountEntry</c> record.
    /// </summary>
    /// <param name="_subledgerJournalAccountEntryRecId">
    /// The record ID of the <c>TaxTransSubledgerJournalAccountEntry</c> table.
    /// </param>
    /// <param name="_taxTransSubledgerJournalAccountEntry">
    /// The <c>TaxTransSubledgerJournalAccountEntry</c> record to initialize.
    /// </param>
    public void initToTaxTransSubledgerJournalAccEntry(
        SubledgerJournalAccountEntryRecId _subledgerJournalAccountEntryRecId,
        TaxTransSubledgerJournalAccountEntry _taxTransSubledgerJournalAccountEntry)
    {
        _taxTransSubledgerJournalAccountEntry.LedgerDimension = this.LedgerDimension;
        _taxTransSubledgerJournalAccountEntry.TaxTrans = this.TaxTrans;
        _taxTransSubledgerJournalAccountEntry.TaxTransRelationship = this.TaxTransRelationship;
        _taxTransSubledgerJournalAccountEntry.SubledgerJournalAccountEntry = _subledgerJournalAccountEntryRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record exists in the TaxTransGeneralJournalAccountEntry table; if not, an error message is displayed.
    /// </summary>
    /// <param name="taxTransGeneralJournalAccountEntryRecId">
    /// The record ID of the TaxTransGeneralJournalAccountEntry record.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean checkExist(TaxTransGeneralJournalAccountEntryRecId taxTransGeneralJournalAccountEntryRecId)
    {
        boolean isExisting = true;
        ;

        if (!TaxTransGeneralJournalAccountEntry::exist(taxTransGeneralJournalAccountEntryRecId))
        {
            isExisting = checkFailed(strFmt(TaxTransGeneralJournalAccountEntry::txtNotExist(), taxTransGeneralJournalAccountEntryRecId));
        }

        return isExisting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>TaxTransGeneralJournalAccountEntry</c> records for the specified subledger journal transfer ID.
    /// </summary>
    /// <param name="_transferId">
    /// The identifier for a group of subledger journal entries that are transferred to the ledger together.
    /// </param>
    /// <param name="_ledgerRecId">
    /// The identifier for the <c>Ledger</c> record with which the subledger journal entries being transferred are associated.
    /// </param>
    public static void create(RefRecId _transferId, LedgerRecId _ledgerRecId)
    {
        TaxTransGeneralJournalAccountEntryCreate taxLinkCreate = TaxTransGeneralJournalAccountEntryCreate::construct();
        taxLinkCreate.create(_transferId, _ledgerRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromTaxTransSubledgerJourAccEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>TaxTransGeneralJournalAccountEntry</c> records from the specified <c>TaxTransSubledgerJournalAccountEntry</c> records.
    /// </summary>
    /// <param name="_transferId">
    /// The identifier for a group of subledger journal entries that are transferred to the ledger together.
    /// </param>
    /// <param name="_ledgerRecId">
    /// The identifier for the <c>Ledger</c> the subledger journal entries being transferred are associated with.
    /// </param>
    /// <remarks>
    /// Use this method to transfer records with <c>TaxTransGeneralJournalAccountEntry</c> and no source document lines.
    /// </remarks>
    public static void createFromTaxTransSubledgerJourAccEntry(
        SubledgerJournalTransferId  _transferId,
        LedgerRecId _ledgerRecId)
    {
        TaxTransGeneralJournalAccountEntryCreate taxLink = TaxTransGeneralJournalAccountEntryCreate::construct();
        taxLink.createFromTaxTransSubledgerJourAccEntry(_transferId, _ledgerRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrphanLink_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates records for TaxTrans without linked GeneralJournalAccountEntry to save information about LedgerDimension
    /// </summary>
    /// <param name="_taxTrans">
    ///  The TaxTrans cursor.
    /// </param>
    /// <param name="_ledgerDimension">
    ///  Record Id of the <c>LedgerDimensionAccount</c> associated with this record.
    /// </param>
    /// <param name="_taxTransRelationship">
    ///  The type of record.
    /// </param>
    public static void createOrphanLink_RU(TaxTrans _taxTrans, LedgerDimensionAccount _ledgerDimension, TaxTransRelationshipType _taxTransRelationship)
    {
        TaxTransGeneralJournalAccountEntry taxLink;

        if (!_ledgerDimension || !_taxTrans)
        {
            return;
        }

        select firstonly forupdate taxLink
            where taxLink.TaxTrans                   == _taxTrans.RecId
               && taxLink.TaxTransRelationship       == _taxTransRelationship
               && taxLink.GeneralJournalAccountEntry ==  0;

        if (taxLink && taxLink.LedgerDimension == _ledgerDimension)
        {
            return;
        }
        else if (!taxLink)
        {
            taxLink.clear();
            taxLink.TaxTrans             = _taxTrans.RecId;
            taxLink.TaxTransRelationship = _taxTransRelationship;
        }

        taxLink.LedgerDimension = _ledgerDimension;
        taxLink.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVATDeferredEntry_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates records for <c> TaxTransGeneralJournalAccountEntry </c> without linked GeneralJournalAccountEntry to save information about VATdeferment.
    /// </summary>
    /// <param name="_ledgerDimensionAccount">
    ///  Record Id of the <c>LedgerDimensionAccount</c> associated with this record.
    /// </param>
    /// <param name="_taxTransRecId">
    ///  The TaxTrans RecId.
    /// </param>
    public static void createVATDeferredEntry_IN(
        LedgerDimensionAccount  _ledgerDimensionAccount,
        TaxTransRecId           _taxTransRecId)
    {
        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntry;

        taxTransGeneralJournalAccountEntry.TaxTrans = _taxTransRecId;
        taxTransGeneralJournalAccountEntry.LedgerDimension = _ledgerDimensionAccount;
        taxTransGeneralJournalAccountEntry.TaxTransRelationship = TaxTransRelationshipType::Tax;
        taxTransGeneralJournalAccountEntry.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>TaxTransLedgerEntry</c> table exists.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the <c>TaxTransLedgerEntry</c> record.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean exist(recId _recId)
    {
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;

        select firstonly
            RecId
        from
            taxTransGeneralJournalAccountEntry
        where
            taxTransGeneralJournalAccountEntry.RecId == _recId;

        return taxTransGeneralJournalAccountEntry != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for a <c>TaxTransGeneralJournalAccountEntry</c> record based on parameters
    /// </summary>
    /// <param name="_taxTransRecId">
    /// RecId of <c>TaxTrans</c> record
    /// </param>
    /// <param name="_taxTransRelationshipType">
    /// Type of relationship between <c>TaxTrans</c> and <c>GeneralJournalAccountEntry</c>.
    /// </param>
    /// <param name="_generalJournalAccountEntryRecId">
    /// RecId of <c>GeneralJournalAccountEntry</c> record
    /// </param>
    /// <param name="_forUpdate">
    /// Whether record shoudl be selected for update
    /// </param>
    /// <returns>
    /// Found <c>TaxTransGeneralJournalAccountEntry</c> record
    /// </returns>
    public static TaxTransGeneralJournalAccountEntry find_RU(
        TaxTransRecId                   _taxTransRecId,
        TaxTransRelationshipType        _taxTransRelationshipType,
        GeneralJournalAccountEntryRecId _generalJournalAccountEntryRecId = 0,
        boolean                         _forUpdate = false)
    {
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;

        taxTransGeneralJournalAccountEntry.selectForUpdate(_forUpdate);

        select firstonly taxTransGeneralJournalAccountEntry
            where taxTransGeneralJournalAccountEntry.TaxTrans                   == _taxTransRecId
               && taxTransGeneralJournalAccountEntry.TaxTransRelationship       == _taxTransRelationshipType
               && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _generalJournalAccountEntryRecId;

        return taxTransGeneralJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record ID for the <c>LedgerDimensionAccount</c> record that is associated with this record.
    /// </summary>
    /// <param name="_taxTransRecId">
    /// The record ID of the <c>TaxTrans</c> record.
    /// </param>
    /// <param name="_taxTransRelationshipType">
    /// The type of record.
    /// </param>
    /// <param name="_accountingDistribution">
    /// The accountingDistribution.
    /// </param>
    /// <returns>
    /// The record ID of the <c>LedgerDimensionAccount</c> record that is associated with this record.
    /// </returns>
    static public LedgerDimensionAccount getLedgerDimensionForTaxTrans(
        TaxTransRecId               _taxTransRecId,
        TaxTransRelationshipType    _taxTransRelationshipType,
        AccountingDistribution      _accountingDistribution = null)
    {
        TaxTransGeneralJournalAccountEntry taxLink;
        GeneralJournalAccountEntry generalJournalAccountEntry;

        SubledgerJournalAccountEntryDistribution    subledgerJournalAccountEntryDistribution;
        SubledgerJournalAccountEntry                subledgerJournalAccountEntry;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            if (!_accountingDistribution)
            {
                select firstonly LedgerDimension, GeneralJournalAccountEntry from taxLink
                    where taxLink.TaxTrans == _taxTransRecId &&
                            taxLink.TaxTransRelationship == _taxTransRelationshipType;
            }
            else
            {
                select firstonly RecId, GeneralJournalAccountEntry, LedgerDimension from taxLink
                    where taxLink.TaxTrans == _taxTransRecId &&
                            taxLink.TaxTransRelationship == _taxTransRelationshipType
                join AccountingDistribution from subledgerJournalAccountEntryDistribution
                    where subledgerJournalAccountEntryDistribution.AccountingDistribution == _accountingDistribution.RecId
                join LedgerDimension from subledgerJournalAccountEntry
                    where subledgerJournalAccountEntry.GeneralJournalAccountEntry == taxLink.GeneralJournalAccountEntry
                    && subledgerJournalAccountEntry.RecId == subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry;
            }
        }
        else
        {
            select firstonly LedgerDimension, GeneralJournalAccountEntry from taxLink
                where taxLink.TaxTrans == _taxTransRecId &&
                taxLink.TaxTransRelationship == _taxTransRelationshipType;
        }

        if (taxLink.LedgerDimension != 0)
        {
            return taxLink.LedgerDimension;
        }

        if (!taxLink)
        {
            str exceptionPlace = strFmt('[%1::%2]', tableStr(TaxTransGeneralJournalAccountEntry), tableStaticMethodStr(TaxTransGeneralJournalAccountEntry, getLedgerDimensionForTaxTrans));

            TaxTransGeneralJournalAccountEntry::logTaxLinkLostError(_taxTransRecId, _taxTransRelationshipType, _accountingDistribution.RecId, exceptionPlace);
        }

        return taxLink.getLedgerDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>logTaxLinkLostError</Name>
				<Source><![CDATA[
    static private void logTaxLinkLostError(RefRecId _taxTransRecId, TaxTransRelationshipType _taxTransRelationshipType, RefRecId _accountingDistributionRecId, str _exceptionPlace)
    {
        Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource   taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
        str                                                     processMessage;
        TaxTrans                                                taxTransLoc;

        taxTransLoc = TaxTrans::findByRecId(_taxTransRecId);

        processMessage += 'Cannot find TaxTransGeneralJournalAccountEntry for TaxTransRecId: ' + int642Str(_taxTransRecId);
        processMessage += ', SourceTableId: ' + int642Str(taxTransLoc.SourceTableId);
        processMessage += ', SourceTableName: ' + tableId2Name(taxTransLoc.SourceTableId);
        processMessage += ', SourceRecId: ' + int642Str(taxTransLoc.SourceRecId);
        processMessage += ', TaxTransRelationshipType: ' + enum2Symbol(enumNum(TaxTransRelationshipType), _taxTransRelationshipType);
        processMessage += ', AccountingDistribution: ' + int642Str(_accountingDistributionRecId);

        taxEventSourceLog.TaxProcessError(guid2Str(newGuid()), processMessage, ApplicationPlatformTelemetry::formatCallStack(xSession::xppCallStack()), _exceptionPlace);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxLedgerDimensionForTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record ID for the <c>LedgerDimensionAccount</c> record that is associated with this record.
    /// </summary>
    /// <param name="_taxTransRecId">
    /// The record ID of the <c>TaxTrans</c> record.
    /// </param>
    /// <param name="_accountingDistribution">
    /// The accountingDistribution.
    /// </param>
    /// <returns>
    /// The record ID of the <c>LedgerDimensionAccount</c> record that is associated with this record.
    /// </returns>
    static public LedgerDimensionAccount getTaxLedgerDimensionForTaxTrans(TaxTransRecId _taxTransRecId, AccountingDistribution _accountingDistribution = null)
    {
        LedgerDimensionAccount ledgerDimension = TaxTransGeneralJournalAccountEntry::getLedgerDimensionForTaxTrans(
            _taxTransRecId,
            TaxTransRelationshipType::Tax,
            _accountingDistribution);

        if (!ledgerDimension)
        {
            ledgerDimension = TaxTransGeneralJournalAccountEntry::getLedgerDimensionForTaxTrans(
                _taxTransRecId,
                TaxTransRelationshipType::TaxInCostPrice,
                _accountingDistribution);
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForTaxTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>LedgerDimensionAccount</c> for a special tax account type based on <c>TaxTrans_IN</c>
    /// </summary>
    /// <param name="_taxTransRecId">
    /// The recId of the <c>TaxTrans</c>
    /// </param>
    /// <param name="_taxTransRelationshipType">
    /// The Given tax relation type
    /// </param>
    /// <param name="_accountFieldName">
    /// The field name of the ledgerDimension field on the <c>TaxTrans_IN</c>
    /// </param>
    /// <returns>
    /// Returns the first matched <c>TaxTransGeneralJournalAccountEntry</c>
    /// </returns>
    static public TaxTransGeneralJournalAccountEntry getLedgerDimensionForTaxTrans_IN(
        TaxTransRecId _taxTransRecId,
        TaxTransRelationshipType _taxTransRelationshipType,
        str _accountFieldName)
    {
        TaxTrans_IN                     taxTransIN;
        LedgerDimensionAccount          postedAccountDimension;
        LedgerDimensionDefaultAccount   postedAccount;

        TaxTransGeneralJournalAccountEntry taxLink;
        GeneralJournalAccountEntry generalJournalAccountEntry;

        taxTransIN = TaxTrans_IN::findRefRecId(_taxTransRecId);

        if (taxTransIN)
        {
            postedAccountDimension = taxTransIN.getFieldValue(_accountFieldName);

            if (postedAccountDimension)
            {
                postedAccount = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(postedAccountDimension);

                while select * from taxLink
                    where taxLink.TaxTrans == _taxTransRecId &&
                        taxLink.TaxTransRelationship == _taxTransRelationshipType
                    exists join LedgerDimension from generalJournalAccountEntry
                        where generalJournalAccountEntry.RecId == taxLink.GeneralJournalAccountEntry
                {
                    if (LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(taxLink.LedgerDimension)  == postedAccount)
                    {
                        break;
                    }
                }
            }
        }

        return taxLink;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromGeneralJournalAccountEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>TaxTransGeneralJournalAccountEntry</c> record.
    /// </summary>
    /// <param name="_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> record.
    /// </param>
    /// <returns>
    /// A <c>TaxTransGeneralJournalAccountEntry</c> record.
    /// </returns>
    public static TaxTransGeneralJournalAccountEntry initFromGeneralJournalAccountEntry(GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;

        taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry = _generalJournalAccountEntry.RecId;
        taxTransGeneralJournalAccountEntry.LedgerDimension = _generalJournalAccountEntry.LedgerDimension;

        return taxTransGeneralJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTaxForeignKeyToTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Replaces the foreign key to the <c>TaxUncommitted</c> table on <c>TaxTransGeneralJournalAccountEntry</c> with
    ///   a foreign key to the table <c>TaxTrans</c>.
    /// </summary>
    /// <param name="_taxUncommittedTaxTransTmp">
    ///   A table containing a mapping of TaxUncommitted records to TaxTrans records.
    /// </param>
    public static void moveTaxForeignKeyToTaxTrans(TaxUncommittedTaxTransTmp _taxUncommittedTaxTransTmp)
    {
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;

        ttsbegin;

        while select forUpdate crosscompany taxTransGeneralJournalAccountEntry
            where taxTransGeneralJournalAccountEntry.TaxUncommitted != 0
        join _taxUncommittedTaxTransTmp
            where _taxUncommittedTaxTransTmp.TaxUncommitted == taxTransGeneralJournalAccountEntry.TaxUncommitted
        {
            changeCompany(taxTransGeneralJournalAccountEntry.dataAreaId)
            {
                taxTransGeneralJournalAccountEntry.TaxTrans = _taxUncommittedTaxTransTmp.TaxTrans;
                taxTransGeneralJournalAccountEntry.TaxUncommitted = 0;
                taxTransGeneralJournalAccountEntry.update();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversePostedByTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates reversing links for all the associated <c>TaxTrans</c> records.
    /// </summary>
    /// <param name="_taxTransRecId">
    /// The record ID of the original <c>TaxTrans</c> record.
    /// </param>
    /// <param name="_taxTransRelationshipType">
    /// The relationship to reverse.
    /// </param>
    /// <param name="_taxTransOldAndNewRecId">
    /// A map that contains the old <c>TaxTrans</c> record ID as the key, and the new <c>TaxTrans</c>
    /// record ID as the value.
    /// </param>
    public static void reversePostedByTaxTrans(
        RefRecId                    _taxTransRecId,
        TaxTransRelationshipType    _taxTransRelationshipType,
        Map                         _taxTransOldAndNewRecId)
    {
        TaxTransGeneralJournalAccountEntry taxLink, taxLinkLocal;
        TaxBase taxBase;
        RefRecId refRecId;

        while select * from taxLink
            where taxLink.TaxTrans == _taxTransRecId &&
                taxLink.TaxTransRelationship == _taxTransRelationshipType
        {
            refRecId = _taxTransOldAndNewRecId.lookup(taxLink.TaxTrans);

            taxBase = TaxTrans::findRecId_IN(refRecId).TaxBaseAmount;
            taxLinkLocal.TaxTrans = refRecId;
            taxLinkLocal.LedgerDimension = taxLink.LedgerDimension;
            taxLinkLocal.TaxTransRelationship = taxLink.TaxTransRelationship;
            taxLinkLocal.AllocationFactor = taxLink.AllocationFactor;
            taxLinkLocal.AccountingCurrencyAmount = abs(taxLink.AccountingCurrencyAmount) * sign(taxBase);
            taxLinkLocal.GeneralJournalAccountEntry = taxLink.GeneralJournalAccountEntry;
            taxLinkLocal.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversePostedLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates reversing links for all the associated <c>GeneralJournalAccountEntry</c> records.
    /// </summary>
    /// <param name="_originalGeneralJournalAccountEntryRecId">
    /// The record ID of the original <c>GeneralJournalAccountEntry</c> record. Original means the very initial record.
    /// Suppose a voucher A has already been reversed once, the reversal voucher is B.
    /// On the second time of reversal, the original <c>GeneralJournalAccountEntry</c> should be still from A, not B.
    /// </param>
    /// <param name="_taxTransOldAndNewRecId">
    /// A map that contains the old <c>TaxTrans</c> record ID as the key and the new <c>TaxTrans</c> record
    /// ID as the value.
    /// </param>
    /// <param name="_newLedgerVoucherTransObject">
    /// The <c>LedgerVoucherTransObject</c> object that is processing the reversal.
    /// </param>
    /// <returns>
    /// A map that indicates which <c>TaxTransRelationshipType</c> values were created in the
    /// <c>TaxTransGeneralJournalAccountEntry</c> record.
    /// </returns>
    public static Map reversePostedLinks(
        GeneralJournalAccountEntryRecId _originalGeneralJournalAccountEntryRecId,
        Map _taxTransOldAndNewRecId,
        LedgerVoucherTransObject _newLedgerVoucherTransObject)
    {
        TaxTransGeneralJournalAccountEntry taxLink;
        Map type;

        type = new Map(Types::Enum, Types::Integer);

        type.insert(TaxTransRelationshipType::Tax, false);
        type.insert(TaxTransRelationshipType::TransactionLineAccount, false);
        type.insert(TaxTransRelationshipType::UseTaxPayable, false);

        while select TaxTrans, TaxTransRelationship, AccountingCurrencyAmount, TransactionCurrencyAmount from taxLink
            where taxLink.GeneralJournalAccountEntry == _originalGeneralJournalAccountEntryRecId
        {
            type.insert(taxLink.TaxTransRelationship, true);

            if (_taxTransOldAndNewRecId.exists(taxLink.TaxTrans))
            {
                AmountMST accountingCurrencyAmount;
                AmountCur transactionCurrencyAmount;

                if (TaxTransGeneralJournalAccountEntry::shouldInvertSignForTaxLinkDuringReversal(
                    _originalGeneralJournalAccountEntryRecId,
                    _newLedgerVoucherTransObject))
                {
                    transactionCurrencyAmount = -taxLink.TransactionCurrencyAmount;
                    accountingCurrencyAmount = -taxLink.AccountingCurrencyAmount;
                }
                else
                {
                    transactionCurrencyAmount = taxLink.TransactionCurrencyAmount;
                    accountingCurrencyAmount = taxLink.AccountingCurrencyAmount;
                }

                _newLedgerVoucherTransObject.addTaxTransRelationship(
                    _taxTransOldAndNewRecId.lookup(taxLink.TaxTrans),
                    taxLink.TaxTransRelationship,
                    curext(),
                    accountingCurrencyAmount,
                    transactionCurrencyAmount
                    );
            }
        }

        return type;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInvertSignForTaxLinkDuringReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the sign of taxlink should be inverted or not
    /// according to whether the sign of <c>GeneralJournalAccountEntry</c> is inverted or not.
    /// </summary>
    /// <param name="_originalGeneralJournalAccountEntryRecId">
    /// The record ID of the original <c>GeneralJournalAccountEntry</c> record. Original means the very initial record.
    /// Suppose a voucher A has already been reversed once, the reversal voucher is B.
    /// On the second time of reversal, the original <c>GeneralJournalAccountEntry</c> should be still from A, not B.
    /// </param>
    /// <param name="_newLedgerVoucherTransObject">
    /// The <c>LedgerVoucherTransObject</c> object that is processing the reversal.
    /// </param>
    /// <returns>true if the sign should be inverted; otherwise, false.</returns>
    /// <remarks>This method should only be used during reversal.</remarks>
    private static boolean shouldInvertSignForTaxLinkDuringReversal(
        GeneralJournalAccountEntryRecId _originalGeneralJournalAccountEntryRecId,
        LedgerVoucherTransObject _newLedgerVoucherTransObject)
    {
        boolean shouldInvert = false;
        AmountCur accountingCurrencyAmountNew = _newLedgerVoucherTransObject.parmAccountingCurrencyAmount();
        AmountCur transactionCurrencyAmountNew = _newLedgerVoucherTransObject.parmTransactionCurrencyAmount();

        GeneralJournalAccountEntry originalGeneralJournalAccountEntry
            = GeneralJournalAccountEntry::find(_originalGeneralJournalAccountEntryRecId);
        AmountCur accountingCurrencyAmountOrig = originalGeneralJournalAccountEntry.AccountingCurrencyAmount;
        AmountCur transactionCurrencyAmountOrig = originalGeneralJournalAccountEntry.TransactionCurrencyAmount;

        boolean isAccountingCurInverted = sign(accountingCurrencyAmountNew) != sign(accountingCurrencyAmountOrig);
        boolean isTransactionCurInverted = sign(transactionCurrencyAmountNew) != sign(transactionCurrencyAmountOrig);

        // During reversal, the sign of <c>GeneralJournalAccountEntry</c> may be inverted or kept the same.
        // To keep consistency, the same operation should be done to taxlink accordingly.
        if (isAccountingCurInverted || isTransactionCurInverted)
        {
            // The sign of <c>GeneralJournalAccountEntry</c> is inverted.
            shouldInvert = true;
        }
        else
        {
            // The sign of <c>GeneralJournalAccountEntry</c> is not inverted.
            shouldInvert = false;
        }
        return shouldInvert;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the message to use when a specific record in the TaxTransLedgerEntry table does not exist.
    /// </summary>
    /// <returns>
    /// The message that indicates a record does not exists.
    /// </returns>
    public static TxtNotExist txtNotExist()
    {
        ;

        return "@SYS102169";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxLinkRecIdForTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record ID for the <c>TaxTransGeneralJournalAccountEntry</c> record that is associated with the specified <c>TaxTrans</c> record ID.
    /// </summary>
    /// <param name="_taxTransRecId">
    /// The record ID of the <c>TaxTrans</c> record.
    /// </param>
    /// <param name="_taxTransRelationshipType">
    /// The type of record.
    /// </param>
    /// <returns>
    /// The record ID of the <c>TaxTransGeneralJournalAccountEntry</c> record that is associated with this record.
    /// </returns>
    public static TaxTransGeneralJournalAccountEntryRecId getTaxLinkRecIdForTaxTrans(TaxTransRecId _taxTransRecId, TaxTransRelationshipType _taxTransRelationshipType)
    {
        TaxTransGeneralJournalAccountEntry taxLink;

        select firstonly RecId from taxLink
            where taxLink.TaxTrans == _taxTransRecId &&
                taxLink.TaxTransRelationship == _taxTransRelationshipType;

        return taxLink.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deTaxRefId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Search all <c>TaxTransGeneralJournalAccountEntry</c> records,
    /// which belong together due to a common TaxTrans or a common GeneralLedgerJournalEntry
    /// </summary>
    /// <returns>
    /// Displays Least Recid number of the <c>TaxTransGeneralJournalAccountEntry</c> record.
    /// </returns>
    public display RefRecId deTaxRefId()
    {
        return this.getTaxRefId_DE();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxRefId_DE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Search all <c>TaxTransGeneralJournalAccountEntry</c> records,
    /// which belong together due to a common TaxTrans or a common GeneralLedgerJournalEntry
    /// </summary>
    /// <returns>
    /// Least Recid number of the <c>TaxTransGeneralJournalAccountEntry</c> record.
    /// </returns>
    public RefRecId getTaxRefId_DE()
    {
        // Initialize the arrays with the RecId values of the records to be used
        int taxTransCount = 0;
        int ledgerTransCount = 0;

        RecId taxTransId[];
        taxTransId[0] = 0;

        RecId ledgerTransId[];
        ledgerTransId[0] = 0;

        RecId minimumId = this.RecId;

        int ledgerCurrent = ledgerTransCount;
        int taxCurrent = taxTransCount;

        if (this.TaxTrans)
        {
            taxTransCount++;
            taxTransId[taxTransCount] = this.TaxTrans;
        }

        // Search, until all taxTrans values have been treated
        while (taxCurrent < taxTransCount)
        {
            taxCurrent++;
            // add all GeneralJournalAccountEntry RecIds to the array to be checked
            TaxTransGeneralJournalAccountEntry taxEntry;
            while select taxEntry
                where taxEntry.TaxTrans == taxTransId[taxCurrent]
            {
                if (taxEntry.GeneralJournalAccountEntry)
                {
                    int ledgerTransCurrent = 1;
                    while ((ledgerTransCurrent <= ledgerTransCount)
                        && (ledgerTransId[ledgerTransCurrent] != taxEntry.GeneralJournalAccountEntry))
                    {
                        ledgerTransCurrent++;
                    }
                    if (ledgerTransCurrent > ledgerTransCount)
                    {
                        ledgerTransCount++;
                        ledgerTransId[ledgerTransCount] = taxEntry.GeneralJournalAccountEntry;

                        if (taxEntry.RecId && taxEntry.RecId < minimumId)
                        {
                            minimumId = taxEntry.RecId;
                        }
                    }
                }
            }

            // For all unchecked GeneralJournalAccountEntry RecIds add all TaxTrans RecIds to the array to be checked
            while (ledgerCurrent < ledgerTransCount)
            {
                ledgerCurrent++;
                TaxTransGeneralJournalAccountEntry ledgerEntry;
                while select ledgerEntry
                    where ledgerEntry.GeneralJournalAccountEntry == ledgerTransId[ledgerCurrent]
                {
                    if (ledgerEntry.TaxTrans)
                    {
                        int taxTransCurrent = 1;
                        while ((taxTransCurrent <= taxTransCount)
                            && (taxTransId[taxTransCurrent] != ledgerEntry.TaxTrans))
                        {
                            taxTransCurrent++;
                        }
                        if (taxTransCurrent > taxTransCount)
                        {
                            taxTransCount++;
                            taxTransId[taxTransCount] = ledgerEntry.TaxTrans;

                            if (ledgerEntry.RecId && ledgerEntry.RecId < minimumId)
                            {
                                minimumId = ledgerEntry.RecId;
                            }
                        }
                    }
                }
            }
            // In case that the found number of Taxrans RecIds has been increased, run the loop again
        }

        // Return the smallest found RecId value from table TaxTransGeneralJournalAccountEntry
        return minimumId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<DeveloperDocumentation>@SYS318720</DeveloperDocumentation>
	<Label>@SYS318719</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>TaxTrans</TitleField1>
	<TitleField2>TaxTransRelationship</TitleField2>
	<AllowArchival>Yes</AllowArchival>
	<AllowRetention>Yes</AllowRetention>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<Modules>Tax</Modules>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxTrans</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxTransRelationship</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GeneralJournalAccountEntry</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS318724</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxTrans</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxTransRelationship</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GeneralJournalAccountEntry</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxUncommitted</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>GeneralJournalAccountEntry</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>GeneralJournalAccountEntryRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionAccount</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxTrans</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxTransRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxTransRelationship</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>TaxTransRelationshipType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxUncommitted</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AccountingCurrencyAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>MonetaryAmountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>MonetaryAmount</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SubledgerJournalAccountEntry</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SubledgerJournalAccountEntryRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransactionCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TransactionCurrencyAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AllocationFactor</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AllocationFactor</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TaxTransIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>TaxTrans</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>GeneralJournalAccountEntry</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxTransRelationship</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>dataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LedgerDimension</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>GeneralJournalAccountEntryIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>GeneralJournalAccountEntry</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxTransRelationship</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TaxUncommittedIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>TaxUncommitted</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxTransRelationship</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>GeneralJournalAccountEntry</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TaxTransGeneralLedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>TaxTrans</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxTransRelationship</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LedgerDimension</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>GeneralJournalAccountEntry</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>GeneralJournalAccountEntry</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>GeneralJournalAccountEntry</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>GeneralJournalAcountEntry</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>GeneralJournalAccountEntry</Name>
					<Field>GeneralJournalAccountEntry</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxTransGeneralJournalAccountEntry</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimension</Name>
					<Field>LedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxTrans</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxTrans</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxTrans_TaxTransGeneralJournalAccountEntry</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxTrans</Name>
					<Field>TaxTrans</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxUncommitted</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxUncommitted</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxUncommitted</Name>
					<Field>TaxUncommitted</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TransactionCurrency</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>TransactionCurrency</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SubledgerJournalAccountEntry</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SubledgerJournalAccountEntry</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SubledgerJournalAccountEntry</Name>
					<Field>SubledgerJournalAccountEntry</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>