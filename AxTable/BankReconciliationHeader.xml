<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankReconciliationHeader</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class BankReconciliationHeader extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canSubmitToWorkflow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the reconciliation can be submitted to workflow.
    /// </summary>
    /// <param name="_workflowType">
    /// The work flow type.
    /// </param>
    /// <returns>
    /// true if the reconciliation can be submitted to workflow; otherwise, false.
    /// </returns>
    public boolean canSubmitToWorkflow(str _workflowType = '')
    {
        boolean ret;

        if (this.RecId != 0
            && this.BankReconciliationApprovalWFStatus == BankReconciliationApprovalWFStatus::Draft
            && !this.IsReconciled
            && ((BankReconciliationHeaderWorkflowEnableFlight::instance().isEnabled() && BankParameters::find().AllowBlankBankStatement)
                || this.checkHasMatchingItem()))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkHasMatchingItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the reconciliation has a matching item.
    /// </summary>
    /// <returns>
    /// true if the reconciliation has a matching item; otherwise, false.
    /// </returns>
    private boolean checkHasMatchingItem()
    {
        BankReconciliationMatchingItemView matchingItemView;

        #macrolib.BankReconciliationConditions

        select firstOnly RecId from matchingItemView
            #MatchedItem(matchingItemView, this);

        return matchingItemView.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkHasMatchingItemGreaterThanCutoffDate</Name>
				<Source><![CDATA[
    private boolean checkHasMatchingItemGreaterThanCutoffDate()
    {
        return (this.checkForMatchingBankDocumentGreaterThanCutoffDate() 
            || this.checkForMatchingBankStatementGreaterThanCutoffDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForMatchingBankDocumentGreaterThanCutoffDate</Name>
				<Source><![CDATA[
    private boolean checkForMatchingBankDocumentGreaterThanCutoffDate()
    {
        BankReconciliationMatchingItemView matchingItemView;
        BankDocumentTableView bankDocumentTableView;

        if (this.RecId != 0)
        {
            if (BankRedesignGenerateVoucherFlight::instance().isEnabled())
            {
                select firstOnly RecId from matchingItemView
                    exists join bankDocumentTableView
                        where matchingItemView.BankDocumentTable == bankDocumentTableView.BankDocumentTableRecId
                            && bankDocumentTableView.DocumentDate > this.CutOffDate
                            && bankDocumentTableView.DocumentType != BankDocumentBookType::BankStatement
                            && matchingItemView.BankReconciliationHeader == this.RecId;
            }
            else
            {
                select firstOnly RecId from matchingItemView
                    exists join bankDocumentTableView
                        where matchingItemView.BankDocumentTable == bankDocumentTableView.BankDocumentTableRecId
                            && bankDocumentTableView.DocumentDate > this.CutOffDate
                            && matchingItemView.BankReconciliationHeader == this.RecId;
            }

            if (!matchingItemView.RecId && FeatureStateProvider::isFeatureEnabled(BankModernReconciliationFeature::instance()))
            {
                // Check for generate voucher related bank document
                BankDocumentTable bankDocumentTable;
                BankStmtISOReportEntry bankStmtISOReportEntry;
                select firstOnly RecId from matchingItemView
                    where matchingItemView.BankReconciliationHeader == this.RecId
                    join RecId from bankDocumentTable
                        where bankDocumentTable.IsReconciled == NoYes::Yes
                            && bankDocumentTable.BankDocumentBookType == BankDocumentBookType::BankStatement
                            && matchingItemView.BankDocumentTable == bankDocumentTable.RecId
                    join RecId from bankStmtISOReportEntry
                        where bankDocumentTable.SourceRecId == bankStmtISOReportEntry.RecId
                            && bankStmtISOReportEntry.AccountingDate > this.CutOffDate;
            }
        }

        return matchingItemView.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForMatchingBankStatementGreaterThanCutoffDate</Name>
				<Source><![CDATA[
    private boolean checkForMatchingBankStatementGreaterThanCutoffDate()
    {
        BankReconciliationMatchingItemView matchingItemView;
        BankStmtISOReportEntry reportEntry;

        TransDateTime cutoffDateTime = this.getCutOffDateTime();

        if (this.RecId != 0)
        {
            select firstonly RecId from matchingItemView
                exists join reportEntry
                    where matchingItemView.BankStmtISOReportEntry == reportEntry.RecId
                        && matchingItemView.BankReconciliationHeader == this.RecId
                        && reportEntry.BookingDateTime > cutoffDateTime;
        }

        return matchingItemView.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDocumentItemInHistoryDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the document items of a bank reconciliation as the history records.
    /// </summary>
    private void createDocumentItemInHistoryDetails()
    {
        BankReconciliationHistoryDetails openedDocumentItem;
        BankDocumentTableView documentView;
        BankAccountTrans cancelledBankAccountTrans;
        RecId bankReconciliationHeaderRecId = this.RecId;

        insert_recordset openedDocumentItem (BankDocumentTable, BankReconciliationHeader)
            select BankDocumentTableRecId, bankReconciliationHeaderRecId from documentview
                where documentView.IsReconciled == NoYes::No
                    && documentView.AccountId == this.AccountId
                    && documentView.DocumentType != BankDocumentBookType::Cheque
                    && documentView.DocumentDate <= this.CutoffDate;

        BankChequeTable bankChequeTable;
        CustVendPDCRegister custVendPDCRegister;

        insert_recordset openedDocumentItem (BankDocumentTable, BankReconciliationHeader)
            select BankDocumentTableRecId, bankReconciliationHeaderRecId from documentview
                where documentView.IsReconciled == NoYes::No
                    && documentView.AccountId == this.AccountId
                    && documentView.DocumentType == BankDocumentBookType::Cheque
                    && documentView.DocumentDate <= this.CutoffDate
                exists join bankChequeTable
                    where bankChequeTable.RecId == documentView.SourceRecId
                notexists join custVendPDCRegister
                    where custVendPDCRegister.LedgerJournalTrans == bankChequeTable.SourceRecId
                        && bankChequeTable.SourceTableId == tableNum(LedgerJournalTrans);

        insert_recordset openedDocumentItem (BankDocumentTable, BankReconciliationHeader)
            select BankDocumentTableRecId, bankReconciliationHeaderRecId from documentview
                where documentView.IsReconciled == NoYes::No
                    && documentView.AccountId == this.AccountId
                    && documentView.DocumentType == BankDocumentBookType::Cheque
                exists join bankChequeTable
                    where bankChequeTable.RecId == documentView.SourceRecId
                exists join custVendPDCRegister
                    where custVendPDCRegister.LedgerJournalTrans == bankChequeTable.SourceRecId
                        && bankChequeTable.SourceTableId == tableNum(LedgerJournalTrans)
                        && custVendPDCRegister.MaturityDate <= this.CutoffDate;

        insert_recordset openedDocumentItem (BankDocumentTable, BankReconciliationHeader)
            select BankDocumentTableRecId, bankReconciliationHeaderRecId from documentview
                where documentView.IsReconciled == NoYes::Yes
                    && documentView.AccountId == this.AccountId
                    && documentView.DocumentDate <= this.CutoffDate
                    && documentView.DocumentType == BankDocumentBookType::Cheque
                    && documentView.Cancelled == NoYes::Yes
                    && documentView.SourceRelationType == tableNum(BankChequeTable)
                exists join cancelledBankAccountTrans
                    where cancelledBankAccountTrans.SourceTableId == documentView.SourceRelationType
                        && cancelledBankAccountTrans.SourceRecId == documentView.SourceRecId
                        && cancelledBankAccountTrans.Cancel == NoYes::Yes
                        && cancelledBankAccountTrans.TransDate > this.CutoffDate
                notexists join custVendPDCRegister
                    where custVendPDCRegister.LedgerJournalTrans == bankChequeTable.SourceRecId
                        && bankChequeTable.SourceTableId == tableNum(LedgerJournalTrans);

        insert_recordset openedDocumentItem (BankDocumentTable, BankReconciliationHeader)
            select BankDocumentTableRecId, bankReconciliationHeaderRecId from documentview
                where documentView.IsReconciled == NoYes::Yes
                    && documentView.AccountId == this.AccountId
                    && documentView.DocumentType == BankDocumentBookType::Cheque
                    && documentView.Cancelled == NoYes::Yes
                    && documentView.SourceRelationType == tableNum(BankChequeTable)
                exists join cancelledBankAccountTrans
                    where cancelledBankAccountTrans.SourceTableId == documentView.SourceRelationType
                        && cancelledBankAccountTrans.SourceRecId == documentView.SourceRecId
                        && cancelledBankAccountTrans.Cancel == NoYes::Yes
                        && cancelledBankAccountTrans.TransDate > this.CutoffDate
                exists join custVendPDCRegister
                    where custVendPDCRegister.LedgerJournalTrans == bankChequeTable.SourceRecId
                        && bankChequeTable.SourceTableId == tableNum(LedgerJournalTrans)
                        && custVendPDCRegister.MaturityDate <= this.CutoffDate;

        if (FeatureStateProvider::isFeatureEnabled(BankModernReconciliationFeature::instance()))
        {
            // Process the document items of a bank reconciliation for generate voucher to show the history records as archive/reference.
            BankDocumentStatementLineView bankDocumentStatementLineView;
            BankStmtISOReportEntry bankStmtISOReportEntry;
            insert_recordset openedDocumentItem (BankDocumentTable, BankReconciliationHeader)
                select BankDocumentTableRecId, bankReconciliationHeaderRecId from bankDocumentStatementLineView
                    where BankDocumentStatementLineView.IsReconciled == NoYes::Yes
                        && BankDocumentStatementLineView.DocumentType == BankDocumentBookType::BankStatement
                        && BankDocumentStatementLineView.AccountId == this.AccountId
                        && BankDocumentStatementLineView.SourceRelationType == tableNum(BankStmtISOReportEntry)
                    exists join bankStmtISOReportEntry
                        where bankStmtISOReportEntry.RecId == BankDocumentStatementLineView.SourceRecId
                            && bankStmtISOReportEntry.Reconciled == NoYes::No
                            && bankStmtISOReportEntry.AccountingDate <= this.CutoffDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createStatementItemInHistoryDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the statement items of a bank reconciliation as the history records.
    /// </summary>
    private void createStatementItemInHistoryDetails()
    {
        BankReconciliationHistoryDetails historyDetails;
        BankStmtISOReportEntry reportEntry;
        BankStmtISOAccountStatement statement;
        TransDateTime cutoffDateTime = this.getCutOffDateTime();
        RecId bankReconciliationHeaderRecId = this.RecId;

        insert_recordset historyDetails (BankStmtISOReportEntry, BankReconciliationHeader)
            select RecId, bankReconciliationHeaderRecId from reportEntry
                where reportEntry.Reconciled == NoYes::No
                    && reportEntry.BookingDateTime <= cutoffDateTime
                exists join statement
                    where statement.RecId == reportEntry.BankStmtISOAccountStatement
                        && statement.BankAccountTable == this.AccountId
                        && statement.Status != BankStatementStatus::Open;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispBankAccountNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a bank account number.
    /// </summary>
    /// <returns>
    /// The bank account number to display.
    /// </returns>
    public display BankAccount dispBankAccountNumber()
    {
        return this.getBankAccountNumber();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispBankCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a bank currency.
    /// </summary>
    /// <returns>
    /// The bank currency to display.
    /// </returns>
    public display CurrencyCode dispBankCurrency()
    {
        return this.getBankCurrency();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispBankName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a bank name.
    /// </summary>
    /// <returns>
    /// The bank name to display.
    /// </returns>
    public display Name dispBankName()
    {
        return this.getBankName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispDocumentTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a summary amount of a bank document.
    /// </summary>
    /// <returns>
    /// The summary amount of a bank document to display.
    /// </returns>
    public display BankReconciliationDocumentSummaryAmount dispDocumentTotal()
    {
        return this.getDocumentTotal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispLastStatementId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the last bank statement ID.
    /// </summary>
    /// <returns>
    /// The last bank statement ID to display.
    /// </returns>
    public display BankStatementId dispLastStatementId()
    {
        return this.getLastStatementId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispMatchedStatementTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a matched amount for the matched bank statement lines.
    /// </summary>
    /// <returns>
    /// The matched amount for the matched bank statement lines.
    /// </returns>
    public display BankReconciliationMatchedAmountCur dispMatchedStatementTotal()
    {
        return this.getMatchedStatementTotal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispReconciliationInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reconciliation information.
    /// </summary>
    /// <returns>
    /// The reconciliation information.
    /// </returns>
    public display Caption dispReconciliationInfo()
    {
        return strFmt("@CashManagement:BankReconciliationInfo",
            this.ReconciliationId,
            this.CutOffDate,
            this.dispBankName(),
            this.dispBankAccountNumber(),
            this.dispBankCurrency());
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispStatementEndingBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the statement ending balance.
    /// </summary>
    /// <returns>
    /// The statement ending balance to display.
    /// </returns>
    public display BankStatementEndingBalance dispStatementEndingBalance()
    {
        return this.getStatementEndingBalance();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispStatementTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the summary amount of the last bank statement.
    /// </summary>
    /// <returns>
    /// The summary amount of the last bank statement to display.
    /// </returns>
    public display BankReconciliationStatementSummaryAmount dispStatementTotal()
    {
        return this.getStatementTotal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayReconciliationInBatchProgress</Name>
				<Source><![CDATA[
    public display str displayReconciliationInBatchProgress()
    {
        BankReconciliationHeaderRunInBatchStatus status = this.ReconcileBatchStatus;
        if (status != BankReconciliationHeaderRunInBatchStatus::Running)
        {
            return enum2Str(status);
        }
        BankReconciliationBatchStatusTable statusTable = BankReconciliationBatchStatusTable::find(this.RecId);
        if (!statusTable)
        {
            return "@CashManagement:AdvancedBankReconciliationInBatchNotStarted";
        }
        System.Double percentage = statusTable.TotalCount == 0 ? 0 : statusTable.ProcessedCount / statusTable.TotalCount * 100;
        return strFmt("@CashManagement:AdvancedBankReconciliationBatchProgress", System.String::Format('{0:F2}', percentage));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedStatementTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the document adjusted total amount.
    /// </summary>
    /// <returns>
    /// The document adjusted total amount.
    /// </returns>
    public BankStatementReconciledAmount getAdjustedStatementTotal()
    {
        if (this.IsReconciled)
        {
            return this.getAdjustedStatementTotalAfterRecon();
        }
        else
        {
            return this.getAdjustedStatementTotalBeforeRecon();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedStatementTotalAfterRecon</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the posted reconciliation statement adjusted amount.
    /// </summary>
    /// <returns>
    ///     The statement adjusted amount.
    /// </returns>
    private BankStatementReconciledAmount getAdjustedStatementTotalAfterRecon()
    {
        BankReconAdjustedStatementTotalAfterRecon adjustedStatementTotal = BankReconAdjustedStatementTotalAfterRecon::construct();
        adjustedStatementTotal.setBankReconciliationHeaderRange(this.RecId);

        AmountCur adjustedAmount = adjustedStatementTotal.getAdjustedDebitAmount();
        adjustedAmount -= adjustedStatementTotal.getAdjustedCreditAmount();

        return adjustedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedStatementTotalBeforeRecon</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the posted reconciliation statement adjusted amount.
    /// </summary>
    /// <returns>
    ///     The statement adjusted amount.
    /// </returns>
    private BankStatementReconciledAmount getAdjustedStatementTotalBeforeRecon()
    {
        BankStmtISOReportEntry reportEntry;
        BankStmtISOAccountStatement statement;
        AmountCur adjustedAmount;
        BankStmtISODateTime toDateTime = this.getCutOffDateTime();
        #macrolib.BankReconciliationConditions

        select sum(Amount) from reportEntry
            #StatementLineForReconcile(reportEntry, toDateTime, statement, this)
                && reportEntry.IsNewBankDocument
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Debit;
        adjustedAmount += reportEntry.Amount;

        select sum(Amount) from reportEntry
            #StatementLineForReconcile(reportEntry, toDateTime, statement, this)
                && reportEntry.IsNewBankDocument
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Credit;
        adjustedAmount -= reportEntry.Amount;

        return adjustedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankAccountNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank account number.
    /// </summary>
    /// <returns>
    /// The bank account number.
    /// </returns>
    public BankAccount getBankAccountNumber()
    {
        return this.getBankAccountTable().AccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankAccountTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank account table.
    /// </summary>
    /// <returns>
    /// The bank account table.
    /// </returns>
    public BankAccountTable getBankAccountTable()
    {
        return BankAccountTable::find(this.AccountId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank currency.
    /// </summary>
    /// <returns>
    /// The bank currency.
    /// </returns>
    public CurrencyCode getBankCurrency()
    {
        return this.getBankAccountTable().CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank name.
    /// </summary>
    /// <returns>
    /// The bank name.
    /// </returns>
    public Name getBankName()
    {
        return this.getBankAccountTable().Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCutOffDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the upper boundary of the booking date time.
    /// </summary>
    /// <returns>
    /// The upper boundary of the booking date time.
    /// </returns>
    public TransDateTime getCutOffDateTime()
    {
        TransDateTime cutOffDateTime;

        if (FeatureStateProvider::isFeatureEnabled(BankUserPreferredTimeZoneAlignmentFeature::instance()))
        {
            cutOffDateTime = DateTimeUtil::newDateTime(this.CutOffDate, timeMax(), DateTimeUtil::getUserPreferredTimeZone());
        }
        else
        {
            cutOffDateTime = DateTimeUtil::newDateTime(this.CutOffDate, timeMax(), DateTimeUtil::getCompanyTimeZone());
        }

        return cutOffDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total amount of a bank document.
    /// </summary>
    /// <returns>
    /// The total amount of a bank document.
    /// </returns>
    public AmountCur getDocumentTotal()
    {
        if (this.IsReconciled)
        {
            return this.getDocumentTotalAfterRecon();
        }
        else
        {
            return this.getDocumentTotalBeforeRecon();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentTotalAfterRecon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the posted reconciliation document total amount.
    /// </summary>
    /// <returns>
    /// The statement total amount.
    /// </returns>
    private AmountCur getDocumentTotalAfterRecon()
    {
        BankDocumentTableView documentView;
        BankReconciliationHistoryDetails openedItem;
        AmountCur totalAmount;
        #macrolib.BankReconciliationConditions

        while select SourceRelationType, SourceRecId, DocumentType, BankDocumentTableRecId from documentView
            exists join openedItem
                where documentView.BankDocumentTableRecId == openedItem.BankDocumentTable
                    && openedItem.BankReconciliationHeader == this.RecId
        {
            totalAmount += BankDocument::newFromDocumentView(documentView).getBankCurrencyAmount();
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentTotalBeforeRecon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the unposted reconciliation document total amount.
    /// </summary>
    /// <returns>
    /// The statement total amount.
    /// </returns>
    private AmountCur getDocumentTotalBeforeRecon()
    {
        BankDocumentTableView documentView;
        #macrolib.BankReconciliationConditions
        AmountCur totalAmount;

        while select SourceRelationType, SourceRecId, DocumentType, BankDocumentTableRecId  from documentView
            where documentView.IsReconciled == NoYes::No
                && documentView.AccountId   == this.AccountId
                && documentView.DocumentDate <= this.CutoffDate
        {
            BankDocument bankDocument = BankDocument::newFromDocumentView(documentView);

            if (!(documentView.DocumentType == BankDocumentBookType::Cheque
                    && bankDocument.getTransactionDate() > this.CutOffDate))
            {
                totalAmount += bankDocument.getBankCurrencyAmount();
            }
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentUnpostedTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the unposted total amount of a bank document.
    /// </summary>
    /// <returns>
    /// The unposted total amount of a bank document.
    /// </returns>
    public AmountCur getDocumentUnpostedTotal()
    {
        if (this.IsReconciled)
        {
            return this.getDocumentUnpostedTotalAfterRecon();
        }
        else
        {
            return this.getDocumentUnpostedTotalBeforeRecon();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentUnpostedTotalAfterRecon</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the posted reconciliation document unposted total amount.
    /// </summary>
    /// <returns>
    ///     The document total unposted amount.
    /// </returns>
    private AmountCur getDocumentUnpostedTotalAfterRecon()
    {
        BankDocumentTableView documentView;
        BankReconciliationHistoryDetails openedItem;
        AmountCur totalAmount;
        #macrolib.BankReconciliationConditions

        while select SourceRelationType, SourceRecId, DocumentType, BankDocumentTableRecId from documentView
            #DocumentInReconciliationHistory(openedItem, documentView, this)
            && documentView.Posted == NoYes::No
        {
            totalAmount += BankDocument::newFromDocumentView(documentView).getBankCurrencyAmount();
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentUnpostedTotalBeforeRecon</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the unposted reconciliation document unposted total amount.
    /// </summary>
    /// <returns>
    ///     The document total unposted amount.
    /// </returns>
    private AmountCur getDocumentUnpostedTotalBeforeRecon()
    {
        BankDocumentTableView documentView;
        AmountCur totalAmount;
        #macrolib.BankReconciliationConditions

        while select SourceRelationType, SourceRecId, DocumentType, BankDocumentTableRecId from documentView
            #DocumentForReconcile(documentView, this)
            && documentView.Posted == NoYes::No
        {
            totalAmount += BankDocument::newFromDocumentView(documentView).getBankCurrencyAmount();
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentUnreconciledTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the document reconciled total amount.
    /// </summary>
    /// <returns>
    /// The document reconciled total amount.
    /// </returns>
    public AmountCur getDocumentUnreconciledTotal()
    {
        return this.getDocumentTotal() - this.getMatchedDocumentTotal() + this.getDocumentCancelledTotal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a last of <c>BankStmtISOAccountStatement</c> records that the <c>ToDateTime</c> value is
    /// before and nearest to the cutoff date.
    /// </summary>
    /// <returns>
    /// A <c>BankStmtISOAccountStatement</c> record .
    /// </returns>
    private BankStmtISOAccountStatement getLastStatement()
    {
        BankStmtISOAccountStatement lastDateStatement;
        BankStmtISODateTime toDateTime = this.getCutOffDateTime();

        select firstOnly lastDateStatement
            order by ToDateTime desc
            where lastDateStatement.BankAccountTable == this.AccountId
                && lastDateStatement.Status != BankStatementStatus::Open
                && lastDateStatement.ToDateTime <= toDateTime;

        BankStmtISOAccountStatement lastStatement = lastDateStatement;

        // If current statement has sequence number (import via MT940), find the last statement with the maximum sequence number (but larger than current statement) with the same Identification
        if (lastDateStatement.RecId && lastDateStatement.SequenceNumber != '')
        {
            int64 lastSequenceNumber = str2Int64(lastDateStatement.SequenceNumber);

            BankStmtISOAccountStatement currentStatement;
            RecId lastStatementRecId;
            while select RecId, SequenceNumber from currentStatement
                where currentStatement.BankAccountTable == lastDateStatement.BankAccountTable
                    && currentStatement.Status != BankStatementStatus::Open
                    && currentStatement.ToDateTime == lastDateStatement.ToDateTime
                    && currentStatement.Identification == lastDateStatement.Identification
                    && currentStatement.RecId != lastDateStatement.RecId
            {
                int64 currentSequenceNumber = str2Int64(currentStatement.SequenceNumber);
                if (lastSequenceNumber < currentSequenceNumber)
                {
                    lastSequenceNumber = currentSequenceNumber;
                    lastStatementRecId = currentStatement.RecId;
                }
            }
            if (lastStatementRecId != 0)
            {
                lastStatement = BankStmtISOAccountStatement::find(lastStatementRecId);
            }
        }

        return lastStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastStatementId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last bank statement ID.
    /// </summary>
    /// <returns>
    /// The last bank statement ID.
    /// </returns>
    public BankStatementId getLastStatementId()
    {
        return this.getLastStatement().Identification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMatchedDocumentTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the matched total amount for the matched bank documents.
    /// </summary>
    /// <returns>
    /// The matched total amount for the matched bank documents.
    /// </returns>
    public BankReconciliationMatchedAmountCur getMatchedDocumentTotal()
    {
        return this.getMatchedStatementTotal() - this.getAdjustedStatementTotal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMatchedStatementTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the matched total amount for the matched bank statement lines.
    /// </summary>
    /// <returns>
    /// The matched amount for the matched bank statement lines.
    /// </returns>
    public BankReconciliationMatchedAmountCur getMatchedStatementTotal()
    {
        BankReconciliationMatchingItemView matchingItemView;
        BankStmtISOReportEntry reportEntry;
        BankReconciliationMatchedAmountCur matchedAmount;
        #macrolib.BankReconciliationConditions

        select sum(Amount) from reportEntry
            #StatementLineMatched(matchingItemView, reportEntry, this)
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Debit;
        matchedAmount += reportEntry.Amount;

        select sum(Amount) from reportEntry
            #StatementLineMatched(matchingItemView, reportEntry, this)
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Credit;
        matchedAmount -= reportEntry.Amount;

        return matchedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementEndingBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the statement ending balance.
    /// </summary>
    /// <returns>
    /// The statement ending balance.
    /// </returns>
    public BankStatementEndingBalance getStatementEndingBalance()
    {
        return this.getLastStatement().getEndingBalance();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementEndingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the statement ending date.
    /// </summary>
    /// <returns>
    /// The statement ending date.
    /// </returns>
    [SysObsolete('Use getStatementMaxBookingDate() if you need the maximum booking date from the most recent preceding statement. Use getStatementEndingDateV2() if you need the ending date from the most recent preceding statement.', true, 30\6\2020)]
    public TransDate getStatementEndingDate()
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementMaxBookingDate</Name>
				<Source><![CDATA[
    public TransDate getStatementMaxBookingDate()
    {
        TransDate maxBookingDate;

        if (FeatureStateProvider::isFeatureEnabled(BankUserPreferredTimeZoneAlignmentFeature::instance()))
        {
            maxBookingDate = DateTimeUtil::date(
                DateTimeUtil::applyTimeZoneOffset(this.getLastStatement().getMaxBookingDateTime(), DateTimeUtil::getUserPreferredTimeZone()));
        }
        else
        {
            maxBookingDate = DateTimeUtil::date(
                DateTimeUtil::applyTimeZoneOffset(this.getLastStatement().getMaxBookingDateTime(), DateTimeUtil::getCompanyTimeZone()));
        }

        return maxBookingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementEndingDateV2</Name>
				<Source><![CDATA[
    public TransDate getStatementEndingDateV2()
    {
        TransDate endingDate;

        if (FeatureStateProvider::isFeatureEnabled(BankUserPreferredTimeZoneAlignmentFeature::instance()))
        {
            endingDate = DateTimeUtil::date(
                DateTimeUtil::applyTimeZoneOffset(this.getLastStatement().ToDateTime, DateTimeUtil::getUserPreferredTimeZone()));
        }
        else
        {
            endingDate = DateTimeUtil::date(
                DateTimeUtil::applyTimeZoneOffset(this.getLastStatement().ToDateTime, DateTimeUtil::getCompanyTimeZone()));
        }

        return endingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total amount of the bank statement lines.
    /// </summary>
    /// <returns>
    /// The total amount of the bank statement lines.
    /// </returns>
    public AmountCur getStatementTotal()
    {
        if (this.IsReconciled)
        {
            return this.getStatementTotalAfterRecon();
        }
        else
        {
            return this.getStatementTotalBeforeRecon();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementTotalAfterRecon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the statement total amount of a posted reconciliation.
    /// </summary>
    /// <returns>
    /// The statement total amount.
    /// </returns>
    private AmountCur getStatementTotalAfterRecon()
    {
        BankReconciliationHistoryDetails openedItem;
        BankStmtISOReportEntry reportEntry;
        AmountCur totalAmount;
        #macrolib.BankReconciliationConditions

        select sum(Amount) from reportEntry
            #StatementLineInReconciliationHistory(openedItem, reportEntry, this)
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Debit;
        totalAmount += reportEntry.Amount;

        select sum(Amount) from reportEntry
            #StatementLineInReconciliationHistory(openedItem, reportEntry, this)
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Credit;
        totalAmount -= reportEntry.Amount;

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementTotalBeforeRecon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the statement total amount of an unposted reconciliation.
    /// </summary>
    /// <returns>
    /// The statement total amount.
    /// </returns>
    private AmountCur getStatementTotalBeforeRecon()
    {
        BankStmtISOReportEntry reportEntry;
        BankStmtISOAccountStatement statement;
        AmountCur totalAmount;
        BankStmtISODateTime toDateTime = this.getCutOffDateTime();
        #macrolib.BankReconciliationConditions

        select sum(Amount) from reportEntry
            #StatementLineForReconcile(reportEntry, toDateTime, statement, this)
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Debit;
        totalAmount += reportEntry.Amount;

        select sum(Amount) from reportEntry
            #StatementLineForReconcile(reportEntry, toDateTime, statement, this)
                && reportEntry.AmountCreditDebitIndicator == DebitCredit::Credit;
        totalAmount -= reportEntry.Amount;

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementUnreconciledTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the statement reconciled total amount.
    /// </summary>
    /// <returns>
    /// The statement reconciled total amount.
    /// </returns>
    public AmountCur getStatementUnreconciledTotal()
    {
        return this.getStatementTotal() - this.getMatchedStatementTotal() + this.getStatementCancelledTotal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementCancelledTotal</Name>
				<Source><![CDATA[
    private AmountCur getStatementCancelledTotal()
    {
        AmountCur totalAmount;

        if (this.IsReconciled)
        {
            totalAmount += this.getStatementCancelledAmount(DebitCredit::Debit);
            totalAmount += this.getStatementPreCancelledUnreconciledAmount(DebitCredit::Debit);
            totalAmount += this.getStatementPreCancelledReconciledAmount(DebitCredit::Debit);

            totalAmount -= this.getStatementCancelledAmount(DebitCredit::Credit);
            totalAmount -= this.getStatementPreCancelledUnreconciledAmount(DebitCredit::Credit);
            totalAmount -= this.getStatementPreCancelledReconciledAmount(DebitCredit::Credit);
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementCancelledAmount</Name>
				<Source><![CDATA[
    private AmountCur getStatementCancelledAmount(DebitCredit _indicator)
    {
        BankReconciliationMatchingItemView matchingItemViewCancelled;
        BankStmtISOReportEntry reportEntry;
        BankStmtISOAccountStatement statement;

        select sum(Amount) from reportEntry
            where reportEntry.AmountCreditDebitIndicator == _indicator
            exists join statement
                where statement.RecId == reportEntry.BankStmtISOAccountStatement
                    && statement.BankAccountTable == this.AccountId
            exists join matchingItemViewCancelled
                where matchingItemViewCancelled.BankStmtISOReportEntry == reportEntry.RecId
                    && matchingItemViewCancelled.BankReconciliationHeader == this.RecId
                    && matchingItemViewCancelled.Cancelled == NoYes::Yes;

        return reportEntry.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementPreCancelledUnreconciledAmount</Name>
				<Source><![CDATA[
    private AmountCur getStatementPreCancelledUnreconciledAmount(DebitCredit _indicator)
    {
        BankReconciliationMatchingItemView matchingItemViewCancelled;
        BankReconciliationHeader headerCancelled;
        BankStmtISOReportEntry reportEntry;
        BankStmtISOAccountStatement statement;
        BankReconciliationHistoryDetails historyDetails;

        select sum(Amount) from reportEntry
            where reportEntry.Reconciled == NoYes::No
                && reportEntry.AmountCreditDebitIndicator == _indicator
            exists join statement
                where statement.RecId == reportEntry.BankStmtISOAccountStatement
                    && statement.BankAccountTable == this.AccountId
            exists join matchingItemViewCancelled
                where matchingItemViewCancelled.BankStmtISOReportEntry == reportEntry.RecId
                    && matchingItemViewCancelled.Cancelled == NoYes::Yes
            exists join headerCancelled
                where headerCancelled.RecId == matchingItemViewCancelled.BankReconciliationHeader
                    && headerCancelled.CutOffDate <= this.CutOffDate
                    && headerCancelled.RecId < this.RecId
            notexists join historyDetails
                where historyDetails.BankStmtISOReportEntry== reportEntry.RecId
                    && historyDetails.BankReconciliationHeader == this.RecId;

        return reportEntry.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatementPreCancelledReconciledAmount</Name>
				<Source><![CDATA[
    private AmountCur getStatementPreCancelledReconciledAmount(DebitCredit _indicator)
    {
        BankReconciliationMatchingItemView matchingItemViewCancelled;
        BankReconciliationMatchingItemView matchingItemViewReconciled;
        BankReconciliationHeader headerCancelled;
        BankReconciliationHeader headerReconciled;
        BankStmtISOReportEntry reportEntry;
        BankStmtISOAccountStatement statement;
        BankReconciliationHistoryDetails historyDetails;

        select sum(Amount) from reportEntry
            where reportEntry.Reconciled == NoYes::Yes
                && reportEntry.AmountCreditDebitIndicator == _indicator
            exists join statement
                where statement.RecId == reportEntry.BankStmtISOAccountStatement
                    && statement.BankAccountTable == this.AccountId
            exists join matchingItemViewCancelled
                where matchingItemViewCancelled.BankStmtISOReportEntry == reportEntry.RecId
                    && matchingItemViewCancelled.Cancelled == NoYes::Yes
            exists join headerCancelled
                where headerCancelled.RecId == matchingItemViewCancelled.BankReconciliationHeader
                    && headerCancelled.CutOffDate <= this.CutOffDate
                    && headerCancelled.RecId < this.RecId
            exists join matchingItemViewReconciled
                where matchingItemViewReconciled.BankStmtISOReportEntry == reportEntry.RecId
                    && matchingItemViewReconciled.Cancelled == NoYes::No
            exists join headerReconciled
                where headerReconciled.RecId == matchingItemViewReconciled.BankReconciliationHeader
                    && headerReconciled.CutOffDate >= this.CutOffDate
                    && headerReconciled.RecId > this.RecId
                    && headerReconciled.IsReconciled == NoYes::Yes
            notexists join historyDetails
                where historyDetails.BankStmtISOReportEntry== reportEntry.RecId
                    && historyDetails.BankReconciliationHeader == this.RecId;

        return reportEntry.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentCancelledTotal</Name>
				<Source><![CDATA[
    private AmountCur getDocumentCancelledTotal()
    {
        BankReconciliationMatchingItemView matchingItemViewCancelled;
        BankReconciliationMatchingItemView matchingItemViewReconciled;
        BankReconciliationHeader headerCancelled;
        BankReconciliationHeader headerReconciled;
        BankDocumentTable documentTable;
        BankAccountTrans bankTrans;
        BankReconciliationHistoryDetails historyDetails;
        AmountCur totalAmount;

        if (this.IsReconciled)
        {
            select sum(AmountCur) from bankTrans
                where bankTrans.AccountId == this.AccountId
                exists join documentTable
                    where documentTable.SourceRelationType == tableNum(BankAccountTrans)
                        && documentTable.SourceRecId == bankTrans.RecId
                exists join matchingItemViewCancelled
                    where matchingItemViewCancelled.BankDocumentTable == documentTable.RecId
                        && matchingItemViewCancelled.BankReconciliationHeader == this.RecId
                        && matchingItemViewCancelled.Cancelled == NoYes::Yes;
            totalAmount += bankTrans.AmountCur;

            select sum(AmountCur) from bankTrans
                where bankTrans.AccountId == this.AccountId
                exists join documentTable
                    where documentTable.SourceRelationType != tableNum(BankAccountTrans)
                        && documentTable.SourceRecId == bankTrans.SourceRecId
                exists join matchingItemViewCancelled
                    where matchingItemViewCancelled.BankDocumentTable == documentTable.RecId
                        && matchingItemViewCancelled.BankReconciliationHeader == this.RecId
                        && matchingItemViewCancelled.Cancelled == NoYes::Yes;
            totalAmount += bankTrans.AmountCur;

            select sum(AmountCur) from bankTrans
                where bankTrans.AccountId == this.AccountId
                    && bankTrans.Reconciled == NoYes::No
                exists join documentTable
                    where documentTable.SourceRelationType == tableNum(BankAccountTrans)
                        && documentTable.SourceRecId == bankTrans.RecId
                exists join matchingItemViewCancelled
                    where matchingItemViewCancelled.BankDocumentTable == documentTable.RecId
                        && matchingItemViewCancelled.Cancelled == NoYes::Yes
                exists join headerCancelled
                    where headerCancelled.RecId == matchingItemViewCancelled.BankReconciliationHeader
                        && headerCancelled.CutOffDate <= this.CutOffDate
                        && headerCancelled.RecId < this.RecId
                notexists join historyDetails
                    where historyDetails.BankDocumentTable == documentTable.RecId
                        && historyDetails.BankReconciliationHeader == this.RecId;
            totalAmount += bankTrans.AmountCur;

            select sum(AmountCur) from bankTrans
                where bankTrans.AccountId == this.AccountId
                    && bankTrans.Reconciled == NoYes::No
                exists join documentTable
                    where documentTable.SourceRelationType != tableNum(BankAccountTrans)
                        && documentTable.SourceRecId == bankTrans.SourceRecId
                exists join matchingItemViewCancelled
                    where matchingItemViewCancelled.BankDocumentTable == documentTable.RecId
                        && matchingItemViewCancelled.Cancelled == NoYes::Yes
                exists join headerCancelled
                    where headerCancelled.RecId == matchingItemViewCancelled.BankReconciliationHeader
                        && headerCancelled.CutOffDate <= this.CutOffDate
                        && headerCancelled.RecId < this.RecId
                notexists join historyDetails
                    where historyDetails.BankDocumentTable == documentTable.RecId
                        && historyDetails.BankReconciliationHeader == this.RecId;
            totalAmount += bankTrans.AmountCur;

            select sum(AmountCur) from bankTrans
                where bankTrans.AccountId == this.AccountId
                    && bankTrans.Reconciled == NoYes::Yes
                exists join documentTable
                    where documentTable.SourceRelationType == tableNum(BankAccountTrans)
                        && documentTable.SourceRecId == bankTrans.RecId
                exists join matchingItemViewCancelled
                    where matchingItemViewCancelled.BankDocumentTable == documentTable.RecId
                        && matchingItemViewCancelled.Cancelled == NoYes::Yes
                exists join headerCancelled
                    where headerCancelled.RecId == matchingItemViewCancelled.BankReconciliationHeader
                        && headerCancelled.CutOffDate <= this.CutOffDate
                        && headerCancelled.RecId < this.RecId
                exists join matchingItemViewReconciled
                    where matchingItemViewReconciled.BankDocumentTable == documentTable.RecId
                        && matchingItemViewReconciled.Cancelled == NoYes::No
                exists join headerReconciled
                    where headerReconciled.RecId == matchingItemViewReconciled.BankReconciliationHeader
                        && headerReconciled.CutOffDate >= this.CutOffDate
                        && headerReconciled.RecId > this.RecId
                        && headerReconciled.IsReconciled == NoYes::Yes
                notexists join historyDetails
                    where historyDetails.BankDocumentTable == documentTable.RecId
                        && historyDetails.BankReconciliationHeader == this.RecId;
            totalAmount += bankTrans.AmountCur;

            select sum(AmountCur) from bankTrans
                where bankTrans.AccountId == this.AccountId
                    && bankTrans.Reconciled == NoYes::Yes
                exists join documentTable
                    where documentTable.SourceRelationType != tableNum(BankAccountTrans)
                        && documentTable.SourceRecId == bankTrans.SourceRecId
                exists join matchingItemViewCancelled
                    where matchingItemViewCancelled.BankDocumentTable == documentTable.RecId
                        && matchingItemViewCancelled.Cancelled == NoYes::Yes
                exists join headerCancelled
                    where headerCancelled.RecId == matchingItemViewCancelled.BankReconciliationHeader
                        && headerCancelled.CutOffDate <= this.CutOffDate
                        && headerCancelled.RecId < this.RecId
                exists join matchingItemViewReconciled
                    where matchingItemViewReconciled.BankDocumentTable == documentTable.RecId
                        && matchingItemViewReconciled.Cancelled == NoYes::No
                exists join headerReconciled
                    where headerReconciled.RecId == matchingItemViewReconciled.BankReconciliationHeader
                        && headerReconciled.CutOffDate >= this.CutOffDate
                        && headerReconciled.RecId > this.RecId
                        && headerReconciled.IsReconciled == NoYes::Yes
                notexists join historyDetails
                    where historyDetails.BankDocumentTable == documentTable.RecId
                        && historyDetails.BankReconciliationHeader == this.RecId;
            totalAmount += bankTrans.AmountCur;
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>headerBlockLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reconciliation blocking level.
    /// </summary>
    /// <returns>
    /// The blocking level.
    /// </returns>
    public JournalBlockLevel headerBlockLevel()
    {
        if (this.SystemBlocked)
        {
            return JournalBlockLevel::System;
        }

        if (this.SessionId)
        {
            return JournalBlockLevel::InUse;
        }

        return JournalBlockLevel::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();

        this.ReconciliationId = "";
        this.CutOffDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isHeaderBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the reconciliation is blocked.
    /// </summary>
    /// <returns>
    /// true if the reconciliation is being used; otherwise, false .
    /// </returns>
    public boolean isHeaderBlocked()
    {
        return this.headerBlockLevel() != JournalBlockLevel::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLockedInWorkflow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the reconciliation is locked in workflow.
    /// </summary>
    /// <returns>
    /// true if the reconciliation is locked in workflow; otherwise, false.
    /// </returns>
    public boolean isLockedInWorkflow()
    {
        return (this.BankReconciliationApprovalWFStatus == BankReconciliationApprovalWFStatus::InReview)
                || (this.BankReconciliationApprovalWFStatus == BankReconciliationApprovalWFStatus::Approved);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPendingWorkflowApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the workflow is pending approval.
    /// </summary>
    /// <returns>
    /// true if the workflow is pending approval; otherwise, false.
    /// </returns>
    public boolean isPendingWorkflowApproval()
    {
        return (BankReconciliationHeader::isWorkflowActive(this.RecId))
                && (this.BankReconciliationApprovalWFStatus != BankReconciliationApprovalWFStatus::Approved);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReconciled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether it is reconciled.
    /// </summary>
    /// <returns>
    /// true if it is reconciled; otherwise, false.
    /// </returns>
    public boolean isReconciled()
    {
        return this.IsReconciled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the field value.
    /// </summary>
    /// <param name="_fieldName">
    /// The field name.
    /// </param>
    /// <param name="_arrayIndex">
    /// The array index.
    /// </param>
    public void modifiedFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        super(_fieldName, _arrayIndex);

        switch (_fieldName)
        {
            case fieldStr(BankReconciliationHeader, AccountId):
                this.Description = this.dispBankName() + ' ' + this.dispBankAccountNumber();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processNewBankDocumentFromStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes a statement line marked as a new bank document.
    /// </summary>
    /// <param name="_bankStmtISOReportEntryId">
    /// The bank statement line ID.
    /// </param>
    private void processNewBankDocumentFromStatement(RefRecId _bankStmtISOReportEntryId)
    {
        BankDocumentProcessor::submitBankDocumentTable(BankStmtISOReportEntry::find(_bankStmtISOReportEntryId), BankDocumentStatusChangeType::Reconcile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAsReconciled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the reconciliation header to reconciled.
    /// </summary>
    private void updateAsReconciled()
    {
        this.selectForUpdate(true);
        this.IsReconciled = NoYes::Yes;
        this.ReconciledDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        this.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAsUnreconciled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the reconciliation header to unreconciled.
    /// </summary>
    private void updateAsUnreconciled()
    {
        this.selectForUpdate(true);
        this.IsReconciled = NoYes::No;
        this.ReconciledDate = dateNull();
        this.BankReconciliationApprovalWFStatus = BankReconciliationApprovalWFStatus::Draft;
        this.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMatchingItem</Name>
				<Source><![CDATA[
    private void updateMatchingItem(SysInstrumentationProgressLogger _progressLogger, boolean _runInBatch, UserConnection _connection)
    {
        #macrolib.BankReconciliationConditions

        BankReconciliationMatchingItemView matchingItemView;
        select count(BankStmtISOReportEntry) from matchingItemView
            #MatchedItem(matchingItemView, this);

        RecIdCount matchingItems = matchingItemView.BankStmtISOReportEntry;
        ListEnumerator updatePoints;
        RecIdCount updatePoint;

        if (_runInBatch)
        {
            updatePoints = this.calculateUpdatePoints(matchingItems);
            updatePoint = this.getNextUpdatePoint(updatePoints);

            BankReconciliationHeaderReconcileInBatch::initializeProgress(this.RecId, matchingItems, _connection);
        }

        RecIdCount matchedItems;

        SysInstrumentationProgressStage progressStage = _progressLogger.createStage(BankInstrumentationConstants::AdvancedBankReconciliationUpdateMatchedItems, matchingItems);

        using (SysInstrumentationActivityContext activityContext = _progressLogger.activityContextWithProgressMonitor(progressStage))
        {
            ttsbegin;

            if (BankRedesignGenerateVoucherFlight::instance().isEnabled())
            {
                while select BankDocumentTable, BankStmtISOReportEntry, BankReconciliationMatchingType from matchingItemView
                    #MatchedItem(matchingItemView, this)
                {
                    if (matchingItemView.BankDocumentTable && matchingItemView.BankReconciliationMatchingType != BankReconciliationMatchingType::SingleStatement)
                    {
                        BankDocumentTable documentTable = BankDocumentTable::find(matchingItemView.BankDocumentTable);
                        BankDocumentProcessor::submitBankDocument(documentTable, BankDocumentStatusChangeType::Reconcile);
                    }

                    if (matchingItemView.BankStmtISOReportEntry)
                    {
                        BankStmtISOReportEntry::find(matchingItemView.BankStmtISOReportEntry, true).updateReconciledStatus(NoYes::Yes);
                    }
                    matchedItems++;

                    if (_runInBatch && matchedItems == updatePoint)
                    {
                        BankReconciliationHeaderReconcileInBatch::updateProgress(this.RecId, matchedItems, _connection);
                        updatePoint = this.getNextUpdatePoint(updatePoints);
                    }
                    _progressLogger.trackProgress(matchedItems);
                }
            }
            else
            {
                while select BankDocumentTable, BankStmtISOReportEntry from matchingItemView
                    #MatchedItem(matchingItemView, this)
                {
                    if (matchingItemView.BankDocumentTable)
                    {
                        BankDocumentTable documentTable = BankDocumentTable::find(matchingItemView.BankDocumentTable);
                        BankDocumentProcessor::submitBankDocument(documentTable, BankDocumentStatusChangeType::Reconcile);
                    }

                    if (matchingItemView.BankStmtISOReportEntry)
                    {
                        BankStmtISOReportEntry::find(matchingItemView.BankStmtISOReportEntry, true).updateReconciledStatus(NoYes::Yes);
                    }
                    matchedItems++;

                    if (_runInBatch && matchedItems == updatePoint)
                    {
                        BankReconciliationHeaderReconcileInBatch::updateProgress(this.RecId, matchedItems, _connection);
                        updatePoint = this.getNextUpdatePoint(updatePoints);
                    }
                    _progressLogger.trackProgress(matchedItems);
                }
            }

            BankStmtISOAccountStatement statement;
            BankStmtISOReportEntry reportEntry;
            while select statement
                where statement.BankAccountTable == this.AccountId
                    && statement.Status != BankStatementStatus::Open
                    && statement.Status != BankStatementStatus::Reconciled
                    && statement.ToDateTime <= this.getCutOffDateTime()
            notexists join reportEntry
                where reportEntry.BankStmtISOAccountStatement == statement.RecId
            {
                statement.refreshMatchingStatus();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateUpdatePoints</Name>
				<Source><![CDATA[
    private ListEnumerator calculateUpdatePoints(int64 _totalCount)
    {
        const int BlockSizeInPercentage = 10;
        List statusUpdatePoints = new List(Types::Int64);
        int64 step = _totalCount < BlockSizeInPercentage ? 1 : any2Int64(_totalCount / BlockSizeInPercentage);
        for (int64 checkPoint = step; checkPoint <= _totalCount; checkPoint += step)
        {
            statusUpdatePoints.addEnd(checkPoint);
        }
        statusUpdatePoints.addEnd(_totalCount + 1);
        return statusUpdatePoints.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextUpdatePoint</Name>
				<Source><![CDATA[
    private int64 getNextUpdatePoint(ListEnumerator _updatePoints)
    {
        _updatePoints.moveNext();
        return _updatePoints.current();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCutOffDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the cutoff date is valid.
    /// </summary>
    /// <returns>
    /// true if no other reconciliation cutoff date is later than current one; otherwise, false.
    /// </returns>
    private boolean validateCutOffDate()
    {
        if (this.CutOffDate > DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
        {
            warning(strFmt("@CashManagement:BankReconciliationFutureCutOffDate", this.CutOffDate));
        }

        BankReconciliationHeader header;
        boolean ret = true;

        select firstOnly RecId from header
            where header.AccountId == this.AccountId
                && header.CutOffDate > this.CutOffDate
                && header.RecId != this.RecId;

        if (header.RecId)
        {
            ret = checkFailed("@GLS221701");
        }

        if (ret && FeatureStateProvider::isFeatureEnabled(BankModernReconciliationFeature::instance()))
        {
            ret = this.validateBankAutomationCutOffDate();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            if (this.IsReconciled())
            {
                ret = checkFailed(strFmt("@GLS221702", this.ReconciliationId));
            }

            if (ret && this.checkHasMatchingItem())
            {
                ret = checkFailed(strFmt("@GLS221703", this.ReconciliationId));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the field value.
    /// </summary>
    /// <param name="_fieldName">
    /// The field name.
    /// </param>
    /// <param name="_arrayIndex">
    /// The array index.
    /// </param>
    /// <returns>
    /// true if the validation succeed; otherwise, false.
    /// </returns>
    public boolean validateFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        boolean ret;

        ret = super(_fieldName, _arrayIndex);

        switch (_fieldName)
        {
            case fieldStr(BankReconciliationHeader, AccountId):
                ret = BankAccountTable::checkIsAdvancedBankReconEnabled(this.AccountId);
                ret = ret && this.validateOpenReconciliation();
                break;

            case fieldStr(BankReconciliationHeader, CutOffDate):
                ret = this.validateCutOffDate();

                if (ret)
                {
                    if (this.checkHasMatchingItemGreaterThanCutoffDate())
                    {
                        ret = checkFailed(strFmt("@GLS221705", this.CutOffDate, this.orig().CutOffDate));
                    }
                }
                break;

            case fieldStr(BankReconciliationHeader, ReconciliationId):
                ret = this.validateReconciliationId();
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOpenReconciliation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there is an open reconciliation journal for a bank account.
    /// </summary>
    /// <returns>
    /// true if there is no open reconciliation journal for the bank account; otherwise, false.
    /// </returns>
    public boolean validateOpenReconciliation()
    {
        BankReconciliationHeader header;
        boolean ret = true;

        select firstOnly RecId from header
            where header.AccountId      == this.AccountId
                && header.IsReconciled  == NoYes::No
                && header.RecId         != this.RecId;
        if (header.RecId)
        {
            ret = checkFailed("@GLS221706");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            ret = BankAccountTable::checkIsAdvancedBankReconEnabled(this.AccountId);
            ret = ret && this.validateOpenReconciliation();
            ret = ret && this.validateCutOffDate();            
            ret = ret && this.validateReconciliationId();            
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastReconciledJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the most recently reconciled bank reconciliation header of the given bank account.
    /// </summary>
    /// <param name = "_bankAccountId">
    /// The ID of the bank account to find the most recently reconciled bank reconciliation header for.
    /// </param>
    /// <returns>
    /// The most recently reconciled bank reconciliation header.
    ///</returns>
    public static BankReconciliationHeader getLastReconciledJournal(BankAccountId _bankAccountId)
    {
        BankReconciliationHeader header;

        // Because we can have multiple reconciliations in a day, we must order by RecId as well.
        select firstonly header
            order by header.ReconciledDate desc, header.RecId desc
            where header.IsReconciled == NoYes::Yes
                && header.AccountId == _bankAccountId;

        return header;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    static boolean checkExist(BankReconciliationId _reconciliationId)
    {
        if (_reconciliationId && !BankReconciliationHeader::exist(_reconciliationId))
        {
            return checkFailed(strFmt(BankReconciliationHeader::txtNotExist(), _reconciliationId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewReconciliation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new bank reconciliation header for a specified bank account.
    /// </summary>
    /// <param name="_bankAccount">
    /// The specified bank account.
    /// </param>
    /// <returns>
    /// The new bank reconciliation header.
    /// </returns>
    public static BankReconciliationHeader createNewReconciliation(CompanyBankAccountId _bankAccount)
    {
        BankReconciliationHeader header;

        header.initValue();
        header.AccountId = _bankAccount;
        header.ReconciliationId = NumberSeq::newGetNum(BankParameters::numRefBankReconciliationId(), true).num();
        header.Description = header.dispBankName() + ' ' + header.dispBankAccountNumber();

        if (header.validateWrite())
        {
            header.insert();
        }

        return header;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a reconciliation header that has the specified ID exists.
    /// </summary>
    /// <param name="_reconciliationId">
    /// The reconciliation ID.
    /// </param>
    /// <returns>
    /// true if it exists; otherwise, false.
    /// </returns>
    static boolean exist(BankReconciliationId _reconciliationId)
    {
        return _reconciliationId
            && (select firstonly RecId from bankReconciliationHeader
                where bankReconciliationHeader.ReconciliationId == _reconciliationId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>BankReconciliationHeader</c> record for a specified record ID.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the record to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the record can be updated.
    /// </param>
    /// <param name="_concurrencyModel">
    /// A currency model.
    /// </param>
    /// <returns>
    /// A <c>BankReconciliationHeader</c> record .
    /// </returns>
    public static BankReconciliationHeader find(
        RecId _recId,
        boolean _forUpdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankReconciliationHeader header;

        header.selectForUpdate(_forUpdate);

        if (_forUpdate
            && _concurrencyModel != ConcurrencyModel::Auto)
        {
            header.concurrencyModel(_concurrencyModel);
        }

        select firstonly header
            where header.RecId == _recId;

        return header;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByReconciliationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>BankReconciliationHeader</c> record for a specified bank reconciliation ID.
    /// </summary>
    /// <param name="_reconciliationId">
    /// A bank reconciliation ID.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the record can be updated.
    /// </param>
    /// <param name="_concurrencyModel">
    /// A currency model.
    /// </param>
    /// <returns>
    /// A <c>BankReconciliationHeader</c> record .
    /// </returns>
    public static BankReconciliationHeader findByReconciliationId(
        BankReconciliationId _reconciliationId,
        boolean _forUpdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankReconciliationHeader header;

        header.selectForUpdate(_forUpdate);

        if (_forUpdate
            && _concurrencyModel != ConcurrencyModel::Auto)
        {
            header.concurrencyModel(_concurrencyModel);
        }

        select firstonly header
            where header.ReconciliationId == _reconciliationId;

        return header;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPrevReconciliation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the previous reconciliation journal of a specified <c>BankReconciliationHeader</c> record.
    /// </summary>
    /// <param name="_currentReconciliation">
    /// A specified <c>BankReconciliationHeader</c> record.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the record can be updated.
    /// </param>
    /// <returns>
    /// A previous reconciliation journal of the specified <c>BankReconciliationHeader</c> record.
    /// </returns>
    public static BankReconciliationHeader findPrevReconciliation(
        BankReconciliationHeader _currentReconciliation,
        boolean _forUpdate = false)
    {
        BankReconciliationHeader header;

        header.selectForUpdate(_forUpdate);

        select firstOnly header
            order by CutOffDate desc
            where header.AccountId == _currentReconciliation.AccountId
                && header.CutOffDate <= _currentReconciliation.CutOffDate
                && header.CreatedDateTime <= _currentReconciliation.CreatedDateTime
                && header.RecId != _currentReconciliation.RecId;

        return header;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkflowActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the workflow is active for a bank reconciliation journal.
    /// </summary>
    /// <param name="_bankReconciliationHeraderRecId">
    /// The record ID of the <c>BankReconciliationHeader</c> record.
    /// </param>
    /// <returns>
    /// true if the workflow is active for the bank reconciliation journal; otherwise, false.
    /// </returns>
    public static boolean isWorkflowActive(RecId _bankReconciliationHeraderRecId)
    {
        WorkflowVersionTable workflowVersionTable;
        BankReconciliationHeader bankReconciliationHerader;
        boolean isWorkflowActive;

        bankReconciliationHerader = BankReconciliationHeader::find(_bankReconciliationHeraderRecId);

        if (bankReconciliationHerader)
        {
            if (bankReconciliationHerader.BankReconciliationApprovalWFStatus == BankReconciliationApprovalWFStatus::Draft)
            {
                workflowVersionTable = Workflow::findWorkflowConfigToActivateForType(
                    workFlowTypeStr(BankReconciliationApproval),
                    bankReconciliationHerader.RecId,
                    tableNum(BankReconciliationHeader));

                if (workflowVersionTable)
                {
                    // Workflow is activated for the bank reconciliation journal record.
                    isWorkflowActive = true;
                }
            }
            else
            {
                if (SysWorkflowTable::existContextRecId(tableNum(BankReconciliationHeader), _bankReconciliationHeraderRecId))
                {
                    // Workflow is active on the bank reconciliation journal record.
                    isWorkflowActive = true;
                }
            }
        }

        return isWorkflowActive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reconcile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs reconciliation.
    /// </summary>
    /// <param name="_reconciliationRecId">
    /// A reconciliation ID.
    /// </param>
    public static void reconcile(RecId _reconciliationRecId)
    {
        if (BankAdvancedReconciliationLockFlight::instance().isEnabled())
        {
            BankReconciliationHeader header = BankReconciliationHeader::find(_reconciliationRecId);
            if (header.RecId)
            {
                SysInstrumentationProgressLogger progressLogger = SysInstrumentationProgressLogger::createLogger(BankInstrumentationConstants::AdvancedBankReconciliationLock, BankInstrumentationConstants::BankNamespace);
                BankAdvancedReconciliationLock lock = new BankAdvancedReconciliationLock(header.AccountId);
                try
                {
                    using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(BankInstrumentationConstants::AdvancedBankReconciliationEnterLock))
                    {
                        activityContext.addCustomProperty(BankInstrumentationConstants::AdvancedBankReconciliationHeaderRecId, int642Str(_reconciliationRecId));
                        activityContext.addCustomProperty(BankInstrumentationConstants::AdvancedBankReconciliationBankAccountTableRecId, int642Str(BankAccountTable::find(header.AccountId).RecId));
                        lock.enterLock();
                    }

                    if (lock.isLockAcquired())
                    {
                        BankReconciliationHeader::reconcileInner(_reconciliationRecId);
                    }
                }
                finally
                {
                    using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(BankInstrumentationConstants::AdvancedBankReconciliationExitLock))
                    {
                        activityContext.addCustomProperty(BankInstrumentationConstants::AdvancedBankReconciliationHeaderRecId, int642Str(_reconciliationRecId));
                        activityContext.addCustomProperty(BankInstrumentationConstants::AdvancedBankReconciliationBankAccountTableRecId, int642Str(BankAccountTable::find(header.AccountId).RecId));
                        activityContext.addCustomProperty(BankInstrumentationConstants::AdvancedBankReconciliationLockAcquired, strFmt("%1", lock.isLockAcquired()));
                        lock.exitLock();
                    }
                }
            }
        }
        else
        {
            BankReconciliationHeader::reconcileInner(_reconciliationRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reconcileInBatch</Name>
				<Source><![CDATA[
    public static void reconcileInBatch(RecId _reconciliationRecId, UserConnection _connection)
    {
        BankReconciliationHeader::reconcileInner(_reconciliationRecId, true, _connection);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reconcileInner</Name>
				<Source><![CDATA[
    private static void reconcileInner(RecId _reconciliationRecId, boolean _runInBatch = false, UserConnection _connection = null)
    {
        BankReconciliationHeader header = BankReconciliationHeader::find(_reconciliationRecId, true);
        boolean isValid = BankParameters::find().AllowBlankBankStatement || BankReconciliationHeader::validateReconcile(header.RecId, _runInBatch);
        if (isValid && FeatureStateProvider::isFeatureEnabled(BankModernReconciliationFeature::instance()) && header.RecId)
        {
            isValid = header.validateBankAutomationCutOffDate();
        }

        if (header.RecId && isValid)
        {
            SysInstrumentationProgressLogger progressLogger = SysInstrumentationProgressLogger::createLogger(BankInstrumentationConstants::SourceNameAdvancedBankReconciliation, BankInstrumentationConstants::BankNamespace);

            using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(BankInstrumentationConstants::AdvancedBankReconciliationReconcile))
            {
                activityContext.addCustomProperty(BankInstrumentationConstants::AdvancedBankReconciliationHeaderRecId, int642Str(_reconciliationRecId));

                // The reconciliation shall not be pending approval.
                Debug::assert(!header.isPendingWorkflowApproval());

                if (header.isPendingWorkflowApproval())
                {
                    activityContext.addCustomProperty(
                        BankInstrumentationConstants::CustomPropertyWorkflowStatus,
                        enum2Symbol(enumNum(BankReconciliationApprovalWFStatus), header.BankReconciliationApprovalWFStatus));
                }

                ttsbegin;

                using (SysInstrumentationActivityContext historyContext = progressLogger.activityContextForStage(BankInstrumentationConstants::AdvancedBankReconciliationCreateReconciliationHistory))
                {
                    header.createStatementItemInHistoryDetails();
                    header.createDocumentItemInHistoryDetails();
                }

                try
                {
                    header.updateMatchingItem(progressLogger, _runInBatch, _connection);
                }
                finally
                {
                    if (_runInBatch)
                    {
                        _connection.finalize();
                    }
                }

                using (SysInstrumentationActivityContext headerContext = progressLogger.activityContextForStage(BankInstrumentationConstants::AdvancedBankReconciliationUpdateReconciliationHeader))
                {
                    header.updateAsReconciled();
                }

                if (FeatureStateProvider::isFeatureEnabled(BankModernReconciliationFeature::instance()))
                {
                    BankAutomationReconciliationHeaderInformation::insertByReconciliationHeader(header);
                }

                TransactionLog::create(TransactionLogType::BankReconciliation, "@SYS4768");
                ttscommit;

                info(strFmt("@GLS221689", header.ReconciliationId));
            }

            BankReconBridgedAutoClearingTopPickController::schedule(_reconciliationRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unreconcile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs unreconciliation.
    /// </summary>
    /// <param name="_reconciliationRecId">
    /// A reconciliation ID.
    /// </param>
    [Hookable(false)]
    public static void unreconcile(RecId _reconciliationRecId)
    {
        BankReconciliationHeader header = BankReconciliationHeader::find(_reconciliationRecId, true);

        if (header.RecId)
        {
            header.validateUnreconcile();

            SysInstrumentationProgressLogger progressLogger = SysInstrumentationProgressLogger::createLogger(BankInstrumentationConstants::SourceNameAdvancedBankReconciliation, BankInstrumentationConstants::BankNamespace);

            using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(BankInstrumentationConstants::AdvancedBankReconciliationUnreconcile))
            {
                activityContext.addCustomProperty(BankInstrumentationConstants::AdvancedBankReconciliationHeaderRecId, int642Str(_reconciliationRecId));

                ttsbegin;

                using (SysInstrumentationActivityContext historyContext = progressLogger.activityContextForStage(BankInstrumentationConstants::AdvancedBankReconciliationDeleteReconciliationHistory))
                {
                    header.deleteHistoryDetails();
                }

                header.unreconcileMatchingItem(progressLogger);

                header.deleteCancelledMatching();

                using (SysInstrumentationActivityContext headerContext = progressLogger.activityContextForStage(BankInstrumentationConstants::AdvancedBankReconciliationUpdateReconciliationHeader))
                {
                    header.updateAsUnreconciled();
                }

                if (FeatureStateProvider::isFeatureEnabled(BankModernReconciliationFeature::instance()))
                {
                    BankAutomationReconciliationHeaderInformation::deleteByReconciliationHeader(header.RecId);
                }

                TransactionLog::create(TransactionLogType::BankReconciliation, "@SYS22850");

                ttscommit;

                if (header.ReconcileBatchStatus != BankReconciliationHeaderRunInBatchStatus::NotInBatch)
                {
                    header.updateReconcileInBatchStatus(BankReconciliationHeaderRunInBatchStatus::NotInBatch);
                }

                info(strFmt("@CashManagement:BankReconciliationReversed", header.ReconciliationId));
            }

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateUnreconcile</Name>
				<Source><![CDATA[
    private void validateUnreconcile()
    {
        BankStmtISOAccountStatement statement;
        BankStmtISOReportEntry statementLine;
        BankReconciliationMatching matching;
        BankReconciliationMatchingItem matchingItem;

        if (!FeatureStateProvider::isFeatureEnabled(DecoupleBankReconciliationReversalWithBankStmtReversalFeature::instance()))
        {
            select firstonly RecId from statementLine
                where statementLine.IsNewBankDocument == NoYes::Yes
                exists join statement
                    where statement.RecId == statementLine.BankStmtISOAccountStatement
                        && statement.Posted == NoYes::Yes
                exists join matchingItem
                    where matchingItem.BankStmtISOReportEntry == statementLine.RecId
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == this.RecId
                        && matching.Cancelled == NoYes::No;

            if (statementLine.RecId)
            {
                throw error("@CashManagement:BankReconciliationCannotReverseExistingNewTransaction");
            }
        }

        BankReconciliationHeader header;
        select firstonly ReconciliationId, IsReconciled, RecId from header
            order by CreatedDateTime, RecId
            where header.AccountId == this.AccountId
                && header.CutOffDate >= this.CutOffDate
                && (header.CreatedDateTime > this.CreatedDateTime
                    || (header.CreatedDateTime == this.CreatedDateTime
                        && header.RecId > this.RecId));

        if (header.RecId && header.IsReconciled)
        {
            throw warning(strFmt("@CashManagement:ReverseFollowingReconciledBankReconciliation", header.ReconciliationId));
        }
        else if (header.RecId && !header.IsReconciled)
        {
            throw warning(strFmt("@CashManagement:DeleteFollowingUnreconciledBankReconciliation", header.ReconciliationId));
        }

        if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()))
        {
            if (BankBatchProcessingTracking::isBatchJobProcessingLegacy(this, classStr(BankReconBridgedAutoClearing)))
            {
                BankBatchProcessingTracking tracking = BankBatchProcessingTracking::findBySourceLegacy(this.TableId, this.RecId, classStr(BankReconBridgedAutoClearing));
                throw error(strFmt("@Bank:BankReconReverseBridgedTransClearingBatchRunningValidation", tracking.BatchJob));
            }
            else if (BankBatchProcessingTracking::isBatchJobProcessing(this, BankReconciliationOperationType::ClearBridgedTrans))
            {
                BankBatchProcessingTracking tracking = BankBatchProcessingTracking::findBySource(this.TableId, this.RecId, BankReconciliationOperationType::ClearBridgedTrans);
                throw error(strFmt("@Bank:BankReconReverseBridgedTransClearingBatchRunningValidation", tracking.BatchJob));
            }

            if (BankAccountTable::find(this.AccountId).BankReconBridgedAutoClearing && BankReconBridgedAutoClearing::existBridgedTrans(this.RecId))
            {
                throw error(strFmt("@Bank:BankReconReverseUnclearedBridgedTransExistValidation", this.ReconciliationId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteHistoryDetails</Name>
				<Source><![CDATA[
    private void deleteHistoryDetails()
    {
        BankReconciliationHistoryDetails historyDetails;

        delete_from historyDetails
            where historyDetails.BankReconciliationHeader == this.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unreconcileMatchingItem</Name>
				<Source><![CDATA[
    private void unreconcileMatchingItem(SysInstrumentationProgressLogger _progressLogger)
    {
        BankReconciliationMatchingItemView  matchingItemView;

        select count(BankStmtISOReportEntry) from matchingItemView
            where matchingItemView.BankReconciliationHeader == this.RecId
                && matchingItemView.Cancelled == NoYes::No;

        int64 matchingItems = matchingItemView.BankStmtISOReportEntry;
        int64 matchedItems;

        SysInstrumentationProgressStage progressStage = _progressLogger.createStage(BankInstrumentationConstants::AdvancedBankReconciliationUnreconcileMatchedItems, matchingItems);

        using (SysInstrumentationActivityContext activityContext = _progressLogger.activityContextWithProgressMonitor(progressStage))
        {
            if (BankRedesignGenerateVoucherFlight::instance().isEnabled())
            {
                while select BankDocumentTable, BankStmtISOReportEntry, BankReconciliationMatchingType from matchingItemView
                    where matchingItemView.BankReconciliationHeader == this.RecId
                        && matchingItemView.Cancelled == NoYes::No
                {
                    if (matchingItemView.BankDocumentTable && matchingItemView.BankReconciliationMatchingType != BankReconciliationMatchingType::SingleStatement)
                    {
                        BankDocumentTable documentTable = BankDocumentTable::find(matchingItemView.BankDocumentTable);
                        BankDocumentProcessor::submitBankDocument(documentTable, BankDocumentStatusChangeType::ReverseReconcile);
                    }

                    if (matchingItemView.BankStmtISOReportEntry)
                    {
                        BankStmtISOReportEntry::find(matchingItemView.BankStmtISOReportEntry, true).updateReconciledStatus(NoYes::No);
                    }

                    matchedItems++;
                    _progressLogger.trackProgress(matchedItems);
                }
            }
            else
            {
                while select BankDocumentTable, BankStmtISOReportEntry from matchingItemView
                    where matchingItemView.BankReconciliationHeader == this.RecId
                        && matchingItemView.Cancelled == NoYes::No
                {
                    if (matchingItemView.BankDocumentTable)
                    {
                        BankDocumentTable documentTable = BankDocumentTable::find(matchingItemView.BankDocumentTable);
                        BankDocumentProcessor::submitBankDocument(documentTable, BankDocumentStatusChangeType::ReverseReconcile);
                    }

                    if (matchingItemView.BankStmtISOReportEntry)
                    {
                        BankStmtISOReportEntry::find(matchingItemView.BankStmtISOReportEntry, true).updateReconciledStatus(NoYes::No);
                    }

                    matchedItems++;
                    _progressLogger.trackProgress(matchedItems);
                }
            }

            this.unreconcileUpdateZerolineStatementStatus();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unreconcileUpdateZerolineStatementStatus</Name>
				<Source><![CDATA[
    private void unreconcileUpdateZerolineStatementStatus()
    {
        BankReconciliationHeader header;

        select firstonly header
            order by header.ReconciledDate desc, header.RecId desc
            where header.IsReconciled == NoYes::Yes
                && header.AccountId == this.AccountId
                && header.CutOffDate < this.CutOffDate;

        TransDateTime cutOffDateTime = this.getCutOffDateTime();
        TransDateTime lastCutOffDateTime = header.getCutOffDateTime();

        BankStmtISOAccountStatement statement;
        BankStmtISOReportEntry statementLine;

        while select statement
            where statement.BankAccountTable == this.AccountId
                && statement.Status == BankStatementStatus::Reconciled
                && statement.ToDateTime <= cutOffDateTime
                && statement.ToDateTime > lastCutOffDateTime
            notexists join statementLine
                where statementLine.BankStmtISOAccountStatement == statement.RecId
        {
            statement.updateStatus(BankStatementStatus::Validated, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCancelledMatching</Name>
				<Source><![CDATA[
    private void deleteCancelledMatching()
    {
        BankReconciliationMatching matching;
        BankReconciliationMatchingItem matchingItem;

        delete_from matchingItem
            exists join matching
                 where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == this.RecId
                    && matching.Cancelled == NoYes::Yes;

        delete_from matching
            where matching.BankReconciliationHeader == this.RecId
                && matching.Cancelled == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReconciliationBatchStatus</Name>
				<Source><![CDATA[
    internal static void updateReconciliationBatchStatus(RecId _recId, BankReconciliationHeaderRunInBatchStatus _status)
    {
        BankReconciliationHeader::find(_recId, true).updateReconcileInBatchStatus(_status);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReconcileInBatchStatus</Name>
				<Source><![CDATA[
    private void updateReconcileInBatchStatus(BankReconciliationHeaderRunInBatchStatus _status)
    {
        ttsbegin;
        this.ReconcileBatchStatus = _status;
        this.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWorkflowStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a bank reconciliation work flow status.
    /// </summary>
    /// <param name="_bankReconciliationHeaderRecId">
    /// The bank reconciliation record ID.
    /// </param>
    /// <param name="_bankReconciliationApprovalWFStatus">
    /// The work flow status.
    /// </param>
    public static void setWorkflowStatus(
        RecId _bankReconciliationHeaderRecId,
        BankReconciliationApprovalWFStatus _bankReconciliationApprovalWFStatus)
    {
        BankReconciliationHeader bankReconciliationHeader;

        ttsBegin;

        update_recordSet bankReconciliationHeader
            setting
                BankReconciliationApprovalWFStatus = _bankReconciliationApprovalWFStatus
        where
            bankReconciliationHeader.RecId == _bankReconciliationHeaderRecId;

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    static TxtNotExist txtNotExist()
    {
        return "@GLS221691";
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReconciliationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there is a reconciliation journal for current reconcile Id.
    /// </summary>
    /// <returns>
    /// true if there is no open reconciliation journal for current reconcile Id; otherwise, false.
    /// </returns>
    public boolean validateReconciliationId()
    {
        boolean ret = true;

        if (!this.RecId && BankReconciliationHeader::exist(this.ReconciliationId))
        {
            ret = checkFailed(strFmt("@Reconciliation_209264:Reconcile_ExistWarning", this.ReconciliationId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReconcile</Name>
				<Source><![CDATA[
    private static boolean validateReconcile(RecId _headerRecId, boolean _runInBatch)
    {
        BankReconciliationMatching bankReconciliationMatching;

        select firstonly RecId from bankReconciliationMatching
            where bankReconciliationMatching.BankReconciliationHeader == _headerRecId;

        if (bankReconciliationMatching.RecId == 0)
        {
            if (_runInBatch)
            {
                throw error("@CashManagement:BankReconciliationMatchingEntry");
            }

            return checkFailed("@CashManagement:BankReconciliationMatchingEntry");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBankAutomationCutOffDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the bank automation cut-off date.
    /// </summary>
    /// <returns>true if the validation succeed; otherwise, false.</returns>
    internal boolean validateBankAutomationCutOffDate()
    {
        TransDateTime cutOffDateTime = this.getCutOffDateTime();
        BankStmtISOAccountStatement statement;

        // Check if there is no statement after the cut-off date, return true.
        select firstonly RecId from statement
            where statement.BankAccountTable == this.AccountId
                && statement.Status != BankStatementStatus::Open
                && statement.ToDateTime > cutOffDateTime;
        if (!statement.RecId)
        {
            return true;
        }

        // Check if the cut-off date is ending date of any statement, return true.
        select firstonly RecId, ToDateTime from statement
            order by statement.ToDateTime desc
            where statement.BankAccountTable == this.AccountId
                && statement.Status != BankStatementStatus::Open
                && statement.ToDateTime <= cutOffDateTime;
        if (statement.RecId)
        {
            if (statement.getTodate() == this.CutOffDate)
            {
                return true;
            }
        }

        return checkFailed("@Bank:BankAutomationCutOffDateValidationError");
    }

]]></Source>
			</Method>
			<Method>
				<Name>findActiveHeaderByAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the active bank reconciliation header for a specified bank account.
    /// </summary>
    /// <param name = "_bankAccountId">The bank account id.</param>
    /// <returns>The active bank reconciliation header.</returns>
    internal static BankReconciliationHeader findActiveHeaderByAccountId(BankAccountId _bankAccountId)
    {
        BankReconciliationHeader header;

        select firstonly header
            where header.IsReconciled == NoYes::No
                && header.AccountId == _bankAccountId;

        return header;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCutOffDateAfterSpecificDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the cut-off date after a specific date.
    /// </summary>
    /// <param name = "_date">The specific date.</param>
    internal void updateCutOffDateAfterSpecificDate(TransDate _date)
    {
        ttsbegin;
        this.selectForUpdate(true);
        // Move cut-off date to max(_date, next statement date) to pass cut-off date validation.
        this.CutOffDate = max(_date, BankStmtISOAccountStatement::getNextStatementDate(_date, this.AccountId));
        this.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasHeaderInformationSnapshot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays whether the bank reconciliation has stored snapshot of bank header information.
    /// </summary>
    /// <returns>True if the reconciliation has snapshot to display, otherwise false.</returns>
    internal display boolean hasHeaderInformationSnapshot()
    {
        BankAutomationReconciliationHeaderInformation headerInformation = BankAutomationReconciliationHeaderInformation::findByReconciliationHeader(this.RecId);
        return headerInformation.RecId != 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Bank</ConfigurationKey>
	<DeveloperDocumentation>@GLS221708</DeveloperDocumentation>
	<Label>@GLS221707</Label>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>ReconciliationId</TitleField1>
	<TitleField2>AccountId</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Bank</Modules>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReconciliationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CutOffDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsReconciled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReconciledDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Bank</Name>
			<Label>@SYS7439</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>dispBankName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>dispBankAccountNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>dispBankCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Block</Name>
			<Label>@SYS14436</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InUseBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SystemBlocked</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Log</Name>
			<Label>@SYS2515</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Log</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reconciliation</Name>
			<Label>@SYS69067</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReconciliationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CutOffDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsReconciled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReconciledDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Session</Name>
			<Label>@SYS7115</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SessionId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SessionLoginDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Statement</Name>
			<Label>@SYS10066</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>dispLastStatementId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>dispStatementEndingBalance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>dispStatementTotal</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WorkflowStatus</Name>
			<Label>@GLS221959</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankReconciliationApprovalWFStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankReconciliationApprovalWFStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>BankReconciliationApprovalWFStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>CutOffDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankReconciliationCutOffDate</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Description</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Description</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InUseBy</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>UserId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsReconciled</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankReconciliationHeaderReconciled</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Log</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LogText</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReconcileBatchStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<Visible>No</Visible>
			<EnumType>BankReconciliationHeaderRunInBatchStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ReconciledDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankReconciliationReconciledDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReconciliationId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankReconciliationId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>SessionId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JournalSessionId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>SessionLoginDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JournalSessionLoginDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SystemBlocked</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS21780</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>CutOffDateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CutOffDate</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AccountId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>JournalTableMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>JournalId</MapField>
					<MapFieldTo>ReconciliationId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SessionLoginDateTime</MapField>
					<MapFieldTo>SessionLoginDateTime</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PostedDateTime</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TimesheetNbr</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SystemBlocked</MapField>
					<MapFieldTo>SystemBlocked</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Posted</MapField>
					<MapFieldTo>IsReconciled</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VoucherNumberSeq</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JournalNameId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Description</MapField>
					<MapFieldTo>Description</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>BlockUserId</MapField>
					<MapFieldTo>InUseBy</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VoucherDraw</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DetailSummary</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeletePostedLines</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JournalType</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SessionId</MapField>
					<MapFieldTo>SessionId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>NumOfLines</MapField>
					<MapFieldTo>rowNumber</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VoucherChange</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PostedUserId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>BlockUserGroupId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>JournalIdOriginal</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxObligationCompany</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankAccountTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>BankAccountTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>BankAccountTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankReconciliationHeader</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountId</Name>
					<Field>AccountId</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankReconciliationHeader</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>BankReconciliationHeader</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>UserInfo</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UserInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>UserInfo</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankReconciliationHeader</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InUseBy</Name>
					<Field>InUseBy</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankReconciliationBatchStatusTable</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>BankReconciliationBatchStatusTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>HeaderRecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>