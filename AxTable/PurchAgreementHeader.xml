<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchAgreementHeader</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class PurchAgreementHeader extends AgreementHeader
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>agreementValidityPeriodText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a String that is used for explaining the validity period when intercompany is enabled.
    /// </summary>
    /// <returns>
    /// A String that is used for explaining the validity period when intercompany is enabled.
    /// </returns>
    display AgreementValidityPeriod agreementValidityPeriodText()
    {
        return "@SYS334941";
    }

]]></Source>
			</Method>
			<Method>
				<Name>buyingCompanyInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>CompanyInfo</c> record referenced by the buying legal entity.
    /// </summary>
    /// <returns>
    /// The <c>CompanyInfo</c> record.
    /// </returns>
    public CompanyInfo buyingCompanyInfo()
    {
        return CompanyInfo::findRecId(this.BuyingLegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddLinesToAgreement</Name>
				<Source><![CDATA[
    public boolean canAddLinesToAgreement()
    {
        boolean canAddLines;

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            canAddLines = super();

            if (!this.hasChildren())
            {
                canAddLines = true;
            }
            else
            {
                canAddLines = false;
            }

            return canAddLines;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAuthorizeFinancialDimension</Name>
				<Source><![CDATA[
    public boolean canAuthorizeFinancialDimension()
    {
        boolean canAuthorizeFinancialDimension;

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            canAuthorizeFinancialDimension = super();

            canAuthorizeFinancialDimension = canAuthorizeFinancialDimension && VendParameters::find().PurchAgreementFinancialDimension_PSN != 0;

            return canAuthorizeFinancialDimension;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeIntercompanyAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether the purchase agreement can be an intercompany agreement.
    /// </summary>
    /// <returns>
    /// true if the purchase agreement can be an intercompany agreement; otherwise, false.
    /// </returns>
    public boolean canBeIntercompanyAgreement()
    {
        return this.vendTable().interCompanyTradingPartner().RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAgreementUsingActiveIntercompanyPartner</Name>
				<Source><![CDATA[
    public boolean isAgreementUsingActiveIntercompanyPartner()
    {
        return this.canBeIntercompanyAgreement()
            && (!AgreementHeaderInterCompanyValidationFlight::instance().isEnabled() 
            || this.vendTable().interCompanyTradingPartner().interCompanyTradingRelation().Active == NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canChangeContractor</Name>
				<Source><![CDATA[
    public boolean canChangeContractor()
    {
        boolean canChangeContractor;
        PurchAgreementSubcontractor purchAgreementSubcontractor;

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            canChangeContractor = super();

            canChangeContractor = canChangeContractor && !(PurchCommitmentHeader_PSN::existsCommitmentByAgreementAndVendor(this.RecId, this.VendAccount));

            canChangeContractor = canChangeContractor && AgreementClassification::find(this.AgreementClassification).Subcontractor_PSN;

            canChangeContractor = canChangeContractor && (select firstonly RecId from purchAgreementSubcontractor
                                                            where purchAgreementSubcontractor.PurchAgreementHeader == this.RecId).RecId != 0;

            return canChangeContractor;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canConfirmAgreement</Name>
				<Source><![CDATA[
    internal boolean canConfirmAgreement(AgreementState _agreementState = this.AgreementState)
    {
        return super() && !this.isAgreementCLMOwned();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canConfirmAgreement_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether the current <c>PurchAgreementHeader</c> record which is within an active workflow
    ///     can be Confirmed according to Public Sector requirements.
    /// </summary>
    /// <returns>
    ///     true if the current <c>PurchAgreementHeader</c> record can be Confirmed; otherwise, false.
    /// </returns>
    public boolean canConfirmAgreement_PSN()
    {
        return (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    && this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::Approved);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateChildAgreement</Name>
				<Source><![CDATA[
    public boolean canCreateChildAgreement()
    {
        boolean canCreateChild;

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            canCreateChild = super();

            canCreateChild = canCreateChild && AgreementLine::existsByAgreementHeader(this.RecId);

            return canCreateChild;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateIntercompanyAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the purchase agreement can be used for creating intercompany agreements.
    /// </summary>
    /// <returns>
    /// true if the purchase agreement can be used for creating intercompany agreements; otherwise, false.
    /// </returns>
    public boolean canCreateIntercompanyAgreement()
    {
        if (this.isAgreementCLMOwned())
        {
            return false;
        }

        boolean                     ret = true;
        InterCompanyTradingPartner  interCompanyTradingPartner;
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        interCompanyTradingPartner = this.vendTable().interCompanyTradingPartner();

        if (!interCompanyTradingPartner.RecId)
        {
            ret = false;
        }

        if (ret && this.intercompanyEndpointActionPolicyCustomer().UnitPriceEqualsCostPrice)
        {
            ret = false;
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (ret && (this.intercompanyLinkExist() || this.intracompanyLinkExist_RU()))
            {
                ret = false;
            }
        }
        else
        {
        // </GEERU>
            if (ret && this.intercompanyLinkExist())
            {
                ret = false;
            }
        // <GEERU>
        }
        // </GEERU>
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateIntracompanyAgreement_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the sales agreement can be used for creating intracompany agreements.
    /// </summary>
    /// <returns>
    /// true if the sales agreement can be used for creating intracompany agreements; otherwise, false;
    /// </returns>
    public boolean canCreateIntracompanyAgreement_RU()
    {
        boolean ret = !this.isAgreementCLMOwned();

        if (ret && !CustTable::findByPartyRecId(this.vendTable().Party))
        {
            ret = false;
        }

        if (ret && this.intracompanyLinkExist_RU())
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteAgreement_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether the current <c>PurchAgreementHeader</c> record which is within an active workflow
    ///     can be deleted according to Public Sector requirements.
    /// </summary>
    /// <returns>
    ///     true if the current <c>PurchAgreementHeader</c> record can be deleted; otherwise, false.
    /// </returns>
    public boolean canDeleteAgreement_PSN()
    {
        return (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    && (this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::NotSubmitted
                        || this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::Completed
                        || this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::Approved));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditAgreement_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether the current <c>PurchAgreementHeader</c> record which is within an active workflow
    ///     can be edited, according to Public Sector requirements.
    /// </summary>
    /// <returns>
    ///     true if the current <c>PurchAgreementHeader</c> record can be edited; otherwise, false.
    /// </returns>
    public boolean canEditAgreement_PSN()
    {
        return (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    && (this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::NotSubmitted
                        || this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::Approved
                        || this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::Rejected
                        || this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::Returned
                        || this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::ChangeRequested));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReleaseAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the purchase agreement can be released.
    /// </summary>
    /// <param name="_agreementDate">
    /// Valid agreement date.
    /// </param>
    /// <returns>
    /// true if the purchase agreement can be released; otherwise, false.
    /// </returns>
    public boolean canReleaseAgreement(
        TransDate _agreementDate = dateNull()
    )
    {
        boolean ret;

        // <GEERU>
        ret = super(_agreementDate);
        // </GEERU>

        if (ret && this.isAgreementUsingActiveIntercompanyPartner() && !this.intercompanyLinkExist())
        {
            ret = false;
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            if (ret && AgreementClassification::find(this.AgreementClassification).DirectInvoiceEnable_PSN)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSubmitToWorkflow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>PurchAgreementHeader</c> table buffer record can be submitted to workflow.
    /// </summary>
    /// <param name="_workflowType">
    /// The workflow type.
    /// </param>
    /// <returns>
    /// true if at least one purchase agreement line is found and the value of the
    /// <c>WorkflowStatus_PSN</c> field in the <c>PurchAgreementHeader</c> table is equal to the
    /// <c>PurchAgreementWorkflowStatus::NotSubmitted</c> enumeration value; otherwise, false.
    /// </returns>
    public boolean canSubmitToWorkflow(str _workflowType = '')
    {
        if (this.isAgreementCLMOwned())
        {
            return false;
        }

        boolean         ret;
        AgreementLine   agreementLine;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            select firstonly Agreement, RecId from agreementLine
                where agreementLine.Agreement == this.RecId;

            if (agreementLine.RecId)
            {
                if (!this.WorkflowStatus_PSN)
                {
                    PurchAgreementHeader::setWorkflowStatus(this.RecId, PurchAgreementWorkflowStatus::NotSubmitted);
                    this.reread();
                }

                ret = true;
            }

            return ret && this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::NotSubmitted;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventOwner_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether it is possible to change agreement document title in case of related inventory owner.
    /// </summary>
    /// <returns>
    ///     true if there is no inventory owner or user accepts document title changing; otherwise, false.
    /// </returns>
    public boolean checkInventOwner_RU()
    {
        PurchAgreementHeader this_orig;
        InventOwner_RU inventOwner;
        boolean ret = true;

        if (appl.ttsLevel() == 0)
        {
            this_orig = this.orig();

            if (this.DocumentTitle != this_orig.DocumentTitle &&
                FormDataUtil::isFormDataSource(this) &&
                PurchParameters::find().InventOwnerIdInitMode_RU == InventOwnerIdInitMode_RU::AccountNumAgreement)
            {
                inventOwner = InventOwner_RU::findAccountNum(InventOwnerAccountType_RU::Vend,
                                                             this.VendAccount,
                                                             PurchAgreementHeaderExt_RU::findByPurchAgreementHeader(this.RecId).RecId);
                if (inventOwner)
                {
                    ret = Box::okCancel(strFmt("@GLS115640", inventOwner.InventOwnerId, fieldId2pname(tableNum(InventDim), fieldNum(InventDim, InventOwnerId_RU))),
                                        DialogButton::Ok) == DialogButton::Ok;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAgreementReleaseHeaderMatch</Name>
				<Source><![CDATA[
    public AgreementReleaseHeaderMatch createAgreementReleaseHeaderMatch(Common _releaseOrderHeader)
    {
        PurchTable                  purchHeader;
        AgreementReleaseHeaderMatch ret;
        if (!(_releaseOrderHeader is PurchTable))
        {
            // Wrong argument type
            throw error("@SYS111577");
        }
        purchHeader = _releaseOrderHeader as PurchTable;

        // Init values and insert
        ret.initFromAgreementHeader(this);
        ret.initFromPurchTable(purchHeader);
        ret.insert();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLegalEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the buying legal entity <c>CompanyInfo</c> instance.
    /// </summary>
    /// <returns>
    /// A <c>CompanyInfo</c> instance related to the buying legal entity.
    /// </returns>
    public CompanyInfo getLegalEntity()
    {
        return this.buyingCompanyInfo();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasActiveWorkFlow</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether the current <c>PurchAgreementHeader</c> record has an active workflow.
    /// </summary>
    /// <returns>
    ///     true if the current <c>PurchAgreementHeader</c> record is within an active workflow; otherwise, false.
    /// </returns>
    public boolean hasActiveWorkFlow()
    {
        return isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && this.WorkflowStatus_PSN
            && PurchAgreementHeader::activeWorkflowTemplateExists();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeWorkflowTemplateExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an active workflow template for purchase agreements exists.
    /// </summary>
    /// <returns>true, if an active workflow template for purchase agreements exists; otherwise, false.</returns>
    public static boolean activeWorkflowTemplateExists()
    {
        return WorkflowTable::findActiveTemplate(workFlowTypeStr(PurchAgreementType)).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasChildren</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the purchase agreement record has children.
    /// </summary>
    /// <returns>
    /// true if child records exist; otherwise, false.
    /// </returns>
    public boolean hasChildren()
    {
        PurchAgreementHeader purchAgreementHeader;

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            select firstonly RecId from purchAgreementHeader
                where purchAgreementHeader.ParentPurchAgreementID_PSN == this.RecId;

            return purchAgreementHeader.RecId != 0;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>image</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resource ID of the image to use in the purchase agreement a parent child hierarchy.
    /// </summary>
    /// <returns>
    /// An Integer value that indicates the image resource ID.
    /// </returns>
    public ImageRes image()
    {
        #resAppl

        int retval;

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            retval = #ImageProjTimeMaterial;
        }

        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromVendTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>PurchAgreementHeader</c> and <c>AgreementHeader</c> records from the
    ///    <c>VendTable</c> table to default values.
    /// </summary>
    /// <param name="_vendTable">
    ///    The vendor record from which to initialize; optional.
    /// </param>
    public void  initFromVendTable(VendTable _vendTable = this.vendTable())
    {
        this.VendAccount      = _vendTable.AccountNum;
        this.VendorDataAreaId = appl.company().dataArea(tableNum(VendTable));
        this.Language         = _vendTable.languageId();
        
        this.initFromCustVendTable(_vendTable);
        if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
        {
            this.ShipCalendarId = _vendTable.PurchaseShipCalendarId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>PurchAgreementHeader</c> record to default values.
    /// </summary>
    /// <remarks>
    ///    For more information, see the <see cref="PurchAgreementHeader Table" />.
    /// </remarks>
    public void initValue()
    {
        super();

        this.BuyingLegalEntity = CompanyInfo::current();
        this.VendorDataAreaId  = appl.company().dataArea(tableNum(VendTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyEndpointActionPolicyCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>IntercompanyEndpointActionPolicy</c> record for the customer in a trading relation to
    /// a vendor for an agreement.
    /// </summary>
    /// <returns>
    /// An <c>IntercompanyEndpointActionPolicy</c> record.
    /// </returns>
    public InterCompanyEndpointActionPolicy intercompanyEndpointActionPolicyCustomer()
    {
        InterCompanyTradingPartner          intercompanyTradingPartnerCustomer;
        InterCompanyTradingRelation         interCompanyTradingRelation = this.vendTable().interCompanyTradingPartner().interCompanyTradingRelation();
        InterCompanyEndpointActionPolicy    intercompanyEndpointActionPolicyCustomer;

        if (interCompanyTradingRelation)
        {
            intercompanyTradingPartnerCustomer = InterCompanyTradingPartner::find(interCompanyTradingRelation.InterCompanyTradingCustomer);

            intercompanyEndpointActionPolicyCustomer = InterCompanyEndpointActionPolicy::findPartner(intercompanyTradingPartnerCustomer.RecId);
        }

        return intercompanyEndpointActionPolicyCustomer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanySync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes changed data to the intercompany sales agreement header record that relates to the
    /// purchase agreement header record.
    /// </summary>
    /// <param name="_forceIntercompanySync">
    /// A Boolean value that indicates whether to force the intercompany synchronization; optional.
    /// </param>
    public void intercompanySync(boolean _forceIntercompanySync = false)
    {
        InterCompanyTradingValueMap         fromInterCompanyTradingValueMap;
        InterCompanyTradingValueMap         toInterCompanyTradingValueMap;
        InterCompanyTradingPartner          interCompanyTradingPartner;
        SalesAgreementHeader                salesAgreementHeader;
        CustTable                           custTable;
        VendTable                           vendTable;
        InterCompanyCompanyId               vendTableInterCompanyTradingPartnerCompanyId;

        TradeInterCompanyConv               convAgreementClassification;
        AgreementClassification             agreementClassification, salesAgreementClassification;
        boolean                             create;
        Name                                salesClassificationName;
        // <GEERU>
        #ISOCountryRegionCodes
        boolean                             toCountryRegion_RU, fromCountryRegion_RU;
        AgreementClassificationExt_RU       agreementClassificationExt;
        PurchAgreementHeaderExt_RU          purchAgreementHeaderExt;
        SalesAgreementHeaderExt_RU          salesAgreementHeaderExt;
        // </GEERU>

        if (!_forceIntercompanySync)
        {
            if (this.InterCompanySkipUpdate == InterCompanySkipUpdate::InterCompany
             || this.InterCompanySkipUpdate == InterCompanySkipUpdate::Both
             || !this.intercompanyUpdateNow())
            {
                return;
            }
        }

        vendTable = this.vendTable();
        vendTableInterCompanyTradingPartnerCompanyId = vendTable.interCompanyTradingPartnerCompanyID();
        if (!TradeInterCompany::checkDataAreaAccess(vendTableInterCompanyTradingPartnerCompanyId))
        {
            return;
        }

        fromInterCompanyTradingValueMap = vendTable.interCompanyTradingPartner().interCompanyTradingValueMap();

        if (this.AgreementClassification)
        {
            select firstonly Name from agreementClassification
                where agreementClassification.RecId == this.AgreementClassification;

            convAgreementClassification = TradeInterCompanyConv::construct();
            convAgreementClassification.axPurchAgreementClassification(fromInterCompanyTradingValueMap, agreementClassification.Name);
        }

        create = !this.intercompanyLinkExist();

        changecompany(vendTableInterCompanyTradingPartnerCompanyId)
        {
            // <GEERU>
            toCountryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
            // </GEERU>

            setPrefix(strFmt("@SYS93821",TradeInterCompany::curCompanyName()));

            custTable                     = CustTable::find(vendTable.interCompanyTradingPartnerAccount());
            interCompanyTradingPartner    = custTable.interCompanyTradingPartner();
            toInterCompanyTradingValueMap = interCompanyTradingPartner.interCompanyTradingValueMap();

            if (!create)
            {
                salesAgreementHeader = this.salesAgreementHeader(true);
            }
            if (create)
            {
                salesAgreementHeader.CustAccount        = vendTable.interCompanyTradingPartnerAccount();
                salesAgreementHeader.CustomerDataAreaId = getCompany(tableNum(CustTable), vendTableInterCompanyTradingPartnerCompanyID);
                salesAgreementHeader.SellingLegalEntity = CompanyInfo::current();
            }
            if (create || this.fieldChanged(fieldNum(PurchAgreementHeader,AgreementState)))
            {
                salesAgreementHeader.AgreementState = this.AgreementState;
            }
            if (create || this.fieldChanged(fieldNum(PurchAgreementHeader,AgreementClassification)))
            {
                if (this.AgreementClassification)
                {
                    salesClassificationName = convAgreementClassification.axSalesAgreementClassification(toInterCompanyTradingValueMap);

                    if (!salesClassificationName)
                    {
                        this.intercompanyErrorAgreementClassification(
                            this.buyingCompanyInfo().DataArea,
                            fromInterCompanyTradingValueMap.AgreementClassificationExtCodeId,
                            toInterCompanyTradingValueMap.AgreementClassificationExtCodeId);
                    }
                    salesAgreementClassification = AgreementClassification::findSalesClassification(salesClassificationName);
                    salesAgreementHeader.AgreementClassification = salesAgreementClassification.RecId;
                }
            }

            if (create || this.fieldChanged(fieldNum(PurchAgreementHeader,DocumentTitle)))
            {
                salesAgreementHeader.DocumentTitle = this.DocumentTitle;
            }
            if (create || this.fieldChanged(fieldNum(PurchAgreementHeader,DocumentExternalReference)))
            {
                salesAgreementHeader.DocumentExternalReference = this.DocumentExternalReference;
            }
            if (create || this.fieldChanged(fieldNum(PurchAgreementHeader,Currency)))
            {
                salesAgreementHeader.Currency = this.Currency;
            }

            if (create)
            {
                salesAgreementHeader.DefaultAgreementLineType = CommitmentType::ProductQuantity;
                // <GEERU>
                if (toCountryRegion_RU)
                {
                    if (salesAgreementClassification)
                    {
                        agreementClassificationExt = AgreementClassificationExt_RU::findByAgreementClassification(salesAgreementClassification.RecId);
                    }

                    if (agreementClassificationExt.NumberSequenceTable)
                    {
                        salesAgreementHeader.SalesNumberSequence = NumberSeq::newGetNumFromId(agreementClassificationExt.NumberSequenceTable).num();
                    }
                    else
                    {
                        salesAgreementHeader.SalesNumberSequence = NumberSeq::newGetNum(SalesParameters::numRefSalesAgreementId()).num();
                    }
                }
                else
                {
                // </GEERU>
                    salesAgreementHeader.SalesNumberSequence = NumberSeq::newGetNum(SalesParameters::numRefSalesAgreementId()).num();
                // <GEERU>
                }
                // </GEERU>
            }
            if (create || this.fieldChanged(fieldNum(PurchAgreementHeader,DefaultAgreementLineEffectiveDate)))
            {
                salesAgreementHeader.DefaultAgreementLineEffectiveDate = this.DefaultAgreementLineEffectiveDate;
            }
            if (create || this.fieldChanged(fieldNum(PurchAgreementHeader,DefaultAgreementLineExpirationDate)))
            {
                salesAgreementHeader.DefaultAgreementLineExpirationDate = this.DefaultAgreementLineExpirationDate;
            }
            if (create || this.fieldChanged(fieldNum(PurchAgreementHeader,Language)))
            {
                salesAgreementHeader.Language = this.Language;
            }
            // <GEERU>
            if (toCountryRegion_RU)
            {
                this.syncField(salesAgreementHeader, create, fieldNum(PurchAgreementHeader, DefaultDimension));
            }
            // </GEERU>

            salesAgreementHeader.InterCompanySkipUpdate = InterCompanySkipUpdate::InterCompany;

            if (create)
            {
                salesAgreementHeader.insert();
                AgreementReference::createRelationShip(this.RecId, salesAgreementHeader.RecId);
                TradeInterCompany::synchronizeDocuRef(this);
            }
            else
            {
                salesAgreementHeader.update();
            }
        }
        // <GEERU>
        if (toCountryRegion_RU)
        {
            fromCountryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

            if (fromCountryRegion_RU)
            {
                purchAgreementHeaderExt = PurchAgreementHeaderExt_RU::findByPurchAgreementHeader(this.RecId);
                if (purchAgreementHeaderExt)
                {
                    purchAgreementHeaderExt.intercompanySync(_forceIntercompanySync);
                }
            }
            else
            {
                if (create)
                {
                    changecompany(vendTableInterCompanyTradingPartnerCompanyId)
                    {
                        salesAgreementHeaderExt.initValue();
                        salesAgreementHeaderExt.initFromAgreementHeader(salesAgreementHeader);
                        salesAgreementHeaderExt.InterCompanySkipUpdate = InterCompanySkipUpdate::InterCompany;
                        salesAgreementHeaderExt.insert();
                    }
                }
            }
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>intracompanySync_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Synchronizes changed data to the intracompany sales agreement header record that relates to the
    ///     purchase agreement header record.
    /// </summary>
    /// <param name="_forceIntracompanySync">
    ///     A Boolean value that indicates whether to force the intracompany synchronization; optional.
    /// </param>
    public void intracompanySync_RU(boolean _forceIntracompanySync = false)
    {
        SalesAgreementHeader    salesAgreementHeader;
        CustTable               custTable;
        VendTable               vendTable;
        AgreementClassification agreementClassification, salesAgreementClassification;
        AgreementClassificationExt_RU agreementClassificationExt;
        boolean                 create;

        if (!_forceIntracompanySync)
        {
            if (this.InterCompanySkipUpdate == InterCompanySkipUpdate::Internal
             || !this.intercompanyUpdateNow())
            {
                return;
            }
        }

        vendTable = this.vendTable();
        custTable = CustTable::findByPartyRecId(vendTable.Party);
        create    = !this.intracompanyLinkExist_RU();

        if (create)
        {
            agreementClassification    = AgreementClassification::find(this.AgreementClassification);
            agreementClassificationExt = AgreementClassificationExt_RU::findByAgreementClassification(this.AgreementClassification);

            if (agreementClassificationExt)
            {
                salesAgreementClassification = AgreementClassification::find(agreementClassificationExt.RelatedAgreementClassification);
            }

            if (salesAgreementClassification)
            {
                agreementClassificationExt = AgreementClassificationExt_RU::findByAgreementClassification(salesAgreementClassification.RecId);

                if (agreementClassificationExt.NumberSequenceTable)
                {
                    salesAgreementHeader.SalesNumberSequence = NumberSeq::newGetNumFromId(agreementClassificationExt.NumberSequenceTable).num();
                }
                else
                {
                    salesAgreementHeader.SalesNumberSequence = NumberSeq::newGetNum(PurchParameters::numRefPurchAgreementId()).num();
                }
            }
            else
            {
                throw error(strFmt("@GLS115642", agreementClassification.Name));
            }

            salesAgreementHeader.AgreementClassification  = salesAgreementClassification.RecId;
            salesAgreementHeader.DocumentTitle            = this.DocumentTitle;
            salesAgreementHeader.DefaultAgreementLineType = CommitmentType::ProductQuantity;
            salesAgreementHeader.CustAccount              = custTable.AccountNum;
            salesAgreementHeader.CustomerDataAreaId       = custTable.DataAreaId;
            salesAgreementHeader.SellingLegalEntity       = CompanyInfo::current();
        }
        else
        {
            salesAgreementHeader = this.salesAgreementHeader_RU(true);
        }

        this.syncField(salesAgreementHeader, create, fieldNum(PurchAgreementHeader, DocumentTitle));
        this.syncField(salesAgreementHeader, create, fieldNum(PurchAgreementHeader, AgreementState));
        this.syncField(salesAgreementHeader, create, fieldNum(PurchAgreementHeader, DocumentExternalReference));
        this.syncField(salesAgreementHeader, create, fieldNum(PurchAgreementHeader, Currency));
        this.syncField(salesAgreementHeader, create, fieldNum(PurchAgreementHeader, DefaultAgreementLineEffectiveDate));
        this.syncField(salesAgreementHeader, create, fieldNum(PurchAgreementHeader, DefaultAgreementLineExpirationDate));
        this.syncField(salesAgreementHeader, create, fieldNum(PurchAgreementHeader, Language));
        this.syncField(salesAgreementHeader, create, fieldNum(PurchAgreementHeader, DefaultDimension));

        salesAgreementHeader.InterCompanySkipUpdate = InterCompanySkipUpdate::Internal;

        if (create)
        {
            salesAgreementHeader.insert();
            AgreementReference::createRelationShip(this.RecId, salesAgreementHeader.RecId, true);
        }
        else
        {
            salesAgreementHeader.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether invoice journal records exist for the agreement.
    /// </summary>
    /// <returns>
    /// true if the invoice journal records exist; otherwise, false.
    /// </returns>
    public boolean invoiceExists()
    {
        AgreementReleaseHeaderMatch agreementReleaseHeaderMatch;
        boolean                     ret = false;
        AgreementLineReleasedLine   agreementLineReleasedLine;
        AgreementLine               agreementLine;
        VendInvoiceTrans            vendInvoiceTrans;

        if (this.RecId)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && this.AgreementClassification
                && (AgreementClassification::find(this.AgreementClassification).DirectInvoiceEnable_PSN == NoYes::Yes))
            {
                select firstonly RecId from agreementLineReleasedLine
                    where agreementLineReleasedLine.ReferenceRelationType == tableNum(VendInvoiceTrans)
                        && !agreementLineReleasedLine.IsDeleted
                    exists join vendInvoiceTrans
                        where vendInvoiceTrans.RecId == agreementLineReleasedLine.VendInvoiceTrans
                    exists join agreementLine
                        where agreementLine.RecId == agreementLineReleasedLine.AgreementLine
                            && agreementLine.Agreement == this.RecId;

                ret = agreementLineReleasedLine.RecId ? true : false;
            }
            else
            {
                select firstonly RecId from agreementReleaseHeaderMatch
                    where agreementReleaseHeaderMatch.MatchingReleaseOrderAgreement == this.RecId
                    exists join vendInvoiceTrans
                        where vendInvoiceTrans.OrigPurchId == agreementReleaseHeaderMatch.PurchTablePurchId;

                ret = agreementReleaseHeaderMatch.RecId ? true : false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtension</Name>
				<Source><![CDATA[
    public TableExtension getExtension()
    {
        return new SysTableExtension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultingDependencies</Name>
				<Source><![CDATA[
    public container getDefaultingDependencies()
    {
        return [
            // [field that needs defaulting,
                //  [fields that the default values depends on]]

            [fieldNum(PurchAgreementHeader, DefaultAgreementLineType),
                [fieldNum(PurchAgreementHeader, VendorDataAreaId), fieldNum(PurchAgreementHeader, VendAccount)]],

            [fieldNum(PurchAgreementHeader, VendorDataAreaId),
                [fieldNum(PurchAgreementHeader, VendAccount)]]
        ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    public void defaultField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(PurchAgreementHeader, VendorDataAreaId):
                this.VendorDataAreaId = this.VendAccount && !this.VendorDataAreaId ? curExt() : this.VendorDataAreaId;
                break;

            case fieldNum(PurchAgreementHeader, DefaultAgreementLineType):
                if (this.isFieldSet(fieldNum(PurchAgreementHeader, VendAccount)))
                {
                    // this is a workaround for the bug in the defaulting sequence
                    if (!this.VendorDataAreaId)
                    {
                        this.defaultField(fieldNum(PurchAgreementHeader, VendorDataAreaId));
                    }

                    if (this.isAgreementUsingActiveIntercompanyPartner())
                    {
                        this.DefaultAgreementLineType = CommitmentType::ProductQuantity;
                    }
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the purchase agreement can be deleted.
    /// </summary>
    /// <returns>
    /// true if the purchase agreement can be deleted; otherwise, false.
    /// </returns>
    public boolean canDeleteAgreement()
    {
        boolean canDelete = !this.isAgreementCLMOwned() && super();

        return canDelete && !this.isPurchaseAgreementLinkedToVendorInvoice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAgreementCLMOwned</Name>
				<Source><![CDATA[
    internal boolean isAgreementCLMOwned()
    {
        return this.CLMIntegrationPurchAgreementOwnership == CLMIntegrationPurchaseAgreementOwnershipType::CLM
            && CLMIntegrationFeature::isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchaseAgreementLinkedToVendorInvoice</Name>
				<Source><![CDATA[
    private boolean isPurchaseAgreementLinkedToVendorInvoice()
    {
        return (select firstonly RecId from vendInvoiceInfoTable
            where vendInvoiceInfoTable.PurchAgreementHeader_PSN == this.RecId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the type, purchase or sales, of the agreement.
    /// </summary>
    /// <returns>
    ///    The type of agreement.
    /// </returns>
    /// <remarks>
    ///    The <c>PurchAgreementHeader</c> subtype always returns the <c>Purch</c> enumeration value.
    /// </remarks>
    ModuleSalesPurch moduleType()
    {
        return ModuleSalesPurch::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>originatorName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrives the name of the originator for the current agreement header.
    /// </summary>
    /// <returns>
    ///    A string that contains the name of the originator.
    /// </returns>
    display DirPartyName originatorName()
    {
        // Just calling super() since BP Check cannot find display method on super type
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchAgreementHeaderDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the purchase agreement header default record that is attached to the current purchase
    ///    agreement header record.
    /// </summary>
    /// <param name="_forupdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A table buffer that contains the purchase agreement header default record.
    /// </returns>
    public PurchAgreementHeaderDefault purchAgreementHeaderDefault(boolean  _forupdate = false)
    {
        PurchAgreementHeaderDefault purchAgreementHeaderDefault;

        if (this.RecId)
        {
            purchAgreementHeaderDefault.selectForUpdate(_forupdate);

            select firstonly purchAgreementHeaderDefault
                where purchAgreementHeaderDefault.PurchaseAgreementHeader == this.RecId;
        }

        return purchAgreementHeaderDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAgreementReleaseHeaderMatch</Name>
				<Source><![CDATA[
    public void removeAgreementReleaseHeaderMatch(Common _releaseOrderHeader)
    {
        PurchTable                  purchHeader;
        AgreementReleaseHeaderMatch agreementReleaseHeaderMatch;

        if (!(_releaseOrderHeader is PurchTable))
        {
            // Wrong argument type
            throw error("@SYS111577");
        }
        purchHeader = _releaseOrderHeader as PurchTable;

        delete_from agreementReleaseHeaderMatch
        where agreementReleaseHeaderMatch.PurchTablePurchId == purchHeader.PurchId
            && agreementReleaseHeaderMatch.PurchTableDataAreaId == purchHeader.DataAreaId
            && agreementReleaseHeaderMatch.ReferenceRelationType == purchHeader.TableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesAgreementHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the intercompany sales agreement header record that is related to the purchase agreement header record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the <c>SalesAgreementHeader</c> record for update; optional.
    /// </param>
    /// <returns>
    ///    A table buffer that contains the intercompany sales agreement header.
    /// </returns>
    public SalesAgreementHeader salesAgreementHeader(boolean _forUpdate = false)
    {
        AgreementReference      agreementReference;
        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        select firstonly DerivedAgreement from agreementReference
            where agreementReference.SourceAgreement == this.RecId
                // <GEERU>
                && (!countryRegion_RU || !agreementReference.IsIntraCompany_RU)
                // </GEERU>
            ;
        if (agreementReference.DerivedAgreement)
        {
            return SalesAgreementHeader::find(agreementReference.DerivedAgreement,_forUpdate);
        }

        select firstonly SourceAgreement from agreementReference
            where agreementReference.DerivedAgreement == this.RecId
                // <GEERU>
                && (!countryRegion_RU || !agreementReference.IsIntraCompany_RU)
                // </GEERU>
            ;

        return SalesAgreementHeader::find(agreementReference.SourceAgreement,_forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesAgreementHeader_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the intracompany sales agreement header record that is related to the purchase agreement header record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the <c>SalesAgreementHeader</c> record for update; optional.
    /// </param>
    /// <returns>
    ///    A table buffer that contains the intracompany sales agreement header.
    /// </returns>
    public SalesAgreementHeader salesAgreementHeader_RU(boolean _forUpdate = false)
    {
        AgreementReference agreementReference;

        select firstonly DerivedAgreement from agreementReference
            where agreementReference.SourceAgreement   == this.RecId
               && agreementReference.IsIntraCompany_RU == true;

        if (agreementReference.DerivedAgreement)
        {
            return SalesAgreementHeader::find(agreementReference.DerivedAgreement,_forUpdate);
        }

        select firstonly SourceAgreement from agreementReference
            where agreementReference.DerivedAgreement  == this.RecId
               && agreementReference.IsIntraCompany_RU == true;

        return SalesAgreementHeader::find(agreementReference.SourceAgreement,_forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCheckFailedTextAgreementState</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the check failed text for the agreement state field for the purchase agreement.
    /// </summary>
    public void setCheckFailedTextAgreementState()
    {
        checkFailed("@SYS334945");
    }

]]></Source>
			</Method>
			<Method>
				<Name>showDocHandIcon</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the document handling icon for the current purchase agreement header record.
    /// </summary>
    /// <returns>
    ///    The icon number of the document handling icon for the purchase agreement header record.
    /// </returns>
    display smmDocIconNum showDocHandIcon()
    {
        #Macrolib.Resource
        boolean     exist;

        if (this.RecId)
        {
            exist = DocuRef::exist(this.VendorDataAreaId, this.TableId, this.RecId);
        }

        return exist? #RES_NODE_DOC : #RES_AM_NEW;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        if (this.needCheckCLMIntegrationFields())
        {
            FieldId modifiedField = CLMIntegrationPurchAgreementDataProvider::getCLMIntegrationPurchAgreementHeaderModifiedField(this);

            if (modifiedField)
            {
                throw error(strFmt("@CLMIntegration:ErrorWhenCLMIntegrationFieldModifiedOnPurchAgreement", fieldId2Name(tableNum(PurchAgreementHeader), modifiedField)));
            }
        }

        // <GEERU>
        #ISOCountryRegionCodes
        AmountMST openBalance;
        AgreementHeader origAgreementHeader;
        PurchAgreementHeaderExt_RU purchAgreementHeaderExt, origPurchAgreementHeaderExt;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            origAgreementHeader = this;
            origAgreementHeader = origAgreementHeader.orig();

            if (this.AgreementState == AgreementState::OnHold
            &&  this.AgreementState != origAgreementHeader.AgreementState)
            {
                ttsbegin;
                purchAgreementHeaderExt = PurchAgreementHeaderExt_RU::findByPurchAgreementHeader(this.RecId, true);
                if (purchAgreementHeaderExt.RecId)
                {
                    origPurchAgreementHeaderExt.data(purchAgreementHeaderExt);
                    openBalance                       = -VendTable::find(this.VendAccount).openBalanceMSTPerAgreement_RU(purchAgreementHeaderExt.AgreementId);
                    purchAgreementHeaderExt.CreditMax = openBalance > 0 ? openBalance : 0;
                    purchAgreementHeaderExt.update();
                }
                ttscommit;
                if (origPurchAgreementHeaderExt.CreditMax != purchAgreementHeaderExt.CreditMax)
                {
                    info(strFmt("@GLS112519", origPurchAgreementHeaderExt.CreditMax, purchAgreementHeaderExt.CreditMax));
                }
            }

            if (this.InterCompanySkipUpdate != InterCompanySkipUpdate::Internal
            &&  this.intracompanyLinkExist_RU())
            {
                ttsbegin;
                this.intracompanySync_RU();
                ttscommit;
            }
        }
        // </GEERU>

        if (this.InterCompanySkipUpdate != InterCompanySkipUpdate::InterCompany
         && this.InterCompanySkipUpdate != InterCompanySkipUpdate::Both
         && this.intercompanyLinkExist())
        {
            ttsbegin;
            this.intercompanySync();
            ttscommit;
        }

        if (CFMParameters::isPaymentRequestsEnabled() && !CFMAgreementPaymentOrder::isMethodOfPaymentRu(this.purchAgreementHeaderDefault(), this.purchAgreementHeaderDefault().MethodOfPayment))
        {
            CFMAgreementPaymentOrder agreementPaymentOrder = CFMAgreementPaymentOrder::findByAgreement(this.RecId, SalesPurch::Purch, true);

            if (agreementPaymentOrder)
            {
                agreementPaymentOrder.delete();
            }
        }
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDeleteErrorMessage</Name>
				<Source><![CDATA[
    public str validateDeleteErrorMessage()
    {
        return "@SYS301387";
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        return super() && (this.canDeleteAgreement_PSN() || !PurchAgreementHeader::activeWorkflowTemplateExists());
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;
        PdsApprovedVendorListCheck avl;
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        ret = super();

        if (this.isAgreementUsingActiveIntercompanyPartner() && this.intercompanyEndpointActionPolicyCustomer().UnitPriceEqualsCostPrice)
        {
            ret = checkFailed("@SYS334935");
        }

        avl = PdsApprovedVendorListCheck::newFromTable(this);

        avl.parmIgnoreError(true);
        ret = ret && avl.validateCheck();

        // <GEERU>
        if (ret && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ret = this.checkInventOwner_RU();
        }
        // </GEERU>

        if (!FormDataUtil::isFormDataSource(this)
            && !this.canEditAgreement_PSN()
            && !this.isAgreementCLMOwned()
            && PurchAgreementHeader::activeWorkflowTemplateExists())
        {
            ret = checkFailed("@SCM:AgreementWorkflowStatusPreventsUpdates");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needCheckCLMIntegrationFields</Name>
				<Source><![CDATA[
    private boolean needCheckCLMIntegrationFields()
    {
        return this.RecId && this.isAgreementCLMOwned()
            && this.IsIntegration != PurchAgreementIntegrationType::CLM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the name of the vendor account for the current purchase agreement header record.
    /// </summary>
    /// <returns>
    ///    A string that contains the name of the Vendor.
    /// </returns>
    public display VendName vendName()
    {
        VendTable       vendTable;
        DirPartyTable   partyTable;

        if (this.VendAccount)
        {
            select firstonly Party from vendTable
                where vendTable.AccountNum == this.VendAccount
                join Name from partyTable
                    where partyTable.RecId == vendTable.Party;
        }

        return partyTable.Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>VendTable</c> record for the current purchase blanket order.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// The <c>VendTable</c> record.
    /// </returns>
    VendTable vendTable(boolean _forUpdate = false)
    {
        return VendTable::findByDataAreaId(this.VendAccount, this.VendorDataAreaId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByAgreementClassification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified record in the <c>PurchAgreementHeader</c> table exists.
    /// </summary>
    /// <param name="_agreementClassificationRecId">
    /// The Record ID of the <c>AgreementClassification</c> record.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    static public boolean existByAgreementClassification(RecId _agreementClassificationRecId)
    {
        boolean found;

        found = (select firstonly RecId from purchAgreementHeader
                    where purchAgreementHeader.AgreementClassification == _agreementClassificationRecId).RecId != 0;

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForVendor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a vendor has valid purchase agreements.
    /// </summary>
    /// <param name="_vendAccount">
    /// The vendor account number.
    /// </param>
    /// <returns>
    /// true if the vendor has at least one valid agreement; otherwise, false.
    /// </returns>
    public static boolean existForVendor(VendAccount _vendAccount)
    {
        QueryRun                queryRun;

        queryRun = new QueryRun(AgreementHeader::partyAgreementsQuery(tableNum(PurchAgreementHeader), fieldNum(PurchAgreementHeader, VendAccount),
            _vendAccount, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), true));
        return queryRun.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>PurchAgreementHeader</c> table.
    /// </summary>
    /// <param name="_agreementHeaderRecId">
    ///    The record ID of the <c>PurchAgreementHeader</c> record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>PurchAgreementHeader</c> table; otherwise, an empty record.
    /// </returns>
    static PurchAgreementHeader find(AgreementHeaderRecId  _agreementHeaderRecId,
                                     boolean   _forUpdate = false)
    {
        PurchAgreementHeader  purchAgreementHeader;

        if (_agreementHeaderRecId)
        {
            if (_forUpdate)
            {
                purchAgreementHeader.selectForUpdate(_forUpdate);
            }

            select firstonly purchAgreementHeader
                where purchAgreementHeader.RecId == _agreementHeaderRecId
                   && !purchAgreementHeader.IsDeleted;
        }

        return purchAgreementHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAgreementId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>PurchAgreementHeader</c> table by using an agreement ID.
    /// </summary>
    /// <param name="_agreementId">
    ///    The ID of the <c>PurchAgreementHeader</c> record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>PurchAgreementHeader</c> table; otherwise, an empty record.
    /// </returns>
    static PurchAgreementHeader findAgreementId(PurchAgreementId  _agreementId,
                                                boolean           _forUpdate = false)
    {
        return PurchAgreementHeader::findByAgreementId(_agreementId, curext(), _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByAgreementId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>PurchAgreementHeader</c> table by using an agreement ID.
    /// </summary>
    /// <param name="_agreementId">
    ///    The ID of the <c>PurchAgreementHeader</c> record to find.
    /// </param>
    /// <param name="_buyingLegalEntity">
    ///    The buying legal entity of the <c>PurchAgreementHeader</c> record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>PurchAgreementHeader</c> table; otherwise, an empty record.
    /// </returns>
    public static PurchAgreementHeader findByAgreementId(PurchAgreementId  _agreementId,
                                                           DataAreaId _buyingLegalEntity = curext(),
                                                           boolean _forUpdate = false)
    {
        PurchAgreementHeader    purchAgreementHeader;
        CompanyInfo             companyInfo;

        if (_agreementId)
        {
            if (_forUpdate)
            {
                purchAgreementHeader.selectForUpdate(_forUpdate);
            }

            select firstonly purchAgreementHeader
                exists join companyInfo
                    where purchAgreementHeader.PurchNumberSequence  == _agreementId
                       && purchAgreementHeader.BuyingLegalEntity    == companyInfo.RecId
                       && companyInfo.DataArea                      == _buyingLegalEntity;
        }

        return purchAgreementHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByExternalContractId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>PurchAgreementHeader</c> table by using an external contract ID.
    /// </summary>
    /// <param name="_externalContractId">
    ///    The ID of the <c>PurchAgreementHeader</c> record to find.
    /// </param>
    /// <param name="_buyingLegalEntity">
    ///    The buying legal entity of the <c>PurchAgreementHeader</c> record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>PurchAgreementHeader</c> table; otherwise, an empty record.
    /// </returns>
    internal static PurchAgreementHeader findByExternalContractId(CLMIntegrationExternalContractId _externalContractId,
                                                                  DataAreaId _buyingLegalEntity = curext(),
                                                                  boolean _forUpdate = false)
    {
        PurchAgreementHeader    purchAgreementHeader;
        CompanyInfo             companyInfo;

        if (_externalContractId)
        {
            if (_forUpdate)
            {
                purchAgreementHeader.selectForUpdate(_forUpdate);
            }

            select firstonly purchAgreementHeader
                exists join companyInfo
                    where purchAgreementHeader.CLMIntegrationExternalContractId == _externalContractId
                       && purchAgreementHeader.BuyingLegalEntity == companyInfo.RecId
                       && companyInfo.DataArea == _buyingLegalEntity;
        }

        return purchAgreementHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupLeanDocumentDataContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a lookup filtered by a <c>LeanDocumentDataContract</c> object.
    /// </summary>
    /// <param name="_formControl">
    /// The <c>FormControl</c> object to which the lookup will be bound.
    /// </param>
    /// <param name="_contract">
    /// A <c>LeanDocumentDataContract</c> object that holds the filtering values.
    /// </param>
    public static void lookupLeanDocumentDataContract(
        FormControl                 _formControl,
        LeanDocumentDataContract    _contract)
    {
        Query                   query  = new Query();
        QueryBuildDataSource    qbdsPlanActivity;
        SysTableLookup          sysTableLookup;

        if (_formControl)
        {
            sysTableLookup   = SysTableLookup::newParameters (tableNum(PurchAgreementHeader), _formControl);
            qbdsPlanActivity = query.addDataSource(tableNum(PurchAgreementHeader));

            if (_contract.parmLegalEntity())
            {
                qbdsPlanActivity.addRange(fieldNum(PurchAgreementHeader, BuyingLegalEntity)).value(queryValue(_contract.parmLegalEntity()));
            }

            if (_contract.parmVendAccount())
            {
                qbdsPlanActivity.addRange(fieldNum(PurchAgreementHeader, VendAccount)).value(queryValue(_contract.parmVendAccount()));
            }

            qbdsPlanActivity.addRange(fieldNum(PurchAgreementHeader, IsDeleted)).value(queryValue(NoYes::No));

            sysTableLookup.addLookupfield(fieldNum(PurchAgreementHeader, PurchNumberSequence));
            sysTableLookup.addLookupfield(fieldNum(PurchAgreementHeader, VendAccount));
            sysTableLookup.addLookupfield(fieldNum(PurchAgreementHeader, AgreementState));

            sysTableLookup.setLabel("@SYS190134");
            sysTableLookup.parmQuery(query);

            sysTableLookup.performFormLookup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchAgreementExcludeDirectInvoiceLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the purchase agreements lookup.
    /// </summary>
    /// <param name="_callingControl">
    /// The control for which a lookup is created.
    /// </param>
    /// <param name="_purchTable">
    /// The <c>PurchTable</c> table record that contains the <c>OrderAccount</c> and <c>DeliveryDate</c>
    /// field values, which is used to filter purchase agreement lookup data.
    /// </param>
    public static void purchAgreementExcludeDirectInvoiceLookup(
        FormControl _callingControl,
        PurchTable  _purchTable)
    {
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(PurchAgreementHeader), _callingControl);

        Query                   query = new Query();
        QueryBuildDataSource    queryBuildDataSource;
        QueryBuildDataSource    qbds;

        QueryBuildRange         queryBuildRange;
        FieldId                 partyAccountFieldId = fieldNum(PurchAgreementHeader, VendAccount);
        CustVendAC              custVendAccount = _purchTable.OrderAccount;
        TransDate               transDate = _purchTable.DeliveryDate;

        queryBuildDataSource = query.addDataSource(tableNum(PurchAgreementHeader));
        qbds = queryBuildDataSource.addDataSource(tableNum(AgreementClassification));
        qbds.relations(true);
        queryBuildRange = queryBuildDataSource.addRange(partyAccountFieldId);
        queryBuildRange.value(custVendAccount);
        queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementHeader, AgreementState));
        queryBuildRange.value(queryValue(AgreementState::Effective));
        queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementHeader, IsDeleted));
        queryBuildRange.value(queryValue(NoYes::No));
        queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementHeader, EarliestLineEffectiveDate));
        queryBuildRange.value(SysQuery::range(null, transDate));
        queryBuildRange = queryBuildDataSource.addRange(fieldNum(AgreementHeader, LatestLineExpirationDate));
        queryBuildRange.value(SysQuery::range(transDate, null));
        queryBuildRange = qbds.addRange(fieldNum(AgreementClassification, DirectInvoiceEnable_PSN));
        queryBuildRange.value(queryValue(NoYes::No));

        sysTableLookup.addLookupfield(fieldNum(PurchAgreementHeader, PurchNumberSequence));
        sysTableLookup.addLookupfield(fieldNum(PurchAgreementHeader, DocumentTitle));
        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchAgreementLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the puchase agreements lookup.
    /// </summary>
    /// <param name="_callingControl">
    /// The control for which lookup will be created.
    /// </param>
    /// <param name="_purchTable">
    /// The <c>PurchTable</c> record containing vendor account and delivery date data, which is used to filter purchase agreement lookup data.
    /// </param>
    /// <param name="_filterStr">
    ///    The filter string entered by the user.
    /// </param>
    /// <param name="_allStatus">
    ///    The flag to show agreements of all statuses.
    /// </param>
    public static void purchAgreementLookup(FormControl _callingControl,
        PurchTable _purchTable
        , str _filterStr = '',
        boolean _allStatus = false
        )
    {
        // <GEERU>
        #ISOCountryRegionCodes
        Query query;
        QueryBuildDataSource qbds;
        // </GEERU>
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(PurchAgreementHeader), _callingControl);

        sysTableLookup.addLookupfield(fieldNum(PurchAgreementHeader, PurchNumberSequence));
        sysTableLookup.addLookupfield(fieldNum(PurchAgreementHeader, VendAccount));
        sysTableLookup.addLookupfield(fieldNum(PurchAgreementHeader, DocumentTitle));
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            sysTableLookup.addLookupMethod(tableMethodStr(AgreementHeader, agreementDate_RU));
            sysTableLookup.addLookupfield(fieldNum(PurchAgreementHeader, Currency));
            sysTableLookup.addLookupfield(fieldNum(PurchAgreementHeader, AgreementClassification));

            query = AgreementHeader::partyAgreementsQuery(tableNum(PurchAgreementHeader),
                fieldNum(PurchAgreementHeader, VendAccount),
                _purchTable.OrderAccount ? _purchTable.OrderAccount : SysQuery::valueEmptyString(),
                _purchTable.DeliveryDate);

            if (_purchTable.InvoiceAccount)
            {
                qbds = query.dataSourceTable(tableNum(PurchAgreementHeader));
                qbds = qbds.addDataSource(tableNum(PurchAgreementHeaderDefault));
                qbds.relations(true);

                qbds.addRange(fieldNum(PurchAgreementHeaderDefault, VendorInvoiceAccount)).value(_purchTable.InvoiceAccount);
            }

            if (_filterStr)
            {
                qbds = query.dataSourceTable(tableNum(PurchAgreementHeader));
                findOrCreateRange_W(qbds, fieldNum(PurchAgreementHeader, PurchNumberSequence), _filterStr);
            }

            if (_allStatus)
            {
                qbds = query.dataSourceTable(tableNum(PurchAgreementHeader));
                findOrCreateRange_W(qbds, fieldNum(PurchAgreementHeader, AgreementState), SysQuery::valueUnlimited());
            }

            qbds = query.dataSourceTable(tableNum(PurchAgreementHeader));
            qbds = qbds.addDataSource(tableNum(PurchAgreementHeaderExt_RU));
            qbds.relations(true);
            qbds.joinMode(JoinMode::ExistsJoin);

            sysTableLookup.parmQuery(query);
        }
        else
        {
        // </GEERU>
            sysTableLookup.parmQuery(AgreementHeader::partyAgreementsQuery(tableNum(PurchAgreementHeader), fieldNum(PurchAgreementHeader, VendAccount),
                _purchTable.OrderAccount, _purchTable.DeliveryDate));
        // <GEERU>
        }
        // </GEERU>
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWorkflowStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the workflow status for the purchase agreement header.
    /// </summary>
    /// <param name="_purchAgreementHeaderRecId">
    /// The record ID of the <c>PurchAgreementHeader</c> record for which to set the workflow status.
    /// </param>
    /// <param name="_workflowStatus">
    /// The workflow status to set.
    /// </param>
    /// <remarks>
    /// The workflow status for the purchase agreement header.
    /// </remarks>
    public static void setWorkflowStatus(
        RecId                        _purchAgreementHeaderRecId,
        PurchAgreementWorkflowStatus _workflowStatus)
    {
        PurchAgreementHeader purchAgreementHeader;

        ttsbegin;

        purchAgreementHeader = PurchAgreementHeader::find(_purchAgreementHeaderRecId, true);

        if (purchAgreementHeader)
        {
            purchAgreementHeader.WorkflowStatus_PSN = _workflowStatus;
            purchAgreementHeader.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendorForContractorChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the value of the <c>VendAccount</c> and the <c>VendorDataAreaID</c> fields in the specified
    /// record when the contractor is modified.
    /// </summary>
    /// <param name="_purchAgreementHeaderRecId">
    /// The record ID of the <c>PurchAgreementheader</c> table record.
    /// </param>
    /// <param name="_vendTable">
    /// A <c>VendTable</c> table buffer.
    /// </param>
    public static void updateVendorForContractorChange(
        AgreementHeaderRecId    _purchAgreementHeaderRecId,
        VendTable               _vendTable)
    {
        PurchAgreementHeader purchAgreementHeader;

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            purchAgreementHeader = PurchAgreementHeader::find(_purchAgreementHeaderRecId, true);

            if (purchAgreementHeader != null)
            {
                ttsbegin;
                purchAgreementHeader.VendAccount        = _vendTable.AccountNum;
                purchAgreementHeader.VendorDataAreaId   = appl.company().dataArea(tableNum(VendTable));
                purchAgreementHeader.update();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkflowStatusForEdit_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Purchase Agreements workflow status when the Purchase Agreements form is in Edit mode,
    /// according to the Public Sector requirements.
    /// </summary>
    public void updateWorkflowStatusForEdit_PSN()
    {
        ttsBegin;

        this.AgreementState = AgreementState::OnHold;
        this.WorkflowStatus_PSN = PurchAgreementWorkflowStatus::NotSubmitted;
        this.update();

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateWorkflowStatusForEdit_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the purchase agreements workflow status should be updated
    /// when the Purchase Agreements form is in Edit mode according to the Public Sector requirements.
    /// </summary>
    public boolean mustUpdateWorkflowStatusForEdit_PSN()
    {
        return isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && this.hasActiveWorkFlow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateWorkflowStatusOnLineChange_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the purchase agreements workflow status should be updated
    /// after creating or updating an agreement line.
    /// </summary>
    public boolean mustUpdateWorkflowStatusOnLineChange_PSN()
    {
        return this.WorkflowStatus_PSN == PurchAgreementWorkflowStatus::Approved
            && this.mustUpdateWorkflowStatusForEdit_PSN();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findIntercompanyAgreementActionPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and returns an <c>IntercompanyAgreementActionPolicy</c> record.
    /// </summary>
    /// <returns>
    /// An <c>IntercompanyAgreementActionPolicy</c> record.
    /// </returns>
    public IntercompanyAgreementActionPolicy findIntercompanyAgreementActionPolicy()
    {
        InterCompanyTradingPartnerRecID interCompanyTradingPartnerRecID = this.vendTable().interCompanyTradingPartner().RecId;
        return IntercompanyAgreementActionPolicy::findFromIntercompanyTradingPartner(interCompanyTradingPartnerRecID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContactPerson</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the specified contact person can be referenced in the agreement.
    /// </summary>
    /// <param name="_contactPersonId">The ID of the contact person.</param>
    /// <returns>true, if the specified contact person can be referenced in the agreement; otherwise, false.</returns>
    public boolean validateContactPerson(ContactPersonId _contactPersonId)
    {
        if (VendTable::find(this.VendAccount).Party != ContactPerson::find(_contactPersonId).ContactForParty)
        {
            return checkFailed("@SCM:ContactPersonIsNotAssociatedWithVendor");
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        if (this.isAgreementCLMOwned() && this.IsIntegration != PurchAgreementIntegrationType::CLM)
        {
            throw error(strFmt("@CLMIntegration:ErrorWhenDeleteCLMIntegrationPurchAgreement", this.PurchNumberSequence));
        }
            
        if (TaxIntegrationUtils::isTransitDocumentEnabled())
        {
            this.TransitDocumentTransactionMap_IN::deleteTransitDocumentsForHeader();
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(PurchAgreementHeader, AgreementClassification):
                AgreementClassification agreementClassification = AgreementClassification::find(this.AgreementClassification);
                this.PrimaryResponsibleWorker = agreementClassification.PrimaryResponsibleWorker;
                this.SecondaryResponsibleWorker = agreementClassification.SecondaryResponsibleWorker;

                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean ret = super(_fieldIdToCheck);

        if (ret)
        {
            switch (_fieldIdToCheck)
            {
                case fieldNum(PurchAgreementHeader, PrimaryResponsibleWorker):
                case fieldNum(PurchAgreementHeader, SecondaryResponsibleWorker):
                    if (this.PrimaryResponsibleWorker
                        && this.PrimaryResponsibleWorker == this.SecondaryResponsibleWorker)
                    {
                        ret = checkFailed("@SCM:ErrorSecondaryResponsibleWorkerSameAsThePrimary");
                    }
                    else if (!this.PrimaryResponsibleWorker && this.SecondaryResponsibleWorker)
                    {
                        ret = checkFailed("@SCM:ErrorSecondaryResponsibleWorkerWithoutAPrimary");
                    }

                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>TradeBlanketOrder</ConfigurationKey>
	<DeveloperDocumentation>@SYS324046</DeveloperDocumentation>
	<FormRef>purchagreement</FormRef>
	<Label>@SYS190134</Label>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>PurchNumberSequence</TitleField1>
	<TitleField2>VendAccount</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<Extends>AgreementHeader</Extends>
	<Modules>ProcurementAndSourcing</Modules>
	<ReplacementKey>PurchNumberSequenceIdx</ReplacementKey>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<SupportInheritance>Yes</SupportInheritance>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>PurchAgreementHeaderDefault</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>PurchAgreementHeaderDefault</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>PurchReqLine</Name>
			<DeleteAction>CascadeRestricted</DeleteAction>
			<Relation></Relation>
			<Table>PurchReqLine</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchNumberSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendAccount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchNumberSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BuyingLegalEntity</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CentralBank_PSN</Name>
			<Label>@SPS2074</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InterestBasedOnCEB_PSN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ContractAmount_PSN</Name>
			<Label>@SPS2077</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MinimumAmount_PSN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MaximumAmount_PSN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Details</Name>
			<Label>@SYS80118</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchNumberSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BuyingLegalEntity</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PurchAgreementType_PSN</Name>
			<Label>@SPS1780</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchAgreementType_PSN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Purchasing_PSN</Name>
			<Label>@SPS2083</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Purpose_PSN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProcurementClassification_PSN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Renewable_PSN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Status</Name>
			<Label>@SYS183849</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkflowStatus_PSN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AgreementState</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WorkflowPreview</Name>
			<Label>@SYS313953</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchNumberSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkflowStatus_PSN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BuyingLegalEntity</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS129100</Label>
			<Mandatory>Yes</Mandatory>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InterestBasedOnCEB_PSN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PurchFrenchRegulatory_PSN</ConfigurationKey>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SPS2075</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>MaximumAmount_PSN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PurchFrenchRegulatory_PSN</ConfigurationKey>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SPS2080</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>MinimumAmount_PSN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PurchFrenchRegulatory_PSN</ConfigurationKey>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SPS2078</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ParentPurchAgreementID_PSN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PurchFrenchRegulatory_PSN</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SPS2051</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProcurementClassification_PSN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PurchFrenchRegulatory_PSN</ConfigurationKey>
			<ExtendedDataType>Description</ExtendedDataType>
			<Label>@SPS2086</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PurchAgreementType_PSN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PurchAgreementType_PSN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PurchNumberSequence</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchAgreementId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Purpose_PSN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PurchFrenchRegulatory_PSN</ConfigurationKey>
			<ExtendedDataType>Description</ExtendedDataType>
			<Label>@SPS2084</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Renewable_PSN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PurchFrenchRegulatory_PSN</ConfigurationKey>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SPS2072</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VendAccount</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>VendAccount</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VendorDataAreaId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>DataAreaId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkflowStatus_PSN</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PurchAgreementWorkflowStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PrimaryResponsibleWorker</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>HcmWorkerRecId</ExtendedDataType>
			<Label>@SCM:PrimaryResponsibleWorker</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SecondaryResponsibleWorker</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>HcmWorkerRecId</ExtendedDataType>
			<Label>@SCM:SecondaryResponsibleWorker</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ShipCalendarId</Name>
			<AssetClassification>Customer content</AssetClassification>
			<ExtendedDataType>PurchVendorShipCalendarId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CLMIntegrationPurchAgreementOwnership</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CLMIntegration</ConfigurationKey>
			<FeatureClass>CLMIntegrationFeature</FeatureClass>
			<EnumType>CLMIntegrationPurchaseAgreementOwnershipType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CLMIntegrationExternalContractId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CLMIntegration</ConfigurationKey>
			<ExtendedDataType>CLMIntegrationExternalContractId</ExtendedDataType>
			<FeatureClass>CLMIntegrationFeature</FeatureClass>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsIntegration</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
			<EnumType>PurchAgreementIntegrationType</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>CompanyInfoIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>BuyingLegalEntity</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PurchNumberSequenceIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>PurchNumberSequence</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>BuyingLegalEntity</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>VendTableIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>VendAccount</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>VendorDataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CLMIntegrationExternalContractIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CLMIntegrationExternalContractId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalTable</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>Posted</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>TableId</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AgreementHeader</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>AgreementHeader</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Specialization</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CompanyInfo</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CompanyInfo</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>CompanyInfo</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CompanyInfo_PurchAgreementHeader</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BuyingLegalEntity</Name>
					<Field>BuyingLegalEntity</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PurchAgreementHeader_PSN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PurchAgreementHeader</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PurchAgreementHeader_PSN</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>PurchAgreementHeader</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ParentPurchAgreementID_PSN</Name>
					<Field>ParentPurchAgreementID_PSN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VendTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>VendTable_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>VendTable_1_PurchAgreementHeader</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendorDataAreaId</Name>
					<Field>VendorDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendAccount</Name>
					<SourceEDT>VendAccount</SourceEDT>
					<Field>VendAccount</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PrimaryResponsibleWorker</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PrimaryResponsibleWorker</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>PrimaryResponsibilityPurchaseAgreementHeaders</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PrimaryResponsibleWorker</Name>
					<Field>PrimaryResponsibleWorker</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SecondaryResponsibleWorker</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>SecondaryResponsibleWorker</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>SecondaryResponsibilityPurchaseAgreementHeaders</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SecondaryResponsibleWorker</Name>
					<Field>SecondaryResponsibleWorker</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>