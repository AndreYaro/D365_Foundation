<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailCategoryPriceRule</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class RetailCategoryPriceRule extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createJounalLink</Name>
				<Source><![CDATA[
    private void createJounalLink(PriceDiscJournalNum _expireJourNum)
    {
        RetailCategoryPriceJournalLink categoryPriceJournalLink;

        categoryPriceJournalLink.JournalNum = _expireJourNum;
        categoryPriceJournalLink.CategoryPriceRule = this.RecId;
        // <GEERU>
        categoryPriceJournalLink.CategoryPriceRuleGroupCode = this.CategoryPriceRuleGroupCode;
        // </GEERU>
        categoryPriceJournalLink.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceDiscAdmTable</Name>
				<Source><![CDATA[
    private PriceDiscAdmTable createPriceDiscAdmTable(Name _name, Boolean _forceSkipAdditionalData = false)
    {
        PriceDiscAdmTable admTable;
        RetailParameters retailParams = RetailParameters::find();

        ttsBegin;
        admTable.JournalName = retailParams.DefaultJournalName4CategoryPrice;
        admTable.Name = _name;
        admTable.DefaultRelation = PriceType::PriceSales;

        admTable.insert();

        // <GEERU>
        RetailPriceDiscAdmTable::createRetailPriceDiscAdmTable(admTable.RecId, this.CategoryPriceRuleGroupCode, _forceSkipAdditionalData);
        // </GEERU>
        ttsCommit;

        return admTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>expirePreviousTAs</Name>
				<Source><![CDATA[
    private void expirePreviousTAs(boolean _expirePreviousTAs,
                                   date _newFromDate,
                                   PriceDiscJournalNum _expireJourNum = '',
                                   PriceDiscJournalNum _generatedJourNum = '',
                                   boolean _expireOnlyChangedItems = false)
    {
        RetailCategoryPriceJournalLink journalLink;
        PriceDiscAdmTable newAdmTable;
        PriceDiscAdmTrans previousAdmTrans, newAdmTrans, generatedAdmTrans;
        PriceDiscTable previousTAs;

        RetailPriceDiscAdmTrans retailPriceDiscAdmTrans;
        Boolean expireLinesExists;
        Boolean groupProcessing;

        ToDate expiredDate = _newFromDate - 1;
        PriceDiscJournalNum jNum;

        #LocalMacro.FieldList
            Agreement,
            ItemCode,
            AccountCode,
            ItemRelation,
            AccountRelation,
            UnitId,
            QuantityAmountFrom,
            QuantityAmountTo,
            GenericCurrency,
            FromDate,
            Amount,
            Currency,
            Percent1,
            Percent2,
            DeliveryTime,
            SearchAgain,
            PriceUnit,
            Relation,
            Markup,
            AllocateMarkup,
            Module,
            CalendarDays,
            InventDimId,
            DisregardLeadTime,
            AgreementHeaderExt_RU,
            InventBaileeFreeDays_RU
            , PDSCalculationId
        #endMacro
    
        if (!_expirePreviousTAs)
        {
            return;
        }
    
        if (_expireJourNum)
        {
            jNum = _expireJourNum;
            groupProcessing = true;
        }
        else
        {
            newAdmTable = this.createPriceDiscAdmTable(RetailParameters::expirePreviousTAsJourDescription(), true);
            jNum = newAdmTable.JournalNum;
        }

        // Note: Parameters are turned off to improve perf for the insert query.
        newAdmTrans.skipDataMethods(true);
        newAdmTrans.skipEvents(true);
        newAdmTrans.skipDatabaseLog(true);

        #localmacro.insertExpireLines

        insert_recordset newAdmTrans(PriceDiscTableRef, #FieldList, ToDate, JournalNum, LineNum)
            select RecId, #FieldList, expiredDate, jNum from previousTAs
                where previousTAs.relation == PriceType::PriceSales
                    && (!previousTAs.ToDate || previousTAs.ToDate > expiredDate)
            join LineNum from previousAdmTrans
                where previousAdmTrans.RecId == previousTAs.OriginalPriceDiscAdmTransRecId
            join journalLink
                where journalLink.JournalNum == previousAdmTrans.JournalNum
                    && journalLink.CategoryPriceRule == this.RecId
        #Endmacro

        #localmacro.filterChangedLines
            exists join generatedAdmTrans
                where generatedAdmTrans.JournalNum == _generatedJourNum
                   && generatedAdmTrans.itemRelation == %1.itemRelation
                   && generatedAdmTrans.itemCode == %1.itemCode
        #Endmacro

        #localmacro.filterCurrentRule
            exists join retailPriceDiscAdmTrans
                where retailPriceDiscAdmTrans.PriceDiscAdmTrans == generatedAdmTrans.RecId
                    && retailPriceDiscAdmTrans.RetailCategoryPriceRuleRecId == this.RecId
        #Endmacro

        #insertExpireLines
        #filterChangedLines(previousAdmTrans)
        #filterCurrentRule
        ;

        select firstOnly RecID from newAdmTrans
        where newAdmTrans.JournalNum == jNum
            #filterChangedLines(newAdmTrans)
        #filterCurrentRule
        ;

        expireLinesExists  = newAdmTrans.RecId;

        if (expireLinesExists)
        {
            this.createJounalLink(jNum);

            if (groupProcessing)
            {
                update_recordSet newAdmTrans setting
                    FromDate = expiredDate
                where newAdmTrans.JournalNum == _expireJourNum
                    && newAdmTrans.FromDate > expiredDate
                exists join generatedAdmTrans
                        where  (generatedAdmTrans.JournalNum == _generatedJourNum
                            && generatedAdmTrans.ItemRelation == newAdmTrans.ItemRelation)
                ;
            }
            else
            {
                update_recordSet newAdmTrans setting
                    FromDate = expiredDate
                where newAdmTrans.JournalNum == _expireJourNum
                    && newAdmTrans.FromDate > expiredDate;
            }
        }

        if (!groupProcessing)
        {
            if (expireLinesExists)
			{
					info("@REX1270", '', SysInfoAction_TableField::newBuffer(PriceDiscAdmTable::find(_expireJourNum)));
			}
			else
			{
				newAdmTable.selectForUpdate(true);
				newAdmTable.delete();
			}
		}
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentPriceBasisCalculator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the current price basis calculator based on the trade agreement journal, price basis date and exchange rate.
    /// </summary>
    /// <param name = "priceDiscTrans">Line of trade agreement journal.</param>
    /// <param name = "priceBasisDate">Price basis date.</param>
    /// <param name = "exchangeRateTypeRecId">Exchange rate type.</param>
    /// <returns>Current price basis calculator</returns>
    public static RetailPriceBasisCalc getCurrentPriceBasisCalculator(PriceDiscAdmTrans priceDiscTrans, TransDate priceBasisDate, ExchangeRateTypeRecId exchangeRateTypeRecId)
    {
        RetailPriceBasisCalc basisCalculator;

        basisCalculator = RetailPriceBasisCalcFactory::getCalculatorFromPriceDiscAdmTrans(priceDiscTrans, RetailPriceBasisType::CurrentPrice, priceBasisDate, exchangeRateTypeRecId);

        basisCalculator.calculate();

        return basisCalculator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBasisPriceCalculator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the price basis calculator from price rule.
    /// </summary>
    /// <param name = "retailCategoryPriceRule">Price rule record.</param>
    /// <param name = "itemRelation">Item id.</param>
    /// <param name = "currency">Currency for price basis calculation.</param>
    /// <param name = "unitId">Unit of measure for calculation.</param>
    /// <param name = "priceBasisDate">Date for price basis calulation.</param>
    /// <returns>Price basis calculator from price rule.</returns>
    public static RetailPriceBasisCalc getBasisPriceCalculator(RetailCategoryPriceRule retailCategoryPriceRule, PriceDiscItemRelation itemRelation, CurrencyCode currency, UnitOfMeasureSymbol unitId, TransDate priceBasisDate)
    {
        RetailPriceBasisCalc basisCalculator;

        basisCalculator = RetailPriceBasisCalcFactory::getCalculatorFromPriceRule(retailCategoryPriceRule, itemRelation, currency, unitId, priceBasisDate);

        basisCalculator.calculate();

        return basisCalculator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPriceDiscTrans</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    private PriceDiscAdmTrans initPriceDiscTrans(PriceDiscAdmTable _priceDiscAdm,
        InventTable _inventTable,
        CurrencyCode _priceCurrencyCode,
        FromDate _priceFromDate,
        ToDate _priceToDate,
        boolean _findNext)
    {
        PriceDiscAdmTrans priceDiscTrans;
        EcoResProduct ecoResProduct;
        InventTable inventTable;

        priceDiscTrans.initValue();
        
        priceDiscTrans.relation         = PriceType::PriceSales;
        priceDiscTrans.JournalNum       = _priceDiscAdm.JournalNum;
        priceDiscTrans.AccountCode      = PriceDiscPartyCodeTypeTableGroupAllMapping::tableGroupAllToPriceDiscPartyCodeType(this.AccountCode);
        priceDiscTrans.AccountRelation  = this.AccountRelation;
        priceDiscTrans.ItemCode         = PriceDiscProductCodeType::Table;
        priceDiscTrans.ItemRelation     = _inventTable.ItemId;

        // As per productSubType the <c>InventDimId </c> will be set.
        select  ecoResProduct 
            join inventTable where ecoResProduct.recid == inventTable.product &&
                 inventTable.ItemId == _inventTable.ItemId ;

        if (ecoResProduct.ProductType == EcoResProductType::Item && 
            (ecoResProduct.productSubtype() == EcoResProductSubtype::ProductMaster || ecoResProduct.productSubtype() == EcoResProductSubtype::ProductVariant))
        {
            priceDiscTrans.InventDimId      = this.PriceBasisInventDimId;
        }
        else if (RetailPricingKillSwitch::considerInventDimOnRetailCategoryPriceRule())
        {
            // For non master/variant products, we should take product-related InventDim fields out.
            InventDim inventDimTrans = InventDim::find(this.PriceBasisInventDimId);
            inventDimTrans.InventColorId = '';
            inventDimTrans.InventSizeId = '';
            inventDimTrans.InventStyleId = '';
            inventDimTrans.configId = '';
            inventDimTrans = InventDim::findOrCreate(inventDimTrans);

            priceDiscTrans.InventDimId      = inventDimTrans.inventDimId;
        }
        else
        {
            priceDiscTrans.InventDimId      = InventDim::inventDimIdBlank();
        }
        priceDiscTrans.FromDate         = _priceFromDate;
        priceDiscTrans.ToDate           = _priceToDate;
        priceDiscTrans.Currency         = _priceCurrencyCode;
        priceDiscTrans.SearchAgain      = _findNext;
        
        if (this.UnitId)
        {
            priceDiscTrans.UnitId = this.UnitId;
        }
        else
        {
            priceDiscTrans.initFromItemCode();
        }

        return priceDiscTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPriceDiscTransAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate price amount based on set of parameters.
    /// </summary>
    /// <param name = "priceDiscTrans">Trade agreement journal line.</param>
    /// <param name = "priceCurrencyCode">Price currency code.</param>
    /// <param name = "priceBasisDate">Date which is used for basis price search.</param>
    /// <returns>Price basis calculator used to calculate the price amount.</returns>
    [HookableAttribute(true)]
    private RetailPriceBasisCalc calcPriceDiscTransAmount(PriceDiscAdmTrans priceDiscTrans, CurrencyCode priceCurrencyCode, TransDate priceBasisDate)
    {
        RetailPriceBasisCalc basisPriceCalculator;
        Price calculationBase;

        switch (this.PriceSetupType)
        {
            case RetailCategoryPriceSetupType::FixedAmount:
                priceDiscTrans.Amount = this.AmountPercent;
                basisPriceCalculator = RetailCategoryPriceRule::getBasisPriceCalculator(this, priceDiscTrans.ItemRelation, priceDiscTrans.Currency, priceDiscTrans.UnitId, priceBasisDate);
                
                calculationBase = basisPriceCalculator.getPriceCurrencyTo();

                if (this.PriceSetupType == RetailCategoryPriceSetupType::FixedAmount)
                {
                    priceDiscTrans.Amount = calculationBase + this.AmountPercent;
                }

                break;

            case RetailCategoryPriceSetupType::Margin:
            case RetailCategoryPriceSetupType::Markup:
                basisPriceCalculator = RetailCategoryPriceRule::getBasisPriceCalculator(this, priceDiscTrans.ItemRelation, priceDiscTrans.Currency, priceDiscTrans.UnitId, priceBasisDate);
                
                calculationBase = basisPriceCalculator.getPriceCurrencyTo();

                if (calculationBase > 0)
                {
                    if (this.PriceSetupType == RetailCategoryPriceSetupType::Markup)
                    {
                        priceDiscTrans.Amount = calculationBase * (1.0 + this.AmountPercent / 100.0);
                    }
                    else // if (this.PriceSetupType == RetailCategoryPriceSetupType::Margin)
                    {
                        priceDiscTrans.Amount = calculationBase / (1.0 - this.AmountPercent / 100.0);
                    }
                }

                break;

            default:
                EventHandlerResult result = new EventHandlerResult();
                
                // Set trade agreement journal line amount by calling the method that subscribes to this delegate, if available.
                this.calcPriceDiscTransAmountDelegate(priceDiscTrans,
                     this.PriceSetupType,
                     priceCurrencyCode,
                     priceBasisDate,
                     result);
                
                if (result.hasResult())
                {
                    basisPriceCalculator = result.result();
                }
                else
                {
                    // If there is no result from the calcPriceDiscTransAmountDelegate, then warning message is displayed
                    warning(strFmt("@Retail:RetailAXExtensibilityDelegateMethodExtensibleEnumNotImplemented", enum2Str(this.PriceSetupType)));
                }
                break;
        }

        if (this.SmartRoundingGroup)
        {
            priceDiscTrans.Amount = PriceDiscSmartRounding::smartRoundByGroup(priceDiscTrans.Amount, this.SmartRoundingGroup);
        }

        priceDiscTrans.Amount = CurrencyExchange::round(priceDiscTrans.Amount, priceCurrencyCode);

        return basisPriceCalculator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>savePriceDiscTrans</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    private void savePriceDiscTrans(
        PriceDiscAdmTrans priceDiscTrans,
        RetailCategoryPriceProductSelectionType productSelection,
        RetailPriceBasisCalc basisPriceCalculator,
        RetailPriceBasisCalc currentPriceBasisCalculator,
        TransDate priceBasisDate
        )
    {
        Price   currentPrice            = currentPriceBasisCalculator != null ? currentPriceBasisCalculator.getPriceCurrencyTo() : 0;
        boolean currentPriceCalculated  = currentPriceBasisCalculator != null ? true : false;

        // <GEERU>
        if (productSelection != RetailCategoryPriceProductSelectionType::ChangedPriceItems || priceDiscTrans.Amount != currentPrice)
        {
            // </GEERU>
            priceDiscTrans.insert();
            // <GEERU>
            RetailPriceDiscAddDataSaver::calcAndSave(this, priceDiscTrans, basisPriceCalculator, priceBasisDate, currentPrice, currentPriceCalculated);
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>generatePrice</Name>
				<Source><![CDATA[
    private void generatePrice(
        PriceDiscAdmTable _priceDiscAdm,
        InventTable _inventTable,
        InventTableModule _priceModule,
        CurrencyCode _priceCurrencyCode,
        FromDate _priceFromDate,
        ToDate _priceToDate,
        boolean _findNext,
        RetailCategoryPriceProductSelectionType _productSelection,
        TransDate _priceBasisDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()),
        LineNum _lineNum = 0
        )
    {
        PriceDiscAdmTrans priceDiscTrans;
        RetailPriceBasisCalc basisPriceCalculator, currentPriceBasisCalculator;
    
        priceDiscTrans = this.initPriceDiscTrans(_priceDiscAdm, _inventTable, _priceCurrencyCode, _priceFromDate, _priceToDate, _findNext);
        priceDiscTrans.LineNum = _lineNum;

        if (_productSelection == RetailCategoryPriceProductSelectionType::ZeroPricedItems
           // <GEERU>
        || _productSelection == RetailCategoryPriceProductSelectionType::ChangedPriceItems
           // </GEERU>
        )
        {
            currentPriceBasisCalculator = RetailCategoryPriceRule::getCurrentPriceBasisCalculator(priceDiscTrans, _priceBasisDate, this.ExchangeRateTypeRecId);

            if (currentPriceBasisCalculator.getPriceCurrencyTo() > 0
                // <GEERU>
            && _productSelection == RetailCategoryPriceProductSelectionType::ZeroPricedItems
                // </GEERU>
            )
            {
                return;
            }
        }

        // calculate the amount and return the price basis calculator used.
        basisPriceCalculator = this.calcPriceDiscTransAmount(priceDiscTrans, _priceCurrencyCode, _priceBasisDate);

        this.savePriceDiscTrans(priceDiscTrans, _productSelection, basisPriceCalculator, currentPriceBasisCalculator, _priceBasisDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPriceDiscTransAmountDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to calculate price based on set of parameters.
    /// </summary>
    /// <param name = "_priceDiscTrans">Trade agreement journal line.</param>
    /// <param name = "_priceSetupType">Price rule type.</param>
    /// <param name = "_priceCurrencyCode">Price currency code.</param>
    /// <param name = "_priceBasisDate">Date which is used for basis price search.</param>
    /// <param name = "_result">Price basis calculator used to calculate the price amount.</param>
    delegate void calcPriceDiscTransAmountDelegate(
        PriceDiscAdmTrans _priceDiscTrans,
        RetailCategoryPriceSetupType _priceSetupType,
        CurrencyCode _priceCurrencyCode,
        TransDate _priceBasisDate,        
        EventHandlerResult _result)
    {
        // Subscriber will provide proper implementation to this method
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfProducts4Pricing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get number of products for pricing.
    /// </summary>
    /// <param name="_priceBasisDate">
    /// Price basis date.
    /// </param>
    /// <returns>
    /// Number of products for pricing.
    /// </returns>
    public int getNumberOfProducts4Pricing(RetailPriceBasisDate _priceBasisDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()))
    {
        RetailCategoryPriceScheduler priceScheduler = RetailCategoryPriceScheduler::construct();

        priceScheduler.parmCategoryPriceRule(this);
        priceScheduler.parmPriceBasisDate(_priceBasisDate);

        return priceScheduler.categoryPriceProductQueryHelper().countTotal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReady4GeneratingPrices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether it's ready for generating prices.
    /// </summary>
    /// <returns>
    /// A flag indicating whether it's ready for generating prices.
    /// </returns>
    public boolean isReady4GeneratingPrices()
    {
        boolean isReady = (this.Category != 0);

        if (isReady)
        {
            isReady = (this.AccountCode == TableGroupAll::All) || (this.AccountRelation != '');
        }

        return isReady;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs specific actions when a field is modified.
    /// </summary>
    /// <param name="_fieldId">
    /// The field ID of the field that has been modified.
    /// </param>
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);
        switch (_fieldId)
        {
            case fieldNum(RetailCategoryPriceRule, AccountCode):
                if (this.AccountCode == TableGroupAll::All)
                {
                    this.AccountRelation = '';
                }
                break;

            case fieldNum(RetailCategoryPriceRule, PriceBasis):
                if (this.PriceBasis == RetailPriceBasisType::BasePrice)
                {
                    if (this.PriceSetupType == RetailCategoryPriceSetupType::Margin)
                    {
                        this.PriceSetupType = RetailCategoryPriceSetupType::Markup;
                        this.AmountPercent = 0;
                    }
                }

                this.PriceBasisCurrencyCode = '';
                this.ExchangeRateTypeRecId = 0;
                this.PriceBasisVendAccount = '';
                this.PriceBasisOtherPriceGroup = '';
                this.PriceBasisInventDimId = InventDim::inventDimIdBlank();

                break;

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generatePricesByScheduler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate prices from the <c>RetailCategoryPriceScheduler</c> class.
    /// </summary>
    /// <param name="_priceScheduler">
    /// Instance of the class.
    /// </param>
    /// <returns>
    /// A record of <c>PriceDiscAdmTable</c>.
    /// </returns>
    public PriceDiscAdmTable generatePricesByScheduler(RetailCategoryPriceScheduler _priceScheduler)
    {
        QueryRun queryRun;
        InventTable inventTable;
        PriceDiscAdmTable priceDiscAdm;
        InventTableModule inventTableModule;
        // <GEERU>
        RetailCategoryContainmentLookup categoryContainmentLookup;
        boolean isPartCategoryTreeProcessing;
        boolean allowToGenerate;
        container excludedCategories, conTmp;
        EcoResCategoryId    exclCategory;
        boolean             inclSubCategory;
        int i;
        #ISOCountryRegionCodes
        // </GEERU>

        ttsbegin;
        // <GEERU>
        isPartCategoryTreeProcessing = _priceScheduler.parmIsGroupProcessing() && this.Scope == RetailPriceCategoryRuleScope::IncludeSubCategories;
        if (isPartCategoryTreeProcessing)
        {
            excludedCategories = _priceScheduler.parmExcludedCategories();
        }

        if (_priceScheduler.parmPriceDiscJournalNum())
        {
            priceDiscAdm = PriceDiscAdmTable::find(_priceScheduler.parmPriceDiscJournalNum());
        }
        else
        {
            // </GEERU>
            priceDiscAdm = this.createPriceDiscAdmTable(strFmt("@REX1227", _priceScheduler.parmPriceBasisDate()));
            // <GEERU>
        }
        // </GEERU>

        this.createJounalLink(priceDiscAdm.JournalNum);

        queryRun = new queryRun(_priceScheduler.categoryPriceProductQueryHelper().getQuery());

        LineNum lineNum = 0;
        while (queryRun.next())
        {
            inventTable = queryRun.get(tableNum(InventTable));
            // <GEERU>
            allowToGenerate = true;
            if (isPartCategoryTreeProcessing)
            {
                categoryContainmentLookup = queryRun.get(tableNum(RetailCategoryContainmentLookup));
                for (i = 1; i <= conLen(excludedCategories); ++i)
                {
                    conTmp = conPeek(excludedCategories, i);
                    exclCategory = conPeek(conTmp, 1);
                    inclSubCategory = conPeek(conTmp, 2);

                    //prevent generation agreements for sub-categories which have rules included into the same group and have relation parent-child
                    //child categories must be calculated once
                    if (inclSubCategory && RetailCategoryContainmentLookup::containsCategory(exclCategory, categoryContainmentLookup.ContainedCategory))
                    {
                        allowToGenerate = false;
                        break;
                    }
                }
            }

            if (allowToGenerate)
            {
                // </GEERU>
                this.generatePrice(priceDiscAdm,
                                   inventTable,
                                   inventTableModule,
                                   _priceScheduler.parmCurrencyCode(),
                                   _priceScheduler.parmFromDate(),
                                   _priceScheduler.parmToDate(),
                                   _priceScheduler.parmFindNext(),
                                   _priceScheduler.parmProductSelectionType(),
                                   _priceScheduler.parmPriceBasisDate(),
                                    lineNum
                                  );
                lineNum++;
                // <GEERU>
            }
            // </GEERU>
        }

        this.expirePreviousTAs(_priceScheduler.parmExpirePreviousTAs(), _priceScheduler.parmFromDate(), _priceScheduler.parmExpireJourNum(), priceDiscAdm.JournalNum, _priceScheduler.parmProductSelectionType() == RetailCategoryPriceProductSelectionType::ChangedPriceItems);

        ttscommit;

        return priceDiscAdm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();

        this.PriceBasisInventDimId = InventDim::inventDimIdBlank();
        this.AccountCode = TableGroupAll::GroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBlankPriceBasisInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if price basis invent dim id is blank.
    /// If a value has been assigned to this field, then an error message is displayed,
    /// </summary>
    /// <returns>True if price basis invent dim id is blank; otherwise, false.</returns>
    public boolean checkBlankPriceBasisInventDimId()
    {
        if (this.PriceBasisInventDimId != InventDim::inventDimIdBlank())
        {
            return checkFailed(strFmt("@SYP4880828", fieldPName(RetailCategoryPriceRule, PriceBasisInventDimId), this.PriceBasis));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBlankPriceBasisCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if price basis currency code is blank.
    /// If a value has been assigned to this field, then an error message is displayed,
    /// </summary>
    /// <returns>True if price basis currency code is blank; otherwise, false.</returns>
    public boolean checkBlankPriceBasisCurrencyCode()
    {
        if (this.PriceBasisCurrencyCode)
        {
            return checkFailed(strFmt("@SYP4880828", fieldPName(RetailCategoryPriceRule, PriceBasisCurrencyCode), this.PriceBasis));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBlankExchangeRateType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if exchange rate type is blank.
    /// If a value has been assigned to this field, then an error message is displayed,
    /// </summary>
    /// <returns>True if exchange rate type is blank; otherwise, false.</returns>
    public boolean checkBlankExchangeRateType()
    {
        if (this.ExchangeRateTypeRecId)
        {
            return checkFailed(strFmt("@SYP4880828", fieldPName(RetailCategoryPriceRule, ExchangeRateTypeRecId), this.PriceBasis));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBlankPriceBasisVendAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if price basis vend account is blank.
    /// If a value has been assigned to this field, then an error message is displayed,
    /// </summary>
    /// <returns>True if price basis vend account is blank; otherwise, false.</returns>
    public boolean checkBlankPriceBasisVendAccount()
    {
        if (this.PriceBasisVendAccount)
        {
            return checkFailed(strFmt("@SYP4880828", fieldPName(RetailCategoryPriceRule, PriceBasisVendAccount), this.PriceBasis));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPriceBasisOtherPriceGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if other price group is blank.
    /// If a value has been assigned to this field, then an error message is displayed,
    /// </summary>
    /// <returns>True if other price group is blank; otherwise, false.</returns>
    public boolean checkPriceBasisOtherPriceGroup(boolean _isBlank)
    {
        if (this.PriceBasisOtherPriceGroup && _isBlank)
        {
            return checkFailed(strFmt("@SYP4880828", fieldPName(RetailCategoryPriceRule, PriceBasisOtherPriceGroup), this.PriceBasis));
        }
        else if (this.PriceBasisOtherPriceGroup == '' && !_isBlank)
        {
            return checkFailed(strFmt("@SYS136411", fieldPName(RetailCategoryPriceRule, PriceBasisOtherPriceGroup)));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteForPriceBasis</Name>
				<Source><![CDATA[
    private boolean validateWriteForPriceBasis()
    {
        boolean ret = true;

        switch (this.PriceBasis)
        {
            case RetailPriceBasisType::BaseCost:
            case RetailPriceBasisType::BasePrice:
            case RetailPriceBasisType::CurrentPrice:
                ret = this.checkBlankPriceBasisInventDimId() && ret;
                ret = this.checkBlankPriceBasisCurrencyCode() && ret;
                ret = this.checkBlankExchangeRateType() && ret;
                ret = this.checkBlankPriceBasisVendAccount() && ret;
                ret = this.checkPriceBasisOtherPriceGroup(true) && ret;
                break;

            case RetailPriceBasisType::InventCost:
                ret = this.checkBlankPriceBasisCurrencyCode() && ret;
                ret = this.checkBlankPriceBasisVendAccount() && ret;
                ret = this.checkPriceBasisOtherPriceGroup(true) && ret;
                break;

            case RetailPriceBasisType::LastPurchasePrice:
            case RetailPriceBasisType::PurchasePrice:
                ret = this.checkPriceBasisOtherPriceGroup(true) && ret;
                break;

            case RetailPriceBasisType::OtherPriceGroup:
                ret = this.checkBlankPriceBasisInventDimId() && ret;
                ret = this.checkBlankPriceBasisVendAccount() && ret;
                ret = this.checkPriceBasisOtherPriceGroup(false) && ret;
                break;

            default:
                EventHandlerResult result = new EventHandlerResult();
                this.validateWriteForPriceBasisDelegate(this, result);

                if (result.hasResult())
                {
                    ret = result.hasResult() && ret;
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteForPriceBasisDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for validating the <c>RetailCategoryPriceRule</c> based on a new price basis type.
    /// </summary>
    /// <param name = "_priceRule">Record to be validated.</param>
    /// <param name = "_result">Subscribers can use this to provide the result.</param>
    delegate void validateWriteForPriceBasisDelegate(RetailCategoryPriceRule _priceRule, EventHandlerResult _result)
    {
        // Subscriber will provide proper implementation to this method
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        RetailCategoryPriceRule priceRule;
        boolean ret;

        ret = super();

        switch (this.AccountCode)
        {
            case TableGroupAll::Table:
                if (! CustTable::exist(this.AccountRelation))
                {
                    ret = checkFailed("@SYS4000121");
                }
                break;

            case TableGroupAll::GroupId:
                if (! PriceDiscGroup::exist(ModuleInventCustVend::Cust, PriceGroupType::PriceGroup, this.AccountRelation))
                {
                    ret = checkFailed("@SYS4000121");
                }
                break;

            case TableGroupAll::All:
                if (this.AccountRelation)
                {
                    ret = checkFailed("@SYS4000121");
                }
                break;
        }

        // Validate the fields' values according to price basis type.
        ret = this.validateWriteForPriceBasis() && ret;

        // <GEERU>
        if (this.CategoryPriceRuleGroupCode && this.Category)
        {
            select firstOnly RecId from priceRule
                where  priceRule.CategoryPriceRuleGroupCode == this.CategoryPriceRuleGroupCode
                    && priceRule.Category == this.Category
                    && priceRule.RecId    != this.RecId;
            if (priceRule.RecId)
            {
                warning(strFmt("@SYP4880845", this.CategoryPriceRuleGroupCode)); //just notify user without action
            }

            if (!RetailCategoryPriceRuleGroup::isCategoryAllowed(this.CategoryPriceRuleGroupCode, this.Category))
            {
                ret = checkFailed("@SYP4880846");
            }
        }
        // </GEERU>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowedCategoryHierarchyRoles</Name>
				<Source><![CDATA[
    public static container allowedCategoryHierarchyRoles()
    {
        return [EcoResCategoryNamedHierarchyRole::Retail,
                EcoResCategoryNamedHierarchyRole::RetailChannelNavigation,
                EcoResCategoryNamedHierarchyRole::RetailSpecialGroup,
                EcoResCategoryNamedHierarchyRole::RetailVendorProductHierarchy];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecId</Name>
				<Source><![CDATA[
    public static RetailCategoryPriceRule findRecId(RetailCategoryPriceRuleRecId _recId,
                                                    boolean                      _update = false)
    {
        RetailCategoryPriceRule  rule;

        rule.selectForUpdate(_update);

        if (_recId)
        {
            select firstonly rule
                where rule.RecId == _recId;
        }

        return rule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        if (!this.LineNum)
        {
            this.LineNum = RetailCategoryPriceRule::nextLineNum(this.CategoryPriceRuleGroupCode);
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the next line number for the redeem scheme lines.
    /// </summary>
    /// <param name="_groupCode">
    /// Retail category price rule group code.
    /// </param>
    /// <returns>
    /// The next line number.
    /// </returns>
    public static LineNum nextLineNum(RetailCategoryPriceRuleGroupCode _groupCode)
    {
        RetailCategoryPriceRule categoryPriceRule;
        select maxof(LineNum) from categoryPriceRule
                where categoryPriceRule.CategoryPriceRuleGroupCode == _groupCode;

        return categoryPriceRule.LineNum + 1.0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Retail</ConfigurationKey>
	<DeveloperDocumentation>@REX1216</DeveloperDocumentation>
	<Label>@REX1215</Label>
	<TitleField1>AccountCode</TitleField1>
	<TitleField2>AccountRelation</TitleField2>
	<CacheLookup>Found</CacheLookup>
	<Modules>Merchandising</Modules>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>RetailCategoryPriceJournalLink</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>RetailCategoryPriceJournalLink</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountPercent</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Category</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PriceBasis</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PriceSetupType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SmartRoundingGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UnitId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryPriceRuleGroupCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Scope</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PriceBasisVendAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PriceBasisCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRateTypeRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountPercent</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Category</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PriceBasis</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PriceSetupType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SmartRoundingGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UnitId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendAccount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PriceBasis</Name>
			<Label>@SYP4880827</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PriceBasisCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRateTypeRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PriceBasisVendAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PriceBasisOtherPriceGroup</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AccountCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PriceDiscAccountCode</ExtendedDataType>
			<EnumType>TableGroupAll</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountRelation</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>PriceDiscAccountRelation</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AmountPercent</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAmountPercent</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Category</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PriceBasis</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>RetailPriceBasisType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PriceSetupType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>RetailCategoryPriceSetupType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SmartRoundingGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PriceDiscSmartRoundingGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>UnitId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>UnitOfMeasureSymbol</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VendAccount</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>VendAccount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CategoryPriceRuleGroupCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailCategoryPriceRuleGroupCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ExchangeRateTypeRecId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>ExchangeRateTypeRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PriceBasisCurrencyCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@SYP4880821</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PriceBasisInventDimId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PriceBasisOtherPriceGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>PriceGroupId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@SYP4880832</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PriceBasisVendAccount</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>VendAccount</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@SYP4880823</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Scope</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<EnumType>RetailPriceCategoryRuleScope</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LineNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LineNum</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>PriceRuleGroupIdx</Name>
			<Fields>
				<AxTableIndexField>
					<DataField>CategoryPriceRuleGroupCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNum</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PriceBasisInventDim</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>PriceBasisInventDimId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Role>RetailCategoryPriceRule</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountCode</Name>
					<Field>AccountCode</Field>
					<ValueStr>TableGroupAll::Table</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>EcoResCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>EcoResCategory</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Category</Name>
					<Field>Category</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PriceDiscGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PriceDiscGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustDiscGroup</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>RetailCategoryPriceRule</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Type_Extern</Name>
					<RelatedField>Type</RelatedField>
					<ValueStr>PriceGroupType::PriceGroup</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Module_Extern</Name>
					<RelatedField>Module</RelatedField>
					<ValueStr>ModuleInventCustVend::Cust</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountCode</Name>
					<Field>AccountCode</Field>
					<ValueStr>TableGroupAll::GroupId</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>GroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PriceDiscSmartRoundingGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PriceDiscSmartRoundingGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SmartRoundingGroup</Name>
					<Field>SmartRoundingGroup</Field>
					<RelatedField>GroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>GroupId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>UnitOfMeasure</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UnitOfMeasure</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>UnitId</Name>
					<Field>UnitId</Field>
					<RelatedField>Symbol</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>SymbolIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VendTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendAccount</Name>
					<Field>VendAccount</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PriceBasisCurrencyCode</Name>
					<Field>PriceBasisCurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ExchangeRateType</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ExchangeRateType</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ExchangeRateTypeRecId</Name>
					<Field>ExchangeRateTypeRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PriceBasisInventDimId</Name>
					<Field>PriceBasisInventDimId</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PriceDiscGroupOther</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PriceDiscGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Module</Name>
					<RelatedField>Module</RelatedField>
					<ValueStr>ModuleInventCustVend::Cust</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Type</Name>
					<RelatedField>Type</RelatedField>
					<ValueStr>PriceGroupType::PriceGroup</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PriceBasisOtherPriceGroup</Name>
					<Field>PriceBasisOtherPriceGroup</Field>
					<RelatedField>GroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>PriceDiscGroup</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RetailCategoryPriceRuleGroupFK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>RetailCategoryPriceRuleGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CategoryPriceRuleGroupCode</Name>
					<Field>CategoryPriceRuleGroupCode</Field>
					<RelatedField>Code</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VendTablePriceBasis</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendTablePriceBasis</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>RetailCategoryPriceRule</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PriceBasisVendAccount</Name>
					<Field>PriceBasisVendAccount</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>