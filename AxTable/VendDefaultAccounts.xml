<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>VendDefaultAccounts</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class VendDefaultAccounts extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountName</Name>
				<Source><![CDATA[
    display AccountName accountName()
    {
        AccountName     accountName;

        switch (this.LedgerJournalACType)
        {
            case LedgerJournalACType::Ledger :
                accountName = MainAccount::findByLedgerDimension(this.LedgerDimension).localizedName();
                break;

            case LedgerJournalACType::Cust :
                accountName = CustTable::findByLedgerDimension(this.LedgerDimension).name();
                break;

            case LedgerJournalACType::Vend :
                accountName = VendTable::findByLedgerDimension(this.LedgerDimension).name();
                break;

            case LedgerJournalACType::Project :
                accountName = ProjTable::findByLedgerDimension(this.LedgerDimension).Name;
                break;

            case LedgerJournalACType::FixedAssets :
                accountName = AssetTable::findByLedgerDimension(this.LedgerDimension).Name;
                break;

            case LedgerJournalACType::Bank :
                accountName = BankAccountTable::findByLedgerDimension(this.LedgerDimension).Name;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return accountName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNumber</Name>
				<Source><![CDATA[
    display VendAccount accountNumber()
    {
        VendAccount                             vendAccount;
        DimensionAttributeValueGroupCombination dimAttributeValueGroupCombo;
        DimensionAttributeLevelValue            dimAttributeLevelValue;
        DimensionAttributeValue                 dimAttributeValue;
        MainAccount                             mainAccount;

        switch (this.LedgerJournalACType)
        {
            case LedgerJournalACType::Ledger :
                select firstonly MainAccountId from mainAccount where
                    mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current()
                    exists join dimAttributeValue where
                        dimAttributeValue.EntityInstance == mainAccount.RecId
                    exists join dimAttributeLevelValue where
                        dimAttributeLevelValue.DimensionAttributeValue == dimAttributeValue.RecId
                    exists join dimAttributeValueGroupCombo where
                        dimAttributeValueGroupCombo.DimensionAttributeValueGroup == dimAttributeLevelValue.DimensionAttributeValueGroup &&
                        dimAttributeValueGroupCombo.DimensionAttributeValueCombination == this.LedgerDimension;

                vendAccount = mainAccount.MainAccountId;
                break;

            case LedgerJournalACType::Cust :
                vendAccount = CustTable::findByLedgerDimension(this.LedgerDimension).AccountNum;
                break;

            case LedgerJournalACType::Vend :
                vendAccount = VendTable::findByLedgerDimension(this.LedgerDimension).AccountNum;
                break;

            case LedgerJournalACType::Project :
                vendAccount = ProjTable::findByLedgerDimension(this.LedgerDimension).ProjId;
                break;

            case LedgerJournalACType::FixedAssets :
                vendAccount = AssetTable::findByLedgerDimension(this.LedgerDimension).AssetId;
                break;

            case LedgerJournalACType::Bank :
                vendAccount = BankAccountTable::findByLedgerDimension(this.LedgerDimension).AccountNum;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return vendAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccount</Name>
				<Source><![CDATA[
    public DimensionDisplayValue parmAccount(DimensionDisplayValue _account = '', LedgerJournalACType _accountType = this.LedgerJournalACType)
    {
        DimensionAttributeValueCombination  ledgerDimension;
        DimensionDisplayValue               account;

        if (!prmisDefault(_accountType))
        {
            this.LedgerJournalACType = _accountType;
        }

        // If account has been changed, update the backing ledger dimension value
        if (!prmisDefault(_account))
        {
            if (_account)
            {
                if (_accountType == LedgerJournalACType::Ledger)
                {
                    this.LedgerDimension = LedgerDefaultAccountHelper::getDefaultAccountFromMainAccountId(_account);
                }
                else
                {
                    this.LedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_account, _accountType);
                }
                account = _account;
            }
            else
            {
                account = '';
                this.LedgerDimension = 0;
            }
        }
        else if (this.LedgerDimension)
        {
            // If the account has not been changed, then pull the value from ledger dimension as the master
            select firstonly DisplayValue from ledgerDimension where ledgerDimension.RecId == this.LedgerDimension;
            account = ledgerDimension.DisplayValue;
        }

        return account;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimension</Name>
				<Source><![CDATA[
    public DimensionDynamicDefaultAccount parmLedgerDimension(DimensionDynamicDefaultAccount _ledgerDimension = this.LedgerDimension)
    {
        this.LedgerDimension = _ledgerDimension;

        return this.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    public static boolean checkExist(RefRecId _account )
    {
        boolean ret = true;

        if (!VendDefaultAccounts::exist(_account))
        {
            ret = checkFailed(strFmt(VendDefaultAccounts::txtNotExist(), _account));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAccounts</Name>
				<Source><![CDATA[
    public static boolean deleteAccounts(
        container           _accountNumbers,
        VendAccount         _vendAccount,
        VendGroupId         _vendGroupId,
        LedgerJournalACType _ledgerJournalACType)
    {
        VendDefaultAccounts                 vendDefaultAccounts;
        AccountNum                          accountNum;
        int                                 i;
        DimensionAttributeValueCombination  dimAttrValueCombo;

        ttsbegin;

        for (i = conLen(_accountNumbers); i; i--)
        {
            accountNum = conPeek(_accountNumbers, i);

            delete_from vendDefaultAccounts
                where vendDefaultAccounts.VendAccount           == _vendAccount
                    && vendDefaultAccounts.VendGroup             == _vendGroupId
                    && vendDefaultAccounts.LedgerJournalACType   == _ledgerJournalACType
                exists join RecId from dimAttrValueCombo where
                    dimAttrValueCombo.RecId == vendDefaultAccounts.LedgerDimension &&
                    dimAttrValueCombo.DisplayValue == accountNum;
        }

        select firstonly RecId from vendDefaultAccounts
            where vendDefaultAccounts.IsDefault
               && vendDefaultAccounts.VendAccount           == _vendAccount
               && vendDefaultAccounts.VendGroup             == _vendGroupId
               && vendDefaultAccounts.LedgerJournalACType   == _ledgerJournalACType;

        ttscommit;

        return vendDefaultAccounts ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    public static boolean exist(RefRecId _account)
    {
        boolean                             found;
        VendDefaultAccounts                 vendDefaultAccounts;
        DimensionAttributeValueCombination  dimAttrValueCombo;

        select firstonly RecId from vendDefaultAccounts
            join RecId from dimAttrValueCombo where
                dimAttrValueCombo.RecId == vendDefaultAccounts.LedgerDimension &&
                dimAttrValueCombo.DisplayValue == LedgerDimensionFacade::getDisplayValueForLedgerDimension(_account);

        found = (vendDefaultAccounts.RecId != 0);

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existDefault</Name>
				<Source><![CDATA[
    public static boolean existDefault(VendAccount _accountNum)
    {
        VendTable   vendTable;

        vendTable = VendTable::find(_accountNum);

        return (VendDefaultAccounts::existVendAccount(vendTable.AccountNum) ||
                VendDefaultAccounts::existVendGroup(vendTable.VendGroup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>existDefaultForType</Name>
				<Source><![CDATA[
    public static boolean existDefaultForType(VendAccount   _accountNum,
                                       LedgerJournalACType  _ledgerJournalACType,
                                       CompanyId            _companyId = curext())
    {
        VendTable   vendTable;
        CompanyId   companyId;
        boolean     ret = false;

        if (!_companyId)
        {
            companyId = curext();
        }
        else
        {
            companyId = _companyId;
            if (! xDataArea::exist(companyId))
            {
                throw error(strFmt("@SYS10666", companyId));
            }
        }

        changecompany(companyId)
        {
            vendTable = VendTable::find(_accountNum);

            ret =  VendDefaultAccounts::existVendAccountForType(_accountNum, _ledgerJournalACType) ||
                   VendDefaultAccounts::existVendGroupForType(vendTable.VendGroup, _ledgerJournalACType);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existJustOne</Name>
				<Source><![CDATA[
    public static boolean existJustOne(VendAccount _vendAccount)
    {
        return (select count(RecId) from vendDefaultAccounts
                    where vendDefaultAccounts.VendAccount == _vendAccount).RecId == 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existJustOneGroup</Name>
				<Source><![CDATA[
    public static boolean existJustOneGroup(VendGroupId _vendgroup)
    {
        return (select count(RecId) from vendDefaultAccounts
                    where vendDefaultAccounts.VendGroup == _vendgroup).RecId == 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existMoreOnVendAccount</Name>
				<Source><![CDATA[
    public static boolean existMoreOnVendAccount(VendAccount _vendAccount)
    {
        return VendDefaultAccounts::numOfVendAccount(_vendAccount) > 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existVendAccount</Name>
				<Source><![CDATA[
    public static boolean existVendAccount(VendAccount   _accountNum)
    {
        return _accountNum && (select firstonly vendDefaultAccounts
                               where vendDefaultAccounts.VendAccount == _accountNum).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existVendAccountForType</Name>
				<Source><![CDATA[
    public static boolean existVendAccountForType(VendAccount          _accountNum,
                                           LedgerJournalACType  _ledgerJournalACType)
    {
        return _accountNum && (select firstonly vendDefaultAccounts
                               where vendDefaultAccounts.VendAccount            == _accountNum &&
                                     vendDefaultAccounts.LedgerJournalACType    == _ledgerJournalACType).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existVendGroup</Name>
				<Source><![CDATA[
    public static boolean existVendGroup(VendGroupId   _groupId)
    {
        return _groupId && (select vendDefaultAccounts
                               where vendDefaultAccounts.VendGroup == _groupId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existVendGroupForType</Name>
				<Source><![CDATA[
    public static boolean existVendGroupForType(VendGroupId   _groupId,
                                         LedgerJournalACType  _ledgerJournalACType)
    {
        return _groupId && (select vendDefaultAccounts
                               where vendDefaultAccounts.VendGroup              == _groupId &&
                                     vendDefaultAccounts.LedgerJournalACType    == _ledgerJournalACType ).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    public static VendDefaultAccounts find(
        RefRecId  _account,
        boolean                 _forupdate = false,
        ConcurrencyModel        _concurrencyModel = ConcurrencyModel::Auto)
    {
        VendDefaultAccounts                 vendDefaultAccounts;
        DimensionAttributeValueCombination  dimAttrValueCombo;

        vendDefaultAccounts.selectForUpdate(_forupdate);
        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            vendDefaultAccounts.concurrencyModel(_concurrencyModel);
        }

        select firstonly
            vendDefaultAccounts
            join RecId from dimAttrValueCombo where
                dimAttrValueCombo.RecId == vendDefaultAccounts.LedgerDimension &&
                dimAttrValueCombo.DisplayValue == LedgerDimensionFacade::getDisplayValueForLedgerDimension(_account);

        return vendDefaultAccounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDefault</Name>
				<Source><![CDATA[
    public static VendDefaultAccounts findDefault(VendAccount _accountNum, CompanyId _companyId = curext(), VendGroupId _vendGroupId = '')
    {
        VendTable           vendTable;
        CompanyId           companyId;
        VendDefaultAccounts vendDefaultAccounts;

        if (!_companyId)
        {
            companyId = curext();
        }
        else
        {
            companyId = _companyId;
            if (! xDataArea::exist(companyId))
            {
                throw error(strFmt("@SYS10666", companyId));
            }
        }

        changecompany(companyId)
        {
            if (_vendGroupId)
            {
                vendTable.AccountNum = _accountNum;
                vendTable.VendGroup  = _vendGroupId;
            }
            else
            {
                vendTable = VendTable::find(_accountNum);
            }

            if (VendDefaultAccounts::existVendAccount(_accountNum))
            {
                if (VendDefaultAccounts::existJustOne(_accountNum))
                {
                    vendDefaultAccounts = VendDefaultAccounts::findVend(_accountNum);
                }
                else
                {
                    select firstonly vendDefaultAccounts
                        where vendDefaultAccounts.VendAccount == _accountNum && vendDefaultAccounts.IsDefault;
                }
            }
            else if (VendDefaultAccounts::existVendGroup(vendTable.VendGroup))
            {
                if (VendDefaultAccounts::existJustOneGroup(vendTable.VendGroup))
                {
                    vendDefaultAccounts = VendDefaultAccounts::findVendGroup(vendTable.VendGroup);
                }
                else
                {
                    select firstonly vendDefaultAccounts
                        where vendDefaultAccounts.VendGroup == vendTable.VendGroup && vendDefaultAccounts.IsDefault;
                }
            }
        }

        return vendDefaultAccounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVend</Name>
				<Source><![CDATA[
    public static VendDefaultAccounts findVend(VendAccount  _vendAccount,
                                        boolean             _forUpdate = false)
    {
        VendDefaultAccounts     vendDefaultAccounts;

        if (_vendAccount)
        {
            vendDefaultAccounts.selectForUpdate(_forUpdate);

            select firstonly vendDefaultAccounts
                where vendDefaultAccounts.VendAccount == _vendAccount;
        }
        return vendDefaultAccounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVendGroup</Name>
				<Source><![CDATA[
    public static VendDefaultAccounts findVendGroup(VendGroupId  _groupId,
                                             boolean             _forUpdate = false)
    {
        VendDefaultAccounts     vendDefaultAccounts;

        if (_groupId)
        {
            vendDefaultAccounts.selectForUpdate(_forUpdate);

            select firstonly vendDefaultAccounts
                where vendDefaultAccounts.VendGroup == _groupId;
        }
        return vendDefaultAccounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>notSelectedBankAccountList</Name>
				<Source><![CDATA[
    public static List notSelectedBankAccountList()
    {
        BankAccountTable    bankAccountTable;
        List                notSelectedFieldList    = new List(Types::Container);

        while select AccountID, Name from bankAccountTable where bankAccountTable.BankAccountStatus == BankAccountHoldStatus::ActiveForAllTransactions
        {
            notSelectedFieldList.addEnd([bankAccountTable.AccountID, bankAccountTable.Name]);
        }
        return notSelectedFieldList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>notSelectedCustAccountList</Name>
				<Source><![CDATA[
    public static List notSelectedCustAccountList()
    {
        CustTable           custTable;
        List                notSelectedFieldList    = new List(Types::Container);

        while select AccountNum, Party from custTable
        {
            notSelectedFieldList.addEnd([custTable.AccountNum, custTable.name()]);
        }
        return notSelectedFieldList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>notSelectedFixedAssetAccountList</Name>
				<Source><![CDATA[
    public static List notSelectedFixedAssetAccountList()
    {
        AssetTable          assetTable;
        List                notSelectedFieldList    = new List(Types::Container);

        while select AssetId, Name from assetTable
        {
            notSelectedFieldList.addEnd([assetTable.AssetId, assetTable.Name]);
        }
        return notSelectedFieldList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>notSelectedLedgerAccountList</Name>
				<Source><![CDATA[
    public static List notSelectedLedgerAccountList()
    {
        MainAccount                         mainAccount;
        DimensionAttributeValue             dimAttributeValue;
        DimensionAttributeValueCombination  dimAttributeValueCombo;
        VendLedgerAccounts                  vendLedgerAccounts;
        List                                notSelectedFieldList    = new List(Types::Container);
        recId                               mainAccountDimAttribute = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);

        // Allow all posting types, so long as they are not closed
        // Only add the combination if it doesn't exist or doesn't exist as a ledger dimension on the vendLedgerAccounts table
        while select MainAccountId, RecId, Type from mainAccount order by MainAccountId where
            mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current() &&
            mainAccount.Type != DimensionLedgerAccountType::Total
            outer join RecId from dimAttributeValueCombo where
                dimAttributeValueCombo.MainAccount == mainAccount.RecId &&
                dimAttributeValueCombo.LedgerDimensionType == LedgerDimensionType::DefaultAccount
            outer join RecId from vendLedgerAccounts where
                (vendLedgerAccounts.SummaryLedgerDimension == dimAttributeValueCombo.RecId ||
                vendLedgerAccounts.ClearingLedgerDimension == dimAttributeValueCombo.RecId ||
                vendLedgerAccounts.PurchasingLedgerDimension == dimAttributeValueCombo.RecId ||
                vendLedgerAccounts.PurchasingOffsetLedgerDimension == dimAttributeValueCombo.RecId)
            notexists join dimAttributeValue where
                dimAttributeValue.DimensionAttribute == mainAccountDimAttribute &&
                dimAttributeValue.EntityInstance == mainAccount.RecId &&
                (dimAttributeValue.IsSuspended == true ||
                 dimAttributeValue.IsBlockedForManualEntry == true)
        {
            if (!vendLedgerAccounts)
            {
                DimensionAttributeValue dimensionAttributeValue = DimensionAttributeValue::findByDimensionAttributeAndEntityInst(
                    mainAccountDimAttribute,
                    mainAccount.RecId);

                if (!dimensionAttributeValue
                    || (!dimAttributeValue.IsSuspended && !MainAccount::isBlockedForManualEntryByMainAccountRecId(mainAccount.RecId)))
                {
                    notSelectedFieldList.addEnd([mainAccount.MainAccountId, MainAccount::getLocalizedName(mainAccount.RecId), mainAccount.Type]);
                }
            }
        }
        return notSelectedFieldList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>notSelectedProjectAccountList</Name>
				<Source><![CDATA[
    public static List notSelectedProjectAccountList()
    {
        ProjTable           projTable;
        List                notSelectedFieldList    = new List(Types::Container);

        while select ProjId, Name from projTable
            where ! projTable.Header
                 && projTable.Type    != ProjType::Time
                 && projTable.Status  != ProjStatus::Completed
        {
            notSelectedFieldList.addEnd([projTable.ProjId, projTable.Name]);
        }

        return notSelectedFieldList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>notSelectedVendAccountList</Name>
				<Source><![CDATA[
    public static List notSelectedVendAccountList()
    {
        VendTable           vendTable;
        List                notSelectedFieldList    = new List(Types::Container);

        while select AccountNum,Party from vendTable
        {
            notSelectedFieldList.addEnd([vendTable.AccountNum, vendTable.name()]);
        }
        return notSelectedFieldList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfVendAccount</Name>
				<Source><![CDATA[
    public static Counter numOfVendAccount(VendAccount _vendAccount)
    {
        return any2int((select count(RecId) from vendDefaultAccounts
                    where vendDefaultAccounts.VendAccount == _vendAccount).RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>packedNotSelectedAccountList</Name>
				<Source><![CDATA[
    public static container packedNotSelectedAccountList(LedgerJournalACType _ledgerJournalACType)
    {
        return VendDefaultAccounts::packedNotSelectedGroupList(_ledgerJournalACType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>packedNotSelectedGroupList</Name>
				<Source><![CDATA[
    public static container packedNotSelectedGroupList(LedgerJournalACType _ledgerJournalACType)
    {
        container       ret;

        switch (_ledgerJournalACType)
        {
            case LedgerJournalACType::Ledger        :
                ret = VendDefaultAccounts::notSelectedLedgerAccountList().pack();
                break;

            case LedgerJournalACType::Cust          :
                ret = VendDefaultAccounts::notSelectedCustAccountList().pack();
                break;

            case LedgerJournalACType::Vend          :
                ret = VendDefaultAccounts::notSelectedVendAccountList().pack();
                break;

            case LedgerJournalACType::Project       :
                ret = VendDefaultAccounts::notSelectedProjectAccountList().pack();
                break;

            case LedgerJournalACType::FixedAssets   :
                ret = VendDefaultAccounts::notSelectedFixedAssetAccountList().pack();
                break;

            case LedgerJournalACType::Bank          :
                ret = VendDefaultAccounts::notSelectedBankAccountList().pack();
                break;

            default:
                ret = new List(Types::Container).pack();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packedSelectedAccountList</Name>
				<Source><![CDATA[
    public static container packedSelectedAccountList(VendAccount _vendAccount, LedgerJournalACType _ledgerJournalACType)
    {
        return VendDefaultAccounts::selectedAccountList(_vendAccount, _ledgerJournalACType).pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>packedSelectedGroupList</Name>
				<Source><![CDATA[
    public static container packedSelectedGroupList(VendGroupId  _vendGroup,
                                                     LedgerJournalACType _ledgerJournalACType)
    {
        return VendDefaultAccounts::selectedGroupList(_vendGroup, _ledgerJournalACType).pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectedAccountList</Name>
				<Source><![CDATA[
    public static List selectedAccountList(VendAccount _vendAccount, LedgerJournalACType _ledgerJournalACType)
    {
        VendDefaultAccounts             vendDefaultAccounts;
        DimensionAttributeValueCombination  dimAttributeValueCombo;
        VendTable                       vendTable           = VendTable::find(_vendAccount);
        List                            selectedAccountList = new List(Types::Container);

        if (_ledgerJournalACType == LedgerJournalACType::Ledger)
        {
            while select vendDefaultAccounts
                order by VendAccount, Position where
                vendDefaultAccounts.VendAccount == _vendAccount &&
                vendDefaultAccounts.LedgerJournalACType == _ledgerJournalACType
                join DisplayValue from dimAttributeValueCombo order by DisplayValue where
                    dimAttributeValueCombo.RecId == vendDefaultAccounts.LedgerDimension
            {
                selectedAccountList.addEnd([vendDefaultAccounts.parmAccount(),
                                            vendDefaultAccounts.accountName(),
                                            vendDefaultAccounts.DimensionLedgerAccountType,
                                            vendDefaultAccounts.IsDefault]);
            }
        }
        else
        {
            while select vendDefaultAccounts // the current account
                order by VendAccount, Position
                where vendDefaultAccounts.VendAccount         == _vendAccount
                   && vendDefaultAccounts.LedgerJournalACType == _ledgerJournalACType
            {
                selectedAccountList.addEnd([vendDefaultAccounts.parmAccount(),
                                            vendDefaultAccounts.accountName(),
                                            vendDefaultAccounts.IsDefault]);
            }
        }
        if (selectedAccountList.empty())
        {
            selectedAccountList = VendDefaultAccounts::selectedGroupList(vendTable.VendGroup, _ledgerJournalACType);
        }
        return selectedAccountList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectedGroupList</Name>
				<Source><![CDATA[
    public static List selectedGroupList(VendGroupId _vendGroup, LedgerJournalACType _ledgerJournalACType)
    {
        VendDefaultAccounts             vendDefaultAccounts;
        DimensionAttributeValueCombination  dimAttributeValueCombo;
        List                            selectedAccountList = new List(Types::Container);

        if (_ledgerJournalACType == LedgerJournalACType::Ledger)
        {
            while select vendDefaultAccounts
                order by VendAccount, Position where
                vendDefaultAccounts.VendGroup == _vendGroup &&
                vendDefaultAccounts.LedgerJournalACType == _ledgerJournalACType
                join DisplayValue from dimAttributeValueCombo order by DisplayValue where
                    dimAttributeValueCombo.RecId == vendDefaultAccounts.LedgerDimension
            {
                selectedAccountList.addEnd([vendDefaultAccounts.parmAccount(),
                                            vendDefaultAccounts.accountName(),
                                            vendDefaultAccounts.DimensionLedgerAccountType,
                                            vendDefaultAccounts.IsDefault]);
            }
        }
        else
        {
            while select vendDefaultAccounts
                order by VendGroup, Position
                where vendDefaultAccounts.VendGroup             == _vendGroup
                   && vendDefaultAccounts.LedgerJournalACType   == _ledgerJournalACType
            {
                selectedAccountList.addEnd([vendDefaultAccounts.parmAccount(),
                                            vendDefaultAccounts.accountName(),
                                            vendDefaultAccounts.IsDefault]);
            }
        }
        return selectedAccountList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    public static TxtNotExist txtNotExist()
    {
        return "@SYS102217";
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeFromPackedAccount</Name>
				<Source><![CDATA[
    public static void writeFromPackedAccount(container      _packedAccount,
                                              LedgerJournalACType   _ledgerJournalACType,
                                              VendAccount           _vendAccount = '',
                                              boolean               _delete = true)
    {
        VendDefaultAccounts     vendDefaultAccounts;
        MainAccount             mainAccount;
        CustTable               custTable;
        VendTable               vendTable;
        ProjTable               projTable;
        AssetTable              assetTable;
        BankAccountTable        bankAccountTable;
        int                     i = 0;
        int                     idxPosition;
        DimensionDisplayValue   defaultAccountNumber;

        ttsbegin;

        select firstonly vendDefaultAccounts
            where vendDefaultAccounts.VendAccount           == _vendAccount         &&
                  vendDefaultAccounts.LedgerJournalACType   == _ledgerJournalACType &&
                  vendDefaultAccounts.IsDefault;

        if (vendDefaultAccounts)
        {
            defaultAccountNumber = vendDefaultAccounts.parmAccount();
        }
        else
        {
            select firstonly vendDefaultAccounts
                where vendDefaultAccounts.VendGroup             == VendTable::groupId(_vendAccount)         &&
                      vendDefaultAccounts.LedgerJournalACType   == _ledgerJournalACType &&
                      vendDefaultAccounts.IsDefault;

            if (vendDefaultAccounts)
            {
                defaultAccountNumber = vendDefaultAccounts.parmAccount();
            }
        }

        if (_delete)
        {
            delete_from vendDefaultAccounts
                where vendDefaultAccounts.VendAccount           == _vendAccount &&
                      vendDefaultAccounts.LedgerJournalACType   == _ledgerJournalACType;
        }

        idxPosition = (select maxof(Position) from vendDefaultAccounts).Position;

        for (i=conLen(_packedAccount); i; i--)
        {
            vendDefaultAccounts.clear();

            switch (_ledgerJournalACType)
            {
                case LedgerJournalACType::Ledger        :
                    mainAccount                             = MainAccount::findByMainAccountId(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(mainAccount.MainAccountId, _ledgerJournalACType);
                    break;

                case LedgerJournalACType::Cust          :
                    custTable                               = CustTable::find(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(custTable.AccountNum, _ledgerJournalACType);
                    break;

                case LedgerJournalACType::Vend          :
                    vendTable                               = VendTable::find(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(vendTable.AccountNum, _ledgerJournalACType);
                    break;

                case LedgerJournalACType::Project       :
                    projTable                               = ProjTable::find(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(projTable.ProjId, _ledgerJournalACType);
                    break;

                case LedgerJournalACType::FixedAssets   :
                    assetTable                              = AssetTable::find(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(assetTable.AssetId, _ledgerJournalACType);
                    break;

                case LedgerJournalACType::Bank          :
                    bankAccountTable                        = BankAccountTable::find(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(bankAccountTable.AccountID, _ledgerJournalACType);
                    break;
            }

            vendDefaultAccounts.LedgerJournalACType = _ledgerJournalACType;
            vendDefaultAccounts.VendAccount         = _vendAccount;
            vendDefaultAccounts.Position            = idxPosition + i;
            vendDefaultAccounts.IsDefault           = defaultAccountNumber == vendDefaultAccounts.parmAccount();
            vendDefaultAccounts.write();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeFromPackedGroup</Name>
				<Source><![CDATA[
    public static void writeFromPackedGroup(container    _packedAccount,
                                            LedgerJournalACType _ledgerJournalACType,
                                            VendGroupId         _vendGroup,
                                            boolean             _delete = true)
    {
        VendDefaultAccounts     vendDefaultAccounts;
        MainAccount             mainAccount;
        CustTable               custTable;
        VendTable               vendTable;
        ProjTable               projTable;
        AssetTable              assetTable;
        BankAccountTable        bankAccountTable;
        int                     i = 0;
        int                     idxPosition;
        VendDefaultAccounts     defaultVendDefaultAccounts;

        ttsbegin;

        select firstonly defaultVendDefaultAccounts
            where defaultVendDefaultAccounts.VendGroup             == _vendGroup         &&
                  defaultVendDefaultAccounts.LedgerJournalACType   == _ledgerJournalACType &&
                  defaultVendDefaultAccounts.IsDefault;

        if (!defaultVendDefaultAccounts && VendDefaultAccounts::existJustOneGroup(_vendGroup))
        {
            defaultVendDefaultAccounts = VendDefaultAccounts::findVendGroup(_vendGroup);
        }

        if (_delete)
        {
            delete_from vendDefaultAccounts
                where vendDefaultAccounts.VendGroup             == _vendGroup &&
                      vendDefaultAccounts.LedgerJournalACType   == _ledgerJournalACType;
        }

        idxPosition = (select maxof(Position) from vendDefaultAccounts).Position;

        for (i=conLen(_packedAccount); i; i--)
        {
            vendDefaultAccounts.clear();
            switch (_ledgerJournalACType)
            {
                case LedgerJournalACType::Ledger        :
                    mainAccount                             = MainAccount::findByMainAccountId(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(mainAccount.MainAccountId, _ledgerJournalACType);
                    break;

                case LedgerJournalACType::Cust          :
                    custTable                               = CustTable::find(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(custTable.AccountNum, _ledgerJournalACType);
                    break;

                case LedgerJournalACType::Vend          :
                    vendTable                               = VendTable::find(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(vendTable.AccountNum, _ledgerJournalACType);
                    break;

                case LedgerJournalACType::Project       :
                    projTable                               = ProjTable::find(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(projTable.ProjId, _ledgerJournalACType);
                    break;

                case LedgerJournalACType::FixedAssets   :
                    assetTable                              = AssetTable::find(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(assetTable.AssetId, _ledgerJournalACType);
                    break;

                case LedgerJournalACType::Bank          :
                    bankAccountTable                        = BankAccountTable::find(conPeek(_packedAccount, i));
                    vendDefaultAccounts.parmAccount(bankAccountTable.AccountID, _ledgerJournalACType);
                    break;
            }

            vendDefaultAccounts.LedgerJournalACType = _ledgerJournalACType;
            vendDefaultAccounts.VendGroup   = _vendGroup;
            vendDefaultAccounts.Position    = idxPosition + i;
            vendDefaultAccounts.IsDefault   = defaultVendDefaultAccounts.LedgerDimension     == vendDefaultAccounts.LedgerDimension &&
                                              defaultVendDefaultAccounts.LedgerJournalACType == vendDefaultAccounts.LedgerJournalACType;
            vendDefaultAccounts.write();
        }

        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasic</ConfigurationKey>
	<DeveloperDocumentation>@SYS127242</DeveloperDocumentation>
	<EntityRelationshipType>Relationship</EntityRelationshipType>
	<FormRef>VendDefaultLedgerListPanel</FormRef>
	<Label>@SYS78115</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>LedgerJournalACType</TitleField1>
	<TitleField2>VendAccount</TitleField2>
	<CacheLookup>Found</CacheLookup>
	<ClusteredIndex>VendAccountpositionIdx</ClusteredIndex>
	<CreateRecIdIndex>No</CreateRecIdIndex>
	<DataSharingType>Single</DataSharingType>
	<Modules>Vendor</Modules>
	<PrimaryIndex>VendAccountpositionIdx</PrimaryIndex>
	<TableContents>DefaultData</TableContents>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Position</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DimensionLedgerAccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerJournalACType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsDefault</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AllFields</Name>
			<Label>@SYS11696</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Position</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DimensionLedgerAccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerJournalACType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsDefault</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DimensionLedgerAccountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>DimensionLedgerAccountType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsDefault</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS27587</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimension</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDynamicDefaultAccount</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LedgerJournalACType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>LedgerJournalACType</EnumType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>Position</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PositiveNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VendAccount</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>VendAccount</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VendGroup</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VendGroupId</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>VendAccountpositionIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<ConfigurationKey>LedgerBasic</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>VendAccount</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Position</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>VendGroupPositionIdx</Name>
			<Fields>
				<AxTableIndexField>
					<DataField>VendGroup</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Position</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>LedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DimensionAttributeValueCombination</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DimensionAttributeValueCombination_VendDefaultAccounts</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimension</Name>
					<Field>LedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VendGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>VendGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendGroup</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>VendDefaultAccounts</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendGroup</Name>
					<SourceEDT>VendGroupId</SourceEDT>
					<Field>VendGroup</Field>
					<RelatedField>VendGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>GroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VendTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>VendTable</RelatedTableRole>
			<RelationshipType>Composition</RelationshipType>
			<Role>VendDefaultAccounts</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendAccount</Name>
					<SourceEDT>VendAccount</SourceEDT>
					<Field>VendAccount</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>