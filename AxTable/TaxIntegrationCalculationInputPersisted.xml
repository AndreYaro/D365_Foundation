<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxIntegrationCalculationInputPersisted</Name>
	<SourceCode>
		<Declaration><![CDATA[
using TaxServiceAPI = Microsoft.Dynamics.TaxCalculation.ApiContracts;

public class TaxIntegrationCalculationInputPersisted extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>findByHeadingTable</Name>
				<Source><![CDATA[
    public static TaxIntegrationCalculationInputPersisted findByHeadingTable(
        RefTableId _headingTableId,
        RefRecId _headingRecId,
        TaxModuleType _taxModuleType,
        boolean _forUpdate = false)
    {
        TaxIntegrationCalculationInputPersisted taxCalculationInputPersisted;

        if (_headingTableId && _headingRecId)
        {
            taxCalculationInputPersisted.selectForUpdate(_forUpdate);

            select firstonly taxCalculationInputPersisted
                where taxCalculationInputPersisted.HeadingTableId == _headingTableId
                    && taxCalculationInputPersisted.HeadingRecId == _headingRecId
                    && taxCalculationInputPersisted.Source == _taxModuleType;
        }

        return taxCalculationInputPersisted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByJournalTable</Name>
				<Source><![CDATA[
    public static TaxIntegrationCalculationInputPersisted findByJournalTable(
        RefTableId _journalTableId,
        RefRecId _journalRecId,
        TaxModuleType _taxModuleType,
        boolean _isReverse = false,
        boolean _forUpdate = false)
    {
        TaxIntegrationCalculationInputPersisted taxCalculationInputPersisted;

        if (_journalTableId && _journalRecId)
        {
            if (_forUpdate)
            {
                taxCalculationInputPersisted.selectForUpdate(_forUpdate);
            }

            if (_isReverse)
            {
                select firstonly taxCalculationInputPersisted
                    where taxCalculationInputPersisted.HeadingTableId == _journalTableId
                        && taxCalculationInputPersisted.HeadingRecId == _journalRecId
                        && taxCalculationInputPersisted.Source == _taxModuleType
                        && taxCalculationInputPersisted.IsReverse == NoYes::Yes;
            }
            else
            {
                select firstonly taxCalculationInputPersisted
                    where taxCalculationInputPersisted.JournalTableId == _journalTableId
                        && taxCalculationInputPersisted.JournalRecId == _journalRecId
                        && taxCalculationInputPersisted.Source == _taxModuleType
                        && taxCalculationInputPersisted.IsReverse == NoYes::No;
            }
        }

        return taxCalculationInputPersisted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transits the persisted tax calculation input, during the transition the <c>TransactionTableId</c> and
    /// <c>TransactionLineId</c> will be converted against the corresponding journal and the actual tax will be
    /// polulated.
    /// </summary>
    internal void transit()
    {
        if (!this.JournalRecId)
        {
            // JournalRecId is required to transit the tax calculation input.
            return;
        }

        ttsbegin;
        this.selectForUpdate(true);
        this.PackedTaxCalculationInput = this.transitPackedTaxCalculationInput();
        this.Status = TaxIntegrationPersistedTaxCalculationInputStatus::Transited;
        this.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxResultJson</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax result in JSON which will contains taxable document and actual tax amounts.
    /// </summary>
    /// <returns>The tax result JSON.</returns>
    internal TaxEngineJsonString getTaxResultJson()
    {
        TaxEngineJsonString taxResultJson;

        if (this.PackedTaxCalculationInput)
        {
            if (this.Status == TaxIntegrationPersistedTaxCalculationInputStatus::Original)
            {
                this.transit();
            }

            taxResultJson = Newtonsoft.Json.JsonConvert::SerializeObject(
                TaxIntegrationISVTaxPostUtil::deserializeTaxCalculationInput(this.PackedTaxCalculationInput),
                Newtonsoft.Json.Formatting::Indented);
        }

        return taxResultJson;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitPackedTaxCalculationInput</Name>
				<Source><![CDATA[
    private container transitPackedTaxCalculationInput()
    {
        TaxServiceAPI.TaxCalculationInput taxCalculationInput = TaxIntegrationISVTaxPostUtil::deserializeTaxCalculationInput(this.PackedTaxCalculationInput);

        TaxServiceAPI.TaxableDocumentHeader taxableDocumentHeader = taxCalculationInput.TaxableDocument.Header;

        this.transitTaxableDocumentHeader(taxableDocumentHeader);

        for (int i = 0; i < taxableDocumentHeader.Lines.get_Count(); i++)
        {
            TaxServiceAPI.TaxableDocumentLine taxableDocumentLine = taxableDocumentHeader.Lines.get_Item(i);

            this.transitTaxableDocumentLine(taxableDocumentLine);

            this.populatActualTax(taxCalculationInput, taxableDocumentLine);
        }

        return TaxIntegrationISVTaxPostUtil::serializeTaxCalculationInput(taxCalculationInput);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitTaxableDocumentHeader</Name>
				<Source><![CDATA[
    private void transitTaxableDocumentHeader(TaxServiceAPI.TaxableDocumentHeader _taxableDocumentHeader)
    {
        // Set the transaction header id as the actual journal table id and recid.
        if (this.JournalTableId == tableNum(LedgerJournalTrans))
        {
            LedgerJournalTable ledgerJournalTable = LedgerJournalTrans::findRecId(this.JournalRecId, false).ledgerJournalTable();
            _taxableDocumentHeader.TransactionHeaderId = con2Str([ledgerJournalTable.TableId, ledgerJournalTable.RecId]);
        }
        else
        {
            _taxableDocumentHeader.TransactionHeaderId = con2Str([this.JournalTableId, this.JournalRecId]);
        }

        // Appends the header information as header measures of taxable document.
        this.appendHeaderInformation(_taxableDocumentHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendHeaderInformation</Name>
				<Source><![CDATA[
    private void appendHeaderInformation(TaxServiceAPI.TaxableDocumentHeader _taxableDocumentHeader)
    {
        var taxableDocumentHeaderWrapper = new TaxServiceAPI.TaxableDocumentHeaderWrapper();
        taxableDocumentHeaderWrapper.Value = _taxableDocumentHeader;

        switch (this.JournalTableId)
        {
            case tableNum(ProjInvoiceJour):
                ProjInvoiceJour projInvoiceJour = ProjInvoiceJour::findRecId(this.JournalRecId);

                // Set the project invoice Id for the project invoices
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::ProjectInvoiceId, projInvoiceJour.ProjInvoiceId);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::VoucherNumber, projInvoiceJour.LedgerVoucher);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::PostingDate, TaxIntegrationCalculationServiceUtils::convertDateToStr(projInvoiceJour.InvoiceDate));
                break;

            case tableNum(CustInvoiceJour):
            case tableNum(VendInvoiceJour):
                CustVendInvoiceJour custVendInvoiceJour = new DictTable(this.JournalTableId).makeRecord();
                select firstonly InvoiceId, LedgerVoucher from custVendInvoiceJour
                    where custVendInvoiceJour.RecId == this.JournalRecId;

                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::InvoiceId, custVendInvoiceJour.InvoiceId);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::VoucherNumber, custVendInvoiceJour.LedgerVoucher);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::PostingDate, TaxIntegrationCalculationServiceUtils::convertDateToStr(custVendInvoiceJour.InvoiceDate));
                break;

            case tableNum(LedgerJournalTrans):
                LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(this.JournalRecId, false);
                
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::InvoiceId, ledgerJournalTrans.Invoice);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::VoucherNumber, ledgerJournalTrans.Voucher);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::PostingDate, TaxIntegrationCalculationServiceUtils::convertDateToStr(ledgerJournalTrans.TransDate));
                break;
        }


        // For transaction reversal
        // Set the 'Is Reversal' flag
        taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::IsReversal, enum2Symbol(enumNum(NoYes), this.IsReverse));

        if (this.IsReverse)
        {
            TransactionReversalTrans originalTrans = TransactionReversalTrans::findOriginal(this.HeadingTableId, this.HeadingRecId);
            if (originalTrans)
            {
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::IsOriginalTransactionReversed, enum2Symbol(enumNum(NoYes), originalTrans.Reversed));
            }

            // For transaction reversal, append the reversal voucher and reversal date
            if (this.HeadingTableId == tableNum(CustTrans)
                || this.HeadingTableId == tableNum(VendTrans))
            {
                CustVendTrans custVendTrans = new DictTable(this.HeadingTableId).makeRecord();
                select firstonly Voucher, TransDate from custVendTrans
                    where custVendTrans.RecId == this.HeadingRecId;

                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::ReversalVoucherNumber, custVendTrans.Voucher);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::ReversalDate, TaxIntegrationCalculationServiceUtils::convertDateToStr(custVendTrans.TransDate));

                CustVendTrans custVendTransOffset = new DictTable(this.HeadingTableId).makeRecord();
                select firstonly custVendTransOffset
                    where custVendTransOffset.RecId == custVendTrans.OffsetRecId;

                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::LastSettleVoucher, custVendTransOffset.Voucher);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::LastSettleVoucherDate, TaxIntegrationCalculationServiceUtils::convertDateToStr(custVendTransOffset.TransDate));
            }
            else if (this.HeadingTableId == tableNum(GeneralJournalEntry))
            {
                GeneralJournalEntry reversalJournalEntry = GeneralJournalEntry::find(this.HeadingRecId);

                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::ReversalVoucherNumber, reversalJournalEntry.SubledgerVoucher);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::ReversalDate, TaxIntegrationCalculationServiceUtils::convertDateToStr(reversalJournalEntry.AccountingDate));

                GeneralJournalEntry generalJournalEntryOffset = this.getOffsetGeneralJournalEntry(reversalJournalEntry);

                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::LastSettleVoucher, generalJournalEntryOffset.SubledgerVoucher);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::LastSettleVoucherDate, TaxIntegrationCalculationServiceUtils::convertDateToStr(generalJournalEntryOffset.AccountingDate));
            }
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(FreeTextInvoiceCorrection))
            && this.HeadingTableId == tableNum(CustInvoiceTable))
        {
            CustRelatedInvoice custRelatedInvoice = CustRelatedInvoice::findByCustInvoice(this.HeadingRecId);
            if (custRelatedInvoice.InvoiceAssociationType == InvoiceAssociationType::AdjustingInvoice
                || custRelatedInvoice.InvoiceAssociationType == InvoiceAssociationType::CorrectedInvoice)
            {
                // For the FTI correction, append invoice type and origianl invoice id and original invoice date.
                taxableDocumentHeaderWrapper.SetField(
                    TaxIntegrationTaxServiceConstants::FTIType, 
                    custRelatedInvoice.InvoiceAssociationType == InvoiceAssociationType::AdjustingInvoice
                        ? TaxIntegrationTaxServiceConstants::FTITypeCanceling
                        : TaxIntegrationTaxServiceConstants::FTITypeCorrected);

                CustInvoiceTable originalInvoice = CustInvoiceTable::findRecId(custRelatedInvoice.ParentCustInvoice);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::OriginalInvoiceId, originalInvoice.InvoiceId);
                taxableDocumentHeaderWrapper.SetField(TaxIntegrationTaxServiceConstants::OriginalInvoiceDate, TaxIntegrationCalculationServiceUtils::convertDateToStr(originalInvoice.InvoiceDate));
                
            }

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitTaxableDocumentLine</Name>
				<Source><![CDATA[
    private void transitTaxableDocumentLine(TaxServiceAPI.TaxableDocumentLine _taxableDocumentLine)
    {
        RefTableId lineTableId;
        RefRecId lineRecId;
        VendInvoiceJour vendInvoiceJour;
        VendInvoiceTrans vendInvoiceTrans;
        ProjProposalJour projProposalJour;
        ProjInvoiceJour projInvoiceJour;

        [lineTableId, lineRecId] = str2con(_taxableDocumentLine.GetId(), ',');

        switch (lineTableId)
        {
            case tableNum(SalesLine):
                SalesLine salesLine;
                CustInvoiceJour custInvoiceJour;
                CustInvoiceTrans custInvoiceTrans;

                select firstonly TableId, RecId from custInvoiceTrans
                    where custInvoiceTrans.ParentRecId == this.JournalRecId
                    join RecId from salesLine
                        where salesLine.RecId == lineRecId
                            && salesLine.InventTransId == custInvoiceTrans.InventTransId;

                _taxableDocumentLine.TransactionLineId = con2Str([custInvoiceTrans.TableId, custInvoiceTrans.RecId]);
                break;

            case tableNum(MarkupTrans):
                MarkupTrans markupTrans;
                select firstonly TableId, RecId from markupTrans
                    where markupTrans.OrigTableId == lineTableId
                        && markupTrans.OrigRecId == lineRecId;

                _taxableDocumentLine.TransactionLineId = con2Str([markupTrans.TableId, markupTrans.RecId]);
                break;

            case tableNum(PurchLine):
                PurchLine purchLine;

                select firstonly TableId, RecId from vendInvoiceTrans
                    exists join vendInvoiceJour
                        where vendInvoiceJour.PurchId == vendInvoiceTrans.PurchID
                            && vendInvoiceJour.InvoiceId == vendInvoiceTrans.InvoiceId
                            && vendInvoiceJour.InvoiceDate == vendInvoiceTrans.InvoiceDate
                            && vendInvoiceJour.NumberSequenceGroup == vendInvoiceTrans.NumberSequenceGroup
                            && vendInvoiceJour.InternalInvoiceId == vendInvoiceTrans.InternalInvoiceId
                            && vendInvoiceJour.RecId == this.JournalRecId
                    exists join purchLine
                        where purchLine.RecId == lineRecId
                            && purchLine.InventTransId == vendInvoiceTrans.InventTransId;

                _taxableDocumentLine.TransactionLineId = con2Str([vendInvoiceTrans.TableId, vendInvoiceTrans.RecId]);
                break;

            case tableNum(VendInvoiceInfoLine):
                VendInvoiceInfoLine vendInvoiceInfoLine;

                select firstonly TableId, RecId from vendInvoiceTrans
                    exists join vendInvoiceJour
                        where vendInvoiceJour.PurchId == vendInvoiceTrans.PurchID
                            && vendInvoiceJour.InvoiceId == vendInvoiceTrans.InvoiceId
                            && vendInvoiceJour.InvoiceDate == vendInvoiceTrans.InvoiceDate
                            && vendInvoiceJour.NumberSequenceGroup == vendInvoiceTrans.NumberSequenceGroup
                            && vendInvoiceJour.InternalInvoiceId == vendInvoiceTrans.InternalInvoiceId
                            && vendInvoiceJour.RecId == this.JournalRecId
                    exists join vendInvoiceInfoLine
                        where vendInvoiceInfoLine.RecId == lineRecId
                            && vendInvoiceInfoLine.SourceDocumentLine == vendInvoiceTrans.SourceDocumentLine;

                _taxableDocumentLine.TransactionLineId = con2Str([vendInvoiceTrans.TableId, vendInvoiceTrans.RecId]);
                break;

            case tableNum(CustInvoiceLine):
                CustInvoiceLine custInvoiceLine;
                CustInvoiceTrans custInvoiceTransInvoiceLine;

                select firstonly TableId, RecId from custInvoiceTransInvoiceLine
                    where custInvoiceTransInvoiceLine.ParentRecId == this.JournalRecId
                    exists join custInvoiceLine
                        where custInvoiceLine.RecId == lineRecId
                            && custInvoiceLine.SourceDocumentLine == custInvoiceTransInvoiceLine.SourceDocumentLine;

                _taxableDocumentLine.TransactionLineId = con2Str([custInvoiceTransInvoiceLine.TableId, custInvoiceTransInvoiceLine.RecId]);
                break;

            case tableNum(CustInvoiceTrans):
                if (this.HeadingTableId == tableNum(CustInvoiceTable))
                {
                    CustInvoiceTrans custInvoiceTransNew;
                    CustInvoiceTrans custInvoiceTransOriginal;

                    // For FTI canceling invoice, the packed tax calculation input is copied from the original invoice journal
                    // here retrieve the new invoice trans using the origianl invocie trans (with the same LineNum).
                    select firstonly TableId, RecId from custInvoiceTransNew
                        where custInvoiceTransNew.ParentRecId == this.JournalRecId
                        exists join custInvoiceTransOriginal
                            where custInvoiceTransOriginal.RecId == lineRecId
                                && custInvoiceTransOriginal.LineNum == custInvoiceTransNew.LineNum;

                    _taxableDocumentLine.TransactionLineId = con2Str([custInvoiceTransNew.TableId, custInvoiceTransNew.RecId]);
                }
                break;

            case tableNum(ProjProposalCost):
                ProjProposalCost projProposalCost;
                ProjInvoiceCost projInvoiceCost;

                select firstonly RecId from projInvoiceJour
                    where projInvoiceJour.RecId == this.JournalRecId
                    join TableId, RecId from projInvoiceCost
                        where projInvoiceCost.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                            && projInvoiceCost.InvoiceDate == projInvoiceJour.InvoiceDate
                    exists join projProposalJour
                        where projProposalJour.ProposalId == projInvoiceJour.ProposalId
                            && projProposalJour.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                    exists join projProposalCost
                        where projProposalCost.RecId == lineRecId
                            && projProposalCost.TransId == projInvoiceCost.TransId
                            && projProposalCost.ProposalId == projProposalJour.ProposalId;

                _taxableDocumentLine.TransactionLineId = con2Str([projInvoiceCost.TableId, projInvoiceCost.RecId]);
                break;

            case tableNum(ProjProposalEmpl):
                ProjProposalEmpl projProposalEmpl;
                ProjInvoiceEmpl projInvoiceEmpl;

                select firstonly RecId from projInvoiceJour
                    where projInvoiceJour.RecId == this.JournalRecId
                    join TableId, RecId from projInvoiceEmpl
                        where projInvoiceEmpl.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                            && projInvoiceEmpl.InvoiceDate == projInvoiceJour.InvoiceDate
                    exists join projProposalJour
                        where projProposalJour.ProposalId == projInvoiceJour.ProposalId
                            && projProposalJour.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                    exists join projProposalEmpl
                        where projProposalEmpl.RecId == lineRecId
                            && projProposalEmpl.TransId == projInvoiceEmpl.TransId
                            && projProposalEmpl.ProposalId == projProposalJour.ProposalId;

                _taxableDocumentLine.TransactionLineId = con2Str([projInvoiceEmpl.TableId, projInvoiceEmpl.RecId]);
                break;

            case tableNum(ProjProposalItem):
                ProjProposalItem projProposalItem;
                ProjInvoiceItem projInvoiceItem;

                select firstonly RecId from projInvoiceJour
                    where projInvoiceJour.RecId == this.JournalRecId
                    join TableId, RecId from projInvoiceItem
                        where projInvoiceItem.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                            && projInvoiceItem.InvoiceDate == projInvoiceJour.InvoiceDate
                    exists join projProposalJour
                        where projProposalJour.ProposalId == projInvoiceJour.ProposalId
                            && projProposalJour.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                    exists join projProposalItem
                        where projProposalItem.RecId == lineRecId
                            && projProposalItem.ProjTransId == projInvoiceItem.ProjTransId
                            && projProposalItem.ProposalId == projProposalJour.ProposalId;

                _taxableDocumentLine.TransactionLineId = con2Str([projInvoiceItem.TableId, projInvoiceItem.RecId]);
                break;

            case tableNum(ProjProposalOnAcc):
                ProjProposalOnAcc projProposalOnAcc;
                ProjInvoiceOnAcc projInvoiceOnAcc;

                select firstonly RecId from projInvoiceJour
                    where projInvoiceJour.RecId == this.JournalRecId
                    join TableId, RecId from projInvoiceOnAcc
                        where projInvoiceOnAcc.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                            && projInvoiceOnAcc.InvoiceDate == projInvoiceJour.InvoiceDate
                    exists join projProposalJour
                        where projProposalJour.ProposalId == projInvoiceJour.ProposalId
                            && projProposalJour.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                    exists join projProposalOnAcc
                        where projProposalOnAcc.RecId == lineRecId
                            && projProposalOnAcc.TransId == projInvoiceOnAcc.TransId
                            && projProposalOnAcc.ProposalId == projProposalJour.ProposalId;

                _taxableDocumentLine.TransactionLineId = con2Str([projInvoiceOnAcc.TableId, projInvoiceOnAcc.RecId]);
                break;

            case tableNum(ProjProposalRevenue):
                ProjProposalRevenue projProposalRevenue;
                ProjInvoiceRevenue projInvoiceRevenue;

                select firstonly RecId from projInvoiceJour
                    where projInvoiceJour.RecId == this.JournalRecId
                    join TableId, RecId from projInvoiceRevenue
                        where projInvoiceRevenue.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                            && projInvoiceRevenue.InvoiceDate == projInvoiceJour.InvoiceDate
                    exists join projProposalJour
                        where projProposalJour.ProposalId == projInvoiceJour.ProposalId
                            && projProposalJour.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                    exists join projProposalRevenue
                        where projProposalRevenue.RecId == lineRecId
                            && projProposalRevenue.TransId == projInvoiceRevenue.TransId
                            && projProposalRevenue.ProposalId == projProposalJour.ProposalId;

                _taxableDocumentLine.TransactionLineId = con2Str([projInvoiceRevenue.TableId, projInvoiceRevenue.RecId]);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populatActualTax</Name>
				<Source><![CDATA[
    private void populatActualTax(
        TaxServiceAPI.TaxCalculationInput _taxCalculationInput,
        TaxServiceAPI.TaxableDocumentLine _taxableDocumentLine)
    {
        if (!_taxCalculationInput.Adjustment)
        {
            _taxCalculationInput.Adjustment = new TaxServiceAPI.TaxAdjustment();
        }

        TaxServiceAPI.TaxAdjustmentWrapper taxAdjustmentWraper = new TaxServiceAPI.TaxAdjustmentWrapper();
        taxAdjustmentWraper.Value = _taxCalculationInput.Adjustment;

        TaxServiceAPI.LineAdjustment lineAjustment = new TaxServiceAPI.LineAdjustment();
        TaxServiceAPI.LineAdjustmentWrapper lineAdjustmentWrapper = new TaxServiceAPI.LineAdjustmentWrapper();
        lineAdjustmentWrapper.Value = lineAjustment;

        taxAdjustmentWraper.SetLineAdjustment(_taxableDocumentLine.GetId(), lineAjustment);

        RefTableId sourceTableId;
        RefRecId sourceRecId;

        [sourceTableId, sourceRecId] = str2con(_taxableDocumentLine.GetId(), ',');

        TaxIntegrationISVTaxPostLog taxIntegrationISVTaxPostLog;

        if (this.IsReverse)
        {
            taxIntegrationISVTaxPostLog = TaxIntegrationISVTaxPostLog::findBySource(this.HeadingTableId, this.HeadingRecId, this.Source);
        }
        else
        {
            taxIntegrationISVTaxPostLog = TaxIntegrationISVTaxPostLog::findBySource(this.JournalTableId, this.JournalRecId, this.Source);
        }

        TaxTrans taxTrans;
        while select taxTrans
            where taxTrans.SourceTableId == sourceTableId
                && taxTrans.SourceRecId == sourceRecId
                && taxTrans.Source == this.Source
                && taxTrans.Voucher == taxIntegrationISVTaxPostLog.Voucher
        {
            if (!lineAjustment.Measures)
            {
                lineAdjustmentWrapper.SetMeasure(TaxIntegrationTaxServiceConstants::TaxGroupMeasureName, taxTrans.TaxGroup);
                lineAdjustmentWrapper.SetMeasure(TaxIntegrationTaxServiceConstants::ItemTaxGroupMeasureName, taxTrans.TaxItemGroup);
            }
            
            lineAdjustmentWrapper.AddAdjustedCode(taxTrans.TaxCode);

            TaxServiceAPI.TaxCodeAdjustment taxCodeAjustment = new TaxServiceAPI.TaxCodeAdjustment();
            TaxServiceAPI.TaxCodeAdjustmentWrapper taxCodeAdjustmentWrapper = new TaxServiceAPI.TaxCodeAdjustmentWrapper();
            taxCodeAdjustmentWrapper.Value = taxCodeAjustment;

            taxCodeAdjustmentWrapper.SetField(TaxIntegrationTaxServiceConstants::AccountingCurrencyMeasureName, Ledger::accountingCurrency());
            taxCodeAdjustmentWrapper.SetField(TaxIntegrationTaxServiceConstants::AccountingCurrencyAmountMeasureName, taxTrans.TaxAmount);
            taxCodeAdjustmentWrapper.SetField(TaxIntegrationTaxServiceConstants::ReportingCurrencyMeasureName, Ledger::reportingCurrency());
            taxCodeAdjustmentWrapper.SetField(TaxIntegrationTaxServiceConstants::ReportingCurrencyAmountMeasureName, taxTrans.TaxAmountRep);
            taxCodeAdjustmentWrapper.SetField(TaxIntegrationTaxServiceConstants::TaxCurrencyMeasureName, taxTrans.CurrencyCode);
            taxCodeAdjustmentWrapper.SetField(TaxIntegrationTaxServiceConstants::TaxCurrencyAmountMeasureName, taxTrans.TaxAmountCur);
            taxCodeAdjustmentWrapper.SetField(TaxIntegrationTaxServiceConstants::TransactionCurrencyMeasureName, taxTrans.SourceCurrencyCode);
            taxCodeAdjustmentWrapper.SetField(TaxIntegrationTaxServiceConstants::TransactionCurrencyAmountMeasureName, taxTrans.SourceRegulateAmountCur);

            lineAdjustmentWrapper.SetTaxCodeAdjustment(taxTrans.TaxCode, taxCodeAjustment);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyPackedTaxCalculationInputFromInvoiceRegisterForInvoicePosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the packed date <c>copyPackedTaxCalculationInputFromInvoiceRegisterForInvoicePosting</c> from invoice register for invoice posting.
    /// </summary>
    /// <param name = "_ledgerJournalTransInvoiceRegister">The invoice register record.</param>
    /// <param name = "_ledgerJournalTransPosting">The ledger journal trans posting record.</param>
    /// <param name = "_postingTransRecId">The recid of posting trans.</param>
    /// <param name = "_taxModuleType">The source of the tax transactions.</param>
    /// <returns>The tax calculation input persisted table for invoice posting.</returns>
    internal static TaxIntegrationCalculationInputPersisted copyPackedTaxCalculationInputFromInvoiceRegisterForInvoicePosting(
        LedgerJournalTrans _ledgerJournalTransInvoiceRegister,
        LedgerJournalTrans _ledgerJournalTransPosting,
        RefRecId _postingTransRecId,
        TaxModuleType _taxModuleType = TaxModuleType::Voucher)
    {
        TaxIntegrationCalculationInputPersisted packedTaxCalculationInputForInvoicePosting, packedTaxCalculationInputForInvoiceRegister;

        packedTaxCalculationInputForInvoiceRegister = TaxIntegrationCalculationInputPersisted::findByJournalTable(
            tableNum(LedgerJournalTrans),
            _ledgerJournalTransInvoiceRegister.RecId,
            TaxModuleType::Voucher);

        if (packedTaxCalculationInputForInvoiceRegister
            && _ledgerJournalTransPosting
            && _postingTransRecId)
        {
            packedTaxCalculationInputForInvoicePosting = TaxIntegrationCalculationInputPersisted::findByJournalTable(
                tableNum(LedgerJournalTrans),
                _postingTransRecId,
                TaxModuleType::Voucher);

            if (!packedTaxCalculationInputForInvoicePosting)
            {
                packedTaxCalculationInputForInvoicePosting.clear();
                packedTaxCalculationInputForInvoicePosting.initValue();
                packedTaxCalculationInputForInvoicePosting.data(packedTaxCalculationInputForInvoiceRegister);
                packedTaxCalculationInputForInvoicePosting.HeadingTableId = tableNum(LedgerJournalTrans);
                packedTaxCalculationInputForInvoicePosting.HeadingRecId = _postingTransRecId;
                packedTaxCalculationInputForInvoicePosting.JournalTableId = tableNum(LedgerJournalTrans);
                packedTaxCalculationInputForInvoicePosting.JournalRecId = _postingTransRecId;
                packedTaxCalculationInputForInvoicePosting.Status = TaxIntegrationPersistedTaxCalculationInputStatus::Original;
                packedTaxCalculationInputForInvoicePosting.Source = _taxModuleType;
                packedTaxCalculationInputForInvoicePosting.PackedTaxCalculationInput = packedTaxCalculationInputForInvoiceRegister.transitTaxableDocumentLineToInvoiceApproval(_ledgerJournalTransPosting);
                packedTaxCalculationInputForInvoicePosting.insert();
            }
            else
            {
                ttsbegin;
                packedTaxCalculationInputForInvoicePosting.selectForUpdate(true);
                packedTaxCalculationInputForInvoicePosting.PackedTaxCalculationInput = packedTaxCalculationInputForInvoicePosting.appendTaxableDocumentLineForInvoiceApprovalLine(_ledgerJournalTransPosting);
                packedTaxCalculationInputForInvoicePosting.update();
                ttscommit;
            }
        }

        return packedTaxCalculationInputForInvoicePosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitTaxableDocumentLineToInvoiceApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transit the taxable document line form invoice register to invoice approval.
    /// </summary>
    /// <param name = "ledgerJournalTransInvoiceApproval">The invoice apporval journal line <c>LedgerJournalTrans</c> record.</param>
    /// <returns>return the serialized input data</returns>
    private container transitTaxableDocumentLineToInvoiceApproval(LedgerJournalTrans ledgerJournalTransInvoiceApproval)
    {
        LedgerJournalTable ledgerJournalTableIA = ledgerJournalTransInvoiceApproval.ledgerJournalTable();

        TaxServiceAPI.TaxCalculationInput taxCalculationInput = TaxIntegrationISVTaxPostUtil::deserializeTaxCalculationInput(this.PackedTaxCalculationInput);

        TaxServiceAPI.TaxableDocumentHeader taxableDocumentHeader = taxCalculationInput.TaxableDocument.Header;
        taxableDocumentHeader.TransactionHeaderId = con2Str([ledgerJournalTableIA.TableId, ledgerJournalTableIA.RecId]);
        
        TaxServiceAPI.TaxableDocumentHeaderWrapper taxableDocumentHeaderWrapper = new TaxServiceAPI.TaxableDocumentHeaderWrapper();
        taxableDocumentHeaderWrapper.Value = taxableDocumentHeader;

        taxableDocumentHeaderWrapper.SetField(TaxIntegrationCalculationActivityOnDocument_CalculationService::IOJournalName, ledgerJournalTableIA.JournalName);
        taxableDocumentHeaderWrapper.SetField(TaxIntegrationCalculationActivityOnDocument_CalculationService::IOJournalType, enum2Symbol(enumNum(LedgerJournalType), ledgerJournalTableIA.JournalType));

        for (int i = 0; i < taxableDocumentHeader.Lines.get_Count(); i++)
        {
            TaxServiceAPI.TaxableDocumentLine taxableDocumentLine = taxableDocumentHeader.Lines.get_Item(i);

            taxableDocumentLine.TransactionLineId = con2Str([ledgerJournalTransInvoiceApproval.TableId, ledgerJournalTransInvoiceApproval.RecId]);
            
            TaxServiceAPI.TaxableDocumentLineWrapper taxableDocumentLineWrapper = new TaxServiceAPI.TaxableDocumentLineWrapper();
            taxableDocumentLineWrapper.Value = taxableDocumentLine;

            taxableDocumentLineWrapper.SetField(TaxIntegrationCalculationActivityOnDocument_CalculationService::IOTransactionAmount, ledgerJournalTransInvoiceApproval.amount());
        }

        taxCalculationInput.Adjustment = null;
        return TaxIntegrationISVTaxPostUtil::serializeTaxCalculationInput(taxCalculationInput);
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendTaxableDocumentLineForInvoiceApprovalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Append the taxable document line form invoice register.
    /// </summary>
    /// <param name = "ledgerJournalTrans">The invoice apporval journal line <c>LedgerJournalTrans</c> record.</param>
    /// <returns>return the serialized input data</returns>
    private container appendTaxableDocumentLineForInvoiceApprovalLine(LedgerJournalTrans ledgerJournalTrans)
    {
        LedgerJournalTable ledgerJournalTableIA = ledgerJournalTrans.ledgerJournalTable();

        TaxServiceAPI.TaxCalculationInput taxCalculationInput = TaxIntegrationISVTaxPostUtil::deserializeTaxCalculationInput(this.PackedTaxCalculationInput);

        TaxServiceAPI.TaxableDocumentHeader taxableDocumentHeader = taxCalculationInput.TaxableDocument.Header;
        taxableDocumentHeader.TransactionHeaderId = con2Str([ledgerJournalTableIA.TableId, ledgerJournalTableIA.RecId]);

        TaxServiceAPI.TaxableDocumentHeaderWrapper taxableDocumentHeaderWrapper = new TaxServiceAPI.TaxableDocumentHeaderWrapper();
        taxableDocumentHeaderWrapper.Value = taxableDocumentHeader;

        TaxServiceAPI.TaxableDocumentLine taxableDocumentLine = taxableDocumentHeader.Lines.get_Item(0);

        if (taxableDocumentLine)
        {
            TaxServiceAPI.TaxableDocumentLine taxableDocumentLineNew = new TaxServiceAPI.TaxableDocumentLine();
            taxableDocumentLineNew.TransactionLineId = con2Str([ledgerJournalTrans.TableId, ledgerJournalTrans.RecId]);

            TaxServiceAPI.TaxableDocumentLineWrapper taxableDocumentLineWrapperNew = new TaxServiceAPI.TaxableDocumentLineWrapper();
            taxableDocumentLineWrapperNew.Value = taxableDocumentLineNew;

            System.Collections.IDictionary taxableDocumentLineFields = taxableDocumentLine.Fields;
            System.Collections.IDictionaryEnumerator taxableDocumentLineFieldsEnumerator = taxableDocumentLineFields.GetEnumerator();
            while (taxableDocumentLineFieldsEnumerator.MoveNext())
            {
                if (taxableDocumentLineFieldsEnumerator.Key == TaxIntegrationCalculationActivityOnDocument_CalculationService::IOTransactionAmount)
                {
                    taxableDocumentLineWrapperNew.SetField(TaxIntegrationCalculationActivityOnDocument_CalculationService::IOTransactionAmount, ledgerJournalTrans.amount());
                }
                else
                {
                    taxableDocumentLineWrapperNew.SetField(taxableDocumentLineFieldsEnumerator.Key, taxableDocumentLineFieldsEnumerator.Value);
                } 
            }
            taxableDocumentHeaderWrapper.AddLine(taxableDocumentLineNew);
        }

        taxCalculationInput.Adjustment = null;
        return TaxIntegrationISVTaxPostUtil::serializeTaxCalculationInput(taxCalculationInput);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetGeneralJournalEntry</Name>
				<Source><![CDATA[
    private GeneralJournalEntry getOffsetGeneralJournalEntry(GeneralJournalEntry generalJournalEntry)
    {
        LedgerTransSettlement ledgerTransSettlement;
        LedgerTransSettlement ledgerTransSettlementOffset;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalAccountEntry generalJournalAccountEntryOffset;
        GeneralJournalEntry generalJournalEntryOffset;


        select firstonly RecId from generalJournalAccountEntry
            where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
            join RecId from ledgerTransSettlement
                where ledgerTransSettlement.TransRecId == generalJournalAccountEntry.RecId
            join RecId from ledgerTransSettlementOffset
                where ledgerTransSettlementOffset.SettleId == ledgerTransSettlement.SettleId
            join RecId from generalJournalAccountEntryOffset
                where generalJournalAccountEntryOffset.RecId == ledgerTransSettlementOffset.TransRecId
            join generalJournalEntryOffset
                where generalJournalEntryOffset.RecId == generalJournalAccountEntryOffset.GeneralJournalEntry;

        return generalJournalEntryOffset;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<SubscriberAccessLevel>
		<Read>Allow</Read>
	</SubscriberAccessLevel>
	<CacheLookup>FoundAndEmpty</CacheLookup>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>HeadingTableId</Name>
			<ExtendedDataType>RefTableId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>HeadingRecId</Name>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>JournalTableId</Name>
			<ExtendedDataType>RefTableId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>JournalRecId</Name>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldContainer">
			<Name>PackedTaxCalculationInput</Name>
			<ExtendedDataType>TaxIntegrationCalculationInputContainer</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Status</Name>
			<EnumType>TaxIntegrationPersistedTaxCalculationInputStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Source</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxModuleTypeId</ExtendedDataType>
			<HelpText>@TaxTrans:SourceHelpText</HelpText>
			<EnumType>TaxModuleType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsReverse</Name>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<EnumType>NoYes</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>HeadingTableIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>HeadingTableId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HeadingRecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Source</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations />
	<StateMachines />
</AxTable>