<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventTestAssociationTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class InventTestAssociationTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowEditQuarantineOnFailure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a field can be edited based on a <c>InventTestReferenceType</c> enumeration type.
    /// </summary>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    public boolean allowEditQuarantineOnFailure()
    {
        switch (this.OrderType)
        {
            case InventTestReferenceType::Quarantine,
                 InventTestReferenceType::RouteOpr,
                 InventTestReferenceType::Sales:
                // Don't allow quarantine on failure for the above types, so no need to edit it.
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>aosValidateInsert</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Ensures that the specified dates are valid and that relation fields are blank if relations are not
    ///    used.
    /// </summary>
    /// <returns>
    ///    true if the dates and other fields are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method overrides the standard <c>aosValidateInsert</c> method.
    /// </remarks>
    public boolean aosValidateInsert()
    {
        if (this.AccountCode == TableGroupAll::All)
        {
            this.AccountRelation = '';
        }

        if (this.ItemCode == TableGroupAll::All)
        {
            this.ItemRelation = '';
        }

        if (this.WrkCtrCode == TableGroupAll::All)
        {
            this.WrkCtrRelation = '';
        }

        return super() && this.validateDateRanges();
    }

]]></Source>
			</Method>
			<Method>
				<Name>aosValidateUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Ensures that the specified dates are valid and that relation fields are blank if relations are not
    ///    used.
    /// </summary>
    /// <returns>
    ///    true if the dates and other fields are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method overrides the standard <c>aosValidateUpdate</c> method.
    /// </remarks>
    public boolean aosValidateUpdate()
    {
        if (this.AccountCode == TableGroupAll::All)
        {
            this.AccountRelation = '';
        }

        if (this.ItemCode == TableGroupAll::All)
        {
            this.ItemRelation = '';
        }

        if (this.WrkCtrCode == TableGroupAll::All)
        {
            this.WrkCtrRelation = '';
        }

        return super() && this.validateDateRanges();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountRelationForTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the <c>AccountRelation</c> is valid when <c>AccountCode</c> is <c>TableGroupAll::Table</c>.
    /// </summary>
    /// <returns>
    ///    true if the combination is valid; otherwise, false.
    /// </returns>
    protected boolean checkAccountRelationForTable()
    {
        switch (this.OrderType)
        {
            case InventTestReferenceType::Sales:
                return CustTable::exist(this.AccountRelation);

            case InventTestReferenceType::Purch:
                return VendTable::exist(this.AccountRelation);
                
            case InventTestReferenceType::RouteOpr:
                return RouteOprTable::exist(this.AccountRelation);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountRelationForGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the <c>AccountRelation</c> is valid when <c>AccountCode</c> is <c>TableGroupAll::GroupId</c>.
    /// </summary>
    /// <returns>
    ///    true if the combination is valid; otherwise, false.
    /// </returns>
    protected boolean checkAccountRelationForGroupId()
    {
        switch (this.OrderType)
        {
            case InventTestReferenceType::Sales:
                return CustGroup::exist(this.AccountRelation);

            case InventTestReferenceType::Purch:
                return VendGroup::exist(this.AccountRelation);
                
            case InventTestReferenceType::RouteOpr:
                return RouteGroup::exist(this.AccountRelation);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountRelation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the combination of the fields <c>AccountCode</c> and <c>AccountRelation</c> is valid.
    /// </summary>
    /// <returns>
    ///    true if the combination is valid; otherwise, false.
    /// </returns>
    public boolean checkAccountRelation()
    {
        switch (this.AccountCode)
        {
            case TableGroupAll::Table   :
                return this.checkAccountRelationForTable();

            case TableGroupAll::GroupId :
                return this.checkAccountRelationForGroupId();

            case TableGroupAll::All     :
                return !this.AccountRelation;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccountRelation</Name>
				<Source><![CDATA[
    private boolean validateAccountRelation()
    {
        boolean ret = true;
        if (!this.checkAccountRelation())
        {
            ret = checkFailed("@SCM:InventTestAssociationTable_InvalidAccountRelation");
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBlockProcess</Name>
				<Source><![CDATA[
    private boolean checkBlockProcess()
    {
        if (!this.isEligibleForBlockProcess(this.BlockProcess))
        {
            return checkFailed("@SYS333775");
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDocumentTypeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for checking the Document type for a <c>InventTestAssociationTable</c> record.
    /// </summary>
    /// <param name = "_inventTestAssociationTable">The <c>InventTestAssociationTable</c> record being checked.</param>
    /// <param name = "_result">An <c>EventHandlerAcceptResult</c> instance, where subscribers can accept when checking passes.</param>
    delegate void checkDocumentTypeDelegate(InventTestAssociationTable _inventTestAssociationTable, EventHandlerAcceptResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDocumentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the combination of the <c>DocumentType</c> and <c>OrderType</c> fields is valid.
    /// </summary>
    /// <returns>
    /// true if the combination is valid; otherwise, false.
    /// </returns>
    public boolean checkDocumentType()
    {
        boolean ok = InventTestAssociationTable::isOrderTypeAndDocumentStatusConsistent(this.OrderType, this.DocumentType);

        if (!ok)
        {
            EventHandlerAcceptResult eventHandlerResult = EventHandlerAcceptResult::newSingleResponse();
            this.checkDocumentTypeDelegate(this, eventHandlerResult);

            ok = eventHandlerResult.isAccepted();
        }

        if (!ok)
        {
            warning("@SYS113807");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExecutionTimeValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates execution time.
    /// </summary>
    /// <returns>
    /// true if the execution time is valid; otherwise, false.
    /// </returns>
    protected boolean isExecutionTimeValid()
    {
        switch (this.TestExecution)
        {
            case InventTestExecution::None:
                if (this.OrderType != InventTestReferenceType::Inventory && 
                    this.DocumentType != InventTestDocumentStatus::Registration)
                {
                    return false;
                }
                break;

            case InventTestExecution::Before:
                if (this.OrderType == InventTestReferenceType::Inventory)
                {
                    return false;
                }
                break;

            case InventTestExecution::After:
                if (this.OrderType == InventTestReferenceType::Inventory)
                {
                    return false;
                }
                if (this.OrderType == InventTestReferenceType::Quarantine && this.DocumentType == InventTestDocumentStatus::End)
                {
                    return false;
                }
                if (this.OrderType == InventTestReferenceType::Sales && this.DocumentType == InventTestDocumentStatus::PackingSlip)
                {
                    return false;
                }
                break;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExecutionTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the <c>TestExecution</c> field has a valid value.
    /// </summary>
    /// <returns>
    ///    true if the <c>TestExecution</c> field is valid; otherwise, false.
    /// </returns>
    public boolean checkExecutionTime()
    {
        if (!this.isExecutionTimeValid())
        {
            return checkFailed("@SYS113803");
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemRelation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the combination of the fields <c>ItemCode</c> and <c>ItemRelation</c> is valid.
    /// </summary>
    /// <returns>
    ///    true if the combination is valid; otherwise, false.
    /// </returns>
    public boolean  checkItemRelation()
    {
        switch (this.ItemCode)
        {
            case TableGroupAll::Table:
                return InventTable::exist(this.ItemRelation);

            case TableGroupAll::GroupId:
                return InventTestQualityGroup::exist(this.ItemRelation);

            case TableGroupAll::All:
                return !this.ItemRelation;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateItemRelation</Name>
				<Source><![CDATA[
    private boolean validateItemRelation()
    {
        boolean ret = true;
        if (!this.checkItemRelation())
        {
            ret = checkFailed("@SCM:InventTestAssociationTable_InvalidItemRelation");
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemSampling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified item sampling is valid.
    /// </summary>
    /// <returns>
    /// true if the item sampling is valid; otherwise, false.
    /// </returns>
    public boolean  checkItemSampling()
    {
        InventItemSampling  inventItemSampling;

        if (!this.ItemSamplingId)
        {
            // Don't validate unless specified.
            return true;
        }

        inventItemSampling = this.inventItemSampling();

        if ( this.DocumentType
          && inventItemSampling.CreatePerUpdatedQuantity
          && this.isBlockingTriggeringEvent()
          && !this.isSetupToBlockPartialPurchaseReceipt())
        {
            return checkFailed(strFmt("@SYP4980055", fieldPName(InventTestAssociationTable, DocumentType)
                                                   , fieldPName(InventTestAssociationTable, BlockProcess)
                                                   , fieldPName(InventTestAssociationTable, ItemSamplingId)));
        }

        if (this.DocumentType != InventTestDocumentStatus::Registration)
        { // All item sampling values are valid for all events except registration
            return true;
        }

        if (!inventItemSampling.CreatePerUpdatedQuantity && inventItemSampling.DiscriminatingInventoryDimensions)
        {
            return checkFailed("@SYS343456");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidCustAccountGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the specified account number matches the <c>AccountRelation</c> on this association.
    /// </summary>
    /// <param name="_accountNum">
    ///    The account number to verify.
    /// </param>
    /// <returns>
    ///    true if the account number matches; otherwise, false.
    /// </returns>
    public boolean checkValidCustAccountGroup(InventTestAccountRelation _accountNum)
    {
        boolean ret = true;

        switch (this.AccountCode)
        {
            case TableGroupAll::GroupId:
                if (CustTable::find(_accountNum).CustGroup != this.AccountRelation)
                {
                    ret = false;
                }
                break;
            case TableGroupAll::Table:
                if (_accountNum != this.AccountRelation)
                {
                    ret = false;
                }
                break;
            default:
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the specified item number matches the <c>ItemRelation</c> on this association.
    /// </summary>
    /// <param name="_itemId">
    ///    The item number to verify.
    /// </param>
    /// <returns>
    ///    true if the item number matches; otherwise, false.
    /// </returns>
    public boolean checkValidItemGroup(ItemId _itemId)
    {
        boolean ret = true;

        if (this.ItemCode == TableGroupAll::GroupId
         && InventTestItemQualityGroup::find(this.ItemRelation,_itemId).QualityGroupId != this.ItemRelation)
        {
            ret = false;
        }

        if (ret && this.ItemCode == TableGroupAll::Table && _itemId != this.ItemRelation)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidVendAccountGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the specified account number matches the account relation on this association.
    /// </summary>
    /// <param name="_accountNum">
    ///    The account number to verify.
    /// </param>
    /// <returns>
    ///    true if the account number matches; otherwise, false.
    /// </returns>
    public boolean checkValidVendAccountGroup(InventTestAccountRelation _accountNum)
    {
        boolean ret = true;

        switch (this.AccountCode)
        {
            case TableGroupAll::GroupId:
                if (VendTable::find(_accountNum).VendGroup != this.AccountRelation)
                {
                    ret = false;
                }
                break;
            case TableGroupAll::Table:
                if (_accountNum != this.AccountRelation)
                {
                    ret = false;
                }
                break;
            default:
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidWorkCenter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the specified work center matches the <c>WrkCtrRelation</c> field on this association.
    /// </summary>
    /// <param name="_wrkCtrId">
    ///    The work center ID to verify.
    /// </param>
    /// <param name="_date">
    ///    The date for which the check should be performed.
    /// </param>
    /// <returns>
    ///    true if the work center ID matches; otherwise, false.
    /// </returns>
    public boolean checkValidWorkCenter(
        WrkCtrId    _wrkCtrId,
        date        _date)
    {
        WrkCtrResourceGroup wrkCtrResourceGroup;
        boolean             ret = true;

        if (this.WrkCtrCode != TableGroupAll::All)
        {
            // Get the resource group that the resource is a member of or the resource group itself
            wrkCtrResourceGroup = WrkCtrTable::resourceGroup(_wrkCtrId, _date, _date);

            switch (this.WrkCtrCode)
            {
                case TableGroupAll::GroupId:
                    if (wrkCtrResourceGroup.WrkCtrId != this.WrkCtrRelation)
                    {
                        ret = false;
                    }
                    break;
                case TableGroupAll::Table:
                    if (_wrkCtrId != this.WrkCtrRelation)
                    {
                        ret = false;
                    }
                    break;
            }

            if (this.InventSiteId)
            {
                // Check for site membership
                if (wrkCtrResourceGroup.SiteId != this.InventSiteId)
                {
                    ret = false;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWrkCtrRelation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the combination of the <c>WrkCtrCode</c> and <c>WrkCtrRelation</c> fields is valid.
    /// </summary>
    /// <returns>
    ///    true if the combination is valid; otherwise, false.
    /// </returns>
    public boolean  checkWrkCtrRelation()
    {
        switch (this.WrkCtrCode)
        {
            case TableGroupAll::Table:
                return this.checkWrkCtrRelationForTable();

            case TableGroupAll::GroupId:
                return this.checkWrkCtrRelationForGroupId();

            case TableGroupAll::All:
                return !this.WrkCtrRelation;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrkCtrRelation</Name>
				<Source><![CDATA[
    private boolean validateWrkCtrRelation()
    {
        boolean ret = true;
        if (!this.checkWrkCtrRelation())
        {
            ret = checkFailed("@SYS113802");
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExistingAssociationCreationSequenceNumber</Name>
				<Source><![CDATA[
    private boolean validateExistingAssociationCreationSequenceNumber()
    {
        boolean ret = true;

        InventTestAssociationTable inventTestAssociationTable;

        select firstonly RecId from inventTestAssociationTable
        where inventTestAssociationTable.AssociationCreationSequenceNumber == this.AssociationCreationSequenceNumber;

        if (inventTestAssociationTable.RecId != 0)
        {
            ret = checkFailed("@SCM:InventTestAssociationTable_DuplicateAssociationCreationSequenceNumber");
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWrkCtrRelationForTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the <c>WrkCtrRelation</c> is valid when <c>WrkCtrCode</c> is <c>TableGroupAll::Table</c>.
    /// </summary>
    /// <returns>
    ///    true if the combination is valid; otherwise, false.
    /// </returns>
    protected boolean checkWrkCtrRelationForTable()
    {
        WrkCtrTable wrkCtrTable = WrkCtrTable::find(this.WrkCtrRelation);

        return this.OrderType == InventTestReferenceType::RouteOpr
               && wrkCtrTable.RecId
               && wrkCtrTable.IsIndividualResource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWrkCtrRelationForGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the <c>WrkCtrRelation</c> is valid when <c>WrkCtrCode</c> is <c>TableGroupAll::GroupId</c>.
    /// </summary>
    /// <returns>
    ///    true if the combination is valid; otherwise, false.
    /// </returns>
    protected boolean checkWrkCtrRelationForGroupId()
    {
        WrkCtrTable wrkCtrTable = WrkCtrTable::find(this.WrkCtrRelation);

        return this.OrderType == InventTestReferenceType::RouteOpr
               && wrkCtrTable.RecId
               && !wrkCtrTable.IsIndividualResource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        InventTestAssociationTable::clearRecordCountForOrderTypeCache(this.OrderType);
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>edit_blockProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the <c>BlockProcess</c> field.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that indicates whether the process is set.
    /// </param>
    /// <param name="_inventTestAssociationTable">
    /// The current record of the <c>InventTestAssociationTable</c> table.
    /// </param>
    /// <param name="_blockProcessStr">
    /// The new process when the <paramref name="_set" /> parameter is true.
    /// </param>
    /// <returns>
    /// The document type of the record in the <c>InventTestAssociationTable</c> table.
    /// </returns>
    public edit InventTestBlockProcessStr edit_blockProcess(
        boolean                     _set,
        InventTestAssociationTable  _inventTestAssociationTable,
        InventTestBlockProcessStr   _blockProcessStr)
    {
        if (_set)
        {
            //Check if user has security access
            if (!hasFieldAccess(tableNum(InventTestAssociationTable),
                                fieldNum(InventTestAssociationTable, BlockProcess),
                                AccessType::View))
            {
                return '';
            }
            if (hasFieldAccess( tableNum(InventTestAssociationTable),
                                fieldNum(InventTestAssociationTable, BlockProcess),
                                AccessType::Edit))
            {
                _inventTestAssociationTable.BlockProcess = str2enum(_inventTestAssociationTable.BlockProcess, _blockProcessStr);
            }
        }
        else
        {
            if (!hasFieldAccess(tableNum(InventTestAssociationTable),
                                fieldNum(InventTestAssociationTable, BlockProcess),
                                AccessType::View))
            {
                return '';
            }
        }

        return  enum2str(_inventTestAssociationTable.BlockProcess);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventTestGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the current record based on the <c>TestGroupId</c> field.
    /// </summary>
    public void initFromInventTestGroup()
    {
        InventTestGroup inventTestGroup;

        if (this.TestGroupId)
        {
            inventTestGroup = InventTestGroup::find(this.TestGroupId);
            this.ItemSamplingId = inventTestGroup.ItemSamplingId;
            this.AcceptableQualityLevel = inventTestGroup.AcceptableQualityLevel;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        this.ShowInfoOnCreate   = NoYes::Yes;
        this.ValidToDateTime    = DateTimeUtil::maxValue();
        this.QualityProcessingPolicy = WHSQualityProcessingPolicy::CreateQualityOrder;

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        if (!this.AssociationCreationSequenceNumber)
        {
            this.AssociationCreationSequenceNumber = this.nextAssociationCreationSequence();
        }
        super();
        InventTestAssociationTable::clearRecordCountForOrderTypeCache(this.OrderType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextAssociationCreationSequence</Name>
				<Source><![CDATA[
    private InventTestAssociationCreationSequenceNumber nextAssociationCreationSequence()
    {
        InventTestAssociationCreationSequenceNumber currentAssociationCreationSequenceNumber = 0;
        InventTestAssociationTable inventTestAssociationTable;

        select maxof(AssociationCreationSequenceNumber)
            from inventTestAssociationTable
            where inventTestAssociationTable.DataAreaId == this.DataAreaId;

        currentAssociationCreationSequenceNumber = inventTestAssociationTable.AssociationCreationSequenceNumber;

        return (currentAssociationCreationSequenceNumber + 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBlockProcessMandatory</Name>
				<Source><![CDATA[
    private boolean isBlockProcessMandatory()
    {
        if (this.OrderType == InventTestReferenceType::Quarantine)
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEligibleForBlockProcessDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for evaluating if the <c>InventTestAssociationTable</c> record is eligible for blocking the specified process.
    /// </summary>
    /// <param name = "_inventTestAssociationTable">The <c>InventTestAssociationTable</c> record being evaluated.</param>
    /// <param name = "_blockProcess">The <c>InventTestBlockProcess</c> value being evaluated.</param>
    /// <param name = "_eventHandlerResult">An <c>EventHandlerResult</c> instance, where subscribers can insert the check result.</param>
    /// <remarks>
    /// This is only called if we have not been able to find an existing combination of quality association settings to evaluate if the specified process can be blocked.
    /// This could, for example, happen if a new base enumeration value was added by a partner.
    /// </remarks>
    delegate void isEligibleForBlockProcessDelegate(InventTestAssociationTable _inventTestAssociationTable, InventTestBlockProcess _blockProcess, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEligibleForBlockProcess</Name>
				<Source><![CDATA[
    private boolean isEligibleForBlockProcess(InventTestBlockProcess _process)
    {
        if (_process == InventTestBlockProcess::None)
        {
            if (this.isBlockProcessMandatory())
            {
                return false;
            }
            return true;
        }

        switch (this.OrderType)
        {
            case InventTestReferenceType::Purch:
                switch (this.DocumentType)
                {
                    case InventTestDocumentStatus::Registration:
                        if (_process == InventTestBlockProcess::ProductReceipt
                         || _process == InventTestBlockProcess::Invoice)
                        {
                            return true;
                        }
                        break;
                    case InventTestDocumentStatus::ReceiptsList:
                        if ((_process == InventTestBlockProcess::ReceiptsList && this.TestExecution == InventTestExecution::Before)
                         ||  _process == InventTestBlockProcess::ProductReceipt
                         ||  _process == InventTestBlockProcess::Invoice)
                        {
                            return true;
                        }
                        break;
                    case InventTestDocumentStatus::ProductReceipt:
                        if ((_process == InventTestBlockProcess::ProductReceipt && this.TestExecution == InventTestExecution::Before)
                         ||  _process == InventTestBlockProcess::Invoice)
                        {
                            return true;
                        }
                        break;
                }
                break;
            case InventTestReferenceType::Sales:
                switch (this.DocumentType)
                {
                    case InventTestDocumentStatus::PickingList:
                        if ((_process == InventTestBlockProcess::PickingList && this.TestExecution == InventTestExecution::Before)
                         ||  _process == InventTestBlockProcess::PackingSlip
                         ||  _process == InventTestBlockProcess::Invoice)
                        {
                            return true;
                        }
                        break;
                    case InventTestDocumentStatus::PackingSlip:
                        if ((_process == InventTestBlockProcess::PackingSlip && this.TestExecution == InventTestExecution::Before)
                         ||  _process == InventTestBlockProcess::Invoice)
                        {
                            return true;
                        }
                        break;
                }
                break;
            case InventTestReferenceType::Production:
                switch (this.DocumentType)
                {
                    case InventTestDocumentStatus::Registration:
                        if ( _process == InventTestBlockProcess::ReportFinished
                         ||  _process == InventTestBlockProcess::End)
                        {
                            return true;
                        }
                        break;
                    case InventTestDocumentStatus::ReportFinished:
                        if ((_process == InventTestBlockProcess::ReportFinished && this.TestExecution == InventTestExecution::Before)
                         ||  _process == InventTestBlockProcess::End)
                        {
                            return true;
                        }
                        break;
                }
                break;
            case InventTestReferenceType::RouteOpr:
                switch (this.DocumentType)
                {
                    case InventTestDocumentStatus::ReportFinished:
                        if ((_process == InventTestBlockProcess::ReportFinished && this.TestExecution == InventTestExecution::Before))
                        {
                            return true;
                        }
                        break;
                }
                break;
            case InventTestReferenceType::Quarantine:
                switch (this.DocumentType)
                {
                    case InventTestDocumentStatus::ReportFinished:
                        if ((_process == InventTestBlockProcess::ReportFinished && this.TestExecution == InventTestExecution::Before)
                         ||  _process == InventTestBlockProcess::End)
                        {
                            return true;
                        }
                        break;
                    case InventTestDocumentStatus::End:
                        if ((_process == InventTestBlockProcess::End && this.TestExecution == InventTestExecution::Before))
                        {
                            return true;
                        }
                        break;
                }
                break;
        }

        EventHandlerResult eventHandlerResult = EventHandlerResult::newSingleResponse();
        this.isEligibleForBlockProcessDelegate(this, _process, eventHandlerResult);

        if (eventHandlerResult.hasResult())
        {
            return eventHandlerResult.result();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupBlockProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and displays a lookup form for the <c>BlockProcess</c> field.
    /// </summary>
    /// <param name="_lookupCtrl">
    /// The calling form control.
    /// </param>
    public void lookupBlockProcess(FormStringControl _lookupCtrl)
    {
        InventTestBlockProcessTmp   inventTestBlockProcessTmp;
        SysTableLookup              sysTableLookup;
        DictEnum                    dictEnum;
        int                         i;

        void addType(InventTestBlockProcess _inventTestBlockProcess)
        {
            inventTestBlockProcessTmp.InventTestBlockProcessStr = enum2str(_inventTestBlockProcess);
            inventTestBlockProcessTmp.insert();
        }

        //Check if user has security access
        if (!hasFieldAccess(tableNum(InventTestAssociationTable),
                            fieldNum(InventTestAssociationTable, BlockProcess),
                            AccessType::Edit))
        {
            return;
        }

        ttsbegin;

        dictEnum = new DictEnum(enumNum(InventTestBlockProcess));
        for (i = 0; i < dictEnum.values(); i++)
        {
            if (this.isEligibleForBlockProcess(any2Enum(dictEnum.index2Value(i))))
            {
                addType(any2Enum(dictEnum.index2Value(i)));
            }
        }

        ttscommit;

        sysTableLookup  = SysTableLookup::newParameters(tableNum(InventTestBlockProcessTmp), _lookupCtrl);
        sysTableLookup.addLookupfield(fieldNum(InventTestBlockProcessTmp, InventTestBlockProcessStr), true);
        sysTableLookup.parmTmpBuffer(inventTestBlockProcessTmp);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupResource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Looks up a resource or resource group.
    /// </summary>
    /// <param name="_formControl">
    ///    The control for which to look up the value.
    /// </param>
    public void lookupResource(FormControl _formControl)
    {
        if (this.WrkCtrCode == TableGroupAll::Table)
        {
            WrkCtrTable::lookupWrkCtrId(_formControl,'','',0,true);
        }
        else
        {
            if (this.WrkCtrCode == TableGroupAll::GroupId)
            {
                WrkCtrResourceGroup::lookupWrkCtrId(_formControl,this.InventSiteId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the DocumentType field based on the passed <c>InventTestDocumentStatus</c> enumeration label text.
    /// </summary>
    /// <param name="_enumLabelText">
    /// Text of the enumeration label.
    /// </param>
    public void setDocumentType(str _enumLabelText)
    {
        InventTestDocumentStatus    inventTestDocumentStatus;

        //Check if user has security access
        if (!hasFieldAccess(tableNum(InventTestAssociationTable),
                            fieldNum(InventTestAssociationTable, DocumentType),
                            AccessType::Edit))
        {
            return;
        }
        if ( ! _enumLabelText )
        {
            this.DocumentType = InventTestDocumentStatus::None;
        }
        else
        {
            try
            {
                inventTestDocumentStatus = str2enum(inventTestDocumentStatus, _enumLabelText);
            }
            catch
            {
                return;
            }
            // Only set DocumentStatus if valid label was passed
            if (enum2str(inventTestDocumentStatus) == _enumLabelText)
            {
                this.DocumentType = inventTestDocumentStatus;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        if (this.OrderType != this.orig().OrderType)
        {
            InventTestAssociationTable::clearRecordCountForOrderTypeCache(this.orig().OrderType);
            InventTestAssociationTable::clearRecordCountForOrderTypeCache(this.OrderType);
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDateRanges</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the specified to and from dates are valid.
    /// </summary>
    /// <returns>
    ///    true if the dates are valid; otherwise false.
    /// </returns>
    public boolean validateDateRanges()
    {
        boolean ret = true;

        if (this.ValidToDateTime <= this.ValidFromDateTime)
        {
            ret = checkFailed(strFmt("@SYS117831",
                fieldPName(InventTestAssociationTable, ValidToDateTime),
                fieldPName(InventTestAssociationTable, ValidFromDateTime)));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean ret;

        ret = super(_fieldIdToCheck);

        switch (_fieldIdToCheck)
        {
            case fieldNum(InventTestAssociationTable, ItemRelation):
                ret = this.validateItemRelation() && ret;
                break;
            case fieldNum(InventTestAssociationTable, AccountRelation):
                ret = this.validateAccountRelation() && ret;
                break;
            case fieldNum(InventTestAssociationTable, WrkCtrRelation):
                ret = this.validateWrkCtrRelation() && ret;
                break;
            case fieldNum(InventTestAssociationTable, ItemSamplingId):
                ret = this.checkItemSampling() && ret;
                break;
            case fieldNum(InventTestAssociationTable, AssociationCreationSequenceNumber):
                ret = this.validateExistingAssociationCreationSequenceNumber() && ret;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean                         ret;
        InventTestAssociationTable      inventTestAssociationTable;
        InventTestGroup                 inventTestGroup;

        if (!this.ShowInfoOnCreate && this.TestExecution != InventTestExecution::After)
        {
            this.ShowInfoOnCreate   = NoYes::Yes;
        }

        ret = super();

        if (ret 
            && this.ItemCode == TableGroupAll::Table
            && InventTable::isItemCatchWeightAndWarehouseProcessEnabled(this.ItemRelation)
            && InventTestGroup::find(this.TestGroupId).UpdateInventStatus == NoYes::Yes
            && !WHSInventTable::ensureInventoryStatusChangedAllowedForItem(this.ItemRelation))
        {
            ret = false;
        }

        //  PI needs the ability to create quality associations of type: inventory
        if (!this.allowEditQuarantineOnFailure())
        {
            // We never allow quarantine on failure for the types not allowing editing
            this.QuarantineOnFailure = NoYes::No;
        }

        ret = this.validateItemRelation() && ret;
        ret = this.validateAccountRelation() && ret;
        ret = this.validateWrkCtrRelation() && ret;
        ret = this.checkDocumentType() && ret;
        ret = this.checkItemSampling() && ret;
        ret = this.checkBlockProcess() && ret;
        ret = this.checkExecutionTime() && ret;
        ret = ret && this.validateDateRanges();

        if (ret)
        {
            Query query = this.buildCheckDateOverlapQuery();
            query.firstOnly1(true);
            QueryBuildDataSource qbdsInventTestAssociationTable = query.dataSourceTable(tableNum(InventTestAssociationTable));
            qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, ValidToDateTime)).value(strFmt('> %1', this.ValidFromDateTime));
            qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, ValidFromDateTime)).value(strFmt('< %1', this.ValidToDateTime));
            qbdsInventTestAssociationTable.firstFast(true);
            QueryRun queryRun = new QueryRun(query);

            if (queryRun.next())
            {
                ret = checkFailed("@SYS113781");
            }
        }

        if (ret && InventTestGroup::find(this.TestGroupId).TestDestructive && this.OrderType == InventTestReferenceType::Quarantine)
        {
            ret = checkFailed("@SYS113805");
        }

        if (ret
            && #PmfEnabled
            && this.ItemCode == TableGroupAll::Table
            && !InventTable::pmfCheckAllowQuality(this.ItemRelation))
        {
            ret = checkFailed("@PRO1980");
        }

        if (ret
            && #PdsShelfEnabled
            && this.TestExecution == InventTestExecution::Before
            && inventTestGroup.PdsFailedQualityDispositionCode)
        {
            ret = checkFailed("@PDS1163");
        }

        ret = this.isValidOrderTypeForWarehouseProcess() && ret;
        ret = this.isValidEventTypeForWarehousePurchaseProcess() && ret;
        ret = this.isValidEventAndExecutionTypeForWarehouseProductionProcess() && ret;
        
        InventItemSampling itemSampling = InventItemSampling::find(this.ItemSamplingId);
        ret = this.isValidItemSamplingScopeConfiguration(itemSampling) && ret;
        ret = this.isValidItemSamplingQuantitySpecification(itemSampling) && ret;
        ret = this.isValidItemSamplingFullBlockingConfiguration(itemSampling) && ret;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidOrderTypeForWarehouseProcess</Name>
				<Source><![CDATA[
    private boolean isValidOrderTypeForWarehouseProcess()
    {
        if (WHSRefactorQualityManagementForWarehouseOrdersOnFlight::instance().isEnabled())
        {
            if (this.ApplicableWarehouseType == WHSApplicableWarehouseType::QualityManagementOnlyEnabled
                && !this.canOrderTypeBeUsedWithWarehouseProcess())
            {
                return checkFailed(strFmt("@WAX:QualityOrderDoesNotSupportTheseReferences", this.OrderType));
            }
        }
        else
        {
            if (this.ApplicableWarehouseType == WHSApplicableWarehouseType::QualityManagementOnlyEnabled
                && this.OrderType != InventTestReferenceType::Purch
                && this.OrderType != InventTestReferenceType::Production)
            {
                return checkFailed(strFmt("@WAX:QualityOrderSupportsOnlyPurchProd",
                                        InventTestReferenceType::Purch,
                                        InventTestReferenceType::Production));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canOrderTypeBeUsedWithWarehouseProcess</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean canOrderTypeBeUsedWithWarehouseProcess()
    {     
        return this.OrderType == InventTestReferenceType::Purch
            || this.OrderType == InventTestReferenceType::Production;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidEventTypeForWarehousePurchaseProcess</Name>
				<Source><![CDATA[
    private boolean isValidEventTypeForWarehousePurchaseProcess()
    {
        if (this.ApplicableWarehouseType == WHSApplicableWarehouseType::QualityManagementOnlyEnabled
            && this.OrderType == InventTestReferenceType::Purch
            && this.DocumentType != InventTestDocumentStatus::Registration)
        {
            return checkFailed(strFmt("@WAX:QualityOrderSupportsOnlyPurchRegistration", 
                                                InventTestReferenceType::Purch,
                                                InventTestDocumentStatus::Registration));
        }
       
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidEventAndExecutionTypeForWarehouseProductionProcess</Name>
				<Source><![CDATA[
    private boolean isValidEventAndExecutionTypeForWarehouseProductionProcess()
    {
        if (this.ApplicableWarehouseType == WHSApplicableWarehouseType::QualityManagementOnlyEnabled
            && this.OrderType == InventTestReferenceType::Production
            && (this.DocumentType != InventTestDocumentStatus::ReportFinished
                || this.TestExecution != InventTestExecution::After))
        {
            return checkFailed(strFmt("@WAX:QualityOrderSupportsOnlyProdRAF", 
                                        InventTestDocumentStatus::ReportFinished,
                                        InventTestExecution::After,
                                        InventTestReferenceType::Production));
        }
        
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidItemSamplingScopeConfiguration</Name>
				<Source><![CDATA[
    private boolean isValidItemSamplingScopeConfiguration(InventItemSampling _itemSampling)
    {
        if (this.ApplicableWarehouseType == WHSApplicableWarehouseType::All
            && _itemSampling.Samplingscope != WHSQualityManagementSamplingScope::OrderNumber)
        {
            return checkFailed(strFmt("@WAX:QualityOrderSamplingScopeError",
                                        this.ItemSamplingId,
                                        new SysDictEnum(enumnum(WHSQualityManagementSamplingScope)).value2Label(_itemSampling.SamplingScope),
                                        enum2Str(WHSQualityManagementSamplingScope::OrderNumber),
                                        fieldPName(InventTestAssociationTable, ApplicableWarehouseType),
                                        this.ApplicableWarehouseType));
        }
        
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidItemSamplingQuantitySpecification</Name>
				<Source><![CDATA[
    private boolean isValidItemSamplingQuantitySpecification(InventItemSampling _itemSampling)
    {
        if (this.ApplicableWarehouseType == WHSApplicableWarehouseType::All
            && _itemSampling.TestQtySpecification == InventTestQtySpecification::FullLicensePlate)
        {
            return checkFailed(strFmt("@WAX:QualityOrderSupportsTestQtySpecificationError",
                                    this.ItemSamplingId,
                                    fieldPName(InventItemSampling, TestQtySpecification),
                                    enum2Str(InventTestQtySpecification::FullLicensePlate),
                                    enum2Str(InventTestQtySpecification::Percent),
                                    enum2Str(InventTestQtySpecification::FixedQty),
                                    fieldPName(InventTestAssociationTable, ApplicableWarehouseType),
                                    this.ApplicableWarehouseType));
        }
        
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidItemSamplingFullBlockingConfiguration</Name>
				<Source><![CDATA[
    private boolean isValidItemSamplingFullBlockingConfiguration(InventItemSampling _itemSampling)
    {
        boolean ret = true;

        if (this.ApplicableWarehouseType == WHSApplicableWarehouseType::QualityManagementOnlyEnabled
            && _itemSampling.CompleteBlocking == NoYes::Yes)
        {
            ret = checkFailed("@WAX:FullBlockingUnsupportedForQualityManagementProcess");
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCheckDateOverlapQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object to check for date overlap.
    /// </summary>
    /// <returns>
    ///  A <c>Query</c> object to check for date overlap.
    /// </returns>
    protected Query buildCheckDateOverlapQuery()
    {
        Query query = new Query();

        QueryBuildDataSource qbdsInventTestAssociationTable = query.addDataSource(tableNum(InventTestAssociationTable));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, AccountCode)).value(queryValue(this.AccountCode));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, AccountRelation)).value(queryValue(this.AccountRelation));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, ItemCode)).value(queryValue(this.ItemCode));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, ItemRelation)).value(queryValue(this.ItemRelation));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, WrkCtrCode)).value(queryValue(this.WrkCtrCode));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, WrkCtrRelation)).value(queryValue(this.WrkCtrRelation));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, OrderType)).value(queryValue(this.OrderType));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, TestGroupId)).value(queryValue(this.TestGroupId));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, TestExecution)).value(queryValue(this.TestExecution));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, DocumentType)).value(queryValue(this.DocumentType));        
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, ApplicableWarehouseType)).value(queryValue(this.ApplicableWarehouseType));
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, RecId)).value(SysQuery::valueNot(this.RecId));
        
        str inventSiteIdRange = strfmt('((%1.%2 == "%3") || (%1.%2 == %4))',
                                       query.dataSourceTable(tableNum(InventTestAssociationTable)).name(),
                                       fieldStr(InventTestAssociationTable, InventSiteId),
                                       this.InventSiteId ? queryValue(this.InventSiteId) : this.InventSiteId,
                                       SysQuery::valueEmptyString());
        qbdsInventTestAssociationTable.addRange(fieldNum(InventTestAssociationTable, InventSiteId)).value(inventSiteIdRange);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDateOverlap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the to and from dates on two <c>InventTestAssociationTable</c> records overlap.
    /// </summary>
    /// <param name="_inventTestAssociationTableCur">
    ///    The first <c>InventTestAssociationTable</c> record.
    /// </param>
    /// <param name="_inventTestAssociationTableOther">
    ///    The second <c>InventTestAssociationTable</c> record.
    /// </param>
    /// <returns>
    ///    true if dates do not overlap; otherwise, false.
    /// </returns>
    public static boolean checkDateOverlap(
        InventTestAssociationTable  _inventTestAssociationTableCur,
        InventTestAssociationTable  _inventTestAssociationTableOther)
    {
        if (_inventTestAssociationTableCur.ValidToDateTime       > _inventTestAssociationTableOther.ValidFromDateTime
         && _inventTestAssociationTableCur.ValidFromDateTime     < _inventTestAssociationTableOther.ValidToDateTime)
        {
            return checkFailed("@SYS113781");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearRecordCountForOrderTypeCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the internal cache that is used to hold the total number of quality associations for a
    /// specified order type.
    /// </summary>
    /// <param name="_orderType">
    /// The order type for which the cache is cleared.
    /// </param>
    public static void clearRecordCountForOrderTypeCache(InventTestReferenceType _orderType)
    {
        SysGlobalObjectCache        sysGlobalObjectCache        = classfactory.globalObjectCache();
        GlobalObjectCacheScope      classScope                  = tableStr(InventTestAssociationTable);
        container                   key                         = ['RecordCount', _orderType, curExt()];

        sysGlobalObjectCache.remove(classScope , key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified record in the <c>InventTestAssociationTable</c> table exists.
    /// </summary>
    /// <param name="_recId">
    ///    The record ID of the record to find.
    /// </param>
    /// <returns>
    ///    true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean exist(RecId  _recId)
    {
        return  _recId &&
                (select firstonly   inventTestAssociationTable
                 where              inventTestAssociationTable.RecId    == _recId).RecId !=0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>InventTestAssociationTable</c> table.
    /// </summary>
    /// <param name="_recId">
    ///    The record ID of the record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>InventTestAssociationTable</c> table; otherwise, an empty record.
    /// </returns>
    public static InventTestAssociationTable find(
        RecId       _recId,
        boolean     _forUpdate = false)
    {
        InventTestAssociationTable inventTestAssociationTable;

        inventTestAssociationTable.selectForUpdate  (_forUpdate);

        select firstonly    inventTestAssociationTable
                 where      inventTestAssociationTable.RecId    == _recId;

        return inventTestAssociationTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOrderTypeAndDocumentStatusConsistent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the consistency of order reference type and document status.
    /// </summary>
    /// <param name="_referenceType">
    /// The order reference type.
    /// </param>
    /// <param name="_documentStatus">
    /// The document status.
    /// </param>
    /// <returns>
    /// true if the order reference type and document status are consistent; otherwise false .
    /// </returns>
    public static boolean isOrderTypeAndDocumentStatusConsistent(
        InventTestReferenceType     _referenceType,
        InventTestDocumentStatus    _documentStatus)
    {
        switch (_referenceType)
        {
            case InventTestReferenceType::Inventory :
                return _documentStatus == InventTestDocumentStatus::None;
            case InventTestReferenceType::PmfProdCoBy :
            case InventTestReferenceType::Production :
                return _documentStatus == InventTestDocumentStatus::ReportFinished
                    || _documentStatus == InventTestDocumentStatus::Registration;
            case InventTestReferenceType::Purch :
                return _documentStatus == InventTestDocumentStatus::ProductReceipt
                    || _documentStatus == InventTestDocumentStatus::ReceiptsList
                    || _documentStatus == InventTestDocumentStatus::Registration;
            case InventTestReferenceType::Quarantine :
                return _documentStatus == InventTestDocumentStatus::ReportFinished
                    || _documentStatus == InventTestDocumentStatus::End;
            case InventTestReferenceType::RouteOpr :
                return _documentStatus == InventTestDocumentStatus::ReportFinished;
            case InventTestReferenceType::Sales :
                return _documentStatus == InventTestDocumentStatus::PackingSlip
                    || _documentStatus == InventTestDocumentStatus::PickingList;
            default:
                EventHandlerResult eventHandlerResult = EventHandlerResult::newSingleResponse();
                InventTestAssociationTable::isOrderTypeAndDocumentStatusConsistentDelegate(_referenceType, _documentStatus, eventHandlerResult);
                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }

                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOrderTypeAndDocumentStatusConsistentDelegate</Name>
				<Source><![CDATA[
    static delegate void isOrderTypeAndDocumentStatusConsistentDelegate(InventTestReferenceType _referenceType, InventTestDocumentStatus _documentStatus, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordCountForOrderType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Find the total number of quality associations for a specified order type.
    /// </summary>
    /// <param name="_orderType">
    ///    The order type for which the number of records is found.
    /// </param>
    /// <returns>
    ///    The number of records.
    /// </returns>
    public static int64 recordCountForOrderType(InventTestReferenceType _orderType)
    {
        SysGlobalObjectCache        sysGlobalObjectCache        = classfactory.globalObjectCache();
        GlobalObjectCacheScope      classScope                  = tableStr(InventTestAssociationTable);
        container                   key                         = ['RecordCount', _orderType, curExt()];
        InventTestAssociationTable  inventTestAssociationTable;
        container                   packedCount;
        int64                       recordCount;

        packedCount = sysGlobalObjectCache.find(classScope , key);
        if (packedCount && conLen(packedCount) >= 0)
        {
            [recordCount] = packedCount;
        }
        else
        {
            select count(RecId) from inventTestAssociationTable
                where inventTestAssociationTable.OrderType  == _orderType;
            recordCount = inventTestAssociationTable.RecId;

            sysGlobalObjectCache.insert(classScope, key, [recordCount]);
        }

        return recordCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventItemSampling</Name>
				<Source><![CDATA[
    public InventItemSampling InventItemSampling(InventItemSampling _relatedTable = null)
    {
        if (prmIsDefault(_relatedTable))
        {
            return this.setLink('InventItemSampling');
        }
        else
        {
            return this.setLink('InventItemSampling', _relatedTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBlockingTriggeringEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the <c>DocumentType</c> and the <c>BlockProcess</c> identify the same event.
    /// </summary>
    /// <returns>
    /// True if the <c>DocumentType</c> and the <c>BlockProcess</c> identify the same event; otherwise, false.
    /// </returns>
    public boolean isBlockingTriggeringEvent()
    {
        if ((this.DocumentType == InventTestDocumentStatus::PackingSlip
          && this.BlockProcess == InventTestBlockProcess::PackingSlip)
          ||(this.DocumentType == InventTestDocumentStatus::PickingList
          && this.BlockProcess == InventTestBlockProcess::PickingList)
          ||(this.DocumentType == InventTestDocumentStatus::ProductReceipt
          && this.BlockProcess == InventTestBlockProcess::ProductReceipt)
          ||(this.DocumentType == InventTestDocumentStatus::ReceiptsList
          && this.BlockProcess == InventTestBlockProcess::ReceiptsList)
          ||(this.DocumentType == InventTestDocumentStatus::ReportFinished
          && this.BlockProcess == InventTestBlockProcess::ReportFinished)
          ||(this.DocumentType == InventTestDocumentStatus::End
          && this.BlockProcess == InventTestBlockProcess::End))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSetupToBlockPartialPurchaseReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether
    /// the trigger is "Product Receipt", execution is "Before", event blocking is "Product Receipt" and  "Per Updated Quantity" is checked.
    /// </summary>
    /// <returns>
    /// true if the trigger is "Product Receipt", execution is "Before", event blocking is "Product Receipt" and"Per Updated Quantity" is checked;
    /// otherwise, false.
    ///</returns>
    public boolean isSetupToBlockPartialPurchaseReceipt()
    {
        return (   this.DocumentType == InventTestDocumentStatus::ProductReceipt
                && this.BlockProcess == InventTestBlockProcess::ProductReceipt
                && this.TestExecution == InventTestExecution::Before
                && this.InventItemSampling().CreatePerUpdatedQuantity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtension</Name>
				<Source><![CDATA[
    public TableExtension getExtension()
    {
        return SysTableExtension::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultingDependencies</Name>
				<Source><![CDATA[
    public container getDefaultingDependencies()
    {
        return  [
            // [field that needs defaulting,
            //      [fields that affect the default value]]

            [fieldNum(InventTestAssociationTable, ItemSamplingId),
                [fieldNum(InventTestAssociationTable, TestGroupId)]],

            [fieldNum(InventTestAssociationTable, AcceptableQualityLevel),
                [fieldNum(InventTestAssociationTable, TestGroupId)]],

            [fieldNum(InventTestAssociationTable, ShowInfoOnCreate),
                [fieldNum(InventTestAssociationTable, TestExecution)]],

            [fieldNum(InventTestAssociationTable, DocumentType),
                [fieldNum(InventTestAssociationTable, OrderType)]],

            [fieldNum(InventTestAssociationTable, TestExecution),
                [fieldNum(InventTestAssociationTable, OrderType)]],

            [fieldNum(InventTestAssociationTable, BlockProcess),
                [fieldNum(InventTestAssociationTable, OrderType)]],

            [fieldNum(InventTestAssociationTable, QuarantineOnFailure),
                [fieldNum(InventTestAssociationTable, OrderType)]]
        ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    public void defaultField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(InventTestAssociationTable, ItemSamplingId):
                this.initFromInventTestGroup();
                break;

            case fieldNum(InventTestAssociationTable, AcceptableQualityLevel):
                this.initFromInventTestGroup();
                break;

            case fieldNum(InventTestAssociationTable, ShowInfoOnCreate):
                if (this.TestExecution  != InventTestExecution::After)
                {
                    this.ShowInfoOnCreate   = NoYes::Yes;
                }
                break;

            case fieldNum(InventTestAssociationTable, DocumentType):
                if (!InventTestAssociationTable::isOrderTypeAndDocumentStatusConsistent(this.OrderType, this.DocumentType))
                {
                    this.setDocumentType('');
                }
                break;

            case fieldNum(InventTestAssociationTable, TestExecution):
                if (this.OrderType == InventTestReferenceType::Inventory)
                {
                    this.TestExecution = InventTestExecution::None;
                }
                break;

            case fieldNum(InventTestAssociationTable, BlockProcess):
                if (this.OrderType == InventTestReferenceType::Quarantine && this.BlockProcess == InventTestBlockProcess::None)
                {
                    this.BlockProcess = InventTestBlockProcess::End;
                }
                break;

            case fieldNum(InventTestAssociationTable, QuarantineOnFailure):
                if (!this.allowEditQuarantineOnFailure())
                {
                    // We never allow quarantine on failure for the types not allowing editing
                    this.QuarantineOnFailure = NoYes::No;
                }
                break;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>InventQualityManagement</ConfigurationKey>
	<DeveloperDocumentation>@SYS124043</DeveloperDocumentation>
	<EntityRelationshipType>Relationship</EntityRelationshipType>
	<Label>@SYS113806</Label>
	<TableGroup>Group</TableGroup>
	<TitleField1>OrderType</TitleField1>
	<TitleField2>DocumentType</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>Found</CacheLookup>
	<ClusteredIndex>AssociationIdx</ClusteredIndex>
	<Modules>Inventory</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<ReplacementKey>AssociationCreationSequenceIdx</ReplacementKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WrkCtrCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WrkCtrRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DocumentType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidFromDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidToDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestExecution</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BlockProcess</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemSamplingId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AssociationCreationSequenceNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@SYS9039</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventSiteId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WrkCtrCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WrkCtrRelation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>QualityOrderGeneration</Name>
			<Label>@SYS335642</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestExecution</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>showInfoOnCreate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>QualityOrderProcess</Name>
			<Label>@SYS339536</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>edit_blockProcess</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QuarantineOnFailure</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Specifications</Name>
			<Label>@SYS17781</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemSamplingId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AcceptableQualityLevel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidFromDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidToDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>System</Name>
			<Label>@SYS4278</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DocumentType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BlockProcess</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AcceptableQualityLevel</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventAcceptableQualityLevel</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AccountCode</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestAccountCode</ExtendedDataType>
			<EnumType>TableGroupAll</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountRelation</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestAccountRelation</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BlockProcess</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>InventTestBlockProcess</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DocumentType</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestDocumentType</ExtendedDataType>
			<EnumType>InventTestDocumentStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventSiteId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventSiteId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ItemCode</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestItemCode</ExtendedDataType>
			<EnumType>TableGroupAll</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemRelation</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestItemRelation</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemSamplingId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventItemSamplingId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OrderType</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>InventTestReferenceType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>QuarantineOnFailure</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestQuarantineOnFailure</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>showInfoOnCreate</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<Label>@SYS75822</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TestExecution</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>InventTestExecution</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TestGroupId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestGroupId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ValidFromDateTime</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ValidFromDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ValidToDateTime</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ValidToDateTime</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WrkCtrCode</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTestWrkCtrCode</ExtendedDataType>
			<EnumType>TableGroupAll</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WrkCtrRelation</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>WrkCtrIdBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>AssociationCreationSequenceNumber</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTestAssociationCreationSequenceNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ApplicableWarehouseType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>WHSApplicableWarehouseType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>QualityProcessingPolicy</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>WHSQualityProcessingPolicy</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>AssociationIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>OrderType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AccountCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemRelation</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AccountRelation</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WrkCtrCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WrkCtrRelation</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DocumentType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventSiteId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValidFromDateTime</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValidToDateTime</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TestExecution</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TestGroupId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ItemSamplingIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ItemSamplingId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DocumentType</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>AssociationCreationSequenceIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>AssociationCreationSequenceNumber</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>CustGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123826</EntityRelationshipRole>
			<RelatedTable>CustGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OrderType</Name>
					<Field>OrderType</Field>
					<ValueStr>InventTestReferenceType::Sales</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountCode</Name>
					<Field>AccountCode</Field>
					<ValueStr>TableGroupAll::GroupId</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>CustGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123523</EntityRelationshipRole>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OrderType</Name>
					<Field>OrderType</Field>
					<ValueStr>InventTestReferenceType::Sales</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountCode</Name>
					<Field>AccountCode</Field>
					<ValueStr>TableGroupAll::Table</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventItemSampling</Name>
			<Cardinality>ZeroMore</Cardinality>
			<CreateNavigationPropertyMethods>Yes</CreateNavigationPropertyMethods>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>InventItemSampling</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemSamplingId</Name>
					<Field>ItemSamplingId</Field>
					<RelatedField>InventItemSamplingId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventItemSamplingIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventSite</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventSite</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventSiteId</Name>
					<Field>InventSiteId</Field>
					<RelatedField>SiteId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>SiteIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123828</EntityRelationshipRole>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ItemCode</Name>
					<Field>ItemCode</Field>
					<ValueStr>TableGroupAll::Table</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemRelation</Name>
					<Field>ItemRelation</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTestGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTestGroup</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TestGroupId</Name>
					<Field>TestGroupId</Field>
					<RelatedField>TestGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TestGroupIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTestQualityGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124044</EntityRelationshipRole>
			<RelatedTable>InventTestQualityGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ItemCode</Name>
					<Field>ItemCode</Field>
					<ValueStr>TableGroupAll::GroupId</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemRelation</Name>
					<Field>ItemRelation</Field>
					<RelatedField>TestQualityGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>RouteGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124045</EntityRelationshipRole>
			<RelatedTable>RouteGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OrderType</Name>
					<Field>OrderType</Field>
					<ValueStr>InventTestReferenceType::RouteOpr</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountCode</Name>
					<Field>AccountCode</Field>
					<ValueStr>TableGroupAll::GroupId</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>RouteGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>RouteOprTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124046</EntityRelationshipRole>
			<RelatedTable>RouteOprTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountCode</Name>
					<Field>AccountCode</Field>
					<ValueStr>TableGroupAll::Table</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OrderType</Name>
					<Field>OrderType</Field>
					<ValueStr>InventTestReferenceType::RouteOpr</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>OprId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123829</EntityRelationshipRole>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>VendGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OrderType</Name>
					<Field>OrderType</Field>
					<ValueStr>InventTestReferenceType::Purch</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountCode</Name>
					<Field>AccountCode</Field>
					<ValueStr>TableGroupAll::GroupId</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>VendGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123524</EntityRelationshipRole>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OrderType</Name>
					<Field>OrderType</Field>
					<ValueStr>InventTestReferenceType::Purch</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountCode</Name>
					<Field>AccountCode</Field>
					<ValueStr>TableGroupAll::Table</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WrkCtrTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124047</EntityRelationshipRole>
			<RelatedTable>WrkCtrTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Resource</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>InventTestAssociationTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>IsIndividualResource_Extern</Name>
					<RelatedField>IsIndividualResource</RelatedField>
					<Value>1</Value>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OrderType</Name>
					<Field>OrderType</Field>
					<ValueStr>InventTestReferenceType::RouteOpr</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>WrkCtrCode</Name>
					<Field>WrkCtrCode</Field>
					<ValueStr>TableGroupAll::Table</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WrkCtrRelation</Name>
					<SourceEDT>WrkCtrIdBase</SourceEDT>
					<Field>WrkCtrRelation</Field>
					<RelatedField>WrkCtrId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WrkCtrTableGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124048</EntityRelationshipRole>
			<RelatedTable>WrkCtrTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ResourceGroup</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>InventTestAssociationTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>IsIndividualResource_Extern</Name>
					<RelatedField>IsIndividualResource</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OrderType</Name>
					<Field>OrderType</Field>
					<ValueStr>InventTestReferenceType::RouteOpr</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>WrkCtrCode</Name>
					<Field>WrkCtrCode</Field>
					<ValueStr>TableGroupAll::GroupId</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WrkCtrRelation</Name>
					<Field>WrkCtrRelation</Field>
					<RelatedField>WrkCtrId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>