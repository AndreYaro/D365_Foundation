<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;

public class ProjTable extends common
{
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the accounting currency of the company of the selected project.
    /// </summary>
    /// <returns>
    /// <c>CurrencyCode</c>
    /// </returns>
    /// <remarks>
    /// This display method is used in the infopart to display the accounting currency of the selected project's company.
    /// </remarks>
    display CurrencyCode accountingCurrency()
    {
        return CompanyInfoHelper::standardCurrency();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBudgetControlBeModified</Name>
				<Source><![CDATA[
    public boolean canBudgetControlBeModified(NoYes _activated)
    {
        DialogButton dialogButton;
        boolean      ret;

        if (_activated)
        {
            dialogButton = Box::yesNo(strFmt("@SYS300175", this.ProjId), DialogButton::Yes);
            if (dialogButton == DialogButton::Yes)
            {
                ret = true;
            }
        }
        else
        {
            dialogButton = Box::yesNo(strFmt("@SYS300176", this.ProjId), DialogButton::Yes);
            if (dialogButton == DialogButton::Yes)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccount</Name>
				<Source><![CDATA[
    protected boolean checkAccount()
    {
        CustVendorBlocked   blockLevel = CustTable::blocked(this.CustAccount);

        return this.validateBlockLevel(blockLevel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBlockLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the block level of a customer account.
    /// </summary>
    /// <param name = "_blockLevel">
    /// A block level enumeration to be validated.
    /// </param>
    /// <returns>
    /// true if the customer is not stopped; otherwise, false.
    /// </returns>
    protected boolean validateBlockLevel(CustVendorBlocked _blockLevel)
    {
        if (this.Type == ProjType::TimeMaterial || this.Type == ProjType::FixedPrice || (this.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled()))
        {
            switch (_blockLevel)
            {
                case CustVendorBlocked::All:
                    return checkFailed(strFmt("@SYS18389", this.CustAccount, enum2str(_blockLevel)));

                case CustVendorBlocked::Invoice:
                    return checkFailed(strFmt("@SYS18389", this.CustAccount, enum2str(_blockLevel)));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAlternateProject</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the alternate project is defined for budget consumption.
    /// </summary>
    /// <returns>
    ///    true if the alternate budget project has successfully validated; otherwise, false.
    /// </returns>
    private boolean checkAlternateProject()
    {
        boolean     ret = true;
        ProjId      origParentId, altParentId;
        container   origProjParentContainer, altProjParentContainer;
        ProjTable   projTablelTemp;
        NoYesId     allowBudgetOutSideHierarchy;

        projTablelTemp = ProjTable::find(this.AlternateBudgetProject);
        allowBudgetOutSideHierarchy = ProjParameters::find().AllowBudgetOutSideHierarchy;

        // Project stage of selected project is Finished.
        if (projTablelTemp.Status == ProjStatus::Completed)
        {
            ret = checkFailed(strFmt("@SYS301172", this.AlternateBudgetProject, projTablelTemp.Stage()));
        }

        // Restrain from selecting header project.
        if (ret && projTablelTemp.Header)
        {
            ret = checkFailed(strFmt("@SYS96612",this.AlternateBudgetProject));
        }

        //allowBudgetOutSideHierarchy is marked and selected project type is not similar to the original project.
        if (ret && allowBudgetOutSideHierarchy && (projTablelTemp.Type != ProjTable::find(this.ProjId).Type || this.ProjId == this.AlternateBudgetProject))
        {
            ret = checkFailed(strFmt("@SYS307219", this.AlternateBudgetProject));
        }

        if (!allowBudgetOutSideHierarchy)
        {
            origProjParentContainer = ProjTable::ancestors(this.ProjId);
            altProjParentContainer  = ProjTable::ancestors(this.AlternateBudgetProject);

            origParentId =  conPeek(origProjParentContainer, conLen(origProjParentContainer));
            altParentId  =  conPeek(altProjParentContainer, conLen(altProjParentContainer));

            // if original project has no parent.
            if (!origParentId)
            {
                origParentId = this.ProjId;
            }

            // if alternate budget project has no parent.
            if (!altParentId)
            {
                altParentId = this.AlternateBudgetProject;
            }

            // if selected alternate project is same as the original project or both have different parent.
            if (this.ProjId == this.AlternateBudgetProject || !origParentId)
            {
                ret = checkFailed(strFmt("@SYS307220", this.AlternateBudgetProject));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTAndMTypeBillingRule</Name>
				<Source><![CDATA[
    boolean checkTAndMTypeBillingRule()
    {
        PSAContractLineItems        psaContractLineItems;
        PSAContractLineItemsSetup   psaContractLineItemsSetup;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            select firstonly ProjId, ContractLineNum from psaContractLineItemsSetup
                where psaContractLineItemsSetup.ProjId == this.ProjId
                    join ContractLineNum, ProjInvoiceProjId, LineType from psaContractLineItems
                        where psaContractLineItemsSetup.ContractLineNum == psaContractLineItems.ContractLineNum
                            && psaContractLineItems.ProjInvoiceProjId == this.ProjInvoiceProjId
                            && psaContractLineItems.LineType == PSAContractLineType::TAndM;
        }

        return psaContractLineItemsSetup ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValid</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether the current record in the table is valid by checking if the <c>ProjId</c> field contains a value.
    /// </summary>
    /// <returns>
    ///    true if the current record is valid; otherwise, false.
    /// </returns>
    public boolean checkValid()
    {
        boolean ok = true;

        if (!this.ProjId)
        {
            ok = checkFailed("@SYS50091");
        }

        if (!this)
        {
            ok = checkFailed(strFmt(ProjTable::txtNotExist(), this.ProjId));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>childExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies whether sub projects exist for the current project record.
    /// </summary>
    /// <returns>
    /// true if sub projects exist; otherwise, false.
    /// </returns>
    display ProjChild childExist()
    {
        return ProjTable::child(this.ProjId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>CompanyInfo</c> record associated with the current record.
    /// </summary>
    /// <returns>
    /// The <c>CompanyInfo</c> record.
    /// </returns>
    public CompanyInfo companyInfo()
    {
        return CompanyInfo::findDataArea(this.company());
    }

]]></Source>
			</Method>
			<Method>
				<Name>contractAmountFixedPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the latest total amount of the contract entered for the project before or on the
    ///    specified date.
    /// </summary>
    /// <param name="_periodFrom">
    ///    The date on which the contract amount is based. The default value is set with the <c>dateMax</c>
    ///    method; optional.
    /// </param>
    /// <returns>
    ///    The contract amount for the current fixed price project.
    /// </returns>
    /// <remarks>
    ///    This method is used when you determine profit on a fixed price project. If the current project
    ///    record is a fixed price project, it uses data in the <c>ProjControlPeriodTable</c> table to
    ///    determine the amount.
    /// </remarks>
    display ProjContractAmount contractAmountFixedPrice(ProjPeriodFrom _periodFrom  = dateMax())
    {
        AmountMST contractSum;
        
        if (this.Type == ProjType::FixedPrice ||
            (this.ProjInvoiceProjId &&
             ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
             ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(this.ProjId, this.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice)))
        {
            DictTable dictTable = new DictTable(tableNum(ProjControlPeriodTable));
            if (dictTable.rights() >= AccessType::View)
            {
                ProjControlPeriodTable  projControlPeriodTable;
                select reverse firstonly ProjId, PeriodFrom, ActualContract, ctcContract from projControlPeriodTable
                    order by PeriodFrom
                    where   projControlPeriodTable.ProjId       == this.ProjId
                    &&      projControlPeriodTable.PeriodFrom   <= _periodFrom;

                contractSum  = projControlPeriodTable.ActualContract + projControlPeriodTable.ctcContract;
            }
        }

        return contractSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>contractCurrCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the currency code from the contract that is associated with this project.
    /// </summary>
    /// <returns>
    ///    The currency code from the contract that is associated with this project.
    /// </returns>
    public display CurrencyCode contractCurrCode()
    {
        return ProjInvoiceTable::find(this.ProjInvoiceProjId).CurrencyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>contractName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the contract description from the contract that is associated with this project.
    /// </summary>
    public display CompanyName contractName()
    {
        return ProjInvoiceTable::find(this.ProjInvoiceProjId).Description;
    }

]]></Source>
			</Method>
			<Method>
				<Name>contractValue</Name>
				<Source><![CDATA[
    [
        SysClientCacheDataMethodAttribute(true)
    ]
    public display ProjContractValueAmount contractValue()
    {
        AmountCur           ret;
        ProjOnAccTrans      projOnAccTrans;
        ProjOnAccTransSale  projOnAccTransSale;

        AccessType          projOnAccTransAllowedAccess;
        AccessType          projOnAccTransSaleAllowedAccess;

        projOnAccTransAllowedAccess = new DictTable(tableNum(ProjOnAccTrans)).rights();
        projOnAccTransSaleAllowedAccess = new DictTable(tableNum(ProjOnAccTransSale)).rights();

        if (projOnAccTransAllowedAccess >= AccessType::View && projOnAccTransSaleAllowedAccess >= AccessType::View)
        {
            CurrencyCode contractCurrCode = this.contractCurrCode();
            select sum(Amount) from projOnAccTransSale
                    where projOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
                exists join projOnAccTrans
                    where projOnAccTrans.TransId == projOnAccTransSale.TransId &&
                          projOnAccTrans.ProjID == this.ProjId &&
                          projOnAccTrans.CurrencyId == contractCurrCode;

            ret = projOnAccTransSale.Amount;

            while select Amount from projOnAccTransSale
                    where projOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
                join CurrencyId, TransDate from projOnAccTrans
                    where projOnAccTrans.TransId == projOnAccTransSale.TransId &&
                          projOnAccTrans.ProjID  == this.ProjId &&
                          projOnAccTrans.CurrencyId != contractCurrCode

            {
                ExchRate fixedExchRate = ProjInvoiceCurrency::find(this.ProjInvoiceProjId, projOnAccTrans.CurrencyId).ExchRate;

                if (fixedExchRate)
                {
                    Amount contractValue = CurrencyExchangeHelper::mstAmount(projOnAccTransSale.Amount,
                                                                             projOnAccTrans.CurrencyId,
                                                                             projOnAccTrans.TransDate,
                                                                             UnknownNoYes::Unknown,
                                                                             fixedExchRate);

                    ret = ret + CurrencyExchangeHelper::curAmount(contractValue,
                                                                  contractCurrCode,
                                                                  projOnAccTrans.TransDate,
                                                                  UnknownNoYes::Unknown);
                }
                else
                {
                    ret = ret + CurrencyExchangeHelper::curAmount2CurAmount(projOnAccTransSale.Amount,
                                                              projOnAccTrans.CurrencyId,
                                                              contractCurrCode,
                                                              projOnAccTrans.TransDate);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </summary>
    /// <param name="_defaultDimension">
    /// A dimension set to apply to the <c>defaultDimension</c> field on this table.
    /// </param>
    /// <param name="_dimensionCopy">
    /// A <c>dimensionCopy</c> object that was initialized with the current buffer; optional.
    /// </param>
    /// <returns>
    /// A dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are not overwritten.
    /// </remarks>
    public DimensionDefault copyDimension(
        DimensionDefault _defaultDimension,
        DimensionCopy    _dimensionCopy = DimensionCopy::newFromTable(this, this.companyInfo().RecId)
        )
    {
        return _dimensionCopy.copy(_defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountFixedPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the latest total cost amount for the project before or on the date passed in if the current project record is a fixed price project by using data in the <c>ProjControlPeriodTable</c> table.
    /// </summary>
    /// <param name="_periodFrom">
    ///    The date on which the cost amount is based. The default value is set with the <c>dateMax</c> method; optional.
    /// </param>
    /// <returns>
    ///    The cost amount for the current fixed price project.
    /// </returns>
    /// <remarks>
    ///    This method is used when you determine profit on a fixed price project.
    /// </remarks>
    display CostAmountProject costAmountFixedPrice(ProjPeriodFrom _periodFrom  = dateMax())
    {
        AmountMST costAmount;

        if (this.Type == ProjType::FixedPrice ||
            (this.ProjInvoiceProjId &&
             ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
             ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(this.ProjId, this.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice)))
        {
            DictTable dictTable = new DictTable(tableNum(ProjControlPeriodTable));
            if (dictTable.rights() >= AccessType::View)
            {
                ProjControlPeriodTable  projControlPeriodTable;
                select reverse firstonly projControlPeriodTable
                    order by PeriodFrom
                    where   projControlPeriodTable.ProjId       == this.ProjId &&
                            projControlPeriodTable.PeriodFrom   <= _periodFrom;

                costAmount = projControlPeriodTable.displayActualCostAmount() + projControlPeriodTable.ctcCostAmount;
            }
        }

        return costAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCreateItemReqFromPOLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if project can create item requirement.
    /// </summary>
    /// <returns>
    /// true if project is valid for creating item requirement; otherwise, false.
    /// </returns>
    internal boolean validateCreateItemReqFromPOLine()
    {
        boolean ret;

        if (FeatureStateProvider::isFeatureEnabled(ProjItemReqFundingSourceValidationFixFlight::instance()))
        {
            // For Cost, Internal, Investment type project, check if CustAccount is set on project.
            // For others, check customer account from Customer or Grant type funding source on contract.
            ret = this.type().custAccount() != '';
        }
        else
        {
            ret = this.CustAccount || ProjFundingSource::findCustAccount(this.ProjInvoiceProjId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesTable_ItemReq</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>SalesTable</c> record that is associated and initialized with details from the current project.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The currency code with which to create the <c>SalesTable</c> record.
    /// </param>
    /// <returns>
    ///    The <c>SalesTable</c> record.
    /// </returns>
    public SalesTable createSalesTable_ItemReq(CustCurrencyCode _currencyCode)
    {
        SalesTable      salesTable = null;

        ttsbegin;

        this.initializeSalesTable_ItemReq(salesTable, _currencyCode);

        if (!salesTable.validateWrite())
        {
            throw Exception::Error;
        }

        salesTable.insert();

        ttscommit;

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesTable_ItemReqMultFundingSources</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>SalesTable</c> record that is associated and initialized with details from the
    ///    current project and given funding source
    /// </summary>
    /// <param name="_currencyCode">
    ///    The currency code with which to create the <c>SalesTable</c> record.
    /// </param>
    /// <param name="_fundingSource">
    ///    The funding source to assign to the <c>SalesTable</c> record.
    /// </param>
    /// <returns>
    ///    The <c>SalesTable</c> record.
    /// </returns>
    public SalesTable createSalesTable_ItemReqMultFundingSources(CustCurrencyCode _currencyCode, ProjFundingSourceRefId _fundingSource)
    {
        SalesTable salesTable = null;

        ttsbegin;

        this.initializeSalesTable_ItemReq(salesTable, _currencyCode);

        salesTable.FundingSource = _fundingSource;
        ProjFundingSource selectedFundingSource = ProjFundingSource::find(_fundingSource);
        ProjParameters projParameters = ProjParameters::find();

        //CustAccount refers to the delivery customer
        if ((selectedFundingSource && projParameters.DefaultSalesOrderCustomerAccount == ProjDefaultSalesOrderCustomerAccount::FundingSource)
            || (projParameters.DefaultSalesOrderCustomerAccount == ProjDefaultSalesOrderCustomerAccount::Project && this.CustAccount == ''))
        {
            salesTable.CustAccount = selectedFundingSource.CustAccount;
        }
        else
        {
            salesTable.CustAccount = this.CustAccount;
        }

        salesTable.transferCustAccount();
        //InvoiceAccount refers to the customer that is being billed
        salesTable.InvoiceAccount = selectedFundingSource.CustAccount;

        if (!salesTable.validateWrite())
        {
            throw Exception::Error;
        }

        salesTable.insert();

        ttscommit;

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSalesTable_ItemReq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes sales order table record.
    /// </summary>
    /// <param name = "_salesTable">
    /// A sales order table buffer to be initialized.
    /// </param>
    /// <param name = "_currencyCode">
    /// A currency code to be set on the sales order table.
    /// </param>
    protected void initializeSalesTable_ItemReq(SalesTable _salesTable, CustCurrencyCode _currencyCode)
    {
        _salesTable.clear();

        _salesTable.ProjId        = this.ProjId;
        _salesTable.initValue(SalesType::ItemReq);

        _salesTable.SalesId       = NumberSeq::newGetNum(SalesParameters::numRefSalesId()).num();

        _salesTable.CurrencyCode  = _currencyCode;
        _salesTable.FixedExchRate = ProjInvoiceCurrency::find(this.projInvoice().ProjInvoiceProjId, _salesTable.CurrencyCode).ExchRate;
        _salesTable.setReportingCurrencyFixedExchangeRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectDefaultInvoiceAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method should be used when ProjItemRequirementMultipleFundingSourcesFeature is turned on.
    /// This method determines the default invoice account that should be used while creating all item requirements 
    /// on projects associated with a contract that has multiple funding sources 
    /// unless an invoice account is explicitly specified on the item requirement line.
    /// </summary>
    /// <param name = "_checkFeature">determines if feature check is required inside the method</param>
    /// <returns>Default invoice account (RecId of the funding source) </returns>
    public ProjFundingSourceRefId getProjectDefaultInvoiceAccount(boolean _checkFeature = true)
    {
        if (!_checkFeature || ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled())
        {
            if (this.DefaultFundingSource)
            {
                return this.DefaultFundingSource;
            }
            else
            {
                ProjFundingSource projFundingSource;

                select firstonly RecId from projFundingSource
                where projFundingSource.ContractId == this.ProjInvoiceProjId
                && ((projFundingSource.FundingType == ProjFundingType::Customer) || (projFundingSource.FundingType == ProjFundingType::Grant));

                return projFundingSource.RecId;
            }
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesTable_ItemReqFromSQ</Name>
				<Source><![CDATA[
    public SalesTable createSalesTable_ItemReqFromSQ(SalesQuotationLine _salesQuotationLine)
    {
        SalesTable      salesTable = null;

        ttsbegin;

        salesTable.clear();

        salesTable.ProjId       = this.ProjId;
        salesTable.initValue(SalesType::ItemReq);

        boolean projItemReqMultipleFundingSourcesFeatureEnabled = ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled();
        if (projItemReqMultipleFundingSourcesFeatureEnabled)
        {
            salesTable.FundingSource = this.getProjectDefaultInvoiceAccount(false);
        }
        
        salesTable.initFromSalesQuotationTable(_salesQuotationLine.salesQuotationTable());
        salesTable.SalesId      = NumberSeq::newGetNum(SalesParameters::numRefSalesId()).num();

        //If feature is on set Invoice account corresponding to Funding Source
        //Override value set by quotation
        if (projItemReqMultipleFundingSourcesFeatureEnabled && salesTable.FundingSource)
        {
            salesTable.InvoiceAccount = ProjFundingSource::find(salesTable.FundingSource).CustAccount;
        }
        salesTable.CurrencyCode = _salesQuotationLine.CurrencyCode;
        salesTable.FixedExchRate = ProjInvoiceCurrency::find(this.projInvoice().ProjInvoiceProjId, salesTable.CurrencyCode).ExchRate;
        salesTable.setReportingCurrencyFixedExchangeRate();

        salesTable.InclTax  = NoYes::No;

        if (!salesTable.validateWrite())
        {
            throw Exception::Error;
        }

        salesTable.insert();

        ttscommit;

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesTable_sales</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>SalesTable</c> record that is associated and initialized with details from the current
    ///    project.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The currency code with which to create the <c>SalesTable</c> record.
    /// </param>
    /// <param name="_salesQuotationLine">
    ///    A <c>SalesQuotationLine</c> record with which to associate the <c>SalesTable</c> record; optional.
    /// </param>
    /// <returns>
    ///    The <c>SalesTable</c> record.
    /// </returns>
    /// <remarks>
    ///    This method also associates the new <c>Salestable</c> record with a <c>SalesQuotationLine</c>
    ///    record if it is passed in as a parameter.
    /// </remarks>
    public SalesTable createSalesTable_sales(CustCurrencyCode _currencyCode, SalesQuotationLine _salesQuotationLine = null)
    {
        SalesTable  salesTable = null;

        ttsbegin;

        salesTable.clear();

        salesTable.ProjId       = this.ProjId;
        salesTable.initValue(SalesType::Sales);

        salesTable.SalesId      = NumberSeq::newGetNum(SalesParameters::numRefSalesId()).num();

        if (_salesQuotationLine)
        {
            salesTable.QuotationId = _salesQuotationLine.QuotationId;
        }

        salesTable.CurrencyCode = _currencyCode;
        salesTable.FixedExchRate = ProjInvoiceCurrency::find(this.projInvoice().ProjInvoiceProjId,salesTable.CurrencyCode).ExchRate;
        salesTable.setReportingCurrencyFixedExchangeRate();

        if (!salesTable.validateWrite())
        {
            throw Exception::Error;
        }

        salesTable.insert();

        ttscommit;

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the currency code for the invoice project associated with the current project if it
    /// exists. Otherwise, retrieves the currency code for the current company.
    /// </summary>
    /// <returns>
    /// The currency code.
    /// </returns>
    public CurrencyCode currencyId()
    {
        if (this.ProjInvoiceProjId)
        {
            return ProjInvoiceTable::find(this.ProjInvoiceProjId).CurrencyId;
        }

        return Ledger::accountingCurrency(CompanyInfo::findDataArea(curext()).RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>custName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the customer name.
    /// </summary>
    /// <returns>
    ///    The name of the customer.
    /// </returns>
    display CustName custName()
    {
        return CustTable::find(this.CustAccount).name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultFundingSource</Name>
				<Source><![CDATA[
    public ProjFundingSourceRefId defaultFundingSource()
    {
        ProjFundingSource   projFundingSource;

        select firstonly ContractId, RecId from projFundingSource where projFundingSource.ContractId == this.ProjInvoiceProjId;

        return projFundingSource.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteHierarchyVersions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes project hierarchy and all WBS versions.
    /// </summary>
    private void deleteHierarchyVersions()
    {
        // Important that these be called in this order. ProjPlanVersionsManager::deleteAllProjWBSVersions
        // depends on data that will be deleted by Hierarchy::deleteHierarchy.
        ProjPlanVersionsManager::deleteAllProjWBSVersions(this.ProjId);
        Hierarchy::deleteHierarchy(tableNum(ProjTable), this.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTableSortingOnDelete</Name>
				<Source><![CDATA[
    private void updateProjTableSortingOnDelete()
    {
        if (this.ParentId != '')
        {
            ttsbegin;
            ProjTable parentRecord = ProjTable::find(this.ParentId);
            ProjTableSorting parentSort = ProjTableSorting::findProjRecId(parentRecord.RecId, true);
            
            //All child records are deleted
            if (!parentRecord.childExist())
            {
                parentSort.EndNode = 1;
                parentSort.update();
            }
            
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete(boolean _skipSyncTrigger = false)
    {
        // <GIN>
        #ISOCountryRegionCodes
        // </GIN>

        CollabSiteManager       collabSiteManager;
        HierarchyTreeTable      hTreeTable;
        ProjTransferPrice       projTransferPrice, projTransferPriceTemp;

        // Check to see if the associated dimension attribute value has been used
        // in a way that would prevent deletion.
        if (!DimensionValidation::canDeleteEntityValue(this))
        {
            throw error(strFmt("@SYS134392", this.ProjId));
        }

        ttsbegin;

        // Update the associated dimension attribute value.
        DimensionAttributeValue::updateForEntityValueDelete(this);

        super();

        if (FeatureStateProvider::isFeatureEnabled(ProjTableFormSubprojectHierarchyGrid::instance()))
        {
            this.updateProjTableSortingOnDelete();
        }

        // Shop Floor Control
        if (Global::isConfigurationkeyEnabled(configurationKeyNum(Jmgjob)))
        {
            JmgJobTable::synchronizeProjTable(this, true);
        }

        this.deleteHierarchyVersions();

        //delete collabsite
        collabSiteManager = CollabSiteManager::construct(this);
        collabSiteManager.deleteSite(false);
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            delete_from hTreeTable
            where hTreeTable.psaNameLink == this.ProjId;
        }

        // delete transfer price
        while select crossCompany dataAreaId, projTable from projTransferPrice
            where projTransferPrice.ProjTable == this.RecId
        {
            changeCompany(projTransferPrice.dataAreaId)
            {
                projTransferPriceTemp = null;
                delete_from projTransferPriceTemp
                    where projTransferPriceTemp.ProjTable == projTransferPrice.ProjTable;
            }
        }

        if (TaxIntegrationUtils::isTransitDocumentEnabled())
        {
            this.TransitDocumentTransactionMap_IN::deleteTransitDocuments();
        }

        if (this.WIPProject && this.validateProjTypeForEstimateProject())
        {
            this.deleteEstimateProject();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjTypeForEstimateProject</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the project type.
    /// </summary>
    /// <returns>
    ///     true if the project type is either investment or fixed price.
    /// </returns>
    protected boolean validateProjTypeForEstimateProject()
    {
        return this.Type == ProjType::Investment ||
               this.Type == ProjType::FixedPrice ||
               (this.ProjInvoiceProjId &&
                ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
	            ProjMultipleContractLinesForProjectFeatureHelper::projectContainsFixedPriceComponent(this.ProjId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayExternalURL</Name>
				<Source><![CDATA[
    display ProjCollabSiteExternalURL displayExternalURL()
    {
        #DEFINE.HTTP("http://")

        int                 i;
        CollabSiteTable     collabSiteTable;
        DictTable dictTable = new DictTable(tableNum(CollabSiteTable));

        if (dictTable.rights() >= AccessType::View)
        {
            collabSiteTable = CollabSiteLink::getCollabSiteProject(this.ProjId);
            if (collabSiteTable)
            {
                i = strScan(collabSiteTable.ExternalURL, #HTTP, 1, strLen(collabSiteTable.ExternalURL));
                return (subStr(collabSiteTable.ExternalURL, i + strLen(#HTTP) ,strLen(collabSiteTable.ExternalURL)));
            }
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayInternalURL</Name>
				<Source><![CDATA[
    display ProjCollabSiteInternalURL displayInternalURL()
    {
        #DEFINE.HTTP("http://")

        int                 i;
        CollabSiteTable     collabSiteTable;
        DictTable dictTable = new DictTable(tableNum(CollabSiteTable));

        if (dictTable.rights() >= AccessType::View)
        {
            collabSiteTable = CollabSiteLink::getCollabSiteProject(this.ProjId);
            if (collabSiteTable)
            {
                i = strScan(collabSiteTable.InternalURL, #HTTP, 1, strLen(collabSiteTable.InternalURL));
                return (subStr(collabSiteTable.InternalURL, i + strLen(#HTTP) ,strLen(collabSiteTable.InternalURL)));
            }
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>editSubProjPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method opens a dialog box for the user to either update the field in all the sub projects or only in sub projects that have the same original value as the original value in current parent
    ///    project.
    /// </summary>
    /// <param name = "_projTableEditSubProjPrompt">
    ///     Instance of ProjTableEditSubProjPrompt to prompt the dialog.
    /// </param>
    /// <param name = "_skipPrompt">
    ///     Optional value to skip prompt.
    /// </param>
    /// <returns>
    ///     false if edit sub project running operation fails; otherwise, true.
    /// </returns>
    protected  boolean editSubProjPrompt(ProjTableEditSubProjPrompt _projTableEditSubProjPrompt, boolean _skipPrompt = false)
    {
        boolean ret;

        if (_skipPrompt)
        {
            ret = true;
        }
        else
        {
            if (_projTableEditSubProjPrompt.prompt())
            {
                _projTableEditSubProjPrompt.runOperation();
                ret = true;
            }
            else
            {
                ret = false;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editSubProj</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates a field in sub projects that belong to the current project record.
    /// </summary>
    /// <param name="_fieldId">
    ///    The ID for the field in the <c>ProjTable</c> table to update.
    /// </param>
    /// <param name="_newValue">
    ///    The new value to update the <c>fieldId</c> with in the sub projects.
    /// </param>
    /// <param name="_formerValue">
    ///    The original <c>fieldId</c> value of the parent project.
    /// </param>
    /// <param name="_arrayIdx">
    ///    The index of the element to update if the _<paramref name="fieldId" /> is an array field; optional.
    /// </param>
    /// <param name="_updateLinePropertyId">
    ///    The boolean value indicates whether to update the line property for sub projects or not; optional.
    /// </param>
    /// <returns>
    ///    False if the user cancelled out of the dialog; true otherwise.
    /// </returns>
    /// <remarks>
    ///    This method opens a dialog box for the user to either update the field in all the sub projects or only in sub projects that have the same original value as the original value in current parent
    ///    project.
    /// </remarks>
    public boolean editSubProj(
        FieldId     _fieldId,
        anytype     _newValue,
        anytype     _formerValue,
        ArrayIdx    _arrayIdx   = 0,
        boolean     _updateLinePropertyId = false)
    {
        ProjTableEditSubProjPrompt  projTableEditSubProjPrompt;
        ProjTable                   projTableOrig = ProjTable::find(this.ProjId);
        boolean                     research;

        if (this.ProjId && _newValue != _formerValue && this.childExist())
        {
            projTableEditSubProjPrompt = new ProjTableEditSubProjPrompt(this.ProjId, _fieldId, _newValue, _formerValue, _arrayIdx, false, ProjType::TimeMaterial, false, NoYes::No, _updateLinePropertyId);

            if (_updateLinePropertyId)
            {
                if (_arrayIdx)
                {
                    if (_fieldId == fieldNum(ProjTable,SortingId))
                    {
                        this.SortingId[_arrayIdx] = _newValue;
                    }
                }
                else if (_fieldId)
                {
                    this.(_fieldId) = _newValue;
                }
            }

            if (this.editSubProjPrompt(projTableEditSubProjPrompt))
            {
                projTableEditSubProjPrompt.runOperation();
                research = true;
            }
            else
            {
                return false;
            }

            if (this.validateWrite())
            {
                this.update();
            }

            if (FormDataUtil::isFormDataSource(this) && research)
            {
                FormDataUtil::getFormDataSource(this).research();
                FormDataUtil::getFormDataSource(this).findRecord(projTableOrig);
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSales</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the exchange rate between the currency passed in and the currency for the invoice project of the current project record on a particular date.
    /// </summary>
    /// <param name="_transDate">
    ///    The date used to determine the exchange rate; optional.
    /// </param>
    /// <param name="_currencyCode">
    ///    The currency for which to determine the exchange rate; optional.
    /// </param>
    /// <returns>
    ///    The exchange rate.
    /// </returns>
    /// <remarks>
    ///    If one does not exist, it retrieves the exchange rate between the currency passed in and the currency used in the current company.
    /// </remarks>
    public ExchRate exchRateSales(
        TransDate       _transDate      = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        CurrencyCode    _currencyCode   = this.currencyId())
    {
        if (ProjInvoiceCurrency::exist(this.ProjInvoiceProjId,_currencyCode))
        {
            return ProjInvoiceCurrency::find(this.ProjInvoiceProjId,_currencyCode).ExchRate;
        }

        return ExchangeRateHelper::exchRate(_currencyCode, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceCreate</Name>
				<Source><![CDATA[
    public void formMethodDataSourceCreate(FormRun _element, Object projTable_ds, ProjId _parentProjId='') //second parm must be of type object!
    {
        this.numberSeqFormHandler(_element, projTable_ds).formMethodDataSourceCreatePre();

        if (_parentProjId)
        {
            this.ProjId = ProjTable::generateNextSubProjectId(_parentProjId);
        }
        else
        {
            this.numberSeqFormHandler(_element, projTable_ds).formMethodDataSourceCreate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceValidateWrite</Name>
				<Source><![CDATA[
    public boolean formMethodDataSourceValidateWrite(FormRun _element, Object projTable_ds,boolean _superValue = true)
    {
        boolean ret = true;

        if (!this.numberSeqFormHandler(_element, projTable_ds).formMethodDataSourceValidateWrite(_superValue))
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceWrite</Name>
				<Source><![CDATA[
    public void formMethodDataSourceWrite(FormRun _element, Object projTable_ds)//Second parm must be object
    {
        this.numberSeqFormHandler(_element, projTable_ds).formMethodDataSourceWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupName</Name>
				<Source><![CDATA[
    public display Name groupName()
    {
        return ProjGroup::find(this.ProjGroupId,false).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasBudgetedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the selected project has some posted transactions that are associated with the
    ///    budget.
    /// </summary>
    /// <returns>
    ///    true if any posted transactions exist; otherwise, false.
    /// </returns>
    public boolean hasBudgetedTransactions()
    {
        boolean                         ret = false;
        ProjTransPosting                projTransPosting;
        ProjBudgetReductionHistory      projBudgetReductionHistory;

        if (!this.Header)
        {
            select firstonly RecId from projBudgetReductionHistory
                exists join TransId, ProjId from projTransPosting
                        where projTransPosting.TransId == projBudgetReductionHistory.ProjTransId &&
                                projTransPosting.ProjId == this.ProjId;

            if (projBudgetReductionHistory)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCommittedOrPostedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the selected project has posted or committed any associated transactions.
    /// </summary>
    /// <returns>
    ///    true if there are associated posted transactions; otherwise, false.
    /// </returns>
    public boolean hasCommittedOrPostedTransactions()
    {
        boolean                         ret = false;
        ProjTransPosting                projTransPosting;
        ProjForecastReductionHistory    projForecastReductionHistory;
        ProjBudgetReductionHistory      projBudgetReductionHistory;
        CostControlTransCommittedCost   costControlTransCommittedCost;

        if (!this.Header)
        {
            select firstonly RecId from projForecastReductionHistory
                exists join TransId, ProjId from projTransPosting
                        where projTransPosting.TransId == projForecastReductionHistory.ProjTransId &&
                              projTransPosting.ProjId == this.ProjId;

            select firstonly RecId from projBudgetReductionHistory
                exists join TransId, ProjId from projTransPosting
                        where projTransPosting.TransId == projBudgetReductionHistory.ProjTransId &&
                              projTransPosting.ProjId == this.ProjId;

            // As soon as a record is saved on purchase orders, sales orders e.t.c,  a record is inserted in this table
            select firstonly ProjId from costControlTransCommittedCost where costControlTransCommittedCost.ProjId == this.ProjId;

            if (projForecastReductionHistory || projBudgetReductionHistory || costControlTransCommittedCost)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasBooking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if a project already has any booking.
    /// </summary>
    /// <returns>
    /// A boolean value indicate if the project already has any booking.
    /// </returns>
    public boolean hasBooking()
    {
        ResBookingView          bookingView;
        ActivityRecId           rootActivity = ProjWBS::getRootActivityRecId(this.ProjId);

        //---has reservation on project level
        select firstonly bookingView
            where bookingView.Activity == rootActivity;

        return bookingView ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>image</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the image corresponding to a particular type of project.
    /// </summary>
    /// <param name="_projType">
    ///    The type of project. The default is the type of the current project record; optional.
    /// </param>
    /// <returns>
    ///    The image for a particular type of project.
    /// </returns>
    public ImageRes image(ProjType _projType = this.Type)
    {
        #resAppl
        int retval;

        switch (_projType)
        {
            case ProjType::TimeMaterial :
                retval = #ImageProjTimeMaterial;
                break;

            case ProjType::FixedPrice   :
                retval = #ImageProjFixedPrice;
                break;

            case ProjType::Internal     :
                retval = #ImageProjInternal;
                break;

            case ProjType::Investment   :
                retval = #ImageProjInvestment;
                break;

            case ProjType::Time         :
                retval = #ImageProjTime;
                break;
        }

        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>imageDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the image corresponding to the type of the current project.
    /// </summary>
    /// <returns>
    ///    The image for the current project.
    /// </returns>
    display ImageRes imageDisplay()
    {
        return this.image();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes fields for the current project record with values from the specified customer record.
    /// </summary>
    /// <param name="_custTable">
    ///    The customer record.
    /// </param>
    /// <remarks>
    ///    This method sets the delivery address fields for the current project record with the delivery
    ///    address for the customer. If a delivery address for the customer does not exist, it sets the
    ///    delivery address fields for the current project with the address for the customer.
    /// </remarks>
    public void initFromCustTable(CustTable _custTable)
    {
        LogisticsLocationEntity location;
        LogisticsLocation       logisticsLocation;
        LogisticsPostalAddress  logisticsPostalAddress;

        this.CustAccount = _custTable.AccountNum;

        if (this.mustInitializeDeliveryLocationFromCustTable())
        {
            //create location and copy address to project
            logisticsLocation = LogisticsLocationDefault::getDefaultActiveLocationByType(_custTable,LogisticsLocationRoleType::Delivery);

            // If an alt. deliverye address exist, we will use this as delivery address on the project
            if (!logisticsLocation.RecId)
            {
                // use the address on the customer.
                location = DirParty::primaryPostalAddressLocation(_custTable.Party,this.startDateTime());
            }
            else
            {
                location = LogisticsLocationEntity::constructFromLocationRecId(logisticsLocation.RecId);
            }

            if (location && location.parmLocationRecId())
            {
                if (this.DeliveryLocation == 0)
                {
                    ttsbegin;
                    // Create a location record
                    logisticsLocation = LogisticsLocation::create(location.parmLocationDescription(),true);
                    this.DeliveryLocation = logisticsLocation.RecId;

                    // Copy Address to location record
                    logisticsPostalAddress.data(location.getPostalAddress());
                    logisticsPostalAddress.Location = logisticsLocation.RecId;
                    logisticsPostalAddress.insert();
                    ttscommit;
                }
                else
                {
                    RecId locationRecId;
                    
                    if (this.orig().CustAccount)
                    {
                        CustTable origCustTable = CustTable::find(this.orig().CustAccount);
                        locationRecId = LogisticsLocationDefault::getDefaultActiveLocationByType(origCustTable, LogisticsLocationRoleType::Delivery).RecId;
                        if (!locationRecId)
                        {
                            locationRecId = DirParty::primaryPostalAddressLocation(origCustTable.Party, this.startDateTime()).parmLocationRecId();
                        }
                    }

                    if (this.DeliveryLocation == locationRecId)
                    {
                        this.DeliveryLocation = location.parmLocationRecId();
                    }
                    else
                    {
                        ttsbegin;

						// Only update the logisticLocation description for existing projects.
						if (this.RecId)
                        {
							logisticsLocation = LogisticsLocation::find(this.DeliveryLocation, true);
							logisticsLocation.Description = location.parmLocationDescription();
							logisticsLocation.update();
                        }

                        // Update address to new address
                        logisticsPostalAddress = LogisticsPostalAddress::findByLocation(this.DeliveryLocation, true);

                        if (this.orig().ProjInvoiceProjId != this.ProjInvoiceProjId || this.orig().CustAccount != this.CustAccount)
                        {
                            // Delete LogisticsPostalAddress record only if it is not being referenced anywhere else.
                            if (this.RecId && LogisticsLocationEntity::canDeletePostalAddress(logisticsPostalAddress.RecId, conNull(), false))
                            {
                                logisticsPostalAddress.delete();
                            }
							else if (!this.RecId)
                            {
								// Since DeliveryLocation != 0 and not a saved record, this is a subproject being created.
								// The Deliverylocation value was copied from the parent.
								// Project doesn't share addresses. Create a new logisticsLocation and assign to the record.
                                logisticsLocation = LogisticsLocation::create(location.parmLocationDescription(), true);
                                this.DeliveryLocation = logisticsLocation.RecId;
                            }

                            logisticsPostalAddress.clear();
                            logisticsPostalAddress.data(location.getPostalAddress());
                            logisticsPostalAddress.Location = logisticsLocation.RecId;
                            logisticsPostalAddress.ValidFrom = DateTimeUtil::utcNow();
                            logisticsPostalAddress.insert();
                        }
                        
                        ttscommit;
                    }
                }
                    
                this.DlvName = location.parmLocationDescription();
            }
            else
            {
                this.DeliveryLocation = 0;
                this.DlvName = '';
            }
        }

        this.Email      = _custTable.email();
        this.DefaultDimension   = _custTable.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInitializeDeliveryLocationFromCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if delivery location must be initialized.
    /// </summary>
    /// <returns>
    /// true if the delivery location must be initialized; otherwise, false.
    /// </returns>
    protected boolean mustInitializeDeliveryLocationFromCustTable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes fields for the current project record with values from the specified project invoice or
    ///    customer associated with the project.
    /// </summary>
    /// <param name="_projInvoiceTable">
    ///    The invoice project ID.
    /// </param>
    /// <remarks>
    ///    This method sets the <c>TaxGroupId</c> field for the current project record to the
    ///    <c>TaxGroupId</c> value for the invoice project. If a <c>TaxGroupId</c> value for the invoice
    ///    project does not exist, it sets the <c>TaxGroupId</c> field to the <c>TaxGroupId</c> value for the
    ///    customer associated to the current project.
    /// </remarks>
    public void initFromInvoice(ProjInvoiceTable _projInvoiceTable)
    {
        CustTable           custTable;
        ProjFundingSource   projFundingSource;

        this.ProjPriceGroup = _projInvoiceTable.ProjPriceGroup;
        this.TaxGroupId     = _projInvoiceTable.TaxGroupId;

        // Retrieve information based on project customer
        custTable               = CustTable::find(this.CustAccount);

        select firstonly DefaultDimension from projFundingSource
             where projFundingSource.ContractId == _projInvoiceTable.ProjInvoiceProjId &&
                 projFundingSource.Party == custTable.Party;

        if (this.ParentId)
        {
            this.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(ProjTable::find(this.ParentId).DefaultDimension, projFundingSource.DefaultDimension);
        }
        else
        {
            this.DefaultDimension = projFundingSource.DefaultDimension;
        }

        if (!this.TaxGroupId)
        {
            this.TaxGroupId = custTable.TaxGroup;
        }

        if (!this.isAssociatedToMultipleFundingSourcesContract() && ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled())
        {
            this.DefaultFundingSource = this.getProjectDefaultInvoiceAccount();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromParent</Name>
				<Source><![CDATA[
    public void initFromParent(ProjId _projId)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            this.status().initFromParent(_projId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromProjGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>ProjLedgerPosting</c> and <c>ProjLinePropertySearch</c> fields for the current project record with values of the equivalent fields of the <c>ProjGroup</c> record passed in as a
    ///    parameter.
    /// </summary>
    /// <param name="projGroup">
    ///    The project group.
    /// </param>
    public void initFromProjGroup(ProjGroup projGroup)
    {
        if (!projGroup)
        {
            return;
        }

        this.ProjLedgerPosting         = projGroup.LedgerPosting;
        this.ProjLinePropertySearch    = projGroup.ProjLinePropertySearch;
        this.CheckBudget               = projGroup.CheckBudget;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProjectFromCustomerAndInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the project from the specified project invoice or customer associated with the project.
    /// </summary>
    /// <param name = "_projInvoice">
    ///     The invoice project ID.
    /// </param>
    /// <param name = "isCustomerTransferNeeded">
    ///     A boolean variable which specifies whether the customer transfer is needed.
    /// </param>
    protected void initProjectFromCustomerAndInvoice(ProjInvoiceTable _projInvoice, boolean _isCustomerTransferNeeded)
    {
        if (_isCustomerTransferNeeded)
        {
            this.initFromCustTable(CustTable::find(this.CustAccount, false));
        }

        this.initFromInvoice(_projInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue(boolean _callSuper = true)
    {
        PSAParameters   tpsaParameters = PSAParameters::find();
        ProjParameters      projParameters  = ProjParameters::find();

        this.Created                            = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        this.ValidateProjCategory               = (projParameters.ValidationProjCategory == ProjValParameter::None) ? NoYes::No : NoYes::Yes;

        this.RequireActivityExpenseForecast     = projParameters.RequireActivityExpenseForecast;
        this.RequireActivityHourForecast        = projParameters.RequireActivityHourForecast;
        this.RequireActivityItemForecast        = projParameters.RequireActivityItemForecast;

        this.RequireActivityExpenseTrx          = projParameters.RequireActivityExpenseTrx;
        this.RequireActivityHourTrx             = projParameters.RequireActivityHourTrx;
        this.RequireActivityItemTrx             = projParameters.RequireActivityItemTrx;

        // for budgeting
        this.UseBudgeting                       = projParameters.UseBudgeting;
        this.ProjBudgetaryControlOn             = projParameters.ProjBudgetaryControlOn;
        this.ProjBudgetOverrunOption            = projParameters.ProjBudgetOverrunOption;
        this.ProjBudgetInterval                 = projParameters.ProjBudgetInterval;
        this.ProjCarryForwardNegativeBudget     = projParameters.ProjCarryForwardNegativeBudget;
        this.ProjCarryForwardRemainingBudget    = projParameters.ProjCarryForwardRemainingBudget;
        this.ProjBudgetManagement               = projParameters.ProjBudgetManagement;

        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            this.Type = ProjType::None;
        }

        // No default project group for project created from CE integration.
        if (!ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
        {
            ProjGroup projGroup;
            select count(RecId) from projGroup where projGroup.ProjType == this.Type;
            if (projGroup.RecId == 1)
            {
                select firstonly projGroup where projGroup.ProjType == this.Type;
                this.ProjGroupId = projGroup.ProjGroupId;
                this.initFromProjGroup(projGroup);
            }
        }

        if (_callSuper)
        {
            super();
        }
        this.psaForecastModelIdExternal = ProjParameters::find().OriginalForecastModel;

        this.MinTimeIncrement                   = projParameters.MinTimeIncrement;
        this.TimePostDetailSummary              = projParameters.PostDetailSummary;

        this.Format                             = projParameters.DisplayFormat;

        // Default calendar--resource scheduling enhancement
        if (!this.psaSchedCalendarId)
        {
            this.psaSchedCalendarId = PSAParameters::find().SchedDefaultCalendar;
            if (!WorkCalendarDate::isPickupDate(this.psaSchedCalendarId, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())))
            {
                this.psaSchedStartDate  = WorkCalendar::findOpenDateForward(this.psaSchedCalendarId,DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),this.psaSchedFromTime);
                this.psaSchedEndDate    = this.psaSchedStartDate;
            }
            else
            {
                this.psaSchedStartDate  = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                this.psaSchedEndDate    = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            }
            this.psaSchedDuration       = 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setShopFloorControlJobId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the shop floor control job ID.
    /// </summary>
    public void setShopFloorControlJobId()
    {
        // Get shop floor control job ID
        if (this.mustGetNewJobId())
        {
            this.JobId = NumberSeq::newGetNum(JmgParameters::numRefIpcActivityId()).num();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustGetNewJobId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the project table record must be get new job identification number.
    /// </summary>
    /// <returns>
    /// true if a new job identification number needs to be get; otherwise, false.
    /// </returns>
    protected boolean mustGetNewJobId()
    {
        return !this.JobId && Global::isConfigurationkeyEnabled(configurationKeyNum(Jmgjob));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a new project record into the table.
    /// </summary>
    public void insert()
    {
        this.setShopFloorControlJobId();

        // Update project budget management setting to sync with the parent project setting.
        if (this.ParentId)
        {
            this.ProjBudgetManagement = ProjTable::find(this.ParentId).ProjBudgetManagement;
        }

        super();

        if (FeatureStateProvider::isFeatureEnabled(ProjTableFormSubprojectHierarchyGrid::instance()))
        {
            this.updateProjTableSortingOnInsert();
        }

        // Sync with parent project.
        if (this.ParentId)
        {
            ttsbegin;

            ProjLinePropertySetup	projLinePropertySetupParent;

            select firstonly projLinePropertySetupParent where projLinePropertySetupParent.ProjRelation == this.ParentId;
            if (projLinePropertySetupParent.RecId)
            {
                ProjLinePropertySetup	projLinePropertySetupChild;

                projLinePropertySetupChild.ProjCode = projLinePropertySetupParent.ProjCode;
                projLinePropertySetupChild.ProjRelation = this.ProjId;
                projLinePropertySetupChild.CategoryCode = projLinePropertySetupParent.CategoryCode;
                projLinePropertySetupChild.LinePropertyId = projLinePropertySetupParent.LinePropertyId;
                projLinePropertySetupChild.insert();
            }
            ttscommit;
        }

        // Shop Floor Control
        if (Global::isConfigurationkeyEnabled(configurationKeyNum(Jmgjob)))
        {
            JmgJobTable::synchronizeProjTable(this);
        }

        // <GTE>
        if (TaxIntegrationUtils::isTransitDocumentEnabled())
        {
            ProjInvoiceTable projInvoiceTable = ProjInvoiceTable::find(this.ProjInvoiceProjId);
            if (this.verifyProjTypeAndProjInvoiceRecord(projInvoiceTable))
            {
                // Form tracking
                TransitDocumentManager_IN transitDocManager = TransitDocumentManager_IN::newManager();
                if (transitDocManager.existsAnyTransitDocType() &&
                        transitDocManager.existTransitRuleForTransType(tableNum(ProjInvoiceTable)))
                {
                    // Always creates the default trans tax information for project
                    if (TaxIntegrationUtils::isTaxInformationEnabled())
                    {
                        TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(projInvoiceTable);
                    }
                    transitDocManager.transit(projInvoiceTable, this);
                    if (TaxIntegrationUtils::isTaxInformationEnabled())
                    {
                        TransTaxInformation transTaxInformationProject = TransTaxInformationHelper::newHelper().findTransTaxInformationByRecord(this);
                        if (transTaxInformationProject && this.CustAccount)
                        {
                            ttsbegin;
                            transTaxInformationProject.selectForUpdate(true);
                            TransTaxInformationHelper::initFromCustVend(transTaxInformationProject, CustTable::find(this.CustAccount));
                            transTaxInformationProject.update();
                            ttscommit;
                        }
                    }
                }
            }
        }
        // </GTE>

        //create Hierarchy record
        HierarchyCreate hierarchyCreate = HierarchyCreate::construct(HierarchyType::Project);
        hierarchyCreate.parmSourceCommon(this);
        hierarchyCreate.run();
        ProjPlanVersionsManager::createDraft(hierarchyCreate.parmHierarchy().HierarchyId, this.ProjId, this.PSASchedStartDate, this.PSASchedEndDate, this.ProjId);
        if (Global::isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            if (this.verifyProjType())
            {
                PSAProjFundingSourceRetain::initFromProjFundingSource(this.ProjInvoiceProjId, this.ProjId, this.ParentId);
                PSAProjWorkComplete::initFromProjTable(this.ProjId);
            }
        }

        DimensionDefaultFacade::copyDimensionValueToDefaultDimensionField(this, fieldNum(ProjTable, ProjId), this, fieldNum(ProjTable, DefaultDimension), true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTableSortingOnInsert</Name>
				<Source><![CDATA[
    private void updateProjTableSortingOnInsert()
    {
        ttsbegin;
        const str hierarchyLevelTemplateField = 'HierarchyLevel%1';

        ProjTableSorting projTableSorting;
        if (this.ParentId)
        {
            ProjTable parentProj = ProjTable::find(this.ParentId);
            ProjTableSorting parentProjTableSorting  = ProjTableSorting::findProjRecId(parentProj.RecId, true);
            if (!parentProjTableSorting)
            {
                ProjTableSortingDataHelper::performMigrationForProject(parentProj.ProjId);
            }
            else
            {
                projTableSorting.data(parentProjTableSorting);
                projTableSorting.RefProjTable = this.RecId;
                int level = projTableSorting.ProjHierarchyLevel + 1;

                // Get max projsiblingnumber and add 1
                ProjTable localProjTable;
                ProjTableSorting localProjTableSorting;
                select maxof(ProjSiblingNumber)
                from localProjTableSorting join localProjTable
                        where localProjTable.RecId == localProjTableSorting.RefProjTable &&
                              localProjTable.ParentId == this.ParentId;
                int siblingNumber = localProjTableSorting.ProjSiblingNumber + 1;

                projTableSorting.setFieldValue(strFmt(hierarchyLevelTemplateField, level), siblingNumber);
                projTableSorting.ProjHierarchyLevel = level;
                projTableSorting.PathId = parentProjTableSorting.PathId + '.' + int2str(siblingNumber);
                projTableSorting.ProjSiblingNumber = siblingNumber;
                projTableSorting.EndNode = FalseTrue::True;
                projTableSorting.insert();

                parentProjTableSorting.EndNode = FalseTrue::False;
                parentProjTableSorting.update();
            }
        }
        else
        {
            projTableSorting.RefRootProjTable = this.RecId;
            projTableSorting.RefProjTable = this.RecId;
            projTableSorting.HierarchyLevel1 = 1;
            projTableSorting.ProjHierarchyLevel = 1;
            projTableSorting.PathId = '1';
            projTableSorting.ProjSiblingNumber = 1;
            projTableSorting.EndNode = FalseTrue::True;
            projTableSorting.insert();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyProjTypeAndProjInvoiceRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies the <c>ProjInvoiceTable</c> table record.
    /// </summary>
    /// <param name = "_projInvoiceTable">
    ///     An instance of <c>ProjInvoiceTable</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if <c>TransTaxInformation</c> table can be updated; otherwise, false.
    /// </returns>
    protected boolean verifyProjTypeAndProjInvoiceRecord(ProjInvoiceTable _projInvoiceTable)
    {
        return _projInvoiceTable &&
               (this.Type == ProjType::TimeMaterial ||
                this.Type == ProjType::FixedPrice ||
                ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled());
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyProjType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check if the project type is of type time and material or fixed price.
    /// </summary>
    /// <returns>
    ///     true if the project type is either fixed price or time and material; otherwise, fasle.
    /// </returns>
    protected boolean verifyProjType()
    {
        return this.Type == ProjType::FixedPrice ||
               this.Type == ProjType::TimeMaterial ||
               (this.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankDocumentCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a bank document has been created for this order.
    /// </summary>
    /// <returns>
    /// true if it is created; otherwise, false
    /// </returns>
    public boolean isBankDocumentCreated()
    {
        boolean ret = false;

        if (this.isMarkedForBankLG())
        {
            if (this.BankLGDocumentMap::isLinkedToGuarantee())
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustomerTransferNeeded</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether a customer transfer is required.
    /// </summary>
    /// <returns>
    ///     true if customer transfer is needed; otherwise false.
    /// </returns>
    protected boolean isCustomerTransferNeeded()
    {
        boolean needed = false;

        if (this.CustAccount)
        {
            if (this.isCustomerTransferPromptReq())
            {
                if (Box::yesNo("@SYS418" + '\n\n'+CustTable::promptAddress(this.CustAccount), DialogButton::Yes) == DialogButton::Yes)
                {
                    needed = true;
                }
            }
            else
            {
                needed = true;
            }
        }

        return needed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustomerTransferPromptReq</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether a transfer prompt is required.
    /// </summary>
    /// <returns>
    ///     true if transfer prompting is needed; otherwise false.
    /// </returns>
    protected boolean isCustomerTransferPromptReq()
    {
        return ProjParameters::find().PromptTransferCustOnProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMarkedForBankLG</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the project is marked for letter of guarantee.
    /// </summary>
    /// <returns>
    /// true if the project order is marked; otherwise, false.
    /// </returns>
    public boolean isMarkedForBankLG()
    {
        return this.BankDocumentType == BankLGDocumentType::LetterOfGuarantee;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWBSEditable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the WBS for this Project is editable
    /// </summary>
    /// <returns>
    /// True, if the WBS is editable; false otherwise.
    /// </returns>
    public boolean isWBSEditable()
    {
        return this.Status != ProjStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTravelRequisitionAllowedForMultipleFundingSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether it is allowed to create a travel requisition for a project associated to a contract with multiple funding sources.
    /// </summary>
    /// <returns>true if it is allowed to create a travel requisition for a project associated to a contract with multiple funding sources; otherwise, false.</returns>
    public boolean isTravelRequisitionAllowedForMultipleFundingSources()
    {
        return !this.isAssociatedToMultipleFundingSourcesContract();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemRequirementAllowedForMultipleFundingSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether it is allowed to create an item requirement for a project associated to a contract with multiple funding sources.
    /// </summary>
    /// <returns>true if it is allowed to create an item requirement for a project associated to a contract with multiple funding sources; otherwise, false.</returns>
    public boolean isItemRequirementAllowedForMultipleFundingSources()
    {
        boolean ret = !this.isAssociatedToMultipleFundingSourcesContract() || ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled();
        if (!ret)
        {
            ApplicationEventSource::EventWriteProjItemReqWithMFSNotAllowed(ProjTelemetryConstants::ProjSCM_ItemReqWithMFSInvalid, '1', '');
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMultipleFundingSourcesWithItemReqMultFundSourcesFeatureEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if associated to a contract with multiple funding sources and the multiple funding sources for an item requirement is enabled.
    /// </summary>
    /// <returns>true if the contract has multiple funding sources and the multiple funding sources for an item requirement is enabled; otherwise, false.</returns>
    public boolean hasMultipleFundingSourcesWithItemReqMultFundSourcesFeatureEnabled()
    {
        return this.isAssociatedToMultipleFundingSourcesContract() && ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesOrderAllowedForMultipleFundingSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether it is allowed to create a sales order for a project associated to a contract with multiple funding sources.
    /// </summary>
    /// <returns>true if it is allowed to create a sales order for a project associated to a contract with multiple funding sources; otherwise, false.</returns>
    public boolean isSalesOrderAllowedForMultipleFundingSources()
    {
        return !this.isAssociatedToMultipleFundingSourcesContract();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllowSalesOrdersForMultipleFundingSourcesParamEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether it is allowed to create a sales order for a project associated to a contract with multiple funding sources
    /// based on whether the AllowSalesOrderForMultipleFundingSources parameter is enabled.
    /// </summary>
    /// <returns>true if the AllowSalesOrderForMultipleFundingSources parameter is enabled; otherwise, false.</returns>
    public boolean isAllowSalesOrdersForMultipleFundingSourcesParamEnabled()
    {
        return ProjParameters::find().AllowSalesOrdersForMultipleFundingSources;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAssociatedToMultipleFundingSourcesContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the project is associated to a contract with multiple funding sources.
    /// </summary>
    /// <returns>true if the project is associated to a contract with multiple funding sources; otherwise, false.</returns>
    internal boolean isAssociatedToMultipleFundingSourcesContract()
    {
        return this.ProjInvoiceProjId && ProjFundingSource::numberOfFundingSources(this.ProjInvoiceProjId) != 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>latestCompletePct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the latest completion percentage  in the <c>ProjControlPeriodTable</c> table for the date that
    /// is passed in as a parameter if the current project is a fixed price project.
    /// </summary>
    /// <param name="_periodFrom">
    /// The date for which to get the completion percentage. The default value is set with the
    /// <c>dateMax</c> method; optional.
    /// </param>
    /// <returns>
    /// The completion percentage.
    /// </returns>
    display ProjControlCompletePct latestCompletePct(ProjPeriodFrom _periodFrom  = dateMax())
    {
        ProjControlCompletePct  completePct;
        
        if (this.Type == ProjType::FixedPrice ||
            (this.ProjInvoiceProjId &&
             ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
             ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(this.ProjId, this.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice)))
        {
            DictTable dictTable = new DictTable(tableNum(ProjControlPeriodTable));
            if (dictTable.rights() >= AccessType::View)
            {
                ProjControlPeriodTable projControlPeriodTable;
                select reverse firstonly ProjId, PeriodFrom, CompletePct from projControlPeriodTable
                    order by PeriodFrom
                    where projControlPeriodTable.ProjId     == this.ProjId      &&
                        projControlPeriodTable.PeriodFrom <= _periodFrom;
                completePct = projControlPeriodTable.CompletePct;
            }
        }
        return completePct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>latestPeriodFromFixedPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the latest begin date for the record in the <c>ProjControlPeriodTable</c> table earlier
    /// than the date passed in as a parameter if the current project is a fixed price project.
    /// </summary>
    /// <param name="_periodFrom">
    /// The default date is set with the <c>dateMax</c> method; optional.
    /// </param>
    /// <returns>
    /// The begin date.
    /// </returns>
    display ProjPeriodFrom latestPeriodFromFixedPrice(ProjPeriodFrom _periodFrom  = dateMax())
    {
        ProjPeriodFrom periodFrom = dateNull();
        
        if (this.Type == ProjType::FixedPrice ||
            (this.ProjInvoiceProjId &&
             ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
             ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(this.ProjId, this.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice)))
        {
            ProjControlPeriodTable projControlPeriodTable;
            select reverse firstonly ProjId, PeriodFrom from projControlPeriodTable
                order by PeriodFrom
                where    projControlPeriodTable.ProjId       == this.ProjId &&
                         projControlPeriodTable.PeriodFrom   <= _periodFrom;

            periodFrom  = projControlPeriodTable.PeriodFrom;
        }

        return periodFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>latestPeriodToFixedPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the latest end date for the record in the <c>ProjControlPeriodTable</c> table earlier than the
    ///    date passed in as a parameter if the current project is a fixed price project.
    /// </summary>
    /// <param name="_periodTo">
    ///    The date to compare with. The default value is set with the <c>dateMax</c> method; optional.
    /// </param>
    /// <returns>
    ///    The begin date.
    /// </returns>
    display ProjPeriodTo latestPeriodToFixedPrice(ProjPeriodTo _periodTo  = dateMax())
    {
        ProjPeriodTo periodTo;
        
        if (this.Type == ProjType::FixedPrice ||
            (this.ProjInvoiceProjId &&
             ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
             ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(this.ProjId, this.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice)))
        {
            ProjControlPeriodTable projControlPeriodTable;
            select reverse firstonly projControlPeriodTable
                order by PeriodFrom
                where    projControlPeriodTable.ProjId     == this.ProjId      &&
                         projControlPeriodTable.PeriodFrom <= _periodTo;

            ProjPeriodId periodId = ProjWIPTable::find(ProjTable::find(this.ProjId).wipProject).PeriodId;
            periodTo = ProjControlPeriodTable::periodTo(periodId, projControlPeriodTable.PeriodFrom);
        }

        return periodTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>level</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the hierarchy level of the current project record.
    /// </summary>
    /// <returns>
    ///    The level for the project.
    /// </returns>
    public Level level()
    {
        ProjId      parentId    = this.ParentId;
        Level       level       = 1;

        while (parentId)
        {
            parentId = ProjTable::find(parentId).ParentId;
            level++;
        }

        return level;
    }

]]></Source>
			</Method>
			<Method>
				<Name>levelFormat</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the project ID for the current project record if it is on the project hierarchy level that is passed in as a parameter.
    /// </summary>
    /// <param name="level">
    ///    The hierarchy level.
    /// </param>
    /// <returns>
    ///    The ID of the project. It returns blank if the current project is not on the hierarchy level that is passed in as a parameter.
    /// </returns>
    public NumberSequenceFormat levelFormat(Level level)
    {
        ProjId                  projId      = this.ProjId;
        NumberSequenceFormat    levelFormat = '';
        boolean                 levelOk     = false;

        while (!levelOk)
        {
            if (ProjTable::find(projId).level() == level)
            {
                levelOk     = true;
                levelFormat = projId;
            }
            else
            {
                projId = ProjTable::find(projId).ParentId;
            }

            if (!projId)
            {
                levelOk = true;
            }
        }

        return levelFormat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadValuesServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the values on server and returns the values in a container.
    /// </summary>
    /// <returns>
    /// Returns a container containing values of functions eveluated on server tier.
    /// </returns>
    /// <remarks>
    /// The values are used for enabling/disabling controls on the client.
    /// </remarks>
    public container loadValuesServer()
    {
        HierarchyTreeTable  hierarchyTreeTable;
        boolean             showSchedule;
        boolean             showRetention;
        boolean             canAssign;
        boolean             hasChildProject;
        boolean             hasWBS;
        PSASummaryActivity  psaSummaryActivity;
        boolean             hasBillingRules;
        boolean             hasBudgetedTransactions;
        boolean             isCtrlSalesOrderTableEnabled;
        boolean             collabRecordExist;
        boolean             isSupportsBudgeting;
        boolean             isFieldPwpThresholdPercent;
        boolean             canCreateInvoiceProposal;
        boolean             canCreateItemRequirement;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            psaSummaryActivity = new PSASummaryActivity();

            hierarchyTreeTable = psaSummaryActivity.isSummaryProject(this);
            hasChildProject    = ProjTable::child(this.ProjId);
            hasWBS             = HierarchyTreeTable_Extension::psaFindChildElement(hierarchyTreeTable.HierarchyId, hierarchyTreeTable.ElementNumber) ? true : false;
            showSchedule       = !(hasWBS);
            showRetention      = (this.Type == ProjType::FixedPrice ||
                                  this.Type == ProjType::TimeMaterial ||
                                  (this.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled()));

            canAssign          = this.Status!=ProjStatus::Completed && this.psaSchedEffort > 0 && this.psaSchedDuration > 0
                                  && this.psaSchedStartDate!=dateNull() && this.psaSchedEndDate!=dateNull() && !hasChildProject;

            if (FeatureStateProvider::isFeatureEnabled(ProjCreationOfInvoiceProposalBasedOnBillingRuleAvailabilityFeature::instance()))
            {
                hasBillingRules = ProjInvoiceTable::hasBillingRulesForSelectedProject(this.ProjInvoiceProjId, this.ProjId);
            }
            else
            {
                hasBillingRules    = PSAContractLineItems::hasBillingRules(this.ProjInvoiceProjId);
            }
        }

        hasBudgetedTransactions         = this.hasBudgetedTransactions();

        isCtrlSalesOrderTableEnabled    = this.status().ctrlSalesOrderTable();

        collabRecordExist               = CollabSiteLink::existCollabSiteProject(this.ProjId);

        isSupportsBudgeting             = this.supportsBudgeting();

        isFieldPwpThresholdPercent      = ProjTable::setFieldPwpThresholdPercent(this);

        canCreateInvoiceProposal        = ProjInvoiceTable::canCreateInvoiceProposal(this.ProjInvoiceProjId) &&
                                          ProjStatusTypeRule::exist(this.Status, this.Type, ProjStatusRule::CreateInvoiceProposal);

        canCreateItemRequirement        = isCtrlSalesOrderTableEnabled ||
                                            (this.CustAccount &&
                                             (this.Type == ProjType::Internal ||
                                              this.Type == ProjType::Investment ||
                                              this.Type == ProjType::Cost ||
                                              this.Type == ProjType::FixedPrice ||
                                              ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled()));

        return [showSchedule, showRetention, canAssign, hasBillingRules,
                hasBudgetedTransactions, isCtrlSalesOrderTableEnabled, collabRecordExist,
                isSupportsBudgeting, isFieldPwpThresholdPercent, canCreateInvoiceProposal,
                hasWBS, canCreateItemRequirement];
    }

]]></Source>
			</Method>
			<Method>
				<Name>margin</Name>
				<Source><![CDATA[
    // Margin
    AmountMST margin()
    {
        projStatement   projStatement;

        projStatement = projStatement::newProjTable(this);

        return (projStatement.a100_Total_Revenue()-projStatement.a300_Total_Cost());
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a dimension set that holds the merged combination of the current <c>defaultDimension</c>
    /// field on this table and the provided dimension set.
    /// </summary>
    /// <param name="_primaryDefaultDimension">
    /// A first dimension set to merge with the current <c>defaultDimension</c> field on this table.
    /// </param>
    /// <param name="_secondaryDefaultDimension">
    /// A second dimension set to merge with the current <c>defaultDimension</c> field on this table;
    /// optional.
    /// </param>
    /// <param name="_dimensionMerge">
    /// A <c>dimensionMerge</c> object that was initialized from the current buffer; optional.
    /// </param>
    /// <returns>
    /// A dimension set that holds the merged combination of the current <c>defaultDimension</c> field on
    /// this table and the provided dimension set.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are not overwritten when they are merged.
    /// </remarks>
    public DimensionDefault mergeDimension(
        DimensionDefault _primaryDefaultDimension,
        DimensionDefault _secondaryDefaultDimension = 0,
        DimensionMerge   _dimensionMerge = DimensionMerge::newFromTable(this, this.companyInfo().RecId)
        )
    {
        return _dimensionMerge.merge(_primaryDefaultDimension, _secondaryDefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls methods appropriate to modified fields.
    /// </summary>
    /// <param name="_fieldId">
    ///    The ID of the field that is modified.
    /// </param>
    /// <remarks>
    ///    This method executes when any field in the table is modified.
    /// </remarks>
    public void modifiedField(FieldId _fieldId)
    {
        ProjInvoiceTable        projInvoiceTable;
        ProjParameters          projParameters;
        DimensionDefault        originalDimensionDefault;
        LogisticsLocation       logisticsLocation;

        ProjTable   tProjTable;
        #define.star('*')
        boolean                 isCustTransferNeeded;

        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(ProjTable, ProjGroupId) :
                this.initFromProjGroup(ProjGroup::find(this.ProjGroupId));
                break;

            case fieldNum(ProjTable, CustAccount) :
                originalDimensionDefault = this.DefaultDimension;
                this.transferCustAccount();
                if (this.RecId && this.ProjInvoiceProjId)
                {
                    // Restore the dimension value overwritten by this.transferCustAcount()
                    this.DefaultDimension = originalDimensionDefault;
                }

                if (!ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled())
                {
                    this.updateItemRequirementsFromCustAccount();
                }

                break;

            case fieldNum(ProjTable, ProjInvoiceProjId) :
                ProjInvoiceProjId origProjInvoiceProjId = this.orig().ProjInvoiceProjId;
                boolean isTransExists;
                if (origProjInvoiceProjId != '' && this.ProjInvoiceProjId != origProjInvoiceProjId && this.trxExists())
                {
                    isTransExists = true;
                    // Restore the contract value to original contract value.
                    this.ProjInvoiceProjId = origProjInvoiceProjId;
                    error(strFmt("@Proj:ProjectContractModifiedError", this.ProjId));
                }
                
                if (!isTransExists)
                {
                    originalDimensionDefault = this.DefaultDimension;
                    if (this.ProjInvoiceProjId)
                    {
                        projInvoiceTable = ProjInvoiceTable::find(this.ProjInvoiceProjId);
                    }
                    else
                    {
                        projInvoiceTable = null;
                    }

                    this.CustAccount = projInvoiceTable.fundingSourceCustomerID();

                    if (this.DefaultFundingSource && ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled())
                    {
                        this.DefaultFundingSource = 0;
                    }

                    isCustTransferNeeded = this.isCustomerTransferNeeded();

                    this.initProjectFromCustomerAndInvoice(projInvoiceTable, isCustTransferNeeded);
                    if (this.ProjId && this.ProjInvoiceProjId && !this.orig().ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                    {
                        // Making sure contract line is setup for project and posted transaction types, when new contract is associated to project
                        this.validateContractLineForProjTrans();
                    }
                    else if (this.RecId)
                    {
                        // Restore the dimension value overwritten by this.initProjectFromCustomerAndInvoice()
                        this.DefaultDimension = originalDimensionDefault;
                    }
                }
				break;

            case fieldNum(ProjTable, Type) :
                if (this.orig().Type != this.Type)
                {
                    this.ProjGroupId = '';
                }
                break;

            case fieldNum(ProjTable, Header) :
                if ((this.Header) && !(this.Format))
                {
                    error("@SYS98827");
                    this.Header = NoYes::No;
                }
                break;

            case fieldNum(ProjTable, Format) :
                if ((this.Header) && !(this.Format))
                {
                    this.Header = NoYes::No;
                }
                break;

            case fieldNum(ProjTable, UseBudgeting) :
                if (this.UseBudgeting)
                {
                    projParameters                          = ProjParameters::find();
                    this.ProjCarryForwardRemainingBudget    = projParameters.ProjCarryForwardRemainingBudget;
                    this.ProjCarryForwardNegativeBudget     = projParameters.ProjCarryForwardNegativeBudget;
                    if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                    {
                        this.ProjCarryForwardRemainingBudget   = NoYes::No;
                        this.ProjCarryForwardNegativeBudget     = NoYes::No;
                    }
                }
                else
                {
                    this.ProjCarryForwardRemainingBudget   = NoYes::No;
                    this.ProjCarryForwardNegativeBudget     = NoYes::No;
                }
                break;

            case fieldNum(ProjTable, ProjCarryForwardRemainingBudget) :
                if (!this.ProjCarryForwardRemainingBudget)
                {
                    this.ProjCarryForwardNegativeBudget     = NoYes::No;
                }
                break;

            case fieldNum(ProjTable, DeliveryLocation) :
                if (this.DeliveryLocation == 0)
                {
                    this.DlvName = '';
                }
                break;

            case fieldNum(ProjTable, DlvName) :
                if (this.DeliveryLocation != 0)
                {
                    ttsbegin;
                    logisticsLocation = LogisticsLocation::find(this.DeliveryLocation, true);
                    logisticsLocation.Description = this.DlvName;
                    logisticsLocation.update();
                    ttscommit;
                }
                break;
            case fieldNum(ProjTable, psaSchedDuration):
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    PSAProjProjSchedule::newSchedule().scheduleProj(this, this.psaSchedStartDate, this.psaSchedEndDate);
                }
                break;

            case fieldNum(ProjTable, psaSchedStartDate):
            case fieldNum(ProjTable, psaSchedEndDate):
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    if (this.psaSchedStartDate && this.psaSchedEndDate)
                    {
                        this.psaSchedDuration = WorkCalendarCalculator::calcDuration(this.psaSchedStartDate, this.psaSchedEndDate, this.psaSchedCalendarId);
                    }
                    else
                    {
                        this.psaSchedDuration = 0;
                    }
                }
                break;
            case fieldNum(ProjTable, psaSchedCalendarId):
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    if (this.psaSchedCalendarId)
                    {
                        this.psaSchedStartDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                        this.psaSchedEndDate   = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                        this.psaSchedDuration  = 1;
                    }
                    else
                    {
                        this.psaSchedStartDate = dateNull();
                        this.psaSchedEndDate   = dateNull();
                        this.psaSchedDuration  = 0;
                    }
                }
                break;

            case fieldNum(ProjTable, psaSchedEffort):
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    this.psaSchedScheduled = ProjActivityCapacity::getProjStatus(this.ProjId);
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContractLineForProjTrans</Name>
				<Source><![CDATA[
    private void validateContractLineForProjTrans()
    {
        boolean ret = true;

        ProjEmplTrans projEmplTrans;
        select firstonly RecId from projEmplTrans
            where projEmplTrans.ProjId == this.ProjId && projEmplTrans.PSAContractLineNum == '';
        if (projEmplTrans.RecId)
        {
            ret = ProjRevRecHelper::getRevProfileForTransactionType(this, ProjTransType::Hour) != null;
        }

        if (ret)
        {
            ProjCostTrans projCostTrans;
            select firstonly RecId from projCostTrans
                where projCostTrans.ProjId == this.ProjId && projCostTrans.PSAContractLineNum == '';
            if (projCostTrans.RecId)
            {
                ret = ProjRevRecHelper::getRevProfileForTransactionType(this, ProjTransType::Cost) != null;
            }
        }

        if (ret)
        {
            ProjItemTrans projItemTrans;
            select firstonly RecId from projItemTrans
                where projItemTrans.ProjId == this.ProjId && projItemTrans.PSAContractLineNum == '';
            if (projItemTrans.RecId)
            {
                ret = ProjRevRecHelper::getRevProfileForTransactionType(this, ProjTransType::Item) != null;
            }
        }
        
        if (!ret)
        {
            throw error("@Proj:InvalidContractLineNum");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSeqFormHandler</Name>
				<Source><![CDATA[
    public NumberSeqFormHandler numberSeqFormHandler(FormRun _element, FormDataSource projTable_DS)
    {
        NumberSeqFormHandler    numberSeqFormHandler;
        NumberSequenceReference numRefProjId = this.numRefProjId();

        numberSeqFormHandler = NumberSeqFormHandler::newForm(numRefProjId.NumberSequenceId,
                                                             _element,
                                                             projTable_DS,
                                                             fieldNum(ProjTable,ProjId)
                                                             );

        return numberSeqFormHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numRefProjId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number sequence reference for the new project.
    /// </summary>
    /// <returns>
    /// The number sequence reference.
    /// </returns>
    protected NumberSequenceReference numRefProjId()
    {
        return ProjParameters::numRefProjId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>party</Name>
				<Source><![CDATA[
    DirPartyRecId party()
    {
        return (this.CustAccount ? CustTable::find(this.CustAccount).Party : CompanyInfo::current());
    }

]]></Source>
			</Method>
			<Method>
				<Name>postalAddress</Name>
				<Source><![CDATA[
    LogisticsPostalAddress postalAddress()
    {
        return LogisticsLocationEntity::location2PostalAddress(this.DeliveryLocation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>previewPaneTitle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the title on top of the preview pane.
    /// </summary>
    /// <returns>
    /// The title field of the preview pane.
    /// </returns>
    display ProjName previewPaneTitle()
    {
        return this.ProjId + ": " + this.Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>profitFixedPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the profit on a fixed price project.
    /// </summary>
    /// <returns>
    ///    The <c>ProjProfit</c> value on a fixed price project.
    /// </returns>
    /// <remarks>
    ///    The profit is calculated by subtracting the value returned from the <c>CostAmountFixedPrice</c>
    ///    method from the value returned from the <c>ContractAmountFixedPrice</c> method.
    /// </remarks>
    display ProjProfit profitFixedPrice()
    {
        return this.contractAmountFixedPrice() - this.costAmountFixedPrice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>projAlternateBudgetLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Modifies the lookup of the alternate project.
    /// </summary>
    /// <param name="_lookupFormRun">
    ///    A lookup form to be modified.
    /// </param>
    /// <returns>
    ///    A modified lookup form.
    /// </returns>
    FormRun projAlternateBudgetLookup(FormRun _lookupFormRun)
    {
        FormDataSource formDataSource;
        container ancestors;
        Query formquery;
        QueryBuildRange  queryRange;
        ProjId grandParent;

        ancestors   = ProjTable::ancestors(this.ProjId);
        grandParent = conPeek(ancestors, conLen(ancestors));
        formDataSource = _lookupFormRun.objectSet();
        formquery = formDataSource.query();
        formquery.dataSourceNo(1).addRange(fieldNum(ProjProjectLookup, Status)).value(SysQuery::valueNot(ProjStatus::Completed));

        if (!grandParent)
        {
            grandParent = this.ProjId;
        }

        if (ProjParameters::find().AllowBudgetOutSideHierarchy)
        {
            formquery.dataSourceNo(1).addRange(fieldNum(ProjProjectLookup, ProjId)).value(SysQuery::valueNot(this.ProjId));
            formquery.dataSourceNo(1).addRange(fieldNum(ProjProjectLookup, Type)).value(queryValue(this.Type));
        }
        else
        {
            queryRange = formquery.dataSourceNo(1).addRange(fieldNum(ProjProjectLookup, ProjId));
            queryRange.value(strFmt('((%1 LIKE "%2*") && (%1 != "%3"))', fieldStr(ProjProjectLookup,ProjId),queryValue(grandParent), this.ProjId));
        }

        return _lookupFormRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>ProjGroup</c> record to which the current project record belongs.
    /// </summary>
    /// <returns>
    /// The <c>ProjGroup</c> record to which the current project belongs.
    /// </returns>
    public ProjGroup projGroup()
    {
        return ProjGroup::find(this.ProjGroupId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedPriceRevRecProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the fixed price revenue recognition project associated with the current project.
    /// </summary>
    /// <returns><ProjWIPTable> record.</returns>
    public ProjWIPTable fixedPriceRevRecProject()
    {
        ProjWIPTable fixedPriceRevRecProject;

        if (this.WIPProject)
        {
            fixedPriceRevRecProject = ProjWIPTable::find(this.WIPProject);
        }

        return fixedPriceRevRecProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projGroupName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the Project group name.
    /// </summary>
    /// <returns>
    /// The name of the project group.
    /// </returns>
    display Name projGroupName()
    {
        return this.projGroup().Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projIdAndNameColumn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project ID and name as one string.
    /// </summary>
    /// <returns>
    /// The project ID, a semicolon, a space, and the name as one string, in that order.
    /// </returns>
    display Name projIdAndNameColumn()
    {
        return strFmt('%1: %2',this.ProjId,ProjTable::name(this.ProjId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>projInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the invoice project that the current project record is associated with.
    /// </summary>
    /// <returns>
    ///    A <c>ProjInvoiceTable</c> record.
    /// </returns>
    public ProjInvoiceTable projInvoice()
    {
        return ProjInvoiceTable::find(ProjTable::find(this.ProjId).ProjInvoiceProjId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLinePropertyId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the line property ID that is associated with the specified <c>ProjTable</c> record and
    ///    optionally updates the corresponding <c>ProjLinePropertySetup</c> record for the line property ID
    ///    with the details of the <c>ProjTable</c> record passed in.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to retrieve the line property ID or update the
    ///    <c>ProjLinePropertySetup</c> record.
    /// </param>
    /// <param name="_projTable">
    ///    The project record.
    /// </param>
    /// <param name="_projLinePropertyId">
    ///    The line property ID.
    /// </param>
    /// <returns>
    ///    The line property ID.
    /// </returns>
    edit ProjLinePropertyId projLinePropertyId(boolean               _set,
                                               ProjTable             _projTable,
                                               ProjLinePropertyId    _projLinePropertyId)
    {
        ProjLinePropertyId  projLinePropertyId = '';
        DictTable dictTableProjLinePropertySetup;
        AccessType allowedAccess;

        dictTableProjLinePropertySetup = new DictTable(tableNum(ProjLinePropertySetup));
        allowedAccess = dictTableProjLinePropertySetup.rights();

        if ((_set) && (allowedAccess >= AccessType::Edit))
        {
            //
            // Edit methods do not call validatefield/validateWrite unless ds_forceWrite(true) is called.
            // This conditional avoids the forceWrite() call. A warning is displayed to the user. The line property
            // value is set to original value.
            //
            if (!_projLinePropertyId || ProjLineProperty::exist(_projLinePropertyId))
            {
                ProjLinePropertySetup::updateLinePropertyProj(_projTable.ProjId, _projLinePropertyId, TableGroupAll::Table, _set);
            }
            else
            {
                warning(strFmt("@SYS76949", _projLinePropertyId));
            }
        }

        if (allowedAccess >= AccessType::View)
        {
            projLinePropertyId = (select projLinePropertySetup where projLinePropertySetup.ProjCode          == TableGroupAll::Table   &&
                                                                                    projLinePropertySetup.ProjRelation      == _projTable.ProjId      &&
                                                                                    projLinePropertySetup.CategoryCode      == TableGroupAll::All     &&
                                                                                    projLinePropertySetup.CategoryRelation  == '').LinePropertyId;
        }

        projLinePropertyId  = ProjLineProperty::find(projLinePropertyId).LinePropertyId;

        return projLinePropertyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTypeName</Name>
				<Source><![CDATA[
    public display Name projTypeName()
    {
        return (this.ProjGroupId && isConfigurationkeyEnabled(configurationKeyNum(Project))) ? enum2str(ProjGroup::find(this.ProjGroupId,false).ProjType) : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaCalcDirectBillingMST</Name>
				<Source><![CDATA[
    public AmountMST psaCalcDirectBillingMST()
    {
        ProjCostTrans       projCostTrans;
        ProjItemTrans       projItemTrans;
        ProjCostTransCost   projCostTransCost;
        ProjItemTransCost   projItemTransCost;
        AmountMST           directBillingAmountMST;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            while select Qty from projCostTrans
                where projCostTrans.ProjId       == this.ProjId
                join CostPrice from projCostTransCost
                where ((projCostTransCost.TransId == projCostTrans.TransId)
                            && (projCostTransCost.TransStatus == ProjTransStatus::Invoiced
                            ||  projCostTransCost.TransStatus == ProjTransStatus::MarkedCreditnote))
            {
                directBillingAmountMST += projCostTrans.Qty*projCostTransCost.CostPrice;
            }

            while select projItemTrans
                where projItemTrans.ProjId       == this.ProjId
                join InventTransId from projItemTransCost
                where ((projItemTransCost.InventTransId == projItemTrans.InventTransId)
                        && (projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId) &&
                       (projItemTransCost.TransStatus == ProjTransStatus::Invoiced
                    || projItemTransCost.TransStatus == ProjTransStatus::MarkedCreditnote))

            {
                directBillingAmountMST += projItemTrans.costAmountTotal();
            }
        }

        return directBillingAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaContractValue</Name>
				<Source><![CDATA[
    // Description    : Calculate contract value from OnAccTrans for selected project
    // Parameters     : _bIncludeChild: Calculate from child projects as well
    // Return value   : The calculated value

    public Amount psaContractValue(boolean _bIncludeChild, boolean _bUseWIPid = false)
    {
        ProjOnAccTrans tProjOnAccTrans;
        ProjOnAccTransSale  tProjOnAccTransSale;
        ProjTable      tProjTable;
        Amount         rAmount;
        #define.star('*')

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            if (_bUseWIPid)
            {
                while select TransDate from tProjOnAccTrans
                        join Amount from tProjOnAccTransSale
                        where tProjOnAccTransSale.TransId == tProjOnAccTrans.TransId &&
                              tProjOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
                        join ProjId from tProjTable where tProjOnAccTrans.ProjID == tProjTable.ProjId
                                    &&  tProjTable.wipProject == this.wipProject
                                    &&  tProjTable.Type != ProjType::TimeMaterial
                {
                    rAmount +=  tProjOnAccTransSale.Amount;
                }
            }
            else
            {
                if (_bIncludeChild)
                {
                    while select * from tProjTable
                        index ProjectIdx
                        where tProjTable.ProjId like this.ProjId + #star
                        &&    tProjTable.Type != ProjType::TimeMaterial
                    {
                        // Description: Calculate the rAmount taking in account the exchange rate also.
                        while select TransId, CurrencyId, TransDate from tProjOnAccTrans
                                index ProjDateIdx
                                where tProjOnAccTrans.ProjID == tProjTable.ProjId
                                join Amount from tProjOnAccTransSale
                                where tProjOnAccTransSale.TransId == tProjOnAccTrans.TransId &&
                                      tProjOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
                        {
                            rAmount +=  tProjOnAccTransSale.Amount;
                        }
                    }
                }
                else
                {
                    if (this.checkProjTypeIsTimeMaterial() && !ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                    {
                        rAmount = 0;
                    }
                    else
                    {
                        // Description: Calculate the rAmount taking in account the exchange rate also.
                        while select TransId, CurrencyId, TransDate from tProjOnAccTrans
                                where tProjOnAccTrans.ProjID == this.ProjId
                                join Amount from tProjOnAccTransSale
                                where tProjOnAccTransSale.TransId == tProjOnAccTrans.TransId &&
                                      tProjOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
                        {
                            rAmount +=  tProjOnAccTransSale.Amount;
                        }
                    }
                }
            }
        }

        return rAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjTypeIsTimeMaterial</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the project type.
    /// </summary>
    /// <returns>
    ///     true if the project type is time and material; otherwise, false.
    /// </returns>
    protected boolean checkProjTypeIsTimeMaterial()
    {
        return this.Type == ProjType::TimeMaterial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaCreateProjValProjCategorySetUp</Name>
				<Source><![CDATA[
    // Description:     Copy category validation from invoice project or parent
    // Parameters:
    // Return value:
    // Exceptions:

    public void psaCreateProjValProjCategorySetUp()
    {
        ProjValProjCategorySetUp tProjValProjCategorySetUp, tProjValProjCategorySetUpCreate, tProjValProjCategorySetUpGroup;

        if (this.ParentId)
        {
            while select * from tProjValProjCategorySetUp
                where tProjValProjCategorySetUp.ProjId == this.ParentId
            {
                if (!tProjValProjCategorySetUp.GroupId)
                {
                    tProjValProjCategorySetUpCreate = null;
                    tProjValProjCategorySetUpCreate.data(tProjValProjCategorySetUp);
                    tProjValProjCategorySetUpCreate.ProjId = this.ProjId;
                    if (!ProjValProjCategorySetUp::existDirect(tProjValProjCategorySetUpCreate.CategoryId, tProjValProjCategorySetUpCreate.ProjId))
                    {
                        tProjValProjCategorySetUpCreate.insert();
                    }
                }
                else
                {
                    while select * from tProjValProjCategorySetUpGroup
                        where tProjValProjCategorySetUpGroup.GroupId == tProjValProjCategorySetUp.GroupId
                        &&    tProjValProjCategorySetUpGroup.ProjId == ""
                    {
                        tProjValProjCategorySetUpCreate = null;
                        tProjValProjCategorySetUpCreate.data(tProjValProjCategorySetUpGroup);
                        tProjValProjCategorySetUpCreate.ProjId = this.ProjId;
                        tProjValProjCategorySetUpCreate.GroupId = "";
                        if (!ProjValProjCategorySetUp::existDirect(tProjValProjCategorySetUpCreate.CategoryId, tProjValProjCategorySetUpCreate.ProjId))
                        {
                            tProjValProjCategorySetUpCreate.insert();
                        }
                    }
                }
            }
        }
        else if (this.ProjInvoiceProjId)
        {
            while select * from tProjValProjCategorySetUp
            {
                if (!tProjValProjCategorySetUp.GroupId)
                {
                    tProjValProjCategorySetUpCreate = null;
                    tProjValProjCategorySetUpCreate.data(tProjValProjCategorySetUp);
                    tProjValProjCategorySetUpCreate.ProjId = this.ProjId;
                    if (!ProjValProjCategorySetUp::existDirect(tProjValProjCategorySetUpCreate.CategoryId, tProjValProjCategorySetUpCreate.ProjId))
                    {
                        tProjValProjCategorySetUpCreate.insert();
                    }
                }
                else
                {
                    while select * from tProjValProjCategorySetUpGroup
                        where tProjValProjCategorySetUpGroup.GroupId == tProjValProjCategorySetUp.GroupId
                        &&    tProjValProjCategorySetUpGroup.ProjId == ""
                    {
                        tProjValProjCategorySetUpCreate = null;
                        tProjValProjCategorySetUpCreate.data(tProjValProjCategorySetUpGroup);
                        tProjValProjCategorySetUpCreate.ProjId = this.ProjId;
                        tProjValProjCategorySetUpCreate.GroupId = "";
                        if (!ProjValProjCategorySetUp::existDirect(tProjValProjCategorySetUpCreate.CategoryId, tProjValProjCategorySetUpCreate.ProjId))
                        {
                            tProjValProjCategorySetUpCreate.insert();
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaCurrency</Name>
				<Source><![CDATA[
    public display CurrencyCode psaCurrency()
    {
        return this.projInvoice().CurrencyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaEstimate</Name>
				<Source><![CDATA[
    // Description    : Calculate estimated cost for a project
    // Parameters     : _sForecastModelId: Forecast model to include in calc.
    //                  _bIncludeChild: Calculate from child projects as well

    public PSAProjProposalProj psaEstimate(ForecastModelId _forecastModelId, boolean _bIncludeChild, PSAProjProposalProj _tpsaProjProposalProj )
    {
        ProjForecastCost    tProjForecastCost;
        ProjForecastEmpl    tProjForecastEmpl;
        ProjForecastRevenue tProjForecastRevenue;
        #define.star("*")

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            if (_bIncludeChild)
            {
                while select * from tProjForecastCost
                    where tProjForecastCost.ProjId like this.ProjId + #star
                    &&    tProjForecastCost.ModelId == _forecastModelId
                {
                    _tpsaProjProposalProj.TotalEstimatedCost     += tProjForecastCost.CostPrice * tProjForecastCost.Qty;
                    _tpsaProjProposalProj.TotalEstimatedRevenue  += tProjForecastCost.SalesPrice * tProjForecastCost.Qty;
                }

                while select * from tProjForecastEmpl
                    where tProjForecastEmpl.ProjId like this.ProjId + #star
                    &&    tProjForecastEmpl.ModelId == _forecastModelId
                {
                    _tpsaProjProposalProj.TotalEstimatedCost     += tProjForecastEmpl.CostPrice * tProjForecastEmpl.Qty;
                    _tpsaProjProposalProj.TotalEstimatedRevenue  += tProjForecastEmpl.SalesPrice * tProjForecastEmpl.Qty;
                    _tpsaProjProposalProj.EstimatedHourQty       += tProjForecastEmpl.CostPrice * tProjForecastEmpl.Qty;
                }
                while select * from tProjForecastRevenue
                    where tProjForecastRevenue.ProjId like this.ProjId + #star
                    &&    tProjForecastRevenue.ModelId == _forecastModelId
                {
                    _tpsaProjProposalProj.TotalEstimatedCost     += tProjForecastEmpl.CostPrice * tProjForecastEmpl.Qty;
                    _tpsaProjProposalProj.TotalEstimatedRevenue  += tProjForecastEmpl.SalesPrice * tProjForecastEmpl.Qty;
                    _tpsaProjProposalProj.EstimatedHourQty       += tProjForecastEmpl.CostPrice * tProjForecastEmpl.Qty;
                }
            }
            else
            {
                while select * from tProjForecastCost
                    where tProjForecastCost.ProjId == this.ProjId
                    &&    tProjForecastCost.ModelId == _forecastModelId
                {
                    _tpsaProjProposalProj.TotalEstimatedCost     += tProjForecastCost.CostPrice * tProjForecastCost.Qty;
                    _tpsaProjProposalProj.TotalEstimatedRevenue  += tProjForecastCost.SalesPrice * tProjForecastCost.Qty;
                }

                while select * from tProjForecastEmpl
                    where tProjForecastEmpl.ProjId == this.ProjId
                    &&    tProjForecastEmpl.ModelId == _forecastModelId
                {
                    _tpsaProjProposalProj.TotalEstimatedCost     += tProjForecastEmpl.CostPrice * tProjForecastEmpl.Qty;
                    _tpsaProjProposalProj.TotalEstimatedRevenue  += tProjForecastEmpl.SalesPrice * tProjForecastEmpl.Qty;
                    _tpsaProjProposalProj.EstimatedHourQty       += tProjForecastEmpl.Qty;
                }

                while select * from tProjForecastRevenue
                    where tProjForecastRevenue.ProjId == this.ProjId
                    &&    tProjForecastRevenue.ModelId == _forecastModelId
                {
                    _tpsaProjProposalProj.TotalEstimatedRevenue  += tProjForecastRevenue.SalesPrice * tProjForecastRevenue.Qty;
                }
            }
        }

        return _tpsaProjProposalProj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaEstimateHours</Name>
				<Source><![CDATA[
    // Description    : Calculate estimated hours for a project
    // Parameters     : _sForecastModelId: Forecast model to include in calc.
    //                  _bIncludeChild: Calculate from child projects as well
    // Return value   : Total estimated hours

    public ProjQtyEmpl psaEstimateHours(ForecastModelId _forecastModelId, boolean _bIncludeChild)
    {
        ProjForecastEmpl tProjForecastEmpl;
        #define.star("*")

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            if (_bIncludeChild)
            {
                select sum(Qty) from tProjForecastEmpl
                    where tProjForecastEmpl.ProjId like this.ProjId + #star
                    &&    tProjForecastEmpl.ModelId == _forecastModelId;
            }
            else
            {
                select sum(Qty) from tProjForecastEmpl
                    where tProjForecastEmpl.ProjId == this.ProjId
                    &&    tProjForecastEmpl.ModelId == _forecastModelId;
            }
        }

        return tProjForecastEmpl.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaEstimateItems</Name>
				<Source><![CDATA[
    // Description    : Calculate estimated items turnover for a project
    // Parameters     : _sForecastModelId: Forecast model to include in calc.
    //                  _bIncludeChild: Calculate from child projects as well
    // Return value   : Total estimated items turnover

    public Amount psaEstimateItems(ForecastModelId _forecastModelId, boolean _bIncludeChild)
    {
        ForecastSales tForecastSales;
        #define.star("*")

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            if (_bIncludeChild)
            {
                select sum(Amount) from tForecastSales
                    where tForecastSales.ProjId like this.ProjId + #star
                    &&    tForecastSales.ModelId == _forecastModelId;
            }
            else
            {
                select sum(Amount) from tForecastSales
                    where tForecastSales.ProjId == this.ProjId
                    &&    tForecastSales.ModelId == _forecastModelId;
            }
        }

        return tForecastSales.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaFindPrevPDSId</Name>
				<Source><![CDATA[
    public int psaFindPrevPDSId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaFindRootProjId</Name>
				<Source><![CDATA[
    public ProjId psaFindRootProjId(ProjId    _projId)
    {
        ProjTable   projTable;
        boolean     found = false;
        ProjId      sprojid = _projId;

        while (!found)
        {
            select ProjId, ParentId from projTable
                where projTable.ProjId == sprojid;

            if (projTable.ParentId)
            {
                sprojid = projTable.ParentId;
            }
            else
            {
                found = true;
            }
        }
        return projTable.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaInvCap</Name>
				<Source><![CDATA[
    // Description    : Display method to return invoiced cap amount for this project
    // Parameters     : None
    // Return value   : AmountCur, invoiced amount for this project
    public display AmountCur psaInvCap()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaLeftToInvoice</Name>
				<Source><![CDATA[
    // Description    : Display method to return left to invoice amount for this project
    // Return value   : AmountCur, left to invoice amount for this project

    public display AmountCur psaLeftToInvoice()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psAlevel</Name>
				<Source><![CDATA[
    // This so the .net connector can call the method. Not able to call methods
    // that are public from .net connector

    public Level psAlevel()
    {
        return this.level();
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaModifiedField</Name>
				<Source><![CDATA[
    public void psaModifiedField(FieldId _iFieldId)
    {
        if (!Global::isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            return;
        }

        switch (_iFieldId)
        {
            case fieldNum(ProjTable, psaSchedDuration):
                PSAProjProjSchedule::newSchedule().scheduleProj(this, this.psaSchedStartDate, this.psaSchedEndDate);
                break;

            case fieldNum(ProjTable, psaSchedStartDate):
            case fieldNum(ProjTable, psaSchedEndDate):
                if (this.psaSchedStartDate && this.psaSchedEndDate)
                {
                    this.psaSchedDuration = WorkCalendarCalculator::calcDuration(this.psaSchedStartDate, this.psaSchedEndDate, this.psaSchedCalendarId);
                }
                else
                {
                    this.psaSchedDuration = 0;
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaPctOfCap</Name>
				<Source><![CDATA[
    // Description    : Display method to return invoiced pct of cap
    // Return value   : Pct
    public display Percent psaPctOfCap()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaProjProposalIdIdList</Name>
				<Source><![CDATA[
    public str psaProjProposalIdIdList()
    {
        ProjProposalEmpl    projProposalEmpl;
        ProjEmplTrans       projEmplTrans;
        ProjProposalCost    projProposalCost;
        ProjCostTrans       projCostTrans;
        ProjProposalItem    projProposalItem;
        ProjItemTrans       projItemTrans;
        ProjProposalOnAcc   projProposalOnAcc;
        ProjOnAccTrans      projOnAccTrans;
        ProjProposalRevenue projProposalRevenue;
        ProjRevenueTrans    projRevenueTrans;

        Set                 set = new Set(Types::String);
        SetIterator         setIterator;
        str                 projProposalIdList;

        if (!isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            return projProposalIdList;
        }

        while select ProposalId from projProposalEmpl
            group by ProposalId
            exists join projEmplTrans
                where projEmplTrans.TransId == projProposalEmpl.TransId
                   && projEmplTrans.ProjId  == this.ProjId
        {
            set.add(projProposalEmpl.ProposalId);
        }

        while select ProposalId from projProposalCost
            group by ProposalId
            exists join projCostTrans
                where projCostTrans.TransId == projProposalCost.TransId
                   && projCostTrans.ProjId  == this.ProjId
        {
            set.add(projProposalCost.ProposalId);
        }

        while select ProposalId from projProposalItem
            group by ProposalId
            exists join projItemTrans
                where projItemTrans.ProjTransId == projProposalItem.ProjTransId
                   && projItemTrans.ProjId  == this.ProjId
        {
            set.add(projProposalItem.ProposalId);
        }

        while select ProposalId from projProposalOnAcc
            group by ProposalId
            exists join projOnAccTrans
                where projOnAccTrans.TransId == projProposalOnAcc.TransId
                   && projOnAccTrans.ProjID  == this.ProjId
        {
            set.add(projProposalOnAcc.ProposalId);
        }

        while select ProposalId from projProposalRevenue
            group by ProposalId
            exists join projRevenueTrans
                where projRevenueTrans.TransId == projProposalRevenue.TransId
                   && projRevenueTrans.ProjId  == this.ProjId
        {
            set.add(projProposalRevenue.ProposalId);
        }

        setIterator = new SetIterator(set);
        while (setIterator.more())
        {
            projProposalIdList += setIterator.value()+',';
            setIterator.next();
        }

        if (!projProposalIdList)
        {
            projProposalIdList = 'ABC';
        }

        return projProposalIdList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaRecCost</Name>
				<Source><![CDATA[
    // Description    : Calculate recognized cost for a project in MST currency
    // Parameters     : _bIncludeChild: Calculate from child projects as well
    // Return value   : Total recognized cost
    public Amount psaRecCost(boolean _bIncludeChild)
    {
        ProjTable tProjTable;
        PSAIndirectComponentTrans   tIndirectComponentTrans;
        ProjControlPeriodTable      tProjControlPeriodTable;
        ProjCostTrans               tProjCostTrans;
        ProjEmplTrans               tProjEmplTrans;
        ProjItemTrans               tProjItemTrans;
        ProjRevenueTrans            tProjRevenueTrans;
        Amount                      rAmount;
        Amount                      rLocalAmount;
        ProjTrans                   projTrans;

        #define.star("*")

        // local method
        Amount calcWIP(ProjId sProjId)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                select sum(wipCost) from tProjControlPeriodTable
                    where tProjControlPeriodTable.ProjId == sProjId
                    &&    tProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Posted;
            }

            return tProjControlPeriodTable.wipCost;
        }

        Amount calcTrans(ProjId sProjId)
        {
            rLocalAmount = 0;

            if (!isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                return rLocalAmount;
            }
            // cost
            while select * from tProjCostTrans
                where tProjCostTrans.ProjId == sProjId
            {
                projTrans = ProjTrans::construct(tProjCostTrans);
                rLocalAmount += projTrans.transCostMST();
            }

            // empl
            while select * from tProjEmplTrans
                where tProjEmplTrans.ProjId == sProjId
            {
                projTrans = ProjTrans::construct(tProjEmplTrans);
                rLocalAmount += projTrans.transCostMST();

                // Add indirect amount to total cost
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    while select tIndirectComponentTrans
                        where tIndirectComponentTrans.TransId               == tProjEmplTrans.TransId &&
                              tIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        rLocalAmount += ProjTrans::psaNewProjEmplIndirecTrans(tIndirectComponentTrans).transCostMST();
                    }
                }
            }

            // item
            while select * from tProjItemTrans
                where tProjItemTrans.ProjId == sProjId
            {
                projTrans = ProjTrans::construct(tProjItemTrans);
                rLocalAmount += projTrans.transCostMST();
            }
            // revenue
            while select * from tProjRevenueTrans
                where tProjRevenueTrans.ProjId == sProjId
            {
                projTrans = ProjTrans::construct(tProjRevenueTrans);
                rLocalAmount += projTrans.transCostMST();
            }

            return rLocalAmount;
        }

        if (_bIncludeChild)
        {
            while select ProjId, Type from tProjTable
                where tProjTable.ProjId like this.ProjId + #star
            {
                rAmount += calcTrans(tProjTable.ProjId);
            }
        }
        else
        {
            rAmount = calcTrans(this.ProjId);
        }

        return CurrencyExchangeHelper::amount(rAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaRecRevenue</Name>
				<Source><![CDATA[
    // Description    : Calculate recognized revenue for a project in MST currency
    // Parameters     : _bIncludeChild: Calculate from child projects as well
    // Return value   : Total recognized revenue
    public Amount psaRecRevenue(boolean _bIncludeChild, boolean _bUseWIPid = false)
    {
        ProjTable tProjTable;
        PSAIndirectComponentTrans tIndirectComponentTrans;// Foliodev.PSA.28.Dec.2007.SG
        ProjControlPeriodTable tProjControlPeriodTable;
        ProjCostTrans   tProjCostTrans;
        ProjEmplTrans   tProjEmplTrans;
        ProjItemTrans   tProjItemTrans;
        ProjRevenueTrans tProjRevenueTrans;

        ProjCostTransSale   tProjCostTransSale;
        ProjEmplTransSale   tProjEmplTransSale;
        ProjItemTransSale   tProjItemTransSale;
        ProjRevenueTransSale tProjRevenueTransSale;
        Amount rAmount, rLocalAmount;
        #define.star("*")

        // Add indirect amount to total revenue
        void calcIndirectAmount(ProjTransIdBase _transId, PSAIndirectComponentType _indirectType)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                while select tIndirectComponentTrans
                    where tIndirectComponentTrans.TransId               == _transId &&
                          tIndirectComponentTrans.IndirectComponentType == _indirectType
                {
                    rLocalAmount += ProjTrans::psaNewProjEmplIndirecTrans(tIndirectComponentTrans).transTurnoverMST();
                }
            }
        }
        // local method
        Amount calcWIP(ProjId sProjId)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                select sum(wipAccruedTurnover), sum(wipAccruedTurnoverProd), sum(wipAccruedTurnoverProfit) from tProjControlPeriodTable
                    where tProjControlPeriodTable.ProjId == sProjId
                    &&   (tProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Posted
                    ||    tProjControlPeriodTable.PeriodStatus == ProjControlPeriodStatus::Eliminate);

                rLocalAmount = tProjControlPeriodTable.wipAccruedTurnover + tProjControlPeriodTable.wipAccruedTurnoverProd + tProjControlPeriodTable.wipAccruedTurnoverProfit;
            }
            return abs(rLocalAmount);
        }

        Amount calcTrans(ProjId sProjId)
        {
            rLocalAmount = 0;

            if (!isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                return rLocalAmount;
            }
            // cost
            while select * from tProjCostTrans
                where tProjCostTrans.ProjId == sProjId
                join LedgerSalesAmount from tProjCostTransSale
                where tProjCostTransSale.TransId == tProjCostTrans.TransId

            {
                if (!tProjCostTrans.invoiced())
                {
                    rLocalAmount += tProjCostTransSale.LedgerSalesAmount;
                }
                else
                {
                    rLocalAmount += ProjTrans::construct(tProjCostTrans).transTurnoverMST();
                }
            }

            // empl
            while select * from tProjEmplTrans
                where tProjEmplTrans.ProjId == sProjId
                join tProjCostTransSale
                where tProjEmplTransSale.TransId == tProjEmplTrans.TransId
            {
                if (!tProjEmplTrans.invoiced())
                {
                    rLocalAmount += tProjCostTransSale.LedgerSalesAmount;
                    calcIndirectAmount(tProjEmplTrans.TransId, PSAIndirectComponentType::Revenue);
                }
                else
                {
                    rLocalAmount += ProjTrans::construct(tProjEmplTrans).transTurnoverMST();
                    calcIndirectAmount(tProjEmplTrans.TransId, PSAIndirectComponentType::Invoice);
                }
            }

            // item
            while select * from tProjItemTrans
                where tProjItemTrans.ProjId == sProjId
                join LedgerSalesAmount from tProjItemTransSale
                where tProjItemTransSale.ProjTransId == tProjItemTrans.ProjTransId

            {
                if (!tProjItemTrans.invoiced())
                {
                    rLocalAmount += tProjItemTransSale.LedgerSalesAmount;
                }
                else
                {
                    rLocalAmount += ProjTrans::construct(tProjItemTrans).transTurnoverMST();
                }
            }

            // revenue
            while select * from tProjRevenueTrans
                where tProjRevenueTrans.ProjId == sProjId
                join LedgerSalesAmount from tProjRevenueTransSale
                where tProjRevenueTransSale.TransId == tProjRevenueTrans.TransId
            {
                if (!tProjRevenueTrans.invoiced())
                {
                    rLocalAmount += tProjRevenueTransSale.LedgerSalesAmount;
                }
                else
                {
                    rLocalAmount += ProjTrans::construct(tProjRevenueTrans).transTurnoverMST();
                }
            }

            return rLocalAmount;
        }
        ;

        if (_bUseWIPid)
        {
            while select ProjId, Type from tProjTable
                where tProjTable.wipProject == this.wipProject
            {
                if (ProjTable::isFixedPriceProject(tProjTable.ProjId))
                {
                    rAmount += calcWIP(tProjTable.ProjId);
                }
                else
                {
                    rAmount += calcTrans(tProjTable.ProjId);
                }
            }
        }
        else
        {
            if (_bIncludeChild)
            {
                while select ProjId, Type from tProjTable
                    where tProjTable.ProjId like this.ProjId + #star
                {
                    if (ProjTable::isFixedPriceProject(tProjTable.ProjId))
                    {
                        rAmount += calcWIP(tProjTable.ProjId);
                    }
                    else
                    {
                        rAmount += calcTrans(tProjTable.ProjId);
                    }
                }
            }
            else
            {
                if (ProjTable::isFixedPriceProject(this.ProjId))
                {
                    rAmount = calcWIP(this.ProjId);
                }
                else
                {
                    rAmount = calcTrans(this.ProjId);
                }
            }
        }

        return CurrencyExchangeHelper::amount(rAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaRetainageBillingDesc</Name>
				<Source><![CDATA[
    public TransTxt psaRetainageBillingDesc()
    {
        return strFmt("%1 %2", this.ProjId, this.Name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaUsePDS</Name>
				<Source><![CDATA[
    // Description    : Is the project connected to MS Project server
    // Return value   : Yes, if a connection exists, else no
    public display NoYes psaUsePDS()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaValidateSchedule</Name>
				<Source><![CDATA[
    public boolean psaValidateSchedule()
    {
        boolean ret = true;
        ProjTable tProjChild;
        boolean   bWrongDate;
        RealBase oldDuration;

        if (!Global::isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            return ret;
        }

        if (!this.psaSchedCalendarId)
        {
            ret=checkFailed(strFmt("@PSA3435",this.ProjId));
            return false;
        }

    // Description: validate the scheduling date for parent record

        oldDuration     = this.orig().psaSchedDuration;

        if (this.psaSchedStartDate > this.orig().psaSchedStartDate)
        {
            while select psaSchedStartDate from tProjChild where tProjChild.ProjId like this.ProjId + '*' && tProjChild.ProjId != this.ProjId
            {
                if (tProjChild.psaSchedStartDate<this.psaSchedStartDate)
                {
                    bWrongDate = true;
                    break;
                }
            }
            if (bWrongDate)
            {
                ret=checkFailed(strFmt('Scheduling start date is wrong. There is a children task with scheduling start date less than calculate start date (%1)!', this.psaSchedStartDate));

                this.psaSchedStartDate = this.orig().psaSchedStartDate;
                this.psaSchedEndDate = this.orig().psaSchedEndDate;
                if (this.psaSchedDuration < this.orig().psaSchedDuration)
                {
                    this.psaSchedDuration    = this.updateProjectDuration(this.psaSchedCalendarId, this.psaSchedStartDate, this.psaSchedEndDate);
                }
            }
            else
            {
                this.psaSchedDuration = oldDuration;
            }
        }

        if (this.psaSchedEndDate < this.orig().psaSchedEndDate)
        {
            while select psaSchedEndDate from tProjChild where tProjChild.ProjId like this.ProjId + '*' && tProjChild.ProjId != this.ProjId
            {
                if (tProjChild.psaSchedEndDate>this.psaSchedEndDate)
                {
                    bWrongDate = true;
                    break;
                }
            }
            if (bWrongDate)
            {
                ret=checkFailed(strFmt('Scheduling end date is wrong! There is a children task with scheduling end date more than calculate end date (%1)',this.psaSchedEndDate));

                this.psaSchedStartDate = this.orig().psaSchedStartDate;
                this.psaSchedEndDate = this.orig().psaSchedEndDate;
                if (this.psaSchedDuration < this.orig().psaSchedDuration)
                {
                    this.psaSchedDuration    = this.updateProjectDuration(this.psaSchedCalendarId, this.psaSchedStartDate, this.psaSchedEndDate);
                }
            }
            else
            {
                this.psaSchedDuration = oldDuration;
            }
        }

        this.doUpdate();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>renamePrimaryKey</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Renames the primary key of the table.
    /// </summary>
    /// <param name="psaIncludeSubProjects">
    ///    Specify if the rename of the key should affect subprojects also.
    /// </param>
    /// <remarks>
    ///    This method also renames all the subprojects that roll up to this current parent project record.
    /// </remarks>
    public void renamePrimaryKey(boolean psaIncludeSubProjects = true)
    {
        NumberSequenceFormat    subFormat;
        ProjTable               projTable;
        DictType                projIdType;
        ProjId                  projId;
        ProjTable               originalRecord;

        ttsbegin;
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) ? psaIncludeSubProjects : true)
        {
            if (this.ParentId && ! this.validateProjId(this.ProjId))
            {
                throw error(strFmt("@SYS62416", this.ParentId, ProjTable::find(this.ParentId).Format));
            }
            else
            {
                if (!strLen(strLTrim(strRTrim(this.ProjId))))
                {
                    throw error("@SYS62427");
                }
            }
        }

        originalRecord = this.orig();
        projId = this.orig().ProjId;
        while select forupdate projTable where projTable.wipProject == projId
        {
            projTable.wipProject = this.ProjId;
            projTable.doUpdate();
        }

        TSTimesheetLine tstTimesheetLine;

        while select crossCompany tstTimesheetLine
            group by DataAreaId
            where  tstTimesheetLine.ProjectDataAreaId == this.dataAreaId
                && tstTimesheetLine.ProjId            == originalRecord.ProjId
        {
            changeCompany(tstTimesheetLine.dataAreaId)
            {
                TSTimesheetLine tsTimesheetLineUpdate;

                update_recordSet tsTimesheetLineUpdate
                    setting ProjId = this.ProjId
                    where  tsTimesheetLineUpdate.ProjectDataAreaId == this.dataAreaId
                        && tsTimesheetLineUpdate.ProjId            == originalRecord.ProjId;
            }
        }

        DimensionValueRenameV2 rename = DimensionValueRenameV2::construct(this, originalRecord);
        rename.syncRenamedValuePreSuper();

        super();

        rename.syncRenamedValuePostSuper();
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) ? psaIncludeSubProjects : true)
        {
            while select forupdate projTable where projTable.ParentId == this.ProjId
            {
                subFormat = subStr(projTable.ProjId, strLen(projTable.ProjId), -(strLen(this.Format)));

                projIdType = new DictType(extendedTypeNum(ProjId));

                if (strLen((projTable.ParentId + subFormat)) > projIdType.stringLen())
                {
                    throw error(strFmt("@SYS62419", projTable.ProjId, (projTable.ParentId + subFormat),
                                                    strLen(projTable.ParentId + subFormat), projIdType.stringLen()));
                }

                projTable.ProjId = (projTable.ParentId + subFormat);

                projTable.renamePrimaryKey();
            }
        }

        this.updateHierarchy();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTable_ItemReq</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the sales order record that is associated with the current project record.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The currency that the <c>SalesTable</c> record should have.
    /// </param>
    /// <param name="_update">
    ///    A Boolean value that indicates whether the sales order record should be selected for update;
    ///    optional.
    /// </param>
    /// <returns>
    ///    The sales order record.
    /// </returns>
    /// <remarks>
    /// This method should not be called when multiple funding sources feature is enabled 
    /// as the method only returns the first SalesOrder of type item requirement in that Project without considering the fundingsource
    /// </remarks>
    public SalesTable salesTable_ItemReq(CustCurrencyCode _currencyCode, boolean _update = false)
    {
        SalesTable  salesTable = null;

        if (this.ProjId)
        {
            ProjPriceGroupID projPriceGroup = this.projPriceGroup();

            salesTable.selectForUpdate(_update);

            if (FeatureStateProvider::isFeatureEnabled(ProjItemReqCreateNewWhenInvoicedFlight::instance()))
            {
                /*
                Do not return documents with a Sales Status of: Invoiced, Canceled, Delivered.
                Adding a new line to the document will attempt to reset the status of the document.
                - An invoiced document could be linked to a PO which is finalized. Attempting to reopen the document will generate an error.
                - If the document was canceled we don't want to reopen the document by adding a line to it.
                - If the document is marked as delivered it may be completed, except for invoicing. We don't want to reopen it.
                */
                select firstonly salesTable
                    where salesTable.ProjId         == this.ProjId                          &&
                          salesTable.PriceGroupId   == projPriceGroup                       &&
                          salesTable.CustAccount    == this.type().custAccount()            &&
                          salesTable.InvoiceAccount == this.type().invoiceAccount()         &&
                          salesTable.CurrencyCode   == _currencyCode                        &&
                          (salesTable.SalesStatus  == SalesStatus::None
                            || salesTable.SalesStatus == SalesStatus::Backorder)			&&
                          salesTable.SalesType      == SalesType::ItemReq;
            }
            else
            {
                select firstonly salesTable
                    where salesTable.ProjId         == this.ProjId                          &&
                          salesTable.PriceGroupId   == projPriceGroup                       &&
                          salesTable.CustAccount    == this.type().custAccount()            &&
                          salesTable.InvoiceAccount == this.type().invoiceAccount()         &&
                          salesTable.CurrencyCode   == _currencyCode                        &&
                          salesTable.SalesType      == SalesType::ItemReq;
            }
        }

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTable_ItemReqMultFundingSources</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the sales order record that is associated with the current project record
    ///    and given funding source
    /// </summary>
    /// <param name="_currencyCode">
    ///    The currency that the <c>SalesTable</c> record should have.
    /// </param>
    /// <param name="_fundingSource">
    ///    The funding source that the <c>SalesTable</c> record should have.
    /// </param>
    /// <param name="_update">
    ///    A Boolean value that indicates whether the sales order record should be selected for update;
    ///    optional.
    /// </param>
    /// <returns>
    ///    The sales order record.
    /// </returns>
    public SalesTable salesTable_ItemReqMultFundingSources(CustCurrencyCode _currencyCode, ProjFundingSourceRefId _fundingSource, boolean _update = false)
    {
        SalesTable salesTable = null;

        if (ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled() && this.ProjId)
        {
            ProjFundingSource _projFundingSource = ProjFundingSource::find(_fundingSource);
            ProjPriceGroupID projPriceGroup = this.projPriceGroup(_projFundingSource);

            salesTable.selectForUpdate(_update);

            // Do not include invoiced sale table as the line coould be linked  to a PO which is finalized
            // This will still return a new header even if ProjItemReqCreateNewWhenInvoicedFlight is off by design
            select firstonly salesTable
                where salesTable.ProjId             == this.ProjId                        &&
                        salesTable.PriceGroupId     == projPriceGroup                     &&
                        salesTable.InvoiceAccount   == _projFundingSource.custAccount     &&
                        salesTable.CurrencyCode     == _currencyCode                      &&
                        (salesTable.SalesStatus == SalesStatus::None
                        || salesTable.SalesStatus == SalesStatus::Backorder)		      &&
                        salesTable.SalesType        == SalesType::ItemReq                 &&
                        SalesTable.FundingSource    == _fundingSource;
        }

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projPriceGroup</Name>
				<Source><![CDATA[
    private ProjPriceGroupID projPriceGroup(ProjFundingSource _projFundingSource = null)
    {
        ProjPriceGroupID projPriceGroup = this.ProjPriceGroup;

        // If on the project level price group is not mentioned select the price group at the project contract level
        if (!projPriceGroup && this.ProjInvoiceProjId)
        {
            projPriceGroup = ProjInvoiceTable::find(this.ProjInvoiceProjId).ProjPriceGroup;
        }

        // If on the project level and Contract level price group is not mentioned select the price group at the Customer level.
        if (!projPriceGroup && this.CustAccount)
        {
            projPriceGroup = CustTable::find(this.CustAccount).PriceGroup;
        }

        // For the case MFS is enabled and there is a custAccount (so it is not an investment project)
        if (ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled() && this.ProjInvoiceProjId && _projFundingSource.CustAccount)
        {
            projPriceGroup = CustTable::find(_projFundingSource.custAccount).PriceGroup;
        }

        return projPriceGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTable_SalesOrder</Name>
				<Source><![CDATA[
    public SalesTable salesTable_SalesOrder(CustCurrencyCode _currencyCode, boolean _update = false)
    {
        SalesTable  salesTable = null;

        if (this.ProjId)
        {
            salesTable.selectForUpdate(_update);

            select firstonly salesTable
                where salesTable.ProjId         == this.ProjId                          &&
                      salesTable.CustAccount    == this.type().custAccount()            &&
                      salesTable.InvoiceAccount == this.type().invoiceAccount()         &&
                      salesTable.CurrencyCode   == _currencyCode
                    && (salesTable.SalesStatus  == SalesStatus::None
                        || salesTable.SalesStatus == SalesStatus::Backorder)
                    && salesTable.SalesType     == SalesType::Sales;
        }

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startDateTime</Name>
				<Source><![CDATA[
    TransDateTime startDateTime()
    {
        return DateTimeUtil::newDateTime(this.StartDate, 0 , DateTimeUtil::getCompanyTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>status</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the corresponding <c>ProjStatusType</c> object based on the status of the current project record.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>ProjStatusType</c> class.
    /// </returns>
    public ProjStatusType status()
    {
        return ProjStatusType::construct(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkActiveInTree</Name>
				<Source><![CDATA[
    public boolean checkActiveInTree()
    {
        if(this.status().activeInTree())
        {
            return true;
        }
        else
        {
            return checkFailed(strFmt("@Proj:ProjectCannotBeSelected", this.ProjId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>supportsBudgeting</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the selected project or the child project has Use Budgeting option selected
    /// </summary>
    /// <returns>
    ///    true if budgeting is used in the project hierarchy that the project belongs to; otherwise, false.
    /// </returns>
    public boolean supportsBudgeting()
    {
        boolean     hasUseBudgeting = false;
        ProjId      projId;
        ProjTable   tmpProjTable;
        ProjBudget  projBudget;

        projId = ProjTable::getRootProjId(this.ProjId);

        select firstonly RecId from tmpProjTable
            where tmpProjTable.ProjId like projId + '*' && tmpProjTable.UseBudgeting;

        hasUseBudgeting = tmpProjTable.RecId ? true : false;

        if (!hasUseBudgeting)
        {
            select firstonly RecId from projBudget
                where projBudget.RootProjId like projId + '*'
                    && (projBudget.BudgetWorkflowStatus == ProjBudgetWorkflowStatus::Submitted
                        || projBudget.BudgetWorkflowStatus == ProjBudgetWorkflowStatus::Approved);
            hasUseBudgeting = projBudget.RecId != 0;
        }

        return hasUseBudgeting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCost</Name>
				<Source><![CDATA[
    // Total cost
    AmountMST totalCost()
    {
        projStatement   projStatement;

        projStatement = projStatement::newProjTable(this);

        return projStatement.a300_Total_Cost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalRevenue</Name>
				<Source><![CDATA[
    // Total revenue
    AmountMST totalRevenue()
    {
        projStatement   projStatement;

        projStatement = projStatement::newProjTable(this);

        return projStatement.a100_Total_Revenue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferCustAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes fields for the current project record.
    /// </summary>
    /// <remarks>
    ///    This method initializes the fields by using values from the customer record. The user is prompted with the option to transfer the customer information if the setup parameter is turned on in project
    ///    setup.
    /// </remarks>
    void transferCustAccount()
    {
        if (this.CustAccount)
        {
            if (ProjParameters::find().PromptTransferCustOnProject)
            {
                if (Box::yesNo("@SYS418" + '\n\n'+CustTable::promptAddress(this.CustAccount), DialogButton::Yes) == DialogButton::Yes)
                {
                    this.initFromCustTable(CustTable::find(this.CustAccount, false));
                }
            }
            else
            {
                this.initFromCustTable(CustTable::find(this.CustAccount, false));
            }
        }
		else
        {
            LogisticsPostalAddress address;
            LogisticsLocation location;
			
            ttsbegin;
            location = LogisticsLocation::find(this.DeliveryLocation, true);
            address = LogisticsPostalAddress::findByLocation(this.DeliveryLocation, true);

            if (LogisticsLocationEntity::canDeletePostalAddress(address.RecId, conNull(), false))
            {
                address.delete();
                location.delete();
            }
            
            ttscommit;

            this.DlvName = '';
            this.DeliveryLocation = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trxExists</Name>
				<Source><![CDATA[
    public boolean trxExists()
    {
        ProjId                  projId = this.ProjId;
        boolean                 ret = true;

        if (!projId)
        {
            ret = false;
        }

        if (ret)
        {
            if (this.Header == NoYes::No)
            {
                ProjJournalTrans projJournalTrans;
                InventJournalTrans inventJournalTrans;
                ProjTransPosting projTransPosting;
                SalesLine salesLine;
                PurchLine purchLine;
                SMAAgreementTable smaAgreementTable;
                SMASubscriptionTable smaSubscriptionTable;
                ProjRevenueTrans projRevenueTrans;
                ProjOnAccTrans projOnAccTrans;
                SMAServiceOrderLine smaServiceOrderLine;
                PurchReqTable purchReqTable;
                PurchRFQCaseTable purchRFQCaseTable;

                if ((!this.AssetId) &&
               ((select firstonly projJournalTrans where projJournalTrans.ProjId == projId).RecId == 0) &&
               ((select firstonly ledgerJournalTrans_project where ledgerJournalTrans_project.ProjId == projId).RecId == 0) &&
               ((select firstonly inventJournalTrans where inventJournalTrans.ProjId == projId).RecId == 0) &&
               ((select firstonly projTransPosting where projTransPosting.ProjId == projId).RecId == 0) &&
               ((select firstonly salesLine where salesLine.ProjId == projId).RecId == 0) &&
               ((select firstonly purchLine where purchLine.ProjId == projId &&
                                  !purchLine.IsDeleted).RecId == 0) &&
               ((select firstonly smaAgreementTable where smaAgreementTable.ProjId == projId).RecId == 0) &&
               ((select firstonly smaSubscriptionTable where smaSubscriptionTable.ProjId == projId).RecId == 0) &&
               ((select firstonly projRevenueTrans where projRevenueTrans.ProjId == projId).RecId == 0) &&
               ((select firstonly projOnAccTrans where projOnAccTrans.ProjID == projId).RecId == 0) &&
               ((select firstonly smaServiceOrderLine where smaServiceOrderLine.ProjId == projId).RecId == 0) &&
               ((select firstonly purchReqTable where purchReqTable.ProjId == projId).RecId == 0) &&
               ((select firstonly purchRFQCaseTable where purchRFQCaseTable.ProjId == projId).RecId == 0))
                {
                    ret = false;
                }
            }
            else
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>type</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the corresponding instance of the <c>ProjTableType</c> class based on the value of the type
    ///    field in the current project record.
    /// </summary>
    /// <returns>
    ///    A <c>ProjtableType</c> object.
    /// </returns>
    public ProjTableType type()
    {
        return ProjTableType::construct(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overridden method to perform custom logic.
    /// </summary>
    /// <param name="_skipSyncTrigger">
    /// When set to true, it will not send updated transactions to the synchronization store.
    /// </param>
    /// <param name="_skipReservationUpdate">
    /// Determines whether related Reservation records will be updated along with the Task update.
    /// </param>
    /// <remarks>
    /// Passing TRUE to the _skipReservationUpdate argument may cause the Reservation data to be misaligned
    /// with the Task data because reactive update of Reservation data will be skipped.
    /// </remarks>
    public void update(boolean _skipSyncTrigger = false, boolean _skipReservationUpdate = false)
    {
        ProjTable   thisOrig             = this.orig();
        boolean     rootParentBudgetManagementChanged = (this.ParentId == '' && (this.ProjBudgetManagement != thisOrig.ProjBudgetManagement));
        boolean     invoiceProjIdChanged = (this.ProjInvoiceProjId != thisOrig.ProjInvoiceProjId);
        boolean     calendarChanged      = (this.psaSchedCalendarId != thisOrig.psaSchedCalendarId);
        boolean     projectNameChanged   = (this.Name != thisOrig.Name);
        boolean     plannedDatesChanged  = (this.psaSchedStartDate != thisOrig.psaSchedStartDate)
                                            || (this.psaSchedEndDate != thisOrig.psaSchedEndDate);
        boolean     effortChanged        = (this.psaSchedEffort != thisOrig.psaSchedEffort);
        boolean     durationChanged      = (this.psaSchedDuration != thisOrig.psaSchedDuration);

        super();

        ttsbegin;

        // Only updates the children ProjBudgetManagement setting if this is the root parent and the setting has been modified.
        if (rootParentBudgetManagementChanged)
        {
            ProjTable projTableSubProj;
            projTableSubProj.skipDataMethods(true);
            const str star = '*';

            update_recordset projTableSubProj
            setting ProjBudgetManagement = this.ProjBudgetManagement
            where projTableSubProj.ParentId != ''
                && projTableSubProj.RecId != this.RecId
                && projTableSubProj.ParentId like (this.ProjId + star);
        }

        ttscommit;

        // Shop Floor Control - synchronizing only upon status change
        if (this.mustSynchronizeJobs(thisOrig) && Global::isConfigurationkeyEnabled(configurationKeyNum(Jmgjob)))
        {
            JmgJobTable::synchronizeProjTable(this);
        }

        ttsbegin;

        if (this.checkInvoiceProjIdAndProjType(invoiceProjIdChanged))
        {
            PSAProjFundingSourceRetain::deleteFromProjFundingSourceRetain(this.ProjId);
            PSAProjFundingSourceRetain::initFromProjFundingSource(this.ProjInvoiceProjId, this.ProjId);

            if (!PSAProjWorkComplete::exist(this.ProjId)
                && FeatureStateProvider::isFeatureEnabled(ProjGroupChangeCorrectRetainLinksFlight::instance()))
            {
                PSAProjWorkComplete::initFromProjTable(this.ProjId);
            }
        }
        else if (invoiceProjIdChanged && FeatureStateProvider::isFeatureEnabled(ProjGroupChangeCorrectRetainLinksFlight::instance()))
        {
            // When contract is changed and project type is not FixedPrice or TimeMaterial, clean up PSAProjFundingSourceRetain and PSAProjWorkComplete record.
            PSAProjFundingSourceRetain::deleteFromProjFundingSourceRetain(this.ProjId);
            PSAProjWorkComplete::deleteForProjTable(this.ProjId);
        }

        if (calendarChanged)
        {
            this.updateTaskCalendars();
            if (!ResUtil::isPerformanceEnhancementFeatureEnabled(ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled()))
            {
                this.updatePlannedResourceRollupByCalendar(thisOrig.PSASchedCalendarId);
            }
        }

        if (plannedDatesChanged || effortChanged || durationChanged)
        {
            HierarchyTreeTable_Extension::projSetRootTaskScheduleAttributes(this.RecId,
                                                                  tableNum(ProjTable),
                                                                  this.psaSchedEffort,
                                                                  this.psaSchedStartDate,
                                                                  this.psaSchedEndDate,
                                                                  this.psaSchedDuration,
                                                                  _skipReservationUpdate);
        }

        if (projectNameChanged)
        {
            HierarchyTreeTable_Extension::projSetHierarchyRootTaskName(this.RecId, this.Name, tableNum(ProjTable));
        }

        ttscommit;

        if (invoiceProjIdChanged && !thisOrig.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            System.Threading.CancellationToken token = new System.Threading.CancellationToken();

            System.Threading.Tasks.Task task = runAsync(classNum(ProjMultipleContractLinesForProjectFeatureHelper),
                staticMethodStr(ProjMultipleContractLinesForProjectFeatureHelper, updateProjectPostedTrans),
                [this.ProjId, this.ProjInvoiceProjId],
                token);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInvoiceProjIdAndProjType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check if the project type is of type fixed price or time and material.
    /// </summary>
    /// <param name = "_invoiceProjIdChanged">
    ///     true if the invoice project ID is changed; false otherwise.
    /// </param>
    /// <returns>
    ///     true if the <c>_invoiceProjIdChanged</c> has value and
    ///     if the current project type is either fixed price or time and material; otherwise, false.
    /// </returns>
    protected boolean checkInvoiceProjIdAndProjType(boolean _invoiceProjIdChanged)
    {
        return _invoiceProjIdChanged &&
                (this.Type == ProjType::FixedPrice ||
                 this.Type == ProjType::TimeMaterial ||
                 (this.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSynchronizeJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the jobs must be synchronized.
    /// </summary>
    /// <returns>
    /// true if the jobs must be synchronized; otherwise, false.
    /// </returns>
    protected boolean mustSynchronizeJobs(ProjTable _thisOrig)
    {
        return _thisOrig.Status != this.Status;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBudgetControls</Name>
				<Source><![CDATA[
    public void updateBudgetControls(ProjId _alternateBudgetProject)
    {
        ProjTable                 projTabletemp;
        ProjBudgetUserGroupOption projBudgetUserGroupOption;

        delete_from projBudgetUserGroupOption where projBudgetUserGroupOption.ProjOrProjGroup == this.ProjId && this.UseAlternateProject == NoYes::Yes;

        if (_alternateBudgetProject)
        {
            projTabletemp = ProjTable::find(_alternateBudgetProject, true);

            ttsbegin;
            this.ProjBudgetaryControlOn = projTabletemp.ProjBudgetaryControlOn;
            this.ProjBudgetOverrunOption = projTabletemp.ProjBudgetOverrunOption;
            this.ProjBudgetInterval = projTabletemp.ProjBudgetInterval;
            this.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateHierarchy</Name>
				<Source><![CDATA[
    void updateHierarchy()
    {
        Hierarchy           hierarchy = null;
        HierarchyLinkTable  hierarchyLinkTable = null;
        HierarchyTreeTable  hierarchyTreeTable = null;
        str name;

        ttsbegin;

        hierarchyLinkTable = HierarchyLinkTable::findRefTableRecId(tableNum(ProjTable), this.RecId, true);
        name = strLTrim(strRTrim(this.ProjId));

        if (hierarchyLinkTable)
        {
           //update HierarchyLinkTable
            hierarchy = Hierarchy::find(hierarchyLinkTable.HierarchyId, true);

            if (hierarchy)
            {
                hierarchy.Name= name;
                hierarchy.doUpdate();
            }

            //update HierarchyTreeTable
            hierarchyTreeTable.selectForUpdate(true);

            select firstonly hierarchyTreeTable
                where   hierarchyTreeTable.HierarchyId == hierarchyLinkTable.HierarchyId &&
                        hierarchyTreeTable.ParentElementNumber == '';

            if (hierarchyTreeTable)
            {
                hierarchyTreeTable.Name = name;
                hierarchyTreeTable.doUpdate();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectDuration</Name>
				<Source><![CDATA[
    // Description    :<update the duration when date is changed >
    // Parameters     :< Description of parameters >
    // Return value   :< Description of return value >
    // Exceptions     :< Exeptions the method could throw >

    public RealBase updateProjectDuration(CalendarId _calendarId,TransDate _startDate,TransDate _endDate)
    {
        TransDate         tCalDate = _startDate;
        RealBase          rDuration;

        while (tCalDate<=_endDate)
        {
            if (WorkCalendarDate::isDateOpen(_calendarId,tCalDate))
            {
                rDuration++;
            }
            tCalDate++;
        }

        if (rDuration == 0)
        {
            rDuration++;
        }
        return rDuration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnForecastDate</Name>
				<Source><![CDATA[
    public TransDate returnForecastDate()
    {
        TransDate   forecastDate;

        if ((this.Status == ProjStatus::Created) || (this.Status == ProjStatus::Scheduled))
        {
            forecastDate = this.ProjectedStartDate;
        }

        return forecastDate? forecastDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSchedulingStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates project scheduling status. If project does not have work break down structure (WBS),
    /// then update other project scheduling properties as well.
    /// </summary>
    /// <param name="_hasWBS">
    /// Whether this project has WBS
    /// </param>
    public void updateSchedulingStatus(boolean _hasWBS = false)
    {
        #OCCRetryCount
        if (this.ProjId)
        {
            this.selectForUpdate(true);
            const str LoggerRetryExceptionMsg = 'Max %1 retries exceeded for %2 method. ProjRecId: %3'; 

            try
            {
                ttsbegin;
                ProjPlanVersion planVersion;
                if (_hasWBS)
                {
                    // If this project has WBS, then evaluate the scheduling status by the latest currently published WBS.
                    ProjPlanVersionDetail planVersionDetail = ProjPlanVersionDetail::findLatestByProjId(this.ProjId, false, false, ProjPlanVersionType::PublishedCurrent);
                    planVersion = ProjPlanVersion::getRootTask(planVersionDetail.HierarchyId);
                }

                // If ProjPlanVersion record can be found, then calculate the scheduling status by combine status.
                if (planVersion)
                {
                    this.PSASchedScheduled = ProjActivityCapacity::combineStatus(
                        ProjActivityCapacity::getProjStatus(this.ProjId),
                        planVersion.TaskSchedulingStatus);
                }
                else
                {
                    this.PSASchedScheduled = ProjActivityCapacity::getProjStatus(this.ProjId);
                    ProjTable::setProjectSchedulingProperties(this);
                }

                this.update();
                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(tableStr(ProjTable));
                    logger.logError(strFmt(LoggerRetryExceptionMsg, 'Deadlock', 'ProjTable.updateSchedulingStatus()', this.RecId));
                    throw Exception::Deadlock;
                }
                else
                {
                    sleep(ProjConstants::DeadLockRetryInterval * xSession::currentRetryCount());
                    retry;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(tableStr(ProjTable));
                        logger.logError(strFmt(LoggerRetryExceptionMsg, 'UpdateConflict', 'ProjTable.updateSchedulingStatus()', this.RecId));
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        retry;
                    }
                }
                else
                {
                    throw Exception::UpdateConflict;
                }
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
                {
                    retry;
                }
                else
                {
                    ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(tableStr(ProjTable));
                    logger.logError(strFmt(LoggerRetryExceptionMsg, 'TransientSqlConnectionError', 'ProjTable.updateSchedulingStatus()', this.RecId));
                    throw Exception::TransientSqlConnectionError;
                }
            }
            catch (Exception::Error)
            {
                throw Exception::Error;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjectSchedulingProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set project scheduling properties including start date, end date, duration and effort
    /// according to  the earliest and lateast resource booking dates in thie project.
    /// </summary>
    /// <param name = "_projTable">The target <c>ProjTable</c> table record buffer.</param>
    /// <param name = "_defaultStartDate">If there is no resource booking record for this project, this date will be set as the scheduling start date.</param>
    /// <param name = "_defaultEndDate">If there is no resource booking record for this project, this date will be set as scheduling end date.</param>
    /// <returns><c>ProjTable</c> record buffer.</returns>
    public static ProjTable setProjectSchedulingProperties(     ProjTable _projTable,
                                                                date _defaultStartDate = Global::dateNull(),
                                                                date _defaultEndDate = Global::dateNull())
    {
        ActivityRecId projectActivityRecId = ProjWBS::getRootActivityRecId(_projTable.ProjId);
        utcDateTime projectBookingMinDateTime = ActivityFacade::getEarliestBookingDate(projectActivityRecId);
        utcDateTime projectBookingMaxDateTime = ActivityFacade::getLatestBookingDate(projectActivityRecId);
        if ((projectBookingMinDateTime != DateTimeUtil::minValue())
                    && (projectBookingMaxDateTime != DateTimeUtil::minValue()))
        {
            _projTable.PSASchedStartDate = DateTimeUtil::date(projectBookingMinDateTime);
            _projTable.PSASchedEndDate = DateTimeUtil::date(projectBookingMaxDateTime);
            _projTable.PSASchedEffort = ProjActivityCapacity::sumBookedHoursPerStaffableEntity(_projTable.ProjId, "",
                    ResCommitType::HardBook, false);
        }
        else
        {
            _projTable.PSASchedEffort = 0;
            if (!prmisdefault(_defaultStartDate) && !prmisdefault(_defaultEndDate))
            {
                _projTable.PSASchedStartDate = _defaultStartDate;
                _projTable.PSASchedEndDate = _defaultEndDate;
            }
        }
        _projTable.PSASchedDuration = ResUtil::getProjectSchedulingDuration(_projTable.PSASchedStartDate,
                    _projTable.PSASchedEndDate, _projTable.PSASchedCalendarId);

        return _projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSubProjectCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the PSASchedCalendarId for all the subprojects
    /// </summary>

    public void updateSubProjectCalendar()
    {
        ProjTable  locProjTable;

        if (ProjTable::child(this.ProjId))
        {
            ttsbegin;

            update_recordset locProjTable
                setting psaSchedCalendarId  = this.psaSchedCalendarId
                where locProjTable.ParentId == this.ProjId;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaskCalendars</Name>
				<Source><![CDATA[
    private void updateTaskCalendars()
    {
        PSAActivitySetup   psaActivitySetup;
        smmActivities      smmActivities;
        HierarchyTreeTable hierarchyTreeTable;
        HierarchyIdBase    localHierarchyid;
        CalendarId         calendarId          = this.psaSchedCalendarId;

        localHierarchyid = HierarchyLinkTable::findRefTableRecId(tableNum(ProjTable), this.RecId).HierarchyId;

        update_recordset psaActivitySetup
           setting CalendarId = calendarId
        join smmActivities
            where smmActivities.ActivityNumber == psaActivitySetup.ActivityNumber
            join hierarchyTreeTable
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
                      && hierarchyTreeTable.HierarchyId == localHierarchyid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePlannedResourceRollupByCalendar</Name>
				<Source><![CDATA[
    private void updatePlannedResourceRollupByCalendar(CalendarId _originalCalendarId)
    {
        // Update all existing planned resource rollup if the existing calendar has been changed.
        if (_originalCalendarId != '')
        {
            ResProjTeamController projTeamController = ResProjTeamController::getInstanceFromProjId(this.ProjId);
            projTeamController.updateAllPlannedResourceRollup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current record is valid and ready to be deleted from the database.
    /// </summary>
    /// <param name="calledFromStatus">
    /// A Boolean value that indicates whether the method will also validate based on project status and
    /// type; optional.
    /// </param>
    /// <returns>
    /// true if the record is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method does not delete a project that still has subscription with fee transactions associated
    /// with it, or projects with sub-projects.
    /// </remarks>
    public boolean validateDelete(boolean calledFromStatus = false)
    {
        if (!SMASubscriptionTable::projectCanBeDeleted(this.ProjId))
        {
            // Subscriptions with fee transactions exist on project %1
            return checkFailed(strFmt("@SYS84369", this.ProjId));
        }

        if (!this.projectCanBeDeleted())
        {
            return checkFailed(strFmt("@Proj:ProjectCannotBeDeleted", this.projId));
        }

        if (!calledFromStatus)
        {
            return this.status().validateDelete();
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the field specified by the <paramref name="fielded" /> parameter is valid.
    /// </summary>
    /// <param name="fieldId">
    ///    The field ID of the field to validate.
    /// </param>
    /// <returns>
    ///    true if the field is valid; otherwise, false.
    /// </returns>
    boolean validateField(FieldId fieldId)
    {
        boolean                 ret;
        DictField               dictField;
        ProjControlPeriodTable  projControlPeriodTable;
        CustTable               custTable;
        int                     integerValue;

        dictField = new DictField(tableNum(ProjTable), fieldNum(ProjTable, ProjId));

        ret       = super(fieldId);

        switch (fieldId)
        {
            case fieldNum(ProjTable, Format) :
                if (this.ParentId && (strLen(this.ParentId) + strLen(this.Format)) > dictField.stringLen())
                {
                    ret = ret && checkFailed("@SYS50459");
                }

                if (ProjTable::projIdLastSon(this.ProjId))
                {
                    if (this.orig().Format != this.Format)
                    {
                        ret = ret && checkFailed("@SYS50787");
                    }
                }

                if (ret && this.Format && !NumberSeq::formatCountSymbols(this.Format))
                {
                    // Incorrect format, the character # must be included in the format
                    ret = ret && checkFailed("@SYS67825");
                }
                break;

            case fieldNum(ProjTable, wipProject) :
                if ((this.wipProject) && (ProjControlPeriodTable::eliminated(this.wipProject, ProjWIPTable::find(this.wipProject).PeriodId)))
                {
                    ret = ret && checkFailed("@SYS107846");
                }

                if (this.wipProject && !(this.Type == ProjType::FixedPrice ||
                                         this.type == ProjType::Investment ||
                                         (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
                                          ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(this.ProjId, this.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice))))
                {
                    str checkfailedLabel;
                    if (FeatureStateProvider::isFeatureEnabled(ProjEstimatesToRevRecRenameFeature::instance()))
                    {
                        checkfailedLabel = "@Proj:EstimateProjectNotValidOnProjectV2";
                    }
                    else
                    {
                        checkfailedLabel = "@Proj:EstimateProjectNotValidOnProject";
                    }
                    ret = ret && checkFailed(checkfailedLabel);
                }
                else if (!this.wipProject && this.shouldCreateRevRecEstimateProject())
                {
                    ret = ret && checkFailed(strFmt("@SYS84753", fieldPName(ProjTable, WIPProject)));
                }

                if (this.wipProject && this.ProjGroupId
                    && (this.wipProject != this.ProjId)
                    && (ProjTable::find(this.wipProject).ProjGroupId != this.ProjGroupId))
                {
                    ret = ret && checkFailed("@SYS55596");
                }

                if (this.orig().wipProject && (this.orig().wipProject != this.wipProject && this.orig().wipProject == this.orig().ProjId))
                {
                    if (ProjTable::existWIPProject(this.orig().wipProject))
                    {
                        ret = ret && checkFailed(strFmt("@SYS91836",tableNum(ProjTable)));
                    }

                    select projControlPeriodTable
                        where projControlPeriodTable.ProjId == this.orig().wipProject;
                    if (projControlPeriodTable)
                    {
                        ret = ret && checkFailed(strFmt("@SYS91835",tableId2pname(tableNum(ProjControlPeriodTable))));
                    }
                }

                if (ret && this.orig().wipProject != this.wipProject)
                {
                    ret = ProjWIPTable::checkRemoveProjectV2(this.ProjId);
                }

                break;

            case fieldNum(ProjTable, ProjGroupId) :
                if (this.ProjGroupId && (ProjGroup::find(this.ProjGroupId).ProjType != this.Type))
                {
                    // Check RecId so ProjGroup can be changed on create
                    if (!isConfigurationkeyEnabled(configurationKeyNum(Project)) || this.RecId)
                    {
                        ret = checkFailed("@SYS55607");
                    }
                }

                if (this.wipProject && this.ProjGroupId && (this.wipProject != this.ProjId) && ProjTable::find(this.wipProject).ProjGroupId != this.ProjGroupId)
                {
                    ret = checkFailed("@SYS55596");
                }
                break;

            case fieldNum(ProjTable, Template) :
                if (this.Template && this.wipProject)
                {
                    if (this.wipProject != this.ProjId)
                    {
                        return checkFailed("@SYS58804");
                    }
                }
                break;

            case fieldNum(ProjTable, CustAccount) :
                if (this.RecId != 0)
                {
                    ret = ret & this.checkAccount();
                }

                if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
                {
                    custTable = CustTable::find(this.CustAccount);
                    if (custTable.mcrMergedParent)
                    {
                        ret = checkFailed(strFmt("@MCR12337",this.CustAccount,custTable.mcrMergedParent));
                    }
                }
                break;
            case fieldNum(ProjTable,AssetId) :
                if (this.AssetId)
                {
                    if (!AssetTable::find(this.AssetId).hasOpenAssetBook())
                    {
                    //This should not fail validation, simply warn the user
                        info("@FixedAssets:FA_MessageValidation_AssetDoesNotHaveBookWithStatusOpen");
                        ret = true;
                    }
                }
                break;

            case fieldNum(ProjTable, AlternateBudgetProject) :
                if (this.AlternateBudgetProject)
                {
                    ret = this.checkAlternateProject();
                }
                break;

            case fieldNum(ProjTable, BankDocumentType):
                if (this.orig().BankDocumentType != this.BankDocumentType)
                {
                    if (this.orig().isBankDocumentCreated())
                    {
                        // Bank document type could not be changed.
                        ret = checkFailed("@SYS316266");
                    }
                    else
                    {
                        if (this.BankDocumentType == BankLGDocumentType::LetterOfGuarantee)
                        {
                            if (BankLGFeatureChecker::checkBankLGEnabled())
                            {
                                if (!this.orig().type().ctrlBankDocumentType(this.BankDocumentType))
                                {
                                    // It is not allowed to set to this type at the current status.
                                    ret = checkFailed("@SYS318015");
                                }
                            }
                            else
                            {
                                // Letter of Guarantee feature is not enabled.
                                ret = checkFailed(
                                    "@SYS318007",
                                    '',
                                    SysInfoAction_Formrun::newFormnameControlnameDesc(
                                        formStr(BankParameters),
                                        formControlStr(BankParameters, BankLG_BankLGEnable),
                                        "@SYS24215"));
                            }
                        }
                    }
                }
                break;

            case fieldNum(ProjTable, WorkerResponsible) :
                if (this.WorkerResponsible)
                {
                    ret = ret && HcmWorker::exist(this.WorkerResponsible);
                }
                break;

            case fieldNum(ProjTable, WorkerResponsibleFinancial) :
                if (this.WorkerResponsibleFinancial)
                {
                    ret = ret && HcmWorker::exist(this.WorkerResponsibleFinancial);
                }
                break;

            case fieldNum(ProjTable, WorkerResponsibleSales) :
                if (this.WorkerResponsibleSales)
                {
                    ret = ret && HcmWorker::exist(this.WorkerResponsibleSales);
                }
                break;

            case fieldNum(ProjTable, MinTimeIncrement):
                integerValue = real2int(this.MinTimeIncrement);

                if (integerValue != 0)
                {
                    return checkFailed("@SYS345061");
                }
                break;

            case fieldNum(ProjTable,psaSchedStartDate):
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    if (!WorkCalendarDate::isDateOpen(this.psaSchedCalendarId,this.psaSchedStartDate))
                    {
                        ret = checkFailed("@PSA11116");
                    }
                }
                break;

            case fieldNum(ProjTable,psaSchedEndDate):
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    if (!WorkCalendarDate::isDateOpen(this.psaSchedCalendarId,this.psaSchedEndDate))
                    {
                        ret = checkFailed("@PSA11116");
                    }
                }
                break;

            case fieldNum(ProjTable,PSASchedCalendarId):
                if (this.PSASchedCalendarId == "")
                {
                    PSAProjSchedRole psaProjSchedRole;
                    select firstonly RecId from psaProjSchedRole where psaProjSchedRole.ProjId == this.ProjId;
                    if (psaProjSchedRole)
                    {
                        ret = checkFailed("@Proj:ProjSchedCalendarError");
                    }
                }
                break;
            case fieldNum(ProjTable, DefaultFundingSource):
                ret = !this.DefaultFundingSource || ProjFundingSource::existExternalContractFundingSource(this.ProjInvoiceProjId, this.DefaultFundingSource);
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the format of the project ID.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID to validate.
    /// </param>
    /// <returns>
    ///    true if the project ID is valid; otherwise, false.
    /// </returns>
    public boolean validateProjId(ProjId _projId)
    {
        NumberSequenceFormat    subFormat;
        Counter                 idx;
        boolean                 validate = true;

        #define.SymbolNumerals('#')
        #define.SymbolAlphabets('&')

        if (this.ParentId)
        {
            if (this.ParentId != subStr(_projId, 1, strLen(this.ParentId)))
            {
                validate = false;
            }
            else
            {
                subFormat = ProjTable::find(this.ParentId).Format;

                for (idx = 1; idx <= strLen(subFormat); idx++)
                {
                    if (subStr(subFormat, idx, 1) != #SymbolNumerals && subStr(subFormat, idx, 1) != #SymbolAlphabets)
                    {
                        if (subStr(subFormat, idx, 1) != subStr(_projId, (strLen(this.ParentId) + idx), 1))
                        {
                            validate = false;
                        }
                    }
                }

                if (strLen(subFormat) != (strLen(_projId) - strLen(this.ParentId)))
                {
                    validate = false;
                }
            }
        }

        if (validate)
        {
            this.ProjId = _projId;
        }

        return validate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current record is valid and ready to be written to the database.
    /// </summary>
    /// <param name="_calledFromStatus">
    ///    A Boolean value that indicates whether the method will also validate based on project status and
    ///    type; optional.
    /// </param>
    /// <returns>
    ///    true if the record is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    If the current project is a subproject, this method makes sure that a valid value is in the format
    ///    field for the parent project. It also makes sure that the project end date is not earlier than the
    ///    project start date. It also performs some other validations based on the status and type of the
    ///    current project.
    /// </remarks>
    public boolean validateWrite(boolean _calledFromStatus = false)
    {
        boolean ret;
        DictField               dictField;

        dictField = new DictField(tableNum(ProjTable), fieldNum(ProjTable, ProjId));
        ret = super();

        if (ret)
        {
            ret = this.validateWriteServer(_calledFromStatus);

            if (ret && !this.isTmp() && this.ParentId && !ProjTable::find(this.ParentId).Format)
            {
                // Project cannot be created, as parent project '%1' does not contain a format.
                ret = checkFailed(strFmt("@SYS67673", this.ParentId));
            }

            if (ret && this.Format && !NumberSeq::formatCountSymbols(this.Format))
            {
                // Incorrect format, the character  must be included in the format
                ret = checkFailed("@SYS67825");
            }

            if (ret && this.validateFieldFormat(dictField))
            {
                ret = ret && checkFailed("@SYS50459");
            }

            if (ret && !ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                if (this.StartDate && this.EndDate)
                {
                    if (this.EndDate < this.StartDate)
                    {
                        // End date must come after start date.
                        ret = checkFailed("@SYS21592");
                    }
                }
                if (ret && this.StartDate)
                {
                    if (this.existEarlyForecastHour())
                    {
                        warning(strFmt("@SYS107211", this.ProjId));
                    }
                }

                // Validation of Projected end date shouldn't be before Projected start date and actual start date
                if (ret && (this.ProjectedEndDate && !this.StartDate && this.ProjectedStartDate))
                {
                    if (this.ProjectedEndDate < this.ProjectedStartDate)
                    {
                        ret = checkFailed("@SYS130588");
                    }
                }

                if (ret && (this.ProjectedEndDate && !this.ProjectedStartDate && this.StartDate))
                {
                    if (this.ProjectedEndDate < this.StartDate)
                    {
                        ret = checkFailed("@SYS130589");
                    }
                }

                if (ret && this.ProjectedEndDate && this.StartDate && this.ProjectedStartDate)
                {
                    if (this.ProjectedEndDate < this.ProjectedStartDate)
                    {
                        ret = checkFailed("@SYS130588");
                    }
                    if (this.ProjectedEndDate < this.StartDate)
                    {
                        ret = checkFailed("@SYS130589");
                    }
                }

                // Validation of Extension date shouldn't be before Actual start date or Projected start date
                if (ret && ((this.ExtensionDate && this.StartDate) || (this.ExtensionDate && this.ProjectedStartDate)))
                {
                    if (this.ExtensionDate < this.StartDate || this.ExtensionDate < this.ProjectedStartDate)
                    {
                        ret = checkFailed("@SYS130590");
                    }
                }

                // Validation of Extension date shouldn't be before Projected end date
                if (ret && this.ExtensionDate && this.ProjectedEndDate && this.ExtensionDate < this.ProjectedEndDate)
                {
                    ret = checkFailed("@SYS130591");
                }
            
                if (this.psaSchedStartDate && this.psaSchedEndDate && this.psaSchedStartDate > this.psaSchedEndDate)
                {
                    ret = checkFailed("@PSA11100");
                }
            }

            //check this on creation only
            if (this.RecId == 0)
            {
                ret = ret && this.checkAccount();
            }
            else
            {
                // Project contract shouldn't be changed if the associated project has any transaction
                // With <c>ProjEnableMultipleContractLinesForProjectFeature</c> enabled, allow adding contract to project with existing transactions
                if (ret &&
                    this.ProjInvoiceProjId != this.orig().ProjInvoiceProjId &&
                    (this.orig().ProjInvoiceProjId || !ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled()))
                {
                    if (ProjTable::hasPostedTransactions(this.ProjId) || ProjTable::hasUnPostedTransactions(this.ProjId))
                    {
                        ret = checkFailed(strFmt("@Proj:ProjectContractModifiedError", this.ProjId));
                    }
                }
            }

            if (ret && this.psaSchedIgnoreCalendar && !this.psaSchedCalendarId)
            {
                ret = checkFailed(strFmt("@PSA3435", strFmt("%1 %2", "@SYS4534", this.ProjId)));
            }

            if (ret && this.UseAlternateProject && this.AlternateBudgetProject == '')
            {
                ret = checkFailed(strFmt("@SYS84753", fieldId2pname(tableNum(ProjTable), fieldNum(ProjTable, AlternateBudgetProject))));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldFormat</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the format of the given field's value.
    /// </summary>
    /// <param name = "_dictField">
    /// A field to be validated.
    /// </param>
    /// <returns>
    /// true, if the field format is valid; otherwise, false.
    /// </returns>
    protected boolean validateFieldFormat(DictField _dictField)
    {
        return this.Format && this.ParentId && (strLen(this.ParentId) + strLen(this.Format)) > _dictField.stringLen();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteServer</Name>
				<Source><![CDATA[
    protected boolean validateWriteServer(boolean _calledFromStatus)
    {
        boolean ret = true;

        if (!_calledFromStatus)
        {
            ret = this.status().validateWrite();
        }

        if (ret && this.ProjInvoiceProjId && !ProjInvoiceTable::exist(this.ProjInvoiceProjId))
        {
            // Project cannot be created, as the associated invoice project '%1' no longer exists.
            ret = checkFailed(strFmt("@SYS96342", this.ProjInvoiceProjId));
        }

        if (ret && this.ProjGroupId && !ProjGroup::exist(this.ProjGroupId))
        {
            // Project cannot be created, as the associated project group '%1' no longer exists.
            ret = checkFailed(strFmt("@SYS98161", this.ProjGroupId));
        }

        if (ret && this.WorkerResponsible)
        {
            ret = HcmWorker::exist(this.WorkerResponsible);
        }

        if (ret && this.WorkerResponsibleFinancial)
        {
            ret = HcmWorker::exist(this.WorkerResponsibleFinancial);
        }

        if (ret && this.WorkerResponsibleSales)
        {
            ret = HcmWorker::exist(this.WorkerResponsibleSales);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUnPostedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the selected project has unposted transactions.
    /// </summary>
    /// <param name="_projId">
    ///    The ID of the project.
    /// </param>
    /// <returns>
    ///    true if there are associated unposted transactions; otherwise, false.
    /// </returns>
    public static boolean hasUnPostedTransactions(ProjId _projId)
    {
        ProjUnpostedTransView	projUnpostedTransView;
        boolean	                hasUnPostedTransactions;

        select firstonly RecId from projUnpostedTransView
            where projUnpostedTransView.ProjId == _projId
            && projUnpostedTransView.TransDataAreaId == curExt();

        if (projUnpostedTransView.RecId)
        {
            hasUnPostedTransactions = true;
        }

        return hasUnPostedTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPostedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the selected project has posted transactions.
    /// </summary>
    /// <param name="_projId">
    ///    The ID of the project.
    /// </param>
    /// <returns>
    ///    true if there are associated posted transactions; otherwise, false.
    /// </returns>
	public static boolean hasPostedTransactions(ProjId _projId)
    {
        ProjPostTransView	projPostTransView;
        boolean	            hasPostedTransactions;

        select firstonly RecId from projPostTransView
            where projPostTransView.ProjId == _projId
            && projPostTransView.DataAreaId == curExt();

        if (projPostTransView.RecId)
		{
            hasPostedTransactions = true;
		}

        return hasPostedTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a project activity exists for the project passed in as a parameter.
    /// </summary>
    /// <param name="projId">
    ///    The ID of the project.
    /// </param>
    /// <returns>
    ///    true if a project activity exists; otherwise, false.
    /// </returns>
    public static boolean activityExists(ProjId projId)
    {
        return HierarchyTreeTable::associationNonRootExist(ProjTable::find(projId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>ancestors</Name>
				<Source><![CDATA[
    static container ancestors(ProjId _projId)
    {
        container ret;
        ProjTable projTable;
        ProjId    projId;

        //return all the ancestors(parents, grandParants...) of the given projId
        projId= _projId;
        projTable = ProjTable::find(projId);
        while (projTable.ParentId)
        {
            ret += projTable.ParentId;
            projId=projTable.ParentId;
            projTable = ProjTable::find(projId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the project passed in as a parameter exists.
    /// </summary>
    /// <param name="projId">
    ///    The project ID.
    /// </param>
    /// <returns>
    ///    true if the project exists; otherwise, false.
    /// </returns>
    static boolean checkExist(ProjId projId)
    {
        if (projId && !ProjTable::exist(projId))
        {
            return checkFailed(strFmt(ProjTable::txtNotExist(), projId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRequireActivity</Name>
				<Source><![CDATA[
    static RequireActivity checkRequireActivity(ProjId _projId, TableId _tableId, ProjCategoryId _categoryId ='')
    {
        boolean ret = false;

        if (_projId)
        {
            switch (_tableId)
            {
                case tableNum(ProjForecastEmpl) :  // Hour 579
                    ret = (select projTable where projTable.ProjId == _projId).RequireActivityHourForecast;
                    break;

                case tableNum(ProjForecastCost) :  // Expense 578
                    ret = (select projTable where projTable.ProjId == _projId).RequireActivityExpenseForecast;
                    break;

                case tableNum(ForecastSales) :  // Item 144
                case tableNum(SalesLine):
                    ret = (select projTable where projTable.ProjId == _projId).RequireActivityItemForecast;
                    break;

                case tableNum(ProjEmplTrans) :  // Hour 587
                    ret = (select projTable where projTable.ProjId == _projId).RequireActivityHourTrx;
                    break;

                case tableNum(ProjCostTrans) :   // Expense journal - 586
                case tableNum(TrvExpTrans):      // Expense transaction - 487
                case tableNum(TrvExpTransSplit): // Split Expense Transaction
                    ret = (select projTable where projTable.ProjId == _projId).RequireActivityExpenseTrx;
                    break;

                case tableNum(ProjItemTrans) :  // Item 1286
                    ret = (select projTable where projTable.ProjId == _projId).RequireActivityItemTrx;
                    break;

                case tableNum(TSTimesheetLine) :  // Hour 4624
                    ret = (select projTable where projTable.ProjId == _projId).RequireActivityHourTrx;
                    break;

                case tableNum(TSTimesheetFavorites) :  // Hour 4622
                    ret = (select projTable where projTable.ProjId == _projId).RequireActivityHourTrx;
                    break;

                case tableNum(VendInvoiceInfoLine_Project):
                case tableNum(PurchLine):
                case tableNum(PurchReqLine):
                case tableNum(PurchRFQLine):
                case tableNum(PurchRFQCaseLine):
                    if (_categoryId != '')
                    {
                        ProjCategory projCategory = ProjCategory::Find(_categoryId);
                        Switch (projCategory.CategoryType)
                        {
                            case ProjCategoryType::Hour :
                                ret = (select projTable where projTable.ProjId == _projId).RequireActivityHourTrx;
                                break;

                            case ProjCategoryType::Cost :
                                ret = (select projTable where projTable.ProjId == _projId).RequireActivityExpenseTrx;
                                break;

                            case ProjCategoryType::Item :
                                ret = (select projTable where projTable.ProjId == _projId).RequireActivityItemTrx;
                                break;
                        }
                    }
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildProjectsFromRootProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetch all child projects to the specified parent project.
    /// </summary>
    /// <param name = "_projId">
    ///  The ID of the project.
    /// </param>
    /// <param name = "_projList"></param>
    /// The list of child projects.
    /// <returns>
    /// Returns list of child projects records.
    /// </returns>
    public static List getChildProjectsFromRootProject(ProjId _projId, List _projList)
    {
        ProjTable   projTable;

        while select projTable
              where projTable.ParentId == _projId
        {
            _projList.addEnd(projTable);

            if (projTable.ProjBudgetManagement == ProjBudgetManagement::None && ProjTable::child(projTable.ProjId))
            {
                ProjTable::getChildProjectsFromRootProject(projTable.ProjId, _projList);
            }
        }

        return _projList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>child</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Check whether the specified project has child project.
    /// </summary>
    /// <param name="_projId">
    ///    The ID of the project.
    /// </param>
    /// <returns>
    ///    true if the project is has child; otherwise, false.
    /// </returns>
    static boolean child(ProjId _projId)
    {
        return (select firstonly RecId from projTable where projTable.ParentId == _projId).RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCategoryConnection</Name>
				<Source><![CDATA[
    public static boolean createCategoryConnection()
    {
        ProjParameters      projParameters  = ProjParameters::find();

        if (projParameters.ValidationProjCategory == ProjValParameter::None)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createResourceConnection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to validate the association of a resource with a project.
    /// </summary>
    /// <param name="_resourceRecId">
    /// The record ID of the resource record.
    /// </param>
    /// <param name="_isIntercompany">
    /// True if transaction is an intercompany transaction.
    /// </param>
    /// <returns>
    /// true if the association should be validated; otherwise, false.
    /// </returns>
    public static boolean createResourceConnection(ResourceRecId _resourceRecId, boolean _isIntercompany = false)
    {
        ProjParameters      projParameters  = ProjParameters::find();

        if (projParameters.ValidationEmplProj == ProjValParameter::None)
        {
            return false;
        }

        if (!_resourceRecId)
        {
            return false;
        }

        // If validation is from an intercompany trx, ignore the resource setup
        if (_isIntercompany)
        {
            return true;
        }

        if (ResourceFacade::validateProjectResource(_resourceRecId) == NoYes::No)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editSubProjects</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates a field in subprojects that are children of the current project record.
    /// </summary>
    /// <param name="_parentProject">
    ///    The ID of the parent project.
    /// </param>
    /// <param name="_fieldId">
    ///    The ID for the field in the <c>ProjTable</c> table to update.
    /// </param>
    /// <param name="_newValue">
    ///    The new value to update the field ID in the subprojects.
    /// </param>
    /// <param name="_editAll">
    ///    A Boolean value that indicates whether all subprojects or only projects that have the same value as
    ///    the original value of the current parent project will be updated.
    /// </param>
    /// <param name="_formerValue">
    ///    The original <c>fieldId</c> value for the parent project; optional.
    /// </param>
    /// <param name="_arrayIdx">
    ///    The index of the element to update if the <paramref name="_fieldId" /> is an array field; optional.
    /// </param>
    /// <param name="_updateLinePropertyId">
    ///     The boolean value indicates whether to update the line property for sub projects or not; optional.
    /// </param>
    /// <remarks>
    ///    This method either updates the field in all the subprojects or only in subprojects that have the
    ///    same original value as the original value in current parent project.
    /// </remarks>
    static void editSubProjects(
        ProjId                  _parentProject,
        FieldId                 _fieldId,
        anytype                 _newValue,
        ProjTableEditSubProj    _editAll,            // If false, only projects with the same former value will be changed.
        anytype                 _formerValue = null,
        ArrayIdx                _arrayIdx = 0,        // Used if field is an array (ie. sortingId or Dimension)
        boolean                 _updateLinePropertyId = false
    )
    {
        //
        // Update the specified field with the new value, for all subprojects.
        // If _formerValue is set the value must match. If not the field is not changed.
        // If field is an array (ie. sortingId or Dimension), the index to be changed,
        // must also be provided.
        //
        // Not all field can be changed "tree-wise". See below.
        //
        ProjTable projTable = null;

        // Check if field is "tree-editable"
        if (_fieldId == fieldNum(ProjTable, ProjGroupId)       ||
            _fieldId == fieldNum(ProjTable, ProjId)            ||
            _fieldId == fieldNum(ProjTable, ProjLedgerPosting) ||
            _fieldId == fieldNum(ProjTable, Created)           ||
            _fieldId == fieldNum(ProjTable, ParentId)          ||
            _fieldId == fieldNum(ProjTable, Format)            ||
            _fieldId == fieldNum(ProjTable, Status)            ||
            _fieldId == fieldNum(ProjTable, wipProject)        ||
            _fieldId == fieldNum(ProjTable, Type)              ||
            _fieldId == fieldNum(ProjTable, Template)          ||
            _fieldId == fieldNum(ProjTable, JobId)             ||
            _fieldId == fieldNum(ProjTable, JobPayType)
           )
        {
            throw error("@SYS57892");
        }

        if (_arrayIdx > 3 || (_arrayIdx &&
                              !(_fieldId == fieldNum(ProjTable, SortingId))
                             )
           )
        {
            // Must be of type Dimension or sortingId, and have length <= 3
            throw error("@SYS57892");
        }

        ttsbegin;

        // Find subprojects
        while select forupdate projTable where projTable.ParentId == _parentProject
        {
            if (_arrayIdx)
            {
                if (_fieldId == fieldNum(ProjTable,SortingId))
                {
                    if (ProjTable::checkProjTableEditSubProjForAll(_editAll) || ((projTable.SortingId[_arrayIdx] == _formerValue) && ProjTable::checkProjTableEditSubProjForSame(_editAll)))
                    {
                        projTable.SortingId[_arrayIdx] = _newValue;
                        if (projTable.validateWrite())
                        {
                            projTable.update();
                        }
                    }
                }
            }
            else
            {
                ProjLinePropertyId  projLinePropertyId = '';

                if (_updateLinePropertyId)
                {
                    projLinePropertyId = (select projLinePropertySetup where projLinePropertySetup.ProjCode          == TableGroupAll::Table   &&
                                                                             projLinePropertySetup.ProjRelation      == projTable.ProjId      &&
                                                                             projLinePropertySetup.CategoryCode      == TableGroupAll::All     &&
                                                                             projLinePropertySetup.CategoryRelation  == '').LinePropertyId;
                    if (ProjTable::checkProjTableEditSubProjForAll(_editAll) || ((projLinePropertyId == _formerValue) && ProjTable::checkProjTableEditSubProjForSame(_editAll)))
                    {
                        projTable.projLinePropertyId(true, projTable, _newValue);
                    }
                }
                // Update field if _editAll, or the former value match this value
                else if (ProjTable::checkProjTableEditSubProjForAll(_editAll) || ((projTable.(_fieldId) == _formerValue) && ProjTable::checkProjTableEditSubProjForSame(_editAll)))
                {
                    projTable.(_fieldId) = _newValue;
                    projTable.modifiedField(_fieldId);
                    if (projTable.validateWrite())
                    {
                        projTable.update();
                    }
                }
            }

            // Edit field for the subproject's subprojects. RECURSIVE!
            if (ProjTable::checkProjTableEditSubProjForAll(_editAll) || ProjTable::checkProjTableEditSubProjForSame(_editAll))
            {
                ProjTable::editSubProjects(projTable.ProjId, _fieldId, _newValue, _editAll, _formerValue, _arrayIdx, _updateLinePropertyId);
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editSubProjectsAddress</Name>
				<Source><![CDATA[
    static void editSubProjectsAddress(
        ProjId                  _parentProject,
        anytype                 _newDeliveryLocation,
        ProjTableEditSubProj    _editAll
    )
    {
        ProjTable projTable = null;
        LogisticsPostalAddress  logisticsPostalAddress;
        LogisticsLocation       locationRecord;

        ttsbegin;

        // Find subprojects
        while select forupdate projTable where projTable.ParentId == _parentProject
        {
            // Update field if _editAll
            if (ProjTable::checkProjTableEditSubProjForAll(_editAll))
            {
                if (!projTable.DeliveryLocation)
                {
                    if (_newDeliveryLocation == 0)
                    {
                        continue;
                    }
                    logisticsPostalAddress.clear();
                    LogisticsPostalAddressMap::initMapFromLocation(logisticsPostalAddress, _newDeliveryLocation);
                    logisticsPostalAddress.insert();
                    projTable.DeliveryLocation = logisticsPostalAddress.Location;
                    if (projTable.validateWrite())
                    {
                        projTable.update();
                    }
                }
                else
                {
                    if (_newDeliveryLocation == 0)
                    {
                        locationRecord = LogisticsLocation::find(projTable.DeliveryLocation, true);

                        projTable.DeliveryLocation = 0;
                        if (projTable.validateWrite())
                        {
                            projTable.update();
                        }

                        if (!ProjClearAddressFromProjectFlight::instance().isEnabled() && locationRecord.validateDelete())
                        {
                            locationRecord.delete();
                        }
                    }
                    else
                    {
                        LogisticsLocation parentProjectLocationRecord;

                        logisticsPostalAddress = LogisticsPostalAddress::findByLocation(projTable.DeliveryLocation, true);
                        locationRecord = LogisticsLocation::find(projTable.DeliveryLocation, true);
                        parentProjectLocationRecord = LogisticsLocation::find(_newDeliveryLocation, false);
                        locationRecord.Description = parentProjectLocationRecord.Description;

                        if(locationRecord && locationRecord.validateWrite())
                        {
                            locationRecord.update();

                            projTable.DlvName = parentProjectLocationRecord.Description;

                            if(projTable.validateWrite())
                            {
                                projTable.update();
                            }
                        }
                        
                        LogisticsPostalAddressMap::initMapFromLocation(logisticsPostalAddress, _newDeliveryLocation);
                        logisticsPostalAddress.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);
                        logisticsPostalAddress.update();
                    }
                }
            }
            // Edit field for the subproject's subprojects. RECURSIVE!
            if (ProjTable::checkProjTableEditSubProjForAll(_editAll) || ProjTable::checkProjTableEditSubProjForSame(_editAll))
            {
                ProjTable::editSubProjectsAddress(projTable.ProjId, _newDeliveryLocation, _editAll);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjTableEditSubProjForAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for enum value on <c>ProjTableEditSubProj</c>.
    /// </summary>
    /// <param name = "_editAll">
    /// Enum value of <c>ProjTableEditSubProj</c>.
    /// </param>
    /// <returns>
    /// true if enum value is all; otherwise, false.
    /// </returns>
    protected static boolean checkProjTableEditSubProjForAll(ProjTableEditSubProj _editAll)
    {
        return (_editAll == ProjTableEditSubProj::All);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjTableEditSubProjForSame</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for enum value on <c>ProjTableEditSubProj</c>.
    /// </summary>
    /// <param name = "_editAll">
    /// Enum value of <c>ProjTableEditSubProj</c>.
    /// </param>
    /// <returns>
    /// true if enum value is same; otherwise, false.
    /// </returns>
    protected static boolean checkProjTableEditSubProjForSame(ProjTableEditSubProj _editAll)
    {
        return (_editAll == ProjTableEditSubProj::Same);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified project exists.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID.
    /// </param>
    /// <returns>
    ///    true if the project exists; otherwise, false.
    /// </returns>
    public static boolean exist(ProjId _projId)
    {
        if (_projId)
        {
            return (select projTable where projTable.ProjId == _projId).RecId != 0;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existAssetProject</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the fixed asset is associated with a project.
    /// </summary>
    /// <param name="_assetId">
    ///    The asset ID to check for association with projects.
    /// </param>
    /// <returns>
    ///    true if the asset ID is associated with a project; otherwise, false.
    /// </returns>
    public static boolean existAssetProject(AssetId _assetId)
    {
        boolean ret = false;

        if (_assetId)
        {
            // Return true if the _assetId is assigned with any project; otherwise, false.
            ret =  (select firstonly projTable where projTable.AssetId == _assetId).RecId != 0;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existEarlyForecastHour</Name>
				<Source><![CDATA[
    public boolean existEarlyForecastHour()
    {
        ProjForecastEmpl  projForecastEmpl;

        select firstonly RecId from projForecastEmpl
            where projForecastEmpl.ProjId == this.ProjId
               && projForecastEmpl.ProjForecastBudgetType == ProjForecastBudgetType::None
               && (projForecastEmpl.SchedFromDate < this.StartDate ||
                  ((projForecastEmpl.SchedToDate!=dateNull()) && projForecastEmpl.SchedToDate < this.StartDate));

        if (projForecastEmpl)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existInvoiceProjFP</Name>
				<Source><![CDATA[
    public static boolean existInvoiceProjFP(ProjInvoiceProjId _projInvoiceId)
    {
        boolean ret = false;

        if (_projInvoiceId)
        {
            if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
            {
                PSAContractLineItems contractLine;
                select firstonly RecId from contractLine
                    where contractLine.ProjInvoiceProjId == _projInvoiceId && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
                
                ret = contractLine.RecId != 0;
            }
            else
            {
                ret = (select firstonly projTable where projTable.ProjInvoiceProjId == _projInvoiceId && projTable.Type == ProjType::FixedPrice).RecId != 0;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existInvoiceProjTM</Name>
				<Source><![CDATA[
    public static boolean existInvoiceProjTM(ProjInvoiceProjId _projInvoiceId)
    {
        boolean ret = false;

        if (_projInvoiceId)
        {
            if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
            {
                PSAContractLineItems contractLine;
                select firstonly RecId from contractLine
                    where contractLine.ProjInvoiceProjId == _projInvoiceId && contractLine.BillingMethod == ProjContractBillingMethod::TimeMaterial;

                ret = contractLine.RecId != 0;
            }
            else
            {
                ret = (select firstonly projTable where projTable.ProjInvoiceProjId == _projInvoiceId && projTable.Type == ProjType::TimeMaterial).RecId != 0;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existProjOpenOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether on-account transactions that have not been invoiced exist for any project associated
    ///    with the invoice project and currency passed in as parameters.
    /// </summary>
    /// <param name="projInvoiceProjId">
    ///    The ID of the invoice project.
    /// </param>
    /// <param name="currencyId">
    ///    The currency ID.
    /// </param>
    /// <returns>
    ///    true if on-account transactions exist; otherwise, false.
    /// </returns>
    public static boolean existProjOpenOnAcc(ProjInvoiceProjId projInvoiceProjId, CurrencyCode currencyId)
    {
        ProjInvoiceOnAcc    projInvoiceOnAcc;
        ProjOnAccTrans      projOnAccTrans;
        ProjTable           projTable;

        select firstonly CurrencyId, ProjID, TransId from projOnAccTrans
            where projOnAccTrans.CurrencyId == currencyId
            join ProjInvoiceProjId, ProjId from projTable
            where projTable.ProjInvoiceProjId   == projInvoiceProjId        &&
                  projTable.ProjId              == projOnAccTrans.ProjID
                  notexists join TransId from projInvoiceOnAcc
                    where projInvoiceOnAcc.TransId  == projOnAccTrans.TransId;

        if (projOnAccTrans)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsProjectInContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the project exists for a particular contract id
    /// </summary>
    /// <param name="_projId">
    /// Project id
    /// </param>
    /// <param name="_projProposalId">
    /// Contract Id
    /// </param>
    /// <returns>
    /// true if project exists for the contract id; otherwise, false.
    /// </returns>
    public static boolean existsProjectInContract(ProjId _projId, ProjProposalId _projProposalId)
    {
        ProjTable     projTable;

        select firstonly RecId from projTable
        where projTable.ProjId            == _projId
        &&    projTable.ProjInvoiceProjId == _projProposalId;

        if (!projTable)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsSubProject</Name>
				<Source><![CDATA[
    public static boolean existsSubProject(ProjId _projId)
    {
        return (select count(RecId) from projTable where projTable.ProjId like _projId).RecId > 1 ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existWIPProject</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the project passed in as a parameter exists as a WIP project.
    /// </summary>
    /// <param name="_wiPprojID">
    ///    The ID of the WIP project.
    /// </param>
    /// <returns>
    ///    true if a WIP project exists; otherwise, false.
    /// </returns>
    static boolean existWIPProject(ProjId _wiPprojID)
    {
        if (_wiPprojID)
        {
            return (select projTable where projTable.wipProject == _wiPprojID && projTable.ProjId != _wiPprojID).RecId != 0;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the project for a given project ID.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID of the transaction.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that determines whether the project should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    The project.
    /// </returns>
    public static ProjTable find(ProjId _projId, boolean _forUpdate = false)
    {
        ProjTable   projTable = null;

        projTable.selectForUpdate(_forUpdate);

        if (_projId)
        {
            select firstonly projTable where projTable.ProjId == _projId;
        }

        return projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByBankLG</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds a record that link to a specified <c>BankLGGuarantee</c> record.
    /// </summary>
    /// <param name="_bankLGRefRecId">
    ///     The rec Id of the related <c>BankLGGuarantee</c> record.
    /// </param>
    /// <param name="_forUpdate">
    ///     A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///     If found, returns the record in the <c>ProjTable</c> table; otherwise, returns an empty record.
    /// </returns>
    public static ProjTable findByBankLG(
        BankLGRefRecId   _bankLGRefRecId,
        boolean          _forUpdate = false)
    {
        ProjTable               projTable;
        BankLGGuaranteeProject  bankLGGuaranteeProject;

        projTable.selectForUpdate(_forUpdate);

        if (_bankLGRefRecId)
        {
            select firstonly projTable
                exists join bankLGGuaranteeProject
                where bankLGGuaranteeProject.Project    == projTable.ProjId
                    && bankLGGuaranteeProject.Guarantee == _bankLGRefRecId;
        }

        return projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByDataArea</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the project for a given project ID and data area
    /// </summary>
    /// <param name="_projId">
    ///    The project ID of the transaction.
    /// </param>
    /// <param name="_dataArea">
    ///     The data area to look for the project in.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that determines whether the project should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    The project.
    /// </returns>
    public static ProjTable findByDataArea(ProjId _projId, SelectableDataArea _dataArea = curext(), boolean _forUpdate = false)
    {
        ProjTable projTable;

        projTable.selectForUpdate(_forUpdate);

        if (_projId)
        {
            select firstonly crossCompany projTable
                where projTable.ProjId     == _projId &&
                      projTable.DataAreaId == _dataArea;
        }

        return projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByLedgerDimension</Name>
				<Source><![CDATA[
    public static ProjTable findByLedgerDimension(
        LedgerDimensionAccount  _ledgerDimension,
        boolean                 _forupdate = false,
        ConcurrencyModel        _concurrencyModel = ConcurrencyModel::Auto)
    {
        ProjTable                           projTable;
        DimensionAttributeValueCombination  ledgerDimension;

        projTable.selectForUpdate(_forupdate);
        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            projTable.concurrencyModel(_concurrencyModel);
        }

        select firstonly projTable
            join RecId from ledgerDimension where
                ledgerDimension.DisplayValue == projTable.ProjId &&
                ledgerDimension.RecId == _ledgerDimension;

        return projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByHierarchyId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the project for a given hierarchy ID
    /// </summary>
    /// <param name="_hierarchyId">
    ///    The hierarchy ID.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that determines whether the project should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    The project.
    /// </returns>
    public static ProjTable findByHierarchyId(HierarchyIdBase _hierarchyId, boolean _forupdate = false)
    {
        ProjTable           projTable;
        HierarchyLinkTable  hierarchyLinkTable;

        projTable.selectForUpdate(_forupdate);

        select firstonly projTable
            exists join hierarchyLinkTable
                where hierarchyLinkTable.RefRecId == projTable.RecId
                    && hierarchyLinkTable.RefTableId == projTable.TableId
                    && hierarchyLinkTable.HierarchyId == _hierarchyId;

        return projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findJobId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the project record for the job ID passed in as a parameter.
    /// </summary>
    /// <param name="_jobId">
    ///    The ID for the job associated to the project returned.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that determines whether the project should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    The project.
    /// </returns>
    public static ProjTable findJobId(JmgJobId _jobId, boolean _forUpdate = false)
    {
        // Shop Floor Control - begin
        ProjTable    projTable;

        projTable.selectForUpdate(_forUpdate);

        select firstonly projTable where projTable.JobId == _jobId;

        return projTable;
        // Shop Floor Control - end
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLike</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves projects that have project IDs that begin with the project ID passed in as a parameter.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID on which to base the query.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that determines whether the project should be selected for update; optional.
    /// </param>
    /// <param name="_projIdOrig">
    ///    The original project ID of the project that should not be retrieved; optional.
    /// </param>
    /// <returns>
    ///    The projects.
    /// </returns>
    public static ProjTable findLike(ProjId _projId, boolean _forUpdate  = false, ProjId _projIdOrig = '')
    {
        ProjTable   projTable = null;

        projTable.selectForUpdate(_forUpdate);

        if (_projId)
        {
            if (_projIdOrig)
            {
                select projTable
                    where projTable.ProjId  like _projId        &&
                          projTable.ProjId  !=   _projIdOrig    &&
                        ! projTable.ParentId;
            }
            else
            {
                select projTable where projTable.ProjId like _projId;
            }
        }

        return projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPriceGroup</Name>
				<Source><![CDATA[
    static ProjPriceGroupID findPriceGroup(ProjId    _projId)
    {
        ProjPriceGroupID    projPriceGroup;

        projPriceGroup = ProjTable::priceGroup(_projId);
        if (!projPriceGroup)
        {
            projPriceGroup = ProjInvoiceTable::priceGroup(ProjTable::projInvoiceStatic(_projId).ProjInvoiceProjId);

            if (!projPriceGroup)
            {
                projPriceGroup = CustTable::projPriceGroup(ProjTable::find(_projId).CustAccount);
            }
        }

        return  projPriceGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the project record for the record ID passed in as a parameter.
    /// </summary>
    /// <param name="_recId">
    ///    The record ID for the project to retrieve.
    /// </param>
    /// <param name="_forUpdate">
    ///    Check if the record is being accessed for update.
    /// </param>
    /// <returns>
    ///    The project record.
    /// </returns>
    public static ProjTable findRecId(RecId _recId, boolean _forUpdate = false)
    {
        ProjTable    projTable;

        projTable.selectForUpdate(_forUpdate);

        if (_recId != 0)
        {
            select projTable where projTable.RecId == _recId;
        }

        return projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldGenerateNextSubProjectId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whther to generate the project ID to use for the next sub project being created on a hierarchy.
    /// </summary>
    /// <returns>
    ///     Always true.
    /// </returns>
    protected static boolean shouldGenerateNextSubProjectId()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateNextSubProjectId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generate the project ID to use for the next sub project being created on a hierarchy
    /// </summary>
    /// <param name="_parentProjId">
    ///     The project ID for the parent project in which the sub project will be created under
    /// </param>
    /// <returns>
    ///     The generated project ID
    /// </returns>
    public static ProjId generateNextSubProjectId(ProjId _parentProjId)
    {
        Integer                 sonNum;
        ProjId                  projFormat;
        ProjId                  projIdLastSon;
        ProjId                  projIdNext;

        #DEFINE.SymbolAlpha('&')

        if(ProjTable::shouldGenerateNextSubProjectId())
        {
            projIdLastSon       = ProjTable::projIdLastSon(_parentProjId);

            if (projIdLastSon)
            {
                projFormat          = subStr(projIdLastSon,
                                            strLen(_parentProjId)+1,
                                            (strLen(projIdLastSon)-strLen(_parentProjId)+1));

                sonNum = NumberSeq::numRemoveFormatV2(projFormat, ProjTable::find(_parentProjId).Format);

                if (sonNum < 0)
                {
                    throw error("@Proj:SubProjectIdExceedsIntegerLimit");
                }
            }
            else
            {
                projFormat          = ProjTable::find(_parentProjId).Format;

                if (subStr(projFormat, strLen(projFormat), 1) == #SymbolAlpha)
                {
                    sonNum = -1;
                }
                else
                {
                    sonNum  = 0;
                }
            }

            projIdNext = _parentProjId +
                         NumberSeq::numInsertFormat(sonNum+1, ProjTable::find(_parentProjId).Format);
            
        }
        return projIdNext;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIfCategoryValidationReq</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Checks if the project requires a category validation.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <returns>true if <c>ValidateProjCategory</c> is set to true on the project. Otherwise, false.</returns>
    public static NoYes getIfCategoryValidationReq(ProjId _projId)
    {
        ProjTable projTable;
        select firstonly validateProjCategory from projTable
            where ProjTable.ProjId == _projId;

        return projTable.ValidateProjCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjTableByStatusTypeRuleQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query to retrieve a list of <c>ProjTable</c> records.
    /// </summary>
    /// <returns>
    /// A query to retrieve a list of <c>ProjTable</c> records.
    /// </returns>
    public static Query getProjTableByStatusTypeRuleQuery()
    {
        Query                   query;
        QueryBuildDataSource    projTableQueryBuildDataSource;
        QueryBuildDataSource    projStatusTypeRuleQueryBuildDataSource;

        query = new Query();

        projTableQueryBuildDataSource = query.addDataSource(tableNum(ProjTable));

        // Adding join with ProjTable table.
        projStatusTypeRuleQueryBuildDataSource = projTableQueryBuildDataSource.addDataSource(tableNum(ProjStatusTypeRule));

        projStatusTypeRuleQueryBuildDataSource.addLink(fieldNum(ProjTable, Status), fieldNum(ProjStatusTypeRule, ProjStatus));
        projStatusTypeRuleQueryBuildDataSource.addLink(fieldNum(ProjTable, Type), fieldNum(ProjStatusTypeRule, ProjType));
        projStatusTypeRuleQueryBuildDataSource.addRange(fieldNum(ProjStatusTypeRule, ProjStatusRule)).value(SysQuery::value(ProjStatusRule::CreateForecast));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRootProjId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the top most root for a given project id.
    /// </summary>
    /// <param name="_projId">
    /// The project id for which an ancestor needs to be found.
    /// </param>
    /// <param name="_dataArea">
    /// The data area of the project
    /// </param>
    /// <returns>
    /// Returns the top most root of the given project id.
    /// </returns>
    /// <remarks>
    /// Breaks out after depth of 64 to prevent infinite loop.
    /// </remarks>
    public static ProjId getRootProjId(ProjId _projId, SelectableDataArea _dataArea = curext())
    {
        const int MaxHeight = 64;

        ProjTable projTable;
        ProjId    projId;
        int       height = MaxHeight;

        //locate top ancestor
        projId = _projId;

        if (_projId)
        {
            select firstonly crossCompany ParentId from projTable
                where projTable.ProjId     == _projId &&
                    projTable.DataAreaId == _dataArea;

            //break out after 64 depth, probably a cycle
            while (projTable.ParentId && height)
            {
                height -= 1;
                projId = projTable.ParentId;

                select firstonly crossCompany ParentId from projTable
                    where projTable.ProjId     == projId &&
                          projTable.DataAreaId == _dataArea;
            }
        }

        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBegBalRuleDefined</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the starting balance rule is defined for the project.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID for which to check the start balance.
    /// </param>
    /// <returns>
    ///    true if the start balance rule is defined; otherwise, false.
    /// </returns>
    public static boolean isBegBalRuleDefined(ProjId _projId)
    {
        return ProjTable::isRuleDefined(_projId, ProjStatusRule::CreateBeginningBalance);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreateItemTaskRuleDefined</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the starting balance rule is defined for the project.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID for which to check the create item task rule.
    /// </param>
    /// <returns>
    /// true if the create item task is allowed; otherwise, false.
    /// </returns>
    public static boolean isCreateItemTaskRuleDefined(ProjId _projId)
    {
        return ProjTable::isRuleDefined(_projId, ProjStatusRule::CreateItemTask);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRuleDefined</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if a rule is defined for the given project
    /// </summary>
    /// <param name="_projId">
    ///    The project ID for which to check the rule.
    /// </param>
    /// <param name="_rule">
    ///    Rule to check for the given projId.
    /// </param>
    /// <returns>
    ///    true if the rule is defined; false otherwise.
    /// </returns>
    private static boolean isRuleDefined(ProjId _projId, ProjStatusRule _rule)
    {
        ProjTable projTable;
        boolean ret;

        select firstonly Status,Type from projTable where projTable.ProjId == _projId;
        ret = ProjStatusTypeRule::exist(projTable.Status, projTable.Type, _rule);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isModelActive</Name>
				<Source><![CDATA[
    // Description    : Check if forecast model is active for a given project
    // Parameters     : _projID: Project number
    //                  _modelID: Forecast model number
    // Return value   : True if active, else false

    public static boolean isModelActive(ProjId _projId, ForecastModelId _modelID)
    {
        ProjTable   srch;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            select firstonly firstfast RecId
                from srch
                where   srch.ProjId                     == _projId &&
                       (srch.psaForecastModelId         == _modelID ||
                        srch.psaForecastModelIdExternal == _modelID);
        }

        return srch.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNumberSeqManual</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the number sequence used for project IDs is set up to be manual.
    /// </summary>
    /// <returns>
    ///    true if the number sequence is set up to be manual; otherwise, false.
    /// </returns>
    public static boolean isNumberSeqManual()
    {
        return NumberSequenceTable::findByNaturalKey(ProjTable::numberSequenceCode()).Manual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedPriceEligibleForOnlyPLPosting</Name>
				<Source><![CDATA[
    private boolean fixedPriceEligibleForOnlyPLPosting()
    {
        return !this.wipProject
                || (this.wipProject && (ProjControlPeriodTable::eliminated(this.wipProject, ProjWIPTable::find(this.wipProject).ControlId)
                    || ProjWIPTable::find(this.wipProject).wipEliminated));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPLPostingRequired</Name>
				<Source><![CDATA[
    [SysObsoleteAttribute('This method is replaced by isPLPostingRequiredForTransType()', false, 23\06\2020)]
    public static boolean isPLPostingRequired(ProjId  _projId)
    {
        boolean     ret;
        ProjTable   projTable;
        ProjType    projType;

        ret = false;

        projTable   = ProjTable::find(_projId);
        projType    = ProjGroup::find(projTable.ProjGroupId).ProjType;

        // Eliminated Fixed Price and Investment projects post to P&l
        // Fixed Price and Investement projects not assigned to estimate project post to P&l
        if ((projType == ProjType::FixedPrice || projType == ProjType::Investment)
            && (projTable.fixedPriceEligibleForOnlyPLPosting()))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPLPostingRequiredForTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether PnL posting is needed for the given project ID and transaction type.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_transType">Transaction type being posted.</param>
    /// <returns>true if PnL posting should be done; otherwise, false.</returns>
    public static boolean isPLPostingRequiredForTransType(ProjId _projId, ProjTransType _transType)
    {
        boolean ret = false;
        boolean multipleContractLineFeature = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

        if (!multipleContractLineFeature)
        {
            ret = ProjTable::isPLPostingRequired(_projId);
        }
        else
        {
            // Eliminated Fixed Price and Investment projects post to P&l
            // Fixed Price and Investement projects not assigned to estimate project post to P&l
            ProjTable projTable = ProjTable::find(_projId);
            if (_transType == ProjTransType::None)
            {
                throw error(strFmt("@SYS22828",funcName()));
            }

            boolean hasFpContractLine = ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(projTable.ProjId, projTable.ProjInvoiceProjId, _transType, ProjContractBillingMethod::FixedPrice);

            // Check if project/wip project is eliminated
            if (hasFpContractLine && projTable.fixedPriceEligibleForOnlyPLPosting())
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>like</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether there are any projects with project IDs that resemble the project ID that is
    ///    passed in as a parameter.
    /// </summary>
    /// <param name="_projId">
    ///    The project ID to base the query on.
    /// </param>
    /// <param name="_projIdOrig">
    ///    The original project ID of the project that should not be included in the result; optional.
    /// </param>
    /// <returns>
    ///    true if the projects exist; otherwise, false.
    /// </returns>
    public static boolean like(ProjId _projId, ProjId _projIdOrig = '')
    {
        if (_projId)
        {
            if (_projIdOrig)
            {
                return (select projTable
                        where projTable.ProjId like _projId     &&
                              projTable.ProjId !=   _projIdOrig &&
                              !projTable.ParentId).RecId != 0;
            }

            return (select projTable where projTable.ProjId like _projId).RecId != 0;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs a lookup on the string control that is passed in as a parameter.
    /// </summary>
    /// <param name="_ctrl">
    ///    The string control on which to perform the lookup.
    /// </param>
    /// <param name="_buffer">
    ///    The data to pass to the lookup form.
    /// </param>
    /// <remarks>
    ///    The <c>ProjtableLookup</c> form is used to display the lookup list for this string control.
    /// </remarks>
    public static void lookupProjId(FormControl _ctrl, Common _buffer, NoYes returnTemplate = NoYes::No)
    {
        SegmentedEntryControl segmentedEntryControl;
        FormStringControl   formStringControl;
        Args                args = new Args();
        FormRun             formRun;

        args.name(formStr(ProjTableLookup));
        args.caller(_ctrl);
        args.record(_buffer);
        args.parmEnum(returnTemplate);

        formRun = classfactory.formRunClass(args);
        formRun.init();

        if (_ctrl is FormStringControl)
        {
            formStringControl = _ctrl as FormStringControl;
            formStringControl.performFormLookup(formRun);
        }
        else if (_ctrl is SegmentedEntryControl)
        {
            segmentedEntryControl = _ctrl as SegmentedEntryControl;
            segmentedEntryControl.performFormLookup(formRun);
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjId_SA</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a lookup of projects for the string control that is passed in as a parameter.
    /// </summary>
    /// <param name="_formControl">
    /// The string control on which to perform the lookup.
    /// </param>
    /// <remarks>
    /// The projects in the returned list are fixed price or investment projects and not completed status.
    /// The list displays the project ID and name fields.
    /// </remarks>
    public static void lookupProjId_SA(FormControl _formControl)
    {
        Query query = ProjTable::lookupProjId_SAQuery();
        SysTableLookup sysTableLookup = ProjTable::addFieldsToProjId_SALookup(_formControl);

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjId_SAQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs a query to create a lookup for <c>lookupProjId_SA</c> control.
    /// </summary>
    /// <returns>
    ///     An instance of a query to construct the lookup.
    /// </returns>
    /// <remarks>
    ///      Extend this method to modify criteria on Project lookups.
    /// </remarks>
    protected static Query lookupProjId_SAQuery()
    {
        Query query = new Query();
        QueryBuildRange queryBuildRange;

        QueryBuildDataSource queryBuildDataSource = query.addDataSource(tableNum(ProjTable));
        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(ProjTable, Type));
            queryBuildRange.value(queryValue(ProjType::TimeMaterial));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(ProjTable, Type));
            queryBuildRange.value(queryValue(ProjType::FixedPrice));
        }
        queryBuildRange = queryBuildDataSource.addRange(fieldNum(ProjTable, Status));
        queryBuildRange.value(SysQuery::valueNot(ProjStatus::Completed));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldsToProjId_SALookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Defines the default fields for Project lookups.
    /// </summary>
    /// <param name = "_formControl">
    ///     The control on which to perform the lookup.
    /// </param>
    /// <returns>
    ///     An instance of <c>SysTableLookup</c> which holds the lookup fields.
    /// </returns>
    /// <remarks>
    ///     Extend this method to add or remove fields from Project lookups.
    /// </remarks>
    protected static SysTableLookup addFieldsToProjId_SALookup(FormControl _formControl)
    {
        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(ProjTable), _formControl);

        sysTableLookup.addLookupfield(fieldNum(ProjTable, ProjId), true);
        sysTableLookup.addLookupfield(fieldNum(ProjTable, Name));

        return sysTableLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjIdByForecastRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a lookup for the <c>ProjId</c> field.
    /// </summary>
    /// <param name="_formControl">
    /// The control to be configured.
    /// </param>
    public static void lookupProjIdByForecastRule(FormControl _formControl)
    {
        SysTableLookup sysTableLookup  = SysTableLookup::newParameters(tableNum(ProjTable), _formControl);

        sysTableLookup.parmQuery(ProjTable::getProjTableByStatusTypeRuleQuery());

        sysTableLookup.addLookupfield(fieldNum(ProjTable, ProjId));
        sysTableLookup.addLookupfield(fieldNum(ProjTable, Name));
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjIdByProjInvoiceProjId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Project lookup constrained by contract id and project type.
    /// </summary>
    /// <param name="_oLookupCtrl">
    ///     Handle for the lookup control.
    /// </param>
    /// <param name="_sProjInvProjId">
    ///     Contract ID
    /// </param>
    /// <param name="_filterByProjType">
    ///     true if filter by project type is enabled, false other wise.
    /// </param>
    /// <param name="_projType">
    ///     Project Type.
    /// </param>
    /// <param name="_excludeFPProjType">
    ///     Excludes projects of type Fixed Price from the lookup.
    /// </param>
    static void lookupProjIdByProjInvoiceProjId(FormStringControl _oLookupCtrl, ProjInvoiceProjId _sProjInvProjId, boolean _filterByProjType = false, ProjType _projType = ProjType::TimeMaterial, boolean _excludeFPProjType = false)
    {
        Query query = ProjTable::lookupProjIdByProjInvoiceProjIdQuery(_sProjInvProjId, _filterByProjType, _excludeFPProjType, _projType);
        SysTableLookup sysTableLookup = ProjTable::addFieldsToProjIdLookup(_oLookupCtrl);

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjIdByProjInvoiceProjIdQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Construct a query for project lookup.
    /// </summary>
    /// <param name = "_sProjInvProjId">
    ///     Contract ID.
    /// </param>
    /// <param name = "_filterByProjType">
    ///     true if filter by project type is enabled, false other wise.
    /// </param>
    /// <param name = "_excludeFPProjType">
    ///     Excludes projects of type Fixed Price from the lookup.
    /// </param>
    /// <param name = "_projType">
    ///     Project Type.
    /// </param>
    /// <returns>
    ///     An instance of a query to construct project lookup.
    /// </returns>
    /// <remarks>
    ///      Extend this method to modify criteria on Project lookups.
    /// </remarks>
    protected static Query lookupProjIdByProjInvoiceProjIdQuery(ProjInvoiceProjId _sProjInvProjId, boolean _filterByProjType, boolean _excludeFPProjType, ProjType _projType)
    {
        Query query = new Query();
        QueryBuildRange queryBuildRange;
        QueryBuildRange projTypeRange;

        QueryBuildDataSource oQueryBuildDataSource = query.addDataSource(tableNum(ProjTable));

        queryBuildRange = oQueryBuildDataSource.addRange(fieldNum(ProjTable, ProjInvoiceProjId));
        queryBuildRange.value(queryValue(_sProjInvProjId));

        if (_excludeFPProjType)
        {
            projTypeRange = oQueryBuildDataSource.addRange(fieldNum(ProjTable, Type));
            projTypeRange.value(strFmt('(Type != %1)', any2int(ProjType::FixedPrice)));
        }

        if (_filterByProjType)
        {
            projTypeRange = oQueryBuildDataSource.addRange(fieldNum(ProjTable, Type));
            projTypeRange.value(queryValue(enum2str(_projType)));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldsToProjIdLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Provides an instance of <c>SysTableLookup</c> class with relevent lookup fields.
    /// </summary>
    /// <param name = "_oLookupCtrl">
    ///		Handle for the lookup control.
    /// </param>
    /// <returns>
    ///		An instance of <c>SysTableLookup</c> which holding the lookup fields.
    /// </returns>
    /// <remarks>
    ///     Extend this method to add or remove fields from Project lookups.
    /// </remarks>
    protected static SysTableLookup addFieldsToProjIdLookup(FormStringControl _oLookupCtrl)
    {
        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(ProjTable), _oLookupCtrl);

        sysTableLookup.addLookupfield(fieldNum(ProjTable, ProjId));
        sysTableLookup.addLookupfield(fieldNum(ProjTable, Name));

        return sysTableLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjIdByContractOrCustomer</Name>
				<Source><![CDATA[
    [SysObsolete('Use ProjTableLookup::createLookup() instead.', false, 31\05\2017)]
    public static void lookupProjIdByContractOrCustomer(FormStringControl _lookupCtrl, ProjInvoiceProjId _projInvoiceProjId, CustAccount  _custAccount)
    {
        ProjOpsManagementLogger logger = ProjOpsManagementLogger::createLogger(tableStr(ProjTable));
        using (var activityContext = logger.projOpsManagementActivity().projTableLookupContext())
        {
            ProjTableLookup::createLookup(_lookupCtrl, ProjTableLookup::buildQueryWithRanges(conNull(), _projInvoiceProjId, _custAccount)).performFormLookup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjIdCustAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a query for the <c>ProjTable</c> that only returns business relation accounts of the
    ///    prospect type.
    /// </summary>
    /// <param name="_custAccount">
    ///    The string on which to perform the lookup.
    /// </param>
    /// <returns>
    ///    A query for a project that is linked with the specified customer.
    /// </returns>
    static Query lookupProjIdCustAccount(CustAccount  _custAccount)
    {
        QueryBuildDataSource            queryBuildDataSource;
        Query                           query = new Query();
        QueryBuildRange                 queryBuildRange;

        queryBuildDataSource = query.addDataSource(tableNum(ProjTable));
        queryBuildDataSource.addSortField(fieldNum(ProjTable, ProjId));

        queryBuildRange = queryBuildDataSource.addRange(fieldNum(ProjTable, CustAccount));
        queryBuildRange.value(SysQuery::value(_custAccount));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjIdHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides a lookup of projects.
    /// </summary>
    /// <param name = "_formControl">
    ///     The control to be configured.
    /// </param>
    /// <param name = "_filterStr">
    ///     The filter string.
    /// </param>
    /// <param name = "_projId">
    ///     The project ID.
    /// </param>
    /// <param name = "_isProjBudgetLineTypeRevenue">
    ///     true if the project budget line type is revenue; false otherwise.
    /// </param>
    public static void lookupProjIdHierarchy(FormControl _formControl, str _filterStr, ProjId _projId, boolean _isProjBudgetLineTypeRevenue = false)
    {
        Query q = ProjTable::lookupProjIdHierarchyQuery(_projId, _isProjBudgetLineTypeRevenue);
        SysTableLookup sysTableLookup = ProjTable::addFieldsToProjIdHierarchyLookup(_formControl);

        sysTableLookup.parmQuery(q);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjIdHierarchyQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Construct a query for project ID Hierarchy lookup.
    /// </summary>
    /// <param name = "_projID">
    ///     Project ID.
    /// </param>
    /// <param name = "_isProjBudgetLineTypeRevenue">
    ///     true if the project budget line type is revenue, false other wise.
    /// </param>
    /// <returns>
    ///     An instance of a query to construct project ID hierarchy lookup.
    /// </returns>
    /// <remarks>
    ///      Extend this method to modify criteria on Project lookups.
    /// </remarks>
    protected static Query lookupProjIdHierarchyQuery(ProjId _projID, boolean _isProjBudgetLineTypeRevenue)
    {
        Query q = new Query();

        #DEFINE.Star('*')

        QueryBuildDataSource qbr = q.addDataSource(tableNum(ProjTable));

        qbr.addRange(fieldNum(ProjTable, ProjId)).value(queryValue(_projId) + #Star);

        //For budget of revenue type, project Id lookup should show only project of Type "TimeMaterial" and "FixedPrice".
        if (_isProjBudgetLineTypeRevenue && !ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            qbr.addRange(fieldNum(ProjTable, Type)).value(strFmt('((Type == %1) || (Type == %2))',
                enum2int(ProjType::TimeMaterial), enum2int(ProjType::FixedPrice)));
        }

        return q;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldsToProjIdHierarchyLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Defines the default fields for Project lookups.
    /// </summary>
    /// <param name = "_formControl">
    ///     The control on which to perform the lookup.
    /// </param>
    /// <returns>
    ///     An instance of <c>SysTableLookup</c> which holding the lookup fields.
    /// </returns>
    /// <remarks>
    ///     Extend this method to add or remove fields from Project lookups.
    /// </remarks>
    protected static SysTableLookup addFieldsToProjIdHierarchyLookup(FormControl _formControl)
    {
        SysTableLookup sysTableLookup  = SysTableLookup::newParameters(tableNum(ProjTable), _formControl);
        sysTableLookup.addLookupfield(fieldNum(ProjTable, ProjId), true);
        sysTableLookup.addLookupfield(fieldNum(ProjTable, Name), false);

        return sysTableLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjIdTypeActivity</Name>
				<Source><![CDATA[
    // Description    :< //for show projid for task filtered on PSAProjTask::Project >
    // Parameters     :< Description of parameters >
    // Return value   :< Description of return value >

    public static void lookupProjIdTypeActivity(FormStringControl _ctrl)
    {
        SysTableLookup          sysTableLookup;
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            sysTableLookup                      = SysTableLookup::newParameters(tableNum(ProjTable), _ctrl);
            query                               = new Query();
            queryBuildDataSource                = query.addDataSource(tableNum(ProjTable));

            sysTableLookup.addLookupfield(fieldNum(ProjTable, ProjId), true);
            sysTableLookup.addLookupfield(fieldNum(ProjTable, Name));

            sysTableLookup.parmQuery(query);
            sysTableLookup.performFormLookup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjWIP</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides a lookup of projects for the string control that is passed in as a parameter.
    /// </summary>
    /// <param name="ctrl">
    ///    The string control on which to perform the lookup.
    /// </param>
    /// <remarks>
    ///    The projects in the returned list are fixed price or investment projects. The list displays the project ID and name fields.
    /// </remarks>
    public static void lookupProjWIP(FormStringControl ctrl)
    {
        SysTableLookup sysTableLookup = ProjTable::addFieldsToProjWIPLookup(ctrl);
        Query query = ProjTable::lookupProjWIPQuery();

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjWIPQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Construct a query for <c>lookupProjWIP</c> lookup.
    /// </summary>
    /// <returns>
    ///     An instance of query to construct <c>lookupProjWIP</c> lookup.
    /// </returns>
    /// <remarks>
    ///      Extend this method to modify criteria on Project lookups.
    /// </remarks>
    protected static Query lookupProjWIPQuery()
    {
        Query query = new Query();

        QueryBuildDataSource queryBuildDataSource = query.addDataSource(tableNum(ProjTable));
        queryBuildDataSource.addRange(fieldNum(ProjTable, wipProject)).value(queryValue(''));

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            queryBuildDataSource.addRange(fieldNum(ProjTable, Type)).value(queryValue(ProjType::FixedPrice));
            queryBuildDataSource.addRange(fieldNum(ProjTable, Type)).value(queryValue(ProjType::Investment));

            QueryBuildDataSource qbdsProjGroup = queryBuildDataSource.addDataSource(tableNum(ProjGroup));
            qbdsProjGroup.relations(true);
            qbdsProjGroup.addRange(fieldNum(ProjGroup, CompletePrincip)).value(SysQuery::valueNot(ProjCompletePrincip::NoWIP));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldsToProjWIPLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Defines the default fields for Project lookups.
    /// </summary>
    /// <param name = "_ctrl">
    ///     The string control on which to perform the lookup.
    /// </param>
    /// <returns>
    ///     An instance of <c>SysTableLookup</c> which holds the fields.
    /// </returns>
    /// <remarks>
    ///     Extend this method to add or remove fields from Project lookups.
    /// </remarks>
    protected static SysTableLookup addFieldsToProjWIPLookup(FormStringControl _ctrl)
    {
        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(ProjTable), _ctrl);

        sysTableLookup.addLookupfield(fieldNum(ProjTable, ProjId));
        sysTableLookup.addLookupfield(fieldNum(ProjTable, Name));

        return sysTableLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjWIPProj</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides a lookup of projects for the string control that is passed in as a parameter.
    /// </summary>
    /// <param name="ctrl">
    ///    The string control on which to perform the lookup.
    /// </param>
    /// <param name="_projWipId">
    ///    The ID for the WIP project.
    /// </param>
    /// <param name="_restrictExternalProjects">
    ///    Optional parameter. True if external projects shouldn't be returned; false otherwise.
    /// </param>
    /// <remarks>
    ///    The list of projects returned are WIP projects that are associated with the WIP project ID that is passed in as a parameter. The list displays the project ID, name and type fields.
    /// </remarks>
    public static void lookupProjWIPProj(FormStringControl ctrl, ProjWipId _projWipId, boolean _restrictExternalProjects = false)
    {
        SysTableLookup       sysTableLookup = SysTableLookup::newParameters(tableNum(ProjTable), ctrl);
        Query                query = new Query();
        QueryBuildDataSource queryBuildDataSource;

        sysTableLookup.addLookupfield(fieldNum(ProjTable, ProjId));
        sysTableLookup.addLookupfield(fieldNum(ProjTable, Name));
        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            sysTableLookup.addLookupfield(fieldNum(ProjTable, Type));
        }

        queryBuildDataSource = query.addDataSource(tableNum(ProjTable));
        queryBuildDataSource.addRange(fieldNum(ProjTable, wipProject)).value(_projWipId);

        if (_restrictExternalProjects)
        {
            queryBuildDataSource.addRange(fieldNum(ProjTable, ProjDataSource)).value(SysQuery::value(0));
        }

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Provides a look for template projects for the string control that is passed in as a parameter.
    /// </summary>
    /// <param name = "ctrl">
    ///    The string control on which to perform the lookup.
    /// </param>
    /// <param name = "_hideTimeProjects">
    ///     Optional parameter. True if time project shouldn't include; false otherwise.
    /// </param>
    public static void lookupTemplate(FormStringControl ctrl, boolean _hideTimeProjects = false)
    {
        SysTableLookup sysTableLookup = ProjTable::addFieldsToTemplateLookup(ctrl);
        Query query = ProjTable::lookupTemplateQuery(_hideTimeProjects);

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupTemplateQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Construct a query for template lookup.
    /// </summary>
    /// <param name = "_hideTimeProjects">
    ///     Hide time project.
    /// </param>
    /// <returns>
    ///     An instance of query to construct template lookup.
    /// </returns>
    /// <remarks>
    ///      Extend this method to modify criteria on Project lookups.
    /// </remarks>
    protected static Query lookupTemplateQuery(boolean _hideTimeProjects)
    {
        Query query = new Query();
        QueryBuildDataSource queryBuildDataSource = query.addDataSource(tableNum(ProjTable));
        QueryBuildRange queryBuildRange = queryBuildDataSource.addRange(fieldNum(ProjTable, Template));

        if (_hideTimeProjects)
        {
            queryBuildDataSource.addRange(fieldNum(ProjTable, Type)).value(SysQuery::valueNot(ProjType::Time));
        }

        queryBuildRange.value(queryValue(NoYes::Yes));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldsToTemplateLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Defines the default fields for Project lookups.
    /// </summary>
    /// <param name = "_ctrl">
    ///     The string control on which to perform the lookup.
    /// </param>
    /// <returns>
    ///     An instance of <c>SysTableLookup</c> which holds the lookup fields.
    /// </returns>
    /// <remarks>
    ///     Extend this method to add or remove fields from Project lookups.
    /// </remarks>
    protected static SysTableLookup addFieldsToTemplateLookup(FormStringControl _ctrl)
    {
        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(ProjTable), _ctrl);

        sysTableLookup.addLookupfield(fieldNum(ProjTable, ProjId));
        sysTableLookup.addLookupfield(fieldNum(ProjTable, Name));

        return sysTableLookup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupValidParentProj</Name>
				<Source><![CDATA[
    /// <summary>
    /// Project lookup, include only top level projects.
    /// </summary>
    /// <param name = "_ctrl">The <c>FormStringControl</c> that calls this lookup.</param>
    public static void lookupValidParentProj(FormStringControl _ctrl)
    {
        ProjOpsManagementLogger logger = ProjOpsManagementLogger::createLogger(tableStr(ProjTable));
        using (var activityContext = logger.projOpsManagementActivity().projTableLookupContext())
        {
            Query query = ProjTableLookup::buildQueryWithRanges(conNull());

            query.dataSourceNo(1).addRange(fieldnum(ProjProjectLookup, Format)).value(SysQuery::valueNotEmptyString());

            SysTableLookup sysTableLookup = ProjTableLookup::createLookup(_ctrl, query);

            sysTableLookup.performFormLookup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjIdRestrictingExternal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs a lookup on the string control that is passed in as a parameter.
    /// </summary>
    /// <param name="_ctrl">
    ///    The string control on which to perform the lookup.
    /// </param>
    /// <param name="_buffer">
    ///    The data to pass to the lookup form.
    /// </param>
    /// <param name="returnTemplate">
    ///    Optional parameter. Yes to return template; No otherwise
    /// </param>
    /// <param name="_restrictExternalProjects">
    ///    Optional parameter. True if Projects should be filtered out that are Externally defined; false otherwise
    /// </param>
    /// <remarks>
    ///    The <c>ProjtableLookup</c> form is used to display the lookup list for this string control.
    /// </remarks>
    public static void lookupProjIdRestrictingExternal(FormControl _ctrl, Common _buffer, NoYes _returnTemplate = NoYes::No, boolean _restrictExternalProjects = false)
    {
        FormStringControl   formStringControl;
        Args                args = new Args();
        FormRun             formRun;

        args.name(formStr(ProjTableLookup));
        args.caller(_ctrl);
        args.record(_buffer);
        args.parmEnum(_returnTemplate);

        formRun = classfactory.formRunClass(args);
        formRun.init();

        if (_restrictExternalProjects)
        {
            FormDataSource formDS = formRun.dataSource(1);
            QueryBuildDataSource qbds1 = formDS.queryBuildDataSource();
            QueryBuildDataSource qbds2 = qbds1.addDataSource(tableNum(ProjTable));
            qbds2.addLink(fieldNum(ProjProjectLookup, ProjId), fieldNum(ProjTable, ProjId));
            qbds2.joinMode(JoinMode::InnerJoin);
            qbds2.addRange(fieldNum(ProjTable, ProjDataSource)).value(SysQuery::value(0));
        }

        formStringControl = _ctrl as FormStringControl;
        formStringControl.performFormLookup(formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modelId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the forecast model ID for the project that is passed in as a parameter.
    /// </summary>
    /// <param name="projId">
    ///    The ID of the forecast model.
    /// </param>
    /// <returns>
    ///    The ID of the forecast model.
    /// </returns>
    public static ForecastModelId modelId(ProjId projId)
    {
        ForecastModelId         modelId;
        ProjControlPeriodTable  projControlPeriodTable;
        ProjPeriodId            periodId;

        periodId = ProjWIPTable::find(ProjTable::find(projId).wipProject).PeriodId;

        if (periodId)
        {
            select projControlPeriodTable
                 where projControlPeriodTable.ProjId          == ProjTable::find(projId).wipProject   &&
                       projControlPeriodTable.PeriodStatus    == ProjControlPeriodStatus::Created;

            if (projControlPeriodTable)
            {
                modelId = ProjPeriodLine::find(periodId, projControlPeriodTable.PeriodFrom).ModelId;
            }
            else
            {
                modelId = ProjPeriodLine::find(periodId, ProjWIPTable::nextControlPeriodFrom(projId)).ModelId;
            }
        }

        if (!modelId)
        {
            modelId = ProjParameters::find().ModelId;
        }

        return modelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>name</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the name of the project that is passed in as a parameter.
    /// </summary>
    /// <param name="_projId">
    ///    The ID of the project.
    /// </param>
    /// <returns>
    ///    The name of the project.
    /// </returns>
    public static Name name(ProjId _projId)
    {
        ProjName    projName = '';

        if ( _projId )
        {
            projName = (select Name from projTable where projTable.ProjId == _projId).Name;
        }

        return projName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSequenceCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the number sequence code used for project ID.
    /// </summary>
    /// <returns>
    ///    The number sequence code used for project ID.
    /// </returns>
    static NumberSequenceCode numberSequenceCode()
    {
        return NumberSequenceTable::find(ProjParameters::numRefProjId().NumberSequenceId).NumberSequence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numRemTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the mask found in a string that is passed in as a parameter.
    /// </summary>
    /// <param name="_num">
    ///    The string to look in for the mask.
    /// </param>
    /// <param name="mask">
    ///    The mask string to look for.
    /// </param>
    /// <returns>
    ///    The integer value of the mask found.
    /// </returns>
    public static Integer numRemTemplate(Num _num, Num mask)
    {
        #define.SymbolNumerals('#')
        #define.SymbolLiterals('&')

        Integer         x           = 1;
        Num             newTxt      = '';
        Num             tmpTxt      = mask;
        Num             tmpNum      = _num;
        int             ascciPos    = 65;

        if (!tmpTxt)
        {
            return str2int(tmpNum);
        }

        if (strLen(tmpNum) != strLen(tmpTxt))
        {
            throw error(strFmt("@SYS25062",tmpNum, tmpTxt));
        }

        while (x)
        {
            // Check if the format contains '&'.
            if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && strFind(mask, #SymbolLiterals, 999, -999))
            {
                x = strFind(tmpTxt, #SymbolLiterals, 999, -999);
            }
            else
            {
                x = strFind(tmpTxt, #SymbolNumerals, 999, -999);
            }
            if (!x)
            {
                //  Return the value for alphabet format.
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && strFind(mask, #SymbolLiterals, 999, -999))
                {
                    return ((char2num(newTxt, strLen(newTxt))-ascciPos)+1);
                }
                else
                {
                    return str2int(newTxt);
                }
            }

            newTxt = subStr(tmpNum, x, 1) + newTxt;
            tmpTxt = strDel(tmpTxt, x, 1);
        }

        return str2int(newTxt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceGroup</Name>
				<Source><![CDATA[
    static ProjPriceGroupID priceGroup(ProjId _projId)
    {
        ProjPriceGroupID  projPriceGroupID = '';

        if ( _projId )
        {
            projPriceGroupID = (select firstonly ProjPriceGroup from projTable
                    where projTable.ProjId == _projId).ProjPriceGroup;
        }

        return projPriceGroupID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projectTeamRoleExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a project team role exists for the project passed in as a parameter.
    /// </summary>
    /// <param name="projId">
    ///    The ID of the project.
    /// </param>
    /// <returns>
    ///    true if a project team role exists; otherwise, false.
    /// </returns>
    public static boolean projectTeamRoleExists(ProjId projId)
    {
        return PSAProjSchedRole::findFirst(projId).RecId && projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projIdLastSon</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the last sub project created for the parent project that is passed in as a parameter.
    /// </summary>
    /// <param name="_projId">
    ///    The ID of the parent project.
    /// </param>
    /// <returns>
    ///    The ID of the last sub project created.
    /// </returns>
    public static ProjId projIdLastSon(ProjId _projId)
    {
        ProjId  projId = '';

        if ( _projId )
        {
            projId = (select reverse ProjId from projTable order by ProjId where projTable.ParentId == _projId).ProjId;
        }

        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projInvoiceStatic</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the invoice project associated with the project that is passed in as a parameter.
    /// </summary>
    /// <param name="_projId">
    ///    The ID of the project.
    /// </param>
    /// <returns>
    ///    The invoice project record.
    /// </returns>
    public static ProjInvoiceTable projInvoiceStatic(ProjId _projId)
    {
        return ProjInvoiceTable::find(ProjTable::find(_projId).ProjInvoiceProjId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>rangeProjId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a comma-delimited string of project IDs.
    /// </summary>
    /// <param name="_fieldId">
    /// The ID of the field in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_FieldValue">
    /// The value of the field that the projects that are retrieved must contain.
    /// </param>
    /// <returns>
    /// A string of comma-delimited project IDs.
    /// </returns>
    public static str rangeProjId(FieldId _fieldId, anytype _FieldValue)
    {
        ProjTable   projTable;
        str         tmpQueryStr;
        DictField   dictField = new DictField(tableNum(ProjTable), _fieldId);

        if (dictField)
        {
            while select ProjId from projTable order by ProjId where projTable.(_fieldId) == _FieldValue
            {
                tmpQueryStr += projTable.ProjId + ',';
            }
        }

        return tmpQueryStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldPwpThresholdPercent</Name>
				<Source><![CDATA[
    public static boolean setFieldPwpThresholdPercent(ProjTable  _projTable)
    {
        boolean     ret;

        if (!isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            return ret;
        }

        if ((_projTable.Type == ProjType::TimeMaterial || ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
             && (ProjFundingSource::numberOfFundingSourcesByFundingType(_projTable.ProjInvoiceProjId, ProjFundingType::Customer) > 0))
        {
            if (PSAContractLineItems::hasBillingRules(_projTable.ProjInvoiceProjId))
            {
                if (_projTable.checkTAndMTypeBillingRule())
                {
                    ret = true;
                }
                else
                {
                    ret = false;
                }
            }
            else
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a label string indicating that the project does not exist.
    /// </summary>
    /// <returns>
    ///    A label string.
    /// </returns>
    static str 80 txtNotExist()
    {
        return "@SYS11217";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStartDateForItemReq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get start date for item requirement.
    /// </summary>
    /// <returns>
    /// Projected start date if it's set, otherwise creation date.
    /// </returns>
    public Date getStartDateForItemReq()
    {
        if (this.ProjectedStartDate)
        {
            return this.ProjectedStartDate;
        }

        return this.Created;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupSelectedProjId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a lookup on a project.
    /// </summary>
    /// <param name="_formControl">
    /// The form control.
    /// </param>
    /// <param name="_filterStr">
    /// The filter string.
    /// </param>
    /// <param name="_projId">
    /// The id of the project to lookup.
    /// </param>
    /// <remarks>
    /// The only project in the lookup will the project specified in the parameter.
    /// </remarks>
    public static void lookupSelectedProjId(FormControl _formControl, str _filterStr, ProjId _projId)
    {
        Query                   q = new Query();
        QueryBuildDataSource    qbr1;

        SysTableLookup  sysTableLookup;

        qbr1 = q.addDataSource(tableNum(ProjTable));

        qbr1.addRange(fieldNum(ProjTable, ProjId)).value(queryValue(_projId));

        sysTableLookup  = SysTableLookup::newParameters(tableNum(ProjTable), _formControl);
        sysTableLookup.addLookupfield(fieldNum(ProjTable, ProjId), true);
        sysTableLookup.addLookupfield(fieldNum(ProjTable, Name), false);

        sysTableLookup.parmQuery(q);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcEstimateTotalCostSalesPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// calculate total sales and cost price of the project
    /// </summary>
    /// <param name = "_projId">The Id of the project.</param>
    public static void calcEstimateTotalCostSalesPrice(ProjId _projId)
    {
        HierarchyLinkTable   hierarchyLinkTable;
        HierarchyTreeTable   hierarchyTreeTable, localhierarchyTreeTable;
        SmmActivities        smmActivities;
        PSAActivityEstimates localPSAActivityEstimates;
        HierarchyPath        descendantsRangeValue;
        ProjTable            projTable;
        SysGlobalCache       globalCache = ClassFactory.globalCache();
        #Characters

        select RecId from projTable where projTable.ProjId == _projId;

        hierarchyLinkTable = HierarchyLinkTable::findRefTableRecId(tablenum(ProjTable), projTable.RecId);

        select firstonly Path, ElementNumber from hierarchyTreeTable where hierarchyTreeTable.HierarchyId == hierarchyLinkTable.HierarchyId
                    && hierarchyTreeTable.ParentElementNumber == "";

        if (hierarchyTreeTable)
        {
            descendantsRangeValue = hierarchyTreeTable.Path + hierarchyTreeTable.ElementNumber + #sharp + "*";

            // Include sum for the selected summary task's descendents.
            select sum(TotalSalesPrice), sum(TotalCostPrice) from localPSAActivityEstimates
            join RecId from smmActivities
                where smmActivities.ActivityNumber == localPSAActivityEstimates.ActivityNumber
                join RecId from localhierarchyTreeTable
                    where localhierarchyTreeTable.RefRecId == smmActivities.RecId
                          && localhierarchyTreeTable.Path like descendantsRangeValue;

            globalCache.set("ProjTable_calcEstimateTotalCostSalesPrice" , _projId + "_TotalCostPrice", localPSAActivityEstimates.TotalCostPrice);
            globalCache.set("ProjTable_calcEstimateTotalCostSalesPrice" , _projId + "_TotalSalesPrice", localPSAActivityEstimates.TotalSalesPrice);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBudgetCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// calculate budget cost for the project
    /// </summary>
    /// <param name = "_projId">The Id of the project</param>
    public static void calcBudgetCost(ProjId _projId)
    {
        ProjBudget           projBudget;
        ProjBudgetLine       projBudgetLine;
        SysGlobalCache       globalCache    = ClassFactory.globalCache();
        #define.Star("*");

        select sum(OriginalBudget),sum(CommittedRevisions),sum(UncommittedRevisions), sum(TotalBudget)
                        from projBudgetLine join projBudget
                        where projBudgetLine.ProjBudget == projBudget.RecId
                        &&    projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost
                        &&    projBudgetLine.ProjId like _projId + #Star;

        globalCache.set("ProjTable_calcBudgetCost" , _projId + "_OriginalBudgetCost", projBudgetLine.OriginalBudget);
        globalCache.set("ProjTable_calcBudgetCost" , _projId + "_CommittedRevisions", projBudgetLine.CommittedRevisions);
        globalCache.set("ProjTable_calcBudgetCost" , _projId + "_UncommittedRevisions", projBudgetLine.UncommittedRevisions);
        globalCache.set("ProjTable_calcBudgetCost" , _projId + "_TotalBudget", projBudgetLine.TotalBudget);
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnEstimateTotalCostInStr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Display the total cost of the project in a string
    /// </summary>
    /// <param name = "_projTable"></param>
    /// <returns> a string of estimate total cost</returns>
    display str returnEstimateTotalCostInStr(ProjTable _projTable)
    {
        str totalCost;

        totalCost = strFmt("@Proj:TotalEstimatedCost", num2str(this.returnEstimateTotalCost(_projTable) , 15, 2, 2, 1));
        return totalCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnProjDurationInStr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Display the duration of the project in a string
    /// </summary>
    /// <param name = "_projTable"></param>
    /// <returns> a string of total duration of the Project </returns>
    display str returnProjDurationInStr(ProjTable _projTable)
    {
        str projDuration;

        projDuration = strFmt("@Proj:DurationInDays", any2str(_projTable.PSASchedDuration));
        return projDuration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnEstimateTotalCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// display total cost of the project
    /// </summary>
    display Total returnEstimateTotalCost(ProjTable _projTable)
    {
        SysGlobalCache       globalCache    = ClassFactory.globalCache();
        Total                totalCostPrice = -1;

        totalCostPrice = globalCache.get("ProjTable_calcEstimateTotalCostSalesPrice", _projTable.ProjId + "_TotalCostPrice" , totalCostPrice);

        if (totalCostPrice < 0)
        {
            ProjTable::calcEstimateTotalCostSalesPrice(_projTable.ProjId);
            totalCostPrice = globalCache.get("ProjTable_calcEstimateTotalCostSalesPrice", _projTable.ProjId + "_TotalCostPrice" , totalCostPrice);
        }

        if (totalCostPrice == -1)
        {
            totalCostPrice = 0;
        }
        return totalCostPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnEstimateTotalSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// display total sales of the project
    /// </summary>
    display Total returnEstimateTotalSales(ProjTable _projTable)
    {
        SysGlobalCache       globalCache    = ClassFactory.globalCache();
        Total                totalSalesPrice = -1;

        totalSalesPrice = globalCache.get("ProjTable_calcEstimateTotalCostSalesPrice", _projTable.ProjId + "_TotalSalesPrice" , totalSalesPrice);

        if (totalSalesPrice < 0)
        {
            ProjTable::calcEstimateTotalCostSalesPrice(_projTable.ProjId);
            totalSalesPrice = globalCache.get("ProjTable_calcEstimateTotalCostSalesPrice", _projTable.ProjId + "_TotalSalesPrice" , totalSalesPrice);
        }

        if (totalSalesPrice == -1)
        {
            totalSalesPrice = 0;
        }
        return totalSalesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnOriginalBudgetCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// display original budget cost of the project
    /// </summary>
    /// <param name = "_projTable">The project for which to compute original budget cost.</param>
    /// <returns></returns>
    public display Total returnOriginalBudgetCost(ProjTable _projTable)
    {
        SysGlobalCache       globalCache    = ClassFactory.globalCache();
        Total                originalBudgetCost = -1;

        if (!_projTable.UseBudgeting)
        {
            return 0;
        }

        originalBudgetCost = globalCache.get("ProjTable_calcBudgetCost", _projTable.ProjId + "_OriginalBudgetCost" , originalBudgetCost);

        if (originalBudgetCost < 0)
        {
            ProjTable::calcBudgetCost(_projTable.ProjId);
            originalBudgetCost = globalCache.get("ProjTable_calcBudgetCost", _projTable.ProjId + "_OriginalBudgetCost" , originalBudgetCost);
        }

        return originalBudgetCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// static constructor that constructs the ProjTable object and inserts it DB.
    /// </summary>
    /// <param name = "_projName">Name of the project</param>
	/// <param name = "_projGroupId">Used to set the project group id. This values is also used to identify the project type from the <c>ProjGroup</c> table</param>
    /// <param name = "_projId">Optional parameter if the number sequence is configured automatically; else the passed value is used to set the projId field on ProjTable</param>
	/// <param name = "_projInvoiceProjId">Project contract id, optional</param>
    /// <returns>The constructed ProjTable object, null if anything goes wrong</returns>
    public static projtable createProject(str _projName, ProjGroupId _projGroupId, ProjId _projId = "", ProjInvoiceProjId _projInvoiceProjId = "")
    {
        ProjTable projTable;
        boolean enableProjMultipleContractLinesForProjectFeature = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

        if (_projName == '' || (!ProjGroup::exist(_projGroupId) && !enableProjMultipleContractLinesForProjectFeature))
        {
            throw Exception::FunctionArgument;
        }

        if (ProjTable::exist(_projId))
        {
            infolog.add(Exception::Warning, strFmt("@Proj:ProjIdExists", _projId));
            throw Exception::DuplicateKeyException;
        }
        projTable.clear();
        projTable.initValue();
        ttsbegin;
        if (ProjTable::isNumberSeqManual()) // ProjId must be manually set
        {
            if (!_projId)
            {
                throw Exception::FunctionArgument;
            }
        }
        else
        {
            _projId =  NumberSeq::newGetNum(ProjParameters::numRefProjId()).num();
        }

        projTable.ProjId = _projId;
        projTable.Name = _projName;
        projTable.ProjGroupId       = _projGroupId;
        projTable.ProjInvoiceProjId = _projInvoiceProjId;

        if (enableProjMultipleContractLinesForProjectFeature)
        {
            projTable.Type = ProjType::None;
            projTable.Status = ProjStatusTypeRule::firstStage(ProjType::None);
        }
        else
        {
            ProjGroup projGroup  = ProjGroup::find(_projGroupId, false);
            projTable.Type = projGroup.projType;
            projTable.Status = ProjStatusTypeRule::firstStage(projGroup.projType);
        }

        projTable.insert();
        ttscommit;

        return projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>DocuRefOnInsert</Name>
				<Source><![CDATA[
    [SubscribesTo(classstr(DocuRefExtension), delegatestr(DocuRefExtension, OnInsert))]
    static void DocuRefOnInsert(DocuRef _docuRef, RecId _interCompanyFromRecId)
    {
        if (_docuRef.RefTableId == tablenum(ProjTable))
        {
            changecompany(_docuRef.RefCompanyId)
            {
                _docuRef.Party              = CustTable::find(ProjTable::findRecId(_docuRef.RefRecId).CustAccount).Party;
                _docuRef.Author             = DirPersonUser::current().PersonParty;
                _docuRef.ActualCompanyId    = curext();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyAdrFromQuotation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes fields for the current project record with values from the sales quotation record.
    /// </summary>
    /// <param name="_salesQuotationTable">
    ///    The buffer of <c>SalesQuotationTable</c>
    /// </param>
    /// <remarks>
    ///    This method sets the delivery address fields for the current project record with the delivery
    ///    address from the quotation.
    /// </remarks>
    public void copyAdrFromQuotation(SalesQuotationTable    _salesQuotationTable)
    {
        LogisticsLocation       logisticsLocation;
        LogisticsPostalAddress  logisticsPostalAddress;

        if (!this.DeliveryLocation && _salesQuotationTable.DeliveryPostalAddress)
        {
            ttsbegin;
            // Create a location record
            logisticsLocation = LogisticsLocation::create(_salesQuotationTable.DeliveryName,true);
            this.DeliveryLocation = logisticsLocation.RecId;

            // Copy Address to location record
            logisticsPostalAddress.data(_salesQuotationTable.deliveryAddress());
            logisticsPostalAddress.Location = logisticsLocation.RecId;
            logisticsPostalAddress.insert();
            ttscommit;

            this.DlvName = _salesQuotationTable.DeliveryName;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>effortAtComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get and display the Effort at complete.
    /// </summary>
    display Hours effortAtComplete()
    {
        ProjProject curProject = ProjProject::construct(this.ProjId);
        return curProject.calculateTotalEffortAtComplete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>plannedEffort</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get and display the Planned Effort.
    /// </summary>
    display Hours plannedEffort()
    {
        ProjProject curProject = ProjProject::construct(this.ProjId);
        return curProject.calculateTotalPlannedEffort();
    }

]]></Source>
			</Method>
			<Method>
				<Name>plannedCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get and display the Planned Cost.
    /// </summary>
    display NonNegativeTotal plannedCost()
    {
        ProjProject curProject = ProjProject::construct(this.ProjId);
        return curProject.calculateTotalPlannedCost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>effortVariance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get and display the Effort Variance.
    /// </summary>
    display Total effortVariance()
    {
        ProjProject curProject = ProjProject::construct(this.ProjId);
        Hours effortEAC = curProject.calculateTotalEffortAtComplete();
        Hours plannedEffort = curProject.calculateTotalPlannedEffort();
        return (effortEAC - plannedEffort);
    }

]]></Source>
			</Method>
			<Method>
				<Name>costVariance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get and display the Cost Variance.
    /// </summary>
    display Total costVariance()
    {
        ProjProject curProject = ProjProject::construct(this.ProjId);
        var totalPlannedCost = curProject.calculateTotalPlannedCost();
        var totalCostAtComplete = curProject.calculateTotalCostAtComplete();
        return (totalCostAtComplete - totalPlannedCost);
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get and display the Progress Percent based on effort.
    /// </summary>
    display NonNegativeTotal progressPercent()
    {
        ProjProject curProject = ProjProject::construct(this.ProjId);
        var effortEAC = curProject.calculateTotalEffortAtComplete();
        var totalActualEffort = curProject.calculateTotalActualEffort();

        return curProject.getScheduleProgressPercent(effortEAC, totalActualEffort);
    }

]]></Source>
			</Method>
			<Method>
				<Name>costConsumed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get and display the percentage of the Cost consumed.
    /// </summary>
    display Total costConsumed()
    {
        int                 budgetPercent;
        ProjProject         curProject = ProjProject::construct(this.ProjId);
        NonNegativeTotal    totalPlannedCost = curProject.calculateTotalPlannedCost();
        NonNegativeTotal    totalActualCost = curProject.calculateTotalActualCost();

        if ( totalPlannedCost == 0)
        {
            return totalPlannedCost;
        }
        else
        {
            budgetPercent = real2int((totalActualCost / totalPlannedCost) * 100);
            return budgetPercent;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByActivityRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the project record using the specified activity record id
    /// </summary>
    /// <param name = "_activity">Activity record identifier</param>
    /// <param name = "_forUpdate">Determines when the project record will be returned for update</param>
    /// <returns>ProjTable record</returns>
    public static ProjTable findByActivityRecId(ActivityRecId _activity, boolean _forUpdate = false)
    {
        ProjTable project;
        HierarchyLinkTable hierarchy;
        HierarchyTreeTable hierarchyTree;

        project.selectForUpdate(_forUpdate);

        select project
            join hierarchy
                where hierarchy.RefRecId == project.RecId
                && hierarchy.RefTableId == project.TableId
            join hierarchyTree
                where hierarchyTree.HierarchyId == hierarchy.HierarchyId
                && hierarchyTree.ParentElementNumber == ''
                && hierarchyTree.RefRecId == _activity;

        return project;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteEstimateProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the estimate projects with respect to the current project.
    /// </summary>
    public void deleteEstimateProject()
    {
        ProjWIPTable    projWIPTable;
        ProjTable       projTable;

        select firstonly RecId from projTable
            where projTable.wipProject  == this.WIPProject  &&
                  projTable.ProjId      != this.ProjId;

        if (!projTable.RecId)
        {
            delete_from projWIPTable
                where projWIPTable.ProjId == this.WIPProject;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjectAgainstContractOrCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// To validate the selected project against contract or customer.
    /// </summary>
    /// <param name = "_projInvoiceProjId">Contract record identifier</param>
    /// <param name = "_custAccount">Customer record identifier</param>
    /// <param name = "_projId">Project record identifier</param>
    /// <returns>Return true if valid project found, otherwise false</returns>
    public static boolean validateProjectAgainstContractOrCustomer(ProjInvoiceProjId _projInvoiceProjId, CustAccount _custAccount, ProjId _projId)
    {
        ProjTable           projTable;
        boolean             ret = true;

        if (_projInvoiceProjId)
        {
            select firstonly RecId from projTable
                where projTable.ProjId == _projId
                && projTable.ProjInvoiceProjId == _projInvoiceProjId;

            if (!projTable.RecId)
            {
                ret = checkFailed(strFmt("@Proj:ValidateProjectAgainstContract", _projId, _projInvoiceProjId));
            }
        }

        if (!_projInvoiceProjId && _custAccount)
        {
            select firstonly RecId from projTable
                where projTable.ProjId == _projId
                && projTable.CustAccount == _custAccount;

            if (!projTable.RecId)
            {
                ret = checkFailed(strFmt("@Proj:ValidateProjectAgainstCustomer", _projId, _custAccount));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the record id for the given project field.
    /// </summary>
    /// <param name = "_projId">Project record identifier</param>
    /// <returns>Project record id.</returns>
    public static RecId getProjRecId(ProjId _projId)
    {
        return (select firstonly RecId from projTable where projTable.ProjId == _projId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyPwpSettingFromParentProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copy the pay when paid settings from parent project to sub project.
    /// </summary>
    public static void copyPwpSettingFromParentProject(ProjTable _subProjTable)
    {
        ProjPWPVendorRetentionSetting       srcProjPWPVendorRetentionSetting;
        ProjPWPVendorRetentionSetting       desProjPWPVendorRetentionSetting;

        while select srcProjPWPVendorRetentionSetting
            where srcProjPWPVendorRetentionSetting.ProjId ==  _subProjTable.ParentId
        {
            desProjPWPVendorRetentionSetting.data(srcProjPWPVendorRetentionSetting);
            desProjPWPVendorRetentionSetting.ProjId = _subProjTable.ProjId;
            desProjPWPVendorRetentionSetting.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>Stage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the project stage for the current project, using the current project
    /// status and current user language.
    /// </summary>
    /// <returns>Project stage.</returns>
    public display ProjStage Stage()
    {
        ProjStageTable projStageTable;

        select firstonly Stage
            from projStageTable
            where projStageTable.Status == this.status
               && projStageTable.Language == currentUserLanguage();

        return projStageTable.Stage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemRequirementsFromCustAccount</Name>
				<Source><![CDATA[
    private void updateItemRequirementsFromCustAccount()
    {
        ttsbegin;
        SalesLine salesLine;
        while select forupdate salesLine
                    where salesLine.ProjId == this.ProjId
                        && salesLine.SalesType == SalesType::ItemReq
                        && (salesLine.SalesStatus == SalesStatus::Backorder || salesLine.SalesStatus == SalesStatus::None)
        {
            salesLine.setAddressFromProjTable(this);
            salesLine.update();
        }

        SalesTable salesTable;
        while select forupdate salesTable
                    where salesTable.ProjId == this.ProjId
                        && salesTable.SalesType == SalesType::ItemReq
                        && (salesTable.SalesStatus == SalesStatus::Backorder || salesTable.SalesStatus == SalesStatus::None)
        {
            salesTable.CustAccount = this.CustAccount;
            salesTable.initFromCustTable();
            salesTable.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllowChangeUp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if AllowChangeUp is marked
    /// </summary>
    public static boolean isAllowChangeUp()
    {
        return NumberSequenceTable::findByNaturalKey(ProjTable::numberSequenceCode()).AllowChangeUp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllowChangeDown</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if AllowChangeDown is marked
    /// </summary>
    public static boolean isAllowChangeDown()
    {
        return NumberSequenceTable::findByNaturalKey(ProjTable::numberSequenceCode()).AllowChangeDown;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projectCanBeDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will check whether project contains any
    /// posted or unposted transaction lines.
    /// </summary>
    /// <returns>
    /// If any posted or unposted transaction lines does not exist against selected project
    /// then this method will return true value; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method will executes when a project is deleted.
    /// </remarks>
    private boolean projectCanBeDeleted()
    {
        boolean canBeDeleted = true;

        ProjPostedTransTable    projPostedTransTable;

        select firstOnly RecId from projPostedTransTable
            where projPostedTransTable.ProjId == this.ProjId;

        if (projPostedTransTable.RecId)
        {
            canBeDeleted = false;
        }

        if (canBeDeleted)
        {
            ProjUnpostedTransView   projUnpostedTransView;

            select firstOnly RecId from projUnpostedTransView
                where projUnpostedTransView.ProjId == this.ProjId &&
                projUnpostedTransView.TransDataAreaId == curExt();

            if (projUnpostedTransView.RecId)
            {
                canBeDeleted = false;
            }
        }

        return canBeDeleted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>DimensionAttributeDelegates_getTablesToAddCopiedValuesTo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of tables and fields to update when copying the values to default dimensions on existing values.
    /// </summary>
    /// <param name = "_tableSet">A <c>Set</c> of <c>DimensionCopyValuesDataContract</c> values.</param>
    [SubscribesTo(classStr(DimensionAttributeDelegates), delegateStr(DimensionAttributeDelegates, getTablesToAddCopiedValuesTo))]
    public static void DimensionAttributeDelegates_getTablesToAddCopiedValuesTo(Set _tableSet)
    {
        DimensionCopyValueDataContract contract = DimensionCopyValueDataContract::construct(tableNum(ProjTable), fieldNum(ProjTable, DefaultDimension));
        contract.addKeyFieldDimensionPair(tableNum(ProjTable), fieldNum(ProjTable, ProjId));
        contract.addKeyFieldDimensionPair(tableNum(CustTable), fieldNum(ProjTable, CustAccount));
        _tableSet.add(contract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFixedPriceProject</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check if the project type is of type fixed price.
    /// </summary>
    /// <param name = "_projId">
    ///     Project Id.
    /// </param>
    /// <returns>
    ///     true if the specified project is of type fixed price; otherwise, false.
    /// </returns>
    public static boolean isFixedPriceProject(ProjId _projId)
    {
        ProjTable projTableLocal = ProjTable::find(_projId);
        return projTableLocal.Type == ProjType::FixedPrice ||
            (projTableLocal.ProjInvoiceProjId &&
             ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
             ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(projTableLocal.ProjId, projTableLocal.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice));
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEstimateCreation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether estimates can be created for this project.
    /// </summary>
    /// <returns>true if estimate creation is allowed; otherwise, false.</returns>
    public boolean allowEstimateCreation()
    {
        boolean isMultiContractLineFeatureEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
        boolean ret = true;
        if (isMultiContractLineFeatureEnabled)
        {
            ProjWIPTable wipProj = this.fixedPriceRevRecProject();
                
            if (!wipProj)
            {
                ret = false;
            }
            else if (wipProj.ProjRevenueProfileId)
            {
                // Return true if there is no revenue profile associated with WIP project.
                ProjRevenueProfile revProf = ProjRevenueProfile::findByRevenueProfileId(wipProj.ProjRevenueProfileId);
                ret = revProf && revProf.CompletePrinciple != ProjCompletePrincip::NoWIP;
            }
        }
        else
        {
            if (this.projGroup().CompletePrincip == ProjCompletePrincip::NoWIP)
            {
                ret = false;
            }

            ret = ret && this.status().ctrlControlSystem();
        }

        return  ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateRevRecEstimateProject</Name>
				<Source><![CDATA[
    internal boolean shouldCreateRevRecEstimateProject()
    {
        return (this.Type == ProjType::FixedPrice || this.Type == ProjType::Investment) &&
            !ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
            ProjGroup::find(this.ProjGroupId).CompletePrincip != ProjCompletePrincip::NoWIP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvestmentProject</Name>
				<Source><![CDATA[
	/// <summary>
    /// Method to check if project is an investment project.
    /// With multiple contract line feature investment projects are not supported 
    /// so this method will return false if feature is turned on.
    /// </summary>
    /// <returns>true if meets investment project criteria, otherwise false.</returns>
	public final boolean isInvestmentProject()
    {
        return this.Type == ProjType::Investment && !ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerCov</Name>
				<Source><![CDATA[
    internal void updateLedgerCov(LedgerCoverage _ledgerCoverage, TmpProjCashFlowExcelPivot _tmpExcelExport)
    {
        LedgerCoverage ledgerCoverage = _ledgerCoverage;
        CurrencyCode accountingCurrency = Ledger::accountingCurrency();
        TransDate todayDate = DateTimeUtil::getToday(DateTimeUtil::getCompanyTimeZone());

        ledgerCoverage.init(this);

        ProjCashFlow projCashFlow = this.initLedgerCovProjCashFlow();

        this.calculateLedgerCovCashFlow(_tmpExcelExport, projCashFlow);

        while select _tmpExcelExport
        {
            AmountCur amount;
            if (_tmpExcelExport.CashInFlow > 0.00)
            {
                amount = _tmpExcelExport.CashInFlow;
            }
            else
            {
                amount = _tmpExcelExport.CashOutFlow * -1;
            }

            //A forecast may or may not have a customer.  Because a forecast may not have customer, we are only generating the expense/revenue enteries 
            //and not generating the customer balance entries.
            
            //Invoice
            if (_tmpExcelExport.LedgerTransDate != dateNull())
            {
                TransDate invoiceDate = this.determineLedgerCovInvoiceDate(_tmpExcelExport);

                ledgerCoverage.updateSum(
                    invoiceDate,
                    _tmpExcelExport.PostingType,
                    LedgerDimensionFacade::getMainAccountFromLedgerDimension(_tmpExcelExport.LedgerDimension).RecId,
                    _tmpExcelExport.DefaultDimension,
                    accountingCurrency,
                    amount,
                    NoYes::Yes);
            }

            //Payment
            if (_tmpExcelExport.PaymentDate != dateNull())
            {
                CustAccount custAccount;
                DimensionDefault paymentDimensionDefault;
                if (_tmpExcelExport.Customer != '')
                {
                    CustTable custTable = CustTable::find(_tmpExcelExport.Customer);
                    custAccount = custTable.AccountNum;
                    paymentDimensionDefault = custTable.DefaultDimension;
                }
                else
                {
                    custAccount = '';
                    paymentDimensionDefault = 0;
                }

                TransDate paymentDate = this.determineLedgerCovPaymentDate(_tmpExcelExport);

                ledgerCoverage.updateSum(
                    paymentDate,
                    this.determineLedgerCovPaymentPostingType(),
                    LedgerDimensionFacade::getMainAccountFromLedgerDimension(_tmpExcelExport.LedgerDimension).RecId,
                    paymentDimensionDefault,
                    accountingCurrency,
                    amount * -1,
                    NoYes::Yes);

                ledgerCoverage.updateSum(
                    paymentDate,
                    this.determineLedgerCovPaymentPostingType(),
                    LedgerDimensionFacade::getMainAccountFromLedgerDimension(CustLedgerAccounts::clearingLedgerDimension(custAccount, '')).RecId,
                    paymentDimensionDefault,
                    accountingCurrency,
                    amount,
                    NoYes::Yes);
                
            }
        }

        ledgerCoverage.endCov();
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineLedgerCovInvoiceDate</Name>
				<Source><![CDATA[
    private TransDate determineLedgerCovInvoiceDate(TmpProjCashFlowExcelPivot _tmpExcelExport)
    {
        TransDate invoiceDate;
        TransDate todayDate = DateTimeUtil::getToday(DateTimeUtil::getCompanyTimeZone());

        if (_tmpExcelExport.LedgerTransDate <= todayDate)
        {
            invoiceDate = todayDate;
        }
        else
        {
            invoiceDate = _tmpExcelExport.LedgerTransDate;
        }

        return invoiceDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineLedgerCovPaymentDate</Name>
				<Source><![CDATA[
    private TransDate determineLedgerCovPaymentDate(TmpProjCashFlowExcelPivot _tmpExcelExport)
    {
        TransDate paymentDate;
        TransDate todayDate = DateTimeUtil::getToday(DateTimeUtil::getCompanyTimeZone());

        if (_tmpExcelExport.PaymentDate <= todayDate)
        {
            paymentDate = todayDate;
        }
        else
        {
            paymentDate = _tmpExcelExport.PaymentDate;
        }

        return paymentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineLedgerCovPaymentPostingType</Name>
				<Source><![CDATA[
    private LedgerPostingType determineLedgerCovPaymentPostingType()
    {
        LedgerPostingType postingType;

        if (this.Type == ProjType::Cost
            || this.Type == ProjType::Internal
            || this.CustAccount == '')
        {
            postingType = LedgerPostingType::Bank;
        }
        else
        {
            postingType = LedgerPostingType::CustBalance;
        }

        return postingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerCovProjCashFlow</Name>
				<Source><![CDATA[
    private ProjCashFlow initLedgerCovProjCashFlow()
    {
        ProjCashFlow projCashFlow = new ProjCashFlow();

        projCashFlow.parmActualBudget(ProjActualBudget::Budget);
      
        projCashFlow.parmProjId(this.ProjId);

        ProjParameters projParameters = ProjParameters::find();

        projCashFlow.parmForecastModelId(projParameters.LedgerCovForecastModelId);

        if (projParameters.LedgerCovIncludeExpenses == NoYes::Yes)
        {
            projCashFlow.parmExpenses(true);
        }

        if (projParameters.LedgerCovIncludeFee == NoYes::Yes)
        {
            projCashFlow.parmFee(true);
        }

        if (projParameters.LedgerCovIncludeHour == NoYes::Yes)
        {
            projCashFlow.parmHour(true);
        }

        if (projParameters.LedgerCovIncludeItem == NoYes::Yes)
        {
            projCashFlow.parmItem(true);
        }

        if (projParameters.LedgerCovIncludeOnAccount == NoYes::Yes)
        {
            projCashFlow.parmOnAcc(true);
        }

        return projCashFlow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateLedgerCovCashFlow</Name>
				<Source><![CDATA[
    private void calculateLedgerCovCashFlow(TmpProjCashFlowExcelPivot _tmpExcelExport, ProjCashFlow _projCashFlow)
    {
        TmpProjCashFlow tmpCashFlow;

        ProjCashFlowCalc projCashFlowCalc = new ProjCashFlowCalc(tmpCashFlow);
        projCashFlowCalc.parmProjCashFlowCon(_projCashFlow.pack());
        projCashFlowCalc.parmTmpExcelExport(_tmpExcelExport);

        ttsbegin;
        projCashFlowCalc.run();
        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Project</ConfigurationKey>
	<DeveloperDocumentation>@SYS124965</DeveloperDocumentation>
	<FormRef>ProjTable</FormRef>
	<Label>@SYS36368</Label>
	<ListPageRef>ProjProjectsListPage</ListPageRef>
	<TableGroup>Main</TableGroup>
	<TitleField1>ProjId</TitleField1>
	<TitleField2>Name</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>Found</CacheLookup>
	<ClusteredIndex>ProjectIdx</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>ProjectManagementAndAccounting</Modules>
	<PrimaryIndex>ProjectIdx</PrimaryIndex>
	<ReplacementKey>ProjectIdx</ReplacementKey>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>ForecastSales(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ForecastSales</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjAllocateTrans(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjAllocateTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjBudget(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjBudget</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjCostSalesPrice(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjCostSalesPrice</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjCostTrans(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjCostTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjEmplTrans(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjEmplTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjForecastCost(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjForecastCost</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjForecastEmpl(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjForecastEmpl</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjForecastOnAcc(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjForecastOnAcc</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjForecastRevenue(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjForecastRevenue</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjHourCostPrice(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjHourCostPrice</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjHourSalesPrice(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjHourSalesPrice</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjInvoiceCost(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjInvoiceCost</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjInvoiceEmpl(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjInvoiceEmpl</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjInvoiceItem(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjInvoiceItem</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjInvoiceOnAcc(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjInvoiceOnAcc</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjInvoiceRevenue(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjInvoiceRevenue</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjItemTrans(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjItemTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjItemTransCost(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjItemTransCost</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjJournalTrans(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjJournalTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjLinePropertySetup(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjLinePropertySetup</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjOnAccTrans(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjOnAccTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjPosting(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjPosting</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjProposalCost(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjProposalCost</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjProposalEmpl(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjProposalEmpl</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjProposalItem(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjProposalItem</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjProposalOnAcc(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjProposalOnAcc</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjProposalRevenue(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjProposalRevenue</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjRevenueSalesPrice(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjRevenueSalesPrice</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjRevenueTrans(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjRevenueTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjValEmplProjSetup(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjValEmplProjSetup</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjValProjCategorySetUp(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjValProjCategorySetUp</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>PurchTable(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>PurchTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>SalesTable(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>SalesTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>SMAAgreementTable(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>SMAAgreementTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>SMAServiceOrderTable(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>SMAServiceOrderTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>SMASubscriptionTable(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>SMASubscriptionTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>smmLeadRelTable(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>smmLeadRelTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>smmOpportunityRelTable(ProjTable)</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>smmOpportunityRelTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>TSTimesheetLine(ProjTable)</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>TSTimesheetLine</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction1</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>SMASalesPriceSubscription</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction3</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjDefaultOffsetSetup</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction4</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>ProjTable</Relation>
			<Table>ProjTransferPrice</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>PSAComponentGroupAssignment</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>PSAComponentGroupAssignment</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>PSAProjSchedRole</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>PSAProjSchedRole</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjCostPriceExpense</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>ProjCostPriceExpense</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjWIPTable</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>ProjWIPTable</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Type</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JobPayType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JobId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjectedEndDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjectedStartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EndDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UseBudgeting</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjPriceGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AssetId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjLedgerPosting</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Type</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>custName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkerResponsibleFinancial</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkerResponsible</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkerResponsibleSales</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Type</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjInvoiceProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Address</Name>
			<Label>@SYS9362</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DlvName</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AddressLookUp</Name>
			<Label>@SYS88672</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Administration</Name>
			<Label>@SYS9853</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AssetGroup</Name>
			<Label>@SYS25653</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AssetId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankDocument</Name>
			<Label>@SYS313653</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankDocumentType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BudgetaryControl</Name>
			<Label>@SYS153335</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>UseBudgeting</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjBudgetaryControlOn</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjBudgetOverrunOption</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UseAlternateProject</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AlternateBudgetProject</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjBudgetInterval</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjCarryForwardNegativeBudget</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjCarryForwardRemainingBudget</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjBudgetManagement</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CaseMoreInformation</Name>
			<Label>@SYS314356</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjInvoiceProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Type</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Header</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CollaborationWorkspaceURL</Name>
			<Label>@SYS132439</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>displayInternalURL</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>displayExternalURL</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ContactInfo</Name>
			<Label>@SYS21663</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Email</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ControlSystem</Name>
			<Label>@SYS54063</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WIPProject</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CostControl</Name>
			<Label>@SYS107921</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CheckBudget</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CustomerContacts</Name>
			<Label>@SYS112870</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjInvoiceProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>contractCurrCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>DateGroup</Name>
			<Label>@SYS7402</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Created</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjectedStartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjectedEndDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExtensionDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EndDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimension</Name>
			<Label>@SYS14926</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Hierarchies</Name>
			<Label>@SYS112869</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ParentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Format</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Header</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Template</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JobId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WIPProject</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JobId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Ledger</Name>
			<Label>@SYS13356</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjLedgerPosting</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>LineProperty</Name>
			<Label>@SYS50026</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjLinePropertySearch</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Payroll</Name>
			<Label>@GLS92169</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OCIP</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OCIPGL</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CertifiedPayroll</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Piecework</Name>
			<Label>@sys711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JobPayType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PreviewPaneLeft</Name>
			<Label>@SYS313169</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>StartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EndDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PreviewPaneRight</Name>
			<Label>@SYS313169</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkerResponsible</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkerResponsibleSales</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PriceGroup</Name>
			<Label>@SYS13076</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjPriceGroup</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Project</Name>
			<Label>@SYS4534</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Header</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Format</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Type</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjInvoiceProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JobId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ProjectIdentification</Name>
			<Label>@SYS89920</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjInvoiceProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WIPProject</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkerResponsible</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ProjectShort</Name>
			<Label>@SYS4534</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Type</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ProjectTemplate</Name>
			<Label>@SYS60758</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Template</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ProjId</Name>
			<Label>@SYS318380</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PSA</Name>
			<Label>@PSA43</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PSAForecastModelId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSAProjStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSAProjTask</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkerPSAArchitect</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSAForecastModelIdExternal</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PSAContract</Name>
			<Label>@PSA143</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjInvoiceProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSAInvoiceMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>childExist</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSADoInvoiceCost</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PSAGroup</Name>
			<Label>@PSA43</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PSAResSchedStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CompleteScheduled</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PSAProjectInfo</Name>
			<Label>@SYS50114</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PSAProjectOverview</Name>
			<Label>@SYS4534</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>childExist</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjInvoiceProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>contractAmountFixedPrice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Type</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Header</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PSAScheduling</Name>
			<Label>@PSA2443</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PSASchedScheduled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSASchedStartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSASchedEndDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSASchedDuration</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSASchedUseDuration</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSASchedEffort</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSASchedIgnoreCalendar</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSASchedCalendarId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSASchedToTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSASchedFromTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>RequireActivityForecast</Name>
			<Label>@SYS104382</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RequireActivityHourForecast</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RequireActivityExpenseForecast</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RequireActivityItemForecast</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>RequireActivityTrx</Name>
			<Label>@SYS104381</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RequireActivityHourTrx</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RequireActivityExpenseTrx</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RequireActivityItemTrx</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ResponsibleWorker</Name>
			<Label>@SYS67464</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkerResponsibleSales</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkerResponsible</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkerResponsibleFinancial</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTax</Name>
			<Label>@SYS67871</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Sorting</Name>
			<Label>@SYS4138</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>sortingId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>System</Name>
			<Label>@SYS4278</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TimeRegistration</Name>
			<Label>@SYS138979</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TimePostDetailSummary</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MinTimeIncrement</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Validation</Name>
			<Label>@SYS4440</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ValidateProjCategory</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WebCategoryBrowsing</Name>
			<Label>@SYS74258</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Type</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Zakat_SA</Name>
			<Label>@SYS321586</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Subject_SA</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContractDate_SA</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContractPeriod_SA</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContractValue_SA</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContractAmendment_SA</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AlternateBudgetProject</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjId</ExtendedDataType>
			<Label>@SYS153317</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AssetId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AssetId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankDocumentType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>BankLGDocumentType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CertifiedPayroll</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PayrollAdministration</ConfigurationKey>
			<Label>@GLS94038</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CheckBudget</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS153311</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CompleteScheduled</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@PSA10199</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ContractAmendment_SA</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>SA</CountryRegionCodes>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<HelpText>@Proj:ContractAmendment_SAHelpText</HelpText>
			<Label>@SYS321595</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ContractDate_SA</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>SA</CountryRegionCodes>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS321592</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContractPeriod_SA</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjContractPeriodZakat_SA</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ContractValue_SA</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>SA</CountryRegionCodes>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SYS331870</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>Created</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS21858</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustAccount</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>CustAccount</ExtendedDataType>
			<GroupPrompt>@SYS24500</GroupPrompt>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDefaultDimensionValueSet</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DeliveryLocation</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>LogisticsLocationRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DlvName</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>CompanyName</ExtendedDataType>
			<Label>@SYS22058</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Email</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Email</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>EndDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjEndDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ExtensionDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjExtensionDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Format</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NumberSequenceFormat</ExtendedDataType>
			<Label>@SYS333115</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Header</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjHeader</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>JobId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>JmgJob</ConfigurationKey>
			<ExtendedDataType>JmgJobId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>JobPayType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>JmgJob</ConfigurationKey>
			<ExtendedDataType>JmgJobPayType</ExtendedDataType>
			<EnumType>JmgJobPayTypeEnum</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>MinTimeIncrement</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TSMinTimeIncrement</ExtendedDataType>
			<HelpText>@Proj:TSMinTimeIncrementHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AliasFor>ProjId</AliasFor>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OCIP</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@GLS93815</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OCIPGL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PayrollAdministration</ConfigurationKey>
			<Label>@GLS93817</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldContainer">
			<Name>PackedExtensions</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>SysExtensionSerializerPackedContainer</ExtendedDataType>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ParentId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjParentId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjBudgetaryControlOn</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjBudgetaryControlOn</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjBudgetInterval</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjBudgetInterval</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjBudgetManagement</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjBudgetManagement</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjBudgetOverrunOption</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@Proj:ProjBudgetOverrunDefaultHelpText</HelpText>
			<EnumType>ProjBudgetOverrunOption</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjCarryForwardNegativeBudget</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<HelpText>@Proj:ProjCarryForwardNegativeBudgetHelpText</HelpText>
			<Label>@SYS312846</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjCarryForwardRemainingBudget</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@sys312844</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ProjectedEndDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjProjectedEndDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ProjectedStartDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjProjectedStartDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjInvoiceProjId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjInvoiceProjId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjLedgerPosting</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS340029</Label>
			<EnumType>ProjLedgerPosting</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjLinePropertySearch</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjLinePropertySearch</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjPriceGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjPriceGroupID</ExtendedDataType>
			<Label>@SYS340030</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSADoInvoiceCost</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PSADoInvoiceCost</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSAForecastModelId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ForecastModelId</ExtendedDataType>
			<Label>@PSA990</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSAForecastModelIdExternal</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ForecastModelId</ExtendedDataType>
			<Label>@PSA1833</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSAInvoiceMethod</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PSAInvoiceMethod</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSANotes</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>Notes</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
			<Label>@SYS70989</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSAPhone</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>Phone</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSAPReqControl</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<IsObsolete>Yes</IsObsolete>
			<EnumType>PSAPReqControl</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSAPReqHourValidate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<IsObsolete>Yes</IsObsolete>
			<EnumType>PSAPReqValidate</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSAPReqItemValidate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<IsObsolete>Yes</IsObsolete>
			<EnumType>PSAPReqValidate</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSAProjStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PSAProjStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSAProjTask</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<IsObsolete>Yes</IsObsolete>
			<EnumType>PSAProjTask</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSAReadyForInvoicing</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
			<Label>@PSA898</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSAResSchedStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PSAResSchedStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSARetainIncludeLower</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
			<Label>@PSA3087</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PSARetainPercent</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>Percent</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
			<Label>@PSA11194</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSARetainScheduleId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>PSAProjRetainScheduleId</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSASchedCalendarId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CalendarId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>PSASchedConstraintDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PSAConstraintDate</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSASchedConstraintType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<IsObsolete>Yes</IsObsolete>
			<EnumType>PSAConstraintType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>PSASchedDefaultDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PSASchedDuration</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RealBase</ExtendedDataType>
			<Label>@PSA10114</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PSASchedEffort</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Hours</ExtendedDataType>
			<Label>@PSA10115</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>PSASchedEndDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SchedToDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldTime">
			<Name>PSASchedFromTime</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SchedFromTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSASchedIgnoreCalendar</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PSAIgnoreCalendar</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSASchedMilestone</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<IsObsolete>Yes</IsObsolete>
			<Label>@SYS26744</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSASchedScheduled</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PSAScheduled</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>PSASchedStartDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SchedFromDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldTime">
			<Name>PSASchedToTime</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SchedToTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSASchedUseDuration</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Project</ConfigurationKey>
			<ExtendedDataType>PSADurationToEnd</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSATeleFax</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>TeleFax</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSATimeMeasure</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<IsObsolete>Yes</IsObsolete>
			<EnumType>PSAProjTimeMeasure</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSATrackCost</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<IsObsolete>Yes</IsObsolete>
			<EnumType>PSAProjTrackCost</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PSAUnitId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>UnitOfMeasureSymbol</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RequireActivityExpenseForecast</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RequireActivityExpenseForecast</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RequireActivityExpenseTrx</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RequireActivityExpenseTrx</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RequireActivityHourForecast</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RequireActivityHourForecast</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RequireActivityHourTrx</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RequireActivityHourTrx</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RequireActivityItemForecast</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RequireActivityItemForecast</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RequireActivityItemTrx</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RequireActivityItemTrx</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>sortingId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjSortingId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>StartDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjStartDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Status</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS56164</Label>
			<EnumType>ProjStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Subject_SA</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjSubjectZakat_SA</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxGroup</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Template</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS60758</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TimePostDetailSummary</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TSPostDetailSummary</ExtendedDataType>
			<Label>@SYS184065</Label>
			<Visible>No</Visible>
			<EnumType>DetailSummary</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Type</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UseAlternateProject</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS153315</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UseBudgeting</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS153313</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ValidateProjCategory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjValidateOption</ExtendedDataType>
			<Label>@SYS11718</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WIPProject</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjWipId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>WorkerPSAArchitect</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>WorkerResponsible</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjResponsibleWorker</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>WorkerResponsibleFinancial</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjResponsibleFinancialWorker</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>WorkerResponsibleSales</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjResponsibleSalesWorker</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Description</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>description</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TemplateApplied</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>AlertTimeFrameWeeks</Name>
			<AssetClassification>Customer Content</AssetClassification>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ProjDataSource</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjDataSourceRefId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultFundingSource</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjFundingSourceRefId</ExtendedDataType>
			<FeatureClass>ProjItemRequirementMultipleFundingSources</FeatureClass>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>ProjectIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CustIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CustAccount</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ProjId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InvoiceProjectIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjInvoiceProjId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ProjId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>FatherIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ParentId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ProjId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WIPProjIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>WIPProject</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>FK_DimensionAttributeValueSet_ProjTable</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>DefaultDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>AssetIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>AssetId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>NameIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>Name</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>HcmWorkerIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkerResponsibleFinancial</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>HcmWorkerIdx1</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkerResponsible</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>HcmWorkerIdx2</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkerResponsibleSales</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>jobididx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>JmgJob</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>JobId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>GroupStatusStartDateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjGroupId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Status</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>StartDate</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ParentIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ParentId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ProjDataSourceIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjDataSource</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>Header</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>Header</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ProjId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Status</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Type</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>MobileProjectQueryIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>Status</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Type</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Header</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>AlternateProjectIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>UseAlternateProject</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AlternateBudgetProject</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>BankLGDocumentMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>BankDocumentType</MapField>
					<MapFieldTo>BankDocumentType</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DefaultDimension</MapField>
					<MapFieldTo>DefaultDimension</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DocumentId</MapField>
					<MapFieldTo>ProjId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>OrderAccount</MapField>
					<MapFieldTo>CustAccount</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>DimensionDefaultMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>DefaultDimension</MapField>
					<MapFieldTo>DefaultDimension</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>LogisticsLocationMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>Location</MapField>
					<MapFieldTo>DeliveryLocation</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SysExtensionSerializerMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>PackedExtensions</MapField>
					<MapFieldTo>PackedExtensions</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PackedPrioritizedIdList</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>TransitDocumentTransactionMap_IN</MappingTable>
			<Connections />
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalLine</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryLocation</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryState</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventDimId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventTransId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineNum</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>TableId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxItemGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TransDate</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AssetTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>AssetTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AssetId</Name>
					<SourceEDT>AssetId</SourceEDT>
					<Field>AssetId</Field>
					<RelatedField>AssetId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>GroupAssetIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustAccount</Name>
					<SourceEDT>CustAccount</SourceEDT>
					<Field>CustAccount</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DimensionAttributeValueSet</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DimensionAttributeValueSet_ProjTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DeliveryLocation_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LogisticsLocation</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LogisticsLocation</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LogisticsLocation_ProjTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DeliveryLocation</Name>
					<Field>DeliveryLocation</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ForecastModel</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ForecastModel</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PSAForecastModelId</Name>
					<SourceEDT>ForecastModelId</SourceEDT>
					<Field>PSAForecastModelId</Field>
					<RelatedField>ModelId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PSAForecastModelIdExternal</Name>
					<SourceEDT>ForecastModelId</SourceEDT>
					<Field>PSAForecastModelIdExternal</Field>
					<RelatedField>ModelId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PriceDiscGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>PriceDiscGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjPriceGroup</Name>
					<SourceEDT>ProjPriceGroupID</SourceEDT>
					<Field>ProjPriceGroup</Field>
					<RelatedField>GroupId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Type_Extern</Name>
					<SourceEDT>ProjPriceGroupID</SourceEDT>
					<RelatedField>Type</RelatedField>
					<ValueStr>PriceGroupType::PriceGroup</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Module_Extern</Name>
					<SourceEDT>ProjPriceGroupID</SourceEDT>
					<RelatedField>Module</RelatedField>
					<ValueStr>ModuleInventCustVend::Cust</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjGroup_1</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>ProjGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjGroup_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjGroupId</Name>
					<SourceEDT>ProjGroupId</SourceEDT>
					<Field>ProjGroupId</Field>
					<RelatedField>ProjGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>GroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjInvoiceTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124968</EntityRelationshipRole>
			<RelatedTable>ProjInvoiceTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjInvoiceTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjInvoiceTable_ProjTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjInvoiceProjId</Name>
					<SourceEDT>ProjInvoiceProjId</SourceEDT>
					<Field>ProjInvoiceProjId</Field>
					<RelatedField>ProjInvoiceProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjSorting1</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjSorting</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjSorting1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>sortingId</Name>
					<Field>sortingId[1]</Field>
					<RelatedField>sortingId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>SortCode_Extern</Name>
					<RelatedField>SortCode</RelatedField>
					<ValueStr>ProjSortValue::Sorting1</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjSorting2</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjSorting</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjSorting2</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>SortCode_Extern</Name>
					<RelatedField>SortCode</RelatedField>
					<ValueStr>ProjSortValue::Sorting2</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>sortingId</Name>
					<Field>sortingId[2]</Field>
					<RelatedField>sortingId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjSorting3</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjSorting</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjSorting3</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>SortCode_Extern</Name>
					<RelatedField>SortCode</RelatedField>
					<ValueStr>ProjSortValue::Sorting3</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>sortingId</Name>
					<Field>sortingId[3]</Field>
					<RelatedField>sortingId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjTable_AlternateBudgetProject</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjTable_AlternateBudgetProject</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AlternateBudgetProject</Name>
					<SourceEDT>ProjId</SourceEDT>
					<Field>AlternateBudgetProject</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ProjectIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjTable_Parent</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjTable_Parent</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ParentId</Name>
					<SourceEDT>ProjParentId</SourceEDT>
					<Field>ParentId</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ProjectIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjWIPTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjWIPTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WIPProject</Name>
					<SourceEDT>ProjWipId</SourceEDT>
					<Field>WIPProject</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>projIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxGroupId</Name>
					<SourceEDT>TaxGroup</SourceEDT>
					<Field>TaxGroupId</Field>
					<RelatedField>TaxGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WorkCalendarTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WorkCalendarTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PSASchedCalendarId</Name>
					<SourceEDT>CalendarId</SourceEDT>
					<Field>PSASchedCalendarId</Field>
					<RelatedField>CalendarId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CalendarIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WorkerPSAArchitect</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HasTheRoleOfAnArchitect</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>WhoseArchitectIs</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkerPSAArchitect</Name>
					<Field>WorkerPSAArchitect</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WorkerRespFinancial</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>HcmWorker_ProjTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkerResponsibleFinancial</Name>
					<Field>WorkerResponsibleFinancial</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WorkerResponsible</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>HcmWorker_1_ProjTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkerResponsible</Name>
					<Field>WorkerResponsible</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WorkerRespSales</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker_2</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>HcmWorker_2_ProjTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkerResponsibleSales</Name>
					<Field>WorkerResponsibleSales</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjDataSource</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjDataSource</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjDataSource</Name>
					<Field>ProjDataSource</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjFundingSource</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjFundingSource</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjFundingSource</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjFundingSource_ProjTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultFundingSource</Name>
					<Field>DefaultFundingSource</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>