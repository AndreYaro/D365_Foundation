<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjPlanVersion</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ProjPlanVersion extends common
{    
    #TimeConstants
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getNextTaskId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a new task id in the specified hierarchy.
    /// </summary>
    /// <param name = "_hierarchyId">The hierarchy ID for which to retrieve the new task ID.</param>
    /// <param name = "_isProject">true if the supplied hierarchy ID is a hierarchy for a project (WBS); false for all other hierarchies.</param>
    /// <returns>The next unused task ID.</returns>
    public static ProjHierarchyTaskId getNextTaskId(HierarchyIdBase _hierarchyId, boolean _isProject)
    {
        return ProjPlanVersion::getMaxTaskId(_hierarchyId, _isProject) + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxTaskId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the max task Id for the specified hierarchy.
    /// </summary>
    /// <param name = "_hierarchyId">The hierarchy ID for which to retrieve the max task ID.</param>
    /// <param name = "_isProject">true if the supplied hierarchy ID is a hierarchy for a project (WBS); false for all other hierarchies.</param>
    /// <returns>The max used task ID.</returns>
    public static ProjHierarchyTaskId getMaxTaskId(HierarchyIdBase _hierarchyId, boolean _isProject)
    {
        ProjPlanVersion projPlanVersion;

        if (_isProject)
        {
            ProjPlanVersionDetail projPlanVersionDetail, projPlanVersionDetailProj;
            if (_hierarchyId)
            {
                select maxof(HierarchyTaskId) from projPlanVersion
                    join RecId from projPlanVersionDetail
                        where projPlanVersionDetail.HierarchyId == _hierarchyId
                    exists join projPlanVersionDetailProj
                        where projPlanVersionDetailProj.ProjId == projPlanVersionDetail.ProjId
                            && projPlanVersion.HierarchyId == projPlanVersionDetailProj.HierarchyId;
            }
        }
        else
        {
            if (_hierarchyId)
            {
                select maxof(HierarchyTaskId) from projPlanVersion
                    where ProjPlanVersion.HierarchyId == _hierarchyId;
            }
        }

        return projPlanVersion.HierarchyTaskId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextSiblingNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a new task id in the specified hierarchy.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy id</param>
    /// <returns></returns>
    public static LineNum getNextSiblingNumber(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _parentTaskId)
    {
        return ProjPlanVersion::getMaxSiblingNumber(_hierarchyId, _parentTaskId) + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxSiblingNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets maximum sibling number of the task with specified parent.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy id of the task</param>
    /// <param name = "_parentTaskId">Id of the parent task</param>
    /// <returns></returns>
    public static LineNum getMaxSiblingNumber(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _parentTaskId)
    {
        ProjPlanVersion projPlanVersion;
        select maxof(TaskSiblingNumber) from projPlanVersion
            where projPlanVersion.ParentHierarchyTaskId == _parentTaskId
                && projPlanVersion.HierarchyId == _hierarchyId;

        return projPlanVersion.TaskSiblingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaskSiblingNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets sibling number for the specified task.
    /// </summary>
    /// <param name = "_taskId">Task id</param>
    /// <returns></returns>
    public static LineNum getTaskSiblingNumber(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId)
    {
        ProjPlanVersion projPlanVersion;

        select firstonly TaskSiblingNumber from projPlanVersion
                where projPlanVersion.HierarchyId == _hierarchyId
                      && projPlanVersion.HierarchyTaskId == _taskId;

        return projPlanVersion.TaskSiblingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRootTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets root task for the specified hierarchy.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy id</param>
    /// <param name = "_forUpdate">Whether the record should be locked for update.</param>
    /// <returns>The ProjPlanVersion record for the root task of the given hierarchy.</returns>
    public static ProjPlanVersion getRootTask(HierarchyIdBase _hierarchyId, boolean _forUpdate = false)
    {
        ProjPlanVersion projPlanVersion;
        
        if (_hierarchyId)
        {
            projPlanVersion.selectForUpdate(_forUpdate);

            select firstonly projPlanVersion
                where projPlanVersion.ParentHierarchyTaskId == 0 && projPlanVersion.HierarchyId == _hierarchyId;
        }

        return projPlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByHierarchyAndTaskId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find <c>ProjPlanVersion</c> record by hierarchy and task ID.
    /// </summary>
    /// <param name = "_hierarchyId">
    /// Hierarchy ID of the task.
    /// </param>
    /// <param name = "_taskId">
    /// ID of the parent task.
    /// </param>
    /// <param name = "_update">
    /// Whether the return table table buffer can be updated.
    /// </param>
    /// <returns>
    /// The specific <c>ProjPlanVersion</c> table buffer.
    /// </returns>
    public static ProjPlanVersion findByHierarchyAndTaskId(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId, boolean _update = false)
    {
        ProjPlanVersion projPlanVersion;
        
        if (_hierarchyId && _taskId)
        {
            projPlanVersion.selectForUpdate(_update);

            select firstOnly projPlanVersion
                where projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.HierarchyTaskId == _taskId;
        }

        return projPlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByHierarchyAndActivityRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find <c>ProjPlanVersion</c> record by hierarchy ID and activity record ID.
    /// </summary>
    /// <param name = "_hierarchyId">
    /// Hierarchy ID of the task.
    /// </param>
    /// <param name = "_activityRecId">
    /// The associated activity record ID of the task.
    /// </param>
    /// <param name = "_update">
    /// Whether the return table table buffer can be updated.
    /// </param>
    /// <returns>
    /// The specific <c>ProjPlanVersion</c> table buffer.
    /// </returns>
    public static ProjPlanVersion findByHierarchyAndActivityRecId(HierarchyIdBase _hierarchyId, ActivityRecId _activityRecId, boolean _update = false)
    {
        ProjPlanVersion projPlanVersion;
        
        if (_hierarchyId && _activityRecId)
        {
            projPlanVersion.selectForUpdate(_update);

            HierarchyTreeTable hierarchyTree;

            select firstonly RecId from hierarchyTree
                where hierarchyTree.RefRecId == _activityRecId
                join projPlanVersion
                    where projPlanVersion.HierarchyId == _hierarchyId
                        && projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTree.RecId;
        }

        return projPlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByActivityNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the latest <c>ProjPlanVersion</c> record by activity number.
    /// </summary>
    /// <param name = "_activityNumber">
    /// The associated activity number of the task.
    /// </param>
    /// <param name = "_update">
    /// Whether the return table table buffer can be updated.
    /// </param>
    /// <returns>
    /// The specific <c>ProjPlanVersion</c> table buffer.
    /// </returns>
    public static ProjPlanVersion findByActivityNumber(smmActivityNumber _activityNumber, boolean _update = false)
    {
        ProjPlanVersion projPlanVersion;
        
        if (_activityNumber)
        {
            projPlanVersion.selectForUpdate(_update);

            HierarchyTreeTable  hierarchyTree;
            smmActivities       activityTable;

            select firstonly projPlanVersion
                order by projPlanVersion.RecId desc
                exists join hierarchyTree
                    where hierarchyTree.RecId == projPlanVersion.HierarchyTreeTableRefRecId
                exists join activityTable
                    where activityTable.RecId == hierarchyTree.RefRecId
                        && activityTable.ActivityNumber == _activityNumber;
        }

        return projPlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByActivityRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the latest <c>ProjPlanVersion</c> record by activity record ID.
    /// </summary>
    /// <param name = "_activityRecId">
    /// The associated activity record ID of the task.
    /// </param>
    /// <param name = "_update">
    /// Whether the return table table buffer can be updated.
    /// </param>
    /// <returns>
    /// The specific <c>ProjPlanVersion</c> table buffer.
    /// </returns>
    public static ProjPlanVersion findByActivityRecId(ActivityRecId _activityRecId, boolean _update = false)
    {
        ProjPlanVersion projPlanVersion;
        
        if (_activityRecId)
        {
            projPlanVersion.selectForUpdate(_update);

            HierarchyTreeTable hierarchyTree;

            select firstonly projPlanVersion
                order by projPlanVersion.RecId desc
                exists join hierarchyTree
                    where hierarchyTree.RecId == projPlanVersion.HierarchyTreeTableRefRecId
                        && hierarchyTree.RefRecId == _activityRecId;
        }

        return projPlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find <c>ProjPlanVersion</c> record by record ID.
    /// </summary>
    /// <param name = "_recId">
    /// The record ID of <c>ProjPlanVersion</c> table.
    /// </param>
    /// <param name = "_update">
    /// Whether the return table table buffer can be updated.
    /// </param>
    /// <returns>
    /// The specific <c>ProjPlanVersion</c> table buffer.
    /// </returns>
    public static ProjPlanVersion findByRecId(RefRecId _recId, boolean _update = false)
    {
        ProjPlanVersion  projPlanVersion;

        if (_recId)
        {
            projPlanVersion.selectForUpdate(_update);

            select firstonly projPlanVersion
                where projPlanVersion.RecId == _recId;
        }

        return projPlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByHierarchyAndPathId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find <c>ProjPlanVersion</c> record by hierarchy and path ID.
    /// </summary>
    /// <param name = "_hierarchyId">
    /// Hierarchy ID of the task.
    /// </param>
    /// <param name = "_pathId">
    /// WBS ID of the task.
    /// </param>
    /// <param name = "_update">
    /// Whether the return table table buffer can be updated.
    /// </param>
    /// <returns>
    /// The specific <c>ProjPlanVersion</c> table buffer.
    /// </returns>
    public static ProjPlanVersion findByHierarchyAndPathId(HierarchyIdBase _hierarchyId, ProjHierarchyPathId _pathId, boolean _update = false)
    {
        ProjPlanVersion projPlanVersion;
        
        if (_hierarchyId)
        {
            projPlanVersion.selectForUpdate(_update);

            select firstOnly projPlanVersion
                where projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.PathID == _pathId;
        }

        return projPlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostAtCompleteV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update cost at complete for <c>ProjPlanVersion</c> table buffer.
    /// </summary>
    /// <param name = "_node"><c>ProjPlanVersion</c> table buffer.</param>
    public static void updateCostAtCompleteV2(ProjPlanVersion _node)
    {
        ttsbegin;
        _node.reread();
        _node.TaskCostAtComplete = 0.0;
        if (_node.TaskEffortAtComplete)
        {
            NonNegativeCostPrice averageUnitCostPrice =
                PSAActivityEstimates::getAverageUnitCostPriceByHierarchyTaskId(_node.HierarchyId, _node.HierarchyTaskId);

            _node.TaskCostAtComplete = averageUnitCostPrice * _node.TaskEffortAtComplete;
        }
        _node.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSummaryTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a task is a summary task.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy id.</param>
    /// <param name = "_hierarchyTaskId">Task id.</param>
    /// <returns>
    /// true if it is a summary task; false otherwise.
    /// </returns>
    public static boolean isSummaryTask(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _hierarchyTaskId)
    {
        ProjPlanVersion projPlanVersion;

        select firstonly RecId from projPlanVersion
            where projPlanVersion.ParentHierarchyTaskId == _hierarchyTaskId
            && projPlanVersion.HierarchyId == _hierarchyId;

        if (projPlanVersion)
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a task's activity number from the linked <c>smmActivities</c> record.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <param name = "_taskId">Task ID.</param>
    /// <returns>The smmActivityNumber from the linked <c>smmActivities</c> record.</returns>
    public static smmActivityNumber getActivityNumber(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId)
    {
        HierarchyTreeTable      hierarchyTreeTable;
        ProjPlanVersion         projPlanVersion;
        smmActivities           smmActivities;

        select ActivityNumber from smmActivities
            exists join hierarchyTreeTable
            where hierarchyTreeTable.RefRecId == smmActivities.RecId
            exists join projPlanVersion
                where projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
                    && projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.HierarchyTaskId == _taskId;

        return smmActivities.ActivityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a task's associated <c>smmActivities</c> table buffer.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <param name = "_taskId">Task ID.</param>
    /// <returns><c>smmActivities</c> table buffer.</returns>
    public static smmActivities getActivityBuffer(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId)
    {
        HierarchyTreeTable      hierarchyTreeTable;
        ProjPlanVersion         projPlanVersion;
        smmActivities           smmActivities;

        select smmActivities
            exists join hierarchyTreeTable
            where hierarchyTreeTable.RefRecId == smmActivities.RecId
            exists join projPlanVersion
                where projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
                    && projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.HierarchyTaskId == _taskId;

        return smmActivities;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a task's activity record ID from the linked <c>smmActivities</c> record.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <param name = "_taskId">Task ID.</param>
    /// <returns>The activity record ID.</returns>
    public static ActivityRecId getActivityRecId(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId)
    {
        HierarchyTreeTable      hierarchyTreeTable;
        ProjPlanVersion         projPlanVersion;
        smmActivities           smmActivities;

        select RecId from smmActivities
            exists join hierarchyTreeTable
            where hierarchyTreeTable.RefRecId == smmActivities.RecId
            exists join projPlanVersion
                where projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
                    && projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.HierarchyTaskId == _taskId;

        return smmActivities.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRootActivityRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the root tasks activity record ID from the linked smmActivityRecord.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <returns>The smmActivityNumber from the linked smmActivities record.</returns>
    public static ActivityRecId getRootActivityRecId(HierarchyIdBase _hierarchyId)
    {
        HierarchyTreeTable      hierarchyTreeTable;
        ProjPlanVersion         projPlanVersion;
        smmActivities           smmActivities;

        select RecId from smmActivities
            exists join hierarchyTreeTable
            where hierarchyTreeTable.RefRecId == smmActivities.RecId
            exists join projPlanVersion
                where projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
                    && projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.ParentHierarchyTaskID == 0;

        return smmActivities.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxOfFinishDateForTheHierarchyId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the maximum finish date for the input hieararchy ID.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <returns>Returns the maximum finish date for the input hieararchy ID.</returns>
    public static SchedToDate getMaxOfFinishDateForTheHierarchyId(HierarchyIdBase _hierarchyId)
    {
        ProjPlanVersion projPlanVersion;

        select maxof(TaskFinishDate) from projPlanVersion
            where projPlanVersion.HierarchyId == _hierarchyId;

        return projPlanVersion.TaskFinishDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRootTaskId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the root task hierarchy task ID.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <returns>The root task hierarchy task ID.</returns>
    public static ProjHierarchyTaskId getRootTaskId(HierarchyIdBase _hierarchyId)
    {
        ProjPlanVersion wbsTable;

        if (_hierarchyId)
        {
            select firstonly HierarchyTaskID from wbsTable
                where wbsTable.HierarchyId == _hierarchyId
                    && wbsTable.ParentHierarchyTaskId == 0;
        }

        return wbsTable.HierarchyTaskID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxHierarchyLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the maximum level of hierarchy by hierarchy ID.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <returns>The maximum level of hierarchy by the specified hierarchy ID</returns>
    public static ProjHierarchyLevel getMaxHierarchyLevel(HierarchyIdBase _hierarchyId)
    {
        ProjPlanVersion wbsTable;

        if (_hierarchyId)
        {
            select maxof(HierarchyLevel) from wbsTable
                where wbsTable.HierarchyId == _hierarchyId;
        }

        return wbsTable.HierarchyLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByParentTaskIdAndSiblingNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>ProjPlanVersion</c> record by the hierarchy ID, parent task ID and sibling number passed in as a parameters.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <param name = "_parentHierarchyTaskId">Parent hierarchy task ID.</param>
    /// <param name = "_taskSiblingNumber">Task sibling number.</param>
    /// <param name = "_forUpdate">Check if the record is being accessed for update.</param>
    /// <returns>The <c>Tutorial_ProjHierarchyTable</c> record.</returns>
    public static ProjPlanVersion findByParentTaskIdAndSiblingNumber(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _parentHierarchyTaskId, LineNum _taskSiblingNumber, boolean _forUpdate = false)
    {
        ProjPlanVersion wbsTable;

        if (_hierarchyId && _parentHierarchyTaskId && _taskSiblingNumber)
        {
            wbsTable.selectForUpdate(_forUpdate);

            select firstonly wbsTable
                where wbsTable.HierarchyId == _hierarchyId
                    && wbsTable.ParentHierarchyTaskId == _parentHierarchyTaskId
                    && wbsTable.TaskSiblingNumber == _taskSiblingNumber;
        }

        return wbsTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextHierarchyTaskId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the next value of hierarchy task ID by hierarchy ID.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <returns>The next value of hierarchy task by the specified hierarchy ID</returns>
    public static ProjHierarchyTaskId getNextHierarchyTaskId(HierarchyIdBase _hierarchyId)
    {
        ProjHierarchyTaskId hierarchyTaskId;
        
        if (_hierarchyId)
        {
            ProjPlanVersion wbsTable;

            select maxof(HierarchyTaskId) from wbsTable
                where wbsTable.HierarchyId == _hierarchyId;

            hierarchyTaskId = wbsTable.HierarchyTaskId + 1;
        }

        return hierarchyTaskId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildTasksLastSiblingNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the child taks last sibling number.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <param name = "_hierarchyTaskId">Hierarchy task ID.</param>
    /// <returns>The child taks last sibling number.</returns>
    public static LineNum getChildTasksLastSiblingNumber(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _hierarchyTaskId)
    {
        ProjPlanVersion wbsTable;

        if (_hierarchyId && _hierarchyTaskId)
        {
            select maxof(TaskSiblingNumber) from wbsTable
                where wbsTable.HierarchyId == _hierarchyId
                    && wbsTable.ParentHierarchyTaskId == _hierarchyTaskId;
        }

        return wbsTable.TaskSiblingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructSuccessorSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a set containing all successors, including parents (recursively) for the given task.
    /// </summary>
    /// <param name = "_task">The task to get successors of.</param>
    /// <param name = "_outSuccessors">The set of successors to add to (set of ProjHierarchyTaskId/Types::Int64).</param>
    public static void constructSuccessorSet(ProjPlanVersion _task, Set _outSuccessors)
    {
        // Successors of a task are:
        // 1 - Its direct parent
        // 2 - Its direct successors
        // 3 - Successors of its successors

        // Check if this task has a parent, and if it exists in the set
        if (_task.ParentHierarchyTaskId && !_outSuccessors.in(_task.ParentHierarchyTaskId))
        {
            _outSuccessors.add(_task.ParentHierarchyTaskId);
            ProjPlanVersion parent = ProjPlanVersion::findByHierarchyAndTaskId(_task.HierarchyId, _task.ParentHierarchyTaskId);
            ProjPlanVersion::constructSuccessorSet(parent, _outSuccessors);
        }

        // For each direct successor of this task
        ProjDependency dependencyEdge;
        while select SuccessorHierarchyTaskId from dependencyEdge where
            dependencyEdge.ProjPlanHierarchyId == _task.HierarchyId
            && dependencyEdge.PredecessorHierarchyTaskId == _task.HierarchyTaskId
        {
            // If this edge does not define a known successor, recurse
            if (!_outSuccessors.in(dependencyEdge.SuccessorHierarchyTaskId))
            {
                _outSuccessors.add(dependencyEdge.SuccessorHierarchyTaskId);
                ProjPlanVersion successor = ProjPlanVersion::findByHierarchyAndTaskId(_task.HierarchyId, dependencyEdge.SuccessorHierarchyTaskId);
                ProjPlanVersion::constructSuccessorSet(successor, _outSuccessors);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removePredecessors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes any predecessor depencies that appear in the given set for the given task.
    /// </summary>
    /// <param name = "_hierarchyId">HierarchyId for which all the TaskIds appear in.</param>
    /// <param name = "_task">The task to remove predecessors from.</param>
    /// <param name = "_predecessorsToRemove">An enumerator for the set of predecessors to remove (set of ProjHierarchyTaskId).</param>
    public static void removePredecessors(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _task, SetEnumerator _predecessorsToRemove)
    {
        ProjDependency dependencyEdge;
        while (_predecessorsToRemove.moveNext())
        {
            delete_from dependencyEdge where
                    dependencyEdge.ProjPlanHierarchyId == _hierarchyId
                    && dependencyEdge.SuccessorHierarchyTaskId == _task
                    && dependencyEdge.PredecessorHierarchyTaskId == _predecessorsToRemove.current();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUserChangeDurationV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles validation and propagation of the user modifying the task duration for the given task.
    /// </summary>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_node">Task whose duration was modified.</param>
    /// <param name = "_autoScheduling">Whether auto scheduling is turned on.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <returns>True if the modification was valid; otherwise, false.</returns>
    public static boolean postUserChangeDurationV2(CalendarId _calendarId, ProjPlanVersion _node,
        boolean _autoScheduling, Hours _calendarStandardWorkDayHours)
    {
        // If this is a summary task, changing the duration is not allowed
        if (!_node.EndNode)
        {
            _node.TaskDuration = _node.orig().TaskDuration;
            warning("@ProjPlan:SummaryTaskDurationCannotBeChanged");
            return false;
        }

        // Duration must be a natural number
        _node.TaskDuration = max(0.0, roundUpDec(_node.TaskDuration, 0));

        // Calculate the finish date
        Days maxTaskDurationDays = ProjWorkBreakdownStructureHelper::getMaxTaskDurationDays();
        if (_node.TaskDuration > maxTaskDurationDays)
        {
            _node.TaskFinishDate = ProjPlanVersion::findEndDateForDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
        }
        else
        {
            _node.TaskFinishDate = WorkCalendarCalculator::findEndDateForStartDateAndDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
        }

        Hours previousEffort = _node.TaskEffort;
        if (_autoScheduling)
        {
            // Calculate the effort
            _node.TaskEffort = ProjPlanVersion::calcTaskEffortHours(_node, _calendarId, _calendarStandardWorkDayHours);
            _node.TaskEffortAtComplete = _node.TaskEffort;
            _node.TaskEffortToComplete = _node.TaskEffort;

            // Recompute the duration from the start date and finish date
            _node.TaskDuration = ProjPlanVersion::calcTaskDurationDays(_node, _calendarStandardWorkDayHours);
        }
        
        if (ProjPlanVersion::validateDateChangesForSuccessors(_calendarId, _node))
        {
            ttsbegin;
            _node.update();

            ProjWBSType typeOfWBS = ProjPlanVersionDetail::findByHierarchyId(_node.HierarchyId).getWBSType();
            ProjEstimate::syncEstimateLinesFromTask(_node.HierarchyId, _node.HierarchyTaskId, typeOfWBS);

            if (_node.TaskEffort != previousEffort)
            {
                _node.reread();
                ProjPlanVersion::updateCostAtCompleteV2(_node);
            }

            ProjPlanVersion::updateStartDateForSuccessors(_calendarId, _node);
            ProjPlanVersion::rollUpToParent(_calendarId, _node);
            ttscommit;
        }
        else
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUserChangeEffortV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles validation and propagation of the user modifying the task effort.
    /// </summary>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_node">Task whose effort was modified.</param>
    /// <param name = "_autoScheduling">Whether auto scheduling is turned on.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <returns>True if the modification was valid; otherwise, false.</returns>
    public static boolean postUserChangeEffortV2(CalendarId _calendarId, ProjPlanVersion _node,
        boolean _autoScheduling, Hours _calendarStandardWorkDayHours)
    {
        boolean valid = true;

        // If this is a summary task, changing the effort is not allowed
        if (!_node.EndNode)
        {
            _node.TaskEffort = _node.orig().TaskEffort;
            warning("@ProjPlan:SummaryTaskEffortCannotBeChanged");
            valid = false;
        }

        if (valid)
        {
            // Effort cannot be less than zero
            _node.TaskEffort = max(0.0, _node.TaskEffort);
            _node.TaskEffortAtComplete = _node.TaskEffort;
            _node.TaskEffortToComplete = _node.TaskEffort;
            
            if (_autoScheduling)
            {
                // Calculate duration (rounded up to whole number)
                _node.TaskDuration = ProjPlanVersion::calcTaskDurationDays(_node, _calendarStandardWorkDayHours);

                // Calendar ID is not expected in case of WBS template
                if (_calendarId)
                {
                    Days maxTaskDurationDays = ProjWorkBreakdownStructureHelper::getMaxTaskDurationDays();
                    if (_node.TaskDuration > maxTaskDurationDays)
                    {
                        _node.TaskFinishDate = ProjPlanVersion::findEndDateForDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
                    }
                    else
                    {
                        // Calculate the finish date
                        _node.TaskFinishDate = WorkCalendarCalculator::findEndDateForStartDateAndDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
                    }
         
                    TransDate maxCalendarDate = ProjPlanVersion::getMaxCalendarDate(_calendarId);
                    if (_node.TaskFinishDate > maxCalendarDate)
                    {
                        // Recompute effort hours
                        _node.TaskEffort = ProjPlanVersion::calcTaskEffortHours(_node, _calendarId, _calendarStandardWorkDayHours);
                        _node.TaskEffortAtComplete = _node.TaskEffort;
                        _node.TaskEffortToComplete = _node.TaskEffort;

                        // Recompute the duration from the start date and finish date
                        _node.TaskDuration = ProjPlanVersion::calcTaskDurationDays(_node, _calendarStandardWorkDayHours);
                    }
                }
            }

           if (ProjPlanVersion::validateDateChangesForSuccessors(_calendarId, _node))
            {
                ttsbegin;
                _node.update();
                _node.reread();

                ProjWBSType typeOfWBS = ProjPlanVersionDetail::findByHierarchyId(_node.HierarchyId).getWBSType();
                ProjEstimate::syncEstimateLinesFromTask(_node.HierarchyId, _node.HierarchyTaskId, typeOfWBS);
                ProjPlanVersion::updateCostAtCompleteV2(_node);

                ProjPlanVersion::updateStartDateForSuccessors(_calendarId, _node);
                ProjPlanVersion::rollUpToParent(_calendarId, _node);
                ttscommit;
            }
            else
            {
                valid = false;
            }
        }
        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUserChangeNumberOfResourcesV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles validation and propagation of the user modifying the task number of resources.
    /// </summary>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_node">Task whose number of resources was modified.</param>
    /// <param name = "_autoScheduling">Whether auto scheduling is turned on.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <returns>True if the modification was valid; otherwise, false.</returns>
    public static boolean postUserChangeNumberOfResourcesV2(CalendarId _calendarId, ProjPlanVersion _node,
        boolean _autoScheduling, Hours _calendarStandardWorkDayHours)
    {
        boolean valid = true;

        // If this is asummary task, changing the number of resources is not allowed
        if (!_node.EndNode)
        {
            _node.NumberOfResources = _node.orig().NumberOfResources;
            warning("@ProjPlan:SummaryTaskNumberOfResourcesCannotBeChanged");
            valid = false;
        }

        if (valid)
        {
            // Number of resources must be greater than zero
            if (_node.NumberOfResources <= 0.0)
            {
                _node.NumberOfResources = 1.0;
            }

            if (_autoScheduling)
            {
                // Calculate duration (round up to whole number) and finish date
                _node.TaskDuration = ProjPlanVersion::calcTaskDurationDays(_node, _calendarStandardWorkDayHours);

                Days maxTaskDurationDays = ProjWorkBreakdownStructureHelper::getMaxTaskDurationDays();
                if (_node.TaskDuration > maxTaskDurationDays)
                {
                    _node.TaskFinishDate = ProjPlanVersion::findEndDateForDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
                }
                else
                {
                    _node.TaskFinishDate = WorkCalendarCalculator::findEndDateForStartDateAndDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
                }

                // Recompute the effort from the start date, finish date and number of resources
                _node.TaskEffort = ProjPlanVersion::calcTaskEffortHours(_node, _calendarId, _calendarStandardWorkDayHours);
                _node.TaskEffortAtComplete = _node.TaskEffort;
                _node.TaskEffortToComplete = _node.TaskEffort;

                // Recompute the duration from the start date and finish date
                _node.TaskDuration = ProjPlanVersion::calcTaskDurationDays(_node, _calendarStandardWorkDayHours);
            }

            if (ProjPlanVersion::validateDateChangesForSuccessors(_calendarId, _node))
            {
                ttsbegin;
                _node.update();
                _node.reread();

                ProjWBSType typeOfWBS = ProjPlanVersionDetail::findByHierarchyId(_node.HierarchyId).getWBSType();
                ProjEstimate::syncEstimateLinesFromTaskV2(_node.HierarchyId, _node.HierarchyTaskId, typeOfWBS);
                ProjPlanVersion::updateCostAtCompleteV2(_node);

                ProjPlanVersion::updateStartDateForSuccessors(_calendarId, _node);
                ProjPlanVersion::rollUpToParent(_calendarId, _node);
                ttscommit;
            }
            else
            {
                valid = false;
            }

        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUserChangeStartDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles validation and propagation of the user modifying the task start date for the given task.
    /// </summary>
    /// <param name = "_node">Task whose start date has been modified.</param>
    /// <returns>Whether the modification was valid. If it was not, the start date will have been reverted to orig().TaskStartDate.</returns>
    public static boolean postUserChangeStartDate(CalendarId _calendarId, ProjPlanVersion _node)
    {
        // If this is a summary task, changing the start date is not allowed
        if (!_node.EndNode)
        {
            _node.TaskStartDate = _node.orig().TaskStartDate;
            return checkFailed("@ProjPlan:SummaryTaskStartDateCannotBeChanged");
        }

        // Ensure that start date is earlier than the max calenadr date
        TransDate maxCalendarDate = ProjPlanVersion::getMaxCalendarDate(_calendarId);
        if (_node.TaskStartDate > maxCalendarDate)
        {
            date nonWorkingDate = _node.TaskStartDate;
            _node.TaskStartDate = _node.orig().TaskStartDate;
            return checkFailed(strFmt("@ProjPlan:DateIsNotAWorkingDay", date2StrUsr(nonWorkingDate, DateFormat::Auto)));
        }

        // Ensure that the date is a valid working day
        WorkCalendarSched workCalendarSched = new WorkCalendarSched();
        if (!workCalendarSched.isDateOpen(_calendarId, _node.TaskStartDate))
        {
            date nonWorkingDate = _node.TaskStartDate;
            _node.TaskStartDate = _node.orig().TaskStartDate;
            return checkFailed(strFmt("@ProjPlan:DateIsNotAWorkingDay", date2StrUsr(nonWorkingDate, DateFormat::Auto)));
        }
        
        // If this node has predecessors, changing the start date is not allowed
        if (_node.isSuccessor())
        {
            _node.TaskStartDate = _node.orig().TaskStartDate;
            return checkFailed("@ProjPlan:SuccessorTaskStartDateCannotBeChanged");
        }

        // Recompute the finish date from the duration
        Days maxTaskDurationDays = ProjWorkBreakdownStructureHelper::getMaxTaskDurationDays();
        if (_node.TaskDuration > maxTaskDurationDays)
        {
            _node.TaskFinishDate = ProjPlanVersion::findEndDateForDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
        }
        else
        {
            _node.TaskFinishDate = WorkCalendarCalculator::findEndDateForStartDateAndDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
        }

        if (_node.TaskFinishDate > maxCalendarDate)
        {
            // Recompute the effort hours from the start date, finish date and number of resources
            Hours calendarStandardWorkDayHours = ProjWorkBreakdownStructureV2FormHelper::getCalendarStandardWorkDayHours(_calendarId);
            _node.TaskEffort = ProjPlanVersion::calcTaskEffortHours(_node, _calendarId, calendarStandardWorkDayHours);
            _node.TaskEffortAtComplete = _node.TaskEffort;
            _node.TaskEffortToComplete = _node.TaskEffort;

            // Recompute the duration from the start date and finish date
            _node.TaskDuration = ProjPlanVersion::calcTaskDurationDays(_node, calendarStandardWorkDayHours);
        }

        if (ProjPlanVersion::validateDateChangesForSuccessors(_calendarId, _node))
        {
            ttsbegin;
            _node.update();
            _node.reread();

            ProjWBSType typeOfWBS = ProjPlanVersionDetail::findByHierarchyId(_node.HierarchyId).getWBSType();
            ProjEstimate::syncEstimateLinesFromTaskV2(_node.HierarchyId, _node.HierarchyTaskId, typeOfWBS);
            ProjPlanVersion::updateCostAtCompleteV2(_node);

            ProjPlanVersion::updateStartDateForSuccessors(_calendarId, _node);
            ProjPlanVersion::rollUpToParent(_calendarId, _node);
            ttscommit;
        }
        else
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUserChangeFinishDateV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles validation and propagation of the user modifying the task finish date for the given task.
    /// </summary>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_node">Task whose finish date has been modified.</param>
    /// <param name = "_autoScheduling">Whether auto scheduling is turned on.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <returns>Whether the modification was valid. If it was not, the finish date will have been reverted to orig().TaskFinishDate.</returns>
    public static boolean postUserChangeFinishDateV2(CalendarId _calendarId, ProjPlanVersion _node,
        boolean _autoScheduling, Hours _calendarStandardWorkDayHours)
    {
        boolean valid = true;

        // Changing the end date earlier than the start date is not allowed
        if (_node.TaskFinishDate < _node.TaskStartDate)
        {
            _node.TaskFinishDate = _node.orig().TaskFinishDate;
            valid = checkFailed("@ProjPlan:StartDateGreaterThanEndDateWarning");
        }

        // If this is a summary task, changing the finish date is not allowed
        if (valid && !_node.EndNode)
        {
            _node.TaskFinishDate = _node.orig().TaskFinishDate;
            valid = checkFailed("@ProjPlan:SummaryTaskEndDateCannotBeChanged");
        }
  
        if (valid)
        {
            // Ensure that the date is a valid working day
            WorkCalendarSched workCalendarSched = new WorkCalendarSched();
            if (!workCalendarSched.isDateOpen(_calendarId, _node.TaskFinishDate))
            {
                date nonWorkingDate = _node.TaskFinishDate;
                _node.TaskFinishDate = _node.orig().TaskFinishDate;
                return checkFailed(strFmt("@ProjPlan:DateIsNotAWorkingDay", date2StrUsr(nonWorkingDate, TimeFormat::Auto)));
            }
        
            Hours previousEffort = _node.TaskEffort;
            if (_autoScheduling)
            {
                // Recompute the effort from the start date, finish date and number of resources
                _node.TaskEffort = ProjPlanVersion::calcTaskEffortHours(_node, _calendarId, _calendarStandardWorkDayHours);
                _node.TaskEffortAtComplete = _node.TaskEffort;
                _node.TaskEffortToComplete = _node.TaskEffort;

                // Recompute the duration from the start date and finish date
                _node.TaskDuration = ProjPlanVersion::calcTaskDurationDays(_node, _calendarStandardWorkDayHours);
            }
            else
            {
                // When auto scheduling is turn off, the duration will be calculated differently.
                _node.TaskDuration = WorkCalendarCalculator::calcDuration(_node.TaskStartDate, _node.TaskFinishDate, _calendarId);
            }
  
            if (ProjPlanVersion::validateDateChangesForSuccessors(_calendarId, _node))
            {
                ttsbegin;
                _node.update();

                ProjWBSType typeOfWBS = ProjPlanVersionDetail::findByHierarchyId(_node.HierarchyId).getWBSType();
                ProjEstimate::syncEstimateLinesFromTaskV2(_node.HierarchyId, _node.HierarchyTaskId, typeOfWBS, _autoScheduling);

                if (_node.TaskEffort != previousEffort)
                {
                    _node.reread();
                    ProjPlanVersion::updateCostAtCompleteV2(_node);
                }

                // Apply changes to dependent tasks
                ProjPlanVersion::updateStartDateForSuccessors(_calendarId, _node);
                ProjPlanVersion::rollUpToParent(_calendarId, _node);
                ttscommit;
            }
            else
            {
                valid = false;
            }
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaskEffortHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the available working hours in the specified date interval.
    /// </summary>
    /// <param name = "_node">Task whose effort hours to be calculated.</param>
    /// <param name="_calendarId">The ID of the calendar to use.</param>
    /// <param name = "_calendarStandardWorkDayHours">Standard calendar work day hours.</param>
    /// <returns>The number of effort hours.</returns>
    public static Hours calcTaskEffortHours(ProjPlanVersion _node, CalendarId _calendarId, Hours _calendarStandardWorkDayHours)
    {
        Hours durationInHours = 0;

        if (_node.TaskFinishDate >= _node.TaskStartDate && _node.NumberOfResources && _calendarId && _calendarStandardWorkDayHours)
        {
            Days duration  = 0;

            // Limit the length of the WBS task scheduling date interval to 5 years for effort hours calculation via Calendar API.
            // Else system may run into out of memory exception or calculation may take too long to response back to client.
            // In case of more than 5 years, open days count logic will be used instead of calendar API.
            Year maxTaskEffortLengthInYears = ProjWorkBreakdownStructureHelper::getMaxTaskEffortLengthInYears();

            // Determine task finish date either max configured date or date after 20 years from now whichever is less
            TransDate maxCalendarDate = ProjPlanVersion::getMaxCalendarDate(_calendarId);
            _node.TaskFinishDate = _node.TaskFinishDate > maxCalendarDate ? maxCalendarDate : _node.TaskFinishDate;

            // If the task end date is larger than the max task effort length in years constant,
            // then limit the task finish date according to the max task effort length in years constant
            // for task effort hours calculation and set the task finish date accordingly.

            if (yearDiff(_node.TaskFinishDate, _node.TaskStartDate) > maxTaskEffortLengthInYears)
            {
                duration = ProjPlanVersion::countDuration(_node, _calendarId);
            }
            else
            {
                WorkCalendarSched workCalendarSched = new WorkCalendarSched();

                for (TransDate transDate = _node.TaskStartDate; transDate <= _node.TaskFinishDate; transDate++)
                {
                    if (workCalendarSched.isDateOpen(_calendarId, transDate))
                    {
                        duration++;
                    }
                }
            }
            
            durationInHours = _calendarStandardWorkDayHours * duration * _node.NumberOfResources;
        }

        return durationInHours;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaskDurationDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the task duration days by task effort hours, number of resources and the calendar standard work day hours.
    /// The minimum task duration days value is 1.0.
    /// </summary>
    /// <param name = "_node">Task whose duration days to be calculated.</param>
    /// <param name = "_calendarStandardWorkDayHours">Standard calendar work day hours.</param>
    /// <returns>Task duration days.</returns>
    public static DaysAsReal calcTaskDurationDays(ProjPlanVersion _node, Hours _calendarStandardWorkDayHours)
    {
        DaysAsReal taskDurationDays = 1.0;

        if (_node.TaskEffort && _node.NumberOfResources && _calendarStandardWorkDayHours)
        {
            taskDurationDays = roundUpDec(_node.TaskEffort / _node.NumberOfResources / _calendarStandardWorkDayHours, 0);
        }

        return taskDurationDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaskDurationDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if the task duration days is validate according to the task effort hours, number of resources and the calendar standard work day hours.
    /// </summary>
    /// <param name = "_node">Task to be validated.</param>
    /// <param name = "_calendarStandardWorkDayHours">Standard calendar work day hours.</param>
    /// <returns>true represents scheduling has no error; otherwise, false.</returns>
    public static boolean validateTaskDurationDays(ProjPlanVersion _node, Hours _calendarStandardWorkDayHours)
    {
        boolean valid = true;

        if (_node.EndNode == FalseTrue::True && _node.NumberOfResources && _calendarStandardWorkDayHours)
        {
            valid = _node.TaskDuration == ProjPlanVersion::calcTaskDurationDays(_node, _calendarStandardWorkDayHours);
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rollUpToParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the start/finish date and effort for the parent of the given task.
    /// </summary>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_node">The task whose parent to update.</param>
    public static void rollUpToParent(CalendarId _calendarId, ProjPlanVersion _node)
    {
        ProjWBSType wbsType = ProjPlanVersionDetail::findByHierarchyId(_node.HierarchyId).getWBSType();
        ProjWorkBreakdownStructureV2FormHelper::updateCorrespondingTaskRecord(_node, wbsType);

        // If we don't have a parent to update
        if (_node.isRoot())
        {
            // If the project is a Quotation, we need to update the start and end date of the SalesQuotationTable to match the root
            if (wbsType == ProjWBSType::ProjectQuotation)
            {
                SalesQuotationTable salesQuotationTable = HierarchyLinkTable::findAssociation(_node.HierarchyId, tableNum(SalesQuotationTable)) as SalesQuotationTable;

                if (salesQuotationTable.psaEstProjStartDate != _node.TaskStartDate || salesQuotationTable.psaEstProjEndDate != _node.TaskFinishDate)
                {
                    ttsbegin;
                    salesQuotationTable.selectForUpdate(true);
                    salesQuotationTable.psaEstProjStartDate = _node.TaskStartDate;
                    salesQuotationTable.psaEstProjEndDate = _node.TaskFinishDate;
                    salesQuotationTable.update();
                    ttscommit;
                }
            }

            return;
        }

        ProjPlanVersion parent = ProjPlanVersion::findByHierarchyAndTaskId(_node.HierarchyId, _node.ParentHierarchyTaskId, true);
        if (parent)
        {
            ProjPlanVersion::updateFromChildren(_calendarId, parent);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFromChildren</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the start/finish dates, effort, and duration for this task based on the children of this task.
    /// </summary>
    /// <param name = "_calendarId">The Id of the calendar for this task.</param>
    /// <param name = "_node">The task to update.</param>
    public static void updateFromChildren(CalendarId _calendarId, ProjPlanVersion _node)
    {
        // If this task is an end node, don't bother updating from children
        if (_node.EndNode == FalseTrue::True)
        {
            return;
        }

        ProjPlanVersion children;
        select minof(TaskStartDate), maxof(TaskFinishDate), sum(TaskEffort), sum(TaskEffortAtComplete),
            sum(TaskEffortToComplete), sum(TaskCostAtComplete) from children
        where children.HierarchyId == _node.HierarchyId
            && children.ParentHierarchyTaskId == _node.HierarchyTaskId;

        // If this has no effect on the parent, don't bother to continue
        if (_node.TaskStartDate == children.TaskStartDate && _node.TaskFinishDate == children.TaskFinishDate && _node.TaskEffort == children.TaskEffort
            && _node.TaskEffortAtComplete == children.TaskEffortAtComplete && _node.TaskEffortToComplete == children.TaskEffortToComplete
            && _node.TaskCostAtComplete == children.TaskCostAtComplete)
        {
            return;
        }

        ttsbegin;
        _node.reread();
        _node.TaskStartDate = children.TaskStartDate;
        _node.TaskFinishDate = children.TaskFinishDate;
        if (_calendarId)
        {
            _node.TaskDuration = WorkCalendarCalculator::calcDuration(_node.TaskStartDate, _node.TaskFinishDate, _calendarId);
        }
        else
        {
            _node.TaskDuration = _node.TaskFinishDate - _node.TaskStartDate + 1;
        }
        _node.TaskEffort = children.TaskEffort;
        _node.TaskEffortAtComplete = children.TaskEffortAtComplete;
        _node.TaskEffortToComplete = children.TaskEffortToComplete;
        _node.TaskCostAtComplete = children.TaskCostAtComplete;
        _node.update();

        ProjPlanVersion::updateStartDateForSuccessors(_calendarId, _node);
        ProjPlanVersion::rollUpToParent(_calendarId, _node);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStartDateForSuccessors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the start date for all successors of the given task.
    /// </summary>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_node">Task whose successors to update.</param>
    public static void updateStartDateForSuccessors(CalendarId _calendarId, ProjPlanVersion _node)
    {
        // Update start date for all sucessors
        ProjDependency edge;
        while select edge
            where edge.ProjPlanHierarchyId == _node.HierarchyId
            && edge.PredecessorHierarchyTaskId == _node.HierarchyTaskId
        {
            ProjPlanVersion successor = ProjPlanVersion::findByHierarchyAndTaskId(edge.ProjPlanHierarchyId, edge.SuccessorHierarchyTaskId, true);
            ProjPlanVersion::updateStartDateFromPredecessors(_calendarId, successor);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStartDateFromPredecessors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the start date of the given task to be the max of its predecessors.
    /// </summary>
    /// <param name = "_calendarId">Id of the calendar for this hierarhy.</param>
    /// <param name = "_node">The task to recalculate start date for.</param>
    public static void updateStartDateFromPredecessors(CalendarId _calendarId, ProjPlanVersion _node)
    {
        // Get max end date among predecessors
        ProjPlanVersion predecessor;
        ProjDependency predecessorEdge;
        select maxof(TaskFinishDate) from predecessor
         exists join predecessorEdge where
             predecessorEdge.ProjPlanHierarchyId == _node.HierarchyId
             && predecessor.HierarchyId == _node.HierarchyId
             && predecessorEdge.PredecessorHierarchyTaskId == predecessor.HierarchyTaskId
                && predecessorEdge.SuccessorHierarchyTaskId == _node.HierarchyTaskId;

        SchedToDate finishDate = WorkCalendarCalculator::findNextWorkDayAfterDate(_calendarId, predecessor.TaskFinishDate);
        if (!predecessor || _calendarId == '' || finishDate == _node.TaskStartDate)
        {
            // Nothing to do
            return;
        }

        // Update start date from predecessor finish date
        _node.reread();
        _node.TaskStartDate = finishDate;

        Days maxTaskDurationDays = ProjWorkBreakdownStructureHelper::getMaxTaskDurationDays();
        if (_node.TaskDuration > maxTaskDurationDays)
        {
            _node.TaskFinishDate = ProjPlanVersion::findEndDateForDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
        }
        else
        {
            _node.TaskFinishDate = WorkCalendarCalculator::findEndDateForStartDateAndDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
        }

        // Remove invalid predecessor which may cause successor end date to be greater than max allow date.
        TransDate maxFinishDate = ProjPlanVersion::getMaxCalendarDate(_calendarId);
        if (_node.TaskFinishDate > maxFinishDate)
        {
            _node.validateAndRemoveInvalidPredecessor(_node, _calendarId, maxFinishDate);   
        }

        ttsbegin;
        _node.update();
        ProjPlanVersion::updateStartDateForSuccessors(_calendarId, _node);
        ProjPlanVersion::rollUpToParent(_calendarId, _node);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDateChangesForSuccessors</Name>
				<Source><![CDATA[
    protected static boolean validateDateChangesForSuccessors(CalendarId _calendarId, ProjPlanVersion _node)
    {
        TransDate maxFinishDate = ProjPlanVersion::getMaxCalendarDate(_calendarId);

        boolean valid = ProjPlanVersion::validateDateChangesForSuccessorsOperation(_calendarId, maxFinishDate, _node.HierarchyId, _node.HierarchyTaskId, _node.TaskFinishDate);

        if (!valid)
        {
            _node.TaskEffort = _node.orig().TaskEffort;
            _node.TaskEffortAtComplete = _node.orig().TaskEffortAtComplete;
            _node.TaskEffortToComplete = _node.orig().TaskEffortToComplete;
            _node.TaskDuration = _node.orig().TaskDuration;
            _node.TaskFinishDate = _node.orig().TaskFinishDate;
            _node.TaskStartDate = _node.orig().TaskStartDate;
            _node.NumberOfResources = _node.orig().NumberOfResources;
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDateChangesForSuccessorsOperation</Name>
				<Source><![CDATA[
    protected static boolean validateDateChangesForSuccessorsOperation(CalendarId _calendarId, date _maxCalendarDate, HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId, Date _taskFinishDate)
    {
        boolean valid = true;

        // Skips the validation in case of WBS template.
        if (!ProjPlanVersionDetail::isTemplateHierarchy(_hierarchyId))
        {
            ProjPlanVersion successor;
            // If any successor start or finish date will be greater than maximum calendar date, then it will return false.
            ProjDependency edge;
            while select edge
                where edge.ProjPlanHierarchyId == _hierarchyId &&
                    edge.PredecessorHierarchyTaskId == _taskId
            {
                successor = ProjPlanVersion::findByHierarchyAndTaskId(edge.ProjPlanHierarchyId, edge.SuccessorHierarchyTaskId);
            
                if (successor)
                {
                    Date successorNewStartDate = WorkCalendarCalculator::findNextWorkDayAfterDate(_calendarId, _taskFinishDate);

                    if (successorNewStartDate > _maxCalendarDate)
                    {
                        valid = checkFailed(strFmt("@ProjPlan:RollBackTaskChangeForInvalidSuccessor", successor.TaskName, date2StrUsr(_maxCalendarDate, DateFormat::Auto)));
                        break;
                    }

                    date successorNewFinishDate = WorkCalendarCalculator::findEndDateForStartDateAndDuration(successorNewStartDate, successor.TaskDuration, _calendarId);
                
                    if (successorNewFinishDate > _maxCalendarDate)
                    {
                        valid = checkFailed(strFmt("@ProjPlan:RollBackTaskChangeForInvalidSuccessor", successor.TaskName, date2StrUsr(_maxCalendarDate, DateFormat::Auto)));
                        break;
                    }

                    if (valid)
                    {
                        valid = ProjPlanVersion::validateDateChangesForSuccessorsOperation(_calendarId, _maxCalendarDate, successor.HierarchyId, successor.HierarchyTaskId, successorNewFinishDate);
                    }
                }            
            }
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether this task record is the hierarchy root.
    /// </summary>
    /// <returns>True if this record is the hierarchy root; otherwise false.</returns>
    public boolean isRoot()
    {
        return this.ParentHierarchyTaskId == 0 && this.HierarchyLevel == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaskDefaultsV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets default values for fields of this record. It is expected that '.insert()' has already been called.
    /// </summary>
    /// <param name = "_calendarId">Id of the calendar for the hierarchy the task is a part of.</param>
    /// <param name = "_wbsType">The type of WBS for the hierarchy.</param>
    /// <param name = "_parent">Parent task of the task.</param>
    /// <param name = "_task">The task to set defaults on.</param>
    /// <param name = "_autoScheduling">Whether auto scheduling should be enabled.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    public static void setTaskDefaultsV2(
        CalendarId _calendarId,
        ProjWBSType _wbsType,
        ProjPlanVersion _parent,
        ProjPlanVersion _task,
        boolean _autoScheduling,
        Hours _calendarStandardWorkDayHours)
    {
        StartDate startDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        EndDate endDate = startDate;
        DaysAsReal duration = 0;
        Hours effort = 0;

        // Add task record
        _task.TaskStartDate = startDate;
        _task.TaskFinishDate = endDate;
        _task.NumberOfResources = 1.0;
        _task.TaskCategory = ProjPlanVersion::defaultTaskCategory(_task.HierarchyId);
        _task.EndNode = FalseTrue::True;
        _task.TaskSchedulingStatus = PSAScheduled::NotScheduled;
        _task.TaskAssignedHours = 0;

        // If the wbs is a template, ignore parent dates
        if (_wbsType != ProjWBSType::Template)
        {
            if (_parent)
            {
                _task.TaskStartDate = _parent.TaskStartDate;
                _task.TaskFinishDate = _parent.TaskFinishDate;

                if (_autoScheduling && _parent.isRoot() && _parent.TaskEffort == 0)
                {
                    effort = _calendarStandardWorkDayHours;
                }
            }

            duration = WorkCalendarCalculator::calcDuration(_task.TaskStartDate, _task.TaskFinishDate, _calendarId);

            if (_autoScheduling && effort == 0)
            {
                effort = ProjPlanVersion::calcTaskEffortHours(_task, _calendarId, _calendarStandardWorkDayHours);
            }
        }

        // Set task effort and duration
        _task.TaskEffort = effort;
        _task.TaskEffortAtComplete = effort;
        _task.TaskEffortToComplete = effort;
        _task.TaskDuration = duration;

        // Update estimates for the given task
        ttsbegin;
        _task.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEndNodeStateV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Helper method which implements required side effects of setting a task to be an end-node/not an end-node.
    /// </summary>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_wbsType">Type of the current WBS.</param>
    /// <param name = "_task">The task being set.</param>
    /// <param name = "_endNodeState">End node value to set on the task.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <param name = "_manualEffort">Custom effort value to set, to bypass calculation. This effort is assumed to be valid for the current Start and End date.</param>
    public static void setEndNodeStateV2(
        CalendarId _calendarId,
        ProjWBSType _wbsType,
        ProjPlanVersion _task,
        FalseTrue _endNodeState,
        Hours _calendarStandardWorkDayHours,
        Hours _manualEffort = -1)
    {
        if (_task.EndNode == _endNodeState)
        {
            return;
        }

        ttsbegin;
        _task.EndNode = _endNodeState;

        // If the task is made into a summary task, must delete all predecessors
        if (_endNodeState == FalseTrue::False)
        {
            _task.TaskCategory = "";
            _task.NumberOfResources = 0.0;

            // Delete all predecessor edges for this task
            ProjDependency predecessorToDelete;
            delete_from predecessorToDelete where
                predecessorToDelete.ProjPlanHierarchyId == _task.HierarchyId
                && predecessorToDelete.SuccessorHierarchyTaskId == _task.HierarchyTaskId;
        }
        else
        {
            _task.NumberOfResources = 1.0;

            // If a custom effort is set, just use that instead of calculating
            if (_manualEffort >= 0.0)
            {
                _task.TaskEffort = _manualEffort;
            }
            else
            {
                _task.TaskEffort = ProjPlanVersion::calcTaskEffortHours(_task, _calendarId, _calendarStandardWorkDayHours);
            }

            if (_calendarId)
            {
                _task.TaskDuration = WorkCalendarCalculator::calcDuration(_task.TaskStartDate, _task.TaskFinishDate, _calendarId);
            }
            else
            {
                _task.TaskDuration = _task.TaskFinishDate - _task.TaskStartDate + 1;
            }

            _task.TaskEffortAtComplete = _task.TaskEffort;
            _task.TaskEffortToComplete = _task.TaskEffort;
            _task.TaskCategory = ProjPlanVersion::defaultTaskCategory(_task.HierarchyId);
            _task.TaskSchedulingStatus = PSAScheduled::NotScheduled;
            _task.TaskAssignedHours = 0;
        }
        _task.update();

        // Synchronize estimate lines
        ProjEstimate::syncEstimateLinesFromTask(_task.HierarchyId, _task.HierarchyTaskId, _wbsType);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTaskCategory</Name>
				<Source><![CDATA[
    private static str defaultTaskCategory(HierarchyIdBase _hierarchyId)
    {
        boolean validateCategories = false;
        ProjParameters projParams = ProjParameters::find();
        ProjTable projTable = ProjPlanVersion::findProjectAssociatedWithHierarchy(_hierarchyId);
        if (projTable)
        {
            boolean projCategoryMandatory = projParams.ValidationProjCategory == ProjValParameter::Mandatory;
            validateCategories = projCategoryMandatory && projTable.ValidateProjCategory;
        }

        str projDefaultCategory;
        if (!validateCategories)
        {
            projDefaultCategory = projParams.EmplCategory;
        }
        else
        {
            ProjProjectCategoryAssoc validationView;

            // Check if the ProjParams default category is enabled for this project
            select firstonly RecId from validationView
            where validationView.ProjId == projTable.ProjId
                && validationView.CategoryId == projParams.EmplCategory;
            
            // If it is, use that
            if (validationView)
            {
                projDefaultCategory = projParams.EmplCategory;
            }
            // Otherwise, just pick the first category enabled for this project
            else
            {
                ProjCategory categories;

                select firstonly CategoryId from validationView                    
                    where validationView.ProjId == projTable.ProjId
                exists join categories
                where validationView.CategoryId == categories.CategoryId
                    && categories.CategoryType == ProjCategoryType::Hour;

                projDefaultCategory = validationView.CategoryId;
            }
        }

        return projDefaultCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingEffortHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get remaining unassigned effort hours.
    /// </summary>
    /// <returns>Remaining assigned effort hours.</returns>
    public Hours getRemainingEffortHours()
    {
        Hours remainingEffortHours = this.TaskEffort - this.TaskAssignedHours;

        // Remaining effort hours should not be less than 0.
        if (remainingEffortHours <= 0)
        {
            remainingEffortHours = 0;
        }
        return remainingEffortHours;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaskSchedulingStatus</Name>
				<Source><![CDATA[
    private boolean calculateTaskSchedulingStatus()
    {
        boolean         updateSchedulingStatus = false;
        ProjPlanVersionDetail planVersionDetail = ProjPlanVersionDetail::findByHierarchyId(this.HierarchyId);
        PSAScheduled schedulingStatus = this.TaskSchedulingStatus;
        
        // To support WBS and WBSV2, end node will be calculated differently depending on the plan version data.
        // For the case of WBS, HierarchyLevel field will not be set. Hence use the backward compatible method isSummaryTask() to find out if this is an EndNode task.
        // For the case of WBSV2, both HierarchyLevel and EndNode fields will be set and can be use as is.
        boolean isEndNode = false;
        if (this.ParentHierarchyTaskId)
        {
            if (this.HierarchyLevel)
            {
                isEndNode = this.EndNode;
            }
            else
            {
                isEndNode = !ProjPlanVersion::isSummaryTask(this.HierarchyId, this.HierarchyTaskId);
            }
        }
        
        if (isEndNode && (planVersionDetail.VersionType == ProjPlanVersionType::Draft)
            && !ProjPlanVersionAssignment::hasProjPlanVersion(this.RecId))
        {
            ResCommitType commitType = planVersionDetail.ProjId ? ResCommitType::HardBook : ResCommitType::SoftBook;

            SchedFromDate origStartDate = this.orig().TaskStartDate;
            SchedToDate origEndDate = this.orig().TaskFinishDate;
            Hours origEffort = this.orig().TaskEffort;
            
            if ((this.TaskStartDate > origEndDate)
                || (this.TaskFinishDate < origStartDate))
            {
                updateSchedulingStatus = true;
                this.TaskSchedulingStatus = PSAScheduled::NotScheduled;
                this.TaskAssignedHours = ActivityFacade::getAssignedCapacityByDateTimeRangeInHours(
                    ProjPlanVersion::getActivityRecId(this.HierarchyId, this.HierarchyTaskId),
                    commitType, false,
                    DateTimeUtil::newDateTime(this.TaskStartDate, 0),
                    DateTimeUtil::newDateTime(this.TaskFinishDate, #LastSecondOfTheDay));
            }
            else if ((this.TaskStartDate < origStartDate)
                || (this.TaskFinishDate > origEndDate)
                || (this.TaskEffort != origEffort))
            {
                updateSchedulingStatus = true;
                this.TaskAssignedHours = ActivityFacade::getAssignedCapacityByDateTimeRangeInHours(
                    ProjPlanVersion::getActivityRecId(this.HierarchyId, this.HierarchyTaskId),
                    commitType, false,
                    DateTimeUtil::newDateTime(this.TaskStartDate, 0),
                    DateTimeUtil::newDateTime(this.TaskFinishDate, #LastSecondOfTheDay));
                if (this.TaskEffort == 0 || this.TaskAssignedHours == 0)
                {
                    this.TaskSchedulingStatus = PSAScheduled::NotScheduled;
                    this.TaskAssignedHours = 0;
                }
                else if (this.TaskEffort > this.TaskAssignedHours)
                {
                    this.TaskSchedulingStatus = PSAScheduled::PartiallyScheduled;
                }
                else if (this.TaskEffort <= this.TaskAssignedHours)
                {
                    this.TaskSchedulingStatus = PSAScheduled::FullyScheduled;
                }
            }
        }

        return updateSchedulingStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the task scheduling status and task assigned hours which caused by the change of task start date, finish date and effort hours.
    /// When scheduling status is recalculated, it will recalculated for the entire WBS starting from the parent task to the root if necessary.
    /// Scheduling status will only be recalculated if:
    /// 1. This activity is an end node.
    /// 2. This WBS is in draft (which will be calculated for both Project in draft and Quotation).
    /// 3. Scheduling status is not in not scheduled status.
    /// 4. There is no draft assignment for this task. Reason is upon draft assignment, the scheduling status has already been calculated.
    /// </summary>
    public void update()
    {
        PSAScheduled origSchedulingStatus = this.orig().TaskSchedulingStatus;
        Hours origAssignedHours = this.orig().TaskAssignedHours;
        ProjPlanVersionDetail planVersionDetail = ProjPlanVersionDetail::findByHierarchyId(this.HierarchyId);

        boolean updatedSchedulingStatus = false;
        if (this.TaskStartDate != this.orig().TaskStartDate
            || this.TaskFinishDate != this.orig().TaskFinishDate
            || this.TaskEffort != this.orig().TaskEffort)
        {
            updatedSchedulingStatus = this.calculateTaskSchedulingStatus();
        }

        super();

        if (updatedSchedulingStatus && (this.TaskSchedulingStatus != origSchedulingStatus || this.TaskAssignedHours != origAssignedHours))
        {
            ProjPlanVersion parentTask = ProjPlanVersion::findByHierarchyAndTaskId(this.hierarchyId, this.parentHierarchyTaskId, true);
            ProjActivityCapacity::updateSummaryTaskSchedulingStatus(parentTask);

            // Update project scheduling status.
            if (planVersionDetail.ProjId)
            {
                ProjActivityCapacity::updateScheduleStatusByProject(planVersionDetail.ProjId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize fields value.
    /// </summary>
    public void initValue()
    {
        this.TaskSchedulingStatus = PSAScheduled::NotScheduled;
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current record is valid and ready to be written to the database.
    /// </summary>
    /// <returns>true to indicate that the write operation is valid; false, otherwise.</returns>
    public boolean validateWrite()
    {
        boolean ret;
    
        ret = super();
    
        if (ret)
        {
            boolean isSummaryNode;
            if (this.HierarchyLevel)
            {
                isSummaryNode = !this.EndNode;
            }
            else
            {
                isSummaryNode = ProjPlanVersion::isSummaryTask(this.HierarchyId, this.HierarchyTaskId);
            }

            // Make sure that non-root end-nodes in migrated hierarchies have a TaskCategory set
            if (!this.isRoot() && this.EndNode == FalseTrue::True && !this.TaskCategory)
            {
                return checkFailed("@ProjPlan:TaskRequiresCategory");
            }

            if (isSummaryNode)
            {
                if (this.ResourceCategory)
                {
                    ret = checkFailed("@ProjPlan:RoleChangeForSummaryTaskWarning");
                }
            }
            else if (this.ResourceCategory != this.orig().ResourceCategory
                && ActivityFacade::existsAnyAssignmentForActivity(ProjPlanVersion::getActivityRecId(this.HierarchyId, this.HierarchyTaskId)))
            {
                ret = checkFailed("@ProjPlan:RoleChangeForLeaftNodeTaskeWarning");
            }

            if (this.TaskCategory && ProjParameters::find().ValidationProjCategory == ProjValParameter::Mandatory)
            {
                ProjTable projTable = ProjPlanVersion::findProjectAssociatedWithHierarchy(this.HierarchyId);
                
                if (projTable && projTable.ValidateProjCategory == NoYes::Yes)
                {
                    ProjCategory projCategory;
                    ProjProjectCategoryAssoc projProjectCategoryAssoc;

                    select firstonly RecId from projProjectCategoryAssoc
                        where projProjectCategoryAssoc.ProjId == projTable.ProjId
                    exists join projCategory
                        where projCategory.CategoryId == projProjectCategoryAssoc.CategoryId &&
                            projCategory.CategoryId == this.TaskCategory &&
                            projCategory.CategoryType == ProjCategoryType::Hour;

                    if (!projProjectCategoryAssoc)
                    {
                        ret = checkFailed(strFmt("@SYS69535", projTable.ProjId, this.TaskCategory));
                        this.TaskCategory = '';
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSuccessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether this task is a successor in <c>ProjDependency</c> table.
    /// </summary>
    /// <returns>true if this task is a successor; otherwise, false.</returns>
    public boolean isSuccessor()
    {
        ProjDependency projDependency;

        select firstonly RecId from projDependency
            where projDependency.ProjPlanHierarchyId == this.HierarchyId
                && projDependency.SuccessorHierarchyTaskId == this.HierarchyTaskId;

        return projDependency ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateResourceCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update resource category for <c>ProjPlanVersion</c> table buffer.
    /// </summary>
    /// <param name = "_calendarId">Calendar ID for the specified <c>ProjPlanVersion</c> table buffer.</param>
    /// <param name = "_node"><c>ProjPlanVersion</c> table buffer.</param>
    /// <param name = "_roleId">Resource category role ID.</param>
    /// <param name = "_typeOfWBS">Type of the specified <c>ProjPlanVersion</c> table buffer.</param>
    public static void updateResourceCategory(CalendarId _calendarId, ProjPlanVersion _node,
        PSASchedRoleId _roleId, ProjWBSType _typeOfWBS)
    {
        ttsbegin;
        _node.ResourceCategory = PSASchedRole::findById(_roleId).RecId;
        _node.update();
        _node.reread();

        ProjEstimate::syncEstimateLinesFromTask(_node.HierarchyId, _node.HierarchyTaskId, _typeOfWBS);
        ProjPlanVersion::updateCostAtCompleteV2(_node);

        //Update corresponding task record for WBS of type quotation.
        ProjWorkBreakdownStructureV2FormHelper::updateCorrespondingTaskRecord(_node, _typeOfWBS);

        ProjPlanVersion parent = ProjPlanVersion::findByHierarchyAndTaskId(_node.HierarchyId, _node.ParentHierarchyTaskId, true);
        if (parent)
        {
            ProjPlanVersion::updateFromChildren(_calendarId, parent);
        }
            
        
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaskCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update project category for <c>ProjPlanVersion</c> table buffer.
    /// </summary>
    /// <param name = "_calendarId">Calendar ID for the specified <c>ProjPlanVersion</c> table buffer.</param>
    /// <param name = "_node"><c>ProjPlanVersion</c> table buffer.</param>
    /// <param name = "_typeOfWBS">Type of the specified <c>ProjPlanVersion</c> table buffer.</param>
    public static void updateTaskCategory(CalendarId _calendarId, ProjPlanVersion _node, ProjWBSType _typeOfWBS)
    {
        if (_node.validateWrite())
        {
            ttsbegin;
            _node.update();
            _node.reread();

            ProjEstimate::syncEstimateLinesFromTask(_node.HierarchyId, _node.HierarchyTaskId, _typeOfWBS);
            ProjPlanVersion::updateCostAtCompleteV2(_node);

            //Update corresponding task record for WBS of type quotation.
            ProjWorkBreakdownStructureV2FormHelper::updateCorrespondingTaskRecord(_node, _typeOfWBS);

            ProjPlanVersion parent = ProjPlanVersion::findByHierarchyAndTaskId(_node.HierarchyId, _node.ParentHierarchyTaskId, true);
            if (parent)
            {
                ProjPlanVersion::updateFromChildren(_calendarId, parent);
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHierarchyLevelByPathId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get hierarchy level by path ID.
    /// </summary>
    /// <param name = "_pathId">Path ID.</param>
    /// <returns>Hierarchy level value.</returns>
    public static ProjHierarchyLevel getHierarchyLevelByPathId(ProjHierarchyPathId _pathId)
    {
        const str pathIdDelimiter = '.';
        List pathIdSegment = strSplit(_pathId, pathIdDelimiter);
        return pathIdSegment.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProjectAssociatedWithHierarchy</Name>
				<Source><![CDATA[
    private static ProjTable findProjectAssociatedWithHierarchy(HierarchyIdBase _currentHierarchyId)
    {
        // Look for the hierarchy referenced ProjTable record.
        // For the case of quotation, it will look up the SalesQuotationTable referenced ProjTable if existed.
        ProjTable projTable;
        HierarchyIdBase oldestVersionHierarchyId = _currentHierarchyId;
        ProjPlanVersionDetail projPlanVersionDetail = ProjPlanVersionDetail::findByHierarchyId(_currentHierarchyId);
        ProjId projId = projPlanVersionDetail.ProjId;

        if (projId && projPlanVersionDetail.VersionId > 1)
        {
            oldestVersionHierarchyId = ProjPlanVersionDetail::findOldestByProjId(projId).HierarchyId;
        }

        Common hierarchyLinkedTable = HierarchyLinkTable_Extension::findLinkedTableByHierarchyId(oldestVersionHierarchyId);

        switch (hierarchyLinkedTable.TableId)
        {
            case tableNum(ProjTable):
                projTable = hierarchyLinkedTable;
                break;

            case tableNum(SalesQuotationTable):
                SalesQuotationTable quotationTable = hierarchyLinkedTable;
                if (quotationTable.ProjIdRef)
                {
                    projTable = ProjTable::find(quotationTable.ProjIdRef);
                    break;
                }
                break;
        }
        return projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxCalendarDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine task finish date either max configured date or date after 20 years whichever is less
    /// </summary>
    /// <param name = "_calendarId">Calendar ID for the specified <c>ProjPlanVersion</c> table buffer.</param>
    /// <returns> Maximum calendar date</returns>
    protected static TransDate getMaxCalendarDate(CalendarId _calendarId)
    {
        // Max year scheduled setup for finish date calculation 
        Year maxScheduledYear = ProjWorkBreakdownStructureHelper::getMaxScheduledYear();
        
        // To get last day of the max year scheduled from today
        TransDate maxScheduledEndDate = dateEndYr(dateMthFwd(DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()), maxScheduledYear * 12));
        
        //To get maximum calendar defined date.
        WorkCalendarDate workcalendarDate;
        select maxof(TransDate) from workcalendarDate
            where workcalendarDate.CalendarId == _calendarId;
            
        TransDate maxConfiguredCalendarDate = workcalendarDate.TransDate;

        // Determine task finish date either max configured date or date after 20 years whichever is less
        maxConfiguredCalendarDate = maxScheduledEndDate > maxConfiguredCalendarDate ? maxConfiguredCalendarDate : maxScheduledEndDate;

        // Make sure the resulting endDate is open.
        WorkCalendarSched workCalendarSched = new WorkCalendarSched();
        while (!workCalendarSched.isDateOpen(_calendarId, maxConfiguredCalendarDate))
        {
            maxConfiguredCalendarDate--;
        }

        return maxConfiguredCalendarDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countDuration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate task duration based on specified start date and end date interval
    /// </summary>
    /// <param name = "_node"><c>ProjPlanVersion</c> table buffer.</param>
    /// <param name = "_calendarId">Calendar ID for the specified <c>ProjPlanVersion</c> table buffer.</param>
    /// <returns>Task duration days.</returns>
    private Static Days countDuration(ProjPlanVersion _node, CalendarId _calendarId)
    {
        Days duration = 0;

        // calculate duration days based on configured calendar setup
        WorkCalendarDate workCalendarDate;
        WorkCalendarDateLine workCalendarDateLine;

        CalendarId basicCalendarId = WorkCalendarTable::find(_calendarId).BasicCalendarId;

        select count(RecId) from workCalendarDate
             exists join workCalendarDateLine
                 where workCalendarDateLine.TransDate == workCalendarDate.TransDate &&
                       (workCalendarDateLine.CalendarId == basicCalendarId ||
                       workCalendarDateLine.CalendarId == workCalendarDate.CalendarId) &&
                       workCalendarDate.CalendarId == _calendarId &&
                       workCalendarDate.TransDate >= _node.TaskStartDate &&
                       workCalendarDate.TransDate <= _node.TaskFinishDate &&
                       (workCalendarDate.WorkTimeControl == WorkTimeControl::Open ||
                       workCalendarDate.WorkTimeControl == WorkTimeControl::UseBasic);
                       {
                            duration = workCalendarDate.RecId;
                       }

        return duration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findEndDateForDuration</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the open end day for a working period based on the task start date and duration.
    /// </summary>
    /// <param name = "_taskStartDate">Task start date for the specified <c>ProjPlanVersion</c> table buffer </param>
    /// <param name = "_taskDuration">Task duration for the specified <c>ProjPlanVersion</c> table buffer </param>
    /// <param name = "_calendarId">Calendar ID for the specified <c>ProjPlanVersion</c> table buffer </param>
    /// <returns>The open working end date./// </returns>
    protected static TransDate findEndDateForDuration(TransDate _taskStartDate, Days _taskDuration, CalendarId _calendarId)
    {
        ProjWBSOpenDatesTmp projWBSOpenDatesTmp;
        WorkCalendarDate workCalendarDate;
        WorkCalendarDateLine workCalendarDateLine;

        CalendarId basicCalendarId = WorkCalendarTable::find(_calendarId).BasicCalendarId;

        // Determine task finish date either max configured date or open date after 20 years from today whichever is less
        TransDate maxCalendarDate = ProjPlanVersion::getMaxCalendarDate(_calendarId);

        insert_recordset projWBSOpenDatesTmp (TaskFinishDate)
            select TransDate from workCalendarDate order by TransDate
                exists join workCalendarDateLine
                    where workCalendarDateLine.TransDate == workCalendarDate.TransDate &&
                          (workCalendarDateLine.CalendarId == basicCalendarId ||
                          workCalendarDateLine.CalendarId == workCalendarDate.CalendarId) &&
                          workCalendarDate.CalendarId == _calendarId &&
                          workCalendarDate.TransDate >= _taskStartDate &&
                          workCalendarDate.TransDate <= maxCalendarDate &&
                          (workCalendarDate.WorkTimeControl == WorkTimeControl::Open ||
                          workCalendarDate.WorkTimeControl == WorkTimeControl::UseBasic);

        int durationCount = 0;
        TransDate taskFinishDate;

        while select projWBSOpenDatesTmp
            order by TaskFinishDate
        {
            durationCount++;

            if (durationCount == _taskDuration)
            {
                taskFinishDate = projWBSOpenDatesTmp.TaskFinishDate;
                break;
            }
        }

        // If end date could not find in temp table then set maximum end date.
        if (taskFinishDate == dateNull())
        {
            taskFinishDate = maxCalendarDate;
        }
        
        return taskFinishDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAndRemoveInvalidPredecessor</Name>
				<Source><![CDATA[
    private void validateAndRemoveInvalidPredecessor(ProjPlanVersion _node, CalendarId _calendarId, TransDate _maxFinishDate)
    {
        ProjPlanVersion predecessor;
        ProjDependency predecessorEdge;
        container invalidPredecessor;

        while select TaskFinishDate, HierarchyTaskId from predecessor order by TaskFinishDate desc
         exists join predecessorEdge where
             predecessorEdge.ProjPlanHierarchyId == _node.HierarchyId
             && predecessor.HierarchyId == _node.HierarchyId
             && predecessorEdge.PredecessorHierarchyTaskId == predecessor.HierarchyTaskId
                && predecessorEdge.SuccessorHierarchyTaskId == _node.HierarchyTaskId
        {
            SchedToDate finishDate = WorkCalendarCalculator::findNextWorkDayAfterDate(_calendarId, predecessor.TaskFinishDate);
            _node.TaskStartDate = finishDate;

            Days maxTaskDurationDays = ProjWorkBreakdownStructureHelper::getMaxTaskDurationDays();
            if (_node.TaskDuration > maxTaskDurationDays)
            {
                _node.TaskFinishDate = ProjPlanVersion::findEndDateForDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
            }
            else
            {
                _node.TaskFinishDate = WorkCalendarCalculator::findEndDateForStartDateAndDuration(_node.TaskStartDate, _node.TaskDuration, _calendarId);
            }

            if (_node.TaskFinishDate > _maxFinishDate)
            {
                invalidPredecessor += predecessor.HierarchyTaskId;

                ProjDependency dependencyTable;
                delete_from dependencyTable
                    where dependencyTable.ProjPlanHierarchyId == _node.HierarchyId
                        && dependencyTable.SuccessorHierarchyTaskId == _node.HierarchyTaskId
                        && dependencyTable.PredecessorHierarchyTaskId == predecessor.HierarchyTaskId;

                _node.TaskStartDate = _node.orig().TaskStartDate;
                _node.TaskFinishDate = _node.orig().TaskFinishDate;
            }
            else
            {
                _node.TaskStartDate = _node.orig().TaskStartDate;
                _node.TaskFinishDate = _node.orig().TaskFinishDate;
                
                ProjPlanVersion::updateStartDateFromPredecessors(_calendarId, _node);
            }
        }
        error(strFmt("@ProjPlan:RemoveInvalidPredecessors", conLen(invalidPredecessor), date2StrUsr(_maxFinishDate, DateFormat::Auto)));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Project</ConfigurationKey>
	<Label>@SYS338946</Label>
	<TableGroup>Group</TableGroup>
	<TitleField1>HierarchyId</TitleField1>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<ClusteredIndex>HierarchyIdTaskNumber</ClusteredIndex>
	<Modules>ProjectManagementAndAccounting</Modules>
	<PrimaryIndex>HierarchyIdTaskNumber</PrimaryIndex>
	<ReplacementKey>HierarchyIdTaskNumber</ReplacementKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>HierarchyId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>HierarchyTaskId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TaskScheduling</Name>
			<Label>@SYS4005016</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaskEffort</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NumberOfResources</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaskStartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaskFinishDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaskDuration</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TaskCategory</Name>
			<Label>@SYS4005017</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaskCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsCategoryMandatory</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>HierarchyId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>HierarchyIdBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>HierarchyTaskId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjHierarchyTaskId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaskName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjTaskName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaskCategory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>NumberOfResources</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NumberOfResources</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>TaskStartDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SchedFromDate</ExtendedDataType>
			<Label>@ProjPlan:TaskStartDate</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>TaskFinishDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SchedToDate</ExtendedDataType>
			<Label>@ProjPlan:TaskEndDate</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaskDuration</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DaysAsReal</ExtendedDataType>
			<Label>@SYS52550</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaskEffort</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Hours</ExtendedDataType>
			<Label>@PSA3078</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaskSchedulingStatus</Name>
			<EnumType>PSAScheduled</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaskAssignedHours</Name>
			<ExtendedDataType>Hours</ExtendedDataType>
			<Label>@Res:AssignedHours</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaskCostAtComplete</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjTotalCostAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaskEffortAtComplete</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Hours</ExtendedDataType>
			<Label>@ProjPlan:TaskEffortAtComplete</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaskEffortToComplete</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Hours</ExtendedDataType>
			<Label>@ProjPlan:TaskEffortToComplete</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>TaskProjectedEndDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SchedToDate</ExtendedDataType>
			<Label>@ProjPlan:TaskProjectedEndDate</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaskProjectedCost</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Label>@PSA11068</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaskProjectedRevenue</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Label>@PSA11067</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaskStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<IsObsolete>Yes</IsObsolete>
			<EnumType>smmActivityTaskTimeType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsTaskClosed</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS67267</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsTaskMandatory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@ProjPlan:MandatoryTask</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>HierarchyTreeTableRefRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaskSiblingNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LineNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ParentHierarchyTaskId</Name>
			<AssetClassification>Customer Content</AssetClassification>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ResourceCategory</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ResourceCategoryRecId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>UserMemo</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>smmActivityUserMemo</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaskPriority</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>smmActivityPriority</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ActivityTaskTimeType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>smmActivityTaskTimeType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsCategoryMandatory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS339663</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldGuid">
			<Name>MSPID</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PathId</Name>
			<ConfigurationKey>Project</ConfigurationKey>
			<ExtendedDataType>ProjHierarchyPathId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>HierarchyLevel</Name>
			<ExtendedDataType>ProjHierarchyLevel</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>EndNode</Name>
			<Label>@ProjPlan:EndNode</Label>
			<EnumType>FalseTrue</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>HierarchyIdTaskNumber</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>HierarchyId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HierarchyTaskId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ParentHierarchyTaskId</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ParentHierarchyTaskId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HierarchyId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaskSiblingNumber</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>MSPID</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>MSPID</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HierarchyId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ChildParentIndex</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>HierarchyTaskId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HierarchyId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ParentHierarchyTaskId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TaskSiblingNumberIndex</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>TaskSiblingNumber</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HierarchyId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>HierarchyLevelIndex</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>HierarchyLevel</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HierarchyId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PathIdIndex</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>PathId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HierarchyId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>HierarchyTreeTableRefRecIdIndex</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>HierarchyTreeTableRefRecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HierarchyId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>HierarchyTreeTable</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>HierarchyTreeTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>HierarchyTreeTableRefRecId</Name>
					<Field>HierarchyTreeTableRefRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ResourceCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ResourceCategoryView</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ResourceCategory</Name>
					<Field>ResourceCategory</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjWBSTaskEstimateUnionView</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>ProjWBSTaskEstimateUnionView</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Link</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TableId</Name>
					<Field>TableId</Field>
					<RelatedField>SourceTableId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>SourceRecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>