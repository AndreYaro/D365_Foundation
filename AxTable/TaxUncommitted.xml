<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxUncommitted</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Tax.Instrumentation;
public class TaxUncommitted extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>impliedDataAreaFieldNameDelegate</Name>
				<Source><![CDATA[
    [SubscribesTo(classStr(DimensionObjectStorageTableReferenceProcessor), delegatestr(DimensionObjectStorageTableReferenceProcessor, impliedDataAreaFieldNameDelegate))]
    static void impliedDataAreaFieldNameDelegate(TableId _tableId, FieldId _fieldId, EventHandlerResult _result)
    {
        if (_tableId == tableNum(TaxUncommitted))
        {
            switch(_fieldId)
            {
                case(fieldNum(TaxUncommitted, LedgerDimension)):
                case(fieldNum(TaxUncommitted, LedgerDimension_IN)):
                case(fieldNum(TaxUncommitted, LedgerDimensionRev_IN)):
                case(fieldNum(TaxUncommitted, OffsetLedgerDimension_RU)):
                case(fieldNum(TaxUncommitted, OperationLedgerDimension)):
                case(fieldNum(TaxUncommitted, TaxOffsetUseTaxLedgerDimension)):
                case(fieldNum(TaxUncommitted, TaxSalesOffsetLedgerDimension_BR)):
                    _result.result(fieldStr(TaxUncommitted, Company));
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomsExchRate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets customs exchange rate.
    /// </summary>
    /// <returns>
    /// The instance of the <c>ExchRate</c> class.
    /// </returns>
    public ExchRate getCustomsExchRate_IN()
    {
        return this.TaxMap::getCustomsExchRate_IN();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEximIncentiveSchemeTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets exim incentive scheme tax information.
    /// </summary>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    public TaxAmountCur getEximIncentiveSchemeTax_IN()
    {
        return this.TaxMap::getEximIncentiveSchemeTax_IN();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountBeforeCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount before deducting the tax in cost price.
    /// </summary>
    /// <returns>
    /// The tax amount.
    /// </returns>
    public TaxAmountCur getTaxAmountBeforeCost()
    {
        return this.TaxMap::getTaxAmountBeforeCost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxBaseAmountRegulatedMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the regulated tax base amount converted to the company s currency code
    /// </summary>
    /// <returns>
    /// If the tax trans currency code is the same of the company s currency code, then, the raw value of SourceBaseAmountCurRegulated will be returned.
    /// Otherwise, the SourceBaseAmountCurRegulated converted value will be returned.
    /// </returns>
    public TaxAmountCur getTaxBaseAmountRegulatedMST_BR()
    {
        if (this.taxBaseAmountHasBeenAdjusted_BR())
        {
            if (this.SourceCurrencyCode != CompanyInfoHelper::standardCurrency())
            {
                return CurrencyExchangeHelper::mstAmount(this.SourceBaseAmountCurRegulated, this.SourceCurrencyCode, this.TransDate);
            }
            else
            {
                return this.SourceBaseAmountCurRegulated;
            }
        }
        else
        {
            return this.TaxBaseAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxInCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax in cost price amount of the tax source document line.
    /// </summary>
    /// <returns>
    /// A tax in cost price amount.
    /// </returns>
    public TaxAmountCur getTaxInCostPrice()
    {
        return this.TaxMap::getTaxInCostPrice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTotalsForDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the <c>RecordSortedList</c> table with tax totals.
    /// </summary>
    /// <param name="_taxTotals">
    /// The <c>RecordSortedList</c> table that will be populated with tax information.
    /// </param>
    /// <param name="_headingTableId">
    /// The document table ID.
    /// </param>
    /// <param name="_headingRecId">
    /// The document table ID.
    /// </param>
    /// <param name="_reverseSign">
    /// A Boolean value that indicates whether the sign of the tax amounts is to be flipped.
    /// </param>
    /// <returns>
    /// The tax amount.
    /// </returns>
    TaxAmountCur getTaxTotalsForDocument(RecordSortedList _taxTotals,
                                         RefTableId       _headingTableId,
                                         RefRecId         _headingRecId,
                                         boolean          _reverseSign)
    {
        TmpTaxTotals    tmpTaxTotals;
        TaxAmountCur    taxAmountCur;
        Counter         signReverse = 1;
        TaxUncommitted  taxUncommitted;

        if (_reverseSign)
            signReverse = -1;

        while select sum(TaxAmount),
                     sum(SourceTaxAmountCur),
                     sum(SourceRegulateAmountCur)
        from taxUncommitted
        group by TaxCode, TaxDirection, SourceCurrencyCode, NegativeTax, TaxAutogenerated
        where taxUncommitted.HeadingRecId == _headingRecId &&
              taxUncommitted.HeadingTableId == _headingTableId
        {
            tmpTaxTotals.clear();
            tmpTaxTotals.TaxCode      = taxUncommitted.TaxCode;
            tmpTaxTotals.TaxDirection = taxUncommitted.TaxDirection;
            tmpTaxTotals.CurrencyCode = taxUncommitted.SourceCurrencyCode;
            _taxTotals.find(tmpTaxTotals);

            tmpTaxTotals.TaxAmountCur              += taxUncommitted.SourceTaxAmountCur * signReverse;
            if (!taxUncommitted.TaxAutogenerated)
                tmpTaxTotals.TaxAmountCurRegulated += taxUncommitted.SourceRegulateAmountCur * signReverse;
            if (!taxUncommitted.TaxAutogenerated)
                tmpTaxTotals.TaxAmountCurCorrect   += taxUncommitted.SourceRegulateAmountCur * signReverse;
            else
                tmpTaxTotals.TaxAmountCurCorrect   += taxUncommitted.SourceTaxAmountCur * signReverse;

            if (taxUncommitted.TaxOrigin != TaxOrigin::TaxReversed)
                if (taxUncommitted.NegativeTax)
                    taxAmountCur -= abs(taxUncommitted.SourceTaxAmountCur);
            else
                    taxAmountCur += abs(taxUncommitted.SourceTaxAmountCur);

            _taxTotals.ins(tmpTaxTotals, true);
        }
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRateDate</Name>
				<Source><![CDATA[
    public AccountingDate parmExchangeRateDate()
    {
        return this.TaxMap::parmExchangeRateDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceDocumentLine</Name>
				<Source><![CDATA[
    public SourceDocumentLine parmParentSourceDocumentLine()
    {
        return this.TaxMap::parmParentSourceDocumentLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineTypeEnumName</Name>
				<Source><![CDATA[
    public EnumName parmSourceDocLineTypeEnumName()
    {
        return this.TaxMap::parmSourceDocLineTypeEnumName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineTypeEnumValue</Name>
				<Source><![CDATA[
    public SourceDocumentTypeEnumValue parmSourceDocLineTypeEnumValue()
    {
        if (!this.SourceTableId && !this.tableAccessRight())
        {
            throw error(strFmt(
                "@TaxIntegrationException:MessageNoPrivilege",
                "@TaxIntegration:TaxSalesTaxMaintain",
                "@TaxIntegration:TaxSalesTaxMaintain"));
        }
        return this.TaxMap::parmSourceDocLineTypeEnumValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocumentHeader</Name>
				<Source><![CDATA[
    public SourceDocumentHeader parmSourceDocumentHeader()
    {
        return this.TaxMap::parmSourceDocumentHeader();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseSignOnAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverses the sign of all of the amounts in the <c>TaxUncommitted</c> record.
    /// </summary>
    public void reverseSignOnAmounts()
    {
        this.TaxAmount = this.TaxAmount * -1;
        this.TaxBaseAmount = this.TaxBaseAmount * -1;
        this.TaxBaseAmountCur = this.TaxBaseAmountCur * -1;
        this.TaxBaseAmountRep = this.TaxBaseAmountRep * -1;
        this.SourceTaxAmountCur = this.SourceTaxAmountCur * -1;
        this.TaxAmountCur = this.TaxAmountCur * -1;
        this.TaxAmountRep = this.TaxAmountRep * -1;
        this.SourceBaseAmountCur = this.SourceBaseAmountCur * -1;
        this.TaxInCostPrice = this.TaxInCostPrice * -1;
        this.SourceRegulateAmountCur = this.SourceRegulateAmountCur * -1;
        this.TaxInCostPriceRegulated = this.TaxInCostPriceRegulated * -1;
        this.TaxInCostPriceCur = this.TaxInCostPriceCur * -1;
        this.TaxInCostPriceRep = this.TaxInCostPriceRep * -1;
        this.TaxInCostPriceMST = this.TaxInCostPriceMST * -1;
        this.SourceBaseAmountCurRegulated = this.SourceBaseAmountCurRegulated * -1;
        this.SourceTaxAmountCurReal = this.SourceTaxAmountCurReal * -1;
        this.SourceBaseAmountCurRaw = this.SourceBaseAmountCurRaw * -1;
        this.TaxBaseAmountRaw = this.TaxBaseAmountRaw * -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTaxValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax rate for the tax code on the current <c>TaxUncommitted</c> record.
    /// </summary>
    /// <returns>
    /// The tax rate for the current <c>TaxUncommitted</c> record.
    /// </returns>
    TaxValue showTaxValue()
    {
        TaxValue taxValue;
        SalesPurchJournalLine salesPurchJournalLine;
        if (this.TaxValue)
        {
            taxValue = this.TaxValue;
        }
        else
        {
            if (this.TaxCode && this.TransDate)
            {
                if (TaxParameters::checkTaxParameters_IN() &&  TaxTable::find(this.TaxCode).TaxType_IN != TaxType_IN::None)
                {
                    salesPurchJournalLine = Tax::getSalesPurchJournalLine(this.SourceRecId, this.SourceTableId);
                    taxValue = TaxUncommitted_IN::showTaxValue(salesPurchJournalLine,
                    this.Source,
                    this.InventTransId,
                    this.TaxCode,
                    this.TaxItemGroup,
                    this.CalculationDate,
                    this.TaxBaseAmount);
                }
                else
                {
                    taxValue = TaxData::percent(
                        this.TaxCode,
                        this.CalculationDate,
                        this.TaxBaseAmount);
                    // <GIN>
                }
                // </GIN>
            }
        }
        return taxValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>submitSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submits the tax record to the accounting distribution process and journalization process
    /// </summary>
    public void submitSourceDocumentLine()
    {
        if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedSubmitSDLWithParentStatus::instance()))
        {
             this.submitSourceDocumentLineWithParentStatus();
             return;
        }
        
        SourceDocumentLine          sourceDocumentLine;
        SourceDocumentLineItem      sourceDocumentLineItem;

        if (this.SourceDocumentLine)
        {
            sourceDocumentLine = SourceDocumentLine::find(this.SourceDocumentLine);
            sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLineImplementation(this);
        }

        if (this.SourceDocumentLine &&
            sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::Completed &&
            (sourceDocumentLineItem.hasAmountResolutionInputChanged() ||
             sourceDocumentLineItem.hasMainAccDerivationInputChanged()))
        {
            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::FullyDistributed);
        }
        //in completed state but nothing has changed to force move back to fully distributed state, let the framework decide what to do
        else if (sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::Completed)
        {
            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false);
        }
        // submit to draft state, tax line will transition to fully distributed when parent is transitioned
        else
        {
            if (sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::None)
            {
                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::Draft);
            }
            else
            {
                if (this.SourceDocumentLine && (sourceDocumentLineItem.hasAmountResolutionInputChanged() || sourceDocumentLineItem.hasMainAccDerivationInputChanged()))
                {
                    if (sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::FullyDistributed
                        && FeatureStateProvider::isFeatureEnabled(TaxSourceDocumentLineSubmitWithParentFlighting::instance()))
                    {
                        // FullyDistributed could go to Draft or Complete, so we go with its parent
                        SourceDocumentLine parentSourceDocumentLine = sourceDocumentLineItem.parmParentSourceDocumentLine();
                        SourceDocumentLineAccountingStatus parentStatus = parentSourceDocumentLine.AccountingStatus;
                        SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, parentStatus);
                    }
                    else
                    {
                        if (this.SourceDocumentLine && this.HeadingTableId == tableNum(PurchTable))
                        {
                            PurchTable purchTable = PurchTable::findRecId(this.HeadingRecId);
                            if (purchTable.InclTax)
                            {
                                // To keep the consistency, first submit the sourcedocumentline and the parent line as Draft
                                SourceDocumentLine parentSourceDocumentLine = sourceDocumentLineItem.parmParentSourceDocumentLine();
                                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(parentSourceDocumentLine.getSourceDocumentLineImplementation(), false, SourceDocumentLineAccountingStatus::Draft);
                                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::Draft);

                                // Clear cache to keep consistency for project accounting distribution if parent distribution is deleted and recreated when purchase order is updated
                                if (purchTable.ProjId)
                                {
                                    SysTransactionScopeCache::clear(classStr(AccountingDistributionRule));
                                }

                                // Then submit the sourcedocumentline and the parent line as FullyDistributed
                                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(parentSourceDocumentLine.getSourceDocumentLineImplementation(), false, SourceDocumentLineAccountingStatus::FullyDistributed);
                                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::FullyDistributed);
                                return;
                            }
                        }

                        SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::Draft);

                    }
                }
                else
                {
                    SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, sourceDocumentLine.AccountingStatus);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>submitSourceDocumentLineWithParentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submits the tax record to the accounting distribution process and journalization process
    /// And the status of tax component should be consistent with its parent status.
    /// </summary>
    private void submitSourceDocumentLineWithParentStatus()
    {
        if (this.SourceDocumentLine)
        {
            SourceDocumentLine sourceDocumentLine = SourceDocumentLine::find(this.SourceDocumentLine);
            SourceDocumentLineItem sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLineImplementation(this);
            SourceDocumentLine parentSourceDocumentLine = SourceDocumentLine::find(sourceDocumentLine.parentSourceDocumentLine); // here a tax source document line must have a parent source document line
            SourceDocumentLineAccountingStatus parentStatus = parentSourceDocumentLine.AccountingStatus;

            switch (sourceDocumentLine.AccountingStatus)
            {
                case SourceDocumentLineAccountingStatus::Completed:
                    if (sourceDocumentLineItem.hasAmountResolutionInputChanged() || sourceDocumentLineItem.hasMainAccDerivationInputChanged())
                    {
                        SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::FullyDistributed);
                    }
                    else
                    {
                        SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false);
                    }
                    break;

                case SourceDocumentLineAccountingStatus::Draft,
                     SourceDocumentLineAccountingStatus::FullyDistributed,
                     SourceDocumentLineAccountingStatus::PartlyDistributed:
                    if (this.HeadingTableId == tableNum(PurchTable)
                        && (sourceDocumentLineItem.hasAmountResolutionInputChanged()
                            || sourceDocumentLineItem.hasMainAccDerivationInputChanged()))
                    {
                        PurchTable purchTable = PurchTable::findRecId(this.HeadingRecId);
                        if (purchTable.InclTax)
                        {
                            // To keep the consistency, first submit the sourcedocumentline and the parent line as Draft
                            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(parentSourceDocumentLine.getSourceDocumentLineImplementation(), false, SourceDocumentLineAccountingStatus::Draft);
                            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::Draft);

                            // Clear cache to keep consistency for project accounting distribution if parent distribution is deleted and recreated when purchase order is updated
                            if (purchTable.ProjId)
                            {
                                SysTransactionScopeCache::clear(classStr(AccountingDistributionRule));
                            }

                            // Then submit the sourcedocumentline and the parent line as FullyDistributed
                            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(parentSourceDocumentLine.getSourceDocumentLineImplementation(), false, SourceDocumentLineAccountingStatus::FullyDistributed);
                            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::FullyDistributed);
                            break;
                        }
                    }
                    // Draft could go to fully distributed or canceled
                    // Fully/Partly distributed could directly go to any further steps, so directly go with parent
                    SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, parentStatus);
                    break;

                case SourceDocumentLineAccountingStatus::None:
                    SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::Draft);
                    break;

                default:
                    break;
            }
        }
        else
        {
            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::Draft);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxBaseAmountHasBeenAdjusted_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the tax base amount has been adjusted.
    /// </summary>
    /// <returns>
    /// True if the tax base amount has been adjusted, false otherwise.
    /// </returns>
    public boolean taxBaseAmountHasBeenAdjusted_BR()
    {
        return this.SourceBaseAmountCurRegulated != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record exists in the TaxUncommitted table; if not, an error message is displayed.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the TaxUncommitted record.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean checkExist(RecId _recId)
    {
        boolean isExisting = true;
        ;

        if (!TaxUncommitted::exist(_recId))
        {
            isExisting = checkFailed(strFmt(TaxUncommitted::txtNotExist(), _recId));
        }

        return isExisting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxLinesByOperationAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for the tax direction and tax code values that uses the <c>OperationAccount</c> field from
    /// the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <param name="_tax">
    /// An instance of the <c>Tax</c> class.
    /// </param>
    /// <returns>
    /// true if the tax verification was successful; otherwise, false.
    /// </returns>
    static boolean checkTaxLinesByOperationAccount(Tax _tax)
    {
        boolean         returnValue = true;
        boolean         taxDirectionControl;
        MainAccount     mainAccount, nextMainAccount;
        MainAccountNum  mainAccountId;
        DataAreaId      companyId;
        TaxUncommitted  taxUncommitted;

        if (_tax.taxParameters().ValidateTaxCode || _tax.taxParameters().MandatoryTaxDirection)
        {
            while select OperationLedgerDimension, TaxCode, Company, SourceTableId, SourceRecId from taxUncommitted
                order by TaxCode
                where taxUncommitted.HeadingTableId == _tax.headingTableId() &&
                      taxUncommitted.HeadingRecId == _tax.headingRecId() &&
                      taxUncommitted.IsDeleted == NoYes::No
            {
                // Retrieve the GL Ledger Account specified as OperationAccount in the tax record,
                //
                nextMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(taxUncommitted.OperationLedgerDimension);
                if (!mainAccountId ||
                    (mainAccountId != nextMainAccount.MainAccountId || companyId != taxUncommitted.company()))
                {
                    mainAccount = null;
                    // Verify that the company exists.
                    if (xDataArea::exist(taxUncommitted.Company))
                    {
                        companyId = taxUncommitted.Company;
                    }
                    else
                    {
                        companyId = curext();
                    }

                    changecompany(companyId)
                    {
                        mainAccount = nextMainAccount;
                        mainAccountId = mainAccount.MainAccountId;
                    }
                }
                if ((taxUncommitted.SourceTableId == tableNum(LedgerJournalTrans) &&
                   LedgerJournalTrans::findRecId(taxUncommitted.SourceRecId,false).TaxDirectionControl) ||taxUncommitted.SourceTableId == tableNum(CustInvoiceLine))
                {
                    taxDirectionControl = true;
                }
                if (_tax.taxParameters().MandatoryTaxDirection && taxDirectionControl)
                {
                    returnValue = _tax.checkTaxDirection(mainAccount);
                }

                if (returnValue && _tax.taxParameters().ValidateTaxCode)
                {
                    returnValue = Tax::checkTaxCode(mainAccount, taxUncommitted.TaxCode);
                }

                if (!returnValue)
                {
                    break;
                }
            }
        }
        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Creates the <c>TaxUncommitted</c> records for transactions which do not use distributions.
    /// </summary>
    /// <param name="_taxCalculation">
    ///   The instance of the tax calculation class used to calculate taxes.
    /// </param>
    /// <param name="_skipNotExistsCheck">
    ///   true if the calling code has verified already that no tax uncommitted records exist and the query
    ///   to find them can be skipped; otherwise, false.
    /// </param>
    /// <param name="_doIsolateTransactionScope">
    /// true if <c>TaxUncommitted</c> should be maintained in a independent transaction scope; otherwise false.
    /// </param>
    public static void createTaxUncommitted(Tax _taxCalculation, boolean _skipNotExistsCheck = false, boolean _doIsolateTransactionScope = false)
    {
        TmpTaxWorkTrans     tmpTaxWorkTrans;
        RecordInsertList    taxUncommittedList;
        MarkupTrans         markupTrans;
        TaxUncommitted      taxUncommitted;
        TaxUncommitted      taxUncommitted2;
        UserConnection      connection;

        void createTaxUncommittedFromTmpTaxWorkTrans()
        {
            ExchRate exchRate = tmpTaxWorkTrans.ExchRate ? tmpTaxWorkTrans.ExchRate : _taxCalculation.parmExchRate();
            ReportingCurrencyExchRate reportingCurrencyExchRate = tmpTaxWorkTrans.ReportingCurrencyExchRate ? tmpTaxWorkTrans.ReportingCurrencyExchRate : _taxCalculation.parmReportingCurrencyExchRate();

            taxUncommitted.clear();
            taxUncommitted.initFromTmpTaxWorkTransV2(tmpTaxWorkTrans, exchRate, _taxCalculation.parmExchRateSecond(), reportingCurrencyExchRate, _taxCalculation.parmReportingCurrencyExchRateSecondary());

            if (!_taxCalculation.getMaintainExistingTaxUncommitted())
            {
                // if we aren't maintaining existing TaxUncommitted records then all the SDL's
                // were deleted so clear the RecId.
                taxUncommitted.SourceDocumentLine = 0;
            }

            if (_taxCalculation.useSubLedgerJournalLines() && tmpTaxWorkTrans.SourceRecId != 0)
            {
                if (TaxUncommitted::isTaxForSourceDocumentLine(tmpTaxWorkTrans.SourceTableId, tmpTaxWorkTrans.SourceRecId))
                {
                    taxUncommitted.submitSourceDocumentLine();
                }
                else
                {
                    taxUncommitted.SourceDocumentLine = 0;
                }
            }

            taxUncommitted.ensureReportingCurrency();

            tmpTaxWorkTrans.SourceDocumentLine = taxUncommitted.SourceDocumentLine;
            tmpTaxWorkTrans.update(_taxCalculation.ignoreCalculatedSalesTax());

            taxUncommittedList.add(taxUncommitted);
        }
        tmpTaxWorkTrans = _taxCalculation.tmpTaxWorkTrans();
        // Check if there is qualified tax line in the memory table
        if(_skipNotExistsCheck)
        {
            select firstonly RecId
                from tmpTaxWorkTrans
                where tmpTaxWorkTrans.HeadingRecId == _taxCalculation.headingRecId() &&
                      tmpTaxWorkTrans.HeadingTableId == _taxCalculation.headingTableId();
        }
        else
        {
            select firstonly RecId
                from tmpTaxWorkTrans
                where tmpTaxWorkTrans.HeadingRecId == _taxCalculation.headingRecId() &&
                      tmpTaxWorkTrans.HeadingTableId == _taxCalculation.headingTableId()
                notexists join taxUncommitted2
                where tmpTaxWorkTrans.SourceTableId == taxUncommitted2.SourceTableId &&
                      tmpTaxWorkTrans.SourceRecId == taxUncommitted2.SourceRecId &&
                      tmpTaxWorkTrans.TaxCode == taxUncommitted2.TaxCode;
        }
        if(!tmpTaxWorkTrans)
        {
            return;
        }

        if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
        {
            _doIsolateTransactionScope = false;
        }

        try
        {
            if (_doIsolateTransactionScope)
            {
                connection = new UserConnection();
                taxUncommitted.setConnection(connection);
            }

            // taxUncommitted table buffer must be passed so that the correct db connection is used.
            taxUncommittedList = new RecordInsertList(tableNum(TaxUncommitted), false, false, false, false, true, taxUncommitted);

            if (_doIsolateTransactionScope)
            {
                connection.ttsbegin();
            }
            else if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
            {
                ttsbegin;
            }

            // If calling code verified none exist already, skip the notexists check
            if (_skipNotExistsCheck)
            {
                boolean isTaxUncommittedDuplicateIssueTraceFlightEnabled = TaxUncommittedDuplicateIssueTraceFlight::instance().isEnabled();
                boolean isTaxUncommittedDuplicateIssueCheckFlightEnabled = TaxUncommittedDuplicateIssueCheckFlight::instance().isEnabled();
                // loop through the memory table which holds all the tax lines, creating a
                // tax uncommitted record for each.
                while select tmpTaxWorkTrans
                    where tmpTaxWorkTrans.HeadingRecId == _taxCalculation.headingRecId()
                        && tmpTaxWorkTrans.HeadingTableId == _taxCalculation.headingTableId()
                {
                    if((isTaxUncommittedDuplicateIssueTraceFlightEnabled
                            || isTaxUncommittedDuplicateIssueCheckFlightEnabled)
                        && TaxUncommitted::traceDuplicateTaxUncommitted(_taxCalculation, _skipNotExistsCheck, _doIsolateTransactionScope))
                    {
                        TaxUncommitted taxUncommittedExisted;
                        select firstonly RecId, SourceTableId, SourceRecId from taxUncommittedExisted
                            where taxUncommittedExisted.HeadingRecId == _taxcalculation.headingRecId()
                                && taxUncommittedExisted.HeadingTableId == _taxcalculation.headingTableId()
                                && taxUncommittedExisted.SourceTableId == tmpTaxWorkTrans.SourceTableId
                                && taxUncommittedExisted.SourceRecId == tmpTaxWorkTrans.SourceRecId
                                && taxUncommittedExisted.TaxCode == tmpTaxWorkTrans.TaxCode
                                && taxUncommittedExisted.IsDeleted == NoYes::No;
                        if (taxUncommittedExisted.RecId)
                        {
                            TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
                            str callStackString = TaxUncommitted::callStackInfo();
                            taxEventSourceLog.DuplicateTaxUncommitted(tableId2Name(taxUncommittedExisted.SourceTableId), taxUncommittedExisted.SourceRecId, _skipNotExistsCheck, _doIsolateTransactionScope, callStackString);
                            if (isTaxUncommittedDuplicateIssueCheckFlightEnabled)
                            {
                                throw error(strFmt(
                                    "@TaxIntegrationException:DuplicateTaxUncommitted",
                                    taxUncommittedExisted.SourceTableId,
                                    taxUncommittedExisted.SourceRecId));
                            }
                        }
                    }

                    createTaxUncommittedFromTmpTaxWorkTrans();
                }
            }
            else
            {
                // loop through the memory table which holds all the tax lines, creating a
                // tax uncommitted record for each.
                while select *
                from tmpTaxWorkTrans
                where tmpTaxWorkTrans.HeadingRecId == _taxCalculation.headingRecId() &&
                      tmpTaxWorkTrans.HeadingTableId == _taxCalculation.headingTableId()
                notexists join taxUncommitted2
                where tmpTaxWorkTrans.SourceTableId == taxUncommitted2.SourceTableId &&
                      tmpTaxWorkTrans.SourceRecId == taxUncommitted2.SourceRecId &&
                      tmpTaxWorkTrans.TaxCode == taxUncommitted2.TaxCode
                {
                    createTaxUncommittedFromTmpTaxWorkTrans();
                }
            }

            // insert new records
            taxUncommittedList.insertDatabase();

            if (TaxUncommitted::traceCreateTaxUncommitted(_taxCalculation, _skipNotExistsCheck, _doIsolateTransactionScope)
                || _taxCalculation is TaxSales)
            {
                TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
                taxEventSourceLog.CreateTaxUncommitted(tableId2Name(_taxCalculation.headingTableId()),
                                                       _taxCalculation.headingRecId(),
                                                       _skipNotExistsCheck,
                                                       _doIsolateTransactionScope,
                                                       TaxUncommitted::callStackInfo());
            }

            if (_doIsolateTransactionScope)
            {
                connection.ttscommit();
            }
            else if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
            {
                ttscommit;
            }
        }
        finally
        {
            if (connection)
            {
                connection.finalize();
            }
        }

        // <GIN>
        if (TaxParameters::checkTaxParameters_IN())
        {
            TaxUncommitted_IN::createTaxUncommitted(_taxCalculation, _skipNotExistsCheck);
        }
        // </GIN>

        // <GTH>
        if (TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled())
        {
            TaxUncommittedExtensionTH::createTaxUncommitted(_taxCalculation, _skipNotExistsCheck);
        }
        // </GTH>
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceDeleteTaxUncommittedForDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace the deleted <c>TaxUncommitted</c> records for specified document header.
    /// </summary>
    /// <param name="_documentTableId">
    /// The table Id for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record Id of the transaction header.
    /// </param>
    /// <param name="_deleteSourceDocumentLine">
    /// If true, then remove <c>SourceDocumentLine</c> and <c>AccountingDistribution</c> records for the current set of tax records; Optional.
    /// </param>
    /// <param name="_needToCheckEventState">
    /// If true, then remove <c>AccountingDistribution</c> records for the current set of tax records which created for the current active event; Optional.
    /// </param>
    /// <param name="_maintainExistingTaxUncommitted">
    /// A boolean value which indicates that Tax should merge the newly calculated taxes with
    /// existing records in TaxUncommitted.
    /// </param>
    /// <param name="_doIsolateTransactionScope">
    /// True if <c>TaxUncommitted</c> should be maintained in an independent transaction scope; otherwise false.
    /// </param>
    /// <returns>
    /// True if delete for document header; otherwise, false.
    /// </returns>
    public static boolean traceDeleteTaxUncommittedForDocumentHeader(RefTableId _documentTableId,
                                                                     RefRecId   _documentId,
                                                                     boolean    _deleteSourceDocumentLine = true,
                                                                     boolean    _needToCheckEventState = false,
                                                                     boolean    _maintainExistingTaxUncommitted = false,
                                                                     boolean    _doIsolateTransactionScope = false)
    {
        return TaxCalculationInstrumentationToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceDeleteTaxUncommittedForForDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace the deleted <c>TaxUncommitted</c> records for specified document line.
    /// <param name="_sourceTableId">
    /// The table ID of the transaction line.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the transaction line.
    /// </param>
    /// <param name="_deleteSourceDocumentLine">
    /// A Boolean value that indicates whether to remove <c>SourceDocumentLine</c> and
    /// <c>AccountingDistribution</c> records for the current set of tax records; optional.
    /// </param>
    /// <param name="_maintainExistingTaxUncommitted">
    /// A Boolean value that indicates whether Tax should merge the newly calculated taxes with existing
    /// records in the <c>TaxUncommitted</c> table.
    /// </param>
    /// <param name="_doIsolateTransactionScope">
    /// True if <c>TaxUncommitted</c> should be maintained in an independent transaction scope; otherwise false.
    /// </param>
    /// <returns>
    /// True if delete for document line; otherwise, false.
    /// </returns>
    public static boolean traceDeleteTaxUncommittedForForDocumentLine(RefTableId _sourceTableId,
                                                                      RefRecId   _sourceRecId,
                                                                      boolean    _deleteSourceDocumentLine = true,
                                                                      boolean    _maintainExistingTaxUncommitted = false,
                                                                      boolean    _doIsolateTransactionScope = false)
    {
        return TaxCalculationInstrumentationToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceDeleteTaxUncommittedForInvoice</Name>
				<Source><![CDATA[
    /// /// <summary>
    /// Trace the deleted <c>TaxUncommitted</c> records for the specified invoice.
    /// </summary>
    /// <param name="_documentTableId">
    /// The document table ID.
    /// </param>
    /// <param name="_documentId">
    /// The document table ID.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice ID.
    /// </param>
    /// <returns>
    /// True if trace the records; otherwise, false.
    /// </returns>
    public static boolean traceDeleteTaxUncommittedForInvoice(RefTableId _documentTableId,
                                                              RefRecId   _documentId,
                                                              Voucher    _voucher,
                                                              InvoiceId  _invoiceId)
    {
        return TaxCalculationInstrumentationToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceDeleteTaxUncommittedForItemTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace delete <c>TaxUncommitted</c> for specified item sales tax group.
    /// </summary>
    /// <param name = "_taxItemGroup">
    /// The buffer of <c>TaxItemGroup</c>.
    /// </param>
    /// <returns>
    /// True if trace the records; otherwise, false.
    /// </returns>
    public static boolean traceDeleteTaxUncommittedForItemTaxGroup(TaxItemGroup _taxItemGroup)
    {
        return TaxCalculationInstrumentationToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceDeleteTaxUncommittedForTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace delete <c>TaxUncommitted</c> for specified tax code.
    /// </summary>
    /// <param name = "_taxCode">
    /// The buffer of <c>TaxCode</c>.
    /// </param>
    /// <returns>
    /// True if trace the records; otherwise, false.
    /// </returns>
    public static boolean traceDeleteTaxUncommittedForTaxCode(TaxCode _taxCode)
    {
        return TaxCalculationInstrumentationToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceDeleteTaxUncommittedForTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace delete <c>TaxUncommitted</c> for specified tax group.
    /// </summary>
    /// <param name = "_taxGroup">
    /// The buffer of <c>TaxGroup</c>.
    /// </param>
    /// <returns>
    /// True if trace the records; otherwise, false.
    /// </returns>
    public static boolean traceDeleteTaxUncommittedForTaxGroup(TaxGroup _taxGroup)
    {
        return TaxCalculationInstrumentationToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceDeleteTaxUncommittedForVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace delete <c>TaxUncommitted</c> for specified voucher.
    /// </summary>
    /// <param name="_documentTableId">
    /// The document table ID.
    /// </param>
    /// <param name="_documentId">
    /// The document record ID.
    /// </param>
    /// <param name="_voucher">
    /// The voucher used for delete.
    /// </param>
    /// <returns>
    /// True if trace the records; otherwise, false.
    /// </returns>
    public static boolean traceDeleteTaxUncommittedForVoucher(RefTableId _documentTableId,
                                                              RefRecId   _documentId,
                                                              Voucher    _voucher)
    {
        return TaxCalculationInstrumentationToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceDeleteTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace the deleted records for <c>TaxUncommitted</c>.
    /// </summary>
    /// <returns>
    /// True if trace the records; otherwise, false.
    /// </returns>
    public static boolean traceDeleteTaxUncommitted()
    {
        return TaxCalculationInstrumentationToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceUpdateTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace the updated records for <c>TaxUncommitted</c>.
    /// </summary>
    /// <returns>
    /// True if trace the records; otherwise, false.
    /// </returns>
    public static boolean traceUpdateTaxUncommitted(TaxCalculation _taxCalculation, boolean _doIsolateTransactionScope)
    {
        return TaxCalculationInstrumentationToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceCreateTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace the created records for <c>TaxUncommitted</c>.
    /// </summary>
    /// <returns>
    /// True if trace the records; otherwise, false.
    /// </returns>
    public static boolean traceCreateTaxUncommitted(Tax _taxCalculation, boolean _skipNotExistsCheck, boolean _doIsolateTransactionScope)
    {
        return TaxCalculationInstrumentationToggle::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceRecalculateTaxForFinalizedSourceDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace the recaculate tax for finalized source document.
    /// </summary>
    /// <param name = "_canRecalculateTax">
    /// Determines whether to recalculate tax.
    /// </param>
    /// <returns>
    /// True if trace the records; otherwise, false.
    /// </returns>
    public static boolean traceRecalculateTaxForFinalizedSourceDocument(boolean _canRecalculateTax)
    {
        return !_canRecalculateTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceDuplicateTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Trace the duplicate transactions for <c>TaxUncommitted</c>.
    /// </summary>
    /// <param name = "_taxCalculation">
    /// The instance of the tax calculation class used to calculate taxes.
    /// </param>
    /// <param name="_skipNotExistsCheck">
    /// True if the calling code has verified already that no tax uncommitted records exist and the query to find them can be skipped; otherwise, false.
    /// <param name = "_doIsolateTransactionScope">
    /// True if <c>TaxUncommitted</c> should be maintained in an independent transaction scope; otherwise false.
    /// </param>
    /// <returns>
    /// True if trace the records; otherwise, false.
    /// </returns>
    public static boolean traceDuplicateTaxUncommitted(Tax _taxCalculation, boolean _skipNotExistsCheck = false, boolean _doIsolateTransactionScope = false)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callStackInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the information for call stacks
    /// </summary>
    /// <returns>Return the information for call stacks.</returns>
    public static str callStackInfo()
    {
        container callStack = xSession::xppCallStack();

        str callStackString;

        for (int i = 1; i <= conlen(callStack); i++)
        {
            callStackString += conpeek(callStack, i) + '\r\n';
        }

        return callStackString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the current set of <c>TaxUncommitted</c> records for the specified document.
    /// </summary>
    /// <param name="_documentTableId">
    /// The table Id for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record Id of the transaction header.
    /// </param>
    /// <param name="_deleteSourceDocumentLine">
    /// If true, then remove <c>SourceDocumentLine</c> and <c>AccountingDistribution</c> records for the current set of tax records; Optional.
    /// </param>
    /// <param name="_needToCheckEventState">
    /// If true, then remove <c>AccountingDistribution</c> records for the current set of tax records which created for the current active event; Optional.
    /// </param>
    /// <param name="_maintainExistingTaxUncommitted">
    /// A boolean value which indicates that Tax should merge the newly calculated taxes with
    /// existing records in TaxUncommitted.
    /// </param>
    /// <param name="_doIsolateTransactionScope">
    /// true if <c>TaxUncommitted</c> should be maintained in a independent transaction scope; otherwise false.
    /// </param>
    public static void deleteForDocumentHeader(RefTableId   _documentTableId,
                                                      RefRecId     _documentId,
                                                      boolean      _deleteSourceDocumentLine = true,
                                                      boolean      _needToCheckEventState = false,
                                                      boolean      _maintainExistingTaxUncommitted = false,
                                                      boolean      _doIsolateTransactionScope = false)
    {
        TaxUncommitted              taxUncommitted;
        AccountingDistribution      accountingDistribution;
        SourceDocumentLine          sourceDocumentLine;
        UserConnection              connection;

        // <GIN>
        #ISOCountryRegionCodes
        boolean                     isoIN         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        TaxUncommitted_IN           taxUncommittedIN;
        // </GIN>
        // <GTH>
        boolean                     isoTH         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]);
        TaxUncommittedExtensionTH   taxUncommittedExtTH;
        // </GTH>

        if (!TaxUncommitted::existByDocumentId(_documentTableId, _documentId))
        {
            return;
        }

        if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
        {
            _doIsolateTransactionScope = false;
        }

        try
        {
            if (_doIsolateTransactionScope)
            {
                connection = new UserConnection();

                taxUncommitted.setConnection(connection);
                accountingDistribution.setConnection(connection);
                sourceDocumentLine.setConnection(connection);
                taxUncommittedIN.setConnection(connection);
                taxUncommittedExtTH.setConnection(connection);

                connection.ttsbegin();
            }
            else if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
            {
                ttsbegin;
            }

            if (_maintainExistingTaxUncommitted)
            {
                // delete any existing TaxUncommitted records which don't use SLJL feature.
                update_recordset taxUncommitted
                    setting
                        IsDeleted = NoYes::Yes,
                        TaxAmount = 0,
                        TaxBaseAmount = 0,
                        TaxBaseAmountCur = 0,
                        TaxBaseAmountRep = 0,
                        SourceTaxAmountCur = 0,
                        TaxAmountCur = 0,
                        TaxamountRep = 0,
                        SourceBaseAmountCur = 0,
                        TaxInCostPrice = 0,
                        SourceRegulateAmountCur = 0,
                        TaxInCostPriceRegulated = 0,
                        TaxInCostPriceCur = 0,
                        TaxInCostPriceRep = 0,
                        TaxInCostPriceMST = 0,
                        SourceBaseAmountCurRegulated = 0,
                        SourceTaxAmountCurReal = 0,
                        SourceBaseAmountCurRaw = 0,
                        TaxBaseAmountRaw = 0
                    where taxUncommitted.HeadingRecId == _documentId &&
                            taxUncommitted.HeadingTableId == _documentTableId;
            }
            else
            {
                Set deletedRecIds = new Set(Types::Int64);

                if (_deleteSourceDocumentLine)
                {                    
                    // delete distributions which are non-reversal and not posted to GL
                    boolean shouldSkipSDLDeleteAction = TaxUncommitted::shouldSkipSDLDeleteActionWhenDeleteForDocumentHeader(_documentTableId, _documentId);

                    accountingDistribution.skipEvents(true);
                    accountingDistribution.skipDataMethods(true);
                    accountingDistribution.skipDeleteActions(shouldSkipSDLDeleteAction);
                    delete_from accountingDistribution
                        where accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
                            accountingDistribution.AccountingEvent == 0
                        exists join taxUncommitted
                            where taxUncommitted.HeadingRecId       == _documentId &&
                                    taxUncommitted.HeadingTableId     == _documentTableId &&
                                    taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine;
                    
                    // delete source document lines which have no distribution.
                    if (TaxUncommitted::traceDeleteTaxUncommittedForDocumentHeader(_documentTableId, _documentId, _deleteSourceDocumentLine, _needToCheckEventState, _maintainExistingTaxUncommitted, _doIsolateTransactionScope))
                    {
                        while select sourceDocumentLine
                            exists join taxUncommitted
                                where taxUncommitted.HeadingRecId       == _documentId &&
                                      taxUncommitted.HeadingTableId     == _documentTableId &&
                                      taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
                            notexists join accountingDistribution
                                where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId
                        {
                            deletedRecIds.add(sourceDocumentLine.RecId);
                        }
                    }

                    // BudgetControlSourceDocumentLineToBeDeletedTmp is created by using the same query
                    // to find out source document lines to be deleted.
                    ttsbegin;
                    BudgetControlSourceDocumentLineToBeDeletedTmp::createBudgetControlSourceDocumentLineToBeDeletedTmp(_documentTableId, _documentId);

                    sourceDocumentLine.skipEvents(true);
                    sourceDocumentLine.skipDataMethods(true);
                    sourceDocumentLine.skipDeleteActions(shouldSkipSDLDeleteAction);
                    delete_from sourceDocumentLine
                        exists join taxUncommitted
                            where taxUncommitted.HeadingRecId       == _documentId &&
                                    taxUncommitted.HeadingTableId     == _documentTableId &&
                                    taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
                        notexists join accountingDistribution
                            where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId;

                    ttscommit;

                    // <GIN>
                    if (isoIN)
                    {
                        delete_from taxUncommittedIN
                            exists join taxUncommitted
                                where taxUncommitted.RecId          == taxUncommittedIN.TaxUncommitted &&
                                      taxUncommitted.HeadingRecId   == _documentId &&
                                      taxUncommitted.HeadingTableId == _documentTableId
                            notexists join accountingDistribution
                                where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
                    }
                    // </GIN>

                    // <GTH>
                    if (isoTH)
                    {
                        delete_from taxUncommittedExtTH
                            exists join taxUncommitted
                                where taxUncommitted.RecId              == taxUncommittedExtTH.TaxUncommitted
                                    && taxUncommitted.HeadingRecId      == _documentId
                                    && taxUncommitted.HeadingTableId    == _documentTableId
                            notexists join accountingDistribution
                                where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
                    }
                    // </GTH>

                    // delete any existing TaxUncommitted records which have no distribution.
                    delete_from taxUncommitted
                        where taxUncommitted.HeadingRecId == _documentId &&
                              taxUncommitted.HeadingTableId == _documentTableId
                        notexists join accountingDistribution
                            where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
                }
                else
                {
                    // <GIN>
                    if (isoIN)
                    {
                        delete_from taxUncommittedIN
                            exists join taxUncommitted
                                where taxUncommitted.RecId          == taxUncommittedIN.TaxUncommitted &&
                                      taxUncommitted.HeadingRecId   == _documentId &&
                                      taxUncommitted.HeadingTableId == _documentTableId &&
                                      taxUncommitted.Company == curext();
                    }
                    // </GIN>

                    // <GTH>
                    if (isoTH)
                    {
                        delete_from taxUncommittedExtTH
                            exists join taxUncommitted
                                where taxUncommitted.RecId              == taxUncommittedExtTH.TaxUncommitted
                                    && taxUncommitted.HeadingRecId      == _documentId
                                    && taxUncommitted.HeadingTableId    == _documentTableId
                                    && taxUncommitted.Company           == curext();
                    }
                    // </GTH>

                    // delete any existing TaxUncommitted records which don't use SLJL feature.
                    delete_from taxUncommitted
                        where taxUncommitted.HeadingRecId == _documentId &&
                                taxUncommitted.HeadingTableId == _documentTableId;
                }

                if (TaxUncommitted::traceDeleteTaxUncommittedForDocumentHeader(_documentTableId, _documentId, _deleteSourceDocumentLine, _needToCheckEventState, _maintainExistingTaxUncommitted, _doIsolateTransactionScope))
                {
                    TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
                    str callStackString = taxUncommitted::callStackInfo();
                    str recIds = deletedRecIds.toString();
                    boolean isDeleted;

                    select firstonly RecId from taxUncommitted
                        where taxUncommitted.HeadingRecId == _documentId &&
                                taxUncommitted.HeadingTableId == _documentTableId;

                    isDeleted = (taxUncommitted.RecId == 0);

                    taxEventSourceLog.DeleteTaxUncommittedForDocumentHeader(tableId2Name(_documentTableId),
                                                                            _documentId,
                                                                            _deleteSourceDocumentLine,
                                                                            _needToCheckEventState,
                                                                            _maintainExistingTaxUncommitted,
                                                                            _doIsolateTransactionScope,
                                                                            callStackString,
                                                                            recIds,
                                                                            isDeleted);
                }
            }

            if (_doIsolateTransactionScope)
            {
                connection.ttscommit();
            }
            else if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
            {
                ttscommit;
            }
        }
        finally
        {
            if (connection)
            {
                connection.finalize();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the current set of <c>TaxUncommitted</c> records for the specified document line.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the transaction line.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the transaction line.
    /// </param>
    /// <param name="_deleteSourceDocumentLine">
    /// A Boolean value that indicates whether to remove <c>SourceDocumentLine</c> and
    /// <c>AccountingDistribution</c> records for the current set of tax records; optional.
    /// </param>
    /// <param name="_maintainExistingTaxUncommitted">
    /// A Boolean value that indicates whether Tax should merge the newly calculated taxes with existing
    /// records in the <c>TaxUncommitted</c> table.
    /// </param>
    /// <param name="_doIsolateTransactionScope">
    /// true if <c>TaxUncommitted</c> should be maintained in a independent transaction scope; otherwise false.
    /// </param>
    /// <remarks>
    /// Deleting taxes for a single line will break all tax rules that are based on invoice total. If the
    /// calling transaction supports taxes that are based on invoice total, do not use this method.
    /// Instead, use the <c>TaxUncommitted::deleteForDocumentHeader</c> method.
    /// </remarks>
    public static void deleteForDocumentLine(RefTableId _sourceTableId,
                                             RefRecId   _sourceRecId,
                                             boolean    _deleteSourceDocumentLine = true,
                                             boolean    _maintainExistingTaxUncommitted = false,
                                             boolean    _doIsolateTransactionScope = false)
    {
        TaxUncommitted              taxUncommitted;
        AccountingDistribution      accountingDistribution;
        SourceDocumentLine          sourceDocumentLine;
        UserConnection              connection;

        // <GIN>
        #ISOCountryRegionCodes
        boolean                     isoIN         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        TaxUncommitted_IN           taxUncommittedIN;
        // </GIN>
        // <GTH>
        boolean                     isoTH         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]);
        TaxUncommittedExtensionTH   taxUncommittedExtTH;
        // </GTH>

        // It is generally not valid to delete taxes for a single line.  In most scenarios the use of this function will cause a bug.
        if(!TaxUncommitted::existByDocumentLineId(_sourceTableId, _sourceRecId))
        {
            return;
        }

        if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
        {
            _doIsolateTransactionScope = false;
        }

        try
        {
            if(_doIsolateTransactionScope)
            {
                connection = new UserConnection();

                taxUncommitted.setConnection(connection);
                accountingDistribution.setConnection(connection);
                sourceDocumentLine.setConnection(connection);
                taxUncommittedIN.setConnection(connection);
                taxUncommittedExtTH.setConnection(connection);

                connection.ttsbegin();
            }
            else if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
            {
                ttsbegin;
            }
        
            if (_maintainExistingTaxUncommitted)
            {
                // delete any existing TaxUncommitted records which don't use SLJL feature.
                update_recordset taxUncommitted
                    setting
                        IsDeleted = NoYes::Yes,
                        TaxAmount = 0,
                        TaxBaseAmount = 0,
                        TaxBaseAmountCur = 0,
                        TaxBaseAmountRep = 0,
                        SourceTaxAmountCur = 0,
                        TaxAmountCur = 0,
                        TaxAmountRep = 0,
                        SourceBaseAmountCur = 0,
                        TaxInCostPrice = 0,
                        SourceRegulateAmountCur = 0,
                        TaxInCostPriceRegulated = 0,
                        TaxInCostPriceCur = 0,
                        TaxInCostPriceRep = 0,
                        TaxInCostPriceMST = 0,
                        SourceBaseAmountCurRegulated = 0,
                        SourceTaxAmountCurReal = 0,
                        SourceBaseAmountCurRaw = 0,
                        TaxBaseAmountRaw = 0
                    where taxUncommitted.SourceRecId == _sourceRecId &&
                            taxUncommitted.SourceTableId == _sourceTableId;
            }
            else
            {
                Set deletedRecIds = new Set(Types::Int64);

                if (_deleteSourceDocumentLine)
                {
                    // delete distributions which are non-reversal and not posted to GL
                    
                    boolean shouldSkipSDLDeleteAction = TaxUncommitted::shouldSkipSDLDeleteActionWhenDeleteForDocumentLine(_sourceTableId, _sourceRecId);

                    accountingDistribution.skipEvents(true);
                    accountingDistribution.skipDataMethods(true);
                    accountingDistribution.skipDeleteActions(shouldSkipSDLDeleteAction);
                    delete_from accountingDistribution
                        where accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
                            accountingDistribution.AccountingEvent == 0
                        exists join taxUncommitted
                            where taxUncommitted.SourceRecId        == _sourceRecId &&
                                    taxUncommitted.SourceTableId      == _sourceTableId &&
                                    taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine;

                    // delete source document lines which have no distribution.
                    if(TaxUncommitted::traceDeleteTaxUncommittedForForDocumentLine(_sourceTableId, _sourceRecId, _deleteSourceDocumentLine, _maintainExistingTaxUncommitted, _doIsolateTransactionScope))
                    {
                        while select sourceDocumentLine
                            exists join taxUncommitted
                                where taxUncommitted.SourceRecId        == _sourceRecId &&
                                      taxUncommitted.SourceTableId      == _sourceTableId &&
                                      taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
                            notexists join accountingDistribution
                                where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId
                        {
                            deletedRecIds.add(sourceDocumentLine.RecId);
                        }
                    }

                    sourceDocumentLine.skipEvents(true);
                    sourceDocumentLine.skipDataMethods(true);
                    sourceDocumentLine.skipDeleteActions(shouldSkipSDLDeleteAction);
                    delete_from sourceDocumentLine
                    exists join taxUncommitted
                        where taxUncommitted.SourceRecId        == _sourceRecId &&
                                taxUncommitted.SourceTableId      == _sourceTableId &&
                                taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
                    notexists join accountingDistribution
                        where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId;

                    // <GIN>
                    if (isoIN)
                    {
                        delete_from taxUncommittedIN
                            exists join taxUncommitted
                                where taxUncommitted.RecId          == taxUncommittedIN.TaxUncommitted &&
                                      taxUncommitted.SourceRecId    == _sourceRecId &&
                                      taxUncommitted.SourceTableId  == _sourceTableId
                                notexists join accountingDistribution
                                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
                    }
                    // </GIN>

                    // <GTH>
                    if (isoTH)
                    {
                        delete_from taxUncommittedExtTH
                            exists join taxUncommitted
                                where taxUncommitted.RecId          == taxUncommittedExtTH.TaxUncommitted
                                    && taxUncommitted.SourceRecId   == _sourceRecId
                                    && taxUncommitted.SourceTableId == _sourceTableId
                                notexists join accountingDistribution
                                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
                    }
                    // </GTH>

                    // delete any existing TaxUncommitted records which have no distribution.
                    delete_from taxUncommitted
                        where taxUncommitted.SourceRecId == _sourceRecId &&
                                taxUncommitted.SourceTableId == _sourceTableId
                        notexists join accountingDistribution
                            where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
                }
                else
                {
                    // <GIN>
                    if (isoIN)
                    {
                        delete_from taxUncommittedIN
                            exists join taxUncommitted
                                where taxUncommitted.RecId          == taxUncommittedIN.TaxUncommitted &&
                                      taxUncommitted.SourceRecId    == _sourceRecId &&
                                      taxUncommitted.SourceTableId  == _sourceTableId;
                    }
                    // </GIN>

                    // <GTH>
                    if (isoTH)
                    {
                        delete_from taxUncommittedExtTH
                            exists join taxUncommitted
                                where taxUncommitted.RecId          == taxUncommittedExtTH.TaxUncommitted
                                    && taxUncommitted.SourceRecId   == _sourceRecId
                                    && taxUncommitted.SourceTableId == _sourceTableId;
                    }
                    // </GTH>

                    // delete any existing TaxUncommitted records which don't use SLJL feature.
                    delete_from taxUncommitted
                        where taxUncommitted.SourceRecId == _sourceRecId &&
                                taxUncommitted.SourceTableId == _sourceTableId;
                }

                if (TaxUncommitted::traceDeleteTaxUncommittedForForDocumentLine(_sourceTableId, _sourceRecId, _deleteSourceDocumentLine, _maintainExistingTaxUncommitted, _doIsolateTransactionScope))
                {
                    TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
                    str callStackString = TaxUncommitted::callStackInfo();
                    str recIds = deletedRecIds.toString();
                    boolean isDeleted;

                    select firstonly RecId from taxUncommitted
                        where taxUncommitted.SourceRecId == _sourceRecId &&
                                taxUncommitted.SourceTableId == _sourceTableId;

                    isDeleted = (taxUncommitted.RecId == 0);

                    taxEventSourceLog.DeleteTaxUncommittedForDocumentLine(tableId2Name(_sourceTableId),
                                                                          _sourceRecId,
                                                                          _deleteSourceDocumentLine,
                                                                          _maintainExistingTaxUncommitted,
                                                                          _doIsolateTransactionScope,
                                                                          callStackString,
                                                                          recIds,
                                                                          isDeleted);
                }
            }

            if (_doIsolateTransactionScope)
            {
                connection.ttscommit();
            }
            else if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
            {
                ttscommit;
            }
        }
        finally
        {
            if (connection)
            {
                connection.finalize();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>TaxUncommitted</c> records for the invoice.
    /// </summary>
    /// <param name="_documentTableId">
    /// The document table ID.
    /// </param>
    /// <param name="_documentId">
    /// The document table ID.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice ID.
    /// </param>
    static public void deleteForInvoice(RefTableId _documentTableId,
                                        RefRecId _documentId,
                                        Voucher _voucher,
                                        InvoiceId _invoiceId)
    {
        TaxUncommitted taxUncommitted;

        // <GIN>
        #ISOCountryRegionCodes
        boolean                     isoIN         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        TaxUncommitted_IN           taxUncommittedIN;
        // </GIN>
        // <GTH>
        boolean                     isoTH         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]);
        TaxUncommittedExtensionTH   taxUncommittedExtTH;
        // </GTH>

        // <GIN>
        if (isoIN)
        {
            delete_from taxUncommittedIN
                exists join taxUncommitted
                    where taxUncommitted.RecId          == taxUncommittedIN.TaxUncommitted &&
                          taxUncommitted.HeadingRecId   == _documentId &&
                          taxUncommitted.HeadingTableId == _documentTableId &&
                          taxUncommitted.Voucher        == _voucher &&
                          taxUncommitted.InvoiceId      == _invoiceId;
        }
        // </GIN>

        // <GTH>
        if (isoTH)
        {
            delete_from taxUncommittedExtTH
                exists join taxUncommitted
                    where taxUncommitted.RecId              == taxUncommittedExtTH.TaxUncommitted
                        && taxUncommitted.HeadingRecId      == _documentId
                        && taxUncommitted.HeadingTableId    == _documentTableId
                        && taxUncommitted.Voucher           == _voucher
                        && taxUncommitted.InvoiceId         == _invoiceId;
        }
        // </GTH>

        // delete any existing TaxUncommitted records as a set
        delete_from taxUncommitted
        where taxUncommitted.HeadingRecId == _documentId &&
              taxUncommitted.HeadingTableId == _documentTableId &&
              taxUncommitted.Voucher == _voucher &&
              taxUncommitted.InvoiceId == _invoiceId;

        if(TaxUncommitted::traceDeleteTaxUncommittedForInvoice(_documentTableId, _documentId, _voucher, _invoiceId))
        {
            TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
            str callStackString = TaxUncommitted::callStackInfo();
            boolean isDeleted;

            select firstonly RecId from taxUncommitted
            where taxUncommitted.HeadingRecId == _documentId &&
                  taxUncommitted.HeadingTableId == _documentTableId &&
                  taxUncommitted.Voucher == _voucher &&
                  taxUncommitted.InvoiceId == _invoiceId;

            isDeleted = (taxUncommitted.RecId == 0);

            taxEventSourceLog.DeleteTaxUncommittedForInvoice(tableId2Name(_documentTableId),
                                                             _documentId,
                                                             _voucher,
                                                             _invoiceId,
                                                             callStackString,
                                                             isDeleted);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForItemTaxGroup</Name>
				<Source><![CDATA[
    public static void deleteForItemTaxGroup(TaxItemGroup _taxItemGroup)
    {
        TaxUncommitted          taxUncommitted;
        TaxUncommitted          taxUncommittedSelf;
        AccountingDistribution  accountingDistribution;
        SourceDocumentLine      sourceDocumentLine;

        // <GIN>
        #ISOCountryRegionCodes
        boolean                     isoIN         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        TaxUncommitted_IN           taxUncommittedIN;
        // </GIN>
        // <GTH>
        boolean                     isoTH         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]);
        TaxUncommittedExtensionTH   taxUncommittedExtTH;
        // </GTH>

        // delete distributions which are not posted to GL
        ttsbegin;

        boolean shouldSkipSDLDeleteAction = TaxUncommitted::shouldSkipSDLDeleteActionWhenDeleteForItemTaxGroup(_taxItemGroup);

        accountingDistribution.skipEvents(true);
        accountingDistribution.skipDataMethods(true);
        accountingDistribution.skipDeleteActions(shouldSkipSDLDeleteAction);
        delete_from accountingDistribution
            where accountingDistribution.AccountingEvent == 0
            exists join taxUncommitted
                where taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine
            exists join taxUncommittedSelf
                where taxUncommittedSelf.TaxItemGroup == _taxItemGroup &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId;

        // delete source document lines which have no distribution.
        Set deletedRecIds = new Set(Types::Int64);
        if(TaxUncommitted::traceDeleteTaxUncommittedForItemTaxGroup(_taxItemGroup))
        {
            while select sourceDocumentLine
                exists join taxUncommitted
                    where taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxItemGroup == _taxItemGroup &&
                          taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId
            {
                deletedRecIds.add(sourceDocumentLine.RecId);
            }
        }

        sourceDocumentLine.skipEvents(true);
        sourceDocumentLine.skipDataMethods(true);
        sourceDocumentLine.skipDeleteActions(shouldSkipSDLDeleteAction);
        delete_from sourceDocumentLine
            exists join taxUncommitted
                where taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
            exists join taxUncommittedSelf
                where taxUncommittedSelf.TaxItemGroup == _taxItemGroup &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
            notexists join accountingDistribution
                where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId;

        // <GIN>
        if (isoIN)
        {
            delete_from taxUncommittedIN
                exists join taxUncommitted
                    where taxUncommitted.RecId          == taxUncommittedIN.TaxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxItemGroup   == _taxItemGroup &&
                          taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                    notexists join accountingDistribution
                        where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
        }
        // </GIN>

        // <GTH>
        if (isoTH)
        {
            delete_from taxUncommittedExtTH
                exists join taxUncommitted
                    where taxUncommitted.RecId          == taxUncommittedExtTH.TaxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxItemGroup       == _taxItemGroup
                        && taxUncommittedSelf.HeadingTableId    == taxUncommitted.HeadingTableId
                        && taxUncommittedSelf.HeadingRecId      == taxUncommitted.HeadingRecId
                    notexists join accountingDistribution
                        where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
        }
        // </GTH>

        Set purchTableRecIdSet = new Set(Types::Int64);
        while select taxUncommitted
             exists join taxUncommittedSelf
                 where taxUncommittedSelf.TaxItemGroup == _taxItemGroup &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId &&
                      taxUncommittedSelf.HeadingTableId == tableNum(PurchTable)
             notexists join accountingDistribution
                 where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine
        {
            purchTableRecIdSet.add(taxUncommitted.HeadingRecId);
        }

        // delete any existing TaxUncommitted records which have no distribution.
        delete_from taxUncommitted
            exists join taxUncommittedSelf
                where taxUncommittedSelf.TaxItemGroup == _taxItemGroup &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
            notexists join accountingDistribution
                where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;

        if(TaxUncommitted::traceDeleteTaxUncommittedForItemTaxGroup(_taxItemGroup))
        {
            TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
            str callStackString = TaxUncommitted::callStackInfo();
            str recIds = deletedRecIds.toString();
            boolean isDeleted;

            select firstonly RecId from taxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxItemGroup == _taxItemGroup &&
                          taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;

            isDeleted = (taxUncommitted.RecId == 0);

            taxEventSourceLog.DeleteTaxUncommittedForItemTaxGroup(_taxItemGroup,
                                                                  callStackString,
                                                                  recIds,
                                                                  isDeleted);
        }

        SetEnumerator setEnumerator = purchTableRecIdSet.getEnumerator();
        PurchTable purchTable;
        while (setEnumerator.moveNext())
        {
            purchTable = PurchTable::findRecId(setEnumerator.current());
            if (purchTable
                && purchTable.ChangeRequestRequired
                && purchTable.PurchStatus == PurchStatus::Backorder
                && PurchTable.DocumentState == VersioningDocumentState::Confirmed)
            {
                purchTable.selectforupdate(true);
                purchTable.DocumentState = VersioningDocumentState::Draft;
                purchTable.update();
            }
        }
        ttscommit;

    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForTaxCode</Name>
				<Source><![CDATA[
    public static void deleteForTaxCode(TaxCode _taxCode)
    {
        TaxUncommitted          taxUncommitted;
        TaxUncommitted          taxUncommittedSelf;
        AccountingDistribution  accountingDistribution;
        SourceDocumentLine      sourceDocumentLine;

        // <GIN>
        #ISOCountryRegionCodes
        boolean                     isoIN         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        TaxUncommitted_IN           taxUncommittedIN;
        // </GIN>
        // <GTH>
        boolean                     isoTH         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]);
        TaxUncommittedExtensionTH   taxUncommittedExtTH;
        // </GTH>

        // delete distributions which are not posted to GL
        ttsbegin;

        boolean shouldSkipSDLDeleteAction = TaxUncommitted::shouldSkipSDLDeleteActionWhenDeleteForTaxCode(_taxCode);

        accountingDistribution.skipEvents(true);
        accountingDistribution.skipDataMethods(true);
        accountingDistribution.skipDeleteActions(shouldSkipSDLDeleteAction);
        delete_from accountingDistribution
            where accountingDistribution.AccountingEvent == 0
            exists join taxUncommitted
                where taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine
            exists join taxUncommittedSelf
                where taxUncommittedSelf.TaxCode == _taxCode &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId;

        // delete source dcoument lines which have no distribution.
        Set deletedRecIds = new Set(Types::Int64);
        if(TaxUncommitted::traceDeleteTaxUncommittedForTaxCode(_taxCode))
        {
            while select sourceDocumentLine
                exists join taxUncommitted
                    where taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxCode == _taxCode &&
                          taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId
            {
                deletedRecIds.add(sourceDocumentLine.RecId);
            }
        }

        sourceDocumentLine.skipEvents(true);
        sourceDocumentLine.skipDataMethods(true);
        sourceDocumentLine.skipDeleteActions(shouldSkipSDLDeleteAction);
        delete_from sourceDocumentLine
            exists join taxUncommitted
                where taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
            exists join taxUncommittedSelf
                where taxUncommittedSelf.TaxCode == _taxCode &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
            notexists join accountingDistribution
                where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId;

        // <GIN>
        if (isoIN)
        {
            delete_from taxUncommittedIN
                exists join taxUncommitted
                    where taxUncommitted.RecId          == taxUncommittedIN.TaxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxCode        == _taxCode &&
                          taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
        }
        // </GIN>

        // <GTH>
        if (isoTH)
        {
            delete_from taxUncommittedExtTH
                exists join taxUncommitted
                    where taxUncommitted.RecId          == taxUncommittedExtTH.TaxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxCode            == _taxCode
                        && taxUncommittedSelf.HeadingTableId    == taxUncommitted.HeadingTableId
                        && taxUncommittedSelf.HeadingRecId      == taxUncommitted.HeadingRecId
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
        }
        // </GTH>

        Set purchTableRecIdSet = new Set(Types::Int64);
        while select taxUncommitted
             exists join taxUncommittedSelf
                 where taxUncommittedSelf.TaxCode == _taxCode &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId &&
                      taxUncommittedSelf.HeadingTableId == tableNum(PurchTable)
             notexists join accountingDistribution
                 where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine
        {
            purchTableRecIdSet.add(taxUncommitted.HeadingRecId);
        }

        // delete any existing TaxUncommitted records which have no distribution.
        delete_from taxUncommitted
            exists join taxUncommittedSelf
                where taxUncommittedSelf.TaxCode == _taxCode &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
            notexists join accountingDistribution
                where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;

        if(TaxUncommitted::traceDeleteTaxUncommittedForTaxCode(_taxCode))
        {
            TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
            str callStackString = TaxUncommitted::callStackInfo();
            str recIds = deletedRecIds.toString();
            boolean isDeleted;

            select firstonly RecId from taxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxCode == _taxCode &&
                          taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;

            isDeleted = (taxUncommitted.RecId == 0);

            taxEventSourceLog.DeleteTaxUncommittedForTaxCode(_taxCode,
                                                             callStackString,
                                                             recIds,
                                                             isDeleted);
        }

        SetEnumerator setEnumerator = purchTableRecIdSet.getEnumerator();
        PurchTable purchTable;
        while (setEnumerator.moveNext())
        {
            purchTable = PurchTable::findRecId(setEnumerator.current());
            if (purchTable
                && purchTable.ChangeRequestRequired
                && purchTable.PurchStatus == PurchStatus::Backorder
                && PurchTable.DocumentState == VersioningDocumentState::Confirmed)
            {
                purchTable.selectforupdate(true);
                purchTable.DocumentState = VersioningDocumentState::Draft;
                purchTable.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForTaxGroup</Name>
				<Source><![CDATA[
    public static void deleteForTaxGroup(TaxGroup _taxGroup)
    {
        TaxUncommitted          taxUncommitted;
        TaxUncommitted          taxUncommittedSelf;
        AccountingDistribution  accountingDistribution;
        SourceDocumentLine      sourceDocumentLine;

        // <GIN>
        #ISOCountryRegionCodes
        boolean                     isoIN         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        TaxUncommitted_IN           taxUncommittedIN;
        // </GIN>
        // <GTH>
        boolean                     isoTH         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]);
        TaxUncommittedExtensionTH   taxUncommittedExtTH;
        // </GTH>

        // delete distributions which are not posted to GL
        ttsbegin;

        boolean shouldSkipSDLDeleteAction = TaxUncommitted::shouldSkipSDLDeleteActionWhenDeleteForTaxGroup(_taxGroup);

        accountingDistribution.skipEvents(true);
        accountingDistribution.skipDataMethods(true);
        accountingDistribution.skipDeleteActions(shouldSkipSDLDeleteAction);
        delete_from accountingDistribution
            where accountingDistribution.AccountingEvent == 0
            exists join taxUncommitted
                where taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine
            exists join taxUncommittedSelf
                where taxUncommittedSelf.TaxGroup == _taxGroup &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId;

        // delete source dcoument lines which have no distribution.
        Set deletedRecIds = new Set(Types::Int64);
        if(TaxUncommitted::traceDeleteTaxUncommittedForTaxGroup(_taxGroup))
        {
            while select sourceDocumentLine
                exists join taxUncommitted
                    where taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxGroup == _taxGroup &&
                          taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId
            {
                deletedRecIds.add(sourceDocumentLine.RecId);
            }
        }

        sourceDocumentLine.skipEvents(true);
        sourceDocumentLine.skipDataMethods(true);
        sourceDocumentLine.skipDeleteActions(shouldSkipSDLDeleteAction);
        delete_from sourceDocumentLine
            exists join taxUncommitted
                where taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
            exists join taxUncommittedSelf
                where taxUncommittedSelf.TaxGroup == _taxGroup &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
            notexists join accountingDistribution
                where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId;

        // <GIN>
        if (isoIN)
        {
            delete_from taxUncommittedIN
                exists join taxUncommitted
                    where taxUncommitted.RecId          == taxUncommittedIN.TaxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxGroup   == _taxGroup &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
        }
        // </GIN>

        // <GTH>
        if (isoTH)
        {
            delete_from taxUncommittedExtTH
                exists join taxUncommitted
                    where taxUncommitted.RecId          == taxUncommittedExtTH.TaxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxGroup           == _taxGroup
                        && taxUncommittedSelf.HeadingTableId    == taxUncommitted.HeadingTableId
                        && taxUncommittedSelf.HeadingRecId      == taxUncommitted.HeadingRecId
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
        }
        // </GTH>

        Set purchTableRecIdSet = new Set(Types::Int64);
        while select taxUncommitted
             exists join taxUncommittedSelf
                 where taxUncommittedSelf.TaxGroup == _taxGroup &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId &&
                      taxUncommittedSelf.HeadingTableId == tableNum(PurchTable)
             notexists join accountingDistribution
                 where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine
        {
            purchTableRecIdSet.add(taxUncommitted.HeadingRecId);
        }

        // delete any existing TaxUncommitted records which have no distribution.
        delete_from taxUncommitted
            exists join taxUncommittedSelf
                where taxUncommittedSelf.TaxGroup == _taxGroup &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
            notexists join accountingDistribution
                where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;

        if(TaxUncommitted::traceDeleteTaxUncommittedForTaxGroup(_taxGroup))
        {
            TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
            str callStackString = TaxUncommitted::callStackInfo();
            str recIds = deletedRecIds.toString();
            boolean isDeleted;

            select firstonly RecId from taxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxGroup == _taxGroup &&
                          taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;

            isDeleted = (taxUncommitted.RecId == 0);

            taxEventSourceLog.DeleteTaxUncommittedForTaxGroup(_taxGroup,
                                                              callStackString,
                                                              recIds,
                                                              isDeleted);
        }

        SetEnumerator setEnumerator = purchTableRecIdSet.getEnumerator();
        PurchTable purchTable;
        while (setEnumerator.moveNext())
        {
            purchTable = PurchTable::findRecId(setEnumerator.current());
            if (purchTable
                && purchTable.ChangeRequestRequired
                && purchTable.PurchStatus == PurchStatus::Backorder
                && PurchTable.DocumentState == VersioningDocumentState::Confirmed)
            {
                purchTable.selectforupdate(true);
                purchTable.DocumentState = VersioningDocumentState::Draft;
                purchTable.update();
            }
        }
        ttscommit;

    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the specified <c>TaxUncommitted</c> records.
    /// </summary>
    /// <param name="_documentTableId">
    /// The document table ID.
    /// </param>
    /// <param name="_documentId">
    /// The document record ID.
    /// </param>
    /// <param name="_voucher">
    /// The voucher used for delete.
    /// </param>
    static public void deleteForVoucher(RefTableId _documentTableId,
                                        RefRecId _documentId,
                                        Voucher _voucher)
    {
        TaxUncommitted taxUncommitted;

        // <GIN>
        #ISOCountryRegionCodes
        boolean                     isoIN         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        TaxUncommitted_IN           taxUncommittedIN;
        // </GIN>
        // <GTH>
        boolean                     isoTH         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]);
        TaxUncommittedExtensionTH   taxUncommittedExtTH;
        // </GTH>

        // <GIN>
        if (isoIN)
        {
            delete_from taxUncommittedIN
                exists join taxUncommitted
                    where taxUncommitted.RecId          == taxUncommittedIN.TaxUncommitted &&
                          taxUncommitted.HeadingRecId   == _documentId &&
                          taxUncommitted.HeadingTableId == _documentTableId &&
                          taxUncommitted.Voucher        == _voucher;
        }
        // </GIN>

        // <GTH>
        if (isoTH)
        {
            delete_from taxUncommittedExtTH
                exists join taxUncommitted
                    where taxUncommitted.RecId              == taxUncommittedExtTH.TaxUncommitted
                        && taxUncommitted.HeadingRecId      == _documentId
                        && taxUncommitted.HeadingTableId    == _documentTableId
                        && taxUncommitted.Voucher           == _voucher;
        }
        // </GTH>

        // delete any existing TaxUncommitted records as a set
        delete_from taxUncommitted
            where taxUncommitted.HeadingRecId == _documentId &&
              taxUncommitted.HeadingTableId == _documentTableId &&
              taxUncommitted.Voucher == _voucher;

        if(TaxUncommitted::traceDeleteTaxUncommittedForVoucher(_documentTableId, _documentId, _voucher))
        {
            TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
            str callStackString = taxUncommitted::callStackInfo();
            boolean isDeleted;

            select firstonly RecId from taxUncommitted
                where taxUncommitted.HeadingRecId == _documentId &&
                  taxUncommitted.HeadingTableId == _documentTableId &&
                  taxUncommitted.Voucher == _voucher;

            isDeleted = (taxUncommitted.RecId == 0);

            taxEventSourceLog.DeleteTaxUncommittedForVoucher(tableId2Name(_documentTableId),
                                                             _documentId,
                                                             _voucher,
                                                             callStackString,
                                                             isDeleted);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxUncommitted</Name>
				<Source><![CDATA[
    public static void deleteTaxUncommitted()
    {
        TaxUncommitted          taxUncommitted;
        TaxUncommitted          taxUncommittedSelf;
        AccountingDistribution  accountingDistribution;
        SourceDocumentLine      sourceDocumentLine;
        TaxTable                taxTable;

        // <GIN>
        #ISOCountryRegionCodes
        boolean                     isoIN         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        TaxUncommitted_IN           taxUncommittedIN;
        // </GIN>
        // <GTH>
        boolean                     isoTH         = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]);
        TaxUncommittedExtensionTH   taxUncommittedExtTH;
        // </GTH>

        // delete distributions which are not posted to GL
        ttsbegin;

        boolean shouldSkipSDLDeleteAction = TaxUncommitted::shouldSkipSDLDeleteActionWhenDeleteTaxUncommitted();

        accountingDistribution.skipEvents(true);
        accountingDistribution.skipDataMethods(true);
        accountingDistribution.skipDeleteActions(shouldSkipSDLDeleteAction);
        delete_from accountingDistribution
            where accountingDistribution.AccountingEvent == 0
            exists join taxUncommitted
                where taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine
            exists join taxUncommittedSelf
                where taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
            exists join taxTable
                    where taxUncommittedSelf.TaxCode == taxTable.TaxCode;

        // delete source document lines which have no distribution.
        sourceDocumentLine.skipEvents(true);
        sourceDocumentLine.skipDataMethods(true);
        sourceDocumentLine.skipDeleteActions(shouldSkipSDLDeleteAction);
        delete_from sourceDocumentLine
            exists join taxUncommitted
                where taxUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
            exists join taxUncommittedSelf
                where taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
            exists join taxTable
                where taxUncommittedSelf.TaxCode == taxTable.TaxCode
            notexists join accountingDistribution
                where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId;

        // <GIN>
        if (isoIN)
        {
            delete_from taxUncommittedIN
                exists join taxUncommitted
                    where taxUncommitted.RecId          == taxUncommittedIN.TaxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                exists join taxTable
                    where taxUncommittedSelf.TaxCode == taxTable.TaxCode
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
        }
        // </GIN>

        // <GTH>
        if (isoTH)
        {
            delete_from taxUncommittedExtTH
                exists join taxUncommitted
                    where taxUncommitted.RecId          == taxUncommittedExtTH.TaxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId
                        && taxUncommittedSelf.HeadingRecId  == taxUncommitted.HeadingRecId
                exists join taxTable
                    where taxUncommittedSelf.TaxCode == taxTable.TaxCode
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;
        }
        // </GTH>

        Set purchTableRecIdSet = new Set(Types::Int64);
        while select taxUncommitted
             exists join taxUncommittedSelf
                 where taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId &&
                      taxUncommittedSelf.HeadingTableId == tableNum(PurchTable)
             notexists join accountingDistribution
                 where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine
        {
            purchTableRecIdSet.add(taxUncommitted.HeadingRecId);
        }

        // delete any existing TaxUncommitted records which have no distribution.
        delete_from taxUncommitted
            exists join taxUncommittedSelf
                where taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
            exists join taxTable
                where taxUncommittedSelf.TaxCode == taxTable.TaxCode
            notexists join accountingDistribution
                where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;

        if(TaxUncommitted::traceDeleteTaxUncommitted())
        {
            TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
            str callStackString = taxUncommitted::callStackInfo();
            boolean isDeleted;

            select firstonly RecId from taxUncommitted
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                exists join taxTable
                    where taxUncommittedSelf.TaxCode == taxTable.TaxCode
                notexists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == taxUncommitted.SourceDocumentLine;

            isDeleted = (taxUncommitted.RecId == 0);

            taxEventSourceLog.DeleteTaxUncommitted(callStackString, isDeleted);
        }
        
        SetEnumerator setEnumerator = purchTableRecIdSet.getEnumerator();
        PurchTable purchTable;
        while (setEnumerator.moveNext())
        {
            purchTable = PurchTable::findRecId(setEnumerator.current());
            if (purchTable
                && purchTable.ChangeRequestRequired
                && purchTable.PurchStatus == PurchStatus::Backorder
                && PurchTable.DocumentState == VersioningDocumentState::Confirmed)
            {
                purchTable.selectforupdate(true);
                purchTable.DocumentState = VersioningDocumentState::Draft;
                purchTable.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record occurs in the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the <c>TaxUncommitted</c> record.
    /// </param>
    /// <returns>
    /// true if the specified <c>TaxUncommitted</c> record occurs in the table; otherwise, false.
    /// </returns>
    public static boolean exist(RecId _recId)
    {
        TaxUncommitted taxUncommitted;

        select firstonly
            RecId
        from
            taxUncommitted
        where
            taxUncommitted.RecId == _recId;

        return taxUncommitted != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByDocumentAndInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>TaxUncommitted</c> table exists for the specified
    /// invoice.
    /// </summary>
    /// <param name="_documentTableId">
    /// The document table ID.
    /// </param>
    /// <param name="_documentId">
    /// The document table ID.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice ID.
    /// </param>
    /// <returns>
    /// true if the record exists; otherwise, false.
    /// </returns>
    static public boolean existByDocumentAndInvoice(RefTableId _documentTableId,
                                      RefRecId _documentId,
                                      Voucher _voucher,
                                      InvoiceId _invoiceId)
    {
        TaxUncommitted taxUncommitted;

        select firstonly
            RecId
        from
            taxUncommitted
        where
              taxUncommitted.HeadingRecId == _documentId &&
              taxUncommitted.HeadingTableId == _documentTableId &&
              taxUncommitted.Voucher == _voucher &&
              taxUncommitted.InvoiceId == _invoiceId;

        return taxUncommitted != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByDocumentAndVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>TaxUncommitted</c> table exists for the specified
    /// voucher.
    /// </summary>
    /// <param name="_documentTableId">
    /// The document table ID.
    /// </param>
    /// <param name="_documentId">
    /// The document table ID.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <returns>
    /// true if the record exists; otherwise, false.
    /// </returns>
    static public boolean existByDocumentAndVoucher(RefTableId _documentTableId,
                                      RefRecId _documentId,
                                      Voucher _voucher)
    {
        TaxUncommitted taxUncommitted;

        select firstonly
            RecId
        from
            taxUncommitted
        where
              taxUncommitted.HeadingRecId == _documentId &&
              taxUncommitted.HeadingTableId == _documentTableId &&
              taxUncommitted.Voucher == _voucher;

        return taxUncommitted != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByDocumentId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the TaxUncommitted table exists for the given document id.
    /// </summary>
    /// <param name="_documentTableId">
    /// The table Id of the transaction header table.
    /// </param>
    /// <param name="_documentId">
    /// The Document ID for a transaction.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean existByDocumentId(RefTableId _documentTableId, RefRecId _documentId)
    {
        TaxUncommitted taxUncommitted;

        select firstonly
            RecId
        from
            taxUncommitted
        where
            taxUncommitted.HeadingRecId == _documentId &&
            taxUncommitted.HeadingTableId == _documentTableId;

        return taxUncommitted != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByDocumentLineId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record occurs in the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <param name="_tableId">
    /// The table ID of the transaction line table on which to perform tax calculations.
    /// </param>
    /// <param name="_lineId">
    /// The line ID for a transaction.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean existByDocumentLineId(RefTableId _tableId, RefRecId _lineId)
    {
        TaxUncommitted taxUncommitted;

        select firstonly
            RecId
        from
            taxUncommitted
        where
            taxUncommitted.SourceTableId == _tableId &&
            taxUncommitted.SourceRecId == _lineId;

        return taxUncommitted != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByDocumentVoucherAndCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>TaxUncommitted</c> table exists for the specified
    /// voucher and company.
    /// </summary>
    /// <param name="_documentTableId">
    /// The document table ID.
    /// </param>
    /// <param name="_documentId">
    /// The document table ID.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_companyId">
    /// The company.
    /// </param>
    /// <returns>
    /// true if the record exists; otherwise, false.
    /// </returns>
    static public boolean existByDocumentVoucherAndCompany(RefTableId _documentTableId,
                                      RefRecId _documentId,
                                      Voucher _voucher,
                                      CompanyId _companyId)
    {
        TaxUncommitted taxUncommitted;

        select firstonly
            RecId
        from
            taxUncommitted
        where
              taxUncommitted.HeadingRecId == _documentId &&
              taxUncommitted.HeadingTableId == _documentTableId &&
              taxUncommitted.Voucher == _voucher &&
              taxUncommitted.Company == _companyId;

        return taxUncommitted != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsNonRecoverableTaxForDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the document has non-recoverable tax amounts.
    /// </summary>
    /// <param name="_documentTableId">
    /// The table ID for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record ID of the transaction header.
    /// </param>
    /// <returns>
    /// True if the document has non-recoverable tax amount, else, false.
    /// </returns>
    static public boolean existsNonRecoverableTaxForDocument(RefTableId _documentTableId, RefRecId _documentId)
    {
        TaxUncommitted taxUncommitted;

        if (TaxParameters::find().PurchTaxOnOperations)
        {
            return false;
        }

        select firstonly RecId from taxUncommitted
            where taxUncommitted.HeadingTableId             == _documentTableId
                && taxUncommitted.HeadingRecId              == _documentId
                && taxUncommitted.TaxInCostPriceRegulated   != 0;

        return taxUncommitted.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the <c>TaxUncommitted</c> record.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that specifies whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option that will be used when it reads the record; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>TaxUncommitted</c> table; otherwise, an empty record.
    /// </returns>
    public static TaxUncommitted find(
        RecId _recId,
        boolean _forUpdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        TaxUncommitted taxUncommitted;
        ;

        taxUncommitted.selectForUpdate(_forUpdate);
        if (_forUpdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            taxUncommitted.concurrencyModel(_concurrencyModel);
        }

        select firstonly
                taxUncommitted
            where
                taxUncommitted.RecId == _recId;

        return taxUncommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>TaxUncommitted</c> record.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    /// A source document line record ID.
    /// </param>
    /// <returns>
    /// A <c>TaxUncommitted</c> record.
    /// </returns>
    static public TaxUncommitted findBySourceDocumentLine(RefRecId _sourceDocumentLine)
    {
        TaxUncommitted     taxUncommitted;

        select firstonly taxUncommitted
            where taxUncommitted.SourceDocumentLine == _sourceDocumentLine;

        return taxUncommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySourceDocumentLineCrossCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>TaxUncommitted</c> record with <c>crosscompany</c>.
    /// </summary>
    /// <param name="_sourceDocumentLine">A source document line record ID.</param>
    /// <returns>A <c>TaxUncommitted</c> record.</returns>
    static public TaxUncommitted findBySourceDocumentLineCrossCompany(RefRecId _sourceDocumentLine)
    {
        TaxUncommitted taxUncommitted;

        select firstonly crosscompany taxUncommitted
            where taxUncommitted.SourceDocumentLine == _sourceDocumentLine;

        return taxUncommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findForDocumentLineTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <param name="_tableId">
    /// The table ID of the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="_taxCode">
    /// The tax code that is calculated.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option that will be used when it reads the record; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>TaxUncommitted</c> table; otherwise, an empty record.
    /// </returns>
    public static TaxUncommitted findForDocumentLineTaxCode(
        RefTableId _tableId,
        RefRecId _documentId,
        TaxCode  _taxCode,
        boolean _forUpdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        TaxUncommitted taxUncommitted;
        ;

        taxUncommitted.selectForUpdate(_forUpdate);
        if (_forUpdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            taxUncommitted.concurrencyModel(_concurrencyModel);
        }

        select firstonly
                taxUncommitted
            where
                taxUncommitted.HeadingRecId == _documentId &&
                taxUncommitted.HeadingTableId == _tableId &&
                taxUncommitted.TaxCode == _taxCode;

        return taxUncommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualNonRecoverableVATAmtForDocAndVo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the actual tax in cost price for the invoice.
    /// </summary>
    /// <param name="_documentTableId">
    /// The table ID for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_companyId">
    /// If supplied, then the tax amount returned will be for the given company.
    /// If not supplied, the tax amount will include tax for all companies; optional.
    /// </param>
    /// <returns>
    /// The tax in cost price in transactional currency, which includes tax adjustments.
    /// </returns>
    static public TaxAmountCur getActualNonRecoverableVATAmtForDocAndVo(RefTableId _documentTableId,
                                                                        RefRecId _documentId,
                                                                        Voucher _voucher,
                                                                        SelectableDataArea _companyId = '')
    {
        TaxUncommitted taxUncommitted;

        select sum(TaxInCostPriceRegulated)
        from taxUncommitted
        where taxUncommitted.HeadingRecId == _documentId &&
        taxUncommitted.HeadingTableId == _documentTableId &&
        taxUncommitted.Voucher == _voucher &&
        (_companyId == '' || taxUncommitted.Company == _companyId);

        return taxUncommitted.TaxInCostPriceRegulated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualTaxAmountForInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the actual tax amount for the invoice.
    /// </summary>
    /// <param name="_documentTableId">
    /// The table ID for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice ID.
    /// </param>
    /// <param name="_includeUseTax">
    /// A Boolean value that indicates whether the tax amount must include use tax.
    /// </param>
    /// <returns>
    /// The tax amount in transactional currency.
    /// </returns>
    static public TaxAmountCur getActualTaxAmountForInvoice(RefTableId _documentTableId,
                                                            RefRecId _documentId,
                                                            Voucher _voucher,
                                                            InvoiceId _invoiceId,
                                                            boolean _includeUseTax)
    {
        TaxUncommitted taxUncommitted;

        select sum(SourceRegulateAmountCur)
        from taxUncommitted
        where taxUncommitted.HeadingTableId == _documentTableId &&
              taxUncommitted.HeadingRecId == _documentId &&
              taxUncommitted.Voucher == _voucher &&
              taxUncommitted.InvoiceId == _invoiceId &&
              (taxUncommitted.TaxDirection != TaxDirection::UseTax ||
              _includeUseTax);

        return taxUncommitted.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualTaxAmountForPrepayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for the specified prepayment.
    /// </summary>
    /// <param name="_isPrepayment">
    /// A Boolean value that indicates whether it is a prepayment.
    /// </param>
    /// <param name="_documentTableId">
    /// The table ID for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <returns>
    /// The tax amount in transactional currency.
    /// </returns>
    public static TaxAmount getActualTaxAmountForPrepayment(boolean _isPrepayment,
                                        RefTableId _documentTableId,
                                        RefRecId _documentId,
                                        Voucher _voucher)
    {
        TaxAmountCur taxAmount;
        TaxUncommitted taxUncommitted;

        select sum(SourceRegulateAmountCur)
        from taxUncommitted
        where   taxUncommitted.HeadingTableId == _documentTableId &&
                taxUncommitted.HeadingRecId == _documentId &&
                taxUncommitted.Voucher == _voucher &&
                taxUncommitted.TaxDirection != TaxDirection::UseTax &&
                taxUncommitted.TaxOrigin != TaxOrigin::TaxReversed &&
                taxUncommitted.TaxOrigin != TaxOrigin::Transfer &&
                taxUncommitted.Prepayment == _isPrepayment;

        taxAmount += taxUncommitted.SourceRegulateAmountCur;

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualTaxAmountForSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the actual tax amount for an invoice.
    /// </summary>
    /// <param name="_sourceTableId">
    /// A transaction line table ID.
    /// </param>
    /// <param name="_sourceRecId">
    /// A transaction line record ID.
    /// </param>
    /// <param name="_includeUseTax">
    /// A Boolean value that indicates whether the tax amount includes the use tax.
    /// </param>
    /// <param name="_useTransactionalCurrency">
    /// A Boolean value that indicates whether the tax amount is in the transactional or accounting
    /// currency.
    /// </param>
    /// <param name="_isIncludeIndiaTax">
    /// A Boolean value that indicates whether the tax amount includes the india tax, optional
    /// </param>
    /// <returns>
    /// The tax amount.
    /// </returns>
    [SysObsolete('Please use getActualTaxAmountForSourceLineWithCompany instead', false, 31\03\2019)]
    static public TaxAmountCur getActualTaxAmountForSourceLine(RefTableId _sourceTableId, RefRecId _sourceRecId,  boolean _includeUseTax, boolean _useTransactionalCurrency
                                                                ,boolean _isIncludeIndiaTax = true
                                                                )
    {
        return TaxUncommitted::getActualTaxAmountForSourceLineWithCompany(_sourceTableId, _sourceRecId, _includeUseTax, _useTransactionalCurrency, _isIncludeIndiaTax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualTaxAmountForSourceLineWithCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the actual tax amount for an invoice.
    /// </summary>
    /// <param name="_sourceTableId">
    /// A transaction line table ID.
    /// </param>
    /// <param name="_sourceRecId">
    /// A transaction line record ID.
    /// </param>
    /// <param name="_includeUseTax">
    /// A Boolean value that indicates whether the tax amount includes the use tax.
    /// </param>
    /// <param name="_useTransactionalCurrency">
    /// A Boolean value that indicates whether the tax amount is in the transactional or accounting
    /// currency.
    /// </param>
    /// <param name="_isIncludeIndiaTax">
    /// A Boolean value that indicates whether the tax amount includes the india tax, optional
    /// </param>
    /// <param name="_postCompany">
    /// The post company.
    /// </param>
    /// <returns>
    /// The tax amount.
    /// </returns>
    static public TaxAmountCur getActualTaxAmountForSourceLineWithCompany(RefTableId _sourceTableId,
        RefRecId _sourceRecId,
        boolean _includeUseTax,
        boolean _useTransactionalCurrency,
        boolean _isIncludeIndiaTax = true,
        DataAreaId _postCompany = '' )
    {
        TaxUncommitted taxUncommitted;
        // <GIN>
        TaxUncommitted taxUncommitted_GIN;
        TaxTable       taxTable;
        // </GIN>

        select sum(SourceRegulateAmountCur), sum(TaxAmount) from taxUncommitted
        where (_postCompany == '' || taxUncommitted.Company == _postCompany) &&
              taxUncommitted.SourceRecId == _sourceRecId &&
              taxUncommitted.SourceTableId == _sourceTableId &&
              (taxUncommitted.TaxDirection != TaxDirection::UseTax ||
              _includeUseTax);
             
        // <GIN>
        select Company, TaxCode from taxUncommitted_GIN
            group by taxUncommitted_GIN.Company, taxUncommitted_GIN.TaxCode
        where (_postCompany == '' || taxUncommitted_GIN.Company == _postCompany) &&
              taxUncommitted_GIN.SourceRecId == _sourceRecId &&
              taxUncommitted_GIN.SourceTableId == _sourceTableId &&
              (taxUncommitted_GIN.TaxDirection != TaxDirection::UseTax ||
              _includeUseTax);

        DataAreaId postCompany = taxUncommitted_GIN.Company ? taxUncommitted_GIN.Company : curext();
        changecompany(postCompany)
        {
            select taxTable where taxTable.TaxCode == taxUncommitted_GIN.TaxCode;
        }
        if(!(_isIncludeIndiaTax || taxTable.TaxType_IN == TaxType_IN::None))
        {
            taxUncommitted = null;
        }
        // </GIN>
        if (_useTransactionalCurrency)
        {
            return taxUncommitted.SourceRegulateAmountCur;
        }
        else
        {
            return taxUncommitted.TaxAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualTaxAmountForVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the actual tax amount for the voucher.
    /// </summary>
    /// <param name="_documentTableId">
    ///    The table ID for the transaction header.
    /// </param>
    /// <param name="_documentId">
    ///    The RecId of the transaction header.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher.
    /// </param>
    /// <param name="_includeUseTax">
    ///    A flag indicating that the tax amount should include Use tax.
    /// </param>
    /// <param name="_companyId">
    ///   If supplied, then the tax amount returned will be for the given company.
    ///   If not supplied, the tax amount will include tax for all companies; optional.
    /// </param>
    /// <param name="_sourceRecId">
    ///   Used to determine the source rec id; optional.
    /// </param>
    /// <param name="_transDate">
    /// The trans date.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code.
    /// </param>
    /// <param name="exchRate">
    /// The exchange rate.
    /// </param>
    /// <returns>
    ///    The tax amount in transactional currency.
    /// </returns>
    static public TaxAmountCur getActualTaxAmountForVoucher(RefTableId _documentTableId,
                                                            RefRecId _documentId,
                                                            Voucher _voucher,
                                                            boolean _includeUseTax,
                                                            SelectableDataArea _companyId = '',
                                                            // <GIN>
                                                            RefRecId _sourceRecId = 0,
                                                            // </GIN>
                                                            TransDate _transDate = dateNull(),
                                                            CurrencyCode _currencyCode = '',
                                                            ExchRate _exchRate = 100        )
    {
        TaxUncommitted taxUncommitted;
        TaxRegulationAmountCur taxAmount;

        // <GIN>
        if (_sourceRecId == 0)
        {
            if (_currencyCode)
            {
                while select *
                    from taxUncommitted
                    where taxUncommitted.HeadingTableId == _documentTableId &&
                        taxUncommitted.HeadingRecId == _documentId &&
                        taxUncommitted.Voucher == _voucher &&
                        (!_transDate || taxUncommitted.TransDate == _transDate) &&
                        taxUncommitted.TaxOrigin != TaxOrigin::Transfer &&
                        (taxUncommitted.TaxDirection != TaxDirection::UseTax ||
                        _includeUseTax) &&
                        // <GBR>
                        (!BrazilParameters::isEnabled() || taxUncommitted.IncludedInPrice_BR == false) &&
                        // </GBR>
                        (_companyId == '' || taxUncommitted.Company == _companyId)
                {
                    if (taxUncommitted.SourceCurrencyCode != _currencyCode)
                    {
                        ExchRate ExchangeRate;
                        if (_currencyCode == taxUncommitted.CurrencyCode)
                        {
                            ExchangeRate = taxUncommitted.ExchRate;
                        }
                        else
                        {
                            if (taxUncommitted.SourceCurrencyCode != taxUncommitted.CurrencyCode)
                            {
                                ExchangeRate = ExchangeRateCalculation::getExchangeRate1_Static(Ledger::find(Ledger::current()).DefaultExchangeRateType, taxUncommitted.SourceCurrencyCode, _currencyCode, taxUncommitted.TransDate);
                            }
                            else
                            {
                                ExchangeRate = ExchangeRateCalculation::calculateReciprocalExchangeRate(_exchRate);
                            }
                        }
                       
                        taxAmount += CurrencyExchange::round(CurrencyExchange::calculateAmount(taxUncommitted.SourceRegulateAmountCur, ExchangeRate), _currencyCode);
                    }
                    else
                    {
                        taxAmount += taxUncommitted.SourceRegulateAmountCur;
                    }
                }
                return taxAmount;
            }
            else
            {
                select sum(SourceRegulateAmountCur)
                    from taxUncommitted
                    where taxUncommitted.HeadingTableId == _documentTableId &&
                        taxUncommitted.HeadingRecId == _documentId &&
                        taxUncommitted.Voucher == _voucher &&
                        (!_transDate || taxUncommitted.TransDate == _transDate) &&
                        taxUncommitted.TaxOrigin != TaxOrigin::Transfer &&
                        (taxUncommitted.TaxDirection != TaxDirection::UseTax ||
                        _includeUseTax) &&
                        // <GBR>
                        (!BrazilParameters::isEnabled() || taxUncommitted.IncludedInPrice_BR == false) &&
                        // </GBR>
                        (_companyId == '' || taxUncommitted.Company == _companyId);

                return taxUncommitted.SourceRegulateAmountCur;
            }

            // <GIN>
        }
        else
        {
            select sum(SourceRegulateAmountCur)
                from taxUncommitted
                where taxUncommitted.HeadingTableId == _documentTableId &&
                    taxUncommitted.HeadingRecId == _documentId &&
                    taxUncommitted.Voucher == _voucher &&
                    (!_transDate || taxUncommitted.TransDate == _transDate) &&
                    taxUncommitted.TaxOrigin != TaxOrigin::Transfer &&
                    (taxUncommitted.TaxDirection != TaxDirection::UseTax ||
                    _includeUseTax) &&
                    (_companyId == '' || taxUncommitted.Company == _companyId)
                    && taxUncommitted.SourceRecId == _sourceRecId;

            return taxUncommitted.SourceRegulateAmountCur;
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualTaxInCostPriceForInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the actual tax in cost price for the invoice.
    /// </summary>
    /// <param name="_documentTableId">
    /// The table ID for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice ID.
    /// </param>
    /// <returns>
    /// The tax in cost price in transactional currency, which includes tax adjustments.
    /// </returns>
    static public TaxAmountCur getActualTaxInCostPriceForInvoice(RefTableId _documentTableId, RefRecId _documentId, Voucher _voucher, InvoiceId _invoiceId)
    {
        TaxUncommitted taxUncommitted;

        select sum(TaxInCostPriceRegulated)
        from taxUncommitted
        where taxUncommitted.HeadingRecId == _documentId &&
              taxUncommitted.HeadingTableId == _documentTableId &&
              taxUncommitted.Voucher == _voucher &&
              taxUncommitted.InvoiceId == _invoiceId;

        return taxUncommitted.TaxInCostPriceRegulated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualTaxInCostPriceForSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the actual tax in cost price for the transaction line.
    /// </summary>
    /// <param name="_sourceTableId">
    ///    The transaction line table ID.
    /// </param>
    /// <param name="_sourceRecId">
    ///    The transaction line record ID.
    /// </param>
    /// <returns>
    ///    The tax in cost price in transactional currency.
    /// </returns>
    static public TaxAmountCur getActualTaxInCostPriceForSourceLine(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        TaxUncommitted taxUncommitted;

        select sum(TaxInCostPriceRegulated)
        from taxUncommitted
        where taxUncommitted.SourceRecId == _sourceRecId &&
              taxUncommitted.SourceTableId == _sourceTableId;

        return taxUncommitted.TaxInCostPriceRegulated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalculatedTaxAmountForInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the calculated tax amount for the invoice.
    /// </summary>
    /// <param name="_documentTableId">
    /// The table ID for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice ID.
    /// </param>
    /// <param name="_includeUseTax">
    /// A flag that indicates that the tax amount should include use tax.
    /// </param>
    /// <returns>
    /// The tax amount in transactional currency, which does not include tax adjustments.
    /// </returns>
    static public TaxAmountCur getCalculatedTaxAmountForInvoice(RefTableId _documentTableId,
                                                                RefRecId _documentId,
                                                                Voucher _voucher,
                                                                InvoiceId _invoiceId,
                                                                boolean _includeUseTax)
    {
        TaxUncommitted taxUncommitted;

        select sum(SourceTaxAmountCur)
        from taxUncommitted
        where   taxUncommitted.HeadingTableId == _documentTableId &&
                taxUncommitted.HeadingRecId == _documentId &&
                taxUncommitted.Voucher == _voucher &&
                taxUncommitted.InvoiceId == _invoiceId &&
                (taxUncommitted.TaxDirection != TaxDirection::UseTax ||
                _includeUseTax);

        return taxUncommitted.SourceTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalculatedTaxAmountForSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the calculated tax amount for the invoice.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The transaction line table ID.
    /// </param>
    /// <param name="_sourceRecId">
    /// The transaction line record ID.
    /// </param>
    /// <param name="_includeUseTax">
    /// A Boolean value that indicates whether the tax amount must include use tax.
    /// </param>
    /// <returns>
    /// The tax amount in transactional currency that does not include tax adjustments.
    /// </returns>
    static public TaxAmountCur getCalculatedTaxAmountForSourceLine(RefTableId _sourceTableId, RefRecId _sourceRecId,  boolean _includeUseTax)
    {
        TaxUncommitted taxUncommitted;

        select sum(SourceTaxAmountCur), sum(TaxAmount)
        from taxUncommitted
        where taxUncommitted.SourceRecId == _sourceRecId &&
              taxUncommitted.SourceTableId == _sourceTableId &&
              (taxUncommitted.TaxDirection != TaxDirection::UseTax ||
              _includeUseTax);

        return taxUncommitted.SourceTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomsDuty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates total customs duty for sourceTableId and sourceRecId.
    /// </summary>
    /// <param name="_sourceTableId">SourceTableId of <c>TaxUncommitted</c></param>
    /// <param name="_sourceRecId">SourceRecId of <c>TaxUncommitted</c></param>
    /// <returns>The tax amount.</returns>
    public static TaxAmount getCustomsDuty_IN(
        RefTableId  _sourceTableId,
        RefRecId    _sourceRecId)
    {
        TaxUncommitted      taxUncommittedLoc;
        TaxUncommitted_IN   taxUncommittedIN;

        select sum(CustomsDuty) from taxUncommittedIN
            where taxUncommittedIN.TaxUncommitted
            join taxUncommittedLoc
                group by TaxAutogenerated
                where taxUncommittedLoc.SourceTableId == _sourceTableId &&
                      taxUncommittedLoc.SourceRecId   == _sourceRecId   &&
                      taxUncommittedIN.TaxUncommitted == taxUncommittedLoc.RecId;

        return  taxUncommittedIN.CustomsDuty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExcludedIndirectTaxAmountforWHT_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets indirect tax amount in transaction currency.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The tableId of the source table.
    /// </param>
    /// <param name="_sourceRecId">
    /// The recId of the source table.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The TaxItemGroup attached for the transaction.
    /// </param>
    /// <param name="_vendAccountLoc">
    /// Vendor Account.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// The TaxWithholdGroup attached for the transaction.
    /// </param>
    /// <returns>
    /// returns the tax amount.
    /// </returns>
    public static TaxAmountCur getExcludedIndirectTaxAmountforWHT_IN(
                                            RefTableId       _sourceTableId,
                                            RefRecId         _sourceRecId,
                                            TaxItemGroup     _taxItemGroup,
                                            VendAccount      _vendAccountLoc ,
                                            TaxWithholdGroup _taxWithholdGroup)
    {
        TaxUncommitted                      taxUncommitted;
        TaxTable                            taxTableLoc;
        AmountCur                           excludedIndirectTaxAmountCur;
        TaxWithholdExcludeIndirectTax_IN    taxWithholdExcludeIndirectTaxIN;
        TaxWithholdGroupHeading             taxWithholdGroupHeading;
        Percent                             reverseChargePercent;

        if (_taxWithholdGroup)
        {
            taxWithholdGroupHeading = TaxWithholdGroupHeading::find(_taxWithholdGroup);

            select sum(SourceRegulateAmountCur) from taxUncommitted
                where taxUncommitted.SourceTableId  == _sourceTableId
                    && taxUncommitted.SourceRecId   == _sourceRecId
                join RecId from taxTableLoc
                    where taxTableLoc.TaxCode    == taxUncommitted.TaxCode
                        && taxTableLoc.TaxType_IN != TaxType_IN::Customs
                        && taxTableLoc.TaxType_IN != TaxType_IN::ServiceTax
                exists join taxWithholdExcludeIndirectTaxIN
                    where taxWithholdExcludeIndirectTaxIN.TaxWithholdGroupHeading == taxWithholdGroupHeading.RecId
                        && taxWithholdExcludeIndirectTaxIN.TaxType == taxTableLoc.TaxType_IN;

            excludedIndirectTaxAmountCur =  abs(taxUncommitted.SourceRegulateAmountCur);

            if (!VendTable::find(_vendAccountLoc).isGTA())
            {
                // For reverse charge mechanism, need to deduct the part service provider paid
                reverseChargePercent = TaxItemGroupHeading::find(_taxItemGroup).ReverseChargePercentage_IN;
                while select SourceRegulateAmountCur from taxUncommitted
                    where taxUncommitted.SourceTableId == _sourceTableId
                        && taxUncommitted.SourceRecId   == _sourceRecId
                    join RecId from taxTableLoc
                        where taxTableLoc.TaxCode    == taxUncommitted.TaxCode
                            && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax
                    exists join taxWithholdExcludeIndirectTaxIN
                        where taxWithholdExcludeIndirectTaxIN.TaxWithholdGroupHeading == taxWithholdGroupHeading.RecId
                            && taxWithholdExcludeIndirectTaxIN.TaxType == taxTableLoc.TaxType_IN
                {
                    excludedIndirectTaxAmountCur += abs(CurrencyExchangeHelper::amount(taxUncommitted.SourceRegulateAmountCur * (100 - reverseChargePercent) / 100));
                }
            }
        }
        return excludedIndirectTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIndirectTaxAmtForWHTSourceBaseCur_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets total Indirect taxes excluding CustomsDuty and service tax for GTA vendor.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The tableId of the source table.
    /// </param>
    /// <param name="_sourceRecId">
    /// The recId of the source table.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The TaxItemGroup attached for the transaction.
    /// </param>
    /// <param name="_vendAccountLoc">
    /// The vendor account of the transaction.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// The TaxWithholdGroup attached for the transaction.
    /// </param>
    /// <returns>
    /// returns total Indirect taxes excluding CustomsDuty and service tax for GTA vendor.
    /// </returns>
    public static TaxAmountCur getIndirectTaxAmtForWHTSourceBaseCur_IN(
        RefTableId       _sourceTableId,
        RefRecId         _sourceRecId,
        TaxItemGroup     _taxItemGroup,
        VendAccount      _vendAccountLoc = '',
        TaxWithholdGroup _taxWithholdGroup = '')
    {
        TaxUncommitted                      taxUncommitted;
        TaxTable                            taxTableLoc;
        AmountCur                           taxWithholdBaseFromIndirectTaxAmountCur;
        FormulaDesigner_IN                  formularDesign;
        Percent                             reverseChargePercent;
        LedgerJournalTrans                  ledgerJournalTrans;
        TaxWithholdExcludeIndirectTax_IN    taxWithholdExcludeIndirectTaxIN;
        TaxWithholdGroupHeading             taxWithholdGroupHeading;

        if (_taxItemGroup)
        {
            // Customs taxes does not hit Vendor, So should not be considered for TaxBase of Withholding taxes.
            // service taxes for GTA vendor does not hit Vendor, So no considere service tax firstly.
            select sum(SourceRegulateAmountCur) from taxUncommitted
                where taxUncommitted.SourceTableId  == _sourceTableId
                    && taxUncommitted.SourceRecId   == _sourceRecId
                join RecId from taxTableLoc
                    where taxTableLoc.TaxCode    == taxUncommitted.TaxCode
                        && taxTableLoc.TaxType_IN != TaxType_IN::Customs
                        && taxTableLoc.TaxType_IN != TaxType_IN::ServiceTax
                join RecId from formularDesign
                    where formularDesign.TaxItemGroup == _taxItemGroup
                        && formularDesign.TaxCode == taxUncommitted.TaxCode
                        && formularDesign.PriceInclTax == NoYes::No;

            taxWithholdBaseFromIndirectTaxAmountCur = abs(taxUncommitted.SourceRegulateAmountCur);

            // Service taxes for non - GTA Vendor hits Vendor, So should be considered for TaxBase of Withholding taxes.
            if (!VendTable::find(_vendAccountLoc).isGTA())
            {
                // For reverse charge mechanism, need to deduct the part service provider paid
                reverseChargePercent = TaxItemGroupHeading::find(_taxItemGroup).ReverseChargePercentage_IN;

                while select SourceRegulateAmountCur from taxUncommitted
                    where taxUncommitted.SourceTableId == _sourceTableId
                        && taxUncommitted.SourceRecId   == _sourceRecId
                    join RecId from taxTableLoc
                        where taxTableLoc.TaxCode    == taxUncommitted.TaxCode
                            && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax
                    join RecId from formularDesign
                        where formularDesign.TaxItemGroup == _taxItemGroup
                            && formularDesign.TaxCode == taxUncommitted.TaxCode
                            && formularDesign.PriceInclTax == NoYes::No
                {
                    taxWithholdBaseFromIndirectTaxAmountCur += abs(CurrencyExchangeHelper::amount(taxUncommitted.SourceRegulateAmountCur * (100 - reverseChargePercent) / 100));
                }
            }

            if (_sourceTableId == tableNum(LedgerJournalTrans))
            {
                ledgerJournalTrans = LedgerJournalTrans::findRecId(_sourceRecId, false);
            }

            taxWithholdGroupHeading = TaxWithholdGroupHeading::find(_taxWithholdGroup);
            select firstOnly RecId from taxWithholdExcludeIndirectTaxIN
                where taxWithholdExcludeIndirectTaxIN.TaxWithholdGroupHeading == taxWithholdGroupHeading.RecId;

            if (!ledgerJournalTrans.isPaymentJournal_IN()
                && taxWithholdExcludeIndirectTaxIN.RecId != 0)
            {
                taxWithholdBaseFromIndirectTaxAmountCur -= TaxUncommitted::getExcludedIndirectTaxAmountforWHT_IN(_sourceTableId, _sourceRecId, _taxItemGroup, _vendAccountLoc, _taxWithholdGroup);
            }
        }

        return taxWithholdBaseFromIndirectTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonPOLedgerDimension_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the LedgerDimension for Non PO lines.
    /// </summary>
    /// <param name="_taxWorkTrans">takes TmpTaxWorkTrans buffer</param>
    /// <returns>
    /// LedgerDimensionDefaultAccount
    /// </returns>
    public static LedgerDimensionDefaultAccount getNonPOLedgerDimension_IN(TmpTaxWorkTrans _taxWorkTrans)
    {
        VendInvoiceInfoLine                 vendInvoiceInfoLineNonPO;
        LedgerDimensionDefaultAccount       defaultAccount;
        TaxLedgerAccounts_IN                taxLedgerAccounts;
        TaxTable                            taxTableLoc = TaxTable::find(_taxWorkTrans.TaxCode);
        TransTaxInformation                 transTaxInformation;

        if (taxTableLoc.TaxType_IN == TaxType_IN::Excise && _taxWorkTrans.SourceTableId == tableNum(VendInvoiceInfoLine))
        {
            vendInvoiceInfoLineNonPO = VendInvoiceInfoLine::findRecId(_taxWorkTrans.SourceRecId);
            if (vendInvoiceInfoLineNonPO.isNonPO())
            {
                transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(vendInvoiceInfoLineNonPO);
                defaultAccount  = taxLedgerAccounts.exciseTaxAccountNum(taxTableLoc,
                                                                        _taxWorkTrans.TaxRegistrationNumberTable_IN,
                                                                        transTaxInformation.ExciseRecordType,
                                                                        _taxWorkTrans.TaxDirection).LedgerDimension;
            }
        }
        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginForSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the origin for the transaction line.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the transaction line.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the transaction line.
    /// </param>
    /// <param name="_useDisplaySign">
    /// A Boolean value that indicates whether the tax amount will have the correct sign for displaying on
    /// the user interface.
    /// </param>
    /// <param name="_lineAmount">
    /// Line amount including tax.
    /// </param>
    /// <param name="_roundedResult">
    ///    true if the result should be rounded; otherwise, false.
    /// </param>
    /// <returns>
    /// The tax origin for the transaction line if an origin could be determined; otherwise 0.
    /// </returns>
    public static TaxBase getOriginForSourceLine(RefTableId _sourceTableId, RefRecId _sourceRecId, boolean _useDisplaySign = false, AmountCur _lineAmount = 0, boolean _roundedResult = true)
    {
        TaxTable        taxTable;
        TaxUncommitted  taxUncommitted;
        TaxAmountCur    taxAmountCur;
        // <GEECZ>
        TaxBaseCur      sourceBaseAmount;
        #ISOCountryRegionCodes
        // </GEECZ>

        // fix tax per unit and gross amount combination, tax inclusive, tax rate is positive, base amount is incorrect for PO and pending vendor invoice issue
        if (_sourceTableId == tableNum(PurchLine) || _sourceTableId == tableNum(VendInvoiceInfoLine))
        {
            select firstonly RecId from taxUncommitted
                where taxUncommitted.SourceRecId == _sourceRecId
                    && taxUncommitted.SourceTableId == _sourceTableId
                    && taxUncommitted.TaxDirection != TaxDirection::UseTax
                    && taxUncommitted.IsDeleted == NoYes::No
                join RecId from taxTable
                    where taxTable.TaxBase == TaxBaseType::AmountByUnit
                        && taxTable.TaxCode == taxUncommitted.TaxCode
                        && taxTable.TaxType_IN == TaxType_IN::None
                        && taxTable.TaxOnTax == '';

            if (taxUncommitted.RecId)
            {
                select firstonly RecId from taxUncommitted
                    where taxUncommitted.SourceRecId == _sourceRecId
                        && taxUncommitted.SourceTableId == _sourceTableId
                        && taxUncommitted.TaxDirection != TaxDirection::UseTax
                        && taxUncommitted.IsDeleted == NoYes::No
                    join RecId from taxTable
                        where taxTable.TaxBase == TaxBaseType::PctPerGross
                            && taxTable.TaxCode == taxUncommitted.TaxCode
                            && taxTable.TaxType_IN == TaxType_IN::None
                            && taxTable.TaxOnTax == '';

                if (taxUncommitted.RecId)
                {
                    taxAmountCur = TaxUncommitted::totalRegulatedTaxAmountSingleLine(_sourceTableId, _sourceRecId);

                    if (taxAmountCur && !prmisDefault(_lineAmount))
                    {
                        sourceBaseAmount = abs(_lineAmount) - abs(taxAmountCur);
                        sourceBaseAmount = (_lineAmount > 0 ? 1: -1) * sourceBaseAmount;
                        return sourceBaseAmount;
                    }
                }
            }
        }

        select firstonly SourceBaseAmountCur, SourceBaseAmountCurRaw, TaxDirection
            //<GEEES>
            ,IntracomVAT
            //</GEEES>
            from taxUncommitted
            where taxUncommitted.SourceRecId == _sourceRecId &&
                taxUncommitted.SourceTableId == _sourceTableId &&
                taxUncommitted.TaxDirection != TaxDirection::UseTax &&
                taxUncommitted.IsDeleted    == NoYes::No &&
                (taxUncommitted.Source != TaxModuleType::Purch
                    || (taxUncommitted.Source == TaxModuleType::Purch && taxUncommitted.ReverseCharge_w == NoYes::No))
            join RecId from taxTable
                where taxTable.TaxBase != TaxBaseType::PctPerGross &&
                    //<GEEU>
                    taxTable.TaxCode == taxUncommitted.TaxCode &&
                    //</GEEU>
                    // <GIN>
                    taxTable.TaxType_IN == TaxType_IN::None &&
                    // </GIN>
                    taxTable.TaxBase != TaxBaseType::AmountByUnit &&
                    taxTable.TaxOnTax == '';

        if (!taxUncommitted.RecId)
        {
            select firstonly SourceBaseAmountCur, SourceBaseAmountCurRaw, TaxDirection
                //<GEEES>
                ,IntracomVAT
                //</GEEES>
                from taxUncommitted
                where taxUncommitted.SourceRecId == _sourceRecId &&
                    taxUncommitted.SourceTableId == _sourceTableId &&
                    (taxUncommitted.Source != TaxModuleType::Purch
                        || (taxUncommitted.Source == TaxModuleType::Purch && taxUncommitted.ReverseCharge_w == NoYes::No))
                join RecId from taxTable
                    where taxTable.TaxBase != TaxBaseType::AmountByUnit &&
                        //<GEEU>
                        taxTable.TaxCode == taxUncommitted.TaxCode &&
                        //</GEEU>
                        // <GIN>
                        taxTable.TaxType_IN == TaxType_IN::None &&
                        // </GIN>
                        taxTable.TaxOnTax == '';
        }

        if (_roundedResult && taxUncommitted.SourceBaseAmountCur)
        {
            sourceBaseAmount = taxUncommitted.SourceBaseAmountCur;
        }
        else
        {
            if (!_roundedResult && taxUncommitted.SourceBaseAmountCurRaw)
            {
                sourceBaseAmount = taxUncommitted.SourceBaseAmountCurRaw;
            }
            else
            {
                taxAmountCur = TaxUncommitted::getActualTaxAmountForSourceLine(_sourceTableId, _sourceRecId, false, true
                                                                            // <GIN>
                                                                            ,false
                                                                            // </GIN>
                                                                            );
                if (taxAmountCur && !prmisDefault(_lineAmount))
                {
                    sourceBaseAmount = _lineAmount - taxAmountCur;
                }
            }
        }

        // <GEECZ>
        if (!(SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoES]) && taxUncommitted.IntracomVAT)
    // </GEECZ>
    && _useDisplaySign)
        {
            sourceBaseAmount = Tax::changeDisplaySign(taxUncommitted.TaxDirection) * sourceBaseAmount;
        }

        return sourceBaseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalRegulatedTaxAmountSingleLine</Name>
				<Source><![CDATA[
    private static TaxAmountCur totalRegulatedTaxAmountSingleLine(TableId _tableId, RecId _recId)
    {
        TaxTable taxTable;
        TaxUncommitted taxUncommitted;

        select sum(SourceRegulateAmountCur) from taxUncommitted
            where taxUncommitted.SourceTableId == _tableId
                && taxUncommitted.SourceRecId == _recId
                && taxUncommitted.TaxDirection != TaxDirection::UseTax
                && taxUncommitted.TaxOrigin != TaxOrigin::TaxReversed
                && taxUncommitted.IsDeleted == NoYes::No
            join RecId from taxTable
                where taxTable.TaxCode == taxUncommitted.TaxCode
                    && taxTable.TaxType_IN == TaxType_IN::None;

        return taxUncommitted.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginForSourceLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the origin for the transaction line.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the transaction line.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the transaction line.
    /// </param>
    /// <returns>
    /// The tax origin for the transaction line if an origin could be determined; otherwise 0.
    /// </returns>
    public static TaxBase getOriginForSourceLine_IN(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        TaxTable        taxTable;
        TaxUncommitted  taxUncommitted;
        TaxBaseCur      sourceBaseAmount;

        select firstonly SourceBaseAmountCur, RecId from taxUncommitted
        where taxUncommitted.SourceRecId == _sourceRecId &&
                taxUncommitted.SourceTableId == _sourceTableId &&
                taxUncommitted.TaxDirection != TaxDirection::UseTax &&
                taxUncommitted.IsDeleted    == NoYes::No
        exists join taxTable
        where taxTable.TaxCode == taxUncommitted.TaxCode &&
                taxTable.TaxType_IN != TaxType_IN::None &&
                taxTable.TaxBase != TaxBaseType::PctPerGross &&
                taxTable.TaxBase != TaxBaseType::AmountByUnit &&
                taxTable.TaxOnTax == '';

        if (!taxUncommitted.RecId)
        {
            select firstonly SourceBaseAmountCur from taxUncommitted
            where taxUncommitted.SourceRecId == _sourceRecId &&
                    taxUncommitted.SourceTableId == _sourceTableId
            exists join taxTable
            where taxTable.TaxCode == taxUncommitted.TaxCode &&
                    taxTable.TaxBase != TaxBaseType::AmountByUnit &&
                    taxTable.TaxType_IN != TaxType_IN::None &&
                    taxTable.TaxOnTax == '';
        }

        if (taxUncommitted.SourceBaseAmountCur)
        {
            sourceBaseAmount = taxUncommitted.SourceBaseAmountCur;
        }

        return sourceBaseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getServiceTaxAmtForWHTSourceBaseCur_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets service tax amount in transaction currency.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The tableId of the source table.
    /// </param>
    /// <param name="_sourceRecId">
    /// The recId of the source table.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The TaxItemGroup attached for the transaction.
    /// </param>
    /// <returns>
    /// returns service tax amount.
    /// </returns>
    public static TaxAmountCur getServiceTaxAmtForWHTSourceBaseCur_IN(
        RefTableId      _sourceTableId,
        RefRecId        _sourceRecId,
        TaxItemGroup    _taxItemGroup)
    {
        TaxUncommitted      taxUncommitted;
        TaxTable            taxTableLoc;
        FormulaDesigner_IN  formularDesign;
        Percent             reverseChargePercent;
        AmountCur           taxWithholdBaseFromIndirectTaxAmountCur;

        // For reverse charge mechanism, need to deduct the part service provider paid
        reverseChargePercent = TaxItemGroupHeading::find(_taxItemGroup).ReverseChargePercentage_IN;

        while select SourceRegulateAmountCur from taxUncommitted
            where taxUncommitted.SourceTableId == _sourceTableId
                && taxUncommitted.SourceRecId   == _sourceRecId
            join RecId from taxTableLoc
                where taxTableLoc.TaxCode    == taxUncommitted.TaxCode
                    && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax
            join RecId from formularDesign
                where formularDesign.TaxItemGroup == _taxItemGroup
                    && formularDesign.TaxCode == taxUncommitted.TaxCode
                    && formularDesign.PriceInclTax == NoYes::No
        {
            taxWithholdBaseFromIndirectTaxAmountCur += abs(CurrencyExchangeHelper::amount(taxUncommitted.SourceRegulateAmountCur * (100 - reverseChargePercent) / 100));
        }

        return taxWithholdBaseFromIndirectTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecificTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extracts and returns the amount for specific india tax type of a source document transaction.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table Id of the source document transaction.
    /// </param>
    /// <param name="_sourceRecId">
    /// The Rec Id of the source document transaction.
    /// </param>
    /// <param name="_taxType">
    /// The specific tax type to retrieve the tax amount.
    /// </param>
    /// <returns>
    /// Returns the tax amount in transaction currency for the specific india tax type.
    /// </returns>
    public static TaxAmountCur getSpecificTaxAmount_IN(
        RefTableId      _sourceTableId,
        RefRecId        _sourceRecId,
        TaxType_IN      _taxType)
    {
        TaxTable            taxTable;
        TaxUncommitted      taxUncommitted;

        if (_sourceRecId != 0)
        {
            select sum(SourceRegulateAmountCur) from taxUncommitted
               where taxUncommitted.SourceTableId == _sourceTableId
                  && taxUncommitted.SourceRecId  == _sourceRecId
                     exists join TaxType_IN from taxTable
                        where taxTable.TaxCode == taxUncommitted.TaxCode
                           && taxTable.TaxType_IN == _taxType;
        }
        return taxUncommitted.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVATDeferredLedgerDimension_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the VAT deferred LedgerDimension for Credit note tansaction.
    /// </summary>
    /// <param name="_taxWorkTrans">takes TmpTaxWorkTrans buffer</param>
    /// <returns>
    /// LedgerDimensionAccount
    /// </returns>
    public static LedgerDimensionAccount  getVATDeferredLedgerDimension_IN(TmpTaxWorkTrans _taxWorkTrans)
    {
        VendInvoiceInfoLine                 vendInvoiceInfoLine;
        LedgerDimensionAccount              ledgerDimensionAccount;
        TaxLedgerAccounts_IN                taxLedgerAccounts;
        TaxLedgerAccountSetup_IN            taxLedgerAccountSetup;
        PurchLine                           purchLine;
        TaxAccountType_IN                   taxAccountType;
        TaxTable                            taxTable = TaxTable::find(_taxWorkTrans.TaxCode);
        DimensionDefault                    dimensionDefault;
        TransTaxInformation                 transTaxInformation;

        switch (_taxWorkTrans.SourceTableId)
        {
            case tableNum(VendInvoiceInfoLine) :
                vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(_taxWorkTrans.SourceRecId);

                if (! vendInvoiceInfoLine.isNonPO())
                {
                    purchLine = PurchLine::findRecId(VendInvoiceInfoLine::findRecId(_taxWorkTrans.SourceRecId).PurchLineRecId);

                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(vendInvoiceInfoLine);

                    if (purchLine.LineAmount < 0
                        && purchLine.InventRefId
                        && transTaxInformation.VATGoodsType == VATGoodsType_IN::CapitalGoods)
                    {
                        if (Tax::getPostedVATDeferredAmount_IN(purchLine.InventRefTransId, _taxWorkTrans.TaxCode) < abs(_taxWorkTrans.TaxAmount))
                        {
                            taxAccountType =  TaxAccountType_IN::VATDeferredAccount;
                            dimensionDefault = vendInvoiceInfoLine.DefaultDimension
                                                ? vendInvoiceInfoLine.DefaultDimension
                                                :  purchLine.DefaultDimension;
                        }
                    }
                }
                break;
        }

        if (taxAccountType ==  TaxAccountType_IN::VATDeferredAccount)
        {
            taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All, 0);

            if (!taxLedgerAccountSetup)
            {
                taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, _taxWorkTrans.TaxRegistrationNumberTable_IN);
            }

            select firstonly LedgerDimension from taxLedgerAccounts
                join RecId from taxLedgerAccountSetup
                where taxLedgerAccountSetup.TaxLedgerAccountGroup == taxTable.TaxLedgerAccountGroup_IN
                    && taxLedgerAccountSetup.AccountCode           == TaxAccountCode_IN::All
                    && taxLedgerAccounts.TaxLedgerAccountSetup     == taxLedgerAccountSetup.RecId
                    && taxLedgerAccounts.AccountType               == taxAccountType
                    && taxLedgerAccounts.TaxComponentTable         == taxTable.TaxComponentTable_IN;

            ledgerDimensionAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(taxLedgerAccounts.LedgerDimension, dimensionDefault);
        }
        else
        {
            ledgerDimensionAccount =  _taxWorkTrans.LedgerDimension;
        }

        return ledgerDimensionAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maintainTaxUncommittedLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows for additional updates to the current <c>TaxUncommitted</c> record
    /// based off the <c>TaxCalculation</c> object parameter.
    /// </summary>
    /// <param name = "_taxCalculation">
    /// The <c>TaxCalculation</c> object updating the current <c>TaxUncommitted</c> record.
    /// </param>
    protected void maintainTaxUncommittedLine(TaxCalculation _taxCalculation)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>maintainTaxUncommitted</Name>
				<Source><![CDATA[
    public static void maintainTaxUncommitted(TaxCalculation _taxCalculation, boolean _doIsolateTransactionScope = false)
    {
        const real precesion = 0.000001;

        TaxUncommitted  taxUncommitted;
        TmpTaxWorkTrans taxWorkTrans = _taxCalculation.tmpTaxWorkTrans();
        TmpTaxWorkTrans taxWorkTrans2;
        UserConnection  connection;

        select firstonly RecId from taxWorkTrans;
        if(!taxWorkTrans)
        {
            return;
        }
        else
        {
            boolean taxUncommittedExists = false;
            while select SourceTableId, SourceRecId from taxWorkTrans
                group by SourceTableId, SourceRecId
            {
                select firstonly RecId from taxUncommitted
                    where taxUncommitted.SourceTableId == taxWorkTrans.SourceTableId &&
                          taxUncommitted.SourceRecId == taxWorkTrans.SourceRecId;
                if(taxUncommitted)
                {
                    taxUncommittedExists = true;
                    break;
                }
            }
            if(!taxUncommittedExists)
            {
                return;
            }
        }

        if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
        {
            _doIsolateTransactionScope = false;
        }

        try
        {
            if (_doIsolateTransactionScope)
            {
                connection = new UserConnection();
                taxUncommitted.setConnection(connection);
                taxWorkTrans2.setConnection(connection);
            }
            else if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
            {
                ttsbegin;
            }

            taxWorkTrans2.setTmpData(taxWorkTrans);

            if (_doIsolateTransactionScope)
            {
                connection.ttsbegin();
            }
        
            // Note this loops seperately over the results since taxWorkTrans is an in-memory
            // temp table while taxUncommitted is a regular table. Doing a direct join will
            // result in pulling back *all* taxUncommitted records then comparing with the
            // in memory temp table, which is hugely expensive when taxUncommitted has thousands
            // of records.
            while select SourceTableId, SourceRecId from taxWorkTrans
                    group by SourceTableId, SourceRecId
            {
                while select forupdate taxUncommitted where
                    taxUncommitted.SourceTableId == taxWorkTrans.SourceTableId &&
                    taxUncommitted.SourceRecId == taxWorkTrans.SourceRecId
                {
                    select firstonly taxWorkTrans2 where
                        taxWorkTrans2.SourceTableId == taxUncommitted.SourceTableId &&
                        taxWorkTrans2.SourceRecId == taxUncommitted.SourceRecId &&
                        taxWorkTrans2.TaxCode == taxUncommitted.TaxCode;

                    TaxAmountCur oldSourceBaseAmountCur = taxUncommitted.SourceBaseAmountCur;
                    TaxUncommitted taxUncommittedOrig = taxUncommitted.orig();
                    if (taxWorkTrans2)
                    {
                        // Update all TaxUncommitted records which have corresponding records in the memory table
                        taxUncommitted.initFromTmpTaxWorkTransV2(taxWorkTrans2, _taxCalculation.parmExchRate(), _taxCalculation.parmExchRateSecond(), _taxCalculation.parmReportingCurrencyExchRate(), _taxCalculation.parmReportingCurrencyExchRateSecondary(), false);
                        taxUncommitted.ensureReportingCurrency();
                        // clear cache the state data may have changed
                        SourceDocumentLineItem::removeFromCache(SourceDocumentLine::find(taxUncommitted.SourceDocumentLine));
                    }
                    else
                    {
                        // Soft delete all TaxUncommitted records for those lines calculated by the tax engine
                        taxUncommitted.IsDeleted = NoYes::Yes;
                        taxUncommitted.TaxAmount = 0;
                        taxUncommitted.TaxBaseAmount = 0;
                        taxUncommitted.TaxBaseAmountCur = 0;
                        taxUncommitted.TaxBaseAmountRep = 0;
                        taxUncommitted.SourceTaxAmountCur = 0;
                        taxUncommitted.TaxAmountCur = 0;
                        taxUncommitted.TaxAmountRep = 0;
                        taxUncommitted.SourceBaseAmountCur = 0;
                        taxUncommitted.TaxInCostPrice = 0;
                        taxUncommitted.SourceRegulateAmountCur = 0;
                        taxUncommitted.TaxInCostPriceRegulated = 0;
                        taxUncommitted.TaxInCostPriceCur = 0;
                        taxUncommitted.TaxInCostPriceRep = 0;
                        taxUncommitted.TaxInCostPriceMST = 0;
                        taxUncommitted.SourceBaseAmountCurRegulated = 0;
                        taxUncommitted.SourceTaxAmountCurReal = 0;
                        taxUncommitted.SourceBaseAmountCurRaw = 0;
                        taxUncommitted.TaxBaseAmountRaw = 0;
                    }

                    if (taxUncommitted.SourceDocumentLine
                        && taxUncommitted.HeadingTableId == tableNum(PurchTable)
                        && taxUncommitted.SourceBaseAmountCur != oldSourceBaseAmountCur)
                    {
                        PurchTable purchTable = PurchTable::findRecId(taxUncommitted.HeadingRecId);

                        if (purchTable.InclTax)
                        {
                            // If tax is included in price, the distribution of parent source document line needs to be reset when tax amount changed.
                            taxUncommitted.resetParentSourceDocumentLine();
                        }
                    }

                    if (TaxUncommitted::isNotUpdateTaxUnCommittedWhenNoChanges()) // This toggle will be enabled by default with corresponding change of submitting source document line.
                    {
                        if (taxUncommitted.IsDeleted != taxUncommittedOrig.IsDeleted
                            || taxUncommitted.TaxAmount != taxUncommittedOrig.TaxAmount
                            || taxUncommitted.TaxBaseAmount != taxUncommittedOrig.TaxBaseAmount
                            || taxUncommitted.TaxBaseAmountCur != taxUncommittedOrig.TaxBaseAmountCur
                            || taxUncommitted.SourceTaxAmountCur != taxUncommittedOrig.SourceTaxAmountCur
                            || taxUncommitted.TaxAmountCur != taxUncommittedOrig.TaxAmountCur
                            || taxUncommitted.SourceBaseAmountCur != taxUncommittedOrig.SourceBaseAmountCur
                            || taxUncommitted.SourceRegulateAmountCur != taxUncommittedOrig.SourceRegulateAmountCur
                            || taxUncommitted.TaxInCostPriceRegulated != taxUncommittedOrig.TaxInCostPriceRegulated
                            || taxUncommitted.TaxInCostPriceCur != taxUncommittedOrig.TaxInCostPriceCur
                            || taxUncommitted.TaxInCostPriceMST != taxUncommittedOrig.TaxInCostPriceMST
                            || taxUncommitted.SourceBaseAmountCurRegulated != taxUncommittedOrig.SourceBaseAmountCurRegulated
                            || round(taxUncommitted.SourceTaxAmountCurReal, precesion) != taxUncommittedOrig.SourceTaxAmountCurReal
                            || round(taxUncommitted.SourceBaseAmountCurRaw, precesion) != taxUncommittedOrig.SourceBaseAmountCurRaw
                            || round(taxUncommitted.TaxBaseAmountRaw, precesion) != taxUncommittedOrig.TaxBaseAmountRaw
                            || taxUncommitted.SourceCurrencyCode != taxUncommittedOrig.SourceCurrencyCode
                            || taxUncommitted.CalculationDate != taxUncommittedOrig.CalculationDate
                            || taxUncommitted.TransDate != taxUncommittedOrig.TransDate
                            || taxUncommitted.VatDueDate_W != taxUncommittedOrig.VatDueDate_W
                            || taxUncommitted.DocumentDate_PL != taxUncommittedOrig.DocumentDate_PL
                            || taxUncommitted.ExchRate != taxUncommittedOrig.ExchRate
                            || taxUncommitted.ReportingCurrencyExchRate != taxUncommittedOrig.ReportingCurrencyExchRate
                            || taxUncommitted.TaxAutogenerated != taxUncommittedOrig.TaxAutogenerated)
                        {
                            taxUncommitted.update();
                            taxUncommitted.submitSourceDocumentLine();
                        }
                    }
                    else // This condition should be removed once toggle isNotUpdateTaxUnCommittedWhenNoChanges can be deleted.
                    {
                        taxUncommitted.update();
                        taxUncommitted.submitSourceDocumentLine();
                    }

                    taxUncommitted.maintainTaxUncommittedLine(_taxCalculation);
                }
            }
            if (_doIsolateTransactionScope)
            {
                connection.ttscommit();
            }
            else if (FeatureStateProvider::isFeatureEnabled(TaxUncommittedDoNotIsolateScopeFlighting::instance()))
            {
                ttscommit;
            }
        }
        finally
        {
            if (connection)
            {
                connection.finalize();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetParentSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the accounting distributions of the parent source document line.
    /// </summary>
    private void resetParentSourceDocumentLine()
    {
        SourceDocumentLine parentSourceDocumentLine = this.parmParentSourceDocumentLine();

        if (parentSourceDocumentLine.SourceRelationType == tableNum(PurchLine))
        {
            SourceDocumentLineAccountingStatus accountingStatus = parentSourceDocumentLine.AccountingStatus;

            if (accountingStatus == SourceDocumentLineAccountingStatus::Canceled
                || accountingStatus == SourceDocumentLineAccountingStatus::Finalized)
            {
                return;
            }

            if (accountingStatus == SourceDocumentLineAccountingStatus::Completed)
            {
                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(
                    parentSourceDocumentLine.getSourceDocumentLineImplementation(),
                    false,
                    SourceDocumentLineAccountingStatus::FullyDistributed);
            }

            if (this.SourceDocumentLine && this.HeadingTableId == tableNum(PurchTable))
            {
                // In this condition: PurchTable include tax with SourceDocumentLine, avoid submitting as Draft
                // and leave the submitSourceDocumentLine() function to handle the SourceDocumentLineAccountingStatus(First submit as Draft then FullyDistributed).
                // This condition usually triggerred when workflow was enabled and price/quantity was updated after the initial PO confirmation.
                PurchTable purchTable = PurchTable::findRecId(this.HeadingRecId);
                if (purchTable.InclTax)
                {
                    return;
                }
            }

            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(
                    parentSourceDocumentLine.getSourceDocumentLineImplementation(),
                    false,
                    SourceDocumentLineAccountingStatus::Draft);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetSourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes the parent of the <c>TaxUncommitted</c> Records.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the transaction line.
    /// </param>
    /// <param name="_newSourceRecId">
    /// The record ID of the new transaction line.
    /// </param>
    /// <param name="_oldSourceRecId">
    /// The record ID of the old transaction line.
    /// </param>
    /// <param name="_oldSourceRecId2">
    /// The record ID of the second old transaction line, optional.
    /// </param>
    static void resetSourceRecId(RefTableId _sourceTableId, RefRecId _newSourceRecId, RefRecId _oldSourceRecId, RefRecId _oldSourceRecId2 = 0)
    {
        TaxUncommitted taxUncommitted;

        if (_oldSourceRecId2)
        {
            // Update both values at once if specified
            update_recordset taxUncommitted
            setting
                SourceRecId     = _newSourceRecId
            where
                taxUncommitted.SourceTableId == _sourceTableId &&
               (taxUncommitted.SourceRecId   == _oldSourceRecId ||
                taxUncommitted.SourceRecId   == _oldSourceRecId2);
        }
        else
        {
            // Avoid adding the "|| 0" to the end of the where clause to make the query more efficient
            update_recordset taxUncommitted
            setting
                SourceRecId     = _newSourceRecId
            where
                taxUncommitted.SourceTableId == _sourceTableId &&
                taxUncommitted.SourceRecId   == _oldSourceRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxInCostPrice_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total tax included in sales price to be subtracted from inventory cost.
    /// </summary>
    /// <param name="_tableId">Tableid from the source table</param>
    /// <param name="_recId">RecId from the source table</param>
    /// <returns>Return the sum of reatined tax for a given sourceTableId and sourceRecId</returns>
    public static TaxAmount taxInCostPrice_BR(TableId _tableId, RecId _recId)
    {
        TaxUncommitted  taxUncommited;
        TaxAmount       taxAmount;
        TaxTable        taxTable;
        ;

        select
            sum (SourceRegulateAmountCur)
        from taxUncommited
            where taxUncommited.SourceTableId   == _tableId      &&
                  taxUncommited.SourceRecId     == _recId        &&
                  taxUncommited.TaxDirection    != TaxDirection::UseTax &&
                  taxUncommited.IncludedInPrice_BR
            exists join taxTable
            where taxTable.TaxCode == taxUncommited.TaxCode      &&
                  taxTable.RetainedTax_BR == false;

        taxAmount = taxUncommited.SourceRegulateAmountCur;

        taxAmount += TaxUncommitted::totalTaxNotRecoverable_BR(_tableId, _recId);

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxInSalesRevenueForSourceLine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the sum of taxes not included in sales price.
    /// </summary>
    /// <param name="_tableId">SourceTableId of the taxWorkTrans</param>
    /// <param name="_recId">SourceRecId of the taxWorkTrans</param>
    /// <returns>Sum of taxes in transaction currency</returns>
    public static TaxAmount taxInSalesRevenueForSourceLine_BR(TableId    _tableId,
                                                              RecId      _recId)
    {
        TaxUncommitted  taxUncommitted;
        TaxAmount       taxAmount;

        select
            sum (SourceRegulateAmountCur)
        from taxUncommitted
        where taxUncommitted.SourceTableId   == _tableId      &&
              taxUncommitted.SourceRecId     == _recId        &&
                taxUncommitted.IncludedInPrice_BR == false;

        taxAmount = taxUncommitted.SourceRegulateAmountCur;

        return -taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountRetained_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns the actual retained tax amount.
    /// </summary>
    /// <param name="_documentTableId">
    /// The table Id for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record Id of the transaction header.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher.
    /// </param>
    /// <returns>
    /// The actual retained tax amount in transactional currency.
    /// </returns>

    public static TaxAmountCur totalTaxAmountRetained_BR(RefTableId _documentTableId, RefRecId   _documentId, Voucher _voucher)
    {
        TaxUncommitted taxUncommitted;
        TaxTable taxTable;

        select sum(SourceRegulateAmountCur)
        from taxUncommitted
            where taxUncommitted.HeadingTableId == _documentTableId &&
                  taxUncommitted.HeadingRecId   == _documentId &&
                  taxUncommitted.Voucher        == _voucher &&
                  taxUncommitted.TaxOrigin      != TaxOrigin::TaxReversed
            exists join taxTable
                where taxUncommitted.TaxCode == taxTable.TaxCode
                    && taxTable.RetainedTax_BR == true;

        if (taxUncommitted.Source == TaxModuleType::Sales
                || taxUncommitted.Source == TaxModuleType::Project
                || taxUncommitted.Source == TaxModuleType::ProjectInvoice)
        {
            taxUncommitted.SourceRegulateAmountCur = taxUncommitted.SourceRegulateAmountCur * -1;
        }

        return taxUncommitted.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountServiceTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates India service tax total amount
    /// </summary>
    /// <param name="_documentTableId">
    /// The table Id for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record Id of the transaction header.
    /// </param>
    /// <param name="_voucher">
    /// Transaction voucher
    /// </param>
    /// <returns>
    /// Total india service tax amount
    /// </returns>
    public static TaxAmountCur totalTaxAmountServiceTax_IN(RefTableId _documentTableId, RefRecId   _documentId, Voucher _voucher)
    {
        TaxUncommitted taxUncommitted;
        TaxTable taxTable;

        select sum(SourceRegulateAmountCur)
        from taxUncommitted
            where taxUncommitted.HeadingTableId == _documentTableId &&
                  taxUncommitted.HeadingRecId   == _documentId &&
                  taxUncommitted.Voucher        == _voucher &&
                  taxUncommitted.TaxOrigin      != TaxOrigin::TaxReversed
            exists join taxTable
                where taxUncommitted.TaxCode == taxTable.TaxCode
                    && taxTable.TaxType_IN == TaxType_IN::ServiceTax;

        return taxUncommitted.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxNotRecoverable_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total tax non recoverable.
    /// </summary>
    /// <param name="_tableId">Tableid from the source table</param>
    /// <param name="_recId">RecId from the source table</param>
    /// <returns>Return the sum of not recoverable taxes for a given sourceTableId and sourceRecId</returns>
    public static TaxAmount totalTaxNotRecoverable_BR(TableId _tableId, RecId _recId)
    {
        TaxUncommitted  taxUncommited;
        TaxAmount       taxAmount;
        ;

        select
            sum (TaxInCostPrice)
        from taxUncommited
            where taxUncommited.SourceTableId   == _tableId      &&
                  taxUncommited.SourceRecId     == _recId        &&
                  taxUncommited.IncludedInPrice_BR == false;

        taxAmount -= taxUncommited.TaxInCostPrice;

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the message to use when a specific record in the TaxUncommitted table does not exist.
    /// </summary>
    /// <returns>
    /// The message that indicates a record does not exists.
    /// </returns>
    public static TxtNotExist txtNotExist()
    {
        ;

        return "@SYS102169";
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces all of the <c>TaxUncommitted</c> records for the specified document and table IDs with the
    /// tax lines stored in the specified <c>TmpTaxWorkTrans</c> buffer.
    /// </summary>
    /// <param name="_taxCalculation">
    /// A <c>Tax</c> object that holds the tax lines, which have to be inserted into the
    /// <c>TaxUncommitted</c> table.
    /// </param>
    /// <param name="_doIsolateTransactionScope">
    /// true if <c>TaxUncommitted</c> should be maintained in a independent transaction scope; otherwise false.
    /// </param>
    static void updateTaxUncommitted(TaxCalculation _taxCalculation, boolean _doIsolateTransactionScope = false)
    {
        boolean skipNotExistsCheck = false;

        ttsbegin;

        if (_taxCalculation.getMaintainExistingTaxUncommitted())
        {
            TaxUncommitted::maintainTaxUncommitted(_taxCalculation, _doIsolateTransactionScope);
        }
        else
        {
            TaxUncommitted::deleteForDocumentHeader(_taxCalculation.headingTableId(), _taxCalculation.headingRecId(), _taxCalculation.useSubLedgerJournalLines(), _doIsolateTransactionScope);
            skipNotExistsCheck = true;
        }

        TaxUncommitted::createTaxUncommitted(_taxCalculation, skipNotExistsCheck, _doIsolateTransactionScope);
        ttscommit;

        if (TaxUncommitted::traceUpdateTaxUncommitted(_taxCalculation, _doIsolateTransactionScope))
        {
            TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
            TaxEventSourceLog.UpdateTaxUncommitted(tableId2Name(_taxCalculation.headingTableId()),
                                                   _taxCalculation.headingRecId(),
                                                   _doIsolateTransactionScope,
                                                   _taxCalculation.getMaintainExistingTaxUncommitted(),
                                                   _taxCalculation.useSubLedgerJournalLines(),
                                                   TaxUncommitted::callStackInfo());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>configureForSkipDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the <c>skip</c> methods that are relevant when doing inserts or updates.
    /// </summary>
    public void configureForSkipDelete()
    {
        this.skipDataMethods(true);
        this.skipDeleteActions(true);
        this.skipDeleteMethod(true);
        this.skipEvents(true);
        this.skipPostLoad(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForTaxCodeAndDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>TaxUncommitted</c> record exists for the specified source record, tax code and direction.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the source record.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the source record.
    /// </param>
    /// <param name="_taxCode">
    /// The tax code.
    /// </param>
    /// <param name="_taxDirection">
    /// The tax direction.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean existForTaxCodeAndDirection(RefTableId _sourceTableId, RefRecId _sourceRecId, TaxCode _taxCode, TaxDirection _taxDirection)
    {
        return (select firstOnly RecId from TaxUncommitted
                where TaxUncommitted.SourceTableId == _sourceTableId &&
                      TaxUncommitted.SourceRecId   == _sourceRecId   &&
                      TaxUncommitted.TaxCode       == _taxCode       &&
                      TaxUncommitted.TaxDirection  == _taxDirection).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecificTaxAmountForVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the Specific tax amount for the voucher.
    /// </summary>
    /// <param name="_documentTableId">
    ///     The table ID for the transaction header.
    /// </param>
    /// <param name="_documentId">
    ///     The RecId of the transaction header.
    /// </param>
    /// <param name="_voucher">
    ///     The voucher.
    /// </param>
    /// <param name="_includeUseTax">
    ///     A flag indicating that the tax amount should include Use tax.
    /// </param>
    /// <param name="_taxType">
    ///    The specific tax type to retrieve the tax amount.
    /// </param>
    /// <param name="_companyId">
    ///     If supplied, then the tax amount returned will be for the given company.
    ///     If not supplied, the tax amount will include tax for all companies; optional.
    /// </param>
    /// <returns>
    ///     The tax amount in transactional currency.
    /// </returns>
    public static TaxAmountCur getSpecificTaxAmountForVoucher_IN(
        RefTableId _documentTableId,
        RefRecId _documentId,
        Voucher _voucher,
        boolean _includeUseTax,
        TaxType_IN      _taxType,
        SelectableDataArea _companyId = ''
        )
    {
        TaxTable            taxTable;
        TaxUncommitted      taxUncommitted;
    
        select sum(SourceRegulateAmountCur)
                from taxUncommitted
                where taxUncommitted.HeadingTableId == _documentTableId &&
                    taxUncommitted.HeadingRecId == _documentId &&
                    taxUncommitted.Voucher == _voucher &&
                    taxUncommitted.TaxOrigin != TaxOrigin::Transfer &&
                    (taxUncommitted.TaxDirection != TaxDirection::UseTax ||
                    _includeUseTax) &&
                    (_companyId == '' || taxUncommitted.Company == _companyId)
                     exists join TaxType_IN from taxTable
                        where taxTable.TaxCode == taxUncommitted.TaxCode
                           && taxTable.TaxType_IN == _taxType;
    
        return taxUncommitted.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTmpTaxWorkTransV2</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method copies all of the fields from TmpTaxWorkTrans (in-memory table) to TaxUncommitted.
    /// </summary>
    /// <param name="_taxWorkTrans">
    ///    The buffer for TmpTaxWorkTrans which has the record to be copied.
    /// </param>
    /// <param name="_exchangeRate">
    ///    The exchange rate.
    /// </param>
    /// <param name="_exchangeRateSecond">
    ///    The secondary exchange rate.
    /// </param>
    /// <param name="_reportingCurrencyExchRate">
    ///    The reporting exchange rate.
    /// </param>
    /// <param name="_reportingCurrencyExchRateSecondary">
    ///    The secondary reporting exchange rate.
    /// </param>
    /// <param name="_copySourceDocumentLine">
    ///    Indicates if the <c>SourceDocumentLine</c> field should be copied.
    /// </param>
    void initFromTmpTaxWorkTransV2(
        TmpTaxWorkTrans _taxWorkTrans,
        ExchRate _exchangeRate,
        ExchrateSecondary _exchangeRateSecond,
        ReportingCurrencyExchRate _reportingCurrencyExchRate,
        ReportingCurrencyExchRateSecondary _reportingCurrencyExchRateSecondary,
        boolean _copySourceDocumentLine = true)
    {
        // <GIN><GEERU>
        #isoCountryRegionCodes
        // </GEERU></GIN>
        this.Company = _taxWorkTrans.Company;
        this.Voucher = _taxWorkTrans.Voucher;
        this.TransDate = _taxWorkTrans.TransDate;
        this.SourceCurrencyCode = _taxWorkTrans.SourceCurrencyCode;
        this.TaxCode = _taxWorkTrans.TaxCode;
        this.Txt = _taxWorkTrans.Txt;
        this.TaxDirection = _taxWorkTrans.TaxDirection;
        this.ExemptTax = _taxWorkTrans.ExemptTax;
        this.TaxReports = _taxWorkTrans.TaxReports;
        this.TaxAmount = _taxWorkTrans.TaxAmount;
        this.TaxBaseQty = _taxWorkTrans.TaxBaseQty;
        this.TaxBaseAmount = _taxWorkTrans.TaxBaseAmount;
        this.Source = _taxWorkTrans.Source;
        this.TaxOrigin = _taxWorkTrans.TaxOrigin;
        this.IsOverUnderPayment = _taxWorkTrans.IsOverUnderPayment;
        this.InvoiceRecId = _taxWorkTrans.InvoiceRecId;
        this.InventTransId = _taxWorkTrans.InventTransId;
        this.TaxBaseAmountCur = _taxWorkTrans.TaxBaseAmountCur;
        this.TaxBaseAmountRep = _taxWorkTrans.TaxBaseAmountRep;
        this.SourceTaxAmountCur = _taxWorkTrans.SourceTaxAmountCur;
        this.TaxAmountCur = _taxWorkTrans.TaxAmountCur;
        this.TaxAmountRep = _taxWorkTrans.TaxAmountRep;
        this.CurrencyCode = _taxWorkTrans.CurrencyCode;
        this.SourceBaseAmountCur = _taxWorkTrans.SourceBaseAmountCur;
        this.SourceBaseAmountCurCalculated = _taxWorkTrans.SourceBaseAmountCurCalculated;
        this.TaxInCostPrice = _taxWorkTrans.TaxInCostPrice;
        this.TaxAutogenerated = _taxWorkTrans.TaxAutogenerated;
        this.SourceRegulateAmountCur = _taxWorkTrans.SourceRegulateAmountCur;
        this.TaxInCostPriceRegulated = _taxWorkTrans.TaxInCostPriceRegulated;
        this.euroTriangulation = _taxWorkTrans.euroTriangulation;
        this.CalculationDate = _taxWorkTrans.CalculationDate;
        this.NegativeTax = _taxWorkTrans.NegativeTax;
        this.TaxInCostPriceCur = _taxWorkTrans.TaxInCostPriceCur;
        this.TaxInCostPriceRep = _taxWorkTrans.TaxInCostPriceRep;
        this.TaxInCostPriceMST = _taxWorkTrans.TaxInCostPriceMST;
        this.SourceBaseAmountCurRegulated = _taxWorkTrans.SourceBaseAmountCurRegulated;
        this.ManualInsertedTax = _taxWorkTrans.ManualInsertedTax;
        this.TaxItemGroup = _taxWorkTrans.TaxItemGroup;
        this.TaxGroup = _taxWorkTrans.TaxGroup;
        this.IntracomVAT = _taxWorkTrans.IntracomVAT;
        this.TaxLimitReached = _taxWorkTrans.TaxLimitReached;
        this.EmptyTaxBaseForOutgoingTax_W = _taxWorkTrans.EmptyTaxBaseForOutgoingTax_W;
        this.OperationPostingType = _taxWorkTrans.OperationPostingType;
        this.InvoiceId = _taxWorkTrans.InvoiceId;
        this.SourceTaxAmountCurReal = _taxWorkTrans.SourceTaxAmountCurReal;
        this.TaxCodeCombinationId = _taxWorkTrans.TaxCodeCombinationId;
        this.Prepayment = _taxWorkTrans.Prepayment;
        this.SourceBaseAmountCurRaw = _taxWorkTrans.SourceBaseAmountCurRaw;
        this.TaxBaseAmountRaw = _taxWorkTrans.TaxBaseAmountRaw;
        this.IsOffset = _taxWorkTrans.IsOffset;
        this.Warning = _taxWorkTrans.Warning;
        this.IsDeleted = _taxWorkTrans.IsDeleted;
        this.gsthstTaxType_CA = _taxWorkTrans.gsthstTaxType_CA;
        this.UnrealizedTax = _taxWorkTrans.UnrealizedTax;
        this.ReverseCharge_W = _taxWorkTrans.ReverseCharge_W;
        this.TaxValue = _taxWorkTrans.showTaxValue();
        this.TaxID = _taxWorkTrans.TaxId;
        this.PartyTaxId = _taxWorkTrans.PartyTaxId;
        this.ISVFeatureSetupGuid = _taxWorkTrans.ISVFeatureSetupGuid;
        this.ISVFeatureSetupName = _taxWorkTrans.ISVFeatureSetupName;
        this.HeadingTableId = _taxWorkTrans.HeadingTableId;
        this.HeadingRecId = _taxWorkTrans.HeadingRecId;
        this.SourceTableId = _taxWorkTrans.SourceTableId;
        this.SourceRecId = _taxWorkTrans.SourceRecId;
        if (TaxCalcPerfFindParentSourceRecIdWithoutSDLFlight::instance().isEnabled())
        {
            this.ParentSourceTableId = _taxWorkTrans.ParentSourceTableId;
            this.ParentSourceRecId = _taxWorkTrans.ParentSourceRecId;
        }

        this.ExchRate = _exchangeRate;
        this.ExchRateSecond = _exchangeRateSecond;
        this.ReportingCurrencyExchRate = _reportingCurrencyExchRate;
        this.ReportingCurrencyExchRateSecondary = _reportingCurrencyExchRateSecondary;

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.vatTaxAgentVendAccount_RU  = _taxWorkTrans.vatTaxAgentVendAccount_RU;
            this.vatOperationCode_RU        = _taxWorkTrans.vatOperationCode_RU;
            this.PostingProfile_RU          = _taxWorkTrans.PostingProfile_RU;
            this.InventProfileType_RU       = _taxWorkTrans.InventProfileType_RU;
            this.OffsetLedgerDimension_RU   = _taxWorkTrans.OffsetLedgerDimension_RU;
            this.WithoutTaxTrans_RU         = _taxWorkTrans.WithoutTaxTrans_RU;
        }
        // </GEERU>

        this.LedgerDimension = _taxWorkTrans.LedgerDimension;
        this.OperationLedgerDimension = _taxWorkTrans.OperationLedgerDimension;
        this.TaxOffsetUseTaxLedgerDimension = _taxWorkTrans.TaxOffsetUseTaxLedgerDimension;

        // <GIN>
        if (TaxParameters::checkTaxParameters_IN())
        {
            if (TaxTable::find(_taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::VAT)
            {
                this.LedgerDimension = TaxUncommitted::getVATDeferredLedgerDimension_IN(_taxWorkTrans);
            }
            this.LedgerDimension_IN = _taxWorkTrans.LedgerDimension_IN;
            // If LedgerDimension is blank, get the LedgerDimension using getNonPOLedgerDimension_IN() for Non PO lines for Excise.
            // For first time ExciseType_IN will be None and LedgerDimension will not be found. So, we are fetching here if LedgerDimension doesnt have value.
            if (!this.LedgerDimension)
            {
                this.LedgerDimension = TaxUncommitted::getNonPOLedgerDimension_IN(_taxWorkTrans);
            }
            if (TaxTable::find(_taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::ServiceTax
                && _taxWorkTrans.ServiceTaxReverseChargePercentage_IN != 0)
            {
                this.LedgerDimensionRev_IN = _taxWorkTrans.LedgerDimensionRev_IN;
            }
        }
        // </GIN>

        if (_copySourceDocumentLine)
        {
            this.SourceDocumentLine = _taxWorkTrans.SourceDocumentLine;
        }

        // <GMX>
        this.TaxType_MX                 = _taxWorkTrans.TaxType_MX;
        // </GMX>
        // <GEECZ>
        this.PostponeVAT                = _taxWorkTrans.PostponeVAT;
        // </GEECZ>
        // <GEEPL>
        this.CustVendName_PL            = _taxWorkTrans.CustVendName_PL;
        this.Addressing_PL              = _taxWorkTrans.Addressing_PL;
        this.vatNum_PL                  = _taxWorkTrans.vatNum_PL;
        this.TaxPeriodPaymentCode_PL    = _taxWorkTrans.TaxPeriodPaymentCode_PL;
        this.DocumentDate_PL            = _taxWorkTrans.DocumentDate_PL;
        // </GEEPL>
        // <GEEU>
        this.VatDueDate_W               = _taxWorkTrans.VatDueDate_W;
        this.Reason                     = _taxWorkTrans.Reason;
        this.ReasonComment              = _taxWorkTrans.ReasonComment;
        if (TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(_taxWorkTrans.HeadingTableId, _taxWorkTrans.HeadingRecId))
        {
            this.ExchangeRateTaxBaseAmount = _taxWorkTrans.ExchangeRateTaxBaseAmount;
            this.ExchangeRateTaxAmount = _taxWorkTrans.ExchangeRateTaxAmount;
            this.ExchangeRateSourceBaseAmountRegulated = _taxWorkTrans.ExchangeRateSourceBaseAmountRegulated;
            this.ExchangeRateSourceRegulateAmount = _taxWorkTrans.ExchangeRateSourceRegulateAmount;
            this.SalesTaxExchangeRate = _taxWorkTrans.SalesTaxExchangeRate;

            this.ExchangeRateTaxBaseAmountRep = _taxWorkTrans.ExchangeRateTaxBaseAmountRep;
            this.ExchangeRateTaxAmountRep = _taxWorkTrans.ExchangeRateTaxAmountRep;
            this.SalesTaxExchangeRateRep = _taxWorkTrans.SalesTaxExchangeRateRep;

            this.ExchangeRateTaxBaseAmountCur = _taxWorkTrans.ExchangeRateTaxBaseAmountCur;
            this.ExchangeRateTaxAmountCur = _taxWorkTrans.ExchangeRateTaxAmountCur;
            this.ExchangeRateBaseAmountCurRegulated = _taxWorkTrans.ExchangeRateBaseAmountCurRegulated;
            this.ExchangeRateRegulateAmountCur = _taxWorkTrans.ExchangeRateRegulateAmountCur;
            this.SalesTaxExchangeRateCur = _taxWorkTrans.SalesTaxExchangeRateCur;
        }
        else if (TaxParameters::isBankExchRateEnabled_W())
        {
            this.ExchangeRateTaxBaseAmount              = _taxWorkTrans.ExchangeRateTaxBaseAmount;
            this.ExchangeRateTaxAmount                  = _taxWorkTrans.ExchangeRateTaxAmount;
            this.ExchangeRateSourceBaseAmountRegulated  = _taxWorkTrans.ExchangeRateSourceBaseAmountRegulated;
            this.ExchangeRateSourceRegulateAmount       = _taxWorkTrans.ExchangeRateSourceRegulateAmount;
        }
        // </GEEU>
        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.FiscalValue_BR                     = _taxWorkTrans.FiscalValue_BR;
            this.TaxSalesOffsetLedgerDimension_BR   = _taxWorkTrans.TaxSalesOffsetLedgerDimension_BR;
            this.TaxType_BR                         = _taxWorkTrans.TaxType_BR;
            this.TaxationCode_BR                    = _taxWorkTrans.TaxationCode_BR;
            this.TaxationCodeAdj_BR                 = _taxWorkTrans.TaxationCodeAdj_BR;
            this.TaxSubstitution_BR                 = _taxWorkTrans.TaxTributarySubstitution;
            this.SourceExemptBaseAmountMST_BR       = _taxWorkTrans.SourceExemptBaseAmountMST_BR;
            this.SourceExemptTaxAmountMST_BR        = _taxWorkTrans.SourceExemptTaxAmountMST_BR;
            this.SourceOtherBaseAmountMST_BR        = _taxWorkTrans.SourceOtherBaseAmountMST_BR;
            this.SourceOtherTaxAmountMST_BR         = _taxWorkTrans.SourceOtherTaxAmountMST_BR;
            this.IncludedInPrice_BR                 = _taxWorkTrans.IncludedInPrice_BR;
            this.TaxReductionPct_BR                 = _taxWorkTrans.TaxReductionPct_BR;
            this.SourceExemptBaseAmount_BR          = _taxWorkTrans.SourceExemptBaseAmount_BR;
            this.SourceOtherBaseAmount_BR           = _taxWorkTrans.SourceOtherBaseAmount_BR;
            this.SourceOtherBaseTaxAmount_BR        = _taxWorkTrans.SourceOtherBaseTaxAmount_BR;
            this.TaxReceivableLongTerm_BR           = _taxWorkTrans.TaxReceivableLongTerm_BR;
            this.TaxationOrigin_BR                  = _taxWorkTrans.TaxationOrigin_BR;
            this.TaxBaseAmountOrig                  = _taxWorkTrans.TaxBaseAmountOrig;
        }
        // <GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxForSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether <c>TaxUncommitted</c> is a source document line or not
    /// </summary>
    /// <param name = "_sourceTableId">Source table id of tax</param>
    /// <param name = "_sourceRecId">Source record id of tax</param>
    /// <returns>
    /// Returns true if it is for source document line; otherwise, returns false.
    /// </returns>
    public static boolean isTaxForSourceDocumentLine(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        if (_sourceTableId)
        {
            if (_sourceTableId == tableNum(PurchTable) || _sourceTableId == tableNum(PurchLine)
                || _sourceTableId == tableNum(PurchReqLine) || _sourceTableId == tableNum(TrvExpTrans)
                || _sourceTableId == tableNum(ProjAdvancedJournalLine) || _sourceTableId == tableNum(CustInvoiceLine)
                || _sourceTableId == tableNum(VendPackingSlipTrans) || _sourceTableId == tableNum(VendPackingSlipJour)
                || _sourceTableId == tableNum(VendInvoiceInfoTable) || _sourceTableId == tableNum(VendInvoiceInfoSubTable)
                || _sourceTableId == tableNum(VendInvoiceInfoLine) || _sourceTableId == tableNum(EmplAdvLine_RU)
                || _sourceTableId == tableNum(SalesComplementaryInvoiceLine) || _sourceTableId == tableNum(PurchComplementaryInvoiceLine)
                || _sourceTableId == tableNum(BankStmtISOReportEntry))
            {
                return true;
            }
            else if (_sourceTableId == tableNum(MarkupTrans))
            {
                MarkupTrans markupTrans = MarkupTrans::findRecId(_sourceRecId);

                if (markupTrans.TransTableId)
                {
                    if (markupTrans.TransTableId == tableNum(PurchLine) || markupTrans.TransTableId == tableNum(PurchTable)
                        || markupTrans.TransTableId == tableNum(PurchReqLine)
                        || markupTrans.TransTableId == tableNum(CustInvoiceTable) || markupTrans.TransTableId == tableNum(VendInvoiceInfoTable)
                        || markupTrans.TransTableId == tableNum(VendInvoiceInfoSubTable) || markupTrans.TransTableId == tableNum(VendInvoiceInfoLine))
                    {
                        return true;
                    }
                    else if (markupTrans.TransTableId == tableNum(CustInvoiceLine) && SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipSDLDeleteActionWhenDeleteForDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if it should skip delete action for source document line when deleting for document header.
    /// </summary>
    /// <param name = "_documentTableId">Document table Id</param>
    /// <param name = "_documentId">Document reccord Id</param>
    /// <returns>True if should skip delete action, otherwise fales.</returns>
    private static boolean shouldSkipSDLDeleteActionWhenDeleteForDocumentHeader(RefTableId _documentTableId, RefRecId _documentId)
    {
        boolean shouldSkipSDLDeleteAction = TaxUncommittedSkipSDLDeleteActionDefaultDisableToggle::isEnabled();
        if (shouldSkipSDLDeleteAction)
        {
            ProjectAccountingDistribution   projectAccountingDistribution;
            TaxUncommitted                  taxUncommitted;
            AccountingDistribution          accountingDistribution;

            select firstonly RecId from projectAccountingDistribution
                exists join accountingDistribution
                    where accountingDistribution.RecId == projectAccountingDistribution.AccountingDistribution &&
                        accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
                        accountingDistribution.AccountingEvent == 0
                    exists join taxUncommitted
                        where taxUncommitted.HeadingRecId == _documentId &&
                            taxUncommitted.HeadingTableId == _documentTableId &&
                            taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine;

            if (projectAccountingDistribution.RecId)
            {
                shouldSkipSDLDeleteAction = false;
            }
        }

        return shouldSkipSDLDeleteAction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipSDLDeleteActionWhenDeleteForDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if it should skip delete action for source document line when deleting for document line.
    /// </summary>
    /// <param name = "_sourceTableId">Source table Id.</param>
    /// <param name = "_sourceRecId">Source record Id.</param>
    /// <returns>True if should skip delete action, otherwise fales.</returns>
    private static boolean shouldSkipSDLDeleteActionWhenDeleteForDocumentLine(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        boolean shouldSkipSDLDeleteAction = TaxUncommittedSkipSDLDeleteActionDefaultDisableToggle::isEnabled();
        if (shouldSkipSDLDeleteAction)
        {
            ProjectAccountingDistribution   projectAccountingDistribution;
            TaxUncommitted                  taxUncommitted;
            AccountingDistribution          accountingDistribution;

            select firstonly RecId from projectAccountingDistribution
                exists join accountingDistribution
                    where accountingDistribution.RecId == projectAccountingDistribution.AccountingDistribution &&
                        accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing &&
                        accountingDistribution.AccountingEvent == 0
                    exists join taxUncommitted
                        where taxUncommitted.SourceRecId == _sourceRecId &&
                        taxUncommitted.SourceTableId == _sourceTableId &&
                        taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine;

            if (projectAccountingDistribution.RecId)
            {
                shouldSkipSDLDeleteAction = false;
            }
        }

        return shouldSkipSDLDeleteAction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipSDLDeleteActionWhenDeleteForItemTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if it should skip delete action for source document line when deleting for item sales tax group.
    /// </summary>
    /// <param name = "_taxItemGroup">Item sales tax group.</param>
    /// <returns>True if should skip delete action, otherwise fales.</returns>
    private static boolean shouldSkipSDLDeleteActionWhenDeleteForItemTaxGroup(TaxItemGroup _taxItemGroup)
    {
        boolean shouldSkipSDLDeleteAction = TaxUncommittedSkipSDLDeleteActionDefaultDisableToggle::isEnabled();;
        if (shouldSkipSDLDeleteAction)
        {
            ProjectAccountingDistribution   projectAccountingDistribution;
            TaxUncommitted                  taxUncommitted;
            TaxUncommitted                  taxUncommittedSelf;
            AccountingDistribution          accountingDistribution;

            select firstonly RecId from projectAccountingDistribution
                join accountingDistribution
                    where accountingDistribution.RecId == projectAccountingDistribution.AccountingDistribution &&
                        accountingDistribution.AccountingEvent == 0
                    exists join taxUncommitted
                        where taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine
                    exists join taxUncommittedSelf
                        where taxUncommittedSelf.TaxItemGroup == _taxItemGroup &&
                            taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                            taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId;

            if (projectAccountingDistribution.RecId)
            {
                shouldSkipSDLDeleteAction = false;
            }
        }

        return shouldSkipSDLDeleteAction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipSDLDeleteActionWhenDeleteForTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if it should skip delete action for source document line when deleting for tax code.
    /// </summary>
    /// <param name = "_taxCode">Tax code</param>
    /// <returns>True if should skip delete action, otherwise fales.</returns>
    private static boolean shouldSkipSDLDeleteActionWhenDeleteForTaxCode(TaxCode _taxCode)
    {
        boolean shouldSkipSDLDeleteAction = TaxUncommittedSkipSDLDeleteActionDefaultDisableToggle::isEnabled();
        if (shouldSkipSDLDeleteAction)
        {
            ProjectAccountingDistribution   projectAccountingDistribution;
            TaxUncommitted                  taxUncommitted;
            TaxUncommitted                  taxUncommittedSelf;
            AccountingDistribution          accountingDistribution;

            select firstonly RecId from projectAccountingDistribution
                exists join accountingDistribution
                    where accountingDistribution.RecId == projectAccountingDistribution.AccountingDistribution &&
                        accountingDistribution.AccountingEvent == 0
                exists join taxUncommitted
                    where taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxCode == _taxCode &&
                      taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                      taxUncommittedSelf.HeadingRecId == taxUncommitted.HeadingRecId;

            if (projectAccountingDistribution.RecId)
            {
                shouldSkipSDLDeleteAction = false;
            }
        }

        return shouldSkipSDLDeleteAction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipSDLDeleteActionWhenDeleteForTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if it should skip delete action for source document line when deleting for tax group.
    /// </summary>
    /// <param name = "_taxGroup">Tax group</param>
    /// <returns>True if should skip delete action, otherwise fales.</returns>
    private static boolean shouldSkipSDLDeleteActionWhenDeleteForTaxGroup(TaxGroup _taxGroup)
    {
        boolean shouldSkipSDLDeleteAction = TaxUncommittedSkipSDLDeleteActionDefaultDisableToggle::isEnabled();
        if (shouldSkipSDLDeleteAction)
        {
            ProjectAccountingDistribution   projectAccountingDistribution;
            TaxUncommitted                  taxUncommitted;
            TaxUncommitted                  taxUncommittedSelf;
            AccountingDistribution          accountingDistribution;

            select firstonly RecId from projectAccountingDistribution
                exists join accountingDistribution
                    where accountingDistribution.RecId == projectAccountingDistribution.AccountingDistribution &&
                        accountingDistribution.AccountingEvent == 0
                exists join taxUncommitted
                    where taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.TaxGroup == _taxGroup &&
                        taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                        taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId;

            if (projectAccountingDistribution.RecId)
            {
                shouldSkipSDLDeleteAction = false;
            }
        }

        return shouldSkipSDLDeleteAction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipSDLDeleteActionWhenDeleteTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if it should skip delete action for source document line when deleting tax uncommitted.
    /// </summary>
    /// <returns>True if should skip delete action, otherwise fales.</returns>
    private static boolean shouldSkipSDLDeleteActionWhenDeleteTaxUncommitted()
    {
        boolean shouldSkipSDLDeleteAction = TaxUncommittedSkipSDLDeleteActionDefaultDisableToggle::isEnabled();
        if (shouldSkipSDLDeleteAction)
        {
            ProjectAccountingDistribution   projectAccountingDistribution;
            TaxUncommitted                  taxUncommitted;
            TaxUncommitted                  taxUncommittedSelf;
            AccountingDistribution          accountingDistribution;
            TaxTable                        taxTable;

            select firstonly RecId from projectAccountingDistribution
                exists join accountingDistribution
                    where accountingDistribution.RecId == projectAccountingDistribution.AccountingDistribution &&
                        accountingDistribution.AccountingEvent == 0
                exists join taxUncommitted
                    where taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine
                exists join taxUncommittedSelf
                    where taxUncommittedSelf.HeadingTableId == taxUncommitted.HeadingTableId &&
                          taxUncommittedSelf.HeadingRecId   == taxUncommitted.HeadingRecId
                exists join taxTable
                    where taxUncommittedSelf.TaxCode == taxTable.TaxCode;

            if (projectAccountingDistribution.RecId)
            {
                shouldSkipSDLDeleteAction = false;
            }
        }

        return shouldSkipSDLDeleteAction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxForTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total sales tax amount from <c>TaxUncommitted</c>.
    /// </summary>
    /// <param name = "_headingTableID">The recid for the buffer for heading table id.</param>
    /// <param name = "_headingRecID">The recid for the buffer for heading recid.</param>
    /// <returns>Total tax amount.</returns>
    [Hookable(false)]
    public static AmountCur useTaxForTaxUncommitted(TableId _headingTableID, RecId _headingRecID)
    {
        TaxUncommitted taxUncommitted;
        select sum(SourceRegulateAmountCur) from taxUncommitted
            where (taxUncommitted.TaxDirection == TaxDirection::UseTax
                && taxUncommitted.TaxOrigin    != TaxOrigin::TaxReversed)
                && taxUncommitted.headingTableId == _headingTableID
                && taxUncommitted.HeadingRecId == _headingRecID;

        return taxUncommitted.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountFromTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the totals tax amount from <c>TaxUncommitted</c>.
    /// </summary>
    /// <param name = "_headingTableID">The recid for the buffer of heading table id.</param>
    /// <param name = "_headingRecID">The recid for the buffer of heading recid.</param>
    /// <param name = "_taxModuleType">The tax Module type for the buffer of <c>TaxModuleType</c>.</param>
    /// <param name = "_includeUseTax">The boolean value of whether include use tax.</param>
    /// <returns> The actual tax amount.</returns>
    [Hookable(false)]
    public static TaxAmountCur totalTaxAmountFromTaxUncommitted(TableId _headingTableID,
                                                                RecId _headingRecID,
                                                                TaxModuleType _taxModuleType,
                                                                boolean _includeUseTax = false)
    {
        TaxAmountCur totalTaxAmountFromTaxUncommitted;
        TaxUncommitted taxUncommitted;
        TaxUncommitted_IN taxUncommitted_IN;
        #ISOCountryRegionCodes

        boolean isIndiaCountryRegionEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        boolean isBrazilEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]);

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return 0;
        }
        
        if (isIndiaCountryRegionEnabled)
        {
            select sum(SourceRegulateAmountCur) from taxUncommitted
            where (_includeUseTax || taxUncommitted.TaxDirection  != TaxDirection::UseTax)
                && taxUncommitted.TaxOrigin     != TaxOrigin::TaxReversed
                && taxUncommitted.HeadingTableId == _headingTableID
                && taxUncommitted.HeadingRecId == _headingRecID
            join taxUncommitted_IN
                    where taxUncommitted_IN.taxuncommitted == taxUncommitted.RecId
                    && !taxUncommitted_IN.IsScrapQtyLine_IN;
                
            totalTaxAmountFromTaxUncommitted = taxUncommitted.SourceRegulateAmountCur;

            // Select SUM can't be used since it will create "0.01" rounding issue.
            while select SourceRegulateAmountCur from taxUncommitted
                join ServiceTaxReverseChargePercentage from taxUncommitted_IN
                    where taxUncommitted_IN.taxuncommitted == taxUncommitted.RecId
                        && taxUncommitted_IN.ServiceTaxReverseChargePercentage != 0
                        && taxUncommitted.HeadingTableId == _headingTableID
                        && taxUncommitted.HeadingRecId == _headingRecID
            {
                totalTaxAmountFromTaxUncommitted -= CurrencyExchangeHelper::amount(taxUncommitted.SourceRegulateAmountCur - CurrencyExchangeHelper::amount(taxUncommitted.SourceRegulateAmountCur * (100 - taxUncommitted_IN.ServiceTaxReverseChargePercentage) / 100));
            }
        }
        else
        {
            select sum(SourceRegulateAmountCur), sum(SourceOtherBaseTaxAmount_BR) from taxUncommitted
                where (_includeUseTax || taxUncommitted.TaxDirection  != TaxDirection::UseTax)
                    && !taxUncommitted.IncludedInPrice_BR
                    && taxUncommitted.TaxOrigin != TaxOrigin::TaxReversed
                    && taxUncommitted.HeadingTableId == _headingTableID
                    && taxUncommitted.HeadingRecId == _headingRecID;

            totalTaxAmountFromTaxUncommitted = taxUncommitted.SourceRegulateAmountCur;
        }

        if (isBrazilEnabled)
        {
            switch (_taxModuleType)
            {
                case TaxModuleType::Purch :
                case TaxModuleType::PurchInvoice :
                case TaxModuleType::Tax :
                    totalTaxAmountFromTaxUncommitted = taxUncommitted.SourceRegulateAmountCur;
                    break;
                default :
                    totalTaxAmountFromTaxUncommitted = taxUncommitted.SourceRegulateAmountCur + taxUncommitted.SourceOtherBaseTaxAmount_BR;
            }
        }

        return totalTaxAmountFromTaxUncommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNotUpdateTaxUnCommittedWhenNoChanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether taxUncommitted are updated when no changes.
    /// </summary>
    /// <returns>true if taxUncommitted are not updated; otherwise, false.</returns>
    private static boolean isNotUpdateTaxUnCommittedWhenNoChanges()
    {
        return FeatureStateProvider::isFeatureEnabled(TaxUncommitedNotUpdateWhenNoChangeToggle::instance());
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureReportingCurrency</Name>
				<Source><![CDATA[
    private void ensureReportingCurrency()
    {
        #ISOCountryRegionCodes
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) || TaxSolutionScopeIntegrationUtil::isCompanyEnabled() || !this.SourceCurrencyCode)
        {
            return;
        }

        if (!Ledger::findByLegalEntity(CompanyInfo::current()).ReportingCurrency)
        {
            return;
        }

        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();
        if (this.SourceBaseAmountCur && !this.TaxBaseAmountRep)
        {
            this.TaxBaseAmountRep = handler.transCurrencyToReportingCurrency(this.SourceCurrencyCode, this.SourceBaseAmountCur, this.ReportingCurrencyExchRate, this.TransDate);
        }

        if (this.SourceTaxAmountCur && !this.TaxAmountRep)
        {
            this.TaxAmountRep = handler.transCurrencyToReportingCurrency(this.SourceCurrencyCode, this.SourceTaxAmountCur, this.ReportingCurrencyExchRate, this.TransDate);
        }

        if (this.TaxInCostPrice && !this.TaxInCostPriceRep)
        {
            this.TaxInCostPriceRep = handler.transCurrencyToReportingCurrency(this.SourceCurrencyCode, this.TaxInCostPrice, this.ReportingCurrencyExchRate, this.TransDate);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasicSalesTax</ConfigurationKey>
	<DeveloperDocumentation>@SYS134155</DeveloperDocumentation>
	<Label>@SYS134153</Label>
	<TableGroup>WorksheetLine</TableGroup>
	<TitleField1>Voucher</TitleField1>
	<TitleField2>TransDate</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>TaxUncommittedByDocument</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Tax</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceBaseAmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceTaxAmountCur</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Amount</Name>
			<Label>@SYS12227</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxBaseAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxBaseQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxInCostPriceMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceExemptBaseAmountMST_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceExemptTaxAmountMST_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceOtherBaseAmountMST_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceOtherTaxAmountMST_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxReductionPct_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceExemptBaseAmount_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceOtherBaseAmount_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceOtherBaseTaxAmount_BR</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Calculation</Name>
			<Label>@SYS7523</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxAutogenerated</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxDirection</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExemptTax</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntracomVAT</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxSubstitution_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DocumentDate_PL</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CurrentCurrency</Name>
			<Label>@SYS17756</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SourceCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceBaseAmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceBaseAmountCurRegulated</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceTaxAmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceRegulateAmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxInCostPrice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxInCostPriceRegulated</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceBaseAmountCurCalculated</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Description</Name>
			<Label>@SYS6303</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxOrigin</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxType_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxationCode_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FiscalValue_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxationCodeAdj_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxationOrigin_BR</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GSTHSTTaxType_CA</Name>
			<Label>@SYS313827</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>GSTHSTTaxType_CA</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IsDeleted</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>InventProfile_RU</Name>
			<Label>@GLS113772</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventProfileType_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WithoutTaxTrans_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Posting_RU</Name>
			<Label>@SYS5943</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PostingProfile_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PostponeVAT</Name>
			<Label>@GLS111972</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PostponeVAT</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReverseCharge</Name>
			<Label>@SYS118818</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>EmptyTaxBaseForOutgoingTax_W</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReverseCharge_W</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTaxCurrency</Name>
			<Label>@SYS22974</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxBaseAmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxAmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxInCostPriceCur</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTaxExchangeRate</Name>
			<Label>@GLS112405</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExchangeRateTaxBaseAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRateTaxAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRateSourceRegulateAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRateSourceBaseAmountRegulated</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTaxGroups</Name>
			<Label>@SYS22352</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroup</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Source</Name>
			<Label>@SYS11258</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SourceRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceTableId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Tax_IN</Name>
			<Label>@SYS28668</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension_IN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TaxType_MX</Name>
			<Label>@SYS33553</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxType_MX</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TaxUnrealized</Name>
			<Label>@SYS115509</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>UnrealizedTax</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VATOperationCode_RU</Name>
			<Label>@GLS112871</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VATOperationCode_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VATTaxAgentVendAccount_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReportingCurrency</Name>
			<Label>@GeneralLedger:ReportingCurrency</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReportingCurrencyExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReportingCurrencyExchRateSecondary</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SourceCurrencyCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<HelpText>@TaxTrans:SourceCurrencyCodeHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Addressing_PL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>PL</CountryRegionCodes>
			<ExtendedDataType>Addressing</ExtendedDataType>
			<HelpText>@TaxTrans_W:Addressing_PLHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>CalculationDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<HelpText>@TaxUncommitted:CalculationDateHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Company</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SelectableDataArea</ExtendedDataType>
			<HelpText>@TaxUncommitted:CompanyHelpText</HelpText>
			<Label>@SYS4003094</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencyCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<HelpText>@TaxTrans:CurrencyCodeHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustVendName_PL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PlCustVendName</ExtendedDataType>
			<HelpText>@TaxTrans_W:CustVendName_PLHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DocumentDate_PL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>CZ,PL</CountryRegionCodes>
			<ExtendedDataType>DocumentDate</ExtendedDataType>
			<HelpText>@TaxTrans_W:DocumentDate_PLHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>EUROTriangulation</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EUROTriangulation</ExtendedDataType>
			<HelpText>@TaxTrans:EUROTriangulationHelpText</HelpText>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRateSourceBaseAmountRegulated</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBase</ExtendedDataType>
			<HelpText>@TaxUncommitted:ExchangeRateSourceBaseAmountRegulatedHelpText</HelpText>
			<Label>@GLS112409</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRateSourceRegulateAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<HelpText>@TaxUncommitted:ExchangeRateSourceRegulateAmountHelpText</HelpText>
			<Label>@GLS112411</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRateTaxAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<HelpText>@TaxUncommitted:ExchangeRateTaxAmountHelpText</HelpText>
			<Label>@GLS112415</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRateTaxBaseAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBase</ExtendedDataType>
			<HelpText>@TaxUncommitted:ExchangeRateTaxBaseAmountHelpText</HelpText>
			<Label>@GLS112413</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRateBaseAmountCurRegulated</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBase</ExtendedDataType>
			<HelpText>@TaxIntegration:ExchangeRateBaseAmountCurRegulatedHelpText</HelpText>
			<Label>@TaxIntegration:ExchangeRateBaseAmountCurRegulated</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRateRegulateAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<HelpText>@TaxIntegration:ExchangeRateRegulateAmountCurHelpText</HelpText>
			<Label>@TaxIntegration:ExchangeRateRegulateAmountCur</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRateTaxAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<HelpText>@TaxIntegration:ExchangeRateTaxAmountCurHelpText</HelpText>
			<Label>@TaxIntegration:ExchangeRateTaxAmountCur</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRateTaxBaseAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBase</ExtendedDataType>
			<HelpText>@TaxIntegration:ExchangeRateTaxBaseAmountCurHelpText</HelpText>
			<Label>@TaxIntegration:ExchangeRateTaxBaseAmountCur</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRateTaxAmountRep</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<HelpText>@TaxIntegration:ExchangeRateTaxAmountRepHelpText</HelpText>
			<Label>@TaxIntegration:ExchangeRateTaxAmountRep</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRateTaxBaseAmountRep</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBase</ExtendedDataType>
			<HelpText>@TaxIntegration:ExchangeRateTaxBaseAmountRepHelpText</HelpText>
			<Label>@TaxIntegration:ExchangeRateTaxBaseAmountRep</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchRate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExchRate</ExtendedDataType>
			<HelpText>@TaxUncommitted:ExchRateHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchRateSecond</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExchrateSecondary</ExtendedDataType>
			<HelpText>@TaxUncommitted:ExchRateSecondHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ExemptTax</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxExemptTax</ExtendedDataType>
			<HelpText>@TaxTrans:ExemptTaxHelpText</HelpText>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>FiscalValue_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxUncommitted:FiscalValue_BRHelpText</HelpText>
			<EnumType>TaxFiscalValue_BR</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>GSTHSTTaxType_CA</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxTrans:GSTHSTTaxType_CAHelpText</HelpText>
			<EnumType>GSTHSTTaxType_CA</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>HeadingRecId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<HelpText>@TaxTrans:HeadingRecIdHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>HeadingTableId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefTableId</ExtendedDataType>
			<HelpText>@TaxTrans:HeadingTableIdHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IncludedInPrice_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<HelpText>@TaxUncommitted:IncludedInPrice_BRHelpText</HelpText>
			<Label>@GLS67</Label>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IntracomVAT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxIntracomVAT</ExtendedDataType>
			<HelpText>@TaxUncommitted:IntracomVATHelpText</HelpText>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InventProfileType_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxUncommitted:InventProfileType_RUHelpText</HelpText>
			<EnumType>InventProfileType_RU</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransId</ExtendedDataType>
			<HelpText>@TaxTrans:InventTransIdHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InvoiceId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InvoiceId</ExtendedDataType>
			<HelpText>@TaxTrans:InvoiceIdHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InvoiceRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<HelpText>@TaxTrans:InvoiceRecIdHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsDeleted</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VersioningIsDeleted</ExtendedDataType>
			<HelpText>@TaxUncommitted:IsDeletedHelpText</HelpText>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsOffset</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<HelpText>@TaxUncommitted:IsOffsetHelpText</HelpText>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsOverUnderPayment</Name>
			<HelpText>@TaxTrans:IsOverUnderPaymentHelpText</HelpText>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimension</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionAccount</ExtendedDataType>
			<HelpText>@TaxUncommitted:LedgerDimensionHelpText</HelpText>
			<SysSharingType>Never</SysSharingType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimension_IN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>LedgerDimensionAccount</ExtendedDataType>
			<HelpText>@TaxUncommitted:LedgerDimension_INHelpText</HelpText>
			<SysSharingType>Never</SysSharingType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimensionRev_IN</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>LedgerDimensionAccount</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ManualInsertedTax</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxUncommitted:ManualInsertedTaxHelpText</HelpText>
			<Label>@SYS67708</Label>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>NegativeTax</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxUncommitted:NegativeTaxHelpText</HelpText>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OffsetLedgerDimension_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>LedgerDimensionAccount</ExtendedDataType>
			<HelpText>@TaxUncommitted:OffsetLedgerDimension_RUHelpText</HelpText>
			<Label>@GLS102172</Label>
			<SysSharingType>Never</SysSharingType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OperationLedgerDimension</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionAccount</ExtendedDataType>
			<HelpText>@TaxUncommitted:OperationLedgerDimensionHelpText</HelpText>
			<SysSharingType>Never</SysSharingType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OperationPostingType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxUncommitted:OperationPostingTypeHelpText</HelpText>
			<Visible>No</Visible>
			<EnumType>LedgerPostingType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Posted</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxUncommitted:PostedHelpText</HelpText>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PostingProfile_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>PostingProfile</ExtendedDataType>
			<HelpText>@TaxUncommitted:PostingProfile_RUHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PostponeVAT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasicVatDueDate_W</ConfigurationKey>
			<CountryRegionCodes>CZ</CountryRegionCodes>
			<ExtendedDataType>CzPostponeVAT</ExtendedDataType>
			<HelpText>@TaxTrans:PostponeVATHelpText</HelpText>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Prepayment</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxUncommitted:PrepaymentHelpText</HelpText>
			<Label>@SYS59473</Label>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>EmptyTaxBaseForOutgoingTax_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>DK,DE,NL,GB,FR,IE,IS</CountryRegionCodes>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<HelpText>@TaxTrans:EmptyTaxBaseForOutgoingTax_WHelpText</HelpText>
			<Label>@Tax:EmptyTaxBaseOutTax</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SalesTaxExchangeRate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyExchangeRate</ExtendedDataType>
			<Label>@GLS112406</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SalesTaxExchangeRateRep</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyExchangeRate</ExtendedDataType>
			<Label>@TaxIntegration:SalesTaxExchangeRateRep</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SalesTaxExchangeRateCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyExchangeRate</ExtendedDataType>
			<Label>@TaxIntegration:SalesTaxExchangeRateCur</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Source</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxTrans:SourceHelpText</HelpText>
			<Visible>No</Visible>
			<EnumType>TaxModuleType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceBaseAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBaseCur</ExtendedDataType>
			<HelpText>@TaxTrans:SourceBaseAmountCurHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceBaseAmountCurCalculated</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBaseCur</ExtendedDataType>
			<HelpText>@TaxTrans:SourceBaseAmountCurCalculatedHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceBaseAmountCurRaw</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBase</ExtendedDataType>
			<HelpText>@TaxTrans:SourceBaseAmountCurRawHelpText</HelpText>
			<Label>@SYS73028</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceBaseAmountCurRegulated</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBaseCur</ExtendedDataType>
			<HelpText>@TaxTrans:SourceBaseAmountCurRegulatedHelpText</HelpText>
			<Label>@SYS67702</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceDocumentLine</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<HelpText>@TaxTrans:SourceDocumentLineHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceExemptBaseAmount_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxBaseCur</ExtendedDataType>
			<Label>@GLS219</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceExemptBaseAmountMST_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceExemptTaxAmountMST_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceOtherBaseAmount_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxBaseCur</ExtendedDataType>
			<Label>@GLS220</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceOtherBaseAmountMST_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceOtherBaseTaxAmount_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<Label>@GLS490</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceOtherTaxAmountMST_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<HelpText>@TaxTrans:SourceRecIdHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceRegulateAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxRegulationAmountCur</ExtendedDataType>
			<HelpText>@TaxTrans:SourceRegulateAmountCurHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>SourceTableId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefTableId</ExtendedDataType>
			<HelpText>@TaxTrans:SourceTableIdHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceTaxAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<HelpText>@TaxTrans:SourceTaxAmountCurHelpText</HelpText>
			<Label>@SYS76510</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceTaxAmountCurReal</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<HelpText>@TaxTrans:SourceTaxAmountCurRealHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<HelpText>@TaxTrans:TaxAmountHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<HelpText>@TaxTrans:TaxAmountCurHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxAmountRep</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<HelpText>@TaxTrans:TaxAmountRepHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxationCode_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxationCode_BR</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxationCodeAdj_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxationCode_BR</ExtendedDataType>
			<Label>@GLS50816</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxationOrigin_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>FITaxationOrigin_BR</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxAutogenerated</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAutoGenerated</ExtendedDataType>
			<HelpText>@TaxTrans:TaxAutogeneratedHelpText</HelpText>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxBaseAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBase</ExtendedDataType>
			<HelpText>@TaxTrans:TaxBaseAmountHelpText</HelpText>
			<Label>@SYS73028</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxBaseAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBaseCur</ExtendedDataType>
			<HelpText>@TaxTrans:TaxBaseAmountCurHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxBaseAmountRep</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBaseCur</ExtendedDataType>
			<HelpText>@TaxTrans:TaxBaseAmountRepHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxBaseAmountOrig</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxBase</ExtendedDataType>
			<HelpText>@TaxTrans:TaxBaseAmountOrigHelpText</HelpText>
			<Label>@GLS226</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxBaseAmountRaw</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBase</ExtendedDataType>
			<HelpText>@TaxTrans:TaxBaseAmountRawHelpText</HelpText>
			<Label>@SYS73028</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxBaseQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxQty</ExtendedDataType>
			<HelpText>@TaxTrans:TaxBaseQtyHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxCode</ExtendedDataType>
			<HelpText>@TaxTrans:TaxCodeHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>TaxCodeCombinationId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxCodeCombinationId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxDirection</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxTrans:TaxDirectionHelpText</HelpText>
			<EnumType>TaxDirection</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxGroup</ExtendedDataType>
			<HelpText>@TaxTrans:TaxGroupHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxInCostPrice</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<HelpText>@TaxTrans:TaxInCostPriceHelpText</HelpText>
			<Label>@SYS24596</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxInCostPriceCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<HelpText>@TaxTrans:TaxInCostPriceCurHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxInCostPriceRep</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<HelpText>@TaxTrans:TaxInCostPriceRepHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxInCostPriceMST</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<HelpText>@TaxTrans:TaxInCostPriceMSTHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxInCostPriceRegulated</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxRegulationAmountCur</ExtendedDataType>
			<HelpText>@TaxTrans:TaxInCostPriceRegulatedHelpText</HelpText>
			<Label>@SYS53190</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxItemGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxItemGroup</ExtendedDataType>
			<HelpText>@TaxTrans:TaxItemGroupHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxLimitReached</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxLimitReached</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxOffsetUseTaxLedgerDimension</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionAccount</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxOrigin</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxTrans:TaxOriginHelpText</HelpText>
			<EnumType>TaxOrigin</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxPeriodPaymentCode_PL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PlTaxPeriodPaymentCode</ExtendedDataType>
			<HelpText>@TaxTrans_W:TaxPeriodPaymentCode_PLHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxReceivableLongTerm_BR</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxReceivableLongTerm_BR</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxReductionPct_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxValue</ExtendedDataType>
			<Label>@GLS60</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxReports</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxSalesOffsetLedgerDimension_BR</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>LedgerDimensionAccount</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxSubstitution_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxSubstitution_BR</ExtendedDataType>
			<EnumType>TaxSubstitutionEnum_BR</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxType_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>TaxType_BR</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxType_MX</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>TaxType_MX</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>TransDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<HelpText>@TaxTrans:TransDateHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Txt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransactionTextLarge</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UnrealizedTax</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>MX</CountryRegionCodes>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<HelpText>@TaxTrans:UnrealizedTaxHelpText</HelpText>
			<Label>@SYS115509</Label>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>VatDueDate_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VatDueDate_W</ExtendedDataType>
			<HelpText>@TaxTrans_W:VatDueDate_WHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VATNum_PL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>PL</CountryRegionCodes>
			<ExtendedDataType>VATNum</ExtendedDataType>
			<HelpText>@TaxTrans_W:VATNum_PLHelpText</HelpText>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VATOperationCode_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VATOperationCode_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VATTaxAgentVendAccount_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VATTaxAgentVendAccount_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Voucher</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Voucher</ExtendedDataType>
			<HelpText>@TaxTrans:VoucherHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Warning</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>TaxWarning</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WithoutTaxTrans_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WithoutTaxTrans_RU</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReverseCharge_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxReverseCharge</ExtendedDataType>
			<HelpText>@TaxTrans:ReverseCharge_WHelpText</HelpText>
			<Label>@SYS118818</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReverseChargeApplies_UK</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<CountryRegionCodes>GB</CountryRegionCodes>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ReportingCurrencyExchRateSecondary</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReportingCurrencyExchRateSecondary</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ReportingCurrencyExchRate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReportingCurrencyExchRate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxValue</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxValue</ExtendedDataType>
			<HelpText>@TaxTrans:TaxValueHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxID</Name>
			<AllowEdit>No</AllowEdit>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<HelpText>@TaxTrans:TaxIDHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PartyTaxId</Name>
			<AllowEdit>No</AllowEdit>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<HelpText>@TaxTrans:PartyTaxIdHelpText</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>ParentSourceTableId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefTableId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ParentSourceRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldGuid">
			<Name>ISVFeatureSetupGuid</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SysGuid</ExtendedDataType>
			<FeatureClass>TaxIntegrationISVTaxPostToggle</FeatureClass>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ISVFeatureSetupName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxIntegrationFeatureSetupName</ExtendedDataType>
			<FeatureClass>TaxIntegrationISVTaxPostToggle</FeatureClass>
			<Label>@TaxIntegration:FeatureSetupName</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TaxUncommittedByDocument</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>HeadingRecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HeadingTableId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Voucher</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InvoiceId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Company</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TaxUncommittedByTransactionLine</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceRecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>SourceTableId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxInCostPriceRegulated</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SourceDocumentLine</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceDocumentLine</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>dataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxDirection</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>OffsetLedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSERussia</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>OffsetLedgerDimension_RU</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueCombinationIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSEBrazil</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>TaxSalesOffsetLedgerDimension_BR</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SourceRefIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceTableId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>SourceRecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>HeadingIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>HeadingTableId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>HeadingRecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SourceRecIdSourceTableIdDataAreaIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceTableId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>SourceRecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SourceDocumentLineImplementation</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>SourceDocumentLine</MapField>
					<MapFieldTo>SourceDocumentLine</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>TaxMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
					<MapFieldTo>CurrencyCode</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TransDate</MapField>
					<MapFieldTo>TransDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxCode</MapField>
					<MapFieldTo>TaxCode</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxDirection</MapField>
					<MapFieldTo>TaxDirection</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAutoGenerated</MapField>
					<MapFieldTo>TaxAutogenerated</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTaxAmountCur</MapField>
					<MapFieldTo>SourceTaxAmountCur</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRegulateAmountCur</MapField>
					<MapFieldTo>SourceRegulateAmountCur</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxInCostPrice</MapField>
					<MapFieldTo>TaxInCostPrice</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxInCostPriceRegulated</MapField>
					<MapFieldTo>TaxInCostPriceRegulated</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
					<MapFieldTo>TaxGroup</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceDocumentLine</MapField>
					<MapFieldTo>SourceDocumentLine</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>SourceTableId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>SourceRecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EUROTriangulation</MapField>
					<MapFieldTo>EUROTriangulation</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchangeRate</MapField>
					<MapFieldTo>ExchRate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchangeRateSecond</MapField>
					<MapFieldTo>ExchRateSecond</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchangeRateSourceRegulateAmount</MapField>
					<MapFieldTo>ExchangeRateSourceRegulateAmount</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchangeRateTaxAmount</MapField>
					<MapFieldTo>ExchangeRateTaxAmount</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceCurrencyCode</MapField>
					<MapFieldTo>SourceCurrencyCode</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceOtherBaseTaxAmount_BR</MapField>
					<MapFieldTo>SourceOtherBaseTaxAmount_BR</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAmount</MapField>
					<MapFieldTo>TaxAmount</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxItemGroup</MapField>
					<MapFieldTo>TaxItemGroup</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VATDueDate_W</MapField>
					<MapFieldTo>VatDueDate_W</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>WithoutTaxTrans_RU</MapField>
					<MapFieldTo>WithoutTaxTrans_RU</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FiscalValue_BR</MapField>
					<MapFieldTo>FiscalValue_BR</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>TaxModelTaxTransaction_IN</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>CalculationDate</MapField>
					<MapFieldTo>CalculationDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Company</MapField>
					<MapFieldTo>Company</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
					<MapFieldTo>CurrencyCode</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchRate</MapField>
					<MapFieldTo>ExchRate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExemptTax</MapField>
					<MapFieldTo>ExemptTax</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximAuthorizationId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximBalanceTaxAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximBalanceTaxAmountCur</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximBalanceTaxCorrectedAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximBalanceTaxCorrectedAmountCur</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximDEPBAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximDEPBAmountCur</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximIncentiveScheme</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximTaxAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximTaxAmountCur</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximTaxCorrectedAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EximTaxCorrectedAmountCur</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FormulaID</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>HeadingRecId</MapField>
					<MapFieldTo>HeadingRecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>HeadingTableId</MapField>
					<MapFieldTo>HeadingTableId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventTransId</MapField>
					<MapFieldTo>InventTransId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LedgerDimension</MapField>
					<MapFieldTo>LedgerDimension</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LedgerDimension_IN</MapField>
					<MapFieldTo>LedgerDimension_IN</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LoadOnInventoryTax</MapField>
					<MapFieldTo>TaxInCostPriceMST</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>OperationLedgerDimension</MapField>
					<MapFieldTo>OperationLedgerDimension</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>OperationPostingType</MapField>
					<MapFieldTo>OperationPostingType</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Posted</MapField>
					<MapFieldTo>Posted</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Source</MapField>
					<MapFieldTo>Source</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceBaseAmountCur</MapField>
					<MapFieldTo>SourceBaseAmountCur</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceBaseAmountCurCalculated</MapField>
					<MapFieldTo>SourceBaseAmountCurCalculated</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceBaseAmountCurRaw</MapField>
					<MapFieldTo>SourceBaseAmountCurRaw</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceBaseAmountCurRegulated</MapField>
					<MapFieldTo>SourceBaseAmountCurRegulated</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceCurrencyCode</MapField>
					<MapFieldTo>SourceCurrencyCode</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>SourceRecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRegulateAmountCur</MapField>
					<MapFieldTo>SourceRegulateAmountCur</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRegulateAmountCustoms</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>SourceTableId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTaxAmountCur</MapField>
					<MapFieldTo>SourceTaxAmountCur</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTaxAmountCurReal</MapField>
					<MapFieldTo>SourceTaxAmountCurReal</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAccountType</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAmount</MapField>
					<MapFieldTo>TaxAmount</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAmountCur</MapField>
					<MapFieldTo>TaxAmountCur</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAutogenerated</MapField>
					<MapFieldTo>TaxAutogenerated</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxBaseAmount</MapField>
					<MapFieldTo>TaxBaseAmount</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxBaseAmountCur</MapField>
					<MapFieldTo>TaxBaseAmountCur</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxBaseAmountRaw</MapField>
					<MapFieldTo>TaxBaseAmountRaw</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxBaseQty</MapField>
					<MapFieldTo>TaxBaseQty</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxCode</MapField>
					<MapFieldTo>TaxCode</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxDirection</MapField>
					<MapFieldTo>TaxDirection</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
					<MapFieldTo>TaxGroup</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxInCostPrice</MapField>
					<MapFieldTo>TaxInCostPrice</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxInCostPriceCur</MapField>
					<MapFieldTo>TaxInCostPriceCur</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxInCostPriceMST</MapField>
					<MapFieldTo>TaxInCostPriceMST</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxInCostPriceRegulated</MapField>
					<MapFieldTo>TaxInCostPriceRegulated</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxItemGroup</MapField>
					<MapFieldTo>TaxItemGroup</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxOffsetUseTaxLedgerDimension</MapField>
					<MapFieldTo>TaxOffsetUseTaxLedgerDimension</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxOrigin</MapField>
					<MapFieldTo>TaxOrigin</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TransDate</MapField>
					<MapFieldTo>TransDate</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation>
			<Name>CustInvoiceLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustInvoiceLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustInvoiceLine</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>IsDeleted</Name>
					<Field>IsDeleted</Field>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceRecId</Name>
					<Field>SourceRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceTableId</Name>
					<Field>SourceTableId</Field>
					<RelatedField>TableId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustInvoiceTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustInvoiceTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustInvoiceTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>HeadingRecId</Name>
					<Field>HeadingRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOrigin</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransId</Name>
					<SourceEDT>InventTransId</SourceEDT>
					<Field>InventTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventTransIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimension</Name>
					<Field>LedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerDimension_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DimensionAttributeValueCombination</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DimensionAttributeValueCombination_TaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimension_IN</Name>
					<Field>LedgerDimension_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerDimensionRev_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>RevDimensionAttributeValueCombination</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>RevTaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimensionRev_IN</Name>
					<Field>LedgerDimensionRev_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>OffsetLedgerDimension_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetLedgerDimension_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetLedgerDimension_RU</Name>
					<Field>OffsetLedgerDimension_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>OperationLedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OperationLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OperationLedgerDimension</Name>
					<Field>OperationLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PlTaxDueTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PlTaxDueTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PlTaxDueTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxPeriodPaymentCode_PL</Name>
					<Field>TaxPeriodPaymentCode_PL</Field>
					<RelatedField>TaxPeriodPaymentCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SourceDocumentLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SourceDocumentLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>SourceDocumentLine</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceDocumentLine</Name>
					<Field>SourceDocumentLine</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxCurrencyCode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CurrencyCode</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>CurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxGroup</Name>
					<SourceEDT>TaxGroup</SourceEDT>
					<Field>TaxGroup</Field>
					<RelatedField>TaxGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxItemGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxItemGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxItemGroup</Name>
					<SourceEDT>TaxItemGroup</SourceEDT>
					<Field>TaxItemGroup</Field>
					<RelatedField>TaxItemGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxItemGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxOffsetUseTaxLedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxOffsetUseTaxLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxOffsetUseTaxLedgerDimension</Name>
					<Field>TaxOffsetUseTaxLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxSalesOffsetLedgerDimension_BR</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxSalesOffsetDimension_BR</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxSalesOffsetLedgerDimension_BR</Name>
					<SourceEDT>LedgerDimensionAccount</SourceEDT>
					<Field>TaxSalesOffsetLedgerDimension_BR</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxCode</Name>
					<SourceEDT>TaxCode</SourceEDT>
					<Field>TaxCode</Field>
					<RelatedField>TaxCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TransactionCurrencyCode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TransactionCurrencyCode</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceCurrencyCode</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>SourceCurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TrvExpTrans</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TrvExpTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TrvExpTrans</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxUncommitted</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceTableId</Name>
					<Field>SourceTableId</Field>
					<RelatedField>TableId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceRecId</Name>
					<Field>SourceRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VATOperationCodeTable_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>VATOperationCodeTable_RU</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VATOperationCode_RU</Name>
					<SourceEDT>VATOperationCode_RU</SourceEDT>
					<Field>VATOperationCode_RU</Field>
					<RelatedField>OperationCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VATTaxAgemtVendTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VATTaxAgentVendAccount_RU</Name>
					<SourceEDT>VATTaxAgentVendAccount_RU</SourceEDT>
					<Field>VATTaxAgentVendAccount_RU</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>VATTaxAgent_RU_Extern</Name>
					<SourceEDT>VATTaxAgentVendAccount_RU</SourceEDT>
					<RelatedField>VATTaxAgent_RU</RelatedField>
					<Value>1</Value>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxRegistration</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxRegistration</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxID</Name>
					<Field>TaxID</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PartyTaxRegistration</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxRegistration</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PartyTaxId</Name>
					<Field>PartyTaxId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>