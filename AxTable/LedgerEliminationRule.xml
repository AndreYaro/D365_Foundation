<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerEliminationRule</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class LedgerEliminationRule extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the currency code to display.
    /// </summary>
    /// <returns>
    /// The currency code.
    /// </returns>
    display CurrencyCode    currencyCode()
    {
        ;

        return Ledger::accountingCurrency(CompanyInfo::current());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInEffectiveRange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the date falls in the effective date range.
    /// </summary>
    /// <param name="_dateToCheck">
    ///    The date to validate.
    /// </param>
    /// <returns>
    ///    true if the date is in the range; otherwise, false.
    /// </returns>
    public boolean isInEffectiveRange(TransDate _dateToCheck)
    {
        boolean inRange;
        ;

        inRange = ((this.EffectiveStartDate <= _dateToCheck) &&
            (this.EffectiveEndDate == dateNull() ||
            this.EffectiveEndDate >= _dateToCheck));

        return inRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRuleValidToProcess</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether an elimination rule is valid to process.
    /// </summary>
    /// <param name="_periodToDate">
    ///    The last day of the date range to retrieve source values. It must fall in the effective date range
    ///    of the rule.
    /// </param>
    /// <param name="_glPostingDate">
    ///    The date on which to create the elimination journal.
    /// </param>
    /// <param name="_destinationCompany">
    ///    The company in which to create the elimination journal.
    /// </param>
    /// <param name="_validateJournalName">
    ///    A Boolean value that determines whether the journal name should be validated; optional.
    /// </param>
    /// <returns>
    ///    true if the elimination rule is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method sets error messages for each error encountered.
    /// </remarks>
    public boolean isRuleValidToProcess(TransDate               _periodToDate,
                                TransDate               _glPostingDate,
                                selectableDataArea      _destinationCompany,
                                boolean                 _validateJournalName = false)
    {
        boolean ret = true;
        recId   calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();

        ;

        // perform these tests in the source company which is the company we are in when entering
        if (!this.Active)
        {
            ret = checkFailed(strfmt("@SYS107564", this.RuleId)) && ret;
        }

        if (!this.isInEffectiveRange(_periodToDate))
        {
            // The period to date is not within the effective date range of the elimination rule.
            ret = checkFailed(strfmt("@SYS107565", date2StrUsr(_periodToDate, DateFlags::FormatAll))) && ret;
        }

        if (!((select firstonly RuleId
            from
                ledgerEliminationRuleLine
            where
                ledgerEliminationRuleLine.RuleId == this.RuleId).RuleId == this.RuleId))
        {
            // The elimination rule(s) does not have any lines to process.
            ret = checkFailed("@SYS107563") && ret;
        }

        // several errors could be generated by this method
        ret = LedgerEliminationRule::validateDestinationCompany(_destinationCompany) && ret;

        // these tests are all done in the destination company
        if (_destinationCompany == curext())
        {
             // infolog msgs are logged within the called method in this situation
            ret = LedgerFiscalCalendar::checkDateIsValid(calendarRecId,_glPostingDate) && ret;

            if (_validateJournalName)
            {
                // several errors could be generated by this method
                ret = LedgerEliminationRule::validateJournalName(this.JournalName) && ret;
            }
        }
        else
        {
            changecompany(_destinationCompany)
            {
                 // infolog msgs are logged within the called method in this situation
                ret = LedgerFiscalCalendar::checkDateIsValid(calendarRecId,_glPostingDate) && ret;

                if (_validateJournalName)
                {
                    // several errors could be generated by this method
                    ret = LedgerEliminationRule::validateJournalName(this.JournalName) && ret;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the journal name to display.
    /// </summary>
    /// <returns>
    /// The journal description; otherwise, an empty string.
    /// </returns>
    display JournalDescription journalDescription()
    {
        LedgerJournalName ledgerJournalName;
        JournalDescription journalDescription;
        ;

        if (this.DestinationCompany)
        {
            changecompany(this.DestinationCompany)
            {
                journalDescription = (select firstonly
                        ledgerJournalName
                    where
                        ledgerJournalName.JournalName == this.JournalName).Name;
            }
        }

        return journalDescription;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified rule exists in the table.
    /// </summary>
    /// <param name="_ruleId">
    ///    The rule to check for.
    /// </param>
    /// <returns>
    ///    true if the rule exits; otherwise, false.
    /// </returns>
    public static boolean checkExist(LedgerEliminationRuleId _ruleId )
    {
        boolean ret = true;
        ;

        if (!LedgerEliminationRule::exist(_ruleId))
        {
            ret = checkFailed(strfmt(LedgerEliminationRule::txtNotExist(), _ruleId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified rule exists in the table.
    /// </summary>
    /// <param name="_ruleId">
    ///    The rule to check for.
    /// </param>
    /// <returns>
    ///    true if the rule exits; otherwise, false.
    /// </returns>
    public static boolean exist(LedgerEliminationRuleId _ruleId )
    {
        ;

        return (select firstonly
                     RecId
                from
                     ledgerEliminationRule
                 where
                     ledgerEliminationRule.RuleId == _ruleId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reads the <c>LedgerEliminationRule</c> table for the specified rule.
    /// </summary>
    /// <param name="_ruleId">
    ///    The elimination rule to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that determines whether the record should be selected for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    ///    A <c>ConcurrencyModel</c> value used when the table is not automatically concurrent; optional.
    /// </param>
    /// <returns>
    ///    An elimination rule buffer.
    /// </returns>
    public static LedgerEliminationRule find(LedgerEliminationRuleId    _ruleId ,
                                            boolean                     _forUpdate = false,
                                            ConcurrencyModel            _concurrencyModel = ConcurrencyModel::Auto)
    {
        LedgerEliminationRule ledgerEliminationRule;
        ;

        ledgerEliminationRule.selectForUpdate(_forUpdate);

        if (_forUpdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            ledgerEliminationRule.concurrencyModel(_concurrencyModel);
        }

        select firstonly ledgerEliminationRule
            where ledgerEliminationRule.RuleId == _ruleId;

        return ledgerEliminationRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupBySource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Opens a lookup on the elimination rules based on both the source and destination companies.
    /// </summary>
    /// <param name="_ctrl">
    ///    The form that calls the method.
    /// </param>
    /// <param name="_sourceCompany">
    ///    The company in which the rules are defined.
    /// </param>
    /// <param name="_destinationCompany">
    ///    The company in which the elimination journals are created.
    /// </param>
    /// <remarks>
    ///    The method is used when choosing an elimination rule defined for a specific set of companies.
    ///    An
    ///    error is thrown if the source company is not specified.
    /// </remarks>
    public static void lookupBySource(FormStringControl       _ctrl,
                                            selectableDataArea _sourceCompany,
                                            selectableDataArea _destinationCompany)
    {
        SysTableLookup       sysTableLookup = SysTableLookup::newParameters(tablenum(LedgerEliminationRule), _ctrl);
        Query                query = new Query();
        QueryBuildDataSource queryBuildDataSource;
        boolean              isValid;
        ;

        if (_sourceCompany == "")
        {
            isValid = checkFailed(strfmt("@SYS26332","@SYS107834"));
            return;
        }

        // display the rule and description in the lookup
        sysTableLookup.addLookupfield(fieldnum(LedgerEliminationRule, RuleId));
        sysTableLookup.addLookupfield(fieldnum(LedgerEliminationRule, Description));

        // range on the source and destination company specified
        queryBuildDataSource = query.addDataSource(tablenum(LedgerEliminationRule));
        queryBuildDataSource.addRange(fieldnum(LedgerEliminationRule, SourceCompany)).value(queryValue(_sourceCompany));
        queryBuildDataSource.addRange(fieldnum(LedgerEliminationRule, DestinationCompany)).value(queryValue(_destinationCompany));

        sysTableLookup.parmQuery(query);

        // The destination company is the calling company but the rules are defined in the source company
        // so we must run the lookup in the source company
        changecompany(_sourceCompany)
        {
            sysTableLookup.performFormLookup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the label number to use when displaying a message to indicate that the record does not
    ///    exist.
    /// </summary>
    /// <returns>
    ///    A string indicating the label number to use.
    /// </returns>
    public static TxtNotExist txtNotExist()
    {
        return "@SYS104127";
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDestinationCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the destination company is valid for an elimination rule.
    /// </summary>
    /// <param name="_destinationCompany">
    ///    The company to validate.
    /// </param>
    /// <param name="_checkEmpty">
    ///    A Boolean value that determines whether the test for an empty company should be performed; optional.
    /// </param>
    /// <returns>
    ///    true if the rule passes all tests; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Error messages are set for each error encountered.
    /// </remarks>
    public static boolean validateDestinationCompany(selectableDataArea _destinationCompany, boolean _checkEmpty = true)
    {
        boolean                 ret = true;
        CurrencyCode            sourceCurrencyCode;
        ;

        if (_destinationCompany == "")
        {
            if (_checkEmpty)
            {
                // company is empty - give message
                // needed for 1st tab-off of field since is defaulted to blank
                return checkFailed(strfmt("@SYS26332", fieldpname(LedgerEliminationRule, DestinationCompany)));
            }
        }
        else if (!xDataArea::exist(_destinationCompany))
        {
            ret = checkFailed(strfmt("@SYS10666",_destinationCompany));
        }

        else
        {
            // only change companies if necessary
            if (_destinationCompany == curext())
            {
                if (CompanyInfo::isEliminationCompany(_destinationCompany) == NoYes::No)
                {
                    // The Eliminations option is not selected in the General ledger parameters form for this company.
                    ret = checkFailed(strfmt("@SYS107570", _destinationCompany));
                }
            }

            else
            {
                // the company currencies must be the same so save the currency for testing before changing companies
                sourceCurrencyCode = Ledger::accountingCurrency(CompanyInfo::current());
                changecompany(_destinationCompany)
                {
                    if (CompanyInfo::isEliminationCompany(_destinationCompany) == NoYes::No)
                    {
                        // The Eliminations option is not selected in the General ledger parameters form for this company.
                        ret = checkFailed(strfmt("@SYS107570", _destinationCompany));
                    }
                    if  (sourceCurrencyCode != Ledger::accountingCurrency(CompanyInfo::current()))
                    {
                        // Currency is different between source and destination companies.
                        ret = checkFailed(strfmt("@SYS107582", _destinationCompany)) && ret;
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that a dimension is valid.
    /// </summary>
    /// <param name="_dimensionDefault">
    ///    The dimension to validate.
    /// </param>
    /// <returns>
    ///    true if the dimension is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method will loop through the dimension and determine if each segment is valid.
    /// </remarks>
    public static boolean validateDimension(DimensionDefault _dimensionDefault)
    {
        boolean                         ret = true;
        DimensionAttributeValueSetItem  setItem;
        DimensionAttributeValue         dimAttrValue;
        DimensionAttribute              dimAttr;

        while select DisplayValue from setItem
            where setItem.DimensionAttributeValueSet == _dimensionDefault
            join IsSuspended from dimAttrValue
                where dimAttrValue.RecId == setItem.DimensionAttributeValue
            join * from dimAttr
                where dimAttr.RecId == dimAttrValue.DimensionAttribute
        {
            if (dimAttrValue.IsSuspended)
            {
                ret = checkFailed(strfmt("@SYS106626",  dimAttr.localizedName(), setItem.DisplayValue));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEffectiveDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies that the start and end effective dates are valid.
    /// </summary>
    /// <param name="_startDate">
    /// The first date in the range.
    /// </param>
    /// <param name="_endDate">
    /// The last date in the range.
    /// </param>
    /// <returns>
    /// true if the last date is on or after the first date; otherwise, false.
    /// </returns>
    public static boolean validateEffectiveDates(StartDate _startDate, EndDate _endDate)
    {
        boolean ret = true;
        ;

        if ((_startDate > _endDate) &&
            (_endDate != dateNull()))
        {
            ret = checkFailed("@SYS105946");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEliminationRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether an elimination rule and the processing criteria are valid.
    /// </summary>
    /// <param name="_ruleId">
    ///    The rule to test.
    /// </param>
    /// <param name="_periodToDate">
    ///    The last day of the date range to retrieve source values for. It must fall in the effective date
    ///    range.
    /// </param>
    /// <param name="_glPostingDate">
    ///    The date on which to create the elimination journal.
    /// </param>
    /// <returns>
    ///    true if the rule is valid to process; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method calls the public method <c>validateRule</c> once an elimination rule is read.
    /// </remarks>
    public static boolean validateEliminationRule(LedgerEliminationRuleId _ruleId,
                                    TransDate   _periodToDate,
                                    TransDate   _glPostingDate)

    {
        LedgerEliminationRule   ledgerEliminationRule;
        boolean ret = true;
        ;

        ledgerEliminationRule = LedgerEliminationRule::find(_ruleId);

        if (ledgerEliminationRule.RecId == 0)
        {
            // The elimination rule does not exist.
            ret = checkFailed("@SYS107562");
        }
        else
        {
            // since we have found the rule we can use the same public method used during processing
            ret = ledgerEliminationRule.isRuleValidToProcess(_periodToDate,
                                                    _glPostingDate,
                                                    ledgerEliminationRule.DestinationCompany,
                                                    true);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateJournalName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a journal is a valid elimination journal.
    /// </summary>
    /// <param name="_journalName">
    ///    The journal to test.
    /// </param>
    /// <param name="_checkUserGroup">
    ///    A Boolean value that determines whether the user is in the specified user group; optional.
    /// </param>
    /// <returns>
    ///    true if the journal is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Error messages are set for each error encountered.
    /// </remarks>
    public static boolean validateJournalName(LedgerJournalNameId _journalName, boolean _checkUserGroup = true)
    {
        boolean             ret = true;
        LedgerJournalName   ledgerJournalName;
        ;

        ledgerJournalName = LedgerJournalName::find(_journalName);

        if (ledgerJournalName.RecId == 0)
        {
            // The elimination journal does not exist.
            ret = checkFailed("@SYS107567");
        }
        else
        {
            if (ledgerJournalName.JournalType == LedgerJournalType::Elimination)
            {
                if (_checkUserGroup)
                {
                    if (!JournalStatic::hasUserAccessForGroupId(ledgerJournalName.BlockUserGroupId))
                    {
                        // The user is not a member of the user group on the journal
                        ret = checkFailed("@SYS106265");
                    }
                }
            }
            else
            {
                // The Journal must be an elimination journal.
                ret = checkFailed("@SYS107560");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the ledger dimension is valid for use by eliminations.
    /// </summary>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension to test.
    /// </param>
    /// <returns>
    ///    true if the ledger dimension is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Error messages are set for each error encountered.
    /// </remarks>
    public static boolean validateLedgerDimension(LedgerDimensionAccount _ledgerDimension)
    {
        boolean                 ret;
        DimensionAttributeValue dimAttrValue;
        MainAccount             mainAccount;

        ret = true;

        mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerDimension);
        dimAttrValue = DimensionAttributeValue::findByDimensionAttributeAndEntityInst(
            DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount),
            mainAccount.RecId,
            false,
            true);

        // If ledger account is not a transaction account, display error.
        if  (!mainAccount.transactionAccount())
        {
            ret = checkFailed(strfmt("@SYS105943",mainAccount.MainAccountId)) && ret;
        }

        // If ledger account is closed, display error.
        if (dimAttrValue.IsSuspended)
        {
            ret = checkFailed(strfmt("@SYS105944", mainAccount.MainAccountId)) && ret;
        }

        // If ledger account is blocked, display error.
        if (dimAttrValue.IsBlockedForManualEntry)
        {
            ret = checkFailed(strfmt("@SYS328229", mainAccount.MainAccountId)) && ret;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePeriodToDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the date falls in the effective date range for an elimination rule.
    /// </summary>
    /// <param name="_ruleId">
    ///    The rule to test against.
    /// </param>
    /// <param name="_periodToDate">
    ///    The date to validate.
    /// </param>
    /// <returns>
    ///    true if the date is in the range; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method calls the public method <c>isInEffectiveRange</c> which expects a record to be read.
    /// </remarks>
    public static boolean validatePeriodToDate(LedgerEliminationRuleId _ruleId, TransDate _periodToDate)
    {
        LedgerEliminationRule   ledgerEliminationRule;
        boolean ret = true;
        ;

        ledgerEliminationRule = LedgerEliminationRule::find(_ruleId);

        // since we have found the rule we can use the same public method used during processing
        ret = ledgerEliminationRule.isInEffectiveRange(_periodToDate);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSourceCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the source company is valid for an elimination rule.
    /// </summary>
    /// <param name="_sourceCompany">
    ///    The company to validate.
    /// </param>
    /// <returns>
    ///    true if the company is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The company must have the elimination value set in the parameters.
    /// </remarks>
    public static boolean validateSourceCompany(selectableDataArea _sourceCompany)
    {
        boolean                 ret = true;
        CurrencyCode            destinationCurrencyCode;
        ;

        if (_sourceCompany == "")
        {
            ret = checkFailed(strfmt("@SYS26332","@SYS107834"));
        }
        else if (!xDataArea::exist(_sourceCompany))
        {
            ret = checkFailed(strfmt("@SYS10666",_sourceCompany));
        }

        else
        {
            // only change companies if necessary
            if (_sourceCompany == curext())
            {
                if (CompanyInfo::isConsolidationCompany(_sourceCompany) == NoYes::No)
                {
                    // Source company is not a consolidation company.
                    ret = checkFailed(strfmt("@SYS107573", _sourceCompany));
                }
            }

            else
            {
                destinationCurrencyCode = Ledger::accountingCurrency(CompanyInfo::current());

                changecompany(_sourceCompany)
                {
                    if (CompanyInfo::isConsolidationCompany(_sourceCompany) == NoYes::No)
                    {
                        // Source company is not a consolidation company.
                        ret = checkFailed(strfmt("@SYS107573", _sourceCompany));
                    }

                    if  (destinationCurrencyCode != Ledger::accountingCurrency(CompanyInfo::current()))
                    {
                        // Source and destination company must have same currency.
                        ret = checkFailed(strfmt("@SYS107582", _sourceCompany));
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates write method.
    /// </summary>
    /// <remarks>
    ///    Returns true if the validation passes other wise false.
    /// </remarks>
    public boolean validateWrite()
    {
        boolean ret;

        ret = super();

        // Perform additional error handling if super was successful.
        if (ret)
        {
            // Validate the effective start and end dates.
            ret = LedgerEliminationRule::validateEffectiveDates(this.EffectiveStartDate, this.EffectiveEndDate) && ret;

            // Validate that the destination company is an elimination company and that the destination
            // company has the same currency as the current company.
            ret = LedgerEliminationRule::validateDestinationCompany(this.DestinationCompany, false) && ret;

            // Change to destination company as journal is for destination company, not current company.
            changecompany(this.DestinationCompany)
            {
                // If JournalName is set and Journal Name is not valid display error.
                if (ret && this.JournalName)
                {
                    LedgerEliminationRule::validateJournalName(this.JournalName, false);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validate field method.
    /// </summary>
    /// <_fieldIdToCheck>
    ///    The field id to be validated.
    /// </_fieldIdToCheck>
    /// <remarks>
    ///    Returns true if the validation passes other wise false.
    /// </remarks>
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean ret;

        if (_fieldIdToCheck == fieldNum(LedgerEliminationRule, JournalName))
        {
            ret = true;

            // Change to destination company as journal should be validated in the destination company.
            if (this.DestinationCompany && this.DestinationCompany != curext())
            {
                changecompany(this.DestinationCompany)
                {
                    // If super was successful and JournalName is set and Journal Name is not valid set ret to false.
                    if (this.JournalName && !LedgerEliminationRule::validateJournalName(this.JournalName, false))
                    {
                        ret = false;
                    }
                }
            }
            else
            {
                // If super was successful and JournalName is set and Journal Name is not valid set ret to false.
                if (this.JournalName && !LedgerEliminationRule::validateJournalName(this.JournalName, false))
                {
                    ret = false;
                }
            }
        }
        else
        {
            ret = super(_fieldIdToCheck);
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerAdvConsolidations</ConfigurationKey>
	<DeveloperDocumentation>@SYS126262</DeveloperDocumentation>
	<FormRef>LedgerEliminationRule</FormRef>
	<Label>@SYS107286</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>RuleId</TitleField1>
	<TitleField2>Description</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>Found</CacheLookup>
	<ClusteredIndex>RuleIdx</ClusteredIndex>
	<CreateRecIdIndex>No</CreateRecIdIndex>
	<Modules>Ledger</Modules>
	<PrimaryIndex>RuleIdx</PrimaryIndex>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>LedgerEliminationRuleLine</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>LedgerEliminationRuleLine</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RuleId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DestinationCompany</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceCompany</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EffectiveStartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EffectiveEndDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Active</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateLastRun</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RuleId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Administration</Name>
			<Label>@SYS40777</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>EffectiveStartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EffectiveEndDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Active</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateLastRun</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Company</Name>
			<Label>@SYS13342</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DestinationCompany</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS35583</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RuleId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Journal</Name>
			<Label>@SYS24010</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JournalName</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Source</Name>
			<Label>@SYS11258</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SourceCompany</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Active</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS26201</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DateLastRun</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LastInvoiceDate</ExtendedDataType>
			<Label>@SYS103514</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Description</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Description</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DestinationCompany</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SelectableDataArea</ExtendedDataType>
			<Label>@SYS108105</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>EffectiveEndDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EndDate</ExtendedDataType>
			<Label>@SYS103509</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>EffectiveStartDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>StartDate</ExtendedDataType>
			<Label>@SYS103508</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>JournalName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalNameId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RuleId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerEliminationRuleId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@SYS24765</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SourceCompany</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SelectableDataArea</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>RuleIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>RuleId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DestCoRuleIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>DestinationCompany</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RuleId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>DataArea</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125040</EntityRelationshipRole>
			<RelatedTable>DataArea</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>CompanyInfo</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>LedgerEliminationRule</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DestinationCompany</Name>
					<Field>DestinationCompany</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DataArea_DestinationCompany</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>DataArea</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>DataArea_DestinationCompany</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DestinationCompany</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<Field>DestinationCompany</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>isVirtual_Extern</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<RelatedField>isVirtual</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DataArea_SourceCompany</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>DataArea</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DataArea_SourceCompany</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceCompany</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<Field>SourceCompany</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>isVirtual_Extern</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<RelatedField>isVirtual</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LedgerJournalName</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125928</EntityRelationshipRole>
			<RelatedTable>LedgerJournalName</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalName</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerEliminationRule</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JournalName</Name>
					<SourceEDT>LedgerJournalNameId</SourceEDT>
					<Field>JournalName</Field>
					<RelatedField>JournalName</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>