<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>EcoResProductMaster</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class EcoResProductMaster extends EcoResProduct
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getVariantGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the corresponding variant group type for the given <c>EcoResProductMaster</c> table field.
    /// </summary>
    /// <param name="_groupNameField">
    /// The ID of the field for storing the reference to the target variant group.
    /// </param>
    /// <returns>
    /// A record of the corresponding type.
    /// </returns>
    /// <remarks>
    /// Needed for performing a select query on a <c>RetailDimensionGroupTable</c> map.
    /// </remarks>
    protected RetailDimensionGroupTable getVariantGroup(FieldId _groupNameField)
    {
        RetailColorGroupTable retailColorGroupTable;
        RetailSizeGroupTable  retailSizeGroupTable;
        RetailStyleGroupTable retailStyleGroupTable;

        switch (_groupNameField)
        {
            case fieldNum(EcoResProductMaster, RetailColorGroupId):
                return retailColorGroupTable;
            case fieldNum(EcoResProductMaster, RetailSizeGroupId):
                return retailSizeGroupTable;
            case fieldNum(EcoResProductMaster, RetailStyleGroupId):
                return retailStyleGroupTable;
            default:
                return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductVariants</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides the product variant record IDs that have been created for the specific product model.
    /// </summary>
    /// <returns>
    ///   A list with the variant record IDs.
    /// </returns>    
    [Hookable(false)]
    public List getProductVariants()
    {
        List productVariantRecIdList = new List(Types::Int64);

        EcoResDistinctProductVariant ecoResDistinctProductVariant;

        while select RecId from ecoResDistinctProductVariant
            where ecoResDistinctProductVariant.ProductMaster == this.RecId
        {
            productVariantRecIdList.addEnd(ecoResDistinctProductVariant.RecId);
        }

        return productVariantRecIdList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupNameIsValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the ID of a variant group is correct in a specified field.
    /// </summary>
    /// <param name="_groupField">
    /// The ID of the field to check.
    /// </param>
    /// <returns>
    /// True if the field is empty or contains a correct ID of an existing variant group of the corresponding type, false otherwise.
    /// </returns>
    boolean groupNameIsValid(FieldId _groupField)
    {
        RetailDimensionGroupTable retailDimensionGroupTable;

        if (this.(_groupField) != "")
        {
            retailDimensionGroupTable = this.getVariantGroup(_groupField);

            select firstonly RecId from retailDimensionGroupTable
                where retailDimensionGroupTable.DimensionGroup == this.(_groupField);

            if (retailDimensionGroupTable.RecId == 0)
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasProductVariants</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether product variants have been created for the product model.
    /// </summary>
    /// <returns>
    ///    true if product variants have been created; otherwise, false.
    /// </returns>
    public boolean hasProductVariants()
    {
        EcoResDistinctProductVariant ecoResDistinctProductVariant;

        select firstonly RecId from ecoResDistinctProductVariant
            where ecoResDistinctProductVariant.ProductMaster == this.RecId;

        return ecoResDistinctProductVariant.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConstraintBased</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the variant configuration technology is constraint based.
    /// </summary>
    /// <returns>
    ///    true if the variant configuration technology is constraint based; otherwise, false.
    /// </returns>
    public boolean isConstraintBased()
    {
        return (this.VariantConfigurationTechnology == EcoResVariantConfigurationTechnologyType::ConstraintBased);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDimensionBased</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the variant configuration technology is dimension based.
    /// </summary>
    /// <returns>
    ///    true if the variant configuration technology is dimension based; otherwise, false.
    /// </returns>
    public boolean isDimensionBased()
    {
        return (this.VariantConfigurationTechnology == EcoResVariantConfigurationTechnologyType::DimensionBased);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPredefinedVariants</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the variant configuration technology is predefined variants.
    /// </summary>
    /// <returns>
    ///    true if the variant configuration technology is predefined variants; otherwise, false.
    /// </returns>
    public boolean isPredefinedVariants()
    {
        return (this.VariantConfigurationTechnology == EcoResVariantConfigurationTechnologyType::PredefinedVariants);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSupportedForNonInventoriedItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the variant configuration technology is supported for non-inventoried items.
    /// </summary>
    /// <returns>
    ///    true if the variant configuration technology is supported for non-inventoried items; otherwise,
    ///    false.
    /// </returns>
    public boolean isSupportedForNonInventoriedItems()
    {
        return (this.VariantConfigurationTechnology != EcoResVariantConfigurationTechnologyType::ConstraintBased);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modelingPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the related record in the <c>EcoResProductMasterModelingPolicy</c> table.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>EcoResProductModelingPolicy</c> table; otherwise, an empty record.
    /// </returns>
    public EcoResProductMasterModelingPolicy modelingPolicy(boolean _forUpdate = false)
    {
        return EcoResProductMasterModelingPolicy::findByProductMaster(this.RecId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateProductVariants</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the product variants must be created for product modeling policy.
    /// </summary>
    /// <returns>
    ///    true if product variants must be created for product modeling policy; otherwise, false.
    /// </returns>
    public boolean mustCreateProductVariants()
    {
        boolean result;

        if (this.isPredefinedVariants())
        {
            result = EcoResProductMasterModelingPolicy::findByProductMaster(this.RecId).isAutomaticVariantGenerationEnabled();
        }
        else
        {
            result = false;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateColorGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts the records into <c>EcoResProductMasterColor</c> table.
    /// </summary>
    /// <param name="_suppressDialog">
    /// A boolean value indicating whether dialogs should be suppressed.
    /// </param>
    /// <returns>
    ///     true if user wants to change item's color to the colors of the new group and the specified group exists (or is empty), else false.
    /// </returns>
    /// <remarks>
    ///     This method is used to validate color group on the product master details form
    ///     and inserts the records into <c>EcoResProductMasterColor</c> table if it does not exist.
    /// </remarks>
    boolean validateColorGroup(boolean _suppressDialog = false)
    {
        EcoResProductMasterColor                ecoResProductMasterColor;

        #Retail

        if (this.groupNameIsValid(fieldNum(EcoResProductMaster, RetailColorGroupId)) && !this.isReleased())
        {
            if (!_suppressDialog)
            {
                select firstOnly RecId from ecoResProductMasterColor
                    where ecoResProductMasterColor.colorProductMaster == this.RecId;

                if (ecoResProductMastercolor.RecId)
                {
                    if (Box::yesNo("@RET3989" + #CharNewLine
                                 + "@RET3990",DialogButton::Yes,"@RET3951","@RET3991") == DialogButton::No)
                    {
                        return false;
                    }
                }
            }

            return true;
        }
        else
        {
            return checkFailed(strFmt("@SYS78966", fieldPname(EcoResProductMaster, RetailColorGroupId)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyColorGroup</Name>
				<Source><![CDATA[
    private void applyColorGroup(boolean _mustCreateProductVariants)
    {
        ttsbegin;

        // Delete all the color names first before reassigning a new color group on the product master details form.
        this.deleteColorReferences();

        RetailColorGroupTrans colorGroupTrans;
        EcoRescolor ecoRescolor;
        while select colorGroupTrans
            where colorGroupTrans.colorGroup == this.RetailcolorGroupId
             join ecoRescolor 
            where ecoRescolor.Name == colorGroupTrans.color
        {
            EcoResProductMasterColor masterColor = this.createMasterColor(colorGroupTrans, ecoResColor);

            this.createColorTranslations(colorGroupTrans, masterColor);

            if (_mustCreateProductVariants)
            {
                masterColor.createVariantsFromDimensionValue(masterColor.ColorProductMaster, masterColor.ColorProductDimensionAttribute, masterColor.Color);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createColorTranslations</Name>
				<Source><![CDATA[
    private void createColorTranslations(RetailColorGroupTrans _colorGroupTrans, EcoResProductMasterColor _masterColor)
    {
        RetailColorGroupTransTranslation retailColorGroupTransTranslation;
        while select Name, Description, LanguageId from retailColorGroupTransTranslation
               where retailColorGroupTransTranslation.RetailColorGroupTrans == _colorGroupTrans.RecId
        {
            EcoResGroupDimValTranslationsHelper::insertDimensionValueTranslation(
                retailColorGroupTransTranslation.Name,
                retailColorGroupTransTranslation.Description,
                retailColorGroupTransTranslation.LanguageId,
                _masterColor.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteColorReferences</Name>
				<Source><![CDATA[
    private void deleteColorReferences()
    {
        EcoResProductMasterColor     ecoResProductMasterColor;
        EcoResDistinctProductVariant ecoResDistinctProductVariant;
        delete_from ecoResDistinctProductVariant
            where ecoResDistinctProductVariant.ProductMaster == this.RecId;
        delete_from ecoResProductMasterColor
            where ecoResProductMasterColor.ColorProductMaster == this.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMasterColor</Name>
				<Source><![CDATA[
    private EcoResProductMasterColor createMasterColor(
        RetailcolorGroupTrans _colorGroupTrans,
        EcoRescolor _ecoRescolor)
    {
        EcoResProductMasterColor masterColor;
        RetailColorGroupTrans::populateInventColorProperties(masterColor, _ecoRescolor, this);
        _colorGroupTrans.populateColorGroupProperties(masterColor);
        using (var variantCreationscope = new EcoResProductMasterSkipVariantCreationScope())
        {
            masterColor.insert();
        }

        return masterColor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(fieldId _fieldIdToCheck)
    {
        boolean ret = true;

        ret = ret && super(_fieldIdToCheck);

        switch (_fieldIdToCheck)
        {
            case(fieldNum(EcoResProductMaster, RetailSizeGroupId)) :
                ret = ret && this.validateSizeGroup(!FormDataUtil::isFormDataSource(this));
                break;
            case(fieldNum(EcoResProductMaster, RetailColorGroupId)) :
                ret = ret && this.validateColorGroup(!FormDataUtil::isFormDataSource(this));
                break;
            case(fieldNum(EcoResProductMaster, RetailStyleGroupId)) :
                ret = ret && this.validateStyleGroup(!FormDataUtil::isFormDataSource(this));
                break;
            case(fieldNum(EcoResProductMaster, IsProductVariantUnitConversionEnabled)) :
                ret = ret && this.validateProductVariantUnitConversion();
                break;
            case(fieldNum(EcoResProduct, PdsCWProduct)) :
                ret = ret  & this.validatePdsCWProduct();                
                break;

            default:
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePdsCWProduct</Name>
				<Source><![CDATA[
    private boolean validatePdsCWProduct()
    {
        if (EcoResProductUnitConverter::isProductUnitConversionPerVariantEnabled() && this.IsProductVariantUnitConversionEnabled && this.PdsCWProduct)
        {
            return checkFailed("@SCM:EnableCatchWeightForUnitOfMeasureMasterError");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSizeGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts the records into <c>EcoResProductMasterSize</c> table.
    /// </summary>
    /// <param name="_suppressDialog">
    /// A boolean value indicating whether dialogs should be suppressed.
    /// </param>
    /// <returns>
    ///     true if user wants to change item's sizes to the sizes of the new group and the specified group exists (or is empty), else false.
    /// </returns>
    /// <remarks>
    ///     This method is used to validate size group on the product master details form
    ///     and inserts the records into <c>EcoResProductMasterSize</c> table if it does not exist.
    /// </remarks>
    boolean validateSizeGroup(boolean _suppressDialog = false)
    {
        EcoResProductMasterSize                 ecoResProductMasterSize;

        #Retail

        if (this.groupNameIsValid(fieldNum(EcoResProductMaster, RetailSizeGroupId)) && !this.isReleased())
        {
            if (!_suppressDialog)
            {
                // To check whether record exists for particular product.
                select firstOnly RecId from ecoResProductMasterSize
                    where ecoResProductMasterSize.SizeProductMaster == this.RecId;

                if (ecoResProductMasterSize.RecId)
                {
                    if (Box::yesNo("@RET4002" + #CharNewLine
                                 + "@RET4003",DialogButton::Yes,"@RET3951","@RET4004") == DialogButton::No)
                    {
                        return false;
                    }
                }
            }

            return true;
        }
        else
        {
            return checkFailed(strFmt("@SYS78966", fieldPname(EcoResProductMaster, RetailSizeGroupId)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applySizeGroup</Name>
				<Source><![CDATA[
    private void applySizeGroup(boolean _mustCreateProductVariants)
    {
        ttsbegin;

        // Delete all the Size names first before reassigning a new Size group on the product master details form.
        this.deleteExistingSizeReferences();

        RetailSizeGroupTrans sizeGroupTrans;
        EcoResSize           ecoResSize;

        while select sizeGroupTrans
             where sizeGroupTrans.sizeGroup == this.RetailSizeGroupId
              join ecoResSize
             where ecoResSize.Name == sizeGroupTrans.size
        {
            EcoResProductMasterSize ecoResProductMasterSize = this.createMasterSize(sizeGroupTrans, ecoResSize);

            this.createSizeGroupTranslations(sizeGroupTrans, ecoResProductMasterSize);

            if (_mustCreateProductVariants)
            {
                ecoResProductMasterSize.createVariantsFromDimensionValue(ecoResProductMasterSize.SizeProductMaster, ecoResProductMasterSize.SizeProductDimensionAttribute, ecoResProductMasterSize.Size);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExistingSizeReferences</Name>
				<Source><![CDATA[
    private void deleteExistingSizeReferences()
    {
        EcoResProductMasterSize      ecoResProductMasterSize;
        EcoResDistinctProductVariant ecoResDistinctProductVariant;
        delete_from ecoResDistinctProductVariant
         where ecoResDistinctProductVariant.ProductMaster == this.RecId;
        delete_from ecoResProductMasterSize
         where ecoResProductMasterSize.SizeProductMaster == this.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSizeGroupTranslations</Name>
				<Source><![CDATA[
    private void createSizeGroupTranslations(RetailSizeGroupTrans _sizeGroupTrans, EcoResProductMasterSize _ecoResProductMasterSize)
    {
        RetailSizeGroupTransTranslation retailSizeGroupTransTranslation;

        while select Name, Description, LanguageId from retailSizeGroupTransTranslation
            where retailSizeGroupTransTranslation.RetailSizeGroupTrans == _sizeGroupTrans.RecId
        {
            EcoResGroupDimValTranslationsHelper::insertDimensionValueTranslation(
                retailSizeGroupTransTranslation.Name,
                retailSizeGroupTransTranslation.Description,
                retailSizeGroupTransTranslation.LanguageId,
                _ecoResProductMasterSize.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMasterSize</Name>
				<Source><![CDATA[
    private EcoResProductMasterSize createMasterSize(RetailSizeGroupTrans _sizeGroupTrans, EcoResSize _ecoResSize)
    {
        EcoResProductMasterSize ecoResProductMasterSize;
        RetailSizeGroupTrans::populateInventSizeProperties(ecoResProductMasterSize, _ecoResSize, this);
        _sizeGroupTrans.populateSizeGroupProperties(ecoResProductMasterSize);
        using (var variantCreationscope = new EcoResProductMasterSkipVariantCreationScope())
        {
            ecoResProductMasterSize.insert();
        }

        return ecoResProductMasterSize;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateStyleGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts the records into <c>EcoResProductMasterStyle</c> table.
    /// </summary>
    /// <param name="_suppressDialog">
    /// A boolean value indicating whether dialogs should be suppressed.
    /// </param>
    /// <returns>
    ///     true if user wants to change item's style to the style of the new group and the specified group exists (or is empty), else false.
    /// </returns>
    /// <remarks>
    ///     This method is used to validate style group on the product master details form
    ///     and inserts the records into <c>EcoResProductMasterStyle</c> table if it does not exist.
    /// </remarks>
    boolean validateStyleGroup(boolean _suppressDialog = false)
    {
        EcoResProductMasterStyle                ecoResProductMasterStyle;

        #Retail

        if (this.groupNameIsValid(fieldNum(EcoResProductMaster, RetailStyleGroupId)) && !this.isReleased())
        {
            if (!_suppressDialog)
            {
                // To check whether record exists for particular product.
                select firstonly RecId from ecoResProductMasterStyle
                    where ecoResProductMasterStyle.StyleProductMaster == this.RecId;

                if (ecoResProductMasterStyle.RecId)
                {
                    if (Box::yesNo("@Retail:RetailProductVariantsStyleGroup" + #CharNewLine
                                 + "@Retail:RetailProductVariantsStyleGroupConfirm",DialogButton::Yes,"@RET3951","@Retail:RetailProductVariantsStyleGroupChange") == DialogButton::No)
                    {
                        return false;
                    }
                }
            }

            return true;
        }
        else
        {
            return checkFailed(strFmt("@SYS78966", fieldPname(EcoResProductMaster, RetailStyleGroupId)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyStyleGroup</Name>
				<Source><![CDATA[
    private void applyStyleGroup(boolean _mustCreateProductVariants)
    {
        ttsbegin;

        // Delete all the style names first before reassigning a new style group on the product master details form.
        this.deleteStyleReferences();

        RetailStyleGroupTrans styleGroupTrans;
        EcoResStyle ecoResStyle;
        while select styleGroupTrans
            where styleGroupTrans.styleGroup == this.RetailStyleGroupId
             join ecoResStyle
            where ecoResStyle.Name == styleGroupTrans.style
        {
            EcoResProductMasterStyle masterStyle = this.createMasterStyle(styleGroupTrans, ecoResStyle);

            this.createStyleTranslations(styleGroupTrans, masterStyle);

            if (_mustCreateProductVariants)
            {
                masterStyle.createVariantsFromDimensionValue(masterStyle.StyleProductMaster, masterStyle.StyleProductDimensionAttribute, masterStyle.Style);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createStyleTranslations</Name>
				<Source><![CDATA[
    private void createStyleTranslations(RetailStyleGroupTrans _styleGroupTrans, EcoResProductMasterStyle _masterStyle)
    {
        RetailStyleGroupTransTranslation retailStyleGroupTransTranslation;
        while select Name, Description, LanguageId from retailStyleGroupTransTranslation
            where retailStyleGroupTransTranslation.RetailStyleGroupTrans == _styleGroupTrans.RecId
        {
            EcoResGroupDimValTranslationsHelper::insertDimensionValueTranslation(
                retailStyleGroupTransTranslation.Name,
                retailStyleGroupTransTranslation.Description,
                retailStyleGroupTransTranslation.LanguageId,
                _masterStyle.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteStyleReferences</Name>
				<Source><![CDATA[
    private void deleteStyleReferences()
    {
        EcoResProductMasterStyle     ecoResProductMasterStyle;
        EcoResDistinctProductVariant ecoResDistinctProductVariant;
        delete_from ecoResDistinctProductVariant
            where ecoResDistinctProductVariant.ProductMaster == this.RecId;
        delete_from ecoResProductMasterStyle
            where ecoResProductMasterStyle.StyleProductMaster == this.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMasterStyle</Name>
				<Source><![CDATA[
    private EcoResProductMasterStyle createMasterStyle(RetailStyleGroupTrans _styleGroupTrans, EcoResStyle _ecoResStyle)
    {
        EcoResProductMasterStyle ecoResProductMasterStyle;
        RetailStyleGroupTrans::populateInventStyleProperties(ecoResProductMasterStyle, _ecoResStyle, this);
        _styleGroupTrans.populateStyleGroupProperties(ecoResProductMasterStyle);
        using (EcoResProductMasterSkipVariantCreationScope variantCreationscope = new EcoResProductMasterSkipVariantCreationScope())
        {
            ecoResProductMasterStyle.insert();
        }

        return ecoResProductMasterStyle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;

        ret = super();

        // Only PredefinedVariants variant configuraton technologies can be defined per product of type "Service"
        if (this.ProductType == EcoResProductType::Service && !this.isPredefinedVariants())
        {
            ret = checkFailed(strFmt("@SYS309240", this.VariantConfigurationTechnology));
        }

        ret = ret && this.validateProductVariantUnitConversion();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified record in the <c>EcoResProductMaster</c> table exists.
    /// </summary>
    /// <param name="_productMaster">
    /// The ID of the <c>EcoResProductMaster</c> record to find.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If the specified record is not found, an error message is displayed.
    /// </remarks>
    static public boolean exist(RefRecId _productMaster)
    {
        EcoResProduct   ecoResProduct;
        if (!_productMaster)
        {
            return false;
        }

        // Do the find on EcoResProduct as that should often find a record in the cache. This isn't the case if querying EcoResProductMaster.
        ecoResProduct = EcoResProduct::find(_productMaster);
        return ecoResProduct is EcoResProductMaster;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>EcoResProductMaster</c> table.
    /// </summary>
    /// <param name="_productMaster">
    ///    The ID of the <c>EcoResProductMaster</c> record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>EcoResProductMaster</c> table; otherwise, an empty record.
    /// </returns>
    static public EcoResProductMaster find(RefRecId _productMaster, boolean _forUpdate = false)
    {
        EcoResProductMaster ecoResProductMaster;

        if (_productMaster)
        {
            if (_forUpdate)
            {
                select firstonly forupdate ecoResProductMaster
                    where ecoResProductMaster.RecId == _productMaster;
            }
            else
            {
                ecoResProductMaster = EcoResProduct::find(_productMaster) as EcoResProductMaster; // Use this to benefit from caching of all product types
            }
        }
        return ecoResProductMaster;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductMasterFromCaller</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a record in the <c>EcoResProductMaster</c>.
    /// </summary>
    /// <param name="_args">
    /// An instance of the <c>Args</c> class.
    /// </param>
    /// <param name="_throwIfNotFound">
    /// Determines if an error should be thrown if no record was found; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>EcoResProductMaster</c> table.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// No arguments specified.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// A record in the <c>EcoResProductMaster</c> table related to the record passed through the arguments
    /// cannot be found.
    /// </exception>
    public static EcoResProductMaster getProductMasterFromCaller(Args _args, boolean _throwIfNotFound = true)
    {
        Common                          callerRecord;
        InventTable                     inventTableCaller;
        EcoResDistinctProductVariant    ecoResDistinctProductVariantCaller;

        if (!_args)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        callerRecord = _args.record();

        //coming from the Go to Main Table
        if (_args.lookupTable() == tableNum(EcoResDistinctProductVariant))
        {
            ecoResDistinctProductVariantCaller = EcoResDistinctProductVariant::find(any2int64(_args.lookupValue()));
            callerRecord = EcoResProductMaster::find(ecoResDistinctProductVariantCaller.ProductMaster);
        }
        if (callerRecord is InventDimCombination)
        {
            InventDimCombination localInventDimCombination = callerRecord;
            ecoResDistinctProductVariantCaller = EcoResDistinctProductVariant::find(localInventDimCombination.DistinctProductVariant);
            callerRecord = EcoResProductMaster::find(ecoResDistinctProductVariantCaller.ProductMaster);
        }

        //coming from EcoResProductVariantsPerCompany form opened by More... button in the EcoResProductVariantsPerCompany info part
        if (callerRecord is InventTable)
        {
            inventTableCaller   = callerRecord as InventTable;
            //Check if value of Product field is there as we may be coming from a form with OnlyFetchActive set to Yes for InventTable
            if (!inventTableCaller.Product)
            {
                inventTableCaller = InventTable::find(inventTableCaller.ItemId);
            }
            callerRecord = EcoResProductMaster::find(inventTableCaller.Product);
        }

        if (!(callerRecord is EcoResProductMaster) || !callerRecord.RecId)
        {
            if (_throwIfNotFound)
            {
                throw error("@SYS330206");
            }
        }

        return EcoResProductMaster::find(callerRecord.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    static public TxtNotExist txtNotExist()
    {
        return "@SYS133845";
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVariantDescriptions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates variant descriptions based on dimension values in all available languages.
    ///     The user is prompted if they want to overwrite manually entered descriptions.
    /// </summary>
    /// <param name="_productMaster">
    ///     The product master for which descriptions will be updated.
    /// </param>
    static public void updateVariantDescriptions(EcoResProductMasterRecId _productMaster)
    {
        Set languageIds = EcoResProductMaster::getSetOfLanguageIds(_productMaster);

        // Temporarily store the new desriptions in case the user decides to cancel the changes.
        List recordsToUpdate = new List(Types::Container);

        EcoResDistinctProductVariant    ecoResDistinctProductVariant;
        boolean yesToAll = false;

        // For all product variants
        while select RecId, ProductMaster, DisplayProductNumber from ecoResDistinctProductVariant
            where ecoResDistinctProductVariant.ProductMaster == _productMaster
        {
            // For all languages used by product dimension values
            SetEnumerator enumerator = languageIds.getEnumerator();
            while (enumerator.movenext())
            {
                EcoResProductTranslation currentVariantTranslation = EcoResProductTranslation::findByProductLanguage(ecoResDistinctProductVariant.RecId, enumerator.current(), true);
                EcoResDescription generatedDescription = EcoResDistinctProductVariant::productDescriptionBasedOnDimValues(ecoResDistinctProductVariant, enumerator.current());

                // Nothing to do if the generated description is already been used
                if (currentVariantTranslation.Description != generatedDescription)
                {
                    boolean toBeUpdated = false;

                    // Cases where the descriptions are changed without prompt
                    if (yesToAll || currentVariantTranslation.Description == "")
                    {
                        toBeUpdated = true;
                    }
                    // The user is prompted if they want to overwrite manually entered descriptions
                    else
                    {
                        str promptMessage = strFmt("@SCM:ProductVariantGenerateDescriptionOverwritePrompt", ecoResDistinctProductVariant.DisplayProductNumber, enumerator.current(), currentVariantTranslation.Description, generatedDescription);
                        DialogButton answer = Box::yesYesAllNoCancel(promptMessage, DialogButton::Cancel);

                        switch (answer)
                        {
                            case DialogButton::YesToAll:    // Apply changes and accept all future changes (Fall through)
                                yesToAll = true;

                            case DialogButton::Yes:    // Apply changes
                                toBeUpdated = true;
                                break;

                            case DialogButton::Cancel:  // Don't apply any of the variant description changes
                                return;

                            default:    // No (do nothing)
                                break;
                        }
                    }

                    // Add the current description information to the list of changes
                    if (toBeUpdated)
                    {
                        recordsToUpdate.addEnd([ecoResDistinctProductVariant.RecId, currentVariantTranslation.Name, generatedDescription, enumerator.current()]);
                    }
                }
            }
        }

        // Apply the changes approved by the user (including overwriting empty descriptions)
        ttsbegin;
        ListEnumerator enumeratorRecordsToUpdate = recordsToUpdate.getEnumerator();

        while (enumeratorRecordsToUpdate.moveNext())
        {
            container record = enumeratorRecordsToUpdate.current();
            EcoResProductTranslation::createOrUpdateTranslation(conPeek(record, 1), conPeek(record, 2), conPeek(record, 3), conPeek(record, 4));
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableGenerateVariantNames</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the product master satisfies the requirments to regenerate its variants' names.
    ///    These are, having name nomenclature enabled and configuration technology set to
    ///    predefined variants or dimension based.
    /// </summary>
    /// <returns>
    ///   True if check succeeds; otherwise false.
    /// </returns>
    [Hookable(false)]
    public boolean enableGenerateVariantNames()
    {
        return (this.isDimensionBased() || this.isPredefinedVariants())
            && this.enabledProductMasterNomenclature(EcoResNomenclatureRole::Name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSetOfLanguageIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Provides the languages that this product master is translated to.
    ///   Makes sure at least one language is present, to assure variant descriptions/names
    ///   also when no <c>EcoResProductMasterDimValueTranslations</c> exist for the product master.
    /// </summary>
    /// <returns>
    ///   A set of language IDs.
    /// </returns>
    [Hookable(false)]
    static public Set getSetOfLanguageIds(EcoResProductMasterRecId _productMaster)
    {
        Set languageIds = EcoResProductMasterDimValueTranslation::getSetOfLanguageIdsForProductMaster(_productMaster);

        if (languageIds.elements() == 0)
        {
            languageIds.add(SystemParameters::getSystemLanguageId());
        }

        return languageIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enabledProductMasterNomenclature</Name>
				<Source><![CDATA[
    private EcoResNomenclatureRecId enabledProductMasterNomenclature(EcoResNomenclatureRole _role)
    {
        return EcoResProductMasterProductVariantNomenclature::findByProductMaster(this.RecId, _role).ProductVariantNomenclature;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        var originalProductMaster = this.orig();

        super();

        this.applySelectedDimensionGroups(originalProductMaster);
    }

]]></Source>
			</Method>
			<Method>
				<Name>applySelectedDimensionGroups</Name>
				<Source><![CDATA[
    protected void applySelectedDimensionGroups(EcoResProductMaster _originalProductMaster = null)
    {
        boolean mustCreateProductVariants = this.mustCreateProductVariants();

        if (!_originalProductMaster && this.RetailSizeGroupId
            || _originalProductMaster.RetailSizeGroupId != this.RetailSizeGroupId)
        {
            this.applySizeGroup(mustCreateProductVariants);
        }

        if (!_originalProductMaster && this.RetailColorGroupId
            || _originalProductMaster.RetailColorGroupId != this.RetailColorGroupId)
        {
            this.applyColorGroup(mustCreateProductVariants);
        }

        if (!_originalProductMaster && this.RetailStyleGroupId
            || _originalProductMaster.RetailStyleGroupId != this.RetailStyleGroupId)
        {
            this.applyStyleGroup(mustCreateProductVariants);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        super();

        this.applySelectedDimensionGroups();
    }

]]></Source>
			</Method>
			<Method>
				<Name>IsDimGroupWarehouseEnabledOrNotSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Checks if the product has a warehouse enabled storage dimension group, or if the group is not set.
    /// </summary>
    /// <returns>
    ///   True if the product has a warehouse enabled storage dimension group, or if the group is not set; otherwise false.
    /// </returns>
    public boolean IsDimGroupWarehouseEnabledOrNotSet()
    {
        EcoResStorageDimensionGroupProduct  storageDimensionGroupProduct;
        boolean                             isDimGroupWarehouseEnabledOrNotSet = true;

        storageDimensionGroupProduct = EcoResStorageDimensionGroupProduct::findByProduct(this.RecId);

        if (storageDimensionGroupProduct)
        {
            isDimGroupWarehouseEnabledOrNotSet = EcoResStorageDimensionGroup::find(storageDimensionGroupProduct.StorageDimensionGroup).IsWarehouseWHSEnabled == NoYes::Yes;
        }

        return isDimGroupWarehouseEnabledOrNotSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEnableProductVariantUnitConv</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the current <c>EcoResProductMaster</c> has a valid configuration for supporting
    ///         variant-level unit of measure conversion.
    /// </summary>
    /// <returns>
    ///     true if the current record has a valid configuration; otherwise false.
    /// </returns>
    public boolean validateEnableProductVariantUnitConv()
    {
        boolean ret = true;

        if (this.IsProductVariantUnitConversionEnabled)
        {
            if (this.PdsCWProduct)
            {
                return checkFailed(strFmt("@SCM:EnabledCatchWeigthProductUOMConversionError", this.displayProductName()));
            }

            if (!EcoResProductUnitConverter::isProductUnitConversionPerVariantEnabled()
                && !this.IsDimGroupWarehouseEnabledOrNotSet())
            {
                return checkFailed(strFmt("@SYP5070004", this.displayProductName()));
            }

            if (this.RecId
                && !EcoResProductUnitConverter::isProductUnitConversionPerVariantEnabled()
                && UnitOfMeasureConversion::existsProductSpecificConversion(this.RecId))
            {
                ret = checkFailed("@SYP4986003");
            }
            else
            {
                InventTable inventTable;
                while select crosscompany inventTable
                    where inventTable.Product == this.RecId
                {
                    changeCompany(inventTable.dataAreaId)
                    {
                        if (!inventTable.validateProductVariantUnitConversion())
                        {
                            ret = false;
                            break;
                        }
                        else if (  InventTrans::openTransactionsExist(inventTable.ItemId)
                                || (WHSInventoryTransactionConfigurationProvider::isWarehouseInventoryTransactionStackEnabled() && WHSInventReserve::itemHasReservations(inventTable.ItemId)))
                        {
                            ret = checkFailed(strFmt("@SYP4986004", inventTable.ItemId, curext()));
                            break;
                        }
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProductVariantUnitConversion</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the current <c>EcoResProductMaster</c> has a valid configuration for supporting
    ///         variant-level unit of measure conversion.
    /// </summary>
    /// <returns>
    ///     true if the current record has a valid configuration; otherwise false.
    /// </returns>
    private boolean validateProductVariantUnitConversion()
    {
        InventTable                  inventTable;
        boolean                      ret = true;
        EcoResDistinctProductVariant productVariant;
        
        if (!this.orig().IsProductVariantUnitConversionEnabled
            && this.IsProductVariantUnitConversionEnabled)
        {
            ret = this.validateEnableProductVariantUnitConv();
        }
        else if (!this.IsProductVariantUnitConversionEnabled
            && this.orig().IsProductVariantUnitConversionEnabled)
        {
            while select RecId from productVariant
                where productVariant.ProductMaster == this.RecId
            {
                if (UnitOfMeasureConversion::existsProductSpecificConversion(productVariant.RecId))
                {
                    ret = checkFailed("@SYP4986007");
                    break;
                }
            }

            while select crosscompany ItemId from inventTable
                    where inventTable.Product == this.RecId
            {
                changeCompany(inventTable.dataAreaId)
                {
                    if (  InventTrans::openTransactionsExist(inventTable.ItemId)
                       || (WHSInventoryTransactionConfigurationProvider::isWarehouseInventoryTransactionStackEnabled() && WHSInventReserve::itemHasReservations(inventTable.ItemId)))
                    {
                        ret = checkFailed(strFmt("@SYP4986008", inventTable.ItemId, curext()));
                        break;
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>nomenclature</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the nomenclature applicable for the product master.
    /// </summary>
    /// <param name = "_role">The nomenclature role to filter on.</param>
    /// <returns>The applicable nomenclature.</returns>
    public EcoResProductVariantNomenclatureRecId nomenclature(EcoResNomenclatureRole _role)
    {
        EcoResProductVariantNomenclatureRecId nomenclature = EcoResProductMasterProductVariantNomenclature::findByProductMaster(this.RecId, _role).ProductVariantNomenclature;
        if (!nomenclature)
        {
            nomenclature = EcoResProductDimensionGroupProductVariantNomenclature::findByProductDimensionGroup(EcoResProductDimensionGroupProduct::findByProduct(this.RecId).ProductDimensionGroup, _role).ProductVariantNomenclature;
        }
        return nomenclature;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();
        if (EcoResProductUnitConverter::isProductUnitConversionPerVariantEnabled())
        {
            this.IsProductVariantUnitConversionEnabled = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LogisticsBasic</ConfigurationKey>
	<DeveloperDocumentation>@SYS133906</DeveloperDocumentation>
	<FormRef>EcoResProductDetails</FormRef>
	<Label>@SYS133905</Label>
	<ListPageRef>EcoResProductListPage</ListPageRef>
	<TableGroup>Main</TableGroup>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>Found</CacheLookup>
	<Extends>EcoResProduct</Extends>
	<Modules>ProductInformationManagement</Modules>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<SupportInheritance>Yes</SupportInheritance>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>EcoResDistinctProductVariant</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResDistinctProductVariant</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResProductMasterColor</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResProductMasterColor</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResProductMasterStyle</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResProductMasterStyle</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResProductMasterVersion</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResProductMasterVersion</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResProductMasterConfiguration</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResProductMasterConfiguration</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResProductMasterModelingPolicy</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResProductMasterModelingPolicy</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResProductMasterSize</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResProductMasterSize</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>PCProductModelVersion</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>PCProductModelVersion</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>RetailKit</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>RetailKit</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VariantConfigurationTechnology</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>General</Name>
			<Label>@SYS2952</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VariantConfigurationTechnology</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>RetailVariants</Name>
			<Label>@RET3153</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RetailSizeGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RetailColorGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RetailStyleGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RetailColorGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailColorGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RetailSizeGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailSizeGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RetailStyleGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailStyleGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>VariantConfigurationTechnology</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<Mandatory>Yes</Mandatory>
			<EnumType>EcoResVariantConfigurationTechnologyType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsProductVariantUnitConversionEnabled</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResProductVariantUnitConversionEnabled</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes />
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>EcoResProduct_2</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>EcoResProduct</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Specialization</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RetailColorGroupTable_3267</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>RetailColorGroupTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RetailColorGroupId</Name>
					<SourceEDT>RetailColorGroupId</SourceEDT>
					<Field>RetailColorGroupId</Field>
					<RelatedField>colorGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>groupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RetailSizeGroupTable_3267</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>RetailSizeGroupTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RetailSizeGroupId</Name>
					<SourceEDT>RetailSizeGroupId</SourceEDT>
					<Field>RetailSizeGroupId</Field>
					<RelatedField>sizeGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>GroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RetailStyleGroupTable_3267</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>RetailStyleGroupTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RetailStyleGroupId</Name>
					<SourceEDT>RetailStyleGroupId</SourceEDT>
					<Field>RetailStyleGroupId</Field>
					<RelatedField>styleGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>groupIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>