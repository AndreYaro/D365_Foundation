<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankAccountTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class BankAccountTable extends common
{

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>balanceCur</Name>
				<Source><![CDATA[
    public display AmountCur balanceCur(container _balances = conNull())
    {
        const int balanceCurPos = 1;
        container balances;

        if (_balances != conNull())
        {
            balances = _balances;
        }
        else
        {
            balances = this.balances();
        }

        return conPeek(balances, balanceCurPos);
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceMST</Name>
				<Source><![CDATA[
    public display AmountMST balanceMST(container _balances = conNull())
    {
        const int balanceMSTPos = 2;
        container balances;

        if (_balances != conNull())
        {
            balances = _balances;
        }
        else
        {
            balances = this.balances();
        }

        return conPeek(balances, balanceMSTPos);
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceReportingCurrency</Name>
				<Source><![CDATA[
    public display AmountMSTSecondary balanceReportingCurrency(container _balances = conNull())
    {
        const int balanceReportingCurrencyPos = 3;
        container balances;

        if (_balances != conNull())
        {
            balances = _balances;
        }
        else
        {
            balances = this.balances();
        }

        return conPeek(balances, balanceReportingCurrencyPos);
    }

]]></Source>
			</Method>
			<Method>
				<Name>balances</Name>
				<Source><![CDATA[
    public container balances()
    {
        BankAccountBalance bankAccountBalance = this.balancesAsOfDate();

        return [bankAccountBalance.parmAmountCurBalance(), bankAccountBalance.parmAmountMstBalance(), bankAccountBalance.parmReportingCurrencyBalance()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>balancesAsOfDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the balance for the current bank account for a given date.
    /// </summary>
    /// <param name = "_balanceAsOfDate">The date for which to calculate the bank account balance.</param>
    /// <returns>A new instance of the <c>BankAccountBalance</c> class that stores the balance values.</returns>
    internal BankAccountBalance balancesAsOfDate(TransDate _balanceAsOfDate = dateMax())
    {
        BankAccountBalanceCalculator bankAccountBalanceCalculator = BankAccountBalanceCalculator::newFromBankAccountTable(this);
        BankAccountBalance bankAccountBalance = bankAccountBalanceCalculator.calculate(_balanceAsOfDate);

        return bankAccountBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankAccountOpenedIn_RU</Name>
				<Source><![CDATA[
    public display BankAccountOpenedIn_RU bankAccountOpenedIn_RU()
    {
        return this.BankAccountMap::bankAccountOpenedIn_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankAccountValidation</Name>
				<Source><![CDATA[
    public Bank bankAccountValidation()
    {
        return this.BankAccountMap::bankAccountValidation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankCode_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the bank code.
    /// </summary>
    /// <returns>
    ///    Bank code.
    /// </returns>
    public display BankAccountNum_BR bankCode_BR()
    {
        return Bank_BR::parseBankCode(this.AccountNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankAccount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the account number of the bank.
    /// </summary>
    /// <returns>
    ///    Account number.
    /// </returns>
    public display BankAccountNum_BR bankAccount_BR()
    {
        return Bank_BR::parseAccount(this.AccountNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankAgency_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the agency number of the bank.
    /// </summary>
    /// <returns>
    ///    Agency number.
    /// </returns>
    public display BankAgency_BR bankAgency_BR()
    {
        return Bank_BR::parseAgency(this.AccountNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankDac_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the account control characters (DAC) of the bank.
    /// </summary>
    /// <returns>
    ///    Account control characters.
    /// </returns>
    public display BankDAC_BR bankDac_BR()
    {
        return Bank_BR::parseDAC(this.AccountNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankBIC_RU</Name>
				<Source><![CDATA[
    public display BankBIC_RU bankBIC_RU()
    {
        return this.BankAccountMap::bankBIC_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankIsBranch_RU</Name>
				<Source><![CDATA[
    public boolean bankIsBranch_RU()
    {
        return this.BankAccountMap::bankIsBranch_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankName_RU</Name>
				<Source><![CDATA[
    public display BankName_RU bankName_RU()
    {
        return this.BankAccountMap::bankName_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankShortAddressing_RU</Name>
				<Source><![CDATA[
    public BankShortAddressing_RU bankShortAddressing_RU()
    {
        return this.BankAccountMap::bankShortAddressing_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>baseBankName_RU</Name>
				<Source><![CDATA[
    public Description baseBankName_RU()
    {
        return this.BankAccountMap::baseBankName_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>baseBankShortAddressing_RU</Name>
				<Source><![CDATA[
    public BankShortAddressing_RU baseBankShortAddressing_RU()
    {
        return this.BankAccountMap::baseBankShortAddressing_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkActiveDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the date in the <c>ActiveFrom</c> field is after the date in the <c>ActiveTo</c>
    /// field.
    /// </summary>
    /// <returns>
    /// true if the date in the <c>ActiveFrom</c> field is before the date in the <c>ActiveTo</c> field;
    /// otherwise, false.
    /// </returns>
    boolean checkActiveDates()
    {
        boolean isValid = true;

        if (this.ActiveFrom != Global::utcDateTimeNull()
            && this.ActiveTo != Global::utcDateTimeNull()
            && this.ActiveFrom > this.ActiveTo)
        {
            isValid = checkFailed(strFmt("@SYS300571", "@SYS129005", "@SYS129004"));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBankNegInstExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a bill of exchange or promissory note exists.
    /// </summary>
    /// <returns>
    /// true if the <c>BankAccountHoldStatus</c> status has the <c>InactiveForAllTransaction</c>
    /// enumeration value and the bill of exchange or promissory note exists; otherwise, false.
    /// </returns>
    public boolean checkBankNegInstExist()
    {
        boolean isExist;

        if (this.BankAccountStatus == BankAccountHoldStatus::InactiveForAllTransactions)
        {
            if (BankBillOfExchangeTable::findNextFree(this.AccountID))
            {
                info(strFmt("@SYS300184", this.AccountID));
                isExist = true;
            }

            if (BankPromissoryNoteTable::findNextFree(this.AccountID))
            {
                info(strFmt("@SYS300183", this.AccountID));
                isExist = true;
            }
        }
        else
        {
            isExist = false;
        }

        return isExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCanEnableAdvancedReconciliation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the advanced reconciliation can be enabled.
    /// </summary>
    /// <returns>
    /// true if the advanced reconciliation can be enabled; otherwise, false.
    /// </returns>
    public boolean checkCanEnableAdvancedReconciliation()
    {
        boolean ret = this.existUnreconciledStatement();
        ret = ret && this.existUnreconciledBankTransInClosedPeriod();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCanDisableAdvancedReconciliation</Name>
				<Source><![CDATA[
    public boolean checkCanDisableAdvancedReconciliation()
    {
        boolean ret = this.existReconciledTransactions();
        ret = this.existPostedBankStatements() && ret;
        ret = ret && this.existOpenAdvancedReconciliationWorksheet();
        ret = ret && this.existBankStatements();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCurrency</Name>
				<Source><![CDATA[
    public boolean checkCurrency(CurrencyCode _currency)
    {
        boolean ret = true;
        
        if (this.CurrencyCode != _currency && this.BankMultiCurrency  == NoYes::No)
        {
            ret = checkFailed(strFmt("@SYS25211", _currency, this.AccountID));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDefault_LV</Name>
				<Source><![CDATA[
    private boolean checkDefault_LV()
    {
        BankAccountTable bankAccountTable;

        if (this.LvDefaultBank)
        {
            select firstonly RecId from bankAccountTable
                where bankAccountTable.CurrencyCode == this.CurrencyCode &&
                      bankAccountTable.LvDefaultBank == NoYes::Yes &&
                      bankAccountTable.RecId != this.RecId;
        }

        return bankAccountTable.RecId ? checkFailed("@GLS108523") : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIsActiveForAllTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>BankAccountHoldStatus</c> enumeration value is set to
    /// <c>InactiveForAllTransactions</c>.
    /// </summary>
    /// <returns>
    /// true if the <c>BankAccountHoldStatus</c> enumeration value is set to
    /// <c>ActiveForAllTransactions</c> or <c>InactiveForNewTransactions</c>; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Displays the warning message.
    /// </remarks>
    public boolean checkIsActiveForAllTransactions()
    {
        boolean isActive = true;

        if (this.BankAccountStatus == BankAccountHoldStatus::InactiveForAllTransactions)
        {
            isActive = BankAccountTable::isActiveForAllTransactions(this.AccountID, this.DataAreaId);
        }

        if (!isActive)
        {
            isActive = checkFailed(strFmt("@SYS300182", this.AccountID));
        }

        return isActive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the main account from the <c>LedgerDimension</c> class has been used on a
    /// different bank account.
    /// </summary>
    /// <returns>
    /// true if the main account from the <c>LedgerDimension</c> table is unique; otherwise, false.
    /// </returns>
    boolean checkLedgerDimension()
    {
        boolean isValid = true;

        if (this.LedgerDimension)
        {
            this.checkLedgerDimAndBridgingAccLedgerDimCouldNotBeSame();

            if (isValid)
            {
                MainAccountNum myMainAccount = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(this.LedgerDimension);

                if (myMainAccount)
                {
                    BankAccountTable bankAccountTable;
        
                    while select LedgerDimension, AccountID from bankAccountTable where bankAccountTable.RecId != this.RecId
                    {
                        if (bankAccountTable.LedgerDimension)
                        {
                            MainAccountNum mainAccount = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(bankAccountTable.LedgerDimension);
                            if (myMainAccount == mainAccount)
                            {
                                checkFailed(strFmt("@CashManagement:MainAccountUniquenessForBankAccounts", myMainAccount, bankAccountTable.AccountID));
                                break;
                            }
                        }
                    }
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countryRegionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the bank account postal address country region ID value.
    /// </summary>
    /// <returns>
    /// The bank account country region ID value.
    /// </returns>
    LogisticsAddressCountryRegionId countryRegionId()
    {
        return LogisticsLocationEntity::location2PostalAddress(this.Location).CountryRegionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dateLastReconciled</Name>
				<Source><![CDATA[
    display TransDate dateLastReconciled()
    {
        return (select
                maxof(ReconcileDate)
                from bankAccountStatement
                where bankAccountStatement.AccountId == this.AccountID).ReconcileDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        if (CustPrenote::existCompanyBankPrenotes(this.AccountID) || VendPrenote::existCompanyBankPrenotes(this.AccountID))
            warning(strFmt("@SYS128512",this.AccountID));

        // Check to see if the associated dimension attribute value has been used
        // in a way that would prevent deletion.
        if (!DimensionValidation::canDeleteEntityValue(this))
        {
            throw error(strFmt("@SYS134392", this.AccountID));
        }

        ttsbegin;

        // Update the associated dimension attribute value.
        DimensionAttributeValue::updateForEntityValueDelete(this);

        super();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableAdvancedBankReconciliation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Peforms operation after enabling the advanced bank reconciliation.
    /// </summary>
    private void enableAdvancedBankReconciliation()
    {
        ttsBegin;
        if (this.checkCanEnableAdvancedReconciliation())
        {
            BankAccountTable::createExistingBankDocForAdvancedRecon(this.AccountID);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existUnreconciledBankTransInClosedPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there are any existing not reconciled bank transactions in the closing period.
    /// </summary>
    /// <returns>
    /// true if there are any existing not reconciled bank transactions in the closing period; otherwise,
    /// false.
    /// </returns>
    private boolean existUnreconciledBankTransInClosedPeriod()
    {
        BankAccountTrans bankAccountTrans;
        FiscalCalendarPeriod fiscalCalendarPeriod;
        LedgerFiscalCalendarPeriod ledgerFiscalCalendarPeriod;
        LedgerPeriodModuleAccessControl ledgerPeriodModuleAccessControl;

        boolean ret = true;

        select firstonly RecId from bankAccountTrans
            where bankAccountTrans.AccountId == this.AccountID
                && bankAccountTrans.Reconciled == NoYes::No
            exists join fiscalCalendarPeriod
                where fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
                    && fiscalCalendarPeriod.StartDate <= bankAccountTrans.TransDate
                    && fiscalCalendarPeriod.EndDate >= bankAccountTrans.TransDate
            exists join ledgerFiscalCalendarPeriod
                where ledgerFiscalCalendarPeriod.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                    && ledgerFiscalCalendarPeriod.Ledger == Ledger::current()
                    && ledgerFiscalCalendarPeriod.Status != FiscalPeriodStatus::Open
            exists join ledgerPeriodModuleAccessControl
                where ledgerPeriodModuleAccessControl.LedgerFiscalCalendarPeriod  == ledgerFiscalCalendarPeriod.RecId
                     && ledgerPeriodModuleAccessControl.LedgerAccessLevel == ModulePeriodStat::All;

        if (bankAccountTrans.RecId)
        {
            ret = checkFailed("@GLS221676");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existUnreconciledStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there are any reconciled statements.
    /// </summary>
    /// <returns>
    /// true if there are any reconciled statements; otherwise, false.
    /// </returns>
    private boolean existUnreconciledStatement()
    {
        boolean ret = true;
        BankAccountStatement bankAccountStatement;

        select firstonly RecId from bankAccountStatement
            where bankAccountStatement.AccountId == this.AccountID
                && bankAccountStatement.ReconcileDate == dateNull();

        if (bankAccountStatement.RecId)
        {
            ret = checkFailed("@GLS221677");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existReconciledTransactions</Name>
				<Source><![CDATA[
    private boolean existReconciledTransactions()
    {
        boolean ret = true;
        BankReconciliationHeader bankReconciliationHeader;

        select firstonly RecId from bankReconciliationHeader
            where bankReconciliationHeader.AccountId == this.AccountID
            && bankReconciliationHeader.isReconciled == NoYes::Yes;

        if (bankReconciliationHeader.RecId
            || (!BankDisableAdvancedReconciliationValidationFlight::instance().isEnabled() && this.existReconciledBankDocumentTableViewResult()))
        {
            error(strFmt("@CashManagement:BankAccountExistAdvancedReconciliationInBusiness", this.AccountID));
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existPostedBankStatements</Name>
				<Source><![CDATA[
    private boolean existPostedBankStatements()
    {
        boolean ret = true;
        BankStmtISOAccountStatement bankStmtISOAccountStatement;

        select firstonly RecId from bankStmtISOAccountStatement
            where bankStmtISOAccountStatement.BankAccountTable == this.AccountID
                && bankStmtISOAccountStatement.Posted;

        if (!bankStmtISOAccountStatement.RecId)
        {
            BankStmtISOReportEntry bankStmtISOReportEntry;
            select firstonly RecId from bankStmtISOAccountStatement
                where bankStmtISOAccountStatement.BankAccountTable == this.AccountID
                exists join bankStmtISOReportEntry
                where bankStmtISOAccountStatement.RecId == bankStmtISOReportEntry.BankStmtISOAccountStatement
                    && bankStmtISOReportEntry.Voucher;
        }

        if (bankStmtISOAccountStatement.RecId)
        {
            error(strFmt("@CashManagement:BankAccountExistPostedStatementsInBusiness", this.AccountID));
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existReconciledBankDocumentTableViewResult</Name>
				<Source><![CDATA[
    private boolean existReconciledBankDocumentTableViewResult()
    {
        BankDocumentTableViewResult bankDocumentTableViewResult;
        BankStmtISOReportEntry bankStmtISOReportEntry;

        select count(RecId) from bankStmtISOReportEntry
            join bankDocumentTableViewResult
            where bankDocumentTableViewResult.AccountId == this.AccountID
            && bankDocumentTableViewResult.isReconciled == NoYes::Yes
                && bankDocumentTableViewResult.SourceRelationType == bankStmtISOReportEntry.TableId
                && bankDocumentTableViewResult.SourceRecId == bankStmtISOReportEntry.RecId
                && bankStmtISOReportEntry.isNewBankDocument == NoYes::Yes;

        select count(RecId) from bankDocumentTableViewResult
            where bankDocumentTableViewResult.AccountId == this.AccountID
                && bankDocumentTableViewResult.isReconciled == NoYes::Yes;

        return bankDocumentTableViewResult.RecId != 0 && bankDocumentTableViewResult.RecId != bankStmtISOReportEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existOpenAdvancedReconciliationWorksheet</Name>
				<Source><![CDATA[
    private boolean existOpenAdvancedReconciliationWorksheet()
    {
        boolean ret = true;
        BankReconciliationHeader bankReconciliationHeader;

        select firstonly RecId from bankReconciliationHeader
            where bankReconciliationHeader.AccountId == this.AccountID
                && bankReconciliationHeader.isReconciled == 0;

        if (bankReconciliationHeader.RecId)
        {
            SetPrefix(strFmt("@CashManagement:BankAccountExistOpenAdvancedReconciliationWorksheet", this.AccountID));
            error("@CashManagement:BankAccountExistOpenAdvancedReconciliationWorksheetStep1");
            error("@CashManagement:BankAccountExistOpenAdvancedReconciliationWorksheetStep2");
            error("@CashManagement:BankAccountExistOpenAdvancedReconciliationWorksheetStep3");
            error("@CashManagement:BankAccountExistOpenAdvancedReconciliationWorksheetStep4");
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existBankStatements</Name>
				<Source><![CDATA[
    private boolean existBankStatements()
    {
        boolean ret = true;
        BankStmtISOAccountStatement bankStmtISOAccountStatement;

        select firstonly RecId from bankStmtISOAccountStatement
            where bankStmtISOAccountStatement.BankAccountTable == this.AccountID;

        if (bankStmtISOAccountStatement.RecId)
        {
            SetPrefix(strFmt("@CashManagement:BankAccountExistStatements", this.AccountID));
            error("@CashManagement:BankAccountExistStatementsStep1");
            error("@CashManagement:BankAccountExistStatementsStep2");
            error("@CashManagement:BankAccountExistStatementsStep3");
            error("@CashManagement:BankAccountExistStatementsStep4");
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBalanceByDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the balance on the cutoff date.
    /// </summary>
    /// <param name="_cutoffDate">
    /// The cutoff date.
    /// </param>
    /// <returns>
    /// The balance.
    /// </returns>
    public AmountCur getBalanceByDate(TransDate _cutoffDate)
    {
        BankAccountTrans bankAccountTrans;

        select sum(AmountCur), sum(AmountCorrect) from bankAccountTrans
            where bankAccountTrans.AccountId == this.AccountID
                && bankAccountTrans.CurrencyCode == this.CurrencyCode
                && bankAccountTrans.TransDate <= _cutoffDate;

        return bankAccountTrans.AmountCur + bankAccountTrans.AmountCorrect;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankAccountBalanceCur</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the bank account balance in currency of the bank account.
    /// </summary>
    /// <returns>
    ///    The bank account balance.
    /// </returns>
    [SysObsolete('This method is no longer in use. Please use the balanceCur() method moving forward.', true, 30\6\2020)]
    display AmountCur getBankAccountBalanceCur()
    {
        AmountCur balanceCur;
        
        if (hasFieldAccess(tableNum(BankAccountTrans), fieldNum(BankAccountTrans, AmountCur), AccessType::View) &&
           hasFieldAccess(tableNum(BankAccountTrans), fieldNum(BankAccountTrans, AmountCorrect), AccessType::View))
        {
            BankAccountTrans bankAccountTrans;

            bankAccountTrans.recordLevelSecurity(true);

            // Group by currencyCode so sum is will perform better
            while select sum(AmountCur), sum(AmountCorrect)
                from bankAccountTrans
                group by CurrencyCode
                where bankAccountTrans.AccountId == this.AccountID
            {
                balanceCur = balanceCur + bankAccountTrans.AmountCur + bankAccountTrans.AmountCorrect;
            }
        }

        return balanceCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankAccountBalanceMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns bank account balance in the currency of the company.
    /// </summary>
    /// <returns>
    ///    The bank account balance.
    /// </returns>
    [SysObsolete('This method is no longer in use. Please use the balancesMST() method moving forward.', true, 30\6\2020)]
    display AmountMST getBankAccountBalanceMST()
    {
        AmountMST balanceMST;
        
        if (hasFieldAccess(tableNum(BankAccountTrans), fieldNum(BankAccountTrans, AmountCur), AccessType::View) &&
            hasFieldAccess(tableNum(BankAccountTrans), fieldNum(BankAccountTrans, AmountCorrect), AccessType::View))
        {
            AmountCur balanceCur;

            BankAccountTrans bankAccountTrans;
            bankAccountTrans.recordLevelSecurity(true);

            CurrencyCode companyCurrencyCode = CompanyInfoHelper::standardCurrency();

            // Group by currencyCode so sum is will perform better
            while select sum(AmountCur), sum(AmountCorrect) from bankAccountTrans
                group by CurrencyCode
                where bankAccountTrans.AccountId == this.AccountID
            {
                balanceCur = bankAccountTrans.AmountCur + bankAccountTrans.AmountCorrect;

                if (bankAccountTrans.CurrencyCode != companyCurrencyCode)
                {
                    balanceMST += CurrencyExchangeHelper::mstAmount(balanceCur, bankAccountTrans.CurrencyCode);
                }
                else
                {
                    balanceMST += balanceCur;
                }
            }
        }

        return balanceMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromBankGroup</Name>
				<Source><![CDATA[
    public void initFromBankGroup(BankGroup _bankGroup)
    {
        // <GJP>
        #isoCountryRegionCodes
        // </GJP>

        this.BankAccountMap::initFromBankGroup(_bankGroup);

        if (_bankGroup.CurrencyCode != "" && this.allowEditCurrency())
        {
            this.CurrencyCode = _bankGroup.CurrencyCode;
        }

        this.BankSuffix = _bankGroup.BankSuffix;
        this.BankTransferCode = _bankGroup.BankTransferCode;
        this.BankContractAccount = _bankGroup.BankContractAccount;
        this.CompanyPaymId = _bankGroup.CompanyPaymId;
        this.BankStatementFormat = _bankGroup.BankStatementFormat;
        this.BankStatementName = _bankGroup.BankStatementName;

        // <GJP>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP]))
        {
            this.AccountNameKana_JP = _bankGroup.NameKana_JP;
        }
        // </GJP>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    void initValue()
    {
        // <GJP>
        #isoCountryRegionCodes
        // </GJP>

        super();

        this.CurrencyCode = CompanyInfoHelper::standardCurrency();

        this.NsfFeeMarkupGroupModule = MarkupModuleType::Cust;

        // <GJP>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP]))
        {
            this.TransType_JP = BankTransType_JP::OrdinarySavings;
        }
        // </GJP>

        if (BankAccountTable::checkBankLifecycleManagementWorkflowEnabled())
        {
            this.BankAccountStatus = BankAccountHoldStatus::InactiveForAllTransactions;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts <c>BankAccountTable</c> record.
    /// </summary>
    public void insert()
    {
        super();

        if (this.BankReconciliationEnabled)
        {
            this.enableAdvancedBankReconciliation();

            if (this.BankReconciliationStmtAsPaymConfirm)
            {
                this.updateBankStatementAsPaymConfirm(this.BankReconciliationStmtAsPaymConfirm);
            }
        }

        DimensionDefaultFacade::copyDimensionValueToDefaultDimensionField(this, fieldNum(BankAccountTable, AccountID), this, fieldNum(BankAccountTable, DefaultDimension));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBankLifecycleManagementWorkflowEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if bank life-cycle management workflow is enabled. 
    /// </summary>
    /// <returns>true if bank life-cycle management workflow is enabled; otherwise, false.</returns>
    internal static boolean checkBankLifecycleManagementWorkflowEnabled()
    {
        return FeatureStateProvider::isFeatureEnabled(BankAccountLifecycleManagementFeature::instance())
            && MainDataChangeSetup::isApprovalOnCreationEnabled(tableNum(BankAccountTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankReconciliationEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the bank reconciliation feature is enabled.
    /// </summary>
    /// <returns>
    /// true if the bank reconciliation is enabled; otherwise, false.
    /// </returns>
    public boolean isBankReconciliationEnabled()
    {
        return this.BankReconciliationEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankStatementUsedAsPaymentConfirmation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the function of bank statement used as payment confirmation is enabled.
    /// </summary>
    /// <returns>
    ///     True if the function is enabled; otherwise, false.
    /// </returns>
    public boolean isBankStatementUsedAsPaymentConfirmation()
    {
        return this.BankReconciliationStmtAsPaymConfirm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMatchAutoAfterImport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to match automatically after a bank statement is imported.
    /// </summary>
    /// <returns>
    /// true if you must to match automatically after the bank statement is imported; otherwise, false.
    /// </returns>
    public BankReconciliationMatchAutoAfterImport isMatchAutoAfterImport()
    {
        return this.isBankReconciliationEnabled() && this.BankReconMatchAutoAfterImport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPTTBankAccount</Name>
				<Source><![CDATA[
    public boolean isPTTBankAccount()
    {
        return (this.RegistrationNum == '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastCreatedNegInst</Name>
				<Source><![CDATA[
    public BankNegInstNum lastCreatedNegInst(BankNegInst _negInst)
    {
        BankNegInstNum negInstNum;

        switch (_negInst)
        {
            case BankNegInst::Check :
                negInstNum = BankChequeTable::findLastChequeNum(this.AccountID);
                break;

            case BankNegInst::BillOfExchange :
                negInstNum = BankBillOfExchangeTable::findLastBillOfExchangeNum(this.AccountID);
                break;

            case BankNegInst::PromissoryNote :
                negInstNum = BankPromissoryNoteTable::findLastPromissoryNum(this.AccountID);
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return negInstNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtension</Name>
				<Source><![CDATA[
    public TableExtension getExtension()
    {
        return SysTableExtension::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultingDependencies</Name>
				<Source><![CDATA[
    public container getDefaultingDependencies()
    {
        container bankMapDependencies = this.BankAccountMap::bankAccountMappingDefaultingDependencies();

        return bankMapDependencies;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    public void defaultField(FieldId _fieldId)
    {
        super(_fieldId);

        this.BankAccountMap::defaultFieldOnMap(_fieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);

        this.BankAccountMap::modifiedField(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(BankAccountTable, BankPositivePayFormatName) :
                if (this.BankPositivePayFormatName != '')
                {
                    if (this.orig().BankPositivePayFormatName == '')
                    {
                        this.BankPositivePayStartDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    }
                }
                else
                {
                    this.BankPositivePayStartDate = dateNull();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postalAddress</Name>
				<Source><![CDATA[
    LogisticsPostalAddress postalAddress()
    {
        return LogisticsLocationEntity::location2PostalAddress(this.Location);
    }

]]></Source>
			</Method>
			<Method>
				<Name>remittedAmount</Name>
				<Source><![CDATA[
    display Amount remittedAmount()
    {
        return this.remittedAmountMST(this.RemitCollectionAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>remittedAmountMST</Name>
				<Source><![CDATA[
    public AmountMST remittedAmountMST(AmountMST _remainAmountMSTLocal)
    {
        AmountMST remittedAmountMST;
        if (this.AccountID)
        {
            if (!this.DiscCreditMaxMST)
            {
                remittedAmountMST = maxInt() - _remainAmountMSTLocal;
            }
            else
            {
                remittedAmountMST = this.DiscCreditMaxMST - _remainAmountMSTLocal;
            }
        }
        return remittedAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>renamePrimaryKey</Name>
				<Source><![CDATA[
    public void renamePrimaryKey()
    {
        DimensionValueRenameV2 rename = DimensionValueRenameV2::construct(this, this.orig());
        rename.syncRenamedValuePreSuper();

        super();

        rename.syncRenamedValuePostSuper();
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>BankAccountTable</c> record.
    /// </summary>
    public void update()
    {
        BankAccountTable bankAccountTableOrig = this.orig();

        super();

        if (this.BankReconciliationEnabled && !bankAccountTableOrig.BankReconciliationEnabled)
        {
            this.enableAdvancedBankReconciliation();
        }
        else if (!this.BankReconciliationEnabled && bankAccountTableOrig.BankReconciliationEnabled)
        {
            BankAccountTable::deleteExistingBankDocForAdvancedRecon(this.AccountID);
        }

        if (this.BankReconciliationStmtAsPaymConfirm != bankAccountTableOrig.BankReconciliationStmtAsPaymConfirm)
        {
            this.updateBankStatementAsPaymConfirm(this.BankReconciliationStmtAsPaymConfirm);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankStatementAsPaymConfirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs operation after turnning on or turnning off the function of using bank statement as payment confirmation.
    /// </summary>
    /// <param name="_enabled">
    /// A boolean value indicating whether to enable the function.
    /// </param>
    private void updateBankStatementAsPaymConfirm(BankReconciliationStmtAsPaymConfirm _enabled)
    {
        if (this.isBankReconciliationEnabled())
        {
            ttsBegin;
            BankAccountTable::updateExistingBankDocForPaymentSent(this.AccountID, _enabled);
            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBankDocumentWhenInActiveBank</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the bank document agreement status to make sure that if the bank account is closed, the
    /// related bank document agreement is not still open.
    /// </summary>
    /// <param name="_status">
    /// The new bank account status.
    /// </param>
    /// <param name="_validFromDateTime">
    /// The starting date of the new active period of the bank account.
    /// </param>
    /// <param name="_validToDateTime">
    /// The ending date of the new active period of the bank account.
    /// </param>
    /// <returns>
    /// true if there is no issue;otherwise, false.
    /// </returns>
    private boolean validateBankDocumentWhenInActiveBank(
        BankAccountHoldStatus _status,
        ValidFromDateTime _validFromDateTime,
        ValidToDateTime _validToDateTime)
    {
        boolean ret = !BankDocumentFacilityAgreement::checkImpactedAgreementsByBankInActived(
            this.AccountID,
            _status,
            _validFromDateTime,
            _validToDateTime);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    boolean validateField(FieldId _fieldId)
    {
        LedgerDimensionDefaultAccount ledgerDimension;
        
        #isoCountryRegionCodes
        
        boolean ret = super(_fieldId);

        if (ret)
        {
            switch (_fieldId)
            {
                case fieldNum(BankAccountTable, CustomerPaymentFeeLedgerDimension),
                     fieldNum(BankAccountTable, RemittanceCollectionLedgerDimension),
                     fieldNum(BankAccountTable, RemittanceDiscountLedgerDimension),
                     fieldNum(BankAccountTable, InvoiceRemittanceLedgerDimension) :
                    ledgerDimension = this.(_fieldId);
                    ret = MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).MainAccountId);
                    break;

                case fieldNum(BankAccountTable, ActiveFrom),
                     fieldNum(BankAccountTable, ActiveTo):
                    ret = this.checkActiveDates();
                    break;

                case fieldNum(BankAccountTable, LedgerDimension) :
                    ret = this.checkLedgerDimension();
                    if (ret)
                    {
                        ret = MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).MainAccountId);
                    }
                    break;

                case fieldNum(BankAccountTable, AccountNum) :
                    ret = this.BankAccountMap::bankAccountValidation().checkBankAccountNum(this.AccountNum);

                    // If an IBAN has been specified for this record, validate that the new bank account number
                    // matches the account number found in the IBAN.
                    if (ret && this.IBAN)
                    {
                        BankIBANAccountValidator bankIBANValidator = BankIBANAccountValidator::construct(this.IBAN);
                        bankIBANValidator.parmRegistrationNum(this.RegistrationNum);
                        bankIBANValidator.validateBankIBANMatchesAccountNumber(this.AccountNum);
                    }

                    break;

                case fieldNum(BankAccountTable, IBAN) :
                    if (Bank::checkBankIBAN(this.IBAN, this.AccountID))
                    {
                        this.IBAN = strUpr(this.IBAN);

                        // If the IBAN has passed Mod97 validation, run further validations to check that
                        // the IBAN both references and adheres to an existing country account structure
                        BankIBANAccountValidator bankIBANValidator = BankIBANAccountValidator::construct(this.IBAN);
                        bankIBANValidator.parmRegistrationNum(this.RegistrationNum);
                        bankIBANValidator.validateBankIBANFollowsCountryStructure(this.AccountNum);

                        ret = true;
                    }
                    else
                    {
                        ret = false;
                    }
                    break;

                case fieldNum(BankAccountTable, RegistrationNum) :
                    ret = this.BankAccountMap::bankAccountValidation().checkBankRegNum(this.RegistrationNum, this.BankCodeType);

                    // If an IBAN has been specified for this record, validate that the new bank routing number
                    // matches the routing number found in the IBAN.
                    if (ret && this.IBAN)
                    {
                        BankIBANAccountValidator bankIBANValidator = BankIBANAccountValidator::construct(this.IBAN);
                        bankIBANValidator.parmRegistrationNum(this.RegistrationNum);
                        bankIBANValidator.validateBankIBANMatchesRoutingNumber(this.RegistrationNum);
                    }
                    break;

                case fieldNum(BankAccountTable, OverDraftLimit) :
                    if (this.OverDraftLimit > 0)
                    {
                        ret = checkFailed("@SYS313990");
                    }
                    break;

                case fieldNum(BankAccountTable, Rfc_MX) :
                    TaxRegistrationValidator_MX taxRegistrationValidator = TaxRegistrationValidator_MX::construct(this);
                    CompanyType_MX companyType = LogisticsAddressCountryRegion::find(this.postalAddress().CountryRegionId).ISOcode == #isoMX
                        ? CompanyType_MX::LegalEntity
                        : CompanyType_MX::ForeignCompany;

                    ret = taxRegistrationValidator.validateRFC(this.Rfc_MX, companyType);

                    break;
                // <GEERU>
                case fieldNum(BankAccountTable, BankGroupId) :
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                    {
                        BankGroup bankGroup = BankGroup::find(this.orig().BankGroupId);
                        ret = ret && bankGroup.checkVendAccountNum_RU(bankGroup.VendAccountNum_RU);
                    }
                    break;
                // </GEERU>
                // <GEEU>
                case fieldNum(BankAccountTable, LvDefaultBank) :
                    ret = this.checkDefault_LV();
                    break;
                // </GEEU>
                case fieldNum(BankAccountTable, BankStatementName) :
                case fieldNum(BankAccountTable, BankStatementFormat) :
                case fieldNum(BankAccountTable, BankReconciliationMatchRuleSet) :
                case fieldNum(BankAccountTable, BankReconMatchAutoAfterImport)  :
                    if (this.orig().(_fieldId) != this.(_fieldId) && !this.BankReconciliationEnabled)
                    {
                        ret = checkFailed(strFmt("@GLS221348", this.AccountID, "@GLS221350"));
                    }
                    break;

                case fieldNum(BankAccountTable, BankReconBridgedAutoClearing):
                    BankReconciliationHeader bankReconciliationHeader;
                    select firstonly RecId from bankReconciliationHeader
                        where bankReconciliationHeader.AccountId == this.AccountID
                            && bankReconciliationHeader.IsReconciled == 0;
                    if (bankReconciliationHeader.RecId)
                    {
                        ret = checkFailed(strFmt("@Bank:BankAccClearBridgedTransactionsDuringBankReconValidation", this.AccountID));
                    }
                    break;

                case fieldNum(BankAccountTable, BridgingAccountLedgerDimension):
                    ret = this.valdiateBridgingAccountLedgerDimension();
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerDimAndBridgingAccLedgerDimCouldNotBeSame</Name>
				<Source><![CDATA[
    private void checkLedgerDimAndBridgingAccLedgerDimCouldNotBeSame()
    {
        // Throw error if bridging account is same as current bank main account
        if (this.BridgingAccountLedgerDimension && this.BridgingAccountLedgerDimension == this.LedgerDimension)
        {
            throw Error("@Bank:BankBridgingAccSameAsMainAccError");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>valdiateBridgingAccountLedgerDimension</Name>
				<Source><![CDATA[
    private boolean valdiateBridgingAccountLedgerDimension()
    {
        BankAccountTable bankAccountTable;
        this.checkLedgerDimAndBridgingAccLedgerDimCouldNotBeSame();

        if (this.BridgingAccountLedgerDimension)
        {
            // Throw warning if bridging account is same across different bank accounts
            select firstonly AccountID, RecId from bankAccountTable
                where bankAccountTable.BridgingAccountLedgerDimension == this.BridgingAccountLedgerDimension
                    && bankAccountTable.RecId != this.RecId;

            MainAccountNum bridgingAccount = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(this.BridgingAccountLedgerDimension);

            if (bankAccountTable.RecId)
            {
                warning(strFmt("@Bank:BankBridgingAccSameWithOtherBankBridgingAccWarning", bridgingAccount, bankAccountTable.AccountID));
            }

            // Throw warning is bridging account is same as other bank main accounts
            select firstonly AccountID, RecId from bankAccountTable where bankAccountTable.LedgerDimension == this.BridgingAccountLedgerDimension;

            if (bankAccountTable.RecId)
            {
                warning(strFmt("@Bank:BankBridgingAccSameWithOtherBankMainAccWarning", bridgingAccount, bankAccountTable.AccountID));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the current bank record before it is written to the database.
    /// </summary>
    /// <returns>
    ///    true if the bank record is valid; otherwise, false
    /// </returns>
    public boolean validateWrite()
    {
        Bank bank = new Bank();
        
        #isoCountryRegionCodes

        boolean ok = super();

        if (ok)
        {
            ok = this.BankAccountMap::validateWrite();
        }

        if (ok)
        {
            ok = bank.checkBankContractAccount(this);
        }

        if (ok)
        {
            ok = bank.checkGiroContractAccount(this);
        }

        if (SysCountryRegionCode::isLocationInCountryRegion(this.Location, [#isoFI])
            && this.IncludeBankBarCode_FI == NoYes::Yes)
        {
            ok = Bank_FI::isBankBarCodeAllowed(this.AccountID);
        }

        if (this.PrenoteResponseDays < 0 || this.PrenoteResponseDays > 99)
        {
            ok = checkFailed(strFmt("@SYS127696","@SYS128503",'0','99'));
        }

        if (ok && BankLCImportFeatureChecker::checkBankLCImportEnabled())
        {
            ok = this.validateBankDocumentWhenInActiveBank(this.BankAccountStatus, this.ActiveFrom, this.ActiveTo);
        }

        if (this.IsBankPrenote == NoYes::Yes && this.PrenoteResponseDays == 0)
        {
            warning(strFmt("@SYS128513", fieldPName(BankAccountTable,PrenoteResponseDays)));
        }

        if (SysCountryRegionCode::isLocationInCountryRegion(this.Location, [#isoMX]))
        {
            TaxRegistrationValidator_MX taxRegistrationValidator = TaxRegistrationValidator_MX::construct(this);
            ok = taxRegistrationValidator.validateBankAccountTaxRegistration() && ok;
        }

        // <GEEU>
        ok = ok && this.checkDefault_LV();
        // </GEEU>

        if (ok)
        {
            if (!this.BankReconciliationEnabled && this.orig().BankReconciliationEnabled)
            {
                ok = this.checkCanDisableAdvancedReconciliation();
            }
            else if (this.BankReconciliationEnabled && !this.orig().BankReconciliationEnabled)
            {
                ok = this.checkCanEnableAdvancedReconciliation();
            }
        }

        if (ok)
        {
            if (this.BankReconciliationStmtAsPaymConfirm != this.orig().BankReconciliationStmtAsPaymConfirm)
            {
                ok = this.isBankReconciliationEnabled();
            }
        }

        if (ok && this.Location && this.BankCIN && !SysCountryRegionCode::isLocationInCountryRegion(this.Location, [#isoIT]))
        {
            ok = checkFailed("@CashManagement_Localization:CINEnabledOnlyInItalianAddress");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendAccount_RU</Name>
				<Source><![CDATA[
    public VendAccount vendAccount_RU()
    {
        return BankGroup::find(this.BankGroupId).VendAccountNum_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNum</Name>
				<Source><![CDATA[
    public static BankAccount accountNum(CompanyBankAccountId _accountID)
    {
        return (select bankAccountTable where bankAccountTable.AccountID == _accountID).AccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDefaultGiroBank_W</Name>
				<Source><![CDATA[
    static void checkDefaultGiroBank_W(CurrencyCode currencyCode = CompanyInfoHelper::standardCurrency())
    {
        #isoCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL]) &&
            BankParameters::find().GiroAccountValidationEnabled_W &&
            !BankAccountTable::findDefault_LV(currencyCode).AccountID)
        {
            warning(strFmt("@GLS112540", currencyCode));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    public static boolean checkExist(CompanyBankAccountId _companyBankAccountId)
    {
        boolean ret = true;

        if (!BankAccountTable::exist(_companyBankAccountId))
        {
            ret = checkFailed(strFmt(BankAccountTable::txtNotExist(), _companyBankAccountId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIsActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified bank account is active.
    /// </summary>
    /// <param name="_bankAccount">
    /// The company bank account for which to check the status.
    /// </param>
    /// <param name="_comparisonDate">
    /// The transaction date.
    /// </param>
    /// <param name="_company">
    /// The company for which the transaction is performed.
    /// </param>
    /// <returns>
    /// true if the bank account is active; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Dates in the <c>ActiveFrom</c> and the <c>ActiveTo</c> fields are inclusive.
    /// </remarks>
    public static boolean checkIsActive(
        CompanyBankAccount _bankAccount,
        TransDate _comparisonDate = DateTimeUtil::date(DateTimeUtil::utcNow()),
        CompanyId _company = curext())
    {
        return BankAccountTableLookup::checkIsActive(_bankAccount, _comparisonDate, _company);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIsAdvancedBankReconEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether a specified bank account is an enabled advanced bank reconciliation.
    /// </summary>
    /// <param name="_companyBankAccountId">
    /// The specified bank account.
    /// </param>
    /// <returns>
    /// true if the advanced bank reconciliation is enabled; otherwise, false.
    /// </returns>
    public static boolean checkIsAdvancedBankReconEnabled(CompanyBankAccountId _companyBankAccountId)
    {
        boolean ret = true;

        if (_companyBankAccountId)
        {
            if (!BankAccountTable::isAdvancedBankReconciliationEnabled(_companyBankAccountId))
            {
                ret = checkFailed(strFmt("@GLS221348", _companyBankAccountId, "@GLS221350"));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExistingBankDocForAdvancedRecon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the existing bank documents when an advanced bank reconciliation is enabled.
    /// </summary>
    /// <param name="_accountId">
    /// A bank account ID.
    /// </param>
    private static void createExistingBankDocForAdvancedRecon(CompanyBankAccountId _accountId)
    {
        #Macrolib.AviFiles
        const int64 TotalTypes = 6;
        const str GeneratingText = "@GLS221780";

        BankAccountTrans bankAccountTrans;
        SysOperationProgress progress = SysOperationProgress::newGeneral(#AviUpdate, "@GLS221675", TotalTypes);

        ttsbegin;
        BankChequeTable bankChequeTable;
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTable ledgerJournalTable;
        // Generate bank document for posted check.
        while select bankChequeTable
            where bankChequeTable.AccountID == _accountId
                && (bankChequeTable.ChequeStatus == ChequeStatus::Payment
                || bankChequeTable.ChequeStatus == ChequeStatus::Cancelled
                || bankChequeTable.ChequeStatus == ChequeStatus::CancelPending)
            exists join bankAccountTrans
                where bankAccountTrans.SourceTableId == tablenum(BankChequeTable)
                    && bankAccountTrans.SourceRecId == bankChequeTable.RecId
                    && bankAccountTrans.Reconciled == NoYes::No
        {
            progress.setText(strFmt(GeneratingText, enum2str(BankDocumentBookType::Cheque), bankChequeTable.ChequeNum));
            if (bankChequeTable.ChequeStatus == ChequeStatus::Payment)
            {
                BankDocumentProcessor::submitBankDocumentTable(bankChequeTable);
            }
            else
            {
                BankDocumentProcessor::submitBankDocumentTable(bankChequeTable, BankDocumentStatusChangeType::Cancel);
            }
        }

        // Generate bank document for not posted check.
        while select bankChequeTable
            where bankChequeTable.AccountID == _accountId
                && bankChequeTable.ChequeStatus == ChequeStatus::Payment
                && bankChequeTable.SourceTableId == tablenum(LedgerJournalTrans)
            exists join ledgerJournalTrans
                where bankChequeTable.SourceRecId == LedgerJournalTrans.RecId
            exists join ledgerJournalTable
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                    && ledgerJournalTable.Posted == NoYes::No
        {
            progress.setText(strFmt(GeneratingText, enum2str(BankDocumentBookType::Cheque), bankChequeTable.ChequeNum));
            BankDocumentProcessor::submitBankDocumentTable(bankChequeTable);
        }

        BankDepositDocument bankDepositDocument;
        // Generate bank document for deposit slip table.
        progress.incCount();
        while select bankDepositDocument
            where bankDepositDocument.AccountId == _accountId
            exists join bankAccountTrans
                where bankAccountTrans.SourceTableId == tablenum(BankDepositDocument)
                    && bankAccountTrans.SourceRecId == bankDepositDocument.RecId
                    && bankAccountTrans.Reconciled == NoYes::No
        {
            progress.setText(strFmt(GeneratingText, enum2str(BankDocumentBookType::DepositSlip), bankDepositDocument.DepositNum));
            BankDocumentProcessor::submitBankDocumentTable(bankDepositDocument);
        }

        BankDeposit bankDeposit;
        // Generate bank document for deposit slip cancel.
        progress.incCount();
        while select bankDeposit
            where bankDeposit.AccountId == _accountId
                && bankDeposit.Canceled == NoYes::Yes
            exists join bankAccountTrans
                where bankAccountTrans.SourceTableId == tablenum(BankDeposit)
                    && bankAccountTrans.SourceRecId == bankDeposit.RecId
                    && bankAccountTrans.Reconciled == NoYes::No
        {
            progress.setText(strFmt(GeneratingText, enum2str(BankDocumentBookType::DepositSlipCancel), bankDeposit.DepositNum));
            BankDocumentProcessor::submitBankDocumentTable(bankDeposit);
        }
        // Generate bank document for pending deposit slip cancel.
        progress.incCount();
        while select bankDeposit
            where bankDeposit.AccountId == _accountId
                && bankDeposit.CancelPending == NoYes::Yes
        {
            progress.setText(strFmt(GeneratingText, enum2str(BankDocumentBookType::DepositSlipCancel), bankDeposit.DepositNum));
            BankDocumentProcessor::submitBankDocumentTable(bankDeposit);
        }

        BankTransSummarizationDocument bankTransSummarizationDocument;
        // Generate bank document for summarized bank transactions.
        progress.incCount();
        while select bankTransSummarizationDocument
            where bankTransSummarizationDocument.AccountId == _accountId
            exists join bankAccountTrans
                where bankAccountTrans.SourceTableId == tablenum(BankTransSummarizationDocument)
                    && bankAccountTrans.SourceRecId == bankTransSummarizationDocument.RecId
                    && bankAccountTrans.Reconciled == NoYes::No
        {
            progress.setText(strFmt(GeneratingText, enum2str(BankDocumentBookType::SummarizedTrans), bankTransSummarizationDocument.SummarizationId));
            BankDocumentProcessor::submitBankDocumentTable(bankTransSummarizationDocument);
        }

        BankBridgingTrans bankBridgingTrans;
        LedgerJournalTrans ledgerJournalTransBridging;
        // Generate bank document for bank bridging transactions.
        progress.incCount();
        while select BridgingStatus, AccountId, IsCheck, BridgedLedgerJournalTransRecId from bankBridgingTrans
            where bankBridgingTrans.AccountId == _accountId
                && bankBridgingTrans.IsCheck == NoYes::No
                && bankBridgingTrans.BridgingStatus == BankBridgingStatus::Bridged
            join ledgerJournalTransBridging
                where ledgerJournalTransBridging.RecId == bankBridgingTrans.BridgedLedgerJournalTransRecId
        {
            progress.setText(strFmt(GeneratingText, enum2str(BankDocumentBookType::BankClearing), ledgerJournalTransBridging.Voucher));
            BankDocumentProcessor::submitBankDocumentTable(ledgerJournalTransBridging);
        }

        progress.incCount();
        while select BridgingStatus, AccountId, IsCheck, BridgedLedgerJournalTransRecId from bankBridgingTrans
            where bankBridgingTrans.AccountId == _accountId
                && bankBridgingTrans.IsCheck == NoYes::No
                && bankBridgingTrans.BridgingStatus == BankBridgingStatus::Cleared
            join ledgerJournalTransBridging
                where ledgerJournalTransBridging.RecId == bankBridgingTrans.BridgedLedgerJournalTransRecId
            join bankAccountTrans
                where bankAccountTrans.SourceTableId == tablenum(LedgerJournalTrans)
                    && bankAccountTrans.SourceRecId == bankBridgingTrans.BridgedLedgerJournalTransRecId
                    && bankAccountTrans.Reconciled == NoYes::No
        {
            progress.setText(strFmt(GeneratingText, enum2str(BankDocumentBookType::BankClearing), ledgerJournalTransBridging.Voucher));
            BankDocumentProcessor::submitBankDocumentTable(ledgerJournalTransBridging);
        }

        BankDocumentTable bankDocumentTable;
        // Generate bank document for other bank transaction.
        progress.incCount();
        while select bankAccountTrans
            where bankAccountTrans.AccountId == _accountId
                && bankAccountTrans.Reconciled == NoYes::No
            notexists join bankDocumentTable
                where   bankDocumentTable.SourceRelationType == bankAccountTrans.SourceTableId
                    &&  bankDocumentTable.SourceRecId == bankAccountTrans.SourceRecId
        {
            progress.setText(strFmt(GeneratingText, enum2str(BankDocumentBookType::Others), bankAccountTrans.Voucher));
            BankDocumentProcessor::submitBankDocumentTable(bankAccountTrans);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExistingBankDocForAdvancedRecon</Name>
				<Source><![CDATA[
    private static void deleteExistingBankDocForAdvancedRecon(CompanyBankAccountId _accountId)
    {
        BankDocumentTable bankDocumentTable;
        BankDocumentTableViewResult bankDocumentTableViewResult;

        ttsbegin;
        if (BankDisableAdvancedReconciliationValidationFlight::instance().isEnabled())
        {
            BankReconciliationMatching bankReconciliationMatching;
            BankReconciliationMatchingItem bankReconciliationMatchingItem;

            bankReconciliationMatching.skipDataMethods(true);
            bankReconciliationMatching.skipDeleteActions(true);

            delete_from bankReconciliationMatching
                exists join bankReconciliationMatchingItem
                    where bankReconciliationMatching.RecId == bankReconciliationMatchingItem.BankReconciliationMatching
                exists join bankDocumentTableViewResult
                    where bankReconciliationMatchingItem.BankDocumentTable == bankDocumentTableViewResult.BankDocumentTableRecId
                        && bankDocumentTableViewResult.AccountId == _accountId;

            delete_from bankReconciliationMatchingItem
                exists join bankDocumentTableViewResult
                    where bankReconciliationMatchingItem.BankDocumentTable == bankDocumentTableViewResult.BankDocumentTableRecId
                        && bankDocumentTableViewResult.AccountId == _accountId;

            delete_from bankDocumentTable
                exists join bankDocumentTableViewResult
                    where bankDocumentTable.RecId == bankDocumentTableViewResult.BankDocumentTableRecId
                        && bankDocumentTableViewResult.AccountId == _accountId;
        }
        else
        {
            delete_from bankDocumentTable
                exists join bankDocumentTableViewResult
                    where bankDocumentTable.RecId == bankDocumentTableViewResult.BankDocumentTableRecId
                        && bankDocumentTableViewResult.AccountId == _accountId
                        && bankDocumentTableViewResult.IsReconciled == NoYes::No;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    public static boolean exist(CompanyBankAccountId _companyBankAccountId)
    {
        boolean found =
            (select firstonly RecId
                from bankAccountTable
                where bankAccountTable.AccountID == _companyBankAccountId).RecId != 0;

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified record exists in the <c>BankAccountTable</c> table.
    /// </summary>
    /// <param name="_company">
    ///    The company of the bank account to check for existence.
    /// </param>
    /// <param name="_accountId">
    ///    The account ID of the bank account to check for existence.
    /// </param>
    /// <returns>
    ///    true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean existByCompany(DataAreaId _company, CompanyBankAccountId _accountId)
    {
        boolean ret = false;

        changecompany(_company)
        {
            ret = BankAccountTable::exist(_accountId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    public static BankAccountTable find(
        CompanyBankAccountId _companyBankAccountId,
        boolean _forupdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankAccountTable bankAccountTable;

        bankAccountTable.selectForUpdate(_forupdate);
        if (_forupdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            bankAccountTable.concurrencyModel(_concurrencyModel);
        }

        if (_companyBankAccountId)
        {
            select firstonly bankAccountTable
                where bankAccountTable.AccountID == _companyBankAccountId;
        }

        return bankAccountTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId</Name>
				<Source><![CDATA[
    public static BankAccountTable findByRecId(
        RecId _bankAccountRecId,
        boolean _forUpdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankAccountTable bankAccountTable;

        bankAccountTable.selectForUpdate(_forupdate);
        
        if (_forupdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            bankAccountTable.concurrencyModel(_concurrencyModel);
        }

        if (_bankAccountRecId)
        {
            select firstonly crosscompany bankAccountTable
                where bankAccountTable.RecId == _bankAccountRecId;
        }

        return bankAccountTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBankDocumentOfPaymentSent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds <c>LedgerJournalTrans</c> which is possible electronic payment in sent status.
    /// </summary>
    /// <param name="_accountId">
    /// The bank account id.
    /// </param>
    /// <param name="_forUpdate">
    /// A boolean value indicating whether to update the record.
    /// </param>
    /// <returns>
    /// The result set of <c>LedgerJournalTrans</c>.
    /// </returns>
    private static LedgerJournalTrans findBankDocumentOfPaymentSent(CompanyBankAccountId _accountId, boolean _forUpdate = true)
    {
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTable ledgerJournalTable;
        DimensionAttributeValueCombination ledgerDimension;

        select ledgerJournalTrans
            where ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::Sent
                && (((ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                            || ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                        && ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
                    || ((ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend
                            || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
                        && ledgerJournalTrans.AccountType == LedgerJournalACType::Bank))
                && ledgerJournalTrans.BankChequeNum == ''
                && ledgerJournalTrans.BankDepositNum == ''
                && ledgerJournalTrans.BankDepositVoucher == NoYes::No
            exists join ledgerJournalTable
                where ledgerJournalTable.JournalNum == ledgerJournalTrans.JournalNum
                    && ledgerJournalTable.Posted == NoYes::No
            exists join ledgerDimension
                where ((ledgerJournalTrans.OffsetLedgerDimension == ledgerDimension.RecId
                            && ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
                        || (ledgerJournalTrans.LedgerDimension == ledgerDimension.RecId
                            && ledgerJournalTrans.AccountType == LedgerJournalACType::Bank))
                    && ledgerDimension.DisplayValue == _accountId;

        ledgerJournalTrans.selectForUpdate(_forUpdate);

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>BankAccountTable</c> table.
    /// </summary>
    /// <param name="_company">
    ///    The company of the bank account.
    /// </param>
    /// <param name="_accountId">
    ///    The account ID of the bank account.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>BankAccountTable</c> table; otherwise, an empty record.
    /// </returns>
    public static BankAccountTable findByCompany(
        DataAreaId _company,
        CompanyBankAccountId _accountId,
        boolean _forUpdate = false)
    {
        BankAccountTable bankAccount;

        changecompany(_company)
        {
            bankAccount = BankAccountTable::find(_accountId, _forUpdate);
        }

        return bankAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByLedgerDimension</Name>
				<Source><![CDATA[
    public static BankAccountTable findByLedgerDimension(
        LedgerDimensionAccount _ledgerDimension,
        boolean _forupdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankAccountTable bankAccountTable;
        DimensionAttributeValueCombination ledgerDimension;

        bankAccountTable.selectForUpdate(_forupdate);
        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            bankAccountTable.concurrencyModel(_concurrencyModel);
        }

        select firstonly bankAccountTable
            join RecId from ledgerDimension where
                ledgerDimension.DisplayValue == bankAccountTable.AccountID &&
                ledgerDimension.RecId == _ledgerDimension;

        return bankAccountTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDefault_LV</Name>
				<Source><![CDATA[
    public static BankAccountTable findDefault_LV(CurrencyCode _currencyCode)
    {
        #isoCountryRegionCodes
        BankAccountTable bankAccountTable;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL]))
        {
            select firstonly bankAccountTable
                where bankAccountTable.CurrencyCode == _currencyCode &&
                      bankAccountTable.LvDefaultBank == NoYes::Yes;
        }

        return bankAccountTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerDimension</Name>
				<Source><![CDATA[
    public static LedgerDimensionDefaultAccount findLedgerDimension(CompanyBankAccountId _companyBankAccountId)
    {
        LedgerDimensionDefaultAccount ledgerDimension;

        if (_companyBankAccountId)
        {
            ledgerDimension = (select LedgerDimension from bankAccountTable
                                where bankAccountTable.AccountID == _companyBankAccountId).LedgerDimension;
        }
        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBridgingAccount</Name>
				<Source><![CDATA[
    internal static LedgerDimensionDefaultAccount findBridgingAccount(CompanyBankAccountId _accountId)
    {
        BankAccountTable bankAccountTable;

        select firstonly BridgingAccountLedgerDimension from bankAccountTable
            where bankAccountTable.AccountID == _accountId;

        return bankAccountTable.BridgingAccountLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOnAccountNum</Name>
				<Source><![CDATA[
    public static BankAccountTable findOnAccountNum(BankAccount _bankAccount, boolean _forUpdate = false)
    {
        BankAccountTable bankAccountTable;

        if (_bankAccount)
        {
            bankAccountTable.selectForUpdate(_forUpdate);

            while select bankAccountTable
            {
                if (strKeep(bankAccountTable.AccountNum, '0123456789') == strKeep(_bankAccount,'0123456789'))
                {
                    break;
                }
            }
        }

        return bankAccountTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified transaction date is in the period that is specified by the
    /// <c>ActiveFrom</c> and <c>ActiveTo</c> fields.
    /// </summary>
    /// <param name="_bankAccount">
    /// The company bank account for which to check the dates.
    /// </param>
    /// <param name="_comparisonDate">
    /// The transaction date.
    /// </param>
    /// <param name="_company">
    /// The company for which the transaction is performed.
    /// </param>
    /// <returns>
    /// true if the transaction date falls in between the <c>ActiveFrom</c> and the <c>ActiveTo</c> field
    /// dates; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Dates in the <c>ActiveFrom</c> and the <c>ActiveTo</c> fields are inclusive.
    /// </remarks>
    public static boolean isActive(
        CompanyBankAccount _bankAccount,
        TransDate _comparisonDate = DateTimeUtil::date(DateTimeUtil::utcNow()),
        CompanyId _company = curext())
    {
        return BankAccountTableLookup::isActive(_bankAccount, _comparisonDate, _company);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isActiveForAllTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>BankAccountHoldStatus</c> status has the <c>InactiveForAllTransactions</c> enumeration value.
    /// </summary>
    /// <param name="_bankAccount">
    /// The company bank account.
    /// </param>
    /// <param name="_dataAreaId">
    /// The <c>DataAreaId</c> of the company.
    /// </param>
    /// <returns>
    /// true if the <c>BankAccountHoldStatus</c> status has the <c>ActiveForAllTransactions</c> or <c>InactiveForNewTransactions</c> enumeration value; otherwise, false.
    /// </returns>
    public static boolean isActiveForAllTransactions(CompanyBankAccount _bankAccount, DataAreaId _dataAreaId = curext())
    {
        return BankAccountTableLookup::isActiveForAllTransactions(_bankAccount, _dataAreaId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAdvancedBankReconciliationEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether an advanced bank reconciliation is enabled for a specified bank account.
    /// </summary>
    /// <param name="_companyBankAccountId">
    /// The specified bank account.
    /// </param>
    /// <returns>
    /// true if the advanced bank reconciliation is enabled; otherwise, false.
    /// </returns>
    public static boolean isAdvancedBankReconciliationEnabled(CompanyBankAccountId _companyBankAccountId)
    {
        return BankAccountTable::find(_companyBankAccountId).BankReconciliationEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSingleCurrency</Name>
				<Source><![CDATA[
    public static boolean isSingleCurrency(CompanyBankAccountId _bankAccountId, LedgerJournalId _journalNum = '')
    {
        BankAccountTable bankAccountTable;
        BankAccountTrans bankAccountTrans;
        boolean ret;

        // Only single currency when Multi currency is not selected and a currency code has been defined in BankAccountTable
        select firstonly BankMultiCurrency, CurrencyCode from bankAccountTable
            where bankAccountTable.AccountID == _bankAccountId
               && bankAccountTable.BankMultiCurrency == NoYes::No
               && bankAccountTable.CurrencyCode != '';

        if (bankAccountTable)
        {
            // No transactions with another currency are allowed
            select firstonly RecId from bankAccountTrans
                where bankAccountTrans.AccountId == _bankAccountId
                   && bankAccountTrans.CurrencyCode != bankAccountTable.CurrencyCode;

            if (!bankAccountTrans)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the Go to Main Table Form option to the shortcut menu.
    /// </summary>
    /// <param name="_accountId">
    /// The account ID of the <c>BankAccountTable</c> table.
    /// </param>
    public static void jumpRef(CompanyBankAccountId _accountId)
    {
        Args args = new Args();
        args.lookupField(fieldNum(BankAccountTable, AccountID));
        args.lookupValue(_accountId);

        new MenuFunction(menuitemDisplayStr(BankAccountTable), MenuItemType::Display).run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupBankAccount</Name>
				<Source><![CDATA[
    public static void lookupBankAccount(FormControl _formControl, CompanyId _companyId = curext())
    {
        CompanyId companyId;
        
        // The following block is needed for the case that intercompany transactions is disabled and someone passes
        // in an empty string. Ideally one would remove the "curext()" defaulting from the paramter list, but this
        // code was added as part of a bug fix, and did not have the scope or need of changing the interface.
        if (!_companyId)
        {
            companyId = curext();
        }
        else
        {
            companyId = _companyId;
            if (!xDataArea::exist(companyId))
            {
                throw error(strFmt("@SYS10666", companyId));
            }
        }

        changecompany(companyId)
        {
            SegmentedEntryControl segmentedEntryControl;
            FormStringControl formStringControl;

            Args args = new Args();
            args.name(formStr(BankAccountTableLookup));
            args.caller(_formControl);
            args.lookupField(fieldNum(BankAccountTableLookup, AccountID));
            
            if (_formControl is FormStringControl)
            {
                formStringControl = _formControl as FormStringControl;
                args.lookupValue(formStringControl.text());
            }
            else if (_formControl is SegmentedEntryControl)
            {
                segmentedEntryControl = _formControl as SegmentedEntryControl;
                args.lookupValue(segmentedEntryControl.valueStr());
            }
            else
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }
            
            FormRun formRun = classfactory.formRunClass(args);
            formRun.init();
            
            if (_formControl is FormStringControl)
            {
                formStringControl = _formControl as FormStringControl;
                formStringControl.performFormLookup(formRun);
            }
            else if (_formControl is SegmentedEntryControl)
            {
                segmentedEntryControl = _formControl as SegmentedEntryControl;
                segmentedEntryControl.performFormLookup(formRun);
            }
            else
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupBankReconEnabledBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Looks up the bank account that is enabled for an advanced bank reconciliation.
    /// </summary>
    /// <param name="_formControl">
    /// A look up control.
    /// </param>
    /// <param name="_filterStr">
    /// A filter string.
    /// </param>
    public static void lookupBankReconEnabledBankAccount(FormControl _formControl)
    {
        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(BankAccountTable), _formControl);
        Query query = new Query();
        QueryBuildDataSource queryBuildDataSource = query.addDataSource(tableNum(BankAccountTable));
        QueryBuildRange queryBuildRange = queryBuildDataSource.addRange(fieldNum(BankAccountTable, BankReconciliationEnabled));

        sysTableLookup.addLookupfield(fieldNum(BankAccountTable, AccountID));
        sysTableLookup.addLookupfield(fieldNum(BankAccountTable, Name));

        queryBuildRange.value(queryValue(NoYes::Yes));
        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupGiroBank_W</Name>
				<Source><![CDATA[
    public static void lookupGiroBank_W(FormStringControl _ctrl, CurrencyCode _currencyCode)
    {
        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(BankAccountTable), _ctrl);
        Query query = new Query();
        QueryBuildDataSource queryBuildDataSource = query.addDataSource(tableNum(BankAccountTable));

        sysTableLookup.addLookupfield(fieldNum(BankAccountTable, AccountID));
        sysTableLookup.addLookupfield(fieldNum(BankAccountTable, Name));

        queryBuildDataSource.addRange(fieldNum(BankAccountTable, CurrencyCode)).value(queryValue(_currencyCode));

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>name</Name>
				<Source><![CDATA[
    public static Name name(CompanyBankAccountId _companyBankAccountId)
    {
        Name name;

        if (_companyBankAccountId)
        {
            name = (select bankAccountTable
                        index hint AccountIdx
                        where bankAccountTable.AccountID == _companyBankAccountId).Name;
        }

        return name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>regNum</Name>
				<Source><![CDATA[
    public static BankRegNum regNum(CompanyBankAccountId _companyBankAccountId)
    {
        BankRegNum bankRegNum;

        if (_companyBankAccountId)
        {
            bankRegNum = (select bankAccountTable
                            index hint AccountIdx
                            where bankAccountTable.AccountID == _companyBankAccountId).RegistrationNum;
        }

        return bankRegNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remittedCurrent</Name>
				<Source><![CDATA[
    static public AmountMST remittedCurrent(CompanyBankAccountId  _bankAccountNum)
    {
        LedgerJournalTrans ledgerJournalTransFieldList;
        LedgerJournalTable ledgerJournalTable;
        AmountMST amountMST;

        while select AmountCurDebit, AmountCurCredit, CurrencyCode, TransDate, Triangulation,
                     ExchRate, ExchRateSecond, Company from ledgerJournalTransFieldList
            where ledgerJournalTransFieldList.BankRemittanceType == BankRemittanceType::Discount
               && ledgerJournalTransFieldList.AccountType == LedgerJournalACType::Cust
               && ledgerJournalTransFieldList.BankAccountId == _bankAccountNum
        exists join ledgerJournalTable
            where ledgerJournalTable.JournalNum == ledgerJournalTransFieldList.JournalNum
               && ledgerJournalTable.JournalType == LedgerJournalType::CustPaymRemittance &&
                  ledgerJournalTable.Posted == NoYes::No
        {
            amountMST -= ledgerJournalTransFieldList.calcAmountMST();
        }
        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    public static TxtNotExist txtNotExist()
    {
        return "@SYS9779";
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExistingBankDocForPaymentSent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populats or removes the bank documents of existing payment in sent status.
    /// </summary>
    /// <param name="_accountId">
    /// The bank account id.
    /// </param>
    /// <param name="_enabled">
    /// A boolean value indicating whether the function of bank statement used as payment confirmation is enabled.
    /// </param>
    private static void updateExistingBankDocForPaymentSent(CompanyBankAccountId _accountId, BankReconciliationStmtAsPaymConfirm _enabled)
    {
        SysOperationProgress progress;

        #Macrolib.AviFiles
        #define.TotalTypes(1)
        //Generating bank document for %1...%2
        #define.GeneratingText("@GLS221780")
        //Removing bank document for %1...%2
        #define.RemovingText("@SYS4081497")

        if (_enabled)
        {
            progress = SysOperationProgress::newGeneral(#AviUpdate, "@GLS221675", #TotalTypes);
        }
        else
        {
            progress = SysOperationProgress::newGeneral(#AviUpdate, "@SYS4081496", #TotalTypes);
        }

        progress.incCount();
        LedgerJournalTrans ledgerJournalTrans = BankAccountTable::findBankDocumentOfPaymentSent(_accountId);

        ttsBegin;

        while (ledgerJournalTrans)
        {
            if (_enabled)
            {
                ledgerJournalTrans.calculateBankCurrencyAmount();
                ledgerJournalTrans.update();
                
                if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                    ||  ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                {
                    progress.setText(strFmt(#GeneratingText, enum2str(BankDocumentBookType::VendPayment), ledgerJournalTrans.DocumentNum));
                }
                else
                {
                    progress.setText(strFmt(#GeneratingText, enum2str(BankDocumentBookType::CustPayment), ledgerJournalTrans.DocumentNum));
                }

                BankDocumentProcessor::submitBankDocumentTable(ledgerJournalTrans);
            }
            else
            {
                ledgerJournalTrans.clearBankCurrencyAmount();
                ledgerJournalTrans.update();
                
                if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                    ||  ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                {
                    progress.setText(strFmt(#RemovingText, enum2str(BankDocumentBookType::VendPayment), ledgerJournalTrans.DocumentNum));
                }
                else
                {
                    progress.setText(strFmt(#RemovingText, enum2str(BankDocumentBookType::CustPayment), ledgerJournalTrans.DocumentNum));
                }

                BankDocumentProcessor::deleteBankDocument(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId);
            }

            next ledgerJournalTrans;
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preventAddressClearOrEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method allows for <c>LogisticsLocationFormHandler</c> to determine if the address can be cleared or edited.
    /// </summary>
    /// <returns>
    /// true if the location is the same as the account's bank group location; otherwise, false.
    /// </returns>
    public boolean preventAddressClearOrEdit()
    {
        return LogisticsLocationAppUtil::callerIsBankGroupLocation(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the user should be allowed to change currency code on the bank account.
    /// </summary>
    /// <returns>
    /// true if the user should be allowed to change the currency on the bank account; otherwise, false.
    /// </returns>
    public boolean allowEditCurrency()
    {
        boolean allowCurrencyEdit = !BankAccountTrans::existForBankAccount(this.AccountID) && !BankChequeTable::existForBankAccount(this.AccountID);

        return allowCurrencyEdit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountNameKanaMatchesJBAFormat_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the bank account kana name matches JBA format.
    /// </summary>
    /// <returns>
    /// True if bank account kana name matches JBA format; otherwise, false.
    /// </returns>
    public boolean checkAccountNameKanaMatchesJBAFormat_JP()
    {
        boolean doesKanaNameMatchJBAFormat = true;

        if (Bank_JP::nameKanaValidatePaymentFileNeeded())
        {
            doesKanaNameMatchJBAFormat = Bank_JP::validateBankNameKana(this.AccountNameKana_JP);
        }

        return doesKanaNameMatchJBAFormat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pendingPaymentAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of the bridging ledger entries associated with the bank account.
    /// </summary>
    /// <param name = "_accountType">
    /// The account type of the payment entries to sum.
    /// </param>
    /// <returns>
    /// The sum of all bridging entries associated with customer or vendor payment methods.
    ///  </returns>
    protected AmountCur pendingPaymentAmountMST(CustVendACType _accountType)
    {
        if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()))
        {
            return this.calculateSumBridgedAmountMST(_accountType);
        }

        LedgerEntry ledgerEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerTransFurtherPosting ledgerTransFurtherPosting;
        CustVendPaymModeTable paymModeTable;
        VendPaymModeTable vendPaymModeTable;
        CustPaymModeTable custPaymModeTable;

        switch (_accountType)
        {
            case CustVendACType::Cust:
                paymModeTable = custPaymModeTable;
                break;

            case CustVendACType::Vend:
                paymModeTable = vendPaymModeTable;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        DimensionDynamicAccount bankAccountLedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(this.AccountID, LedgerJournalACType::Bank);

        select sum(AccountingCurrencyAmount) from generalJournalAccountEntry
            exists join ledgerEntry
                where generalJournalAccountEntry.RecId == ledgerEntry.GeneralJournalAccountEntry
                    && ledgerEntry.IsBridgingPosting == NoYes::Yes
            exists join ledgerTransFurtherPosting
                where ledgerTransFurtherPosting.RefRecId == ledgerEntry.RecId
            exists join paymModeTable
                where paymModeTable.PaymMode == ledgerEntry.PaymentMode
                    && paymModeTable.PaymentLedgerDimension == bankAccountLedgerDimension;

        return generalJournalAccountEntry.AccountingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSumBridgedAmountMST</Name>
				<Source><![CDATA[
    private AmountCur calculateSumBridgedAmountMST(CustVendACType _accountType)
    {
        LedgerEntry ledgerEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerTransFurtherPosting ledgerTransFurtherPosting;
        BankBridgingTrans bankBridgingTrans;
        AmountCur sumAmountMST;
        ModuleCustVend moduleCustVend = (_accountType == CustVendACType::Cust) ? ModuleCustVend::Cust : ModuleCustVend::Vend;

        // Calculate the sum of the AccountingCurrencyAmount for bridged transactions after the feature BankBridgedTransAutoClearingFeature is enabled.
        select sum(AccountingCurrencyAmount) from generalJournalAccountEntry
            join ledgerEntry
                where generalJournalAccountEntry.RecId == ledgerEntry.GeneralJournalAccountEntry
                    && ledgerEntry.IsBridgingPosting == NoYes::Yes
            join bankBridgingTrans
                where bankBridgingTrans.AccountId == this.AccountID
                    && bankBridgingTrans.LedgerEntryRecId == ledgerEntry.RecId
                    && bankBridgingTrans.BridgingStatus == BankBridgingStatus::Bridged
                    && bankBridgingTrans.AccountType == moduleCustVend;

        sumAmountMST = generalJournalAccountEntry.AccountingCurrencyAmount;

        CustVendPaymModeTable paymModeTable;
        VendPaymModeTable vendPaymModeTable;
        CustPaymModeTable custPaymModeTable;

        switch (_accountType)
        {
            case CustVendACType::Cust:
                paymModeTable = custPaymModeTable;
                break;

            case CustVendACType::Vend:
                paymModeTable = vendPaymModeTable;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        DimensionDynamicAccount bankAccountLedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(this.AccountID, LedgerJournalACType::Bank);

        // Calculate the sum of the AccountingCurrencyAmount for bridged transactions before the feature BankBridgedTransAutoClearingFeature is enabled.
        select sum(AccountingCurrencyAmount) from generalJournalAccountEntry
            exists join ledgerEntry
                where generalJournalAccountEntry.RecId == ledgerEntry.GeneralJournalAccountEntry
                    && ledgerEntry.IsBridgingPosting == NoYes::Yes
            exists join ledgerTransFurtherPosting
                where ledgerTransFurtherPosting.RefRecId == ledgerEntry.RecId
            exists join paymModeTable
                where paymModeTable.PaymMode == ledgerEntry.PaymentMode
                    && paymModeTable.PaymentLedgerDimension == bankAccountLedgerDimension
            notexists join bankBridgingTrans
                where bankBridgingTrans.LedgerEntryRecId == ledgerEntry.RecId;

        return sumAmountMST + generalJournalAccountEntry.AccountingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pendingPaymentAmountSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the sum of the pending payments of the bank account.
    /// </summary>
    /// <returns>
    /// The sum of the pending payments.
    /// </returns>
    /// <remarks>
    /// The pending payments of the bank account is the sum of customer and vendor bridging transactions.
    /// </remarks>
    public display AmountCur pendingPaymentAmountSum()
    {
        CurrencyExchangeHelper transExchRateHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(CompanyInfo::current()),
            DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        AmountMST pendingPaymentAmountMST = this.pendingPaymentAmountMST(CustVendACType::Cust) + this.pendingPaymentAmountMST(CustVendACType::Vend);

        return transExchRateHelper.calculateAccountingToTransaction(this.CurrencyCode, pendingPaymentAmountMST, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pendingBalanceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the pending balance of the bank account.
    /// </summary>
    /// <returns>
    /// The pending balance amount of a given account.
    /// </returns>
    public display AmountCur pendingBalanceAmount()
    {
        return this.balanceCur() + this.pendingPaymentAmountSum();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBalanceCurForDateRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the sum of transactions from the given starting date to the ending date.
    /// </summary>
    /// <param name = "_startDate">
    /// The starting date of the span to calculate the balance for.
    /// </param>
    /// <param name = "_endDate">
    /// The ending date of the span to calculate the balance for.
    /// </param>
    /// <returns>
    /// The sum of transactions for the given date span.
    /// </returns>
    public AmountCur getBalanceCurForDateRange(TransDate _startDate, TransDate _endDate)
    {
        BankAccountTrans bankAccountTrans;

        select sum(AmountCur), sum(AmountCorrect) from bankAccountTrans
            group by CurrencyCode
            where bankAccountTrans.AccountId == this.AccountID
                && bankAccountTrans.TransDate >= _startDate
                && bankAccountTrans.TransDate < _endDate;

        return bankAccountTrans.AmountCur + bankAccountTrans.AmountCorrect;
    }

]]></Source>
			</Method>
			<Method>
				<Name>DimensionAttributeDelegates_getTablesToAddCopiedValuesTo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of tables and fields to update when copying the values to default dimensions on existing values.
    /// </summary>
    /// <param name = "_tableSet">A <c>Set</c> of <c>DimensionCopyValuesDataContract</c> values.</param>
    [SubscribesTo(classStr(DimensionAttributeDelegates), delegateStr(DimensionAttributeDelegates, getTablesToAddCopiedValuesTo))]
    public static void DimensionAttributeDelegates_getTablesToAddCopiedValuesTo(Set _tableSet)
    {
        DimensionCopyValueDataContract contract = DimensionCopyValueDataContract::construct(tableNum(BankAccountTable), fieldNum(BankAccountTable, DefaultDimension));
        contract.addKeyFieldDimensionPair(tableNum(BankAccountTable), fieldNum(BankAccountTable, AccountID));
        _tableSet.add(contract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupTemplateReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides values for template lookups.
    /// </summary>
    public Common lookupTemplateReference(FormReferenceControl _formControl)
    {
        Query query = new Query();
        QueryBuildDataSource docuRefDs = query.addDataSource(tableNum(DocuRef));
        docuRefDs.addRange(fieldNum(DocuRef, RefTableId)).value(queryValue(this.TableId));
        docuRefDs.addRange(fieldNum(DocuRef, RefRecId)).value(queryValue(this.RecId));

        QueryBuildDataSource docuValueDs = docuRefDs.addDataSource(tableNum(DocuValue));
        docuValueDs.relations(true);
        docuValueDs.addRange(fieldNum(DocuValue, filetype)).value('docx');

        SysReferenceTableLookup sysTableLookup = SysReferenceTableLookup::newParameters(tableNum(DocuRef), _formControl);
        sysTableLookup.addLookupfield(fieldNum(DocuRef, Name));
        sysTableLookup.addLookupfield(fieldNum(DocuRef, Notes));
        sysTableLookup.addLookupfield(fieldNum(DocuRef, CreatedDateTime));
        sysTableLookup.parmQuery(query);
        
        DocuRef selectedRecord = sysTableLookup.performFormLookup();
        return selectedRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>DocuRefOnDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if attachment is in use before deleting.
    /// </summary>
    [SubscribesTo(tablestr(DocuRef), delegatestr(DocuRef, OnValidateDelete))]
    static void DocuRefOnDelete(DocuRef _docuRef)
    {
        BankAccountTable bankAccountTable;
        select firstonly AccountID from bankAccountTable
            where bankAccountTable.CurrencyOrder_TemplateRefRecId_RU == _docuRef.RecId
                || bankAccountTable.CurrencySellOrder_TemplateRefRecId_RU == _docuRef.RecId
                || bankAccountTable.TemplateRefRecId_RU == _docuRef.RecId;

        if (bankAccountTable)
        {
            throw error(strFmt("@CashManagement:AttachmentInUseByAccount", bankAccountTable.AccountID));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the current ledger's reporting currency is not blank and it is not same as accounting currency.
    /// </summary>
    public display boolean showReportingCurrency()
    {
        boolean showReportingCurrency = false;

        if (Ledger::reportingCurrency() && Ledger::reportingCurrency() != Ledger::accountingCurrency())
        {
            showReportingCurrency = true;
        }

        return showReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastRevalResetDate</Name>
				<Source><![CDATA[
    public static date getLastRevalResetDate(BankAccountID _accountId, DataAreaId _dataAreaId = curExt())
    {
        BankAccountTable bankAccountTable = BankAccountTable::findByCompany(_dataAreaId, _accountId);

        return bankAccountTable.LastRevalResetDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIsRunMatchingRule</Name>
				<Source><![CDATA[
    internal static void updateIsRunMatchingRule(CompanyBankAccountId _accountId, boolean _isRunMatchingRule)
    {
        ttsbegin;
        BankAccountTable bankAccountTable = BankAccountTable::find(_accountId, true);

        if (bankAccountTable)
        {
            if (bankAccountTable.IsRunMatchingRule && _isRunMatchingRule)
            {
                throw warning(strFmt("@CashManagement:BankRunMatchingRuleConflict", _accountId));
            }

            bankAccountTable.IsRunMatchingRule = _isRunMatchingRule;
            bankAccountTable.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Bank</ConfigurationKey>
	<DeveloperDocumentation>@SYS328970</DeveloperDocumentation>
	<FormRef>BankAccountTable</FormRef>
	<Label>@SYS21829</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>AccountID</TitleField1>
	<TitleField2>Name</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>Found</CacheLookup>
	<ClusteredIndex>AccountIdx</ClusteredIndex>
	<Modules>Bank</Modules>
	<PrimaryIndex>AccountIdx</PrimaryIndex>
	<ReplacementKey>AccountIdx</ReplacementKey>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>BankAccountStatement</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>BankAccountStatement</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>BankAccountTrans</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>BankAccountTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>BankChequeLayout</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>BankChequeLayout</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>BankChequeTable</Name>
			<DeleteAction>CascadeRestricted</DeleteAction>
			<Relation></Relation>
			<Table>BankChequeTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>BankDeposit</Name>
			<DeleteAction>CascadeRestricted</DeleteAction>
			<Relation></Relation>
			<Table>BankDeposit</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>BankDocumentFacilityAgreement</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>BankDocumentFacilityAgreement</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CustPrenote</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustPrenote</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>VendPrenote</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>VendPrenote</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankCodeType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SWIFTNo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankClearingCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DivisionPaymId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankAccountStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerJournalNameId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContactPerson</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Phone</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RegistrationNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankCIN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankInterbankClearingCode_BE</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NsfLedgerJournalName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IBAN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountID</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Activation</Name>
			<Label>@SYS106756</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ActiveFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActiveTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankAccountStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CFMBankBalanceMinimum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Administration</Name>
			<Label>@SYS9853</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankAccountDetails</Name>
			<Label>@GLS60009</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransType_JP</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankConstantSymbol</Name>
			<Label>@GLS107997</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankConstantSymbol</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SpecificSymbol</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankPositivePayFormat</Name>
			<Label>@SYS4004473</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankPositivePayFormatName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankPositivePayStartDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankReconciliation</Name>
			<Label>@SYS69067</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankReconciliationEnabled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankStatementName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankStatementFormat</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankReconciliationStmtAsPaymConfirm</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankReconAllowedPennyDifference</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TimeZonePreference</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TimeZone</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BridgingAccountLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankReconBridgedAutoClearing</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankReconciliationReportFormat</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankReconciliationAutomation</Name>
			<Label>@GLS222317</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankReconMatchAutoAfterImport</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankReconciliationMatchRuleSet</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BillOfExchange</Name>
			<Label>@SYS69795</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RemitCollectionAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RemittanceCollectionLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RemitDiscountAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RemittanceDiscountLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerJournalNameId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceRemitAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceRemittanceLedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ContactInfo</Name>
			<Label>@SYS21663</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ContactPerson</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Phone</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PhoneLocal</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CellularPhone</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Pager</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TeleFax</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Email</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SMS</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>URL</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Telex</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Credit</Name>
			<Label>@sys7084</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OverDraftLimit</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Currency</Name>
			<Label>@SYS7572</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankMultiCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LvDefaultBank</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Description</Name>
			<Label>@SYS7576</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountNameKana_JP</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankCompanyStatementName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankDestinationName</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimensions</Name>
			<Label>@SYS342338</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ExportPath_LT</Name>
			<Label>@SYS95311</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymLocalExportPath_LT</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymForeignExportPath_LT</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GiroSlip_FI</Name>
			<Label>@SYS5231</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PrintGiro_FI</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IncludeBankBarCode_FI</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankCodeType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RegistrationNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankCIN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SWIFTNo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IBAN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CompanyPaymId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DivisionPaymId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>bankBIC_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CorrAccount_W</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Ledger</Name>
			<Label>@SYS13356</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>NonSufficientFunds</Name>
			<Label>@SYS133998</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>NsfLedgerJournalName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NsfFeeMarkupGroupModule</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NsfFeeMarkupGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@SYS9039</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>bankName_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RegistrationNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankCIN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>bankBIC_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CorrAccount_W</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>bankAccountOpenedIn_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LvDefaultBank</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PaymentManagement</Name>
			<Label>@SYS57540</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DiscCreditMaxMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankSuffix</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankTransferCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PaymentOrder_W</Name>
			<Label>@GLS108610</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LvPayOrderType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymOrderNumSeqId_W</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PaymentOrderInCurrency_RU</Name>
			<Label>@GLS102327</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TemplateFileName_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Prenotes</Name>
			<Label>@SYS128504</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>isBankPrenote</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PrenoteResponseDays</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PurchaseOfFundsInHardCurrency_RU</Name>
			<Label>@GLS102989</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CurrencyOrder_TemplateName_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencySellOrder_TemplateName_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Setup</Name>
			<Label>@SYS2186</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankSortCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankContractAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GiroContractAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FeeContractAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GiroContract</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustomerPaymentFeeLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustPaymFeePost</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DebitDirectId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankClearingCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankInterbankClearingCode_BE</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LvDefaultBank</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SWIFT</Name>
			<Label>@SYS9360</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SWIFTNo</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TaxRegistration_MX</Name>
			<Label>@SYS312490</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Rfc_MX</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>NsfLedgerJournalName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustNsfJournalName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountID</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountNameKana_JP</Name>
			<AosAuthorization>Yes</AosAuthorization>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankAccountNameKana_JP</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountNum</Name>
			<AosAuthorization>Yes</AosAuthorization>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankAccount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ActiveFrom</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>UTCTimestamp</ExtendedDataType>
			<Label>@SYS129004</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ActiveTo</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>UTCTimestamp</ExtendedDataType>
			<Label>@SYS129005</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankAccountStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>BankAccountHoldStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankCIN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankCIN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankClearingCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankClearingCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankCodeType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>BankCodeType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankCompanyStatementName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionContextField>Location</CountryRegionContextField>
			<ExtendedDataType>BankCompanyStatementName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankConstantSymbol</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>CZ</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS108021</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankContractAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>GiroContractAccount</ExtendedDataType>
			<Label>@SYS70490</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankDestinationName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionContextField>Location</CountryRegionContextField>
			<ExtendedDataType>BankDestinationName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankInterbankClearingCode_BE</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>BankInterbankClearingCode_BE</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankMultiCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankMultiCurrency</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankPositivePayFormatName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankPositivePayFormatName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>BankPositivePayStartDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>StartDate</ExtendedDataType>
			<Label>@SYS4004504</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>BankReconAllowedPennyDifference</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankReconAllowedPennyDifference</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankReconciliationEnabled</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankReconciliationEnabled</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankReconciliationMatchRuleSet</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankReconciliationMatchRuleSetRefRecId</ExtendedDataType>
			<Label>@GLS222249</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankReconciliationStmtAsPaymConfirm</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankReconciliationStmtAsPaymConfirm</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankReconMatchAutoAfterImport</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankReconciliationMatchAutoAfterImport</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankReconMatchRuleManualMatch</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>BankReconciliationMatchRuleRefRecId</ExtendedDataType>
			<Label>@GLS222603</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankReconMatchRuleManualReversal</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>BankReconciliationMatchRuleRefRecId</ExtendedDataType>
			<Label>@GLS222605</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankSortCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankSortCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankStatementFormat</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankStatementFormatRefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankStatementName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankStatementName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankSuffix</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankSuffix</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankTransferCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankTransferCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CellularPhone</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>PhoneMobile</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CompanyPaymId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CompanyPaymId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContactPerson</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>PersonName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CorrAccount_W</Name>
			<AosAuthorization>Yes</AosAuthorization>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankCorrAccount_W</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencyCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencyOrder_TemplateName_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>Filename</ExtendedDataType>
			<Label>@GLS114369</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencySellOrder_TemplateName_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>Filename</ExtendedDataType>
			<Label>@GLS114367</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CustomerPaymentFeeLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
			<Label>@SYS16999</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CustPaymFeePost</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS67173</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DebitDirectId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankDebitDirectId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDefaultDimensionValueSet</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>DiscCreditMaxMST</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankDiscCreditMaxMST</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DivisionPaymId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankDivisionPaymId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Email</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Email</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>FeeContractAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>FeeContractAccount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>GiroContract</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>GiroContractNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>GiroContractAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>GiroContractAccount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>IBAN</Name>
			<AosAuthorization>Yes</AosAuthorization>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankIBAN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IncludeBankBarCode_FI</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>IncludeBankBarCode_FI</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>InvoiceRemitAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>VendPromissoryNote</ConfigurationKey>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SYS76482</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InvoiceRemittanceLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>VendPromissoryNote</ConfigurationKey>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
			<Label>@SYS76483</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>isBankPrenote</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankPrenote</ExtendedDataType>
			<Label>@SYS128571</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LedgerJournalNameId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CustBillOfExchange</ConfigurationKey>
			<ExtendedDataType>LedgerJournalNameId</ExtendedDataType>
			<Label>@SYS73715</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Location</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LogisticsLocationRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LvDefaultBank</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LVDefaultBank</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LvPayOrderType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>LvPaymentOrderType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Name</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>NsfFeeMarkupGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustNsfFeeMarkupGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>NsfFeeMarkupGroupModule</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustNsfFeeMarkupGroupModule</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>MarkupModuleType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>OverDraftLimit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankOverDraftLimit</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Pager</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Pager</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymForeignExportPath_LT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>LT</CountryRegionCodes>
			<ExtendedDataType>FilePath</ExtendedDataType>
			<Label>@GLS113333</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymLocalExportPath_LT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>LT</CountryRegionCodes>
			<ExtendedDataType>FilePath</ExtendedDataType>
			<Label>@GLS113331</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymOrderNumSeqId_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU,LV</CountryRegionCodes>
			<ExtendedDataType>NumberSequenceCode</ExtendedDataType>
			<Label>@GLS103473</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Phone</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Phone</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PhoneLocal</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PhoneLocal</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>PrenoteResponseDays</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PrenoteResponseDays</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PrintGiro_FI</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PrintGiro_FI</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RegistrationNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankRegNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>RemitCollectionAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CustBillOfExchange</ConfigurationKey>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SYS73717</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>RemitDiscountAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CustBillOfExchange</ConfigurationKey>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SYS73718</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>RemittanceCollectionLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CustBillOfExchange</ConfigurationKey>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
			<Label>@SYS75660</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>RemittanceDiscountLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CustBillOfExchange</ConfigurationKey>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
			<Label>@SYS75661</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Rfc_MX</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Rfc_MX</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SMS</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>SMS</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SpecificSymbol</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>CZ</CountryRegionCodes>
			<ExtendedDataType>SpecificSymbol</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SWIFTNo</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SWIFTNo</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TeleFax</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>TeleFax</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Telex</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Telex</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TemplateFileName_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>Filename</ExtendedDataType>
			<Label>@GLS102339</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TransType_JP</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>BankTransType_JP</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>URL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>URL</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankPositivePayFormat</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<HelpText>@SYS4004483</HelpText>
			<Label>@SYS4004473</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsNACHAFileBlocked</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@CashManagement:CashBankMgmt_Payment_IsNACHABlockedLabel</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TemplateRefRecId_RU</Name>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS102339</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CurrencyOrder_TemplateRefRecId_RU</Name>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS114369</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CurrencySellOrder_TemplateRefRecId_RU</Name>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS114367</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CFMBankBalanceMinimum</Name>
			<ExtendedDataType>CFMBankBalanceMinimum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TimeZonePreference</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@CashManagement:TimeZonePreference</Label>
			<EnumType>DMFTimeZonePreference</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TimeZone</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@CashManagement:TimeZone</Label>
			<EnumType>Timezone</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReverseDebitCredit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@CashManagement:ReverseDebitCreditHelpText</HelpText>
			<Label>@CashManagement:ReverseDebitCreditLabel</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>LastRevalResetDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<FeatureClass>BankCurrencyRevalEnhancementFeature</FeatureClass>
			<Label>@CashManagement:BankCurrencyRevalResetLastResetDate</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RevalDimensionSetting</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<FeatureClass>BankCurrencyRevalEnhancementFeature</FeatureClass>
			<EnumType>BankCurrencyRevalDimensionSetting</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsRunMatchingRule</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustPaymentJournalName</Name>
			<ExtendedDataType>LedgerJournalNameId</ExtendedDataType>
			<FeatureClass>BankModernReconciliationFeature</FeatureClass>
			<Label>@CashManagement:BankStatementGenerateCustPaymentJournal</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VendPaymentJournalName</Name>
			<ExtendedDataType>LedgerJournalNameId</ExtendedDataType>
			<FeatureClass>BankModernReconciliationFeature</FeatureClass>
			<Label>@CashManagement:BankStatementGenerateVendPaymentJournal</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ReportingCurrencyExchangeRateType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<FeatureClass>BankRevalExchRateTypeEnhancementFeature</FeatureClass>
			<Label>@Ledger:ReportingCurrencyExchangeRateType</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>AccountingCurrencyExchangeRateType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<FeatureClass>BankRevalExchRateTypeEnhancementFeature</FeatureClass>
			<Label>@Ledger:DefaultExchangeRateType</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankReconBridgedAutoClearing</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<FeatureClass>BankBridgedTransAutoClearingFeature</FeatureClass>
			<HelpText>@Bank:BankReconBridgedAutoClearingHelpText</HelpText>
			<Label>@Bank:BankReconBridgedAutoClearing</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BridgingAccountLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
			<FeatureClass>BankBridgedTransAutoClearingFeature</FeatureClass>
			<HelpText>@Bank:BankAccountBridgingAccHelpText</HelpText>
			<Label>@SYS21687</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankReconciliationReportFormat</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ERFormatMappingID</ExtendedDataType>
			<HelpText>@Bank:BankReconciliationReportFormatHelpText</HelpText>
			<Label>@Bank:BankReconciliationReportFormat</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>AccountIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>AccountID</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>RemittanceDiscountLedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>RemittanceDiscountLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>RemittanceCollectionLedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>RemittanceCollectionLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>LedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InvoiceRemittanceLedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>InvoiceRemittanceLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CustomerPaymentFeeLedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CustomerPaymentFeeLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DefaultDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>DefaultDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>BankStatementFormatIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>BankStatementFormat</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>BankConstantSymbolIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>BankConstantSymbol</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>BankAccountMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>AccountID</MapField>
					<MapFieldTo>AccountID</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>BankGroupId</MapField>
					<MapFieldTo>BankGroupId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Name</MapField>
					<MapFieldTo>Name</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>AccountNum</MapField>
					<MapFieldTo>AccountNum</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Location</MapField>
					<MapFieldTo>Location</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>RegistrationNum</MapField>
					<MapFieldTo>RegistrationNum</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Phone</MapField>
					<MapFieldTo>Phone</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TeleFax</MapField>
					<MapFieldTo>TeleFax</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ContactPerson</MapField>
					<MapFieldTo>ContactPerson</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Email</MapField>
					<MapFieldTo>Email</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>URL</MapField>
					<MapFieldTo>URL</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Telex</MapField>
					<MapFieldTo>Telex</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PhoneLocal</MapField>
					<MapFieldTo>PhoneLocal</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CellularPhone</MapField>
					<MapFieldTo>CellularPhone</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CustVendAccount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>BankContractAccount</MapField>
					<MapFieldTo>GiroContract</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CustVendPaymTextCode</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SWIFTNo</MapField>
					<MapFieldTo>SWIFTNo</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>MsgToBank</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchRate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchRateRef</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>GiroContractAccount</MapField>
					<MapFieldTo>GiroContractAccount</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Pager</MapField>
					<MapFieldTo>Pager</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SMS</MapField>
					<MapFieldTo>SMS</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>BankCodeType</MapField>
					<MapFieldTo>BankCodeType</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>isBankPrenote</MapField>
					<MapFieldTo>isBankPrenote</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PrenoteResponseDays</MapField>
					<MapFieldTo>PrenoteResponseDays</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>BankIBAN</MapField>
					<MapFieldTo>IBAN</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>BankCIN</MapField>
					<MapFieldTo>BankCIN</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ForeignBank_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ForeignAccount_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ForeignSWIFT_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CorrAccount_W</MapField>
					<MapFieldTo>CorrAccount_W</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>LogisticsLocationMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>Location</MapField>
					<MapFieldTo>Location</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankConstantSymbol</Name>
			<Cardinality>ZeroOne</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>BankConstantSymbol</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankConstantSymbol</Name>
					<Field>BankConstantSymbol</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankGroupId</Name>
					<SourceEDT>BankGroupId</SourceEDT>
					<Field>BankGroupId</Field>
					<RelatedField>BankGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>BankGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankReconciliationMatchRuleSet</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>BankReconciliationMatchRuleSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankReconciliationMatchRuleSet</Name>
					<Field>BankReconciliationMatchRuleSet</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankStatementFormat</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>BankStatementFormat</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankStatementFormat</Name>
					<Field>BankStatementFormat</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CurrencyCode</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>CurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustomerPaymentFeeLedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustomerPaymentFeeLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustomerPaymentFeeLedgerDimension</Name>
					<Field>CustomerPaymentFeeLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DefaultDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InvoiceRemittanceLedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InvoiceRemittanceLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InvoiceRemittanceLedgerDimension</Name>
					<Field>InvoiceRemittanceLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimension</Name>
					<Field>LedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalName_LedJourNameId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalName</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalName_LedJourNameId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerJournalNameId</Name>
					<SourceEDT>LedgerJournalNameId</SourceEDT>
					<Field>LedgerJournalNameId</Field>
					<RelatedField>JournalName</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>JournalNameIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LedgerJournalName_NsfLedJourName</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalName</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalName_NsfLedJourName</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>NsfLedgerJournalName</Name>
					<SourceEDT>CustNsfJournalName</SourceEDT>
					<Field>NsfLedgerJournalName</Field>
					<RelatedField>JournalName</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>JournalType_Extern</Name>
					<SourceEDT>CustNsfJournalName</SourceEDT>
					<RelatedField>JournalType</RelatedField>
					<ValueStr>LedgerJournalType::CustPayment</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Location_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LogisticsLocation</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Location_FK</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Location</Name>
					<Field>Location</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>MarkupGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>MarkupGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>NsfFeeMarkupGroupId</Name>
					<SourceEDT>CustNsfFeeMarkupGroupId</SourceEDT>
					<Field>NsfFeeMarkupGroupId</Field>
					<RelatedField>GroupId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Module_Extern</Name>
					<SourceEDT>CustNsfFeeMarkupGroupId</SourceEDT>
					<RelatedField>Module</RelatedField>
					<ValueStr>MarkupModuleType::Cust</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>NumberSequenceTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>NumberSequenceTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymOrderNumSeqId_W</Name>
					<SourceEDT>NumberSequenceCode</SourceEDT>
					<Field>PaymOrderNumSeqId_W</Field>
					<RelatedField>NumberSequence</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RemittanceCollectionLedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>RemittanceCollectionLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RemittanceCollectionLedgerDimension</Name>
					<Field>RemittanceCollectionLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RemittanceDiscountLedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>RemittanceDiscountLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RemittanceDiscountLedgerDimension</Name>
					<Field>RemittanceDiscountLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankPositivePayFormat</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankPositivePayFormat</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankPositivePayFormatName</Name>
					<SourceEDT>BankPositivePayFormatName</SourceEDT>
					<Field>BankPositivePayFormatName</Field>
					<RelatedField>FormatName</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TemplateDocuRef</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DocuRef</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TemplateRefRecId_RU</Name>
					<Field>TemplateRefRecId_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CurrencyOrderTemplateDocuRef</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DocuRef</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CurrencyOrder_TemplateRefRecId_RU</Name>
					<Field>CurrencyOrder_TemplateRefRecId_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CurrencySellOrderDocuRef</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DocuRef</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CurrencySellOrder_TemplateRefRecId_RU</Name>
					<Field>CurrencySellOrder_TemplateRefRecId_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustPaymentJournalName</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LedgerJournalName</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustPaymentJournalName</Name>
					<Field>CustPaymentJournalName</Field>
					<RelatedField>JournalName</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendPaymentJournalName</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LedgerJournalName</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendPaymentJournalName</Name>
					<Field>VendPaymentJournalName</Field>
					<RelatedField>JournalName</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>AccountingCurrencyExchangeRateType</Name>
			<Cardinality>ZeroOne</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>ExchangeRateType</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountingCurrencyExchangeRateType</Name>
					<Field>AccountingCurrencyExchangeRateType</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ReportingCurrencyExchangeRateType</Name>
			<Cardinality>ZeroOne</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>ExchangeRateType</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReportingCurrencyExchangeRateType</Name>
					<Field>ReportingCurrencyExchangeRateType</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>FloatAccountLedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BridgingAccountLedgerDimension</Name>
					<Field>BridgingAccountLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankReconciliationReportFormat</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ERFormatMappingTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankReconciliationReportFormat</Name>
					<Field>BankReconciliationReportFormat</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>