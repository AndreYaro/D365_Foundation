<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustomsImportAssessableValue_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustomsImportAssessableValue_IN extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getInvoiceCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the CurrencyCode for specified PurchId from PurchaseOrder.
    /// </summary>
    /// <returns>
    /// The CurrencyCode for selected PurchaseOrder.
    /// </returns>
    display CurrencyCode getInvoiceCurrency()
    {
        return PurchTable::find(this.PurchId).CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceFOBAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets fobAmount if the Basis is FOB otherwise zero.
    /// </summary>
    /// <returns>
    /// The FOBAmount for selected PurchaseOrder with Misc.Charges.
    /// </returns>
    display CustomsAmount_IN getInvoiceFOBAmount()
    {
        CustomsAmount_IN fobAmount;

        if (this.Basis == CustomsAssessableValueBasis_IN::FOB)
        {
            fobAmount = this.Amount;
        }
        else
        {
            fobAmount = 0;
        }
        return fobAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// inserts the CustomsImportAssessableValue_IN table and MarkupTrans from PurchLine record.
    /// </summary>
    /// <param name="_purchLine">
    /// The PurchLine record from which CustomsImportAssessableValue_IN buffer needs to be copied.
    /// </param>
    public void initFromPurchLine(PurchLine _purchLine)
    {
        CustomsImportAssessableValue_IN customsImportAssessableValue;
        boolean                         ret;
        MarkupTrans                     markupTrans, markUpTransLoc;

        if (_purchLine.RecId)
        {
            this.PurchId            = _purchLine.PurchId;
            this.Amount             = _purchLine.LineAmount;
            this.LandingChargesPct  = VendParameters::find().CustomsLandingChargesPct_IN;
            this.InventTransId      = _purchLine.InventTransId;
            this.Value              = CustomsImportAssessableValue_IN::getMarkupValue(_purchLine.TableId, _purchLine.RecId, _purchLine.InventTransId);

            while select RecId from customsImportAssessableValue
                where   customsImportAssessableValue.InventTransId  == _purchLine.InventTransId
            {
                if (customsImportAssessableValue.RecId)
                {
                    ret = true;
                }
            }
            if (!ret && this.PurchId)
            {
                ttsbegin;
                this.insert();

                CustomsImportAssessableValue_IN::refreshMarkupTrans(_purchLine, this);
                ttscommit;
            }
            else
            {
                ttsbegin;
                select forupdate customsImportAssessableValue
                    where   customsImportAssessableValue.InventTransId  == _purchLine.InventTransId;

                if (customsImportAssessableValue.Basis == CustomsAssessableValueBasis_IN::FOB)
                {
                    customsImportAssessableValue.Value  = this.Value;
                }
                else
                {
                    customsImportAssessableValue.Value  = 0;
                }
                customsImportAssessableValue.Amount = _purchLine.LineAmount;
                customsImportAssessableValue.update();

                CustomsImportAssessableValue_IN::refreshMarkupTrans(_purchLine, customsImportAssessableValue);
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshMarkupTrans</Name>
				<Source><![CDATA[
    private static void refreshMarkupTrans(Common _from, CustomsImportAssessableValue_IN _to)
    {
        MarkupTrans oldMarkupTrans, newMarkupTrans;
        delete_from newMarkupTrans
            where newMarkupTrans.TransTableId == _to.TableId && newMarkupTrans.TransRecId == _to.RecId;

        while select oldMarkupTrans
            where oldMarkupTrans.TransTableId == _from.TableId && oldMarkupTrans.TransRecId == _from.RecId
        {
            newMarkupTrans = oldMarkupTrans.data();
            newMarkupTrans.TransTableId = _to.TableId;
            newMarkupTrans.TransRecId = _to.RecId;
            newMarkupTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPurchParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// inserts the CustomsImportAssessableValue_IN table and MarkupTrans from PurchParmLine record.
    /// </summary>
    /// <param name="_purchParmLine">
    /// The PurchParmLine record from which CustomsImportAssessableValue_IN buffer needs to be copied.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    public void initFromPurchParmLine(
        PurchParmLine _purchParmLine,
        TransDate     _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        CustomsImportAssessableValue_IN customsImportAssessableValue;
        boolean                         ret;
        PurchLine                       purchLineLoc;
        MarkupTrans                     markupTrans, markUpTransLoc;

        purchLineLoc = PurchLine::findInventTransId(_purchParmLine.InventTransId);
        if (_purchParmLine.RecId)
        {
            select firstonly forupdate customsImportAssessableValue
                where customsImportAssessableValue.InventTransId == _purchParmLine.InventTransId;

            if (customsImportAssessableValue.RecId)
            {
                CustomsImportAssessableValue_IN::updateWithPurchParmLine(customsImportAssessableValue, _purchParmLine, _transDate);
            }
            else if (_purchParmLine.OrigPurchId)
            {
                CustomsImportAssessableValue_IN::updateWithPurchParmLine(this, _purchParmLine, _transDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWithPurchParmLine</Name>
				<Source><![CDATA[
    private static void updateWithPurchParmLine(CustomsImportAssessableValue_IN _record, PurchParmLine _purchParmLine, TransDate _transDate)
    {
        _record.PurchId = _purchParmLine.OrigPurchId;
        _record.Amount = _purchParmLine.LineAmount;
        _record.LandingChargesPct = VendParameters::find().CustomsLandingChargesPct_IN;
        _record.InventTransId = _purchParmLine.InventTransId;

        Common fromTable;

        if (TaxIntegrationUtils::isChargeOnBOEEnabled())
        {
            _record.Value = CustomsImportAssessableValue_IN::getMarkupValue(
                    _purchParmLine.TableId,
                    _purchParmLine.RecId,
                    _purchParmLine.InventTransId,
                    _transDate);

            fromTable = _purchParmLine;
        }
        else
        {
            PurchLine purchLine =_purchParmLine.purchLine();
            _record.Value = CustomsImportAssessableValue_IN::getMarkupValue(
                    purchLine.TableId,
                    purchLine.RecId,
                    purchLine.InventTransId,
                    _transDate);

            fromTable = purchLine;
        }

        ttsbegin;
        _record.write();

        CustomsImportAssessableValue_IN::refreshMarkupTrans(fromTable, _record);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAssessableValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets AssessableValue from sum of InvoiceCIFAmount and LandingChargesPercentAmount.
    /// </summary>
    /// <returns>
    /// The Calculated AssessableValue for PurchaseOrder with Misc.Charges.
    /// </returns>
    display CustomsAmount_IN invoiceAssessableValue()
    {
        return (this.invoiceCIFAmount() + this.landingChargesPercentAmt());
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceCIFAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets invoice CIFAmount from sum of Amount and Value fields.
    /// </summary>
    /// <returns>
    /// The calculated invoice CIFAmount for selected PurchaseOrder.
    /// </returns>
    display CustomsAmount_IN invoiceCIFAmount()
    {
        return (this.Amount + this.Value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>landingChargesPercentAmt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets landingChargesPercentage Amount from invoiceCIFAmount and landingChargesPct.
    /// </summary>
    /// <returns>
    /// The calculated landingChargesPercentage Amount for selected PurchaseOrder.
    /// </returns>
    display CustomsAmount_IN landingChargesPercentAmt()
    {
        return this.invoiceCIFAmount() * (this.LandingChargesPct/100);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifys field.
    /// </summary>
    /// <param name="_fieldId">
    /// The field id.
    /// </param>
    public void modifiedField(fieldId _fieldId)
    {
        PurchLine   purchLine;

        super(_fieldId);
        switch (_fieldId)
        {
            case fieldnum(CustomsImportAssessableValue_IN, Basis):
                if (this.Basis == CustomsAssessableValueBasis_IN::CIF)
                {
                    this.Value = 0;
                }
                else
                {
                    purchLine   = PurchLine::findInventTransId(this.InventTransId);
                    if (purchLine.RecId)
                    {
                        this.Value = CustomsImportAssessableValue_IN::getMarkupValue(purchLine.TableId, purchLine.RecId, purchLine.InventTransId);
                    }
                }
                break;
            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomsAssessableValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// updates AssessableValue_IN value for PurchLine.
    /// </summary>
    public void updateCustomsAssessableValue()
    {
        PurchLine       purchLine;
        PurchLine_IN    purchLine_IN;

        ttsbegin;
        select firstOnly forUpdate purchLine_IN
            exists join purchLine
                where purchLine.RecId           == purchLine_IN.PurchLine
                    && purchLine.InventTransId  == this.InventTransId;
        purchLine_IN.AssessableValueTransactionCurrency = this.invoiceAssessableValue();
        purchLine_IN.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkupTotalValue</Name>
				<Source><![CDATA[
    private static Amount calcMarkupTotalValue(
        Amount         _amount,
        MarkupTrans    _markupTrans,
        tableId        _tableId,
        RecId          _recId,
        InventTransId  _inventTransId,
        TransDate      _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        Amount  markupTotalValue;
        Amount  notionalCharges;
        Amount  notionalAmount;
        Amount  miscChargeAmount;

        CurrencyCode    currencyCode;
        #DEFINE.ExchangeRateMultiplier(100)

        AmountMST               amountMSTLoc;
        CustomsExchangeRate_IN  customsExchangeRate;

        if (Global::mappingExists(tableNum(SalesPurchJournalLine), _tableId, fieldNum(SalesPurchJournalLine, CurrencyCode))
            && Global::mappingExists(tableNum(SalesPurchJournalLine), _tableId, fieldNum(SalesPurchJournalLine, SalesPurchQty)))
        {
            SalesPurchJournalLine salePurchJournalLine = SalesPurchJournalLine::findRecId(_tableId, _recId);
            currencyCode = salePurchJournalLine.CurrencyCode;

            if (_markupTrans.MarkupCategory == MarkupCategory::Percent)
            {
                if (_markupTrans.MarkUpAllocateAfter_IN == MarkupAllocateAfter::NetAmount)
                {
                    _markupTrans.Value = _amount ;
                }
                else if (_markupTrans.MarkUpAllocateAfter_IN == MarkupAllocateAfter::Qty)
                {
                    _markupTrans.Value = salePurchJournalLine.SalesPurchQty * _markupTrans.Value / 100;
                }
                else if (_markupTrans.MarkUpAllocateAfter_IN == MarkupAllocateAfter::Line)
                {
                    _markupTrans.Value = 1 * _markupTrans.Value / 100;
                }
            }
            else if (_markupTrans.MarkupCategory == MarkupCategory::Pcs)
            {
                _markupTrans.Value = salePurchJournalLine.SalesPurchQty * _markupTrans.Value;
            }
        }

        if (_tableId != tablenum(CustInvoiceTable))
        {
            customsExchangeRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN(
                                                            currencyCode,
                                                            Direction_IN::Import,
                                                            _transDate);

            if (customsExchangeRate && _markupTrans.CurrencyCode == Ledger::find(Ledger::current()).AccountingCurrency)
            {
                customsExchangeRate = customsExchangeRate / #ExchangeRateMultiplier;

                if (_markupTrans.CurrencyCode
                    && currencyCode
                    && _markupTrans.CurrencyCode != currencyCode
                    && _markupTrans.MarkupCategory != MarkupCategory::Percent)
                {
                    amountMSTLoc = CurrencyExchangeHelper::mstAmount(_markupTrans.Value, _markupTrans.CurrencyCode, _transDate, UnknownNoYes::Unknown, 0, 0, false);

                    markupTotalValue = (amountMSTLoc / customsExchangeRate);
                }
                else
                {
                    markupTotalValue = _markupTrans.Value;
                }
            }
            else
            {
                markupTotalValue = CurrencyExchangeHelper::curAmount2CurAmount(_markupTrans.Value, _markupTrans.CurrencyCode, currencyCode, _transDate);
            }
        }
        else
        {
            markupTotalValue = _markupTrans.Value;
        }

        notionalCharges = _markupTrans.NotionalPct_IN/100;

        if (_tableId == tableNum(PurchParmLine) && TaxIntegrationUtils::isChargeOnBOEEnabled())
        {
            notionalAmount = PurchParmLine::findRecId(_recId).LineAmount * notionalCharges;
        }
        else
        {
            notionalAmount = PurchLine::findInventTransId(_inventTransId).LineAmount * notionalCharges;
        }

        if (notionalAmount == 0)
        {
            miscChargeAmount = markupTotalValue;
        }
        else if (markupTotalValue == 0)
        {
            miscChargeAmount = notionalAmount;
        }
        else if (notionalAmount < markupTotalValue)
        {
            miscChargeAmount = notionalAmount;
        }
        else
        {
            miscChargeAmount = markupTotalValue;
        }

        return miscChargeAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkupTotalValueByBuffer</Name>
				<Source><![CDATA[
    private static Amount calcMarkupTotalValueByBuffer(
        Amount         _amount,
        MarkupTrans    _markupTrans,
        PurchLine      _buffer,
        TransDate      _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        Amount  markupTotalValue;
        Amount  notionalCharges;
        Amount  notionalAmount;
        Amount  miscChargeAmount;

        PurchLine       purchLine;
        CurrencyCode    currencyCode;
        InventTransId   inventTransId;
        #DEFINE.ExchangeRateMultiplier(100)

        AmountMST               amountMSTLoc;
        CustomsExchangeRate_IN  customsExchangeRate;

        if (_buffer.TableId == tableNum(PurchLine))
        {
            purchLine = _buffer;
            currencyCode = purchLine.currencyCode;

            if (_markupTrans.MarkupCategory == MarkupCategory::Percent)
            {
                if (_markupTrans.MarkUpAllocateAfter_IN == MarkupAllocateAfter::NetAmount)
                {
                    _markupTrans.Value = _amount;
                }
                if (_markupTrans.MarkUpAllocateAfter_IN == MarkupAllocateAfter::Qty)
                {
                    _markupTrans.Value = purchLine.PurchQty * _markupTrans.Value / 100;
                }
                if (_markupTrans.MarkUpAllocateAfter_IN == MarkupAllocateAfter::Line)
                {
                    _markupTrans.Value = 1 * _markupTrans.Value / 100;
                }
            }

            if (_markupTrans.MarkupCategory == MarkupCategory::Pcs)
            {
                _markupTrans.Value = purchLine.PurchQty * _markupTrans.Value;
            }

            customsExchangeRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN(
                                                            currencyCode,
                                                            Direction_IN::Import,
                                                            _transDate);

            if (customsExchangeRate && _markupTrans.CurrencyCode == Ledger::find(Ledger::current()).AccountingCurrency)
            {
                customsExchangeRate = customsExchangeRate / #ExchangeRateMultiplier;

                if (_markupTrans.CurrencyCode
                    && currencyCode
                    && _markupTrans.CurrencyCode != currencyCode
                    && _markupTrans.MarkupCategory != MarkupCategory::Percent)
                {
                    amountMSTLoc = CurrencyExchangeHelper::mstAmount(_markupTrans.Value, _markupTrans.CurrencyCode, _transDate, UnknownNoYes::Unknown, 0, 0, false);

                    markupTotalValue = (amountMSTLoc / customsExchangeRate);
                }
                else
                {
                    markupTotalValue = _markupTrans.Value;
                }
            }
            else
            {
                markupTotalValue = CurrencyExchangeHelper::curAmount2CurAmount(_markupTrans.Value, _markupTrans.CurrencyCode, currencyCode, _transDate);
            }

            notionalCharges = _markupTrans.NotionalPct_IN/100;

            notionalAmount  = purchLine.LineAmount * notionalCharges;

            if (notionalAmount == 0)
            {
                miscChargeAmount = markupTotalValue;
            }
            else if (markupTotalValue == 0)
            {
                miscChargeAmount = notionalAmount;
            }
            else if (notionalAmount < markupTotalValue)
            {
                miscChargeAmount = notionalAmount;
            }
            else
            {
                miscChargeAmount = markupTotalValue;
            }
        }

        return miscChargeAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the CustomsImportAssessableValue_IN table for the specified record id.
    /// </summary>
    /// <param name="_recId">
    /// The unique record id to find.
    /// </param>
    /// <param name="_forupdate">
    /// If true, then read the record for updating.
    /// </param>
    /// <param name="_concurrencyModel">
    /// An optional value used when the table is not automatically concurrent.
    /// </param>
    /// <returns>
    /// A buffer containing CustomsImportAssessableValue_IN table.
    /// </returns>
    public static CustomsImportAssessableValue_IN find(
        RefRecId            _recId,
        boolean             _forupdate          = false,
        ConcurrencyModel    _concurrencyModel   = ConcurrencyModel::Auto)
    {
        CustomsImportAssessableValue_IN customsImportAssessableValue;

        customsImportAssessableValue.selectForUpdate(_forupdate);
        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            customsImportAssessableValue.concurrencyModel(_concurrencyModel);
        }

        select firstonly customsImportAssessableValue
            where customsImportAssessableValue.RecId == _recId;

        return customsImportAssessableValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the CustomsImportAssessableValue_IN table for the specified InventTransId.
    /// </summary>
    /// <param name="inventTransId">
    /// The InventTransId of the selected PurchaseOrder line.
    /// </param>
    /// <param name="update">
    /// if true, select record for update.
    /// </param>
    /// <returns>
    /// The selected CustomsImportAssessableValue_IN record.
    /// </returns>
    public static CustomsImportAssessableValue_IN findInventTransId(
        InventTransId   inventTransId,
        boolean         update = false)
    {
        CustomsImportAssessableValue_IN customsImportAssessableValue;

        if (inventTransId)
        {
            customsImportAssessableValue.selectForUpdate(update);

            select firstonly customsImportAssessableValue
                where customsImportAssessableValue.InventTransId == inventTransId;
        }

        return customsImportAssessableValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the MarkupValue for specified source tableId, recId and InventTransId.
    /// </summary>
    /// <param name="_tableId">
    /// TableId of the transaction table where Misc.Charges are attached.
    /// </param>
    /// <param name="_recId">
    /// RecId of the transaction table where Misc.Charges are attached.
    /// </param>
    /// <param name="_inventTransId">
    /// InventTransId of the transaction table where Misc.Charges are attached.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date
    /// </param>
    /// <returns>
    /// Misc. Charges attached for the transactionLine.
    /// </returns>
    public static MarkupValue getMarkupValue(
        tableId        _tableId,
        RecId          _recId,
        InventTransId  _inventTransId,
        TransDate      _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        MarkupTrans                     markupTrans;
        CustomsImportAssessableValue_IN customsImportAssessableValue;
        Amount                          miscChargeAmount;

        while select markupTrans
            where markupTrans.TransTableId       == _tableId
               && markupTrans.TransRecId         == _recId
               && markupTrans.NotionalCharges_IN == NoYes::Yes
               && markupTrans.Value              >=  0
        {
            customsImportAssessableValue = CustomsImportAssessableValue_IN::findInventTransId(_inventTransId);
            if (!customsImportAssessableValue.RecId)
            {
                miscChargeAmount += CustomsImportAssessableValue_IN::calcMarkupTotalValue((PurchLine::findInventTransId(_inventTransId).LineAmount * markupTrans.Value) / 100,
                                                                                           markupTrans,
                                                                                           _tableId,
                                                                                           _recId,
                                                                                           _inventTransId,
                                                                                           _transDate);
            }
            else
            {
                miscChargeAmount += CustomsImportAssessableValue_IN::calcMarkupTotalValue((customsImportAssessableValue.Amount * markupTrans.Value) / 100,
                                                                                           markupTrans,
                                                                                           _tableId,
                                                                                           _recId,
                                                                                           _inventTransId,
                                                                                           _transDate);
            }
        }

        return miscChargeAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupValueByBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the MarkupValue for related purchLine.
    /// </summary>
    /// <param name="_buffer">
    /// The buffer of purchLine record where Misc.Charges are attached.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    /// <returns>
    /// Misc. Charges attached for the purchLine.
    /// </returns>
    public static MarkupValue getMarkupValueByBuffer(
        PurchLine      _buffer,
        TransDate      _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        MarkupTrans                     markupTrans;
        CustomsImportAssessableValue_IN customsImportAssessableValue;
        Amount                          miscChargeAmount;
        PurchLine                       purchLine;

        if (_buffer.TableId == tableNum(PurchLine))
        {
            purchLine = _buffer;
            while select markupTrans
                where markupTrans.TransTableId       == purchLine.TableId
                   && markupTrans.TransRecId         == purchLine.RecId
                   && markupTrans.NotionalCharges_IN == NoYes::Yes
                   && markupTrans.Value              >=  0
            {
                customsImportAssessableValue = CustomsImportAssessableValue_IN::findInventTransId(purchLine.InventTransId);
                if (!customsImportAssessableValue.RecId)
                {
                    miscChargeAmount += CustomsImportAssessableValue_IN::calcMarkupTotalValueByBuffer(purchLine.LineAmount * markupTrans.Value / 100,
                                                                                               markupTrans,
                                                                                               _buffer,
                                                                                               _transDate);
                }
                else
                {
                    miscChargeAmount += CustomsImportAssessableValue_IN::calcMarkupTotalValueByBuffer((customsImportAssessableValue.Amount * markupTrans.Value) / 100,
                                                                                               markupTrans,
                                                                                               _buffer,
                                                                                               _transDate);
                }
            }
        }
        return miscChargeAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateAssessableValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// recalulates assessable value when the BillOfEntry date/Bill of Entry number is modified.
    /// </summary>
    /// <param name="_purchParmTable">
    /// The PurchParmTable for which assessableValue is recalculated based on BillOfEntry date.
    /// </param>
    // This method is recalculates the PurchParmLine assessable value when the BillOfEntry date/Bill of entry number
    // is modified. This is a bug fix for wrong consideration of session date in the assessable value calculation.
    public static void recalculateAssessableValue(PurchParmTable _purchParmTable)
    {
        PurchLine                       purchLineLoc;
        CustomsImportAssessableValue_IN customsImportAssessableValue;
        Query                           query = new Query();
        QueryBuildDataSource            queryBuildDataSource;
        QueryBuildRange                 queryBuildRange;
        PurchParmLine                   purchParmLineCopy;
        PurchParmLine                   purchParmLineLoc;
        PurchParmLine_IN                purchParmLineIN;
        SysQueryRun                     queryRun;
        RealBase                        factor;

        while select purchParmLineLoc
            where purchParmLineLoc.ParmId     == _purchParmTable.ParmId &&
                  purchParmLineLoc.TableRefId == _purchParmTable.TableRefId
        notexists join customsImportAssessableValue
            where customsImportAssessableValue.InventTransId == purchParmLineLoc.InventTransId
        {
            customsImportAssessableValue.initFromPurchParmLine(purchParmLineLoc, _purchParmTable.TransDate);
        }

        if (_purchParmTable.CustomsImportInvoiceNumberTable_IN)
        {
            queryBuildDataSource    = query.addDataSource(tablenum(CustomsImportAssessableValue_IN));
            queryBuildRange         = queryBuildDataSource.addRange(fieldnum(CustomsImportAssessableValue_IN, PurchId));
            queryBuildRange.value(_purchParmTable.PurchId);

            while select ParmId, TableRefId, InventTransId from purchParmLineCopy
                where purchParmLineCopy.ParmId      == _purchParmTable.ParmId   &&
                      purchParmLineCopy.TableRefId  == _purchParmTable.TableRefId
            {
                queryBuildRange         = queryBuildDataSource.addRange(fieldnum(CustomsImportAssessableValue_IN, InventTransId));
                queryBuildRange.value(purchParmLineCopy.InventTransId);
            }

            queryRun = new SysQueryRun(query);
            while (queryRun.next())
            {
                customsImportAssessableValue = queryRun.get(tablenum(CustomsImportAssessableValue_IN));
                purchParmLineLoc = PurchParmLine::findInventTransId_IN(_purchParmTable.ParmId, _purchParmTable.TableRefId, customsImportAssessableValue.InventTransId);

                if (purchParmLineLoc.RecId)
                {
                    purchLineLoc = PurchLine::findInventTransId(purchParmLineLoc.InventTransId);
                    factor = purchParmLineLoc.ReceiveNow/purchLineLoc.PurchQty;
                    ttsbegin;
                    customsImportAssessableValue.selectForUpdate(true);
                    customsImportAssessableValue.Amount = purchParmLineLoc.LineAmount;
                    if (customsImportAssessableValue.Basis == CustomsAssessableValueBasis_IN::FOB)
                    {
                        if (TaxIntegrationUtils::isChargeOnBOEEnabled())
                        {
                            customsImportAssessableValue.Value  = CustomsImportAssessableValue_IN::getMarkupValue(purchParmLineLoc.TableId, purchParmLineLoc.RecId, purchParmLineLoc.InventTransId, _purchParmTable.TransDate);
                        }
                        else
                        {
                            customsImportAssessableValue.Value  = factor * CustomsImportAssessableValue_IN::getMarkupValue(purchLineLoc.TableId, purchLineLoc.RecId, purchLineLoc.InventTransId, _purchParmTable.TransDate);
                        }
                    }
                    else
                    {
                        customsImportAssessableValue.Value  = 0;
                    }

                    purchParmLineLoc.selectForUpdate(true);
                    purchParmLineIN = purchParmLineLoc.purchParmLine_IN();
                    if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                    {
                        if (TaxIntegrationUtils::isChargeOnBOEEnabled())
                        {
                            purchParmLineIN.AssessableValueTransactionCurrency = purchParmLineLoc.getMiscChargesAmount_IN(purchParmLineLoc.TableId, purchParmLineLoc.RecId, _purchParmTable.Ordering);
                        }
                        else
                        {
                            purchParmLineIN.AssessableValueTransactionCurrency = purchParmLineLoc.getMiscChargesAmount_IN(purchLineLoc.TableId, purchLineLoc.RecId, _purchParmTable.Ordering);
                        }
                    }
                    else
                    {
                        purchParmLineIN.AssessableValueTransactionCurrency = ((customsImportAssessableValue.Amount + customsImportAssessableValue.Value) * (1 + (customsImportAssessableValue.LandingChargesPct/100)));
                    }
                    purchParmLineIN.AssessableValueAccountingCurrency = TaxAssessableValueHandler_IN::calcAssessableValueAccountingCurrency(purchParmLineIN.AssessableValueTransactionCurrency, purchParmLineLoc.currencyCode, _purchParmTable.TransDate);
                    purchParmLineLoc.packPurchParmLine_IN(purchParmLineIN);
                    purchParmLineLoc.sysextensionserializermap::PostUpdate();
                    customsImportAssessableValue.update();
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupValueForCurrencySameWithAccounting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gests the markup value for the markupTrans's currency same with accounting currency.
    /// </summary>
    /// <param name = "_markupAmount">The markup amount.</param>
    /// <param name = "_markupCurrencyCode">The markup currency code.</param>
    /// <param name = "_parentCurrencyCode">The parent currency code.</param>
    /// <param name = "_transDate">The transaction date.</param>
    /// <returns>The markup amount.</returns>
    public static MarkupAmount getMarkupValueForCurrencySameWithAccounting(
        MarkupAmount    _markupAmount,
        CurrencyCode    _markupCurrencyCode,
        CurrencyCode    _parentCurrencyCode,
        TransDate       _transDate)
    {
        MarkupAmount markupAmount;

        CustomsExchangeRate_IN customsExchangeRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN(
            _parentCurrencyCode,
            Direction_IN::Import,
            _transDate);

        if (customsExchangeRate)
        {
            markupAmount = CurrencyExchangeHelper::mstAmount(_markupAmount, _parentCurrencyCode, _transDate, UnknownNoYes::Unknown, customsExchangeRate, 0, false);

        }
        else
        {
            markupAmount = CurrencyExchangeHelper::curAmount2CurAmount(_markupAmount, _parentCurrencyCode, _markupCurrencyCode, _transDate);
        }

        return markupAmount;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<CountryRegionCodes>IN</CountryRegionCodes>
	<DeveloperDocumentation>@GLS64157</DeveloperDocumentation>
	<Label>@GLS5298</Label>
	<TitleField1>PurchId</TitleField1>
	<TitleField2>Basis</TitleField2>
	<CacheLookup>Found</CacheLookup>
	<ClusteredIndex>RecId</ClusteredIndex>
	<Modules>AccountsReceivable</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<ReplacementKey>TransIdIdx</ReplacementKey>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>MarkupTrans</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>MarkupTrans</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Value</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Basis</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Amount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PurchId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Customs</Name>
			<Label>@GLS5007</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Amount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Basis</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Value</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LandingChargesPct</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Misc</Name>
			<Label>@SYS80069</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Amount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustomsAmount_IN</ExtendedDataType>
			<Label>@SYS6901</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Basis</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CustomsAssessableValueBasis_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InventTransId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LandingChargesPct</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Percent</ExtendedDataType>
			<Label>@GLS5755</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PurchId</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>PurchIdBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Value</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>MarkupValue</ExtendedDataType>
			<Label>@SYS8371</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TransIdIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOrigin</Name>
			<Cardinality>ZeroOne</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransId</Name>
					<SourceEDT>InventTransId</SourceEDT>
					<Field>InventTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventTransIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PurchLine</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>PurchLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransId</Name>
					<Field>InventTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PurchTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>PurchTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PurchId</Name>
					<SourceEDT>PurchIdBase</SourceEDT>
					<Field>PurchId</Field>
					<RelatedField>PurchId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>PurchIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>