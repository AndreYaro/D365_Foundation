<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ReqTrans extends common
{

    #localmacro.updateBOMIdRouteId
        update_recordSet reqTrans
            setting #ifnot.empty(%1) itemBOMId = salesLine.ItemBOMId #endif
                    #ifnot.empty(%2) #ifnot.empty(%1), #endif itemRouteId = salesLine.ItemRouteId #endif
            where reqTrans.PlanVersion    == _reqPlanData.parmReqPlanVersionRefRecId()
               && reqTrans.RefType        == ReqRefType::Sales
               && reqTrans.ItemId         == itemId
               && reqTrans.CovInventDimId == covDimId
            join TableId from inventTransOriginSalesLine
                where inventTransOriginSalesLine.InventTransOrigin == reqTrans.InventTransOrigin
            join ItemBOMId,ItemRouteId from salesLine
                where salesLine.InventTransId == inventTransOriginSalesLine.SalesLineInventTransId
                   && salesLine.DataAreaId    == inventTransOriginSalesLine.SalesLineDataAreaId;
            
        update_recordSet reqTrans
            setting #ifnot.empty(%1) itemBOMId = purchLine.ItemBOMId #endif
                    #ifnot.empty(%2) #ifnot.empty(%1), #endif itemRouteId = purchLine.ItemRouteId #endif
            where reqTrans.PlanVersion    == _reqPlanData.parmReqPlanVersionRefRecId()
               && reqTrans.RefType        == ReqRefType::Purch
               && reqTrans.ItemId         == itemId
               && reqTrans.CovInventDimId == covDimId
            join TableId from inventTransOriginPurchline
                where inventTransOriginPurchline.InventTransOrigin == reqTrans.InventTransOrigin
            join ItemBOMId,ItemRouteId from Purchline
                where purchline.InventTransId == inventTransOriginPurchline.PurchlineInventTransId
                   && purchline.DataAreaId    == inventTransOriginPurchline.PurchlineDataAreaId;

        update_recordSet reqTrans
            setting #ifnot.empty(%1) itemBOMId = prodTable.BOMId #endif
                    #ifnot.empty(%2) #ifnot.empty(%1), #endif itemRouteId = prodTable.RouteId #endif
            where reqTrans.PlanVersion    == _reqPlanData.parmReqPlanVersionRefRecId()
               && reqTrans.RefType        == ReqRefType::Production
               && reqTrans.ItemId         == itemId
               && reqTrans.CovInventDimId == covDimId
            join TableId from inventTransOriginProdTable
                where inventTransOriginProdTable.InventTransOrigin == reqTrans.InventTransOrigin
            join BOMId, RouteId from ProdTable
                where ProdTable.ProdId     == inventTransOriginProdTable.ProdOrderId
                   && ProdTable.DataAreaId == inventTransOriginProdTable.ProdOrderDataAreaId;

        update_recordSet reqTrans
            setting #ifnot.empty(%1) itemBOMId = prodBOM.ItemBOMId #endif
                    #ifnot.empty(%2) #ifnot.empty(%1), #endif itemRouteId = prodBOM.ItemRouteId #endif
            where reqTrans.PlanVersion    == _reqPlanData.parmReqPlanVersionRefRecId()
               && reqTrans.RefType        == ReqRefType::ProdLine
               && reqTrans.ItemId         == itemId
               && reqTrans.CovInventDimId == covDimId
            join TableId from inventTransOriginProdBOM
                where inventTransOriginProdBOM.InventTransOrigin == reqTrans.InventTransOrigin
            join ItemBOMId,ItemRouteId from ProdBOM
                where ProdBOM.InventTransId == inventTransOriginProdBOM.ProdBOMInventTransId
                   && ProdBOM.DataAreaId    == inventTransOriginProdBOM.ProdBOMDataAreaId;
        
        // Update bom/route information of blocking receipt reqTrans from its original blocked source receipt reqTrans
        update_recordSet reqTrans
            setting #ifnot.empty(%1) itemBOMId = reqTransReceiptSource.ItemBOMId #endif
                    #ifnot.empty(%2) #ifnot.empty(%1), #endif itemRouteId = reqTransReceiptSource.ItemRouteId #endif
            where reqTrans.PlanVersion    == _reqPlanData.parmReqPlanVersionRefRecId()
               && reqTrans.RefType        == ReqRefType::InventJournal
               && reqTrans.ItemId         == itemId
               && reqTrans.CovInventDimId == covDimId
               && reqTrans.Direction      == InventDirection::Receipt
            join TableId from inventTransOriginBlockingReceipt
                where inventTransOriginBlockingReceipt.InventTransOrigin == reqTrans.InventTransOrigin
            join TableId from inventTransOriginBlockingIssue
                where inventTransOriginBlockingIssue.InventBlockingIssue == inventTransOriginBlockingReceipt.InventBlockingReceipt
            join TableId from inventTransOriginBlockingReceiptOrigin
                where inventTransOriginBlockingReceiptOrigin.RecId == inventTransOriginBlockingReceipt.InventTransOrigin
            join TableId from reqTransIssueBlocking
                where reqTransIssueBlocking.InventTransOrigin == InventTransOriginBlockingIssue.InventTransOrigin
                   && reqTransIssueBlocking.PlanVersion       == _reqPlanData.parmReqPlanVersionRefRecId()
                   && reqTransIssueBlocking.RefType           == ReqRefType::InventJournal
                   && reqTransIssueBlocking.RefId             == inventTransOriginBlockingReceiptOrigin.ReferenceId
                   && reqTransIssueBlocking.ItemId            == itemId
                   && reqTransIssueBlocking.CovInventDimId    == covDimId
            join TableId from inventTransOriginSourceReceipt
                where inventTransOriginSourceReceipt.RecId == reqTransIssueBlocking.MarkingRefInventTransOrigin
            join ItemBOMId, ItemRouteId from reqTransReceiptSource
                where reqTransReceiptSource.InventTransOrigin           == reqTransIssueBlocking.MarkingRefInventTransOrigin
                   && reqTransReceiptSource.RefId                       == inventTransOriginSourceReceipt.ReferenceId
                   && reqTransReceiptSource.MarkingRefInventTransOrigin == reqTransIssueBlocking.InventTransOrigin
                   && reqTransReceiptSource.PlanVersion                 == _reqPlanData.parmReqPlanVersionRefRecId()
                   && reqTransReceiptSource.ItemId                      == itemId
                   && reqTransReceiptSource.CovInventDimId              == covDimId;

        #ifnot.empty(%1)
        update_recordSet reqTrans
            setting itemBOMId = kanban.BOMId
            where reqTrans.PlanVersion    == _reqPlanData.parmReqPlanVersionRefRecId()
               && reqTrans.RefType        == ReqRefType::Kanban
               && reqTrans.ItemId         == itemId
               && reqTrans.CovInventDimId == covDimId
            join TableId from inventTransOriginKanbanJobProcess
                where inventTransOriginKanbanJobProcess.InventTransOrigin == reqTrans.InventTransOrigin
            join TableId from kanbanJob
                where kanbanJob.RecId == inventTransOriginKanbanJobProcess.KanbanJob
            join BOMId from kanban
                where kanban.RecId == kanbanJob.Kanban
                   && kanban.Type  == LeanKanbanType::Manufacturing;

        update_recordSet reqTrans
            setting itemBOMId = kanban.BOMId
            where reqTrans.PlanVersion    == _reqPlanData.parmReqPlanVersionRefRecId()
               && reqTrans.RefType        == ReqRefType::Kanban
               && reqTrans.ItemId         == itemId
               && reqTrans.CovInventDimId == covDimId
            join TableId from inventTransOriginKanbanJobTrsReceipt
                where inventTransOriginKanbanJobTrsReceipt.InventTransOrigin == reqTrans.InventTransOrigin
            join TableId from kanbanJob
                where kanbanJob.RecId == inventTransOriginKanbanJobTrsReceipt.KanbanJob
            join BOMId from kanban
                where kanban.RecId == kanbanJob.Kanban
                   && kanban.Type  == LeanKanbanType::Manufacturing;

        update_recordSet reqTrans
            setting itemBOMId = kanban.BOMId
            where reqTrans.PlanVersion    == _reqPlanData.parmReqPlanVersionRefRecId()
               && reqTrans.RefType        == ReqRefType::Kanban
               && reqTrans.ItemId         == itemId
               && reqTrans.CovInventDimId == covDimId
            join TableId from inventTransOriginKanbanJobWIP
                where inventTransOriginKanbanJobWIP.InventTransOrigin == reqTrans.InventTransOrigin
            join TableId from kanbanJob
                where kanbanJob.RecId == inventTransOriginKanbanJobWIP.KanbanJob
            join BOMId from kanban
                where kanban.RecId == kanbanJob.Kanban
                   && kanban.Type  == LeanKanbanType::Manufacturing;
            
        #endif
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>actionAdvancePostpone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the advance, postpone or cancel icon based on the action type.
    /// </summary>
    /// <returns>
    /// The relevant icon; otherwise, an empty image.
    /// </returns>
    display ImageRes actionAdvancePostpone()
    {
        #ResAppl

        ImageRes    ret = #ImageBlank2;

        if ( this.ActionMarked )
        {
            switch (this.ActionType)
            {
                case ActionType::Advance            :
                case ActionType::AdvanceAppreciate  :
                case ActionType::AdvanceDepreciate  :
                    ret = #ImageReqTransAdvance;
                    break;

                case ActionType::Postpone           :
                case ActionType::PostponeAppreciate :
                case ActionType::PostponeDepreciate :
                    ret = #ImageReqTransPostPone;
                    break;

                case ActionType::Cancel             :
                    ret = #ImageReqTransCancel;
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionIncreaseDecrease</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the increase, decrease or cancel icon based on the action type.
    /// </summary>
    /// <returns>
    /// The relevant icon; otherwise, an empty image.
    /// </returns>
    display ImageRes actionIncreaseDecrease()
    {
        #ResAppl

        ImageRes    ret = #ImageBlank2;

        if (this.ActionMarked)
        {
            switch (this.ActionType)
            {
                case ActionType::Appreciate         :
                case ActionType::AdvanceAppreciate  :
                case ActionType::PostponeAppreciate :
                    ret = #ImageReqTransIncrease;
                    break;

                case ActionType::Depreciate         :
                case ActionType::AdvanceDepreciate  :
                case ActionType::PostponeDepreciate :
                    ret = #ImageReqTransDecrease;
                    break;

                case ActionType::Cancel             :
                    ret = #ImageReqTransCancel;
                    break;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the final requirement quantity of the current <c>ReqTrans</c> record if the action message is accepted.
    /// </summary>
    /// <returns>
    /// A real value that holds the new requirement quantity.
    /// </returns>
    public ActionQty actionSum()
    {
        return this.Qty + this.ActionQtyAdd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCov</Name>
				<Source><![CDATA[
    void addCov(ReqTransCov _reqTransCov)
    {
        if (this.Direction == InventDirection::Receipt || this.Qty >= 0)
        {
            this.CovQty += -_reqTransCov.Qty;
        }
        else
        {
            this.CovQty +=  _reqTransCov.Qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs a <c>BOMTypeBase</c> derived object based on the bom type of the current record.
    /// </summary>
    /// <returns>
    ///    A new <c>BOMTypeBase</c> object.
    /// </returns>
    public BOMTypeBase bomType()
    {
        return BOMTypeBase::construct(this.bomType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheKey</Name>
				<Source><![CDATA[
    public str cacheKey()
    {
        return ReqTransCache::itemDimId2cachekey(this.ItemId,this.CovInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcFuturesDaysFromDerived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the highest number of the futures days for the derived requirement transactions.
    /// </summary>
    /// <returns>
    /// An integer value that holds the number of the futures days.
    /// </returns>
    public FuturesDays calcFuturesDaysFromDerived()
    {
        ReqTrans    reqTrans;

        if (this.RefId
            && (this.RefType == ReqRefType::PmfCoProduct || ReqTrans::derivedRefType(this.RefType) != ReqRefType::None))
        {
            select maxof(FuturesDays) from reqTrans
                where reqTrans.PlanVersion == this.PlanVersion
                   && (( this.RefType == ReqRefType::PmfCoProduct && reqTrans.RefType == ReqRefType::PmfPlannedProdBatch)
                      || reqTrans.RefType == ReqTrans::derivedRefType(this.RefType))
                   && reqTrans.RefId == this.RefId;
        }

        return reqTrans.FuturesDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcFuturesDaysReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of the futures days for the current requirement transaction.
    /// </summary>
    /// <param name="_todaysDate">
    /// A date that represents the current date.
    /// </param>
    /// <param name="_includeDerivedFutureDays">
    /// A Boolean value that indicates whether the futures days from the derived requirement transactions
    /// must be included.
    /// </param>
    /// <param name="_orderDate">
    /// A date that indicates the order date for the requirement transaction; optional.
    /// </param>
    /// <returns>
    /// The number of the futures days.
    /// </returns>
    public FuturesDays calcFuturesDaysReceipt(
        TransDate   _todaysDate,
        boolean     _includeDerivedFutureDays,
        TransDate   _orderDate = dateNull())
    {
        ProdTable       prodTable;
        KanbanJob       kanbanJob;

        TransDate       orderDate;
        FuturesDays     futuresDays;
        FuturesDays     futuresDaysDerived;

        if (! this.isReceipt())
        {
            return 0;
        }

        if (prmisDefault(_orderDate))
        {
            switch (this.RefType)
            {
                case ReqRefType::Production:
                    prodTable       = ProdTable::find(this.RefId);
                    if (prodTable
                        && prodTable.status().isBefore(ProdStatus::StartedUp))
                    {
                        orderDate = prodTable.SchedStart;
                    }
                    break;

                case ReqRefType::Kanban:
                    kanbanJob = this.kanbanJob();
                    if (   kanbanJob
                        && kanbanJob.Status < LeanKanbanJobStatus::InProgress)
                    {
                        orderDate = kanbanJob.scheduledPeriodDate();
                    }
                    break;

                default:
                    if (this.isPlannedOrder())
                    {
                        orderDate = this.reqPo().ReqDateOrder;
                    }
            }
        }
        else
        {
            orderDate = _orderDate;
        }

        orderDate = orderDate ? orderDate : this.ReqDate;

        futuresDays     = _todaysDate - orderDate;
        futuresDays     = max(0,futuresDays);

        if (_includeDerivedFutureDays)
        {
            futuresDaysDerived  = this.calcFuturesDaysFromDerived();
            futuresDays         = max(futuresDaysDerived,futuresDays);
        }

        return futuresDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMaxFuturesDateFromDerived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the latest futures date of the derived requirement transactions.
    /// </summary>
    /// <returns>
    /// The latest futures date of the derived requirement transactions.
    /// </returns>
    public FuturesDate calcMaxFuturesDateFromDerived()
    {
        ReqTrans    reqTrans;
        reqTrans = this.derivedTransWithMaxFuturesDateTime();

        return reqTrans.FuturesDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeFirmed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the requirement can be firmed.
    /// </summary>
    /// <returns>
    ///    true if the planned order can be firmed; otherwise, false.
    /// </returns>
    public boolean canBeFirmed()
    {
        return    this.IsDerivedDirectly == NoYes::No
               && this.isPlannedOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeMarked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the requirement can be marked.
    /// </summary>
    /// <param name="_reqMarkUpdate">
    ///    An enumeration value that specifies how marking is performed.
    /// </param>
    /// <returns>
    ///    true if the requirement can be marked; otherwise, false.
    /// </returns>
    public boolean canBeMarked(ReqMarkUpdate _reqMarkUpdate)
    {
        return this.CovQty && this.InventTransOrigin && this.checkSingleLevelMarking(_reqMarkUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSingleLevelMarking</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the requirement can be marked if single level marking policy is enabled and chosen.
    /// </summary>
    /// <param name="_reqMarkUpdate">
    ///    An enumeration value that specifies how marking is performed.
    /// </param>
    /// <returns>
    ///    true if the requirement can be marked according to single level marking options; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     This method identifies whether mark the production orders derived directly from the triggering requirement,
    ///     but doesn't mark orders for the related production materials.
    /// </remarks>
    private boolean checkSingleLevelMarking(ReqMarkUpdate _reqMarkUpdate)
    {
        if (_reqMarkUpdate != ReqMarkUpdate::SingleLevelStandard 
            && _reqMarkUpdate != ReqMarkUpdate::SingleLevelExtended)
        {
            return true;
        }

        if (this.RefType == ReqRefType::BOMLine || this.RefType == ReqRefType::ProdLine)
        {
            return false;
        }

        if (ReqTransSingleLevelMarkingAllowBOMFlight::instance().isEnabled())
        {   
            return true;
        }
        else
        {
            ReqTrans reqTransSettled;
            ReqTransCov reqTransCov;

            select forceselectorder firstonly RecId from reqTransCov
                where reqTransCov.ReceiptRecId == this.RecId
                   && reqTransCov.PlanVersion == this.PlanVersion
                   && reqTransCov.ItemId == this.ItemId
            exists join reqTransSettled
                where reqTransSettled.RecId == reqTransCov.IssueRecId
                  && (reqTransSettled.RefType == ReqRefType::BOMLine ||
                      reqTransSettled.RefType == ReqRefType::ProdLine);

            return !reqTransCov.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Marks inventory transactions according to how the coverage is performed.
    /// </summary>  
    /// <param name="_reqMarkUpdate">
    ///    An enumeration value that specifies how marking is performed.
    /// </param>
    /// <returns>
    ///    The marked quantity.
    /// </returns>
    public InventQty markCoverage(ReqMarkUpdate _reqMarkUpdate)
    {
        InventQty markqtyUpd;

        ttsbegin;

        Map mapMovement = new Map(Types::Int64,Types::Class);
        InventTransOriginId reqTransInventTransOriginId = this.InventTransOrigin;

        ReqTransCov reqTransCov = this.selectCovJoinTrans(true);
        ReqTrans reqTransSettled = reqTransCov.joinChild() as ReqTrans;

        while (reqTransCov.RecId)
        {
            InventTransOriginId reqTransSettledInventTransOriginId = reqTransSettled.InventTransOrigin;

            if (reqTransCov.Qty != 0 && reqTransSettledInventTransOriginId)
            {
                InventQty markNow = reqTransSettled.Qty > 0 ? abs(reqTransCov.Qty) : -abs(reqTransCov.Qty);
                PdsCWInventQty cwMarkQty = reqTransSettled.Qty > 0 ? abs(reqTransCov.pdsCWSettled()) : -abs(reqTransCov.pdsCWSettled());

                if (reqTransSettled.Qty < 0)
                {
                    InventTransIdSum inventTransSum = InventTransIdSum::newTransOriginId(reqTransSettledInventTransOriginId);
                    InventQty availForMarkingQty = inventTransSum.onOrder() + inventTransSum.reserveOrdered();
                    PdsCWQty availForMarkingCWQty = inventTransSum.pdsCWOnOrder() + inventTransSum.pdsCWReserveOrdered();

                    // We do not want to mark order lines which were processed (reserved, picked, e.t.c) since the MRP run took place. Otherwise, unexpected side effects may happen. E.g. the warehouse worker may not be able to complete warehouse work for the issue.
                    if (abs(availForMarkingQty) < abs(markNow))
                    {
                        markNow = -abs(availForMarkingQty);
                        cwMarkQty = -abs(availForMarkingCWQty);
                    }
                }

                markNow = decRound(markNow, UnitOfMeasure::findBySymbol(InventTable::find(reqTransCov.ItemId).inventUnitId()).DecimalPrecision);

                markNow = InventTransOrigin::updateMarking(reqTransSettledInventTransOriginId, reqTransInventTransOriginId, markNow, '', SortOrder::Descending,
                                                            false, null, null, cwMarkQty);

                if (markNow)
                {
                    if (!mapMovement.exists(reqTransSettledInventTransOriginId))
                    {
                        mapMovement.insert(reqTransSettledInventTransOriginId, InventMovement::newReqTrans(reqTransSettled));
                    }
                }

                markNow = InventTransOrigin::updateMarking(reqTransInventTransOriginId, reqTransSettledInventTransOriginId, markNow, '', SortOrder::Descending,
                                                            false, null, null, cwMarkQty);

                markqtyUpd += markNow;

                if (markNow)
                {
                    if (!mapMovement.exists(reqTransInventTransOriginId))
                    {
                        mapMovement.insert(reqTransInventTransOriginId, InventMovement::newReqTrans(this));
                    }
                }
            }
            next reqTransCov;
        }

        if (mapMovement.elements())
        {
            MapIterator mi = new MapIterator(mapMovement);
            mi.begin();
            while (mi.more())
            {
                InventMovement movement = mapMovement.lookup(mi.key());
                if (movement && movement.transIdSum().estimatedIssue() != 0)
                {
                    InventUpd_Reservation::updateReserveRefTransId(movement);
                }
                mi.next();
            }

            InventTrans::updateInventRefFields(mapMovement,_reqMarkUpdate);
        }

        ttscommit;

        return markqtyUpd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>compareIntercompanyValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the values of the fields essential for the intercompany demand are the same.
    /// </summary>
    /// <param name="_reqTrans">
    /// The intercompany demand record to compare with.
    /// </param>
    /// <returns>
    /// true if the field values are identical; otherwise, false.
    /// </returns>
    public boolean compareIntercompanyValues(ReqTrans _reqTrans)
    {
        return this.ItemId          == _reqTrans.ItemId
            && this.CovInventDimId  == _reqTrans.CovInventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRoute</Name>
				<Source><![CDATA[
    public void createRoute(ReqPlanData _reqPlanData)
    {
        Route               route;
        RouteOpr            routeOpr;

        RouteSearch         routeSearch;
        ReqRoute            reqRoute;

        RecordInsertList    recordInsertList;

        if (!this.ItemRouteId)
        {
            return;
        }

        routeSearch      = RouteSearch_Level::newRouteData(this.ItemRouteId);
        while (routeSearch.next())
        {
            route           = routeSearch.route();
            routeOpr        = route.routeOpr(this.ItemId, this.inventDim().ConfigId, this.inventDim().InventSiteId, routeOpr);

            if (routeOpr.RecId && route.OprNum)
            {
                reqRoute.clear();
                reqRoute.PlanVersion            = this.PlanVersion;

                reqRoute.RefId                = this.RefId;
                reqRoute.OprNum               = route.OprNum;
                reqRoute.OprId                = routeOpr.OprId;
                reqRoute.OprPriority          = route.OprPriority;
                reqRoute.RouteRefRecId        = route.RecId;
                reqRoute.RouteOprRefRecId     = routeOpr.RecId;
                reqRoute.OprNumNext           = route.OprNumNext;
                reqRoute.AccError             = route.AccError;
                reqRoute.Level                = route.Level;
                reqRoute.ErrorPct             = route.ErrorPct;

                reqRoute.LinkType             = route.LinkType;

                if (_reqPlanData && _reqPlanData.useInsertList())
                {
                    if (! recordInsertList)
                    {
                        recordInsertList = new RecordInsertList(tableNum(ReqRoute),true);
                    }

                    recordInsertList.add(reqRoute);
                }
                else
                {
                    reqRoute.insert();
                }
            }
        }
        if (recordInsertList)
        {
            recordInsertList.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a derived requirement transaction for the planned transfer order.
    /// </summary>
    /// <param name="_reqPO">
    /// A <c>ReqPO</c> record that represents a planned transfer order.
    /// </param>
    /// <param name="_reqPlanData">
    /// An instance of the <c>ReqPlanData</c> class that holds master scheduling settings.
    /// </param>
    /// <param name="_fromInventLocationId">
    /// A string value that holds the from location ID.
    /// </param>
    [Replaceable]
    public void createTransferDemand(
        ReqPO               _reqPO,
        ReqPlanData         _reqPlanData            = null,
        InventLocationId    _fromInventLocationId   = '')
    {
        ReqTrans transferDemand;

        _reqPlanData = this.initializeReqPlan(_reqPlanData);
        this.initializeTransferDemand(transferDemand, _reqPO);
        this.initializeCoverageInventDimIdForTransferDemand(transferDemand, _reqPO, _reqPlanData, _fromInventLocationId);
        this.initializeReqDateForTransferDemand(transferDemand, _reqPlanData);
        this.insertTransferDemand(transferDemand, _reqPlanData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeReqPlan</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>ReqPlanData</c> instance, based on the <c>PlanVersion</c>.
    /// </summary>
    /// <param name = "_reqPlanData">The instance of <c>ReqPlanData</c>, if null it will initialize the <c>ReqPlanData</c>.</param>
    /// <returns>The initialized <c>ReqPlanData</c> instance.</returns>
    protected ReqPlanData initializeReqPlan(ReqPlanData _reqPlanData)
    {
        if (!_reqPlanData)
        {
            _reqPlanData = ReqPlanData::newReqPlanVersion(this.PlanVersion);
        }

        return _reqPlanData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTransferDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>ReqTrans</c> instance.
    /// </summary>
    /// <param name="_transferDemand">
    /// A <c>ReqTrans</c> record that represents a transfer demand.
    /// </param>
    /// <param name="_reqPO">
    /// A <c>ReqPO</c> record that represents a planned transfer order.
    /// </param>
    protected void initializeTransferDemand(ReqTrans _transferDemand, ReqPO _reqPO)
    {
        // make issue transaction as copy from receipt
        _transferDemand.data(this);
        _transferDemand.RefType           =  ReqTrans::derivedRefType(_reqPO.RefType);
        _transferDemand.Qty               = -this.Qty;
        _transferDemand.ReqDateDlvOrig    = _reqPO.SchedFromDate;
        _transferDemand.IsDerivedDirectly = NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCoverageInventDimIdForTransferDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>CovInventDimId</c> for the transfer demand.
    /// </summary>
    /// <param name="_transferDemand">
    /// A <c>ReqTrans</c> record that represents a transfer demand.
    /// </param>
    /// <param name="_reqPO">
    /// A <c>ReqPO</c> record that represents a planned transfer order.
    /// </param>
    /// <param name="_reqPlanData">
    /// An instance of the <c>ReqPlanData</c> class that holds master scheduling settings.
    /// </param>
    /// <param name="_fromInventLocationId">
    /// A string value that holds the from location ID.
    /// </param>
    protected void initializeCoverageInventDimIdForTransferDemand(
        ReqTrans            _transferDemand,
        ReqPO               _reqPO,
        ReqPlanData         _reqPlanData,
        InventLocationId    _fromInventLocationId)
    {
        ReqSetup    setup    = _reqPlanData.newReqSetup(this.ItemId);
        ReqSetupDim setupDim = _reqPlanData.newReqSetupDim(setup, this.CovInventDimId);

        // correct inventory dimensions
        InventDim inventDim = InventDim::find(_transferDemand.CovInventDimId);

        inventDim.wmsLocationId     = '';
        inventDim.InventLocationId  = _fromInventLocationId;

        switch (_transferDemand.RefType)
        {
            case ReqRefType::TransferDemand:
                if (! inventDim.InventLocationId)
                {
                    inventDim.InventLocationId  = setupDim.mainInventLocationId(_reqPO.RefType, _reqPO.reqDateTime());
                }
                break;

            case ReqRefType::PlannedKanbanLine:
                this.SupplyDemandSubClassification = SupplyDemandSubClassification::WithdrawalKanban;
                if (! inventDim.InventLocationId)
                {
                    LeanRuleData leanRuleData = setupDim.leanRuleData(_reqPO.reqDateTime(), _reqPO.RefType, _reqPO.Qty);
                    if (leanRuleData)
                    {
                        LeanProdFlowFindConsumptionActivity leanProdFlowFindConsumptionActivity = LeanProdFlowFindConsumptionActivity::newKanbanFlow(setup.inventTable(),
                                                                                       inventDim,
                                                                                       leanRuleData.kanbanFlow(),
                                                                                       leanRuleData.parmKanbanRule(),
                                                                                       leanRuleData.leanKanbanType());
                        if (_reqPlanData)
                        {
                            leanProdFlowFindConsumptionActivity.parmLeanLocationCache(_reqPlanData.parmLeanLocationCache());
                        }

                        inventDim = leanProdFlowFindConsumptionActivity.inventDimFinal();
                    }
                }
                break;
        }

        InventDimParm       inventDimParm;
        InventDimParm       inventDimParmMissing;
        inventDimParm.initFromInventDim(inventDim);
        inventDimParmMissing.initCovPrDimension(InventDimGroupSetup::newItemId(setup.itemId()));
        inventDimParmMissing = InventDimParm::xorParms(inventDimParmMissing, inventDimParm);

        // Force update of the site based on the warehouse
        inventDimParmMissing.InventSiteIdFlag       = NoYes::Yes;
        inventDimParmMissing.InventLocationIdFlag   = NoYes::Yes;

        inventDim.initFromInventLocationAndDefault(inventDim.inventLocation(), this.ItemId, InventDirection::Issue, inventDimParmMissing);
        inventDim.clearNotCovPrDim(InventDimGroupSetup::newItemId(setup.itemId()));

        inventDim = InventDim::findOrCreate(inventDim);

        _transferDemand.CovInventDimId = inventDim.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeReqDateForTransferDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>ReqDate</c> for the transfer demand.
    /// </summary>
    /// <param name="_transferDemand">
    /// A <c>ReqTrans</c> record that represents a transfer demand.
    /// </param>
    /// <param name="_reqPlanData">
    /// An instance of the <c>ReqPlanData</c> class that holds master scheduling settings.
    /// </param>
    protected void initializeReqDateForTransferDemand(
        ReqTrans            _transferDemand,
        ReqPlanData         _reqPlanData)
    {
        ReqSetupDim transferSetupDim = _reqPlanData.newReqSetupDim(
            _reqPlanData.newReqSetup(this.ItemId),
            _transferDemand.CovInventDimId);

        _transferDemand.ReqDate = _reqPlanData.schedReqDateIssue(_transferDemand.ReqDateDlvOrig, transferSetupDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransferDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert the <c>ReqTrans</c> record.
    /// </summary>
    /// <param name="_transferDemand">
    /// A <c>ReqTrans</c> record that represents a transfer demand.
    /// </param>
    /// <param name="_reqPlanData">
    /// An instance of the <c>ReqPlanData</c> class that holds master scheduling settings.
    /// </param>
    [Replaceable]
    protected void insertTransferDemand(ReqTrans _transferDemand, ReqPlanData _reqPlanData)
    {
        _transferDemand.insert(_reqPlanData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cwActionSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the final catch weight requirement quantity of the current <c>ReqTrans</c> record if the action message is accepted.
    /// </summary>
    /// <returns>
    /// A a catch weight quantity that holds the new requirement catch weight quantity.
    /// </returns>
    public PdsCWActionQtyAdd cwActionSum()
    {
        return this.pdsCWReqQty() + this.pdsCWActionQtyAdd();
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete(
        ReqPlanData     _reqPlanData     = null,
        boolean         _derivedDelete   = true,
        boolean         _coverageDelete  = true
        )
    {
        ReqTransCov     reqTransCov;
        ReqTrans        req;

        ReqPO           reqPO;

        boolean         doDelete = true;

        if (! _derivedDelete)
        {
            if (this.isDerivedFromPlannedOrder())
            {
                doDelete = false;
            }

            if (   ReqTrans::refTypeIsPlannedOrder(this.RefType)
                && this.IsDerivedDirectly)
            {
                doDelete = false;
            }
        }

        if (doDelete)
        {
            ttsbegin;

            ReqTraceLog::deleteTraceForReqTrans(this);

            super();

            if (this.isDerivedFromPlannedOrder()
                && this.IsDerivedDirectly)
            {
                reqTransCov = this.selectCovJoinTransDerived(true);
                req         = reqTransCov.joinChild() as ReqTrans;

                while (reqTransCov)
                {
                    req.delete(_reqPlanData,true);
                    next reqTransCov;
                }
            }

            if (this.isPlannedOrder())
            {
                this.deleteDerivedReqTrans(_reqPlanData);

                if (ReqTrans::refTypeCanHaveRoute(this.RefType))
                {
                    this.deleteRoute();
                }
            }

            if (_coverageDelete)
            {
                this.deleteCoverageOnReqTransDelete(_reqPlanData);
            }

            if (this.isPlannedOrder())
            {
                reqPO = this.getReqPo(_reqPlanData, true);
                if (reqPO.RecId)
                {
                    reqPO.delete(true);
                }
            }

            if (_reqPlanData)
            {
                _reqPlanData.subReqLog(this);
            }

            ttscommit;

            if (_reqPlanData && _reqPlanData.inMemoryCache())
            {
                _reqPlanData.inMemoryCache().handleReqTransDeleted(this);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBOM</Name>
				<Source><![CDATA[
    public void deleteBOM(ReqPlanData _reqPlanData = null)
    {
        ReqTrans    derived;

        if (this.RefType == ReqRefType::BOMPlannedOrder
            || this.RefType == ReqRefType::PmfPlannedProdBatch
            )
        {
            while select forupdate derived
                where derived.PlanVersion   ==  this.PlanVersion
                    && (derived.RefType     ==  ReqRefType::BOMLine
                        || derived.RefType  == ReqRefType::PmfFormulaLine)
                    && derived.RefId        ==  this.RefId
            {
                derived.delete(_reqPlanData,true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveCoverage</Name>
				<Source><![CDATA[
    private boolean canHaveCoverage()
    {
        return this.CovQty || this.ActionQtyAdd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrioritized</Name>
				<Source><![CDATA[
    internal boolean isPrioritized()
    {
        return this.Priority < 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCoverageOnReqTransDelete</Name>
				<Source><![CDATA[
    private void deleteCoverageOnReqTransDelete(ReqPlanData _reqPlanData = null)
    {
        ReqTransCov cov;

        if (this.canHaveCoverage())
        {
            if (InventTable::exist(this.ItemId))
            {
                this.deleteCov(_reqPlanData);
            }
            else
            {
                // When ReqTrans is being removed as part of the cascading delete action on InventTable
                // we can just clean up the related coverage records.

                delete_from cov
                    where cov.ReceiptRecId == this.RecId
                        || cov.IssueRecId == this.RecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCov</Name>
				<Source><![CDATA[
    public void deleteCov(ReqPlanData _reqPlanData = null, boolean _updateSettledReqTransCovQty = true)
    {
        ReqTransCov  reqTransCov;
        ReqTrans     reqTrans;
        if (this.CovQty || this.ActionQtyAdd)
        {
            ttsbegin;

            reqTransCov = this.selectCov(true);
            while (reqTransCov.RecId)
            {
                if (_updateSettledReqTransCovQty)
                {
                    reqTrans  = this.reqTransSettled(reqTransCov,true);

                    if (reqTrans.RecId)
                    {
                        reqTrans.subCov(reqTransCov);
                        reqTrans.update(_reqPlanData);

                        if ( reqTrans.CovQty == 0
                                && reqTrans.isPlannedOrder()
                                    && ! reqTrans.isSelfSettled(this))
                        {
                            if (ReqTransMustNotBeDeletedIfIntercompanyRefExistsFlight::instance().isEnabled() && reqTrans.findIntercompanyRefPlannedOrder())
                            {
                                ReqPoPreventDeletionContext::construct(reqTrans.RefId, reqTrans.RefType);
                            }
                            reqTrans.deleteUnusedPlannedOrder(_reqPlanData);
                        }
                    }
                }

                reqTransCov.delete();
                next reqTransCov;
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findIntercompanyRefPlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// If there is <c>ReqTrans</c> reference in intercompany, do not delete the current <c>ReqTrans</c> record for unused planned order.
    /// </summary>
    /// <returns>
    /// true if find the <c>ReqTrans</c> reference in intercompany; otherwise, false.
    /// </returns>
    private boolean findIntercompanyRefPlannedOrder()
    {
        ReqTrans reqTransIntercompRef;
        ReqPlanVersion reqPlanVersionIntercompRef;

        reqPO reqPO = this.reqPo();

        if(this.RefType == ReqRefType::ItemPlannedOrder && reqPO.recId != 0)
        {
            select firstonly crossCompany reqTransIntercompRef
            index hint IntercompanyPlannedOrderIdx
            where reqTransIntercompRef.IntercompanyPlannedOrder == reqPO.RecId &&
                  reqTransIntercompRef.ItemId == this.ItemId &&
                  reqTransIntercompRef.RefType == ReqRefType::PlannedIntercompanyDemand
            exists join reqPlanVersionIntercompRef
                where reqPlanVersionIntercompRef.RecId == reqTransIntercompRef.PlanVersion
                   && reqPlanVersionIntercompRef.Active == NoYes::Yes;
        }

        return reqTransIntercompRef.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteDerivedReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes derived <c>ReqTrans</c> records.
    /// </summary>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that holds master planning settings.
    /// </param>
    public void deleteDerivedReqTrans(ReqPlanData _reqPlanData = null)
    {
        ReqTrans    derived;

        if (ReqTrans::derivedRefType(this.RefType) != ReqRefType::None)
        {
            derived = this.selectDerived(true);
            while (derived.RecId)
            {
                derived.delete(_reqPlanData,true);
                next derived;
            }
        }

        this.pmfDeleteCoProducts(_reqPlanData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExplosionCoverage</Name>
				<Source><![CDATA[
    void deleteExplosionCoverage(ReqPlanData     _reqPlanData             = null)
    {
        ReqTrans        reqTransSettled;
        ReqTrans        reqTransDerived;
        ReqTrans        reqTransPO;

        ReqTransCov     reqTransCov;

        if (! _reqPlanData)
        {
            _reqPlanData = ReqPlanData::newReqPlanVersion(this.PlanVersion);
        }

        if (this.Qty < 0)
        {
            if (this.CovQty)
            {
                if (this.IsDerivedDirectly)
                {
                    reqTransCov = this.selectCov(true);
                    while (reqTransCov.RecId)
                    {
                        reqTransSettled = this.reqTransSettled(reqTransCov,true);
                        if (reqTransSettled.RecId)
                        {
                            reqTransSettled.deleteExplosionCoverage(_reqPlanData);
                        }
                        next reqTransCov;
                    }
                }
                else
                {
                    this.deleteExplosionCoverageTrans(_reqPlanData);
                }
            }
        }
        else
        {
            if (ReqTrans::refTypeIsPlannedOrder(this.RefType))
            {
                reqTransDerived = this.selectDerived(true);

                while (reqTransDerived.RecId)
                {
                    if (reqTransDerived.IsDerivedDirectly)
                    {
                        reqTransCov = reqTransDerived.selectCovJoinTransDerived(true);
                        if (reqTransCov.RecId)
                        {
                            reqTransPO = reqTransCov.joinChild() as ReqTrans;
                            reqTransPO.deleteExplosionCoverage(_reqPlanData);
                            reqTransPO.delete(_reqPlanData,true);
                        }
                    }
                    else
                    {
                        reqTransDerived.deleteExplosionCoverageTrans(_reqPlanData);
                    }

                    next reqTransDerived;
                }
            }
            else
            if (ReqTrans::derivedRefType(this.RefType) != ReqRefType::None)
            {
                reqTransDerived = this.selectDerived(true);
                while (reqTransDerived.RecId)
                {
                    if (_reqPlanData &&
                        _reqPlanData.reqTransCache() &&
                        _reqPlanData.reqTransCache().isItemMarkedForProcessing(reqTransDerived.ItemId))
                    {
                        continue;
                    }

                    if (reqTransDerived.IsDerivedDirectly)
                    {
                        reqTransDerived.deleteExplosionCoverage(_reqPlanData);
                    }
                    else
                    {
                        reqTransDerived.deleteExplosionCoverageTrans(_reqPlanData);
                    }

                    next reqTransDerived;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExplosionCoverageTrans</Name>
				<Source><![CDATA[
    void deleteExplosionCoverageTrans(ReqPlanData     _reqPlanData = null)
    {
        ReqPlanData     reqPlanData;

        reqPlanData = _reqPlanData ? _reqPlanData : ReqPlanData::newReqPlanVersion(this.PlanVersion);

        this.deleteCov(_reqPlanData);

        this.reread();
        this.CovQty = 0;
        this.update(_reqPlanData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteReceiptReqTrans</Name>
				<Source><![CDATA[
    void deleteReceiptReqTrans(ReqTransCov reqTransCov)
    {
        ReqTransCov     lastTransCov;
        ReqTrans        reqTransReceipt;
        ReqPO           reqPOReceipt;

        if (this.RefType == ReqRefType::BOMLine
           || this.RefType == ReqRefType::PmfFormulaLine)
        {
            reqTransReceipt = ReqTrans::findRecId(reqTransCov.ReceiptRecId,true);

            select firstonly RecId from reqPOReceipt
                where reqPOReceipt.PlanVersion            == reqTransReceipt.PlanVersion            &&
                      reqPOReceipt.RefId     == reqTransReceipt.RefId     &&
                      reqPOReceipt.RefType   == reqTransReceipt.RefType;

            if (reqTransReceipt.RecId && reqPOReceipt.RecId)
            {
                select firstonly RecId from lastTransCov
                    where lastTransCov.ReceiptRecId == reqTransReceipt.RecId &&
                          lastTransCov.RecId        != reqTransCov.RecId;

                if (!lastTransCov.RecId)
                {
                    select firstonly RecId from lastTransCov
                        where lastTransCov.IssueRecId == reqTransReceipt.RecId &&
                              lastTransCov.RecId      != reqTransCov.RecId;
                }

                if (!lastTransCov.RecId)
                {
                    reqTransReceipt.delete();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the route, jobs and reservations for the order associated with the requirement transaction.
    /// </summary>
    public void deleteRoute()
    {
        if (this.RefType == ReqRefType::BOMPlannedOrder
            || this.RefType == ReqRefType::PmfPlannedProdBatch)
        {
            ReqRoute::deleteRefId(this.PlanVersion,this.RefId);
            ReqRouteJob::deletePO(this.PlanVersion,this.RefId);
            WrkCtrCapResHandler::construct().deleteOrderReservations(WrkCtrCapRefType::PlannedOrder, this.RefId, 0, this.PlanVersion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteUnusedPlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the current <c>ReqTrans</c> record if this represents an unused planned order.
    /// </summary>
    /// <param name="_reqPlanData">
    /// An instance of the <c>ReqPlanData</c> class that holds master planning settings.
    /// </param>
    public void deleteUnusedPlannedOrder(ReqPlanData   _reqPlanData = null)
    {
        ReqPlanData     reqPlanData;
        ReqSetupDim     setupDim;

        if (   this.CovQty == 0
            && this.isPlannedOrder())
        {
            reqPlanData = _reqPlanData ? _reqPlanData : ReqPlanData::newReqPlanVersion(this.PlanVersion);
            setupDim    = reqPlanData.newReqSetupDim(reqPlanData.newReqSetup(this.ItemId),this.CovInventDimId);

            if (! reqPlanData.mustKeepPlannedOrder(setupDim,this, null))
            {
                this.delete(reqPlanData,true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>derivedTransWithMaxFuturesDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the latest futures date of the derived requirement transactions.
    /// </summary>
    /// <returns>
    /// The latest futures date of the derived requirement transactions.
    /// </returns>
    public ReqTrans derivedTransWithMaxFuturesDateTime()
    {
        ReqTrans    reqTrans;
        boolean     needConsiderItemId, needConsiderVariant;
        ReqRefType  derivedRefType = ReqTrans::derivedRefType(this.RefType);

        if (this.RefId && derivedRefType != ReqRefType::None)
        {
            switch (derivedRefType)
            {
                case ReqRefType::TransferDemand:
                case ReqRefType::TransferOrderShip:
                case ReqRefType::InventTransfer:
                case ReqRefType::Quarantine:
                    needConsiderItemId = true;
                    needConsiderVariant = InventTable::find(this.ItemId).productSubtype() == EcoResProductSubtype::ProductMaster;
                    break;

                default:
                    needConsiderItemId = false;
            }

            if (needConsiderVariant)
            {
                inventDim itemVariantInventDim = InventDimCombination::findByInventDim(this.ItemId, this.inventDim()).inventDim();
                InventDimParm inventDimParm;
                inventDimParm.initFromInventDim(itemVariantInventDim);
                InventDim inventDim;

                select firstonly FuturesDate, FuturesTime from reqTrans
                    order by FuturesDate desc, FuturesTime desc
                    where reqTrans.PlanVersion == this.PlanVersion
                       && reqTrans.RefType == derivedRefType
                       && reqTrans.RefId == this.RefId
                       && reqTrans.ItemId == this.ItemId
                        #inventDimJoin(reqTrans.CovInventDimId, inventDim, itemVariantInventDim, inventDimParm);
            }
            else
            {
                select firstonly FuturesDate, FuturesTime from reqTrans
                    order by FuturesDate desc, FuturesTime desc
                    where reqTrans.PlanVersion == this.PlanVersion
                       && reqTrans.RefType     == derivedRefType
                       && reqTrans.RefId       == this.RefId
                       && (!needConsiderItemId || reqTrans.ItemId == this.ItemId);
            }
        }

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayActionDate</Name>
				<Source><![CDATA[
    public display ActionDate displayActionDate()
    {
        return this.ActionDate != this.ReqDate ? this.ActionDate : dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayActionSum</Name>
				<Source><![CDATA[
    public display ActionQty displayActionSum()
    {
        return this.actionSum() != this.Qty ? this.actionSum() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCWActionSum</Name>
				<Source><![CDATA[
    public display PdsCWActionQtyAdd displayCWActionSum()
    {
        return this.cwActionSum() != this.pdsCWReqQty() ? this.cwActionSum() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFuturesDate</Name>
				<Source><![CDATA[
    display FuturesDate displayFuturesDate()
    {
        if (this.RefType == ReqRefType::InventOnHand)
        {
            return dateNull();
        }

        return this.FuturesDays > 0 ? this.FuturesDate : dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFuturesDays</Name>
				<Source><![CDATA[
    display FuturesDays displayFuturesDays()
    {
        if (this.RefType == ReqRefType::InventOnHand)
        {
            return 0;
        }

        return this.FuturesDays > 0 ? this.FuturesDays : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFuturesMessage</Name>
				<Source><![CDATA[
    public display ReqFuturesMessage displayFuturesMessage()
    {
        return this.FuturesMarked ? "@SYS8028" : "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayReqDateDlv</Name>
				<Source><![CDATA[
    public display ReqDateDlvOrig displayReqDateDlv()
    {
        return this.ReqDate != this.ReqDateDlvOrig ? this.ReqDateDlvOrig : dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayReqPlanId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the ID of the master plan.
    /// </summary>
    /// <returns>
    ///     The ID of the master plan.
    /// </returns>
    public display ReqPlanId displayReqPlanId()
    {
        return ReqPlanVersion::find(this.PlanVersion).ReqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWrkCtrConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the value of the <c>wrkCtrConsumption</c> field from either the standard bill of materials or from the production bill of materials.
    /// </summary>
    /// <returns>
    /// true if the the <c>wrkCtrConsumption</c> field is selected; otherwise, false;
    /// </returns>
    display WrkCtrConsumption displayWrkCtrConsumption()
    {
        Common      originator;
        ProdBOM     prodBOM;

        switch (this.RefType)
        {
            case ReqRefType::BOMLine:
            case ReqRefType::PmfFormulaLine:
                if (this.bomRefRecId)
                {
                    return BOM::findRecId(this.bomRefRecId).WrkCtrConsumption;
                }
                break;

            case ReqRefType::ProdLine:
                originator = this.inventTransOrigin().originator();
                if (   originator.RecId
                    && originator.TableId == tableNum(ProdBOM))
                {
                    prodBOM = originator as ProdBOM;
                    return prodBOM.WrkCtrConsumption;
                }
                break;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doIntercompanyDemandUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the database update of a planned intercompany demand transaction,
    /// after it was updated by ReqIntercompanyDemand.initReqTransFromIntercompanyReqPO(),
    /// making sure that fields like open status and direction are correctly set.
    /// </summary>
    /// <param name="_reqPlanData">
    /// The plan data for the current plan.
    /// </param>
    public void doIntercompanyDemandUpdate(ReqPlanData _reqPlanData)
    {
        ttsbegin;

        this.updateReduceCovQty(_reqPlanData);
        this.setOpenStatus();
        this.setDirection();

        this.ReqProcessId = _reqPlanData.parmProcessId();

        _reqPlanData.addReqLog(this);
        _reqPlanData.addReqTransCache(this);

        this.doUpdate();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSimilarIntercompanyDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>ReqTrans</c> record which is relating to the same intercompany planned order.
    /// </summary>
    /// <returns>
    /// A <c>ReqTrans</c> record which is relating to the same intercompany planned order.
    /// </returns>
    public ReqTrans findSimilarIntercompanyDemand()
    {
        ReqTrans reqTrans;

        select forupdate firstonly reqTrans
            where reqTrans.PlanVersion              == this.PlanVersion
               && reqTrans.RefType                  == this.RefType
               && reqTrans.IntercompanyPlannedOrder == this.IntercompanyPlannedOrder;

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromDate</Name>
				<Source><![CDATA[
    FromDate fromDate()
    {
        ProdTable               prodTable;
        KanbanJob               kanbanJob;

        if (this.isPlannedOrder() || this.isDerivedFromPlannedOrder())
        {
            return this.reqPo().SchedFromDate;
        }

        switch (this.RefType)
        {
            case ReqRefType::Production:
            case ReqRefType::PmfCoProduct:
            case ReqRefType::ProdLine:
                select firstonly SchedStart from prodTable
                    index hint ProdIdx
                    where prodTable.ProdId == this.RefId;

                return prodTable.SchedStart;

            case ReqRefType::Kanban:
            case ReqRefType::KanbanLine:
                kanbanJob = this.kanbanJob();
                if (kanbanJob)
                {
                    return kanbanJob.scheduledPeriodDate();
                }
                break;
        }

        return this.ReqDate ? this.ReqDate : this.toDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromTime</Name>
				<Source><![CDATA[
    public SchedFromTime fromTime()
    {
        ProdTable       prodTable;

        if (this.isPlannedOrder() || this.isDerivedFromPlannedOrder())
        {
            return this.reqPo().ReqTimeOrder;
        }

        switch (this.RefType)
        {
            case ReqRefType::Production:
            case ReqRefType::PmfCoProduct:
            case ReqRefType::ProdLine:
                select firstonly SchedFromTime from prodTable
                    index hint ProdIdx
                    where prodTable.ProdId == this.RefId;

                return prodTable.SchedFromTime;

            case ReqRefType::Kanban:
            case ReqRefType::KanbanLine:
                return 0;   //company TZ

            case ReqRefType::Purch:
                return this.ReqTime;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresDaysBaseDate</Name>
				<Source><![CDATA[
    display FuturesDaysBaseDate futuresDaysBaseDate()
    {
        switch (this.RefType)
        {
            case ReqRefType::PmfFormulaLine :
            case ReqRefType::BOMLine :
            case ReqRefType::PlannedKanbanLine:
                return this.ReqDate;
        }

        return this.ReqDateDlvOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresPostpone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the image icon for futures.
    /// </summary>
    /// <returns>
    /// The image icon for futures.
    /// </returns>
    display ImageRes futuresPostpone()
    {
        #ResAppl
        ImageRes    ret = #ImageBlank2;

        if (this.FuturesMarked)
        {
            ret = #ImageReqTransFuture;
        }

        if (this.ActionType == ActionType::Cancel)
        {
            ret = #ImageReqTransCancel;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ganttCalenderId</Name>
				<Source><![CDATA[
    GanttCalendarId ganttCalenderId()
    {
        GanttCalendarId calendarId;
        ReqSetupDim     setupDim = this.reqSetupDim();

        switch (this.RefType)
        {
            case ReqRefType::Purch              :

                calendarId = setupDim.purchCalendarId(PurchTable::find(this.RefId).OrderAccount);
                break;

            case ReqRefType::ItemPlannedOrder   :

                calendarId = setupDim.purchCalendarId(this.reqPo().VendId);
                break;

            default                             :
                calendarId = setupDim.reqCalendarId();
        }

        return calendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initExpiryFromReqTransReceiptCov</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes expired batch transaction
    /// </summary>
    /// <param name="_reqTransReceiptCov">
    /// A receipt
    /// </param>
    /// <param name="_qty">
    /// An expired inventory quantity
    /// </param>
    public void initExpiryFromReqTransReceiptCov(ReqTransReceiptCov _reqTransReceiptCov, InventQty _qty)
    {
        if (_reqTransReceiptCov)
        {
            this.PlanVersion      = _reqTransReceiptCov.PlanVersion;
            this.ItemId           = _reqTransReceiptCov.ItemId;
            this.CovInventDimId   = _reqTransReceiptCov.CovInventDimId;
            this.ReqDate          = _reqTransReceiptCov.PdsExpiryDate;
            this.ReqDateDlvOrig   = _reqTransReceiptCov.PdsExpiryDate;
            this.ReqProcessId     = _reqTransReceiptCov.ReqProcessId;
            this.Level            = _reqTransReceiptCov.Level;
            this.RefType          = ReqRefType::PdsExpiredBatch;
            this.Qty              = _qty;
            this.CovQty           = _qty;
            this.OriginalQuantity = _qty;
            this.Direction        = InventDirection::Issue;
            this.OpenStatus       = ReqOpenStatus::Zero;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDateTimeFromInvent</Name>
				<Source><![CDATA[
    void initDateTimeFromInvent(        // requires that refType and qty is already inited
        DateStatus      _dateStatus,
        TimeExpected    _timeExpected,
        ReqPlanData     _reqPlanData,
        ReqSetupDim     _setupDim
        )
    {
        this.ReqDateDlvOrig = _dateStatus ? _dateStatus : _reqPlanData.todaysdate();

        if (this.Qty >= 0)
        {
            this.ReqDate = _reqPlanData.schedReqDateReceipt(this.ReqDateDlvOrig,_setupDim);
        }
        else
        {
            this.ReqDate = _reqPlanData.schedReqDateIssue(this.ReqDateDlvOrig,_setupDim);
        }

        this.ReqTime = _timeExpected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the bill of materials line information from the master data bill of materials line record.
    /// </summary>
    /// <param name="_bom">
    /// A <c>BOM</c> record containing the master data bill of materials line information.
    /// </param>
    /// <param name="_bomTable">
    /// A <c>BOMTable</c> record; optional.
    /// </param>
    public void initFromBOM(BOM _bom, BOMTable _bomTable = null)
    {
        if (#PmfEnabled)
        {
            if (!_bomTable)
            {
                _bomTable = _bom.pmfBOMTable();
            }
            if (_bomTable.PmfBOMFormula == PmfBOMFormula::Formula)
            {
                this.RefType = ReqRefType::PmfFormulaLine;
            }
        }

        this.ItemId         = _bom.ItemId;
        this.OprNum         = _bom.OprNum;

        this.ItemBomId      = _bom.ItemBOMId;
        this.ItemRouteId    = _bom.ItemRouteId;

        this.bomRefRecId    = _bom.RecId;

        this.bomType        = this.RefType == ReqRefType::PlannedKanban ? BOMType::Item : _bom.bomType;

        if (#PmfEnabled)
        {
            this.PmfPlanGroupId = _bom.PmfPlanGroupId;
            this.PmfPlanGroupPriority = _bom.PmfPlanGroupPriority;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventSumLogTTS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current <c>ReqTrans</c> record from a <c>InventSumLogTTS</c> record.
    /// </summary>
    /// <param name="_inventSumLogTTS">
    /// A <c>InventSumLogTTS</c> record.
    /// </param>
    public void initFromInventSumLogTTS(InventSumLogTTS _inventSumLogTTS)
    {
        this.MarkingRefInventTransOrigin = _inventSumLogTTS.InventTransOriginRef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current <c>ReqTrans</c> record from an <c>InventTransOrigin</c> record.
    /// </summary>
    /// <param name="_inventTransOrigin">
    /// An <c>InventTransOrigin</c> record; optional.
    /// </param>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that holds the coverage settings for a specific item ID and the
    /// inventory dimensions; optional.
    /// </param>
    public void initFromInventTransOrigin(
        InventTransOrigin   _inventTransOrigin  = null,
        ReqSetupDim         _setupDim           = null)
    {
        ReqSetupDim setupDim;

        Common      originator;

        SalesLine   salesLine;
        CustTable	custTable;
        PurchLine   purchLine;
        ProdTable   prodTable;
        ProdBOM     prodBOM;
        KanbanJob   kanbanJob;
        Kanban      kanban;

        ReqRefType  reqRefType = this.RefType;

        void setBOMIdRouteId(BOMId  _bomId,RouteId  _routeId)
        {
            this.ItemBomId     =  setupDim.bomVersionReq()    ?   _bomId     : '';
            this.ItemRouteId   =  setupDim.routeVersionReq()  ?   _routeId   : '';
        }

        boolean setOriginator(Common   _common)
        {
            originator = _inventTransOrigin.originator();

            return  originator.RecId
                 && originator.TableId == _common.TableId;
        }

        setupDim = _setupDim ? _setupDim : this.reqSetupDim();

        if (!_inventTransOrigin)
        {
            _inventTransOrigin = this.inventTransOrigin();
        }
        if (_inventTransOrigin.ReferenceCategory == InventTransType::Blocking)
        {
            _inventTransOrigin = InventTransOrigin::find(InventTransOrigin::findMarkingRefInventTransOrigin(_inventTransOrigin.RecId, _inventTransOrigin.ItemId));
            reqRefType = ReqTrans::transType2RefType(_inventTransOrigin.ReferenceCategory, this.Qty);
        }

        switch (reqRefType)
        {
            case ReqRefType::Sales:
                if (setOriginator(salesLine))
                {
                    salesLine = originator as SalesLine;
                    if (   setupDim.bomVersionReq()
                        || setupDim.routeVersionReq()
                        || this.Qty > 0)
                    {
                        setBOMIdRouteId(salesLine.ItemBOMId,salesLine.ItemRouteId);
                        this.Qty = salesLine.Scrap && this.Qty > 0   ? 0 : this.Qty;
                    }

                    custTable = CustTable::find(salesLine.CustAccount);
                    this.CustGroupId    = custTable.CustGroup;
                    this.CustAccountId  = custTable.AccountNum;
                }
                break;

            case ReqRefType::Purch:
                if (   setupDim.bomVersionReq()
                    || setupDim.routeVersionReq()
                    || this.Qty > 0)
                {
                    if (setOriginator(purchLine))
                    {
                        purchLine = originator as PurchLine;
                        setBOMIdRouteId(purchLine.ItemBOMId,purchLine.ItemRouteId);
                        this.Qty = purchLine.Scrap && purchLine.ProjId == '' && this.Qty > 0 ? 0 : this.Qty;
                    }
                }
                break;

            case ReqRefType::Production:
                if (   setupDim.bomVersionReq()
                    || setupDim.routeVersionReq())
                {
                    if (setOriginator(prodTable))
                    {
                        prodTable = originator as ProdTable;
                        setBOMIdRouteId(prodTable.bomId,prodTable.RouteId);
                    }
                }
                break;

            case ReqRefType::ProdLine:
                if (   setupDim.bomVersionReq()
                    || setupDim.routeVersionReq())
                {
                    if (setOriginator(prodBOM))
                    {
                        prodBOM = originator as ProdBOM;
                        setBOMIdRouteId(prodBOM.ItemBomId,prodBOM.ItemRouteId);
                    }
                }
                break;

            case ReqRefType::Kanban:
                if (setupDim.bomVersionReq())
                {
                    if (setOriginator(kanbanJob))
                    {
                        kanbanJob = originator as KanbanJob;
                        kanban    = kanbanJob.kanban();
                        if (kanban.Type == LeanKanbanType::Manufacturing)
                        {
                            setBOMIdRouteId(kanban.bomId,'');
                        }
                    }
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromParentReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current <c>ReqTrans</c> record from a parent <c>ReqTrans</c> record.
    /// </summary>
    /// <param name="_parentReqTrans">
    /// A parent <c>ReqTrans</c> record.
    /// </param>
    public void initFromParentReqTrans(ReqTrans    _parentReqTrans)
    {
        this.PlanVersion                    = _parentReqTrans.PlanVersion;
        this.RefId                          = _parentReqTrans.RefId;

        this.RefType                        = ReqTrans::derivedRefType(_parentReqTrans.RefType);

        this.SupplyDemandSubClassification  = _parentReqTrans.SupplyDemandSubClassification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromReqPo</Name>
				<Source><![CDATA[
    void initFromReqPo(ReqPO _reqPO)
    {
        this.PlanVersion        = _reqPO.PlanVersion;

        this.ItemId             = _reqPO.ItemId;
        this.CovInventDimId     = _reqPO.CovInventDimId;

        this.RefType            = _reqPO.RefType;
        this.RefId              = _reqPO.RefId;

        this.ItemBomId          = _reqPO.ItemBomId;
        this.ItemRouteId        = _reqPO.ItemRouteId;

        this.ReqDate            = _reqPO.ReqDate;
        this.ReqTime            = _reqPO.ReqTime;

        this.Qty                = _reqPO.Qty;

        this.IsDerivedDirectly  = _reqPO.IsDerivedDirectly;
        this.IsForecastPurch    = _reqPO.IsForecastPurch;
        this.PlanningPriority   = _reqPO.PlanningPriority;

        this.OriginalQuantity   = FormDataUtil::isFormDataSource(_reqPO) ? _reqPO.Qty : this.OriginalQuantity;

        this.initSupplyDemandSubClassification(_reqPO);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSetupDim</Name>
				<Source><![CDATA[
    void initFromSetupDim(ReqSetupDim _setupDim)
    {
        this.Level = _setupDim.itemLevel();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeReceiptTime</Name>
				<Source><![CDATA[
    internal void initializeReceiptTime()
    {
        boolean newRecord = !this.orig().RecId;

        // the default receipt time should be initialized upon:
        // - insertion of new records and
        //      - the field is not set explicitly (can be set explicitly to 0 = 00:00 = "MidNight")
        //      - or the value is empty and the order is not a planned order
        if (newRecord)
        {
            if ((this.fieldState(fieldNum(ReqTrans, ReqTime)) == FieldState::NotSet)
            || (!this.ReqTime && !this.isPlannedOrder() && !ReqCalcCreateDerivedReqTransContext::skipRequirementTransactionReqTimeDefaulting()))
            {
                this.ReqTime = ReqParameters::find().ReqTimePoDefault;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSupplyDemandSubClassification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the sub classification setting based on the planned order.
    /// </summary>
    /// <param name="_reqPO">
    /// The planned order to initialize from.
    /// </param>
    public void initSupplyDemandSubClassification(ReqPO _reqPO)
    {
        ReqSupplyPrinciple reqSupplyPrinciple;

        switch (this.RefType)
        {
            case ReqRefType::PlannedKanban:
                // Get classification from supply principle
                reqSupplyPrinciple = _reqPO.supplyPrinciple();
                if (reqSupplyPrinciple == ReqSupplyPrinciple::Conversion)
                {
                    this.SupplyDemandSubClassification = SupplyDemandSubClassification::ProductionKanban;
                }
                else
                {
                    if (reqSupplyPrinciple == ReqSupplyPrinciple::Transfer)
                    {
                        this.SupplyDemandSubClassification = SupplyDemandSubClassification::WithdrawalKanban;
                    }
                }
                break;

            default:
                // Default to None
                this.SupplyDemandSubClassification = SupplyDemandSubClassification::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Persists a record in the data base when super is called.
    /// </summary>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that contains master scheduling settings.
    /// </param>
    /// <remarks>
    /// System defined method provided as an event for applying logic before and after a record is inserted in the data base.
    /// </remarks>
    public void insert(ReqPlanData _reqPlanData = null)
    {
        ttsbegin;

        this.setFields(_reqPlanData ? _reqPlanData.todaysdate() : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        this.setDirection();

        this.pmfSetPlanningData();

        if (!this.OriginalQuantity)
        {
            this.OriginalQuantity = this.Qty;
        }

        ReqTransRecIdPreallocationScope::assignRecId(this);

        super();

        if (_reqPlanData)
        {
            _reqPlanData.addReqLog(this);
            _reqPlanData.addReqTransCache(this);
        }

        ttscommit;

        if (_reqPlanData && _reqPlanData.inMemoryCache())
        {
            _reqPlanData.inMemoryCache().handleReqTransInserted(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertUsingInsertList</Name>
				<Source><![CDATA[
    public void insertUsingInsertList(
        RecordInsertList    _list,
        ReqPlanData         _reqPlanData     = null
        )
    {
        if (!_list || ! _reqPlanData || _reqPlanData.parmUseReqTransCache() || this.isPlannedOrder())
        {
            this.insert(_reqPlanData);
        }
        else
        {
            this.setFields(_reqPlanData ? _reqPlanData.todaysdate() : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            this.setDirection();
            this.pmfSetPlanningData();

            if (_reqPlanData)
            {
                this.ReqProcessId = _reqPlanData.parmProcessId();
            }

            ReqTransRecIdPreallocationScope::assignRecId(this);

            _list.add(this);

            if (_reqPlanData)
            {
                _reqPlanData.addReqLog(this);
                _reqPlanData.addReqTransCache(this);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyParentReqPO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the parent planned order record from another legal entity for an intercompany demand.
    /// </summary>
    /// <returns>
    /// The parent planned order record from another legal entity.
    /// </returns>
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public ReqPO intercompanyParentReqPO()
    {
        ReqPO           reqPO;

        ReqPlanVersion  reqPlanVersion;

        select crossCompany reqPO
            where reqPO.RecId == this.IntercompanyPlannedOrder
            exists join reqPlanVersion
            where reqPlanVersion.RecId  == reqPO.PlanVersion
                && reqPlanVersion.Active == NoYes::Yes;

        return reqPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    public InventDim inventDim()
    {
        return InventDim::find(this.CovInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return related inventTable record.
    /// </summary>
    /// <param name="_forUpdate">Select record for update.</param>
    /// <returns>related inventTable.</returns>
    public InventTable inventTable(boolean _forUpdate = false)
    {
        InventTable inventTable = InventTable::find(this.ItemId,_forUpdate);

        return inventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the related <c>InventTransOrigin</c> record if a relation exists.
    /// </summary>
    /// <returns>
    /// A <c>InventTransOrigin</c> record; otherwise an empty record.
    /// </returns>
    public InventTransOrigin inventTransOrigin()
    {
        if (this.InventTransOrigin)
        {
            return InventTransOrigin::find(this.InventTransOrigin);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventUnitId</Name>
				<Source><![CDATA[
    display InventUnitId inventUnitId()
    {
        return InventTableModule::find(this.ItemId,ModuleInventPurchSales::Invent).UnitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDelayed</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether the current order is delayed.
    /// </summary>
    /// <param name="_reqPO">
    ///     The planned order associated to the current record; optional.
    /// </param>
    /// <returns>
    ///     true if the order is delayed; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     If <paramref name="_reqPO" /> parameter is not specified, it is calculated for planned order references.
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///     An error is thrown if the specified planned order in the <paramref name="_reqPO" /> parameter is not linked to this requirement.
    /// </exception>
    public boolean isDelayed(ReqPO _reqPO = null)
    {
        ReqPO   reqPO;

        if (! this.ReqDate || this.RefType == ReqRefType::InventOnHand)
        {
            return false;
        }

        if (this.ReqDateDlvOrig < this.FuturesDate)
        {
            return true;
        }

        if (this.isPlannedOrder())
        {
            if (!prmisDefault(_reqPO))
            {
                reqPO = _reqPO;
                if ((reqPO.PlanVersion != this.PlanVersion) || (reqPO.RefId != this.RefId))
                {
                    throw error(error::wrongUseOfFunction(funcname()));
                }
            }
            else
            {
                reqPO = this.reqPo();
            }

            if (reqPO.ReqDateOrder != dateNull() && reqPO.ReqDateOrder < DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
            {
                return true;
            }
        }

        if (this.ReqDate < DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDerivedDemand</Name>
				<Source><![CDATA[
    public boolean isDerivedDemand()
    {
        return this.RefType == ReqRefType::BOMLine
                || this.RefType == ReqRefType::PmfFormulaLine
                || this.RefType == ReqRefType::TransferDemand ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEventKanban</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the transactions is representing an Event Kanban.
    /// </summary>
    /// <returns>
    /// true if the transactions is representing an Event Kanban; otherwise, false.
    /// </returns>
    public boolean isEventKanban()
    {
        boolean ret = false;
        Kanban  kanban;

        kanban = this.kanban();

        if (kanban
            && kanban.kanbanRule().ReplenishmentStrategy == LeanReplenishmentStrategy::Event)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForecast</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current <c>ReqTrans</c> record is a forecast transaction.
    /// </summary>
    /// <returns>
    /// true if the current <c>ReqTrans</c> record is a forecast; otherwise, false.
    /// </returns>
    public boolean isForecast()
    {
        if (this.IsForecastPurch)
        {
            return true;
        }

        return this.RefType == ReqRefType::SalesForecast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPlannedOrder</Name>
				<Source><![CDATA[
    public boolean isPlannedOrder()
    {
        return ReqTrans::refTypeIsPlannedOrder(this.RefType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPmfTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the current record is related to the process industries functionality.
    /// </summary>
    /// <returns>
    ///     true if the current record is related to the process industries functionality; otherwise, false.
    /// </returns>
    private boolean isPmfTransaction()
    {
        return this.RefType == ReqRefType::PmfCoProduct
            || this.RefType == ReqRefType::PmfFormulaLine
            || this.RefType == ReqRefType::PmfPlannedProdBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current <c>ReqTrans</c> record is a receipt.
    /// </summary>
    /// <returns>
    /// true if the current <c>ReqTrans</c> record is a receipt; otherwise, false.
    /// </returns>
    public boolean isReceipt()
    {
        if (this.Qty > 0)
        {
            return true;
        }

        if (this.Qty < 0)
        {
            return false;
        }

        // qty == 0

        if (this.OriginalQuantity > 0)
        {
            return true;
        }

        if (this.OriginalQuantity < 0)
        {
            return false;
        }

        // qtyOrig == 0

        if (this.Direction == InventDirection::Receipt)
        {
            return true;
        }

        if (this.Direction == InventDirection::Issue)
        {
            return false;
        }

        // Direction = inventDirection::None

        if (!ReqTrans::refTypeIsReceipt(this.RefType))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSelfSettled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the settled requirement transaction represents the same transaction as the
    /// current requirement transaction.
    /// </summary>
    /// <param name="_reqTransSettled">
    /// A <c>ReqTrans</c> record that represents a requirement transaction that is settled with the current
    /// record.
    /// </param>
    /// <returns>
    /// true if the settled requirement transaction originates from the same transaction; otherwise, false.
    /// </returns>
    /// <remarks>
    /// For example, a transfer receipt transaction and issue transaction can in some cases be settled with
    /// each other.
    /// </remarks>
    public boolean isSelfSettled(ReqTrans    _reqTransSettled)
    {
        if (   _reqTransSettled.RefId == this.RefId
            && (ReqTrans::derivedRefType(this.RefType)            == _reqTransSettled.RefType
            || ReqTrans::derivedRefType(_reqTransSettled.RefType) == this.RefType))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSafetyStockCoveredByReceiptLot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether safety stock is covered by a receipt with the same lot ID of current receipt.
    /// </summary>
    /// <returns>
    /// True if a safety stock is covered by a receipt with the same lot ID of current receipt; otherwise, false.
    /// </returns>
    public boolean isSafetyStockCoveredByReceiptLot()
    {
        ReqTrans        reqTransReceiptWithSameLotId;
        ReqTrans        reqTransIssue;
        ReqTransCov     reqTransCov;

        select firstOnly RefId from reqTransReceiptWithSameLotId
            where  reqTransReceiptWithSameLotId.InventTransOrigin == this.InventTransOrigin
                && reqTransReceiptWithSameLotId.CovInventDimId    == this.CovInventDimId
                && reqTransReceiptWithSameLotId.RefId             == this.RefId
                && reqTransReceiptWithSameLotId.Direction         == this.Direction
                && reqTransReceiptWithSameLotId.PlanVersion       == this.PlanVersion
                && reqTransReceiptWithSameLotId.ItemId            == this.ItemId
                && reqTransReceiptWithSameLotId.RefType           == this.RefType
            exists join reqtranscov
                where reqTransCov.ReceiptRecId                    == reqTransReceiptWithSameLotId.RecId
            exists join reqtransissue
                where reqtransissue.RecId                         == reqtransCov.IssueRecId
                   && reqtransissue.RefType                       == ReqRefType::SafetyInvent;

        return reqTransReceiptWithSameLotId.RefId != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStaticReceipt</Name>
				<Source><![CDATA[
    boolean isStaticReceipt()
    {
        if (this.Qty < 0)
        {
            return false;
        }

        if (this.RefType == ReqRefType::InventOnHand
            || this.RefType == ReqRefType::SafetyInvent)
        {
            return true;
        }
        
        if (this.RefType == ReqRefType::InventJournal
            && this.InventTransOrigin
            && InventTransOrigin::find(this.InventTransOrigin).ReferenceCategory == InventTransType::Blocking)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemGroupId</Name>
				<Source><![CDATA[
    display ItemGroupId itemGroupId()
    {
        return InventTable::find(this.ItemId).itemGroupId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemName</Name>
				<Source><![CDATA[
    display ItemName itemName()
    {
        return InventTable::find(this.ItemId).itemName(this.inventDim());
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpRefRefId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the related form for the current <c>ReqTrans</c> record.
    /// </summary>
    /// <param name="_caller">
    /// The caller of the method.
    /// </param>
    /// <param name="_openMode">
    /// The mode to open the form in.
    /// </param>
    /// <returns>true if the <c>jumpRef</c> was successful; otherwise, false.</returns>
    public boolean jumpRefRefId(Object _caller, OpenMode _openMode = OpenMode::Auto)
    {
        PurchReqLine purchReqLine;

        void jumpRef(Common     _jumpToTable,
                     str        _jumpToMenuItem)
        {
            Args                args;
            MenuFunction        menuFunction;

            args = new Args();
            args.record(_jumpToTable);
            args.caller(_caller);
            args.openMode(_openMode);
            menuFunction = new MenuFunction(_jumpToMenuItem, MenuItemType::Display);
            menuFunction.run(args);
        }

        if (this.InventTransOrigin != 0)
        {
            return InventTransFormHelper::jumpRefReferenceId(InventTransOrigin::find(this.InventTransOrigin), _openMode);
        }

        if (this.RefType == ReqRefType::PlannedIntercompanyDemand)
        {
            if (this.IntercompanyPlannedOrder)
            {
                jumpRef(this, menuitemDisplayStr(ReqIncomingIntercompanyDemand));
                return true;
            }
            return false;
        }

        if (this.RefType == ReqRefType::RequisitionLine)
        {
            purchReqLine = PurchReqLine::find(this.RequisitionLine);
            if (purchReqLine)
            {
                jumpRef(purchReqLine, menuitemDisplayStr(PurchReqTableDetails));
                return true;
            }
            return false;
        }

        if (this.isPlannedOrder() || ReqTrans::refTypeIsPlannedOrder(this.parentReqRefType()))
        {
            return ReqPO::jumpRefRefId(_caller, this.RefId, this.PlanVersion, _openMode);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanban</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the kanban that the transactions is representing.
    /// </summary>
    /// <returns>
    /// The kanban that the transactions is representing.
    /// </returns>
    public Kanban kanban()
    {
        Kanban  kanban;

        if (this.RefType == ReqRefType::Kanban)
        {
            kanban = Kanban::findKanbanId(this.RefId);
        }

        return kanban;
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanbanJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the related <c>KanbanJob</c> record of the current <c>ReqTrans</c> record.
    /// </summary>
    /// <returns>
    /// A <c>KanbanJob</c> record; otherwise, an empty record.
    /// </returns>
    public KanbanJob    kanbanJob()
    {
        Common                  originator;
        KanbanJob               kanbanJob;
        KanbanJobPickingList    kanbanJobPickingList;

        if (   this.RefType == ReqRefType::Kanban
            || this.RefType == ReqRefType::KanbanLine)
        {
            originator = this.inventTransOrigin().originator();
            switch (originator.TableId)
            {
                case tableNum(KanbanJob):
                    kanbanJob = originator as KanbanJob;
                    break;

                case tableNum(KanbanJobPickingList):
                    kanbanJobPickingList = originator as KanbanJobPickingList;
                    kanbanJob = kanbanJobPickingList.kanbanJob();
                    break;
            }
        }

        return kanbanJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustTransIdBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current <c>ReqTrans</c> record must be updated.
    /// </summary>
    /// <returns>
    /// true if the current <c>ReqTrans</c> record must be updated; otherwise false.
    /// </returns>
    public NoYesId mustTransIdBeUpdated()
    {
        ReqPlanId reqPlanId;

        if (! this.InventTransOrigin)
        {
            return false;
        }

        reqPlanId = ReqPlanVersion::find(this.PlanVersion).ReqPlanId;

        if (reqPlanId != ReqPlanSched::defaultDynamicId())
        {
            return false;
        }

        return InventSumLogTTS::mustTransBeUpdated(this.InventTransOrigin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openQty</Name>
				<Source><![CDATA[
    display InventQtyOpen  openQty()
    {
        return this.Qty   - this.CovQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWActionQtyAdd</Name>
				<Source><![CDATA[
    public display PdsCWActionQtyAdd pdsCWActionQtyAdd()
    {
        if (PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            return PdsCatchWeight::convertQtyToCWQty(this.ItemId, this.ActionQtyAdd, this.inventUnitId());
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWCovQty</Name>
				<Source><![CDATA[
    public display PdsCWQtyCoverage pdsCWCovQty()
    {
        if (PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            return PdsCatchWeight::convertQtyToCWQty(this.ItemId, this.CovQty, this.inventUnitId());
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWOriginalQty</Name>
				<Source><![CDATA[
    public display PdsCWOriginalQty pdsCWOriginalQty()
    {
        if (PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            return PdsCatchWeight::convertQtyToCWQty(this.ItemId, this.OriginalQuantity, this.inventUnitId());
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReqQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the current quantity to a catch weight quantity.
    /// </summary>
    /// <returns>
    /// The catch weight quantity equivalent of the current record's quantity.
    /// </returns>
    public display PdsCWReqQty pdsCWReqQty()
    {
        if (PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            return PdsCatchWeight::cwQty(this.ItemId, this.Qty);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWUnitId</Name>
				<Source><![CDATA[
    /// <summary>
    /// The catch weight units, if applicable, of the current record.
    /// </summary>
    /// <returns>
    /// The catch weight unit. If not applicable, an empty string is returned.
    /// </returns>
    public display PdsCWUnitId pdsCWUnitId()
    {
        return PdsCatchWeightItem::find(this.ItemId).PdsCWUnitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsNeedByDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the final date the product must be available to the customer.
    /// </summary>
    /// <returns>
    /// A required date adjusted, if necessary, by the number of sellable days.
    /// </returns>
    public ReqDate pdsNeedByDate()
    {
        return this.ReqDate + this.PdsSellableDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSetShelfLifeFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns the appropriate expiration date and sellable days to this requirements transaction line.
    /// </summary>
    /// <param name="_inventDim">The inventory dimension for the originating transaction; optional.
    /// </param>
    /// <remarks>
    /// Specific types of requirements transactions need to have the originating
    /// inventory dimension that contains the batch number - the dimension stored in the
    /// transaction line are coverage dimensions so may not include a batch.
    /// </remarks>
    public void pdsSetShelfLifeFields(InventDim _inventDim = this.inventDim())
    {
        InventTable inventTable = this.inventTable();

        if (inventTable.isShelfLifeItem())
        {
            if (this.isReceipt())
            {
                // Set the expiry date either from the batch or item
                if (_inventDim && _inventDim.InventBatchId)
                {
                    this.PdsExpiryDate = InventBatch::find(_inventDim.InventBatchId, this.ItemId).pdsEffectiveExpiryDate();
                }

                if (!this.PdsExpiryDate)
                {
                    ReqPO reqPO = this.reqPo();
                    this.PdsExpiryDate = this.inventTable().pdsEffectExpiryDate(reqPO.SchedToDate ? reqPO.SchedToDate : this.ReqDate);
                }
            }

            if (this.RefType == ReqRefType::Sales)
            {
                // Sets the number of days from the sales line's shipping date that the product must be sellable.
                SalesLine salesLine = InventTransOriginSalesLine::salesLine(this.InventTransOrigin);
                this.PdsSellableDays = salesLine.pdsSellableDays(this.inventDim());
            }

            if (this.CustAccountId && this.RefType == ReqRefType::SalesForecast)
            {
                this.PdsSellableDays = PdsCustSellableDays::findValidRec(this.ItemId, this.CustAccountId, _inventDim).SellableDays;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCreateCoProducts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates co-product receipt records related to a planned order.
    /// </summary>
    /// <param name="_reqPO">
    /// Related reqPO parent record.
    /// </param>
    /// <param name="_reqPlanData">
    /// Master planning run plan record.
    /// </param>
    /// <param name="_coInventDim">
    /// InventDim for the coproduct.
    /// </param>
    /// <param name="_coItemId">
    /// Item of the issue.
    /// </param>
    public void pmfCreateCoProducts(
        ReqPO           _reqPO,
        ReqPlanData     _reqPlanData     = null,
        InventDim       _coInventDim     = null,
        ItemId          _coItemId        = '')
    {
        PmfCoBySearch           search;

        ReqSetup                setup;

        ReqSetup                childSetup;
        ReqSetupDim             childSetupDim;

        ReqTrans                reqTransCoBy;
        InventDim               inventDim;

        PmfFormulaCoBy          coby;

        if (!_reqPO.ItemBomId
            || ! _reqPO.RecId
            || _reqPO.RefType != ReqRefType::PmfPlannedProdBatch)
        {
            return;
        }

        if (! _reqPlanData)
        {
            _reqPlanData = ReqPlanData::newReqPlanVersion(this.PlanVersion);
        }

        setup    = _reqPlanData.newReqSetup(this.ItemId);
        _reqPlanData.newReqSetupDim(setup,this.CovInventDimId);

        search = PmfCoBySearch::newReqCalculation(_reqPO, setup);

        while (search.next())
        {
            coby = search.coBy();

            childSetup  = _reqPlanData.newReqSetup(coby.ItemId);

            reqTransCoBy.ItemId             = coby.ItemId;
            reqTransCoBy.PmfCoByRefRecId    = coby.RecId;
            reqTransCoBy.PlanVersion        = this.PlanVersion;
            reqTransCoBy.RefId              = this.RefId;
            reqTransCoBy.RefType            = ReqRefType::PmfCoProduct;

            inventDim                       = InventDim::find(coby.InventDimId);

            if (reqTransCoBy.ItemId == _coItemId
                && _coInventDim.InventDimId
                && InventDim::isInventDimEqualProductDim(EcoResProductDimGroupSetup::newItemId(childSetup.itemId()), _coInventDim, inventDim))
            {
                reqTransCoBy.CovInventDimId = _coInventDim.InventDimId;
            }
            else
            {
                reqTransCoBy.CovInventDimId = inventDim.reqCovDimId(InventDimGroupSetup::newItemId(childSetup.itemId()));
            }
            childSetupDim                   = _reqPlanData.newReqSetupDim(childSetup, reqTransCoBy.CovInventDimId);

            reqTransCoBy.initFromSetupDim(childSetupDim);

            reqTransCoBy.OpenStatus         = ReqOpenStatus::Zero;
            reqTransCoBy.Direction          = InventDirection::Receipt;

            // Qty calculation
            reqTransCoBy.Qty                =  coby.CoByQtySerie
                                               ? _reqPO.Qty * coby.CoByQty / coby.CoByQtySerie
                                               : 0;

            reqTransCoBy.Qty = decRound(reqTransCoBy.Qty, ReqTransPmfCreateCoProductsToggle::instance().isEnabled() ? childSetup.inventDecimals() : setup.inventDecimals());

            // Default requirement dates from the dates of the primary output
            reqTransCoBy.ReqTime         = _reqPO.ReqTime;
            reqTransCoBy.ReqDateDlvOrig  = _reqPO.ReqDateDlv;
            reqTransCoBy.ReqDate         = _reqPO.ReqDate;

            reqTransCoBy.IsDerivedDirectly = childSetupDim.setup().mustBeDerivedDirectly(BomType::Item);

            if (_reqPlanData.pdsUseShelfLife())
            {
                reqTransCoBy.pdsSetShelfLifeFields();
            }

            reqTransCoBy.insert(_reqPlanData);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfDeleteCoProducts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes co-product requirement transactions for the current batch planned order record.
    /// </summary>
    /// <param name="_reqPlanData">
    /// The requirements plan data object with the current scheduling plan information.
    /// </param>
    public void pmfDeleteCoProducts(ReqPlanData _reqPlanData = null)
    {
        ReqTrans    derived;

        if (this.RefType == ReqRefType::PmfPlannedProdBatch)
        {
            while select forupdate derived
                where derived.PlanVersion  == this.PlanVersion
                   && derived.RefType      == ReqRefType::PmfCoProduct
                   && derived.RefId        == this.RefId
            {
                derived.delete(_reqPlanData, true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfSetPlanningData</Name>
				<Source><![CDATA[
    private void pmfSetPlanningData()
    {
        #PmfProcessMfg
        ReqItemTable reqItemTable;
        boolean isPmfTransaction;

        if (#PmfEnabled)
        {
            isPmfTransaction = this.isPmfTransaction();

            if (isPmfTransaction)
            {
                this.PmfPlanningItemId =
                    InventTable::find(this.ItemId).PmfPlanningItemId;
            }

            if (this.PmfPlanPriorityCurrent <= #PMF_PlanZero)
            {
                if (isPmfTransaction)
                {
                    reqItemTable = ReqItemTable::find(
                                        this.ItemId,
                                        this.CovInventDimId);
                }

                if (reqItemTable)
                {
                    this.PmfPlanPriorityCurrent =
                        reqItemTable.PmfPlanPriorityCurrent;
                }
                else
                {
                    this.PmfPlanPriorityCurrent = #PMF_Plan99;
                }
            }

            if (this.PmfPlanGroupId)
            {
                // Mark as primary issue if the quantity has been set
                this.PmfPlanGroupPrimaryIssue = (this.Qty != 0);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfUpdateCoProductDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the requirement and future date on related co-product outputs.
    /// </summary>
    public void pmfUpdateCoProductDates()
    {
        ReqTrans reqTransCo;

        while select forupdate reqTransCo
            where reqTransCo.PlanVersion  == this.PlanVersion
                && reqTransCo.RefType      == ReqRefType::PmfCoProduct
                && reqTransCo.RefId        == this.RefId
        {
            // The Co-products should directly inherit the dates from the primary output
            reqTransCo.ReqDate     = this.ReqDate;
            reqTransCo.ReqTime     = this.ReqTime;
            reqTransCo.FuturesDate = this.FuturesDate;
            reqTransCo.FuturesTime = this.FuturesTime;

            // If an expiry date has already been applied then it must be updated based on the new requirement (=inventory) date
            if (reqTransCo.PdsExpiryDate)
            {
                reqTransCo.PdsExpiryDate = reqTransCo.inventTable().pdsEffectExpiryDate(reqTransCo.ReqDate);
            }

            reqTransCo.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfUpdateCoProductsQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the quantities on all co-product transactions for the current
    /// planned batch order transaction.
    /// </summary>
    /// <param name="_reqPlanData">
    /// The data for the current requirement plan. This defaults to <c>null</c>, in which
    /// case this creates a new instance using the current master plan ID.
    /// </param>
    /// <remarks>
    /// The current record should be the transaction record for a planned batch
    /// order. However, if the current record is not, then this method will check
    /// and not do any processing.
    /// </remarks>
    public void pmfUpdateCoProductsQty(ReqPlanData _reqPlanData = null)
    {
        ReqSetup        setup;
        ReqPlanData     reqPlanData = _reqPlanData;
        ReqTrans        reqTransCo;
        PmfFormulaCoBy  coby;

        if (this.RefType == ReqRefType::PmfPlannedProdBatch)
        {
            if (!reqPlanData)
            {
                reqPlanData = ReqPlanData::newReqPlanVersion(this.PlanVersion);
            }

            setup = reqPlanData.newReqSetup(this.ItemId);
            reqPlanData.newReqSetupDim(setup,this.CovInventDimId);

            while select forupdate reqTransCo
                index hint RefIdx
                where  reqTransCo.PlanVersion   == this.PlanVersion
                    && reqTransCo.RefType       == ReqRefType::PmfCoProduct
                    && reqTransCo.RefId         == this.RefId
                join CoByQty, CoByQtySerie
                from coby
                    where  coby.RecId           == reqTransCo.PmfCoByRefRecId
            {
                reqTransCo.Qty = this.Qty * coby.CoByQty / coby.CoByQtySerie;
                reqTransCo.Qty = decRound(reqTransCo.Qty, setup.inventDecimals());

                reqTransCo.update(reqPlanData);

                if (reqTransCo.OpenStatus == ReqOpenStatus::Neg)
                {
                    reqPlanData.addReqTransCache(reqTransCo);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyCovOnhand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the coverage quantity for the current <c>ReqTrans</c> record that is covered by on-hand.
    /// </summary>
    /// <returns>
    /// A real value that holds the coverage quantity that is covered by on-hand.
    /// </returns>
    InventQty qtyCovOnhand()
    {
        ReqTransCov             reqTransCov;
        ReqTrans                reqTransReceipt;

        if (this.CovQty && this.InventTransOrigin && this.Direction == InventDirection::Issue)
        {
            select forceplaceholders sum(Qty) from reqTransCov
                group by IssueRecId
                where reqTransCov.IssueRecId == this.RecId
            join reqTransReceipt
                index hint RecId
                where reqTransReceipt.RecId   == reqTransCov.ReceiptRecId &&
                      reqTransReceipt.RefType == ReqRefType::InventOnHand;

            return reqTransCov.Qty;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refBOM</Name>
				<Source><![CDATA[
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public BOM refBOM()
    {
        BOM bom;

        select bom
            index hint recid
            where bom.RecId == this.bomRefRecId;

        return bom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqDateOrder</Name>
				<Source><![CDATA[
    ReqDateOrder reqDateOrder()
    {
        if (this.isPlannedOrder())
        {
            return this.reqPo().ReqDateOrder;
        }

        return this.ReqDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqDateSchedBackward</Name>
				<Source><![CDATA[
    ReqDate reqDateSchedBackward(
        ReqDate     _reqDate,
        ReqPlanData _reqPlanData = null
        )
    {
        ReqSetupDim setupDim;

        if (! _reqPlanData)
        {
            _reqPlanData = ReqPlanData::newReqPlanVersion(this.PlanVersion);
        }

        setupDim = _reqPlanData.newReqSetupDim(_reqPlanData.newReqSetup(this.ItemId),this.CovInventDimId);

        return _reqPlanData.workCalendarSched().schedDate(SchedDirection::Backward,_reqDate,_reqPlanData.marginReceipt(setupDim),_reqPlanData.marginCalendarDays(),setupDim.reqCalendarId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqExplodeTypeDefault</Name>
				<Source><![CDATA[
    ReqExplodeType reqExplodeTypeDefault()
    {
        return ReqRefTypeDescriptor::newFromReqRefType(this.RefType).reqExplodeType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqPo</Name>
				<Source><![CDATA[
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    ReqPO   reqPo(boolean _forUpdate = false)
    {
        ReqPO   reqPO;

        reqPO.selectForUpdate(_forUpdate);

        if (this.isPlannedOrder() || this.isDerivedFromPlannedOrder())
        {
            select reqPO
                where reqPO.PlanVersion == this.PlanVersion
                   && reqPO.RefId       == this.RefId;
        }

        return reqPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReqPo</Name>
				<Source><![CDATA[
    internal ReqPO getReqPo(ReqPlanData _reqPlanData, boolean _forUpdate = false)
    {
        ReqTransCache reqTransCache = _reqPlanData ? _reqPlanData.reqTransCache() : null;

        if (!reqTransCache)
        {
            return this.reqPo(_forUpdate);
        }

        if (_forUpdate)
        {
            // Clean cache
            reqTransCache.reqPoCacheDelete(this.RefId);

            return this.reqPo(_forUpdate);
        }

        ReqPO reqPO = reqTransCache.reqPoCacheLookup(this.RefId);

        if (!reqPO)
        {
            reqPO = this.reqPo(_forUpdate);
            reqTransCache.reqPoCacheInsert(reqPO);
        }

        return reqPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqRefTypeImage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns icon based on the referenced order type.
    /// </summary>
    /// <returns>
    /// Icon based on the referenced order type.
    /// </returns>
    display ImageRes reqRefTypeImage()
    {
        #ResAppl

        ImageRes    ret = #ImageBlank2;

        switch (this.RefType)
        {
            case ReqRefType::None :
                ret  = #ImageBlank2;
                break;

            case ReqRefType::InventOnHand :
                ret = #ImageReqRefInventOnhand;
                break;

            case ReqRefType::Purch :
                ret = #ImageReqRefPurch;
                break;

            case ReqRefType::Quarantine :
                ret = #ImageReqRefPurch;
                break;

            case ReqRefType::Production :
                ret = #ImageReqRefProduction;
                break;

            case ReqRefType::Kanban :
                ret = #ImageReqRefKanban;
                break;

            case ReqRefType::Sales :
                ret = #ImageReqRefSales;
                break;

            case ReqRefType::ProdLine :
                ret = #ImageReqRefProdLine;
                break;

            case ReqRefType::KanbanLine :
                ret = #ImageReqRefKanbanLine;
                break;

            case ReqRefType::InventJournal :
                ret = #ImageReqRefInventJournal;
                break;

            case ReqRefType::TransferOrderReceive :
                ret = #ImageReqRefTransferOrderReceive;
                break;

            case ReqRefType::TransferOrderShip :
                ret = #ImageReqRefTransferOrderShip;
                break;

            case ReqRefType::SalesForecast :
                ret = #ImageReqRefSalesForecast;
                break;

            case ReqRefType::SalesQuotation :
                return #ImageReqRefProdLine;

            case ReqRefType::PmfPlannedProdBatch:
            case ReqRefType::BOMPlannedOrder :
                if (this.IsForecastPurch)
                {
                    ret = #ImageReqRefBOMPlannedOrderForecast;
                }
                else
                {
                    ret = #ImageReqRefBOMPlannedOrder;
                }
                break;

            case ReqRefType::PlannedKanban:
                ret = #ImageKanbanJobPlanned;
                break;

            case ReqRefType::PmfFormulaLine :
            case ReqRefType::BOMLine :
            case ReqRefType::PlannedKanbanLine :
                ret = #ImageReqRefBOMLine;
                break;

            case ReqRefType::ItemPlannedOrder :
            case ReqRefType::RequisitionLine :
                if (this.IsForecastPurch)
                {
                    ret = #ImageReqRefItemPlannedOrderForecast;
                }
                ret = #ImageReqRefItemPlannedOrder;
                break;

            case ReqRefType::TransferPlannedOrder :
                if (this.IsForecastPurch)
                {
                    ret = #ImageReqRefTransferPlannedOrderForecast;
                }
                else
                {
                    ret = #ImageReqRefTransferPlannedOrder;
                }
                break;

            case ReqRefType::TransferDemand :
                ret = #ImageReqRefTransferDemand;
                break;

            case ReqRefType::PlannedIntercompanyDemand :
                ret = #ImageReqRefTransIntercompanyDemand;
                break;

            case ReqRefType::ConsignmentReplenishmentOrder :
                ret = #ImageReqRefInventJournal;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqSetup</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public ReqSetup reqSetup(ReqPlanData _reqPlanData = null)
    {
        return _reqPlanData ? _reqPlanData.newReqSetup(this.ItemId) : ReqSetup::newItemId(this.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqSetupDim</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public ReqSetupDim reqSetupDim(ReqPlanData _reqPlanData = null)
    {
        return _reqPlanData ?
            _reqPlanData.newReqSetupDim(_reqPlanData.newReqSetup(this.ItemId), this.CovInventDimId) :
            ReqSetupDim::newCovInventDimId(ReqSetup::newItemId(this.ItemId), this.CovInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTimeOrder</Name>
				<Source><![CDATA[
    ReqTimeOrder reqTimeOrder()
    {
        if (this.isPlannedOrder())
        {
            return this.reqPo().ReqTimeOrder;
        }

        return this.ReqTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransDirectlyDerived</Name>
				<Source><![CDATA[
    public ReqTrans reqTransDirectlyDerived(boolean _forupdate = false)
    {
        ReqTransCov     reqTransCov;
        ReqTrans        reqTrans;

        reqTransCov.selectForUpdate(_forupdate);
        reqTrans.selectForUpdate(_forupdate);

        if (! this.IsDerivedDirectly)
        {
            throw error(strFmt("@SYS68912",funcName()));
        }

        if (this.Direction == InventDirection::Receipt || this.Qty > 0 || this.CovQty > 0)
        {
            select firstonly reqTrans
                index hint RecId
                where reqTrans.IsDerivedDirectly
                exists join reqTransCov
                    where reqTransCov.ReceiptRecId  == this.RecId
                       && reqTransCov.IssueRecId    == reqTrans.RecId
                       && reqTransCov.Qty           != 0;
        }
        else
        {
            select firstonly reqTrans
                index hint RecId
                where reqTrans.IsDerivedDirectly
                exists join reqTransCov
                    where reqTransCov.ReceiptRecId  == reqTrans.RecId
                       && reqTransCov.IssueRecId    == this.RecId
                       && reqTransCov.Qty           != 0;
        }

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransSettled</Name>
				<Source><![CDATA[
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public ReqTrans reqTransSettled(
        ReqTransCov         _reqTransCov,
        boolean             _forupdate = false
        )
    {
        ReqTrans        reqTrans;
        reqTrans.selectForUpdate(_forupdate);

        if (this.Direction == InventDirection::Receipt || this.Qty > 0 || this.CovQty > 0)
        {
            select reqTrans
                index hint RecId
                where reqTrans.RecId == _reqTransCov.IssueRecId;
        }
        else
        {
            select reqTrans
                index hint RecId
                where reqTrans.RecId == _reqTransCov.ReceiptRecId;
        }

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransTransferDemand</Name>
				<Source><![CDATA[
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public ReqTrans reqTransTransferDemand(boolean _forUpdate = false)
    {
        ReqTrans reqTrans;
        reqTrans.selectForUpdate(_forUpdate);

        if (this.RefType == ReqRefType::TransferPlannedOrder)
        {
            select reqTrans
                where reqTrans.PlanVersion            == this.PlanVersion             &&
                      reqTrans.RefType                == ReqRefType::TransferDemand   &&
                      reqTrans.RefId                  == this.RefId;
        }

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetFutures</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Resets the futures data of this record.
    /// </summary>
    public void resetFutures()
    {
        this.FuturesDate = dateNull();
        this.FuturesTime = 0;
        this.FuturesDays = 0;
        this.FuturesMarked = NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFutures</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the futures date based on the delivery date.
    /// </summary>
    /// <param name = "_reqPlanData">Plan data.</param>
    public void initializeFutures(ReqPlanData _reqPlanData)
    {
        this.FuturesDate = this.ReqDateDlvOrig;
        this.FuturesTime = 0;

        if (this.FuturesDate < _reqPlanData.todaysdate())
        {
            this.FuturesDate = _reqPlanData.todaysdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectCov</Name>
				<Source><![CDATA[
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public ReqTransCov selectCov(boolean _forupdate = false)
    {
        ReqTransCov reqTransCov;
        reqTransCov.selectForUpdate(_forupdate);

        if (this.Direction == InventDirection::Receipt || this.Qty > 0 || this.CovQty > 0)
        {
            select reqTransCov
                index hint ReceiptIdx
                where reqTransCov.ReceiptRecId == this.RecId;
        }
        else
        {
            select reqTransCov
                index hint IssueIdx
                where reqTransCov.IssueRecId == this.RecId;
        }

        return reqTransCov;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectCovJoinTrans</Name>
				<Source><![CDATA[
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public ReqTransCov selectCovJoinTrans(boolean _forupdate = false)
    {
        ReqTransCov     reqTransCov;
        ReqTrans        reqTrans;
        reqTransCov.selectForUpdate(_forupdate);

        if (this.Direction == InventDirection::Receipt || this.Qty > 0 || this.CovQty > 0)
        {
            select forceplaceholders reqTransCov
                where reqTransCov.ReceiptRecId == this.RecId
            join reqTrans
                index hint RecId
                where reqTrans.RecId == reqTransCov.IssueRecId;
        }
        else
        {
            select forceplaceholders reqTransCov
                where reqTransCov.IssueRecId == this.RecId
            join reqTrans
                index hint RecId
                where reqTrans.RecId == reqTransCov.ReceiptRecId;
        }

        return reqTransCov;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectCovJoinTransDerived</Name>
				<Source><![CDATA[
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public ReqTransCov selectCovJoinTransDerived(boolean _forupdate = false)
    {
        ReqTransCov     reqTransCov;
        ReqTrans        reqTrans;

        reqTrans.selectForUpdate(_forupdate);

        if (this.isReceipt() || this.CovQty > 0)
        {
            select forceplaceholders reqTransCov
                index hint ReceiptIdx
                where reqTransCov.ReceiptRecId == this.RecId
            join reqTrans
                index hint RecId
                where reqTrans.RecId    == reqTransCov.IssueRecId           &&
                      reqTrans.IsDerivedDirectly                            &&
                     (reqTrans.RefType  == ReqRefType::BOMPlannedOrder      ||
                      reqTrans.RefType  == ReqRefType::ItemPlannedOrder     ||
                      reqTrans.RefType  == ReqRefType::TransferPlannedOrder ||
                      reqTrans.RefType  == ReqRefType::PlannedKanban        ||
                      reqTrans.RefType  == ReqRefType::PmfPlannedProdBatch
                      );
        }
        else
        {
            select forceplaceholders reqTransCov
                index hint IssueIdx
                where reqTransCov.IssueRecId == this.RecId
            join reqTrans
                index hint RecId
                where reqTrans.RecId    == reqTransCov.ReceiptRecId         &&
                      reqTrans.IsDerivedDirectly                            &&
                     (reqTrans.RefType  == ReqRefType::BOMPlannedOrder      ||
                      reqTrans.RefType  == ReqRefType::ItemPlannedOrder     ||
                      reqTrans.RefType  == ReqRefType::TransferPlannedOrder ||
                      reqTrans.RefType  == ReqRefType::PlannedKanban        ||
                      reqTrans.RefType  == ReqRefType::PmfPlannedProdBatch
                      );
        }

        return reqTransCov;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectDerived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Selects derived <c>ReqTrans</c> records from the current <c>ReqTrans</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    /// true if records should be selected for update; otherwise, false.
    /// </param>
    /// <param name="_allowIntercompany">
    /// A <c>boolean</c> value that indicates if cross company queries are allowed; optional.
    /// </param>
    /// <returns>
    /// Derived <c>ReqTrans</c> records.
    /// </returns>
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public ReqTrans selectDerived(boolean _forUpdate = false, boolean _allowIntercompany = false)
    {
        ReqTrans                        reqTrans;

        InventTransOrigin               inventTransOriginTransferShip, inventTransOriginTransferReceipt;
        InventTransOriginTransfer       inventTransOriginTransfer;
        InventTransferLine              inventTransferLine;

        ReqPO                           reqPO;
        SalesLine                       salesLine;
        PurchLine                       purchLine;

        Map                             planVersionPerCompany;
        MapEnumerator                   mapEnumerator;
        boolean                         doMapInsert;
        boolean                         isDynamicPlan;
        boolean                         isStaticPlan;
        boolean                         isPrevDynamicPlan;
        boolean                         isPrevStaticPlan;
        RefRecId                        planVersionFound;

        Query                           incomingDemandQuery;
        QueryRun                        incomingDemandQueryRun;
        QueryBuildDataSource            qbdsReqTrans;
        str                             allowedPlanVersionsFilter;

        ReqPlanVersion                  reqPlanVersion;
        ReqParameters                   reqParameters;
        ReqRefType                      derivedRefType;

        reqTrans.selectForUpdate(_forUpdate);

        switch (true)
        {
            // transfer order
            case this.RefType == ReqRefType::TransferOrderReceive:
                // jumping over transactions on transit warehouse as those isn't in the profile.
                select reqTrans
                    where reqTrans.PlanVersion == this.PlanVersion
                       && reqTrans.RefType ==  ReqTrans::derivedRefType(this.RefType)
                       && reqTrans.RefId == this.RefId
                       && reqTrans.ItemId == this.ItemId
                    exists join inventTransOriginTransferShip
                        where inventTransOriginTransferShip.RecId == reqTrans.InventTransOrigin
                    exists join inventTransferLine
                        where inventTransferLine.InventTransId == inventTransOriginTransferShip.InventTransId
                    exists join inventTransOriginTransferReceipt
                        where inventTransOriginTransferReceipt.InventTransId == inventTransferLine.InventTransIdReceive
                            && inventTransOriginTransferReceipt.RecId == this.InventTransOrigin;
                break;

            // transfer journals
            case  this.RefType == ReqRefType::InventTransfer:

                derivedRefType = ReqTrans::derivedRefType(this.RefType);

                select reqTrans
                    where reqTrans.PlanVersion          == this.PlanVersion
                       && reqTrans.RefType              == derivedRefType
                       && reqTrans.RefId                == this.RefId
                       && reqTrans.ItemId               == this.ItemId
                       && (this.RefType != derivedRefType || reqTrans.Qty < 0)
                    exists join inventTransOriginTransfer
                        where inventTransOriginTransfer.ReceiptInventTransOrigin == this.InventTransOrigin
                           && inventTransOriginTransfer.IssueInventTransOrigin   == reqTrans.InventTransOrigin;

                break;

            // Selection of intercompany demand from planned purchase order
            case this.RefType == ReqRefType::ItemPlannedOrder && _allowIntercompany:

                reqPO = this.reqPo();
                if (reqPO)
                {
                    // Determine which plan to include records from
                    // The order is: Dynamic plan (if any), Static plan (if any), other plans
                    planVersionPerCompany = new Map(Types::String, Types::Container);

                    while select crossCompany reqTrans
                        where reqTrans.RefType                  == ReqRefType::PlannedIntercompanyDemand
                           && reqTrans.IntercompanyPlannedOrder == reqPO.RecId
                        join ReqPlanId from reqPlanVersion
                            where reqPlanVersion.RecId == reqTrans.PlanVersion
                               && reqPlanVersion.Active         == NoYes::Yes
                    {
                        changecompany(reqTrans.company())
                        {
                            isDynamicPlan   = false;
                            isStaticPlan    = false;
                            doMapInsert     = false;
                            reqParameters = ReqParameters::find();

                            if (reqParameters.CurrentReqPlanIdSchedDynamic == reqPlanVersion.ReqPlanId)
                            {
                                isDynamicPlan = true;
                            }
                            else if (reqParameters.CurrentReqPlanIdSchedStatic == reqPlanVersion.ReqPlanId)
                            {
                                isStaticPlan = true;
                            }

                            if (isDynamicPlan)
                            {
                                doMapInsert = true;
                            }
                            else if (planVersionPerCompany.exists(reqTrans.company()))
                            {
                                [isPrevDynamicPlan, isPrevStaticPlan, planVersionFound] = planVersionPerCompany.lookup(reqTrans.company());
                                doMapInsert = !(isPrevDynamicPlan || isPrevStaticPlan);
                            }
                            else
                            {
                                doMapInsert = true;
                            }

                            if (doMapInsert)
                            {
                                planVersionPerCompany.insert(reqTrans.company(), [isDynamicPlan, isStaticPlan, reqTrans.PlanVersion]);
                            }
                        }
                    }

                    // build query to include only the selected plans
                    incomingDemandQuery = new Query();
                    incomingDemandQuery.allowCrossCompany(true);

                    qbdsReqTrans = incomingDemandQuery.addDataSource(tableNum(ReqTrans));

                    allowedPlanVersionsFilter = '';
                    mapEnumerator = planVersionPerCompany.getEnumerator();
                    while (mapEnumerator.moveNext())
                    {
                        if (allowedPlanVersionsFilter != '')
                        {
                            allowedPlanVersionsFilter += '||';
                        }

                        [isDynamicPlan, isStaticPlan, planVersionFound] = mapEnumerator.currentValue();
                        allowedPlanVersionsFilter += strFmt('(%1.%2 == %3)',
                                                            qbdsReqTrans.name(),
                                                            fieldStr(ReqTrans, PlanVersion),
                                                            queryValue(planVersionFound));
                    }

                    // run the query only if any plans were found
                    if (allowedPlanVersionsFilter != '')
                    {
                        qbdsReqTrans.addRange(fieldNum(ReqTrans, RefType))
                                    .value(queryValue(enum2int(ReqRefType::PlannedIntercompanyDemand)));
                        qbdsReqTrans.addRange(fieldNum(ReqTrans, IntercompanyPlannedOrder))
                                    .value(queryValue(reqPO.RecId));
                        qbdsReqTrans.addRange(fieldNum(ReqTrans, PlanVersion))
                                    .value(allowedPlanVersionsFilter);

                        incomingDemandQueryRun = new QueryRun(incomingDemandQuery);
                        incomingDemandQueryRun.next();

                        reqTrans = incomingDemandQueryRun.get(tableNum(ReqTrans));
                    }
                }

                break;

            // Selection of intercompany based sales order from purchase order
            case this.RefType == ReqRefType::Purch && _allowIntercompany:

                purchLine = InventTransOriginPurchLine::purchLine(this.InventTransOrigin);
                salesLine = purchLine.interCompanySalesLine();
                if (salesLine)
                {
                    changecompany(salesLine.company())
                    {
                        reqTrans = salesLine.reqTrans();
                    }
                }

                break;

            case this.RefType == ReqRefType::PmfCoProduct:
                
                derivedRefType = this.InventTransOrigin && ReqTransSelectDerivedPmfCoProductForProductionToggle::instance().isEnabled() ?
                                 ReqTrans::derivedRefType(ReqRefType::Production) : 
                                 ReqTrans::derivedRefType(ReqRefType::PmfPlannedProdBatch);

                select reqTrans
                    where reqTrans.PlanVersion  == this.PlanVersion
                       && reqTrans.RefType      == derivedRefType
                       && reqTrans.RefId        == this.RefId;
                break;

            // general case - derived type exists
            case ReqTrans::derivedRefType(this.RefType) != ReqRefType::None:

                derivedRefType = ReqTrans::derivedRefType(this.RefType);

                select reqTrans
                    where reqTrans.PlanVersion  == this.PlanVersion
                       && reqTrans.RefType      == derivedRefType
                       && reqTrans.RefId        == this.RefId
                       && (this.RefType != derivedRefType || reqTrans.Qty < 0);

                break;
        }

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Selects parent <c>ReqTrans</c> records from the current <c>ReqTrans</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    /// true if records should be selected for update; otherwise, false.
    /// </param>
    /// <param name="_allowIntercompany">
    /// A <c>boolean</c> value that indicates if cross company queries are allowed; optional.
    /// </param>
    /// <returns>
    /// Parent <c>ReqTrans</c> records.
    /// </returns>
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    public ReqTrans selectParent(boolean _forUpdate = false, boolean _allowIntercompany = false)
    {
        ReqTrans                            reqTrans;
        ReqPO                               reqPO;

        InventTransOriginTransferReceive    inventTransOriginTransferReceipt;
        InventTransOriginTransfer           inventTransOriginTransfer;

        SalesLine                           salesLine;
        PurchLine                           purchLine;

        ReqRefType                          parentRefType = this.parentReqRefType();

        reqTrans.selectForUpdate(_forUpdate);

        switch (true)
        {
            // transfer order
            case this.RefType == ReqRefType::TransferOrderShip:
                // jumping over transactions on transit warehouse as those aren't in the profile.
                select reqTrans
                    where reqTrans.PlanVersion  == this.PlanVersion
                       && reqTrans.RefType      == parentRefType
                       && reqTrans.RefId        == this.RefId
                       && reqTrans.ItemId       == this.ItemId
                    exists join inventTransOriginTransferReceipt
                        where inventTransOriginTransferReceipt.InventTransOrigin == reqTrans.InventTransOrigin;
                break;

            // transfer journals
            case  this.RefType == ReqRefType::InventTransfer:

                select reqTrans
                    where reqTrans.PlanVersion          == this.PlanVersion
                       && reqTrans.RefType              == parentRefType
                       && reqTrans.RefId                == this.RefId
                       && reqTrans.ItemId               == this.ItemId
                       && (this.RefType != parentRefType || reqTrans.Qty > 0)
                    exists join inventTransOriginTransfer
                        where  inventTransOriginTransfer.IssueInventTransOrigin     == this.InventTransOrigin
                            && inventTransOriginTransfer.ReceiptInventTransOrigin   == reqTrans.InventTransOrigin;

                break;

            // selection of intercompany planned purchase from an intercompany planned demand
            case this.RefType == ReqRefType::PlannedIntercompanyDemand && _allowIntercompany:

                reqPO = this.intercompanyParentReqPO();

                if (reqPO)
                {
                    changecompany(reqPO.company())
                    {
                        reqTrans = reqPO.reqTrans();
                    }
                }

                break;

            // Selection of intercompany based purchase order from sales order
            case this.RefType == ReqRefType::Sales && _allowIntercompany:

                salesLine = InventTransOriginSalesLine::salesLine(this.InventTransOrigin);
                purchLine = salesLine.interCompanyPurchLine();
                if (purchLine)
                {
                    changecompany(purchLine.company())
                    {
                        reqTrans = purchLine.reqTrans();
                    }
                }

                break;

            // general case - parent type exists
            case this.parentReqRefType() != ReqRefType::None:

                select reqTrans
                    where reqTrans.PlanVersion  == this.PlanVersion
                       && reqTrans.RefType      == parentRefType
                       && reqTrans.RefId        == this.RefId
                       && (this.RefType != parentRefType || reqTrans.Qty > 0);

                break;
        }

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAction</Name>
				<Source><![CDATA[
    public void setAction()
    {
        if (this.actionSum() == 0)
        {
            this.ActionType = ActionType::Cancel;
            this.ActionDays = 0;
            this.ActionDate = this.ReqDate;
        }
        else
        {
            this.ActionType     = ActionType::None;
            this.ActionDate     = this.ReqDate + this.ActionDays;

            if (abs(this.actionSum()) > abs(this.Qty))
            {
                this.ActionType = ActionType::Appreciate;
            }
            else if (abs(this.actionSum())  < abs(this.Qty))
            {
                this.ActionType = ActionType::Depreciate;
            }

            if (this.ActionDate > this.ReqDate)
            {
                if (! this.ActionType)
                {
                    this.ActionType = ActionType::Postpone;
                }
                else if (this.ActionType == ActionType::Appreciate)
                {
                    this.ActionType = ActionType::PostponeAppreciate;
                }
                else if (this.ActionType == ActionType::Depreciate)
                {
                    this.ActionType = ActionType::PostponeDepreciate;
                }
            }
            else if (this.ActionDate < this.ReqDate)
            {
                if (! this.ActionType)
                {
                    this.ActionType = ActionType::Advance;
                }
                else if (this.ActionType == ActionType::Appreciate)
                {
                    this.ActionType = ActionType::AdvanceAppreciate;
                }
                else if (this.ActionType == ActionType::Depreciate)
                {
                    this.ActionType = ActionType::AdvanceDepreciate;
                }
            }
        }

        this.ActionMarked  = this.ActionType != ActionType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDirection</Name>
				<Source><![CDATA[
    public void setDirection()
    {
        if (this.Qty   > 0)
        {
            this.Direction= InventDirection::Receipt;
        }
        else if (this.Qty   < 0)
        {
            this.Direction= InventDirection::Issue;
        }
        else
        {
            this.Direction= InventDirection::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFields</Name>
				<Source><![CDATA[
    public void setFields(TransDate _todaysdate)
    {
        if (! this.ReqDate && this.RefType != ReqRefType::InventOnHand)
        {
            this.ReqDate = _todaysdate;
        }

        this.ReqDateDlvOrig = this.ReqDateDlvOrig ? this.ReqDateDlvOrig : this.ReqDate;

        this.ActionDate     = this.ReqDate + this.ActionDays;

        this.setOpenStatus();

        if (this.FuturesDate)
        {
            this.FuturesDays = this.FuturesDate - this.ReqDateDlvOrig;

            if (this.FuturesDays >  0)
            {
                this.FuturesMarked = NoYes::Yes;
            }
            else
            {
                this.FuturesMarked = NoYes::No;
            }
        }
        else
        {
            this.FuturesDays   = 0;
            this.FuturesMarked = NoYes::No;
        }

        this.initializeReceiptTime();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMinFuturesDateTimeIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the minimum delay date and time for an issue
    /// if it is pegged with the specified receipt.
    /// </summary>
    /// <param name = "_receiptReqTrans">The receipt <c>ReqTrans</c> record.</param>
    /// <param name = "_reqPlanData">Parameters of the current master planning run.</param>
    /// <param name = "_setupDim">Planning parameters for the current combination of item and coverage dimensions.</param>
    /// <param name = "_skipLogging">A boolean value indicating whether to skip logging.</param>
    /// <returns>The delay date and time.</returns>
    public ReqDateTime calculateMinFuturesDateTimeIssue(
        ReqTrans        _receiptReqTrans,
        ReqPlanData     _reqPlanData,
        ReqSetupDim     _setupDim,
        boolean         _skipLogging = true)
    {
        ReqTraceLogger reqTraceLogger = _skipLogging ? null : _reqPlanData.reqTraceLogger();
        boolean loggingEnabled = _skipLogging ? false : reqTraceLogger.loggingEnabled();

        if (loggingEnabled)
        {
            reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::FutureDateBasedOnReceipt, [this.RefId, _receiptReqTrans.RefId], this));
        }

        ReqDate futuresDateIssue = _receiptReqTrans.FuturesDate ? _receiptReqTrans.FuturesDate : _receiptReqTrans.ReqDate;

        if (!this.allowIssueFuturesDateInThePast(_receiptReqTrans))
        {
            futuresDateIssue = max(futuresDateIssue, _reqPlanData.todaysdate());
        }

        ReqTime futuresTimeIssue = _receiptReqTrans.ReqTime;

        if (loggingEnabled)
        {
            reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::InitialReceiptFutureDate, [futuresDateIssue]));
        }

        if (this.RefType == ReqRefType::Sales && _receiptReqTrans.FuturesTime > _reqPlanData.reqTimeFutures())
        {
            futuresDateIssue++;
            futuresTimeIssue = 0;
        }

        if (_receiptReqTrans.RefType != ReqRefType::InventOnHand && 
            (_receiptReqTrans.RefType != ReqRefType::SafetyInvent))
        {
            futuresDateIssue = _reqPlanData.schedMarginForward(futuresDateIssue, _reqPlanData.marginReceipt(_setupDim), _setupDim);
        }

        futuresDateIssue = _reqPlanData.schedMarginForward(futuresDateIssue, _reqPlanData.marginIssue(_setupDim), _setupDim);

        return new ReqDateTime(futuresDateIssue, futuresTimeIssue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowIssueFuturesDateInThePast</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the issue futures date in the past is allowed or not.
    /// This method is added for extensibility purposes.
    /// </summary>
    /// <param name = "_receiptReqTrans">The receipt <c>ReqTrans</c> record.</param>
    /// <returns>True if the issue futures date in the past is allowed; otherwise, false.</returns>
    protected boolean allowIssueFuturesDateInThePast(ReqTrans _receiptReqTrans)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFuturesDateTimeIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the futures date and time for the current issue requirement transaction.
    /// </summary>
    /// <param name="_receiptReqTrans">
    /// A <c>ReqTrans</c> record that represents a receipt requirement transaction that covers the current
    /// issue requirement transaction.
    /// </param>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that holds the master planning settings.
    /// </param>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that holds the coverage settings for a specific item ID and inventory
    /// dimensions.
    /// </param>
    public void setFuturesDateTimeIssue(
        ReqTrans        _receiptReqTrans,
        ReqPlanData     _reqPlanData,
        ReqSetupDim     _setupDim)
    {
        ReqTraceLogger  reqTraceLogger = _reqPlanData.reqTraceLogger();
        boolean         loggingEnabled = reqTraceLogger.loggingEnabled();

        if (this.isReceipt() || !_receiptReqTrans.isReceipt())
        {
            return;
        }

        boolean skipLogging = false;
        ReqDateTime futuresDateTimeIssue = this.calculateMinFuturesDateTimeIssue(_receiptReqTrans, _reqPlanData, _setupDim, skipLogging);

        if ((this.FuturesDate < futuresDateTimeIssue.parmDate()) ||
            (this.RefType == ReqRefType::ProdLine) ||
            (this.RefType == ReqRefType::BOMLine) ||
            (this.RefType == ReqRefType::PmfFormulaLine))
        {
            this.FuturesDate = futuresDateTimeIssue.parmDate();
            this.FuturesTime = futuresDateTimeIssue.parmTime();

            if (loggingEnabled)
            {
                reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::FutureDateAfterMargins, [futuresDateTimeIssue.parmDate()]));
            }
        }
        else
        {
            if (loggingEnabled)
            {
                reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::FutureDateNoChange, [futuresDateTimeIssue.parmDate(), this.FuturesDate]));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFuturesDateTimeReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the futures date and time for the current requirement transaction.
    /// </summary>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that holds master planning settings.
    /// A <c>ReqPlanData</c> object that holds the master planning settings.
    /// </param>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that holds coverage settings for a specific item ID and inventory dimensions.
    /// A <c>ReqSetupDim</c> object that holds the coverage settings for a specific item ID and inventory
    /// dimension.
    /// </param>
    /// <param name="_includeDerivedFutureDays">
    /// true if futures days from derived requirement transactions must be included; otherwise, false.
    /// A Boolean value that indicates whether futures days from derived requirement transactions must be
    /// included.
    /// </param>
    /// <returns>
    /// true if a new futures date has been determined; otherwise, false.
    /// </returns>
    public boolean setFuturesDateTimeReceipt(
        ReqPlanData     _reqPlanData,
        ReqSetupDim     _setupDim,
        boolean         _includeDerivedFutureDays)
    {
        ReqPO               reqPO;

        ReqTrans            intercompanyReqTrans;

        Days                futuresDays;
        ReqDateOrder        orderDate;

        SchedDate           schedFromDate;
        SchedDate           schedToDate;

        ReqTraceLogger  reqTraceLogger = _reqPlanData.reqTraceLogger();
        boolean         loggingEnabled = reqTraceLogger.loggingEnabled();
        boolean         isPlannedOrder = this.isPlannedOrder();

        if (! this.isReceipt())
        {
            return false;
        }

        if (isPlannedOrder)
        {
            reqPO = this.getReqPo(_reqPlanData);
        }

        if (loggingEnabled)
        {
            reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::FutureDateForReceipt, [this.RefId], this));
        }

        switch (this.RefType)
        {
            case ReqRefType::Production:
            case ReqRefType::PmfCoProduct:
            case ReqRefType::Kanban:
                futuresDays         = this.calcFuturesDaysReceipt(_reqPlanData.todaysdate(),_includeDerivedFutureDays);

                this.FuturesDate    = this.ReqDateDlvOrig + futuresDays;
                this.FuturesDate    = _reqPlanData.schedMarginForward(this.FuturesDate,0,_setupDim);

                if (loggingEnabled)
                {
                    reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::FutureDaysForwardReqDate, [futuresDays, this.ReqDateDlvOrig]));
                }
                break;

            case ReqRefType::BOMPlannedOrder:
            case ReqRefType::PmfPlannedProdBatch:
                futuresDays         = this.calcFuturesDaysReceipt(_reqPlanData.todaysdate(),_includeDerivedFutureDays,reqPO.ReqDateOrder);

                this.FuturesDate    = reqPO.SchedToDate + futuresDays;
                this.FuturesDate    = _reqPlanData.schedMarginForward(this.FuturesDate,0,_setupDim);

                if (loggingEnabled)
                {
                    reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::FutureDaysForwardSchedEnd, [futuresDays, reqPO.SchedToDate]));
                }

                break;

            case ReqRefType::TransferPlannedOrder:
            case ReqRefType::PlannedKanban:
            case ReqRefType::TransferOrderReceive:
                orderDate = max(reqPO.ReqDateOrder, _reqPlanData.todaysdate());
                if (_includeDerivedFutureDays || this.RefType == ReqRefType::TransferPlannedOrder)
                {
                    if (_reqPlanData.reqTransCache().parmProcessStatus() >= ReqProcessStatus::PreFutures)
                    {
                        orderDate = max(orderDate, _reqPlanData.schedMarginBackward(this.calcMaxFuturesDateFromDerived(),_reqPlanData.marginOrder(_setupDim),_setupDim));
                    }
                }

                if (!isPlannedOrder || orderDate > reqPO.ReqDateOrder)
                {
                    if (this.RefType == ReqRefType::TransferPlannedOrder)
                    {
                        schedFromDate   = _reqPlanData.schedMarginForwardWithCalendar(orderDate,_reqPlanData.marginOrder(_setupDim), _setupDim, _setupDim.shippingCalendarId(), '', SalesCheckForPickup::PrimaryCalendar);
                        schedToDate     = _reqPlanData.schedReqPoForward(schedFromDate, reqPO, _setupDim.transportCalendarId(), _setupDim.reqCalendarId());
                    }
                    else
                    {
                        schedFromDate   = _reqPlanData.schedMarginForward(orderDate,_reqPlanData.marginOrder(_setupDim),_setupDim);
                        schedToDate     = isPlannedOrder ? _reqPlanData.schedReqPoForward(schedFromDate, reqPO, _setupDim.reqCalendarId()) : schedFromDate;
                    }

                    if (this.FuturesDate < schedToDate)
                    {
                        this.FuturesDate = schedToDate;
                    }

                    if (loggingEnabled && this.RefType == ReqRefType::TransferPlannedOrder)
                    {
                        reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::FuturesDateDerivedTransfer, [orderDate, _reqPlanData.marginOrder(_setupDim)]));
                    }
                }
                else if (reqPO.ReqDateDlv > this.ReqDateDlvOrig)
                {
                    this.FuturesDate = reqPO.ReqDateDlv;
                }

                if (loggingEnabled && this.RefType == ReqRefType::PlannedKanban && this.FuturesDate != dateNull())
                {
                    reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::FutureDaysForwardSchedEnd, [this.FuturesDate - this.ReqDateDlvOrig, this.FuturesDate]));
                }

                break;

            case ReqRefType::ItemPlannedOrder :
                this.FuturesDate = _reqPlanData.todaysdate();
                boolean intercompanyReqTransExist = false;

                intercompanyReqTrans = this.selectDerived(false, _includeDerivedFutureDays);
                while (intercompanyReqTrans)
                {
                    this.FuturesDate = max(this.FuturesDate, intercompanyReqTrans.FuturesDate);
                    intercompanyReqTransExist = true;
                    next intercompanyReqTrans;
                }

                if (!intercompanyReqTransExist)
                {
                    this.FuturesDate = _reqPlanData.schedMarginForward(this.FuturesDate,_reqPlanData.marginOrder(_setupDim),_setupDim,_setupDim.purchCalendarId(reqPO.VendId));
                    this.FuturesDate = _reqPlanData.schedReqPoForward(this.FuturesDate,reqPO,_setupDim.purchCalendarId(reqPO.VendId));
                    this.FuturesDate = _reqPlanData.schedMarginForward(this.FuturesDate,0,_setupDim);
                }

                if (loggingEnabled)
                {
                    reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::FuturesDateTodayForward, [_reqPlanData.todaysdate(), _reqPlanData.marginOrder(_setupDim), reqPO.LeadTime, _setupDim.purchCalendarId(reqPO.VendId)]));
                }

                break;
        }

        this.FuturesTime = this.ReqTime;

        if (loggingEnabled)
        {
            if (this.FuturesDate > this.ReqDate)
            {
                reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::OrderDelayedDueToFutures, [this.FuturesDate, this.ReqDate]));
            }
            else
            {
                reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::OrderNotDelayed, [this.FuturesDate, this.ReqDate]));
            }
        }

        return this.FuturesDate > this.ReqDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOpenStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets this record's OpenStatus field, according to
    /// requirement quantity and covered quantity.
    /// </summary>
    public void setOpenStatus()
    {
        if (this.Qty > this.CovQty)
        {
            this.OpenStatus = ReqOpenStatus::Pos;
        }
        else if (this.Qty < this.CovQty)
        {
            this.OpenStatus = ReqOpenStatus::Neg;
        }
        else
        {
            this.OpenStatus = ReqOpenStatus::Zero;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSupplyDemandSubClassification</Name>
				<Source><![CDATA[
    public void setSupplyDemandSubClassification(InventTransType _inventTransType)
    {
        switch (_inventTransType)
        {
            case InventTransType::KanbanJobPickingList:
                this.SupplyDemandSubClassification = SupplyDemandSubClassification::ProductionKanban;
                break;

            case InventTransType::KanbanJobProcess:
                this.SupplyDemandSubClassification = SupplyDemandSubClassification::ProductionKanban;
                break;

            case InventTransType::KanbanJobTransferIssue:
                this.SupplyDemandSubClassification = SupplyDemandSubClassification::WithdrawalKanban;
                break;

            case InventTransType::KanbanJobTransferReceipt:
                this.SupplyDemandSubClassification = SupplyDemandSubClassification::WithdrawalKanban;
                break;

            case InventTransType::KanbanJobWIP:
                this.SupplyDemandSubClassification = SupplyDemandSubClassification::WithdrawalKanban;
                break;

            default:
                this.SupplyDemandSubClassification = SupplyDemandSubClassification::None;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sortingDate</Name>
				<Source><![CDATA[
    public ReqDate sortingDate(ReqSorting _sorting)
    {
        switch (_sorting)
        {
            case ReqSorting::ReqDate     :
                return this.ReqDate;
            case ReqSorting::ReqDateDlvOrig  :
                return this.ReqDateDlvOrig;
            case ReqSorting::FuturesDate :
                return this.FuturesDate;
            case ReqSorting::ActionDate  :
                return this.ActionDate;
        }

        return this.ReqDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>subCov</Name>
				<Source><![CDATA[
    public void subCov(ReqTransCov _reqTransCov)
    {
        if (this.Direction == InventDirection::Receipt || this.Qty > 0 || this.CovQty > 0)
        {
            this.CovQty -= -_reqTransCov.Qty;
        }
        else
        {
            this.CovQty -=  _reqTransCov.Qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>toDate</Name>
				<Source><![CDATA[
    ToDate toDate()
    {
        ProdTable   prodTable;
        KanbanJob       kanbanJob;
        TransDateTime   kanbanDateTime;

        if (this.isPlannedOrder() || this.isDerivedFromPlannedOrder())
        {
            return this.reqPo().SchedToDate;
        }

        switch (this.RefType)
        {
            case ReqRefType::Production:
            case ReqRefType::PmfCoProduct :
            case ReqRefType::ProdLine:
                select firstonly SchedEnd from prodTable
                    index hint ProdIdx
                    where prodTable.ProdId == this.RefId;

                return prodTable.SchedEnd;

            case ReqRefType::Kanban:
            case ReqRefType::KanbanLine:
                kanbanJob = this.kanbanJob();
                if (kanbanJob)
                {
                    kanbanDateTime = DateTimeUtil::applyTimeZoneOffset(kanbanJob.ExpectedDateTime,DateTimeUtil::getCompanyTimeZone());
                    return DateTimeUtil::date(kanbanDateTime);
                }
                break;
        }

        return this.ReqDateDlvOrig ? this.ReqDateDlvOrig : (this.ReqDate ? this.ReqDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>toTime</Name>
				<Source><![CDATA[
    SchedToTime toTime()
    {
        ProdTable   prodTable;
        KanbanJob       kanbanJob;
        TransDateTime   kanbanDateTime;

        if (this.isPlannedOrder())
        {
            return this.reqPo().ReqTime;
        }

        switch (this.RefType)
        {
            case ReqRefType::Production:
            case ReqRefType::PmfCoProduct :
            case ReqRefType::ProdLine:

                select firstonly SchedToTime from prodTable
                    index hint ProdIdx
                    where prodTable.ProdId == this.RefId;

                return prodTable.SchedToTime;

            case ReqRefType::Kanban:
            case ReqRefType::KanbanLine:
                kanbanJob = this.kanbanJob();
                if (kanbanJob)
                {
                    kanbanDateTime = DateTimeUtil::applyTimeZoneOffset(kanbanJob.ExpectedDateTime,DateTimeUtil::getCompanyTimeZone());
                    return DateTimeUtil::time(kanbanDateTime);
                }
        }

        return this.ReqTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitOfMeasure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the unit of measure for the item of the transaction.
    /// </summary>
    /// <returns>
    /// The unit of measure for the item.
    /// </returns>
    public display UnitOfMeasureSymbol unitOfMeasure()
    {
        return InventTable::find(this.ItemId).inventUnitId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update(ReqPlanData _reqPlanData = null,
                              boolean _reduceCovQty = true)
    {

        ttsbegin;

        if (this.orig().Qty != this.Qty)
        {
            if (_reduceCovQty)
            {
                this.updateReduceCovQty(_reqPlanData);
            }

            if  ((this.Qty           < 0         && this.Direction == InventDirection::Receipt  ) ||
                 (this.Qty           > 0         && this.Direction == InventDirection::Issue    ))
            {
                this.setDirection();
            }
        }

        this.setFields(_reqPlanData ? _reqPlanData.todaysdate() : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        if (this.Direction == InventDirection::None)
        {
            this.setDirection();
        }

        ReqTransCache reqTransCache = _reqPlanData ? _reqPlanData.reqTransCache() : null;
        if (reqTransCache)
        {
            this.skipTTSCheck(true);
        }

        super();

        if (reqTransCache)
        {
            reqTransCache.update(this);
        }

        ttscommit;

        if (_reqPlanData && _reqPlanData.inMemoryCache())
        {
            _reqPlanData.inMemoryCache().handleReqTransUpdated(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOMQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the requirement quantity for derived requirement transactions.
    /// </summary>
    /// <param name="_reqPO">
    /// A <c>ReqPO</c> record that represents a planned order.
    /// </param>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that holds master planning settings.
    /// </param>
    public void updateBOMQty(
        ReqPO           _reqPO,
        ReqPlanData     _reqPlanData     = null
        )
    {
        ReqTrans                reqTransDerived;
        ReqTrans                reqTransBOM;
        BOM                     bom;
        ReqPO                   reqPoBOM;
        BOMCalcData             bomCalcData;
        ReqTransCov             reqTransCov;
        BOMSearchPhantomExpand  bomSearchPhantomExpand;
        boolean                 useDlvDateFlightEnabled = ReqTransPoMarkFirmUseDlvDateForBOMVersionFlight::instance().isEnabled();

        if (ReqTrans::refTypeCanHaveBOM(this.RefType))
        {
            while select forupdate reqTransBOM
                where reqTransBOM.PlanVersion       == this.PlanVersion
                   && reqTransBOM.RefType           == ReqTrans::derivedRefType(this.RefType)
                   && reqTransBOM.RefId             == this.RefId
            {
                if (_reqPO.mustExpandPhantom())
                {
                    if (! bomSearchPhantomExpand)
                    {
                        bomSearchPhantomExpand = BOMSearchPhantomExpand::newParameters(
                            _reqPO.ItemId, 
                            _reqPO.inventDim(), 
                            _reqPO.Qty, 
                            _reqPO.ItemBomId, 
                            useDlvDateFlightEnabled ? _reqPO.getBOMDate() : _reqPO.ReqDate);
                    }
                    // this BOM line will contain the right quantities for phantom items
                    bom = bomSearchPhantomExpand.findBOM(reqTransBOM.bomRefRecId);
                }
                else
                {
                    bom = reqTransBOM.refBOM();
                }

                bomCalcData = bomCalcData ? bomCalcData : BOMCalcData::newInventTable(this.Qty, InventTable::find(reqTransBOM.ItemId));

                this.updateBOMReqTrans(reqTransBOM, _reqPO, _reqPlanData, bom, bomCalcData);
                // update directly derived BOM's
                if (reqTransBOM.IsDerivedDirectly)
                {
                    reqTransCov = reqTransBOM.selectCovJoinTransDerived(true);
                    if (reqTransCov.RecId)
                    {
                        reqTransDerived = reqTransCov.joinChild() as ReqTrans;
                        reqTransDerived.Qty = -reqTransBOM.Qty;
                        reqTransDerived.update(_reqPlanData);

                        reqPoBOM = reqTransDerived.getReqPo(_reqPlanData, true);
                        if (reqPoBOM.RecId && reqPoBOM.Qty != reqTransDerived.Qty)
                        {
                            reqPoBOM.Qty = reqTransDerived.Qty;
                            reqPoBOM.initPurchQty();
                            reqPoBOM.update();
                        }
                        reqTransDerived.updateBOMQty(reqPoBOM);

                        reqTransDerived.pmfUpdateCoProductsQty();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOMReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update an instance of net requirements used for derived requirement transactions.
    /// </summary>
    /// <param name = "_reqTransBOM">Net requirements need to be initialized for master planning.</param>
    /// <param name = "_reqPO">A planned order record.</param>
    /// <param name = "_reqPlanData">Record that holds master planning settings.</param>
    /// <param name = "_bom">Bill of material line.</param>
    /// <param name = "_bomCalcData">Data used for BOM Calculation.</param>
    protected void updateBOMReqTrans(ReqTrans _reqTransBOM, ReqPO _reqPO, ReqPlanData _reqPlanData, BOM _bom, BOMCalcData _bomCalcData)
    {
        _reqTransBOM.Qty = - BOMLineConsumption::construct()
                            .bomConsumptionInInventUnit(_bom,
                             _bomCalcData,
                             ReqRoute::accError(_reqTransBOM.PlanVersion,_reqTransBOM.RefId,_reqTransBOM.OprNum),
                            InventTable::find(_reqTransBOM.ItemId).inventUnitId(),
                            _reqPO.PmfYieldPct,
                            bom::isPmfFormula(_bom.BOMId));
        _reqTransBOM.updateReduceCovQty();
        _reqTransBOM.update(_reqPlanData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReduceCopyCovQty</Name>
				<Source><![CDATA[
    public void updateReduceCopyCovQty(
        ReqTrans        _reqTransTo,
        ReqPlanData     _reqPlanData     = null
        )
    {
        ReqTransCov reqTransCov;
        ReqTransCov reqTransCovNew;

        ReqTrans    reqTransSettled;

        InventQty   qtyReduce;
        InventQty   qtyNow;

        if (abs(this.Qty) < abs(this.CovQty))
        {
            qtyReduce       = this.Qty - this.CovQty;

            reqTransCov     = this.selectCov(true);

            while (reqTransCov.RecId)
            {
                reqTransSettled = this.reqTransSettled(reqTransCov,true);

                if (reqTransCov.Qty != 0)
                {
                    if (abs(reqTransCov.Qty) <= abs(qtyReduce))
                    {
                        if (reqTransSettled.Qty > 0 || reqTransSettled.CovQty > 0)
                        {
                            reqTransCov.IssueRecId   = _reqTransTo.RecId;
                        }
                        else
                        {
                            reqTransCov.ReceiptRecId = _reqTransTo.RecId;
                        }

                        qtyNow = abs(reqTransCov.Qty);
                    }
                    else
                    {
                        qtyNow = abs(qtyReduce);

                        reqTransCovNew.data(reqTransCov);
                        reqTransCovNew.Qty = -qtyNow;

                        if (reqTransSettled.Qty > 0 || reqTransSettled.CovQty > 0)
                        {
                            reqTransCovNew.IssueRecId   = _reqTransTo.RecId;
                        }
                        else
                        {
                            reqTransCovNew.ReceiptRecId = _reqTransTo.RecId;
                        }

                        reqTransCovNew.insert();

                        reqTransCov.Qty += qtyNow;
                    }

                    reqTransCov.update();

                    if (reqTransSettled.Qty > 0 || reqTransSettled.CovQty > 0)
                    {
                        _reqTransTo.CovQty      -= qtyNow;
                        this.CovQty             += qtyNow;
                    }
                    else
                    {
                        _reqTransTo.CovQty      += qtyNow;
                        this.CovQty             -= qtyNow;
                    }

                    _reqTransTo.update(_reqPlanData);
                    this.update(_reqPlanData);

                    qtyReduce += qtyReduce > 0 ? -qtyNow : qtyNow;
                }

                if (! qtyReduce)
                {
                    break;
                }

                next reqTransCov;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReduceCovQty</Name>
				<Source><![CDATA[
    public void updateReduceCovQty(
        ReqPlanData     _reqPlanData     = null,
        boolean         _updateSettledReqTransCovQty = true
        )
    {
        ReqTransCov reqTransCov;
        ReqTrans    reqTransSettled;

        InventQty   qtyReduce;
        InventQty   qtyNow;

        if (abs(this.Qty) < abs(this.CovQty))
        {
            qtyReduce       = this.Qty - this.CovQty;

            reqTransCov     = this.selectCov(true);

            while (reqTransCov.RecId)
            {
                reqTransSettled = this.reqTransSettled(reqTransCov,true);

                if (reqTransCov.Qty != 0)   // don't delete action coverage
                {
                    if (abs(reqTransCov.Qty) <= abs(qtyReduce))
                    {
                        reqTransCov.delete();

                        qtyNow = abs(reqTransCov.Qty);
                    }
                    else
                    {
                        reqTransCov.Qty += abs(qtyReduce);
                        reqTransCov.update();

                        qtyNow = abs(qtyReduce);
                    }

                    if (reqTransSettled.Qty > 0 || reqTransSettled.CovQty > 0)
                    {
                        reqTransSettled.CovQty -= qtyNow;
                        this.CovQty            += qtyNow;
                    }
                    else
                    {
                        reqTransSettled.CovQty += qtyNow;
                        this.CovQty            -= qtyNow;
                    }

                    if (_updateSettledReqTransCovQty)
                    {
                        if (reqTransSettled.RecId)
                        {
                            reqTransSettled.update(_reqPlanData);
                        }
                    }

                    qtyReduce += qtyReduce > 0 ? -qtyNow : qtyNow;
                }

                if (! qtyReduce)
                {
                    break;
                }

                next reqTransCov;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransferDemandQty</Name>
				<Source><![CDATA[
    public void updateTransferDemandQty(
        ReqPlanData     _reqPlanData     = null
        )
    {
        ReqTrans            transferDemand;

        transferDemand      = this.selectDerived(true);
        transferDemand.Qty  = -this.Qty;
        transferDemand.update(_reqPlanData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransferReqDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the requirement date of the transfer demand based on the dates of a planned order.
    /// </summary>
    /// <param name="_reqPO">
    /// The planned order to update the dates based on.
    /// </param>
    /// <param name="_reqPlanData">
    /// An instance of the <c>ReqPlanData</c> class that holds master scheduling settings.
    /// </param>
    public void updateTransferReqDate(ReqPO _reqPO, ReqPlanData _reqPlanData)
    {
        ReqTrans            transferDemand;

        transferDemand = this.selectDerived(true);

        transferDemand.ReqDateDlvOrig = _reqPO.SchedFromDate;
        transferDemand.ReqDate = _reqPlanData.schedReqDateIssue(transferDemand.ReqDateDlvOrig, _reqPlanData.newReqSetupDimReqTrans(this));
        transferDemand.update(_reqPlanData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldValue</Name>
				<Source><![CDATA[
    public boolean validateFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        boolean ret;

        ret = super(_fieldName, _arrayIndex);

        switch (_fieldName)
        {
            case (fieldStr(ReqTrans, ItemRouteId)) :
                if (this.ItemRouteId)
                {
                    ret = RouteVersion::checkItemRelation(this.ItemRouteId,this.ItemId) && ret;
                }

                break;

            case (fieldStr(ReqTrans, ItemBomId)) :
                if (this.ItemBomId)
                {
                    ret = BOMVersion::checkItemRelation(this.ItemBomId,this.ItemId) && ret;
                }

                break;

            default:
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bulkInitFromInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes many <c>ReqTrans</c> records for a specific item ID with the settings from the related
    /// originator records.
    /// </summary>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that holds the master planning settings.
    /// </param>
    /// <param name="_setup">
    /// A <c>ReqSetup</c> object that holds the master planning settings for a specific item ID.
    /// </param>
    public static void bulkInitFromInventTransOrigin(
        ReqPlanData _reqPlanData,
        ReqSetup    _setup)
    {
        ItemId itemId = _setup.itemId();

        ReqTrans reqTrans;

        Set setCovDimId;
        if (_reqPlanData.reqTransCache())
        {
            setCovDimId = _reqPlanData.reqTransCache().itemDimSetForCurrentLevel(itemId, true);
        }

        if (! setCovDimId)
        {
            setCovDimId = new Set(Types::String);

            while select CovInventDimId from reqTrans
                group by CovInventDimId
                where  reqTrans.PlanVersion == _reqPlanData.parmReqPlanVersionRefRecId()
                    && reqTrans.ItemId      == itemId
            {
                setCovDimId.add(reqTrans.CovInventDimId);
            }
        }

        SetEnumerator se = setCovDimId.getEnumerator();

        // loop coverage dimensions
        while (se.moveNext())
        {
            ReqTrans::updateFromCoverageDimension(se.current(), _reqPlanData, _setup);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFromCoverageDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update many <c>ReqTrans</c> records for a specific item ID with the settings from the related
    /// coverage dimension.
    /// </summary>
    /// <param name="_covInventDimId">
    /// The id of the coverage dimension.
    /// </param>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that holds the master planning settings.
    /// </param>
    /// <param name="_setup">
    /// A <c>ReqSetup</c> object that holds the master planning settings for a specific item ID.
    /// </param>
    protected static void updateFromCoverageDimension(
        ReqCovInventDimId   _covInventDimId,
        ReqPlanData         _reqPlanData,
        ReqSetup            _setup)
    {
        SalesLine                               salesLine;
        PurchLine                               purchLine;
        ProdTable                               prodTable;
        ProdBOM                                 prodBOM;
        KanbanJob                               kanbanJob;
        Kanban                                  kanban;
        ReqTrans                                reqTransReceiptSource;
        ReqTrans                                reqTransIssueBlocking;
        ReqTrans                                reqTrans;
        InventTrans                             inventTrans;

        InventTransOriginSalesLine              inventTransOriginSalesLine;
        InventTransOriginPurchLine              inventTransOriginPurchLine;
        InventTransOriginProdTable              inventTransOriginProdTable;
        InventTransOriginProdBOM                inventTransOriginProdBOM;
        InventTransOriginKanbanJobProcess       inventTransOriginKanbanJobProcess;
        InventTransOriginKanbanJobTrsReceipt    inventTransOriginKanbanJobTrsReceipt;
        InventTransOriginKanbanJobWIP           inventTransOriginKanbanJobWIP;
        InventTransOriginBlockingIssue          inventTransOriginBlockingIssue;
        InventTransOriginBlockingReceipt        inventTransOriginBlockingReceipt;
        InventTransOrigin                       inventTransOriginBlockingReceiptOrigin;
        InventTransOrigin                       inventTransOriginSourceReceipt;

        ReqSetupDim setupDim        = _reqPlanData.newReqSetupDim(_setup, _covInventDimId);
        ItemId      itemId          = _setup.itemId();
        boolean     bomVersionReq   = setupDim.bomVersionReq();
        boolean     routeVersionReq = setupDim.routeVersionReq();
            
        reqTrans.skipDataMethods(true);

        if (bomVersionReq || routeVersionReq)
        {
            InventDimId covDimId = setupDim.inventDim().InventDimId;

            if (bomVersionReq)
            {
                if (routeVersionReq)
                {
                    // update bomId and routeId
                    #updateBOMIdRouteId(true, true)
                }
                else
                {
                    // update only bomId
                    #updateBOMIdRouteId(true)
                }
            }
            else if (routeVersionReq)
            {
                // update only routeId
                #updateBOMIdRouteId(, true)
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>common2ReqTrans</Name>
				<Source><![CDATA[
    static ReqTrans common2ReqTrans(Common _common)
    {
        ReqPO               reqPO;

        if (_common.TableId  == tableNum(ReqTrans))
        {
            return _common as ReqTrans;
        }

        if (_common.TableId  == tableNum(ReqPO))
        {
            reqPO = _common as ReqPO;

            return reqPO.reqTrans();
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>derivedRefType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the derived requirement type based on the specified <c>ReqRefType</c> enum.
    /// </summary>
    /// <param name="_refType">
    /// An enum value that holds a requirement type.
    /// </param>
    /// <returns>
    /// An enum value that holds the derived requirement type.
    /// </returns>
    public static ReqRefType derivedRefType(ReqRefType _refType)
    {
        return ReqRefTypeDescriptor::newFromReqRefType(_refType).derivedRefType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCommon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the corresponding <c>ReqTrans</c> record if possible from a record of any type.
    /// </summary>
    /// <param name="_reqPlanVersionRefRecId">
    /// An integer value that holds the ID of a <c>ReqPlanVersion</c> record.
    /// </param>
    /// <param name="_common">
    /// A record of any type.
    /// </param>
    /// <param name="_inventMovSubType">
    /// A <c>InventMovSubType</c> enumeration value; optional.
    /// </param>
    /// <returns>
    /// A <c>ReqTrans</c> record.
    /// </returns>
    static ReqTrans findCommon(
        RefRecId         _reqPlanVersionRefRecId,
        Common           _common,
        InventMovSubType _inventMovSubType = InventMovSubType::None)
    {
        ReqTrans                reqTransCaller;
        ReqTrans                reqTrans;
        ReqPO                   reqPO;
        ProdTable               prodTable;
        SalesLine               salesLine;
        PurchLine               purchLine;
        PurchReqLine            purchReqLine;
        ProdBOM                 prodBOM;
        Kanban                  kanban;
        InventSum               inventSum;
        InventDimId             covInventDimId;
        Common                  joinedInventDim;
        ReqTransIntercompany    reqTransIntercompany;
        ReqIntercompanyOutboundDemand reqIntercomanyOutboundDemand;
        ReqUpstreamIntercompanyDemand reqUpstreamIntercompanyDemand;

        InventMovement          inventMovement;

        switch (_common.TableId)
        {
            case (tableNum(ReqTrans)):
                reqTransCaller.data(_common);

                if (reqTransCaller.isTmp())
                {
                    select firstonly reqTrans
                        where reqTrans.PlanVersion          == _reqPlanVersionRefRecId           &&
                              reqTrans.RefType              == reqTransCaller.RefType            &&
                              reqTrans.RefId                == reqTransCaller.RefId              &&
                              reqTrans.InventTransOrigin    == reqTransCaller.InventTransOrigin  &&
                              reqTrans.ItemId               == reqTransCaller.ItemId             &&
                              reqTrans.CovInventDimId       == reqTransCaller.CovInventDimId;
                }
                else
                {
                    reqTrans.data(_common);
                }

                if (reqTrans.RefType == ReqRefType::TransferDemand)
                {
                    select firstonly reqTrans
                        where reqTrans.PlanVersion   == _reqPlanVersionRefRecId           &&
                              reqTrans.RefType       == ReqRefType::TransferPlannedOrder  &&
                              reqTrans.RefId         == reqTransCaller.RefId;
                }
                break;

            case (tableNum(ProdTable)):

                prodTable.data(_common);
                reqTrans  = prodTable.reqTrans(_reqPlanVersionRefRecId);

                break;

            case (tableNum(ReqPO)):
                reqPO.data(_common);
                reqTrans  = reqPO.reqTrans();

                break;

            case (tableNum(SalesLine)):

                salesLine.data(_common);
                reqTrans  = salesLine.reqTrans(_reqPlanVersionRefRecId);

                break;

            case (tableNum(PurchLine)):

                purchLine.data(_common);
                reqTrans  = purchLine.reqTrans(_reqPlanVersionRefRecId);

                break;

            case (tableNum(PurchReqLine)):

                purchReqLine.data(_common);
                reqTrans  = ReqTrans::findFromPurchReqLineRecId(purchReqLine.RecId);

                break;

            case (tableNum(ProdBOM)):

                prodBOM.data(_common);
                reqTrans  = prodBOM.reqTrans(_reqPlanVersionRefRecId);

                break;

            case (tableNum(ReqTransIntercompany)):

                reqTransIntercompany.data(_common);
                reqTrans = ReqTrans::findRecId(reqTransIntercompany.ReqTrans);

                break;

            case (tableNum(ReqIntercompanyOutboundDemand)):

                reqIntercomanyOutboundDemand.data(_common);
                reqTrans = ReqPO::findRecId(reqIntercomanyOutboundDemand.PlannedOrder).reqTrans();

                break;

            case (tableNum(ReqUpstreamIntercompanyDemand)):

                reqUpstreamIntercompanyDemand.data(_common);
                reqTrans = ReqTrans::findRecId(reqUpstreamIntercompanyDemand.UpstreamRequirement);

                break;

            case (tableNum(kanban)):

                kanban.data(_common);
                reqTrans = kanban.reqTrans(_reqPlanVersionRefRecId);
                break;

            case (tableNum(ConsignmentReplenishmentOrderLine)):

                ConsignmentReplenishmentOrderLine consignmentReplenishmentOrderLine;

                consignmentReplenishmentOrderLine.data(_common);

                reqTrans  = consignmentReplenishmentOrderLine.reqTrans(_reqPlanVersionRefRecId);
                break;

            case (tableNum(InventSum)):

                inventSum.data(_common);
                joinedInventDim = _common.joinChild();

                if (inventSum.ItemId && joinedInventDim.TableId == tableNum(InventDim))
                {
                    joinedInventDim.data(_common.joinChild());
                    covInventDimId = InventDim::dimId2ReqCovDimId(InventDim::findDim(joinedInventDim).inventDimId, InventDimGroupSetup::newItemId(inventSum.ItemId));
                    reqTrans = inventSum.reqTrans(covInventDimId, _reqPlanVersionRefRecId);
                }

            default:

                inventMovement = InventMovement::constructNoThrow(_common,_inventMovSubType);
                if (inventMovement)
                {
                    select firstonly reqTrans
                        where reqTrans.PlanVersion          == _reqPlanVersionRefRecId
                           && reqTrans.InventTransOrigin    == inventMovement.inventTransOriginId();
                }
        }

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFromPurchReqLineRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find a ReqTrans record based on the RecId of a requisition line;
    /// </summary>
    /// <param name="_purchReqLineRecId">
    /// The requisition line RecId to find a ReqTrans record for.
    /// </param>
    /// <returns>
    /// The found ReqTrans record.
    /// </returns>
    public static ReqTrans findFromPurchReqLineRecId(RecId _purchReqLineRecId)
    {
        ReqTrans reqTrans;

        select firstonly reqTrans
            where reqTrans.RequisitionLine == _purchReqLineRecId;

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOprNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the operation number for a specific production bills of materials line.
    /// </summary>
    /// <param name="_refType">
    /// An enumeration value that holds the requirement type.
    /// </param>
    /// <param name="_inventTransOriginId">
    /// An integer value that holds the ID of a <c>InventTransOrigin</c> record.
    /// </param>
    /// <param name="_reqPlanData">
    /// An object that holds the master planning settings.
    /// </param>
    /// <returns>
    /// The operation number of a production BOM line.
    /// </returns>
    static OprNum findOprNum(
        ReqRefType              _refType,
        InventTransOriginId     _inventTransOriginId,
        ReqPlanData             _reqPlanData
        )
    {
        ProdBOM                     prodBOM;
        InventTransOriginProdBOM    inventTransOriginProdBOM;

        if (_refType != ReqRefType::ProdLine)
        {
            return 0;
        }

        if (_reqPlanData.parmDisableDbCache())
        {
            inventTransOriginProdBOM.disableCache(true);
            prodBOM.disableCache(true);
        }

        select firstonly OprNum from prodBOM
            exists join inventTransOriginProdBOM
                where inventTransOriginProdBOM.ProdBOMDataAreaId    == prodBOM.DataAreaId
                   && inventTransOriginProdBOM.ProdBOMInventTransId == prodBOM.InventTransId
                   && inventTransOriginProdBOM.InventTransOrigin    == _inventTransOriginId;

        if (_reqPlanData.parmDisableDbCache())
        {
            inventTransOriginProdBOM.disableCache(false);
            prodBOM.disableCache(false);
        }

        return prodBOM.OprNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPriceDiscTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a purchase trade agreement for a specific item.
    /// </summary>
    /// <param name="_itemId">
    /// The ID of the item for which to search.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimension for which to search.
    /// </param>
    /// <param name="_qty">
    /// The quantity of items for which to search.
    /// </param>
    /// <param name="_transDate">
    /// The date for which the found trade agreements must be active.
    /// </param>
    /// <param name="_searchTradeMethod">
    /// The method that prioritizes the search results.
    /// </param>
    /// <param name="_reqSetup">
    /// The item setup; optional.
    /// </param>
    /// <returns>
    /// A record of a purchase trade agreement that matches the search criteria.
    /// </returns>
    static PriceDiscTable findPriceDiscTable(
        ItemId                  _itemId,
        InventDimId             _inventDimId,
        Qty                     _qty,
        TransDate               _transDate,
        ReqSearchTradeMethod    _searchTradeMethod,
        ReqSetup                _reqSetup = ReqSetup::newItemId(_itemId)
        )
    {
        PriceDiscTable      priceDiscTable;
        VendTable           vendTable;

        UnitOfMeasureSymbol unitID;
        Qty                 qty     = _qty;

        InventDimId         inventDimId;
        InventDimId         lastInventDimId;

        InventDim           inventDim;
        InventDimParm       inventDimParm;

        Integer             loop;

        boolean             found;

        PriceDiscTable      bestPriceDiscTable;
        Price               bestPrice;

        InventDimGroupSetup inventDimGroupSetup     = InventDimGroupSetup::newItemId(_itemId);

        // Only search for trade agreements with specific vendors for specific items if it has been activated
        if (!PriceDiscTable::isPartyCodeProductCodeActivated(PriceType::PricePurch, PriceDiscPartyCodeType::Table, PriceDiscProductCodeType::Table))
        {
            return priceDiscTable;
        }

        // convert qty to purchase unit
        unitID   = _reqSetup.purchUnitId();
        if (_reqSetup.inventUnitId() != unitID)
        {
            qty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_itemId,
																						_inventDimId,
																						qty,
																						_reqSetup.inventUnitId(),
																						unitID,
																						NoYes::Yes);
        }

        loop        = 0;

        inventDim   = InventDim::find(_inventDimId);
        inventDimGroupSetup.inventDimParmActivePurchPrice(inventDimParm);
        inventDim.clearNotSelectedDim(inventDimParm);
        inventDimId = InventDim::findDim(inventDim).InventDimId;

        while (loop < 3)
        {
            if (inventDimId && inventDimId != lastInventDimId)
            {
                found = false;

                lastInventDimId = inventDimId;

                switch (_searchTradeMethod)
                {
                    case ReqSearchTradeMethod::ShortestDlvTime:

                       select firstonly priceDiscTable
                            index hint ItemDimIdx
                            order by DeliveryTime,Amount
                            where priceDiscTable.Relation           == PriceType::PricePurch                                    &&
                                  priceDiscTable.ItemCode           == PriceDiscProductCodeType::Table                                     &&
                                  priceDiscTable.ItemRelation       == _itemId                                                  &&
                                  priceDiscTable.AccountCode        == PriceDiscPartyCodeType::Table                                     &&
                                  priceDiscTable.UnitId             == unitID                                                   &&
                                  priceDiscTable.InventDimId        == inventDimId                                              &&
                                  priceDiscTable.QuantityAmountFrom <= qty                                                      &&
                                 ((qty < priceDiscTable.QuantityAmountTo) || !priceDiscTable.QuantityAmountTo)                 &&
                                 (_transDate                        >= priceDiscTable.FromDate  || ! priceDiscTable.FromDate)   &&
                                 (_transDate                        <= priceDiscTable.ToDate    || ! priceDiscTable.ToDate)
                            join TableId from vendTable where
                                  vendTable.AccountNum              == priceDiscTable.AccountRelation                           &&
                                  vendTable.Currency                == priceDiscTable.Currency;

                        if (priceDiscTable)
                        {
                            found = true;
                        }

                        break;

                    case ReqSearchTradeMethod::LowestPcsPrice:

                        while select priceDiscTable
                            index hint ItemDimIdx
                            where priceDiscTable.Relation           == PriceType::PricePurch                                    &&
                                  priceDiscTable.ItemCode           == PriceDiscProductCodeType::Table                                     &&
                                  priceDiscTable.ItemRelation       == _itemId                                                  &&
                                  priceDiscTable.AccountCode        == PriceDiscPartyCodeType::Table                                     &&
                                  priceDiscTable.UnitId             == unitID                                                   &&
                                  priceDiscTable.InventDimId        == inventDimId                                              &&
                                  priceDiscTable.QuantityAmountFrom <= qty                                                      &&
                                 ((qty < priceDiscTable.QuantityAmountTo) || !priceDiscTable.QuantityAmountTo)                  &&
                                 (_transDate                        >= priceDiscTable.FromDate  || ! priceDiscTable.FromDate)   &&
                                 (_transDate                        <= priceDiscTable.ToDate    || ! priceDiscTable.ToDate)
                            join TableId from vendTable where
                                  vendTable.AccountNum              == priceDiscTable.AccountRelation                           &&
                                  vendTable.Currency                == priceDiscTable.Currency
                        {
                            if (! bestPriceDiscTable.RecId || bestPrice > priceDiscTable.pcsPriceMST())
                            {
                                bestPrice           = priceDiscTable.pcsPriceMST();
                                bestPriceDiscTable  = priceDiscTable.data();
                                found               = true;
                            }
                        }

                        if (found)
                        {
                            priceDiscTable.data(bestPriceDiscTable);
                        }
                }

                if (found)
                {
                    break;
                }
            }

            if (inventDimId == InventDim::inventDimIdBlank())
            {
                break;
            }

            loop++;

            if (loop == 1)
            {
                inventDimId = InventDim::findDim(inventDim).InventDimId;
            }
            else
            {
                inventDimId = InventDim::inventDimIdBlank();
            }
        }

        if (found)
        {
            return priceDiscTable;
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecId</Name>
				<Source><![CDATA[
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    static ReqTrans findRecId(RecId _recId, boolean _forUpdate = false)
    {
        ReqTrans reqTrans;

        if (_recId != 0)
        {
            reqTrans.selectForUpdate(_forUpdate);

            select reqTrans
                index hint recid
                where reqTrans.RecId == _recId;
        }

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecIdPessimistic</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a firstonly <c>ReqTrans</c> record based on RecId using selection with pessimisticLock.
    /// </summary>
    /// <param name = "recId">The ID to find.</param>
    /// <param name = "_forUpdate">A <c>boolean</c> value that indicates if the record should be selected for update; optional.</param>
    /// <returns>The found record if any.</returns>
    static ReqTrans findRecIdPessimistic(RecId _recId, boolean _forUpdate = false)
    {
        ReqTrans reqTrans;

        if (_recId != 0)
        {
            reqTrans.selectForUpdate(_forUpdate);

            select firstonly pessimisticLock reqTrans
                index hint recid
                where reqTrans.RecId == _recId;
        }

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecIdCrossCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find a <c>ReqTrans</c> record across all company accounts.
    /// </summary>
    /// <param name="recId">
    /// The ID to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A <c>boolean</c> value that indicates if the record should be selected for update; optional.
    /// </param>
    /// <returns>
    /// The found record if any.
    /// </returns>
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    static ReqTrans findRecIdCrossCompany(RecId recId, boolean _forUpdate = false)
    {
        ReqTrans reqTrans;

        reqTrans.selectForUpdate(_forUpdate);

        select crossCompany reqTrans
            where reqTrans.RecId== recId;

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the final inventory dimensions for a bills of materials line.
    /// </summary>
    /// <param name="_parentItemId">
    /// A string that holds the itemID for the parent item.
    /// </param>
    /// <param name="_parentInventDim">
    /// A record of type InventDim that holds the inventory dimensions related to the parent item.
    /// </param>
    /// <param name="_routeId">
    /// A string that holds the routeID related to the parent item.
    /// </param>
    /// <param name="_oprNum">
    /// An integer value that holds the operation number.
    /// </param>
    /// <param name="_wrkCtrConsumption">
    /// A Boolean value that holds the resource consumption flag.
    /// </param>
    /// <param name="_inventTable">
    /// An <c>InventTable</c> record containing the item data for the BOM item.
    /// </param>
    /// <param name="_bom">
    /// A <c>BOM</c> record containing the bom item data.
    /// </param>
    /// <param name="_reqCalcRecordCacheInventDim">
    /// A <c>ReqCalcRecordCacheInventDim</c> object used to cache inventory dimension information.
    /// </param>
    /// <returns>
    /// A record of type inventDim that holds the inventory dimensions the current bills of materials line must have.
    /// </returns>
    public static InventDim getInventDim(
        ItemId                      _parentItemId,
        InventDim                   _parentInventDim,
        RouteId                     _routeId,
        OprNum                      _oprNum,
        WrkCtrConsumption           _wrkCtrConsumption,
        InventTable                 _inventTable,
        BOM                         _bom,
        ReqCalcRecordCacheInventDim _reqCalcRecordCacheInventDim)
    {
        InventDim   inventDim;
        InventDim   inventDimCache;
        InventDim   inventDimCacheBom;

        boolean isReqTransGetInventDimFlightEnabled = ReqTransGetInventDimUseBomFlight::instance().isEnabled();

        if (_reqCalcRecordCacheInventDim)
        {
            inventDimCache = _reqCalcRecordCacheInventDim.lookup(_parentItemId, _parentInventDim.RecId, _routeId,
                                                                 _oprNum, _wrkCtrConsumption, _inventTable.ItemId);
            
            if (inventDimCache && InventDim::isInventDimEqualCovDim(InventDimGroupSetup::newItemId(_bom.ItemId), _bom.inventDim(), inventDimCache))
            {
                inventDim = inventDimCache;
            }
            else if (isReqTransGetInventDimFlightEnabled)
            {
                inventDimCacheBom = _reqCalcRecordCacheInventDim.lookupWithBom(_parentItemId, _parentInventDim.RecId, _routeId,
                                                                               _oprNum, _wrkCtrConsumption, _inventTable.ItemId, _bom.RecId);

                if (inventDimCacheBom)
                {
                    inventDim = inventDimCacheBom;
                }
            }
        }

        if (!inventDim)
        {
            inventDim = _bom.BOMMap::inventDimFinal(_parentItemId, _parentInventDim, _routeId, _inventTable, _oprNum, _wrkCtrConsumption);
        }

        if (_reqCalcRecordCacheInventDim)
        {
            // Insert to the cache only the first value for the specific key. Values shouldn't be overwritten. Only in case the flight is enabled.
            if (!isReqTransGetInventDimFlightEnabled || !inventDimCache)
            {
                _reqCalcRecordCacheInventDim.insert(_parentItemId,_parentInventDim.RecId,_routeId,
                                                    _oprNum,_wrkCtrConsumption,_inventTable.ItemId,
                                                    inventDim);
            }
            // Bom RecID is used as an additional parameter to make the key more specific in case 
            // when there is alredy a avalue for a key with 6 parameters. There is no need to insert a value again if it has been found in the cache. 
            else if (inventDim != inventDimCache && !inventDimCacheBom)
            {
                _reqCalcRecordCacheInventDim.insertWithBom(_parentItemId, _parentInventDim.RecId, _routeId,
                                                           _oprNum, _wrkCtrConsumption, _inventTable.ItemId, _bom.RecId,
                                                           inventDim);
            }
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitOfMeasure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the unit of measure for the supplied item.
    /// </summary>
    /// <param name="_inventTable">
    /// A <c>InventTable</c> record specifying the item to retrieve the unit of measure for.
    /// </param>
    /// <param name="_reqCalcRecordCacheUnitOfMeasure">
    /// A <c>ReqCalcRecordCacheUnitOfMeasure</c> object used for caching unit of measure information.
    /// </param>
    /// <returns>
    /// The unit of measure for the item.
    /// </returns>
    public static UnitOfMeasureSymbol getUnitOfMeasure(
        InventTable                     _inventTable,
        ReqCalcRecordCacheUnitOfMeasure _reqCalcRecordCacheUnitOfMeasure)
    {
        UnitOfMeasure unitOfMeasure;

        if (_reqCalcRecordCacheUnitOfMeasure)
        {
            unitOfMeasure = _reqCalcRecordCacheUnitOfMeasure.lookup(_inventTable.ItemId);
        }

        if (!unitOfMeasure)
        {
            unitOfMeasure = UnitOfMeasure::findBySymbol(_inventTable.inventUnitId());
        }

        if (_reqCalcRecordCacheUnitOfMeasure)
        {
            _reqCalcRecordCacheUnitOfMeasure.insert(_inventTable.ItemId, unitOfMeasure);
        }

        return unitOfMeasure.Symbol;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasSalesForecast</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an item has a sales forecast defined for the specified inventory dimensions.
    /// </summary>
    /// <param name="_reqPlanId">
    /// A string value that holds a master plan ID.
    /// </param>
    /// <param name="_itemId">
    /// A string value that holds an item ID.
    /// </param>
    /// <param name="_covInventDimId">
    /// A string value that holds an inventory dimension ID.
    /// </param>
    /// <returns>
    /// true if the sales forecast exists; otherwise, false.
    /// </returns>
    static boolean hasSalesForecast(
        ReqPlanId       _reqPlanId,
        ItemId          _itemId,
        InventDimId     _covInventDimId
        )
    {
        ReqPlanVersion reqPlanVersion = ReqPlan::findReqPlanId(_reqPlanId).findActiveVersion();

        return ((select firstonly reqTrans
                    where reqTrans.PlanVersion            == reqPlanVersion.RecId              &&
                          reqTrans.RefType                == ReqRefType::SalesForecast         &&
                          reqTrans.RefId                  == ''                                &&
                          reqTrans.InventTransOrigin      == 0                                 &&
                          reqTrans.ItemId                 == _itemId                           &&
                          reqTrans.CovInventDimId         == _covInventDimId).RecId ? true : false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransfer</Name>
				<Source><![CDATA[
    static boolean isTransfer(ReqRefType _reqRefType)
    {
        if (_reqRefType     == ReqRefType::InventTransfer           ||
            _reqRefType     == ReqRefType::TransferPlannedOrder     ||
            _reqRefType     == ReqRefType::TransferOrderReceive     ||
            _reqRefType     == ReqRefType::TransferOrderShip)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrHasSalesContinuity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see if there are ReqTras records of type continuity
    /// </summary>
    /// <param name="_planVersion">
    /// Master planning version
    /// </param>
    /// <param name="_itemId">
    /// Unique Item Id
    /// </param>
    /// <param name="_covInventDimId">
    /// Inventory dimension Id
    /// </param>
    /// <returns>
    /// true if there are <c>ReqTras</c> records of type continuity.
    /// </returns>
    public static boolean mcrHasSalesContinuity(
        RefRecId       _planVersion,
        ItemId          _itemId,
        InventDimId     _covInventDimId
        )
    {
        return ((select reqTrans
                    index hint RefIdx
                    where reqTrans.PlanVersion         == _planVersion                &&
                          reqTrans.RefType             == ReqRefType::MCRContinuity   &&
                          reqTrans.RefId               == ''                          &&
                          reqTrans.InventTransOrigin   == 0                           &&
                          reqTrans.ItemId              == _itemId                     &&
                          reqTrans.CovInventDimId      == _covInventDimId).RecId ? true : false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentRefType</Name>
				<Source><![CDATA[
    [SysObsolete("The method ReqTrans::parentRefType() is obsolete, use ReqTrans.parentReqRefType() instead.", false, 30\11\2017)]
    public static ReqRefType parentRefType(ReqRefType _refType)
    {
        return ReqRefTypeDescriptor::newFromReqRefType(_refType).parentRefType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfSetActionCancel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set action type to cancel for all reqTrans related to the planned production batch.
    /// </summary>
    /// <param name="_reqPlanData">Master planning run plan.</param>
    /// <param name="_reqTrans">Planned production batch planning transaction.</param>
    public static void pmfSetActionCancel(
        ReqPlanData _reqPlanData,
        ReqTrans    _reqTrans)
    {
        ReqTrans    relatedReqTrans;

        while select forupdate relatedReqTrans
            where relatedReqTrans.PlanVersion
                    == _reqTrans.PlanVersion
                && relatedReqTrans.RefId
                    == _reqTrans.RefId
                && (relatedReqTrans.RefType
                        == ReqRefType::PmfFormulaLine
                    || relatedReqTrans.RefType
                        == ReqRefType::PmfCoProduct
                    || relatedReqTrans.RefType
                        == ReqRefType::PmfPlannedProdBatch)
                && relatedReqTrans.ActionType
                    != ActionType::Cancel
        {
            relatedReqTrans.ActionType = ActionType::Cancel;
            relatedReqTrans.ActionDays = 0;
            relatedReqTrans.ActionDate = _reqTrans.ReqDate;
            relatedReqTrans.update(_reqPlanData);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refType2Short</Name>
				<Source><![CDATA[
    static ReqRefTypeShort refType2Short(ReqRefType _reqRefType)
    {
        return ReqRefTypeDescriptor::newFromReqRefType(_reqRefType).refTypeShort();
    }

]]></Source>
			</Method>
			<Method>
				<Name>refType2RefTypeTrunc</Name>
				<Source><![CDATA[
    public ReqRefTypeTrunc refType2RefTypeTrunc()
    {
        var symbol = new DictEnum(enumNum(ReqRefType)).value2Symbol(enum2int(this.RefType));
        return any2Enum(new DictEnum(enumNum(ReqRefTypeTrunc)).symbol2Value(symbol));
    }

]]></Source>
			</Method>
			<Method>
				<Name>refType2TransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds corresponding <c>InventTransType</c> for given <c>ReqRefType</c> value.
    /// </summary>
    /// <param name="_reqRefType">
    /// A <c>ReqRefType</c> value.
    /// </param>
    /// <returns>
    /// The corresponding <c>InventTransType</c> value.
    /// </returns>
    static InventTransType refType2TransType(ReqRefType _reqRefType)
    {
        return ReqRefTypeDescriptor::newFromReqRefType(_reqRefType).inventTransType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>refTypeCanHaveBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the specified requirement type can have a bills of materials attached.
    /// </summary>
    /// <param name="_refType">
    /// An enum value that holds the requirement type.
    /// </param>
    /// <returns>
    /// true if the requirement type can have a bills of materials attached; otherwise, false.
    /// </returns>
    public static boolean refTypeCanHaveBOM(ReqRefType _refType)
    {
        return ReqRefTypeDescriptor::newFromReqRefType(_refType).canHaveBOM();
    }

]]></Source>
			</Method>
			<Method>
				<Name>refTypeCanHaveKanbanRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified requirement type can have a kanban rule attached.
    /// </summary>
    /// <param name="_refType">
    /// An enumeration value that holds the requirement type.
    /// </param>
    /// <returns>
    /// true if the requirement type can have a kanban rule attached; otherwise, false.
    /// </returns>
    public static boolean refTypeCanHaveKanbanRule(ReqRefType _refType)
    {
        return ReqRefTypeDescriptor::newFromReqRefType(_refType).canHaveKanbanRule();
    }

]]></Source>
			</Method>
			<Method>
				<Name>refTypeCanHaveRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the specified requirement type can have a route attached.
    /// </summary>
    /// <param name="_refType">
    /// An enum value that holds the requirement type.
    /// </param>
    /// <returns>
    /// true if the requirement type can have a route attached; otherwise, false.
    /// </returns>
    public static boolean refTypeCanHaveRoute(ReqRefType _refType)
    {
        return ReqRefTypeDescriptor::newFromReqRefType(_refType).canHaveRoute();
    }

]]></Source>
			</Method>
			<Method>
				<Name>refTypeCanReserveWorkCenter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a requirement type can reserve workcenter capacity.
    /// </summary>
    /// <param name="_refType">
    /// An enum value of type <c>ReqRefType</c> that holds a requirement type.
    /// </param>
    /// <returns>
    /// true if the requirement type can reserve workcenter capacity; otherwise, false.
    /// </returns>
    public static boolean refTypeCanReserveWorkCenter(ReqRefType _refType)
    {
        return ReqRefTypeDescriptor::newFromReqRefType(_refType).canReserveWorkCenterCapacity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>refTypeIsDerivedFromPlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified requirement type represents a derived requirement type from a
    /// planned order.
    /// </summary>
    /// <param name="_refType">
    /// An enumeration value that holds a requirement type.
    /// </param>
    /// <returns>
    /// true if the requirement type represents a derived requirement type from a planned order; otherwise,
    /// false.
    /// </returns>
    [SysObsolete("The method ReqTrans::refTypeIsDerivedFromPlannedOrder() is obsolete, use ReqTrans.isDerivedFromPlannedOrder() instead.", false, 30\11\2017)]
    public static boolean refTypeIsDerivedFromPlannedOrder(ReqRefType  _refType)
    {
        ReqRefType      parentRefType = ReqTrans::parentRefType(_refType);

        return ReqTrans::refTypeIsPlannedOrder(parentRefType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDerivedFromPlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the <c>ReqTrans</c> record was derived from planned order.
    /// </summary>
    /// <returns>
    /// true if the <c>ReqTrans</c> record was derived from planned order; otherwise, false.
    /// </returns>
    public boolean isDerivedFromPlannedOrder()
    {
        ReqRefType parentRefType = this.parentReqRefType();

        return ReqTrans::refTypeIsPlannedOrder(parentRefType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentReqRefType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>ReqRefType</c> of the parent record.
    /// </summary>
    /// <returns>
    /// The <c>ReqRefType</c> of the parent record.
    /// </returns>
    public ReqRefType parentReqRefType()
    {
        return ReqRefTypeDescriptor::newFromReqRefType(this.RefType).parentRefType(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>refTypeIsPlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the specified requirement type is a planned order.
    /// </summary>
    /// <param name="_refType">
    /// An enum value that holds the requirement type.
    /// </param>
    /// <returns>
    /// true if the requirement type is a planned order; otherwise, false.
    /// </returns>
    public static boolean refTypeIsPlannedOrder(ReqRefType _refType)
    {
        #macrolib.Req

        if (#ReqRefTypeIsPlannedOrder(_refType))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refTypeIsReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a type as default represents a receipt.
    /// </summary>
    /// <param name="_reqRefType">
    /// The reference type.
    /// </param>
    /// <returns>
    /// true if the type represents a receipts; otherwise, false.
    /// </returns>
    public static NoYes refTypeIsReceipt(ReqRefType _reqRefType)
    {
        return ReqRefTypeDescriptor::newFromReqRefType(_reqRefType).isReceipt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>statusIssue2Priority</Name>
				<Source><![CDATA[
    static Integer statusIssue2Priority(StatusIssue _statusIssue)
    {
        #Req

        if (_statusIssue == StatusIssue::ReservPhysical)
        {
            return #PriorityReservPhysical;
        }
        else if (_statusIssue == StatusIssue::ReservOrdered)
        {
            return #PriorityReservOrdered;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType2RefType</Name>
				<Source><![CDATA[
    public static ReqRefType transType2RefType(InventTransType _inventTransType,InventQty   _qty)
    {
        switch (_inventTransType)
        {
            case InventTransType::Sales                 : return ReqRefType::Sales;
            case InventTransType::Statement             :
                if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                {
                    return ReqRefType::Statement;
                }
                return ReqRefType::InventJournal;
            case InventTransType::SalesQuotation        : return ReqRefType::SalesQuotation;
            case InventTransType::Production            : return ReqRefType::Production;
            case InventTransType::Purch                 : return ReqRefType::Purch;
            case InventTransType::ProdLine              : return ReqRefType::ProdLine;
            case InventTransType::BOMMain               : return ReqRefType::InventJournal;
            case InventTransType::BOMLine               : return ReqRefType::InventJournal;
            case InventTransType::InventTransfer        : return ReqRefType::InventTransfer;
            case InventTransType::TransferOrderShip     : return ReqRefType::TransferOrderShip;
            case InventTransType::TransferOrderReceive  : return ReqRefType::TransferOrderReceive;
            case InventTransType::QuarantineOrder       : return ReqRefType::Quarantine;
            case InventTransType::PmfProdCoBy           : return ReqRefType::PmfCoProduct;
            case InventTransType::KanbanEmptied            : return ReqRefType::KanbanLine;
            case InventTransType::KanbanJobPickingList     : return ReqRefType::KanbanLine;
            case InventTransType::KanbanJobProcess         : return ReqRefType::Kanban;
            case InventTransType::KanbanJobTransferIssue   : return ReqRefType::KanbanLine;
            case InventTransType::KanbanJobTransferReceipt : return ReqRefType::Kanban;
            case InventTransType::KanbanJobWIP             : return _qty >= 0 ? ReqRefType::Kanban : ReqRefType::KanbanLine;
            case InventTransType::ConsignmentReplenishmentOrder : return ReqRefType::ConsignmentReplenishmentOrder;
        }

        return ReqRefType::InventJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toolTipRecord</Name>
				<Source><![CDATA[
    public str toolTipRecord()
    {
        str inventDimText;

        var inventDim = InventDim::find(this.CovInventDimId);
        if (inventDim)
        {
            inventDimText = inventDim.preFix(InventDim::dimFieldsList(), ', ', ' ');
        }

        return strfmt("@SCM:ReqTransTooltip", this.RefType, this.RefId, this.ItemId, inventDimText);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReqRefTypeActionable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a type is actionable.
    /// </summary>
    /// <param name="_reqRefType">
    /// The reference type.
    /// </param>
    /// <returns>
    /// true if the type is actionable; otherwise, false.
    /// </returns>
    public static boolean isReqRefTypeActionable(ReqRefType _reqRefType)
    {
        return _reqRefType != ReqRefType::BOMLine
            && _reqRefType != ReqRefType::InventOnHand
            && _reqRefType != ReqRefType::PlannedKanbanLine
            && _reqRefType != ReqRefType::ProdLine
            && _reqRefType != ReqRefType::PmfFormulaLine
            && _reqRefType != ReqRefType::TransferDemand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCounterPartForJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determine if counter part reqTrans exists for current reqTrans that refers to invent journal.
    /// </summary>
    /// <returns>
    ///     A <c>boolean</c> value represents whether current reqTrans has counter part reqTrans or not.
    /// </returns>
    public boolean hasCounterPartForJournalTrans()
    {
        boolean result = false;

        if (this.RefType == ReqRefType::InventJournal && this.CovQty == 0 && this.MarkingRefInventTransOrigin && !this.PmfPlanGroupId)
        {
            ReqTrans reqTransCounterPart;

            select firstOnly RecId from reqTransCounterPart
                where reqTransCounterPart.PlanVersion          == this.PlanVersion
                        && reqTransCounterPart.ItemId          == this.ItemId
                        && reqTransCounterPart.CovInventDimId  == this.CovInventDimId
                        && reqTransCounterPart.RefId           == this.RefId
                        && reqTransCounterPart.ReqDate         == this.ReqDate
                        && reqTransCounterPart.Qty             == - this.Qty
                        && reqTransCounterPart.CovQty          == 0;

            result = reqTransCounterPart.RecId;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the delay date and time
    /// </summary>
    /// <returns>The delay date and time.</returns>
    [Hookable(false)]
    public ReqDateTime futuresDateTime()
    {
        return new ReqDateTime(this.FuturesDate, this.FuturesTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFromInventLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the source warehouse if the current <c>ReqTrans</c> is a planned transfer order receipt. 
    /// Otherwise, does nothing.
    /// </summary>
    /// <param name = "_fromInventLocationId">The id of the source warehouse.</param>
    /// <remarks>The source warehouse is updated on the derived planned transfer shipment <c>ReqTrans</c>.</remarks>
    internal void setFromInventLocationId(InventLocationId _fromInventLocationId)
    {
        if (this.RefType == ReqRefType::TransferPlannedOrder)
        {
            var transferDemand = this.selectDerived(true);
            while (transferDemand.RecId)
            {
                var inventDimDemand = transferDemand.inventDim();
                inventDimDemand.InventLocationId    = _fromInventLocationId;
                inventDimDemand.initFromInventLocation(inventDimDemand.inventLocation());
                transferDemand.CovInventDimId       = InventDim::findOrCreate(inventDimDemand).InventDimId;
                transferDemand.update();
                next transferDemand;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return super();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Req</ConfigurationKey>
	<DeveloperDocumentation>@SYS124112</DeveloperDocumentation>
	<FormRef>reqTransoverview</FormRef>
	<Label>@SYS5803</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>ItemId</TitleField1>
	<TitleField2>RefId</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>ItemIdx</ClusteredIndex>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<Modules>MasterPlanning</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RefType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RefId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReqDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActionType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActionDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActionQtyAdd</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FuturesMarked</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FuturesDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ActionMessage</Name>
			<Label>@Sys2041</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ActionMarked</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActionType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>displayActionDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActionDays</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>pdsCWActionQtyAdd</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActionQtyAdd</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BOM</Name>
			<Label>@SYS7916</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemBomId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BOMType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OprNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Level</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Customer</Name>
			<Label>@SYS302</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustAccountId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>FuturesMessage</Name>
			<Label>@Sys2417</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FuturesMarked</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>displayFuturesDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FuturesTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>displayFuturesDays</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RefType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RefId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CovInventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsForecastPurch</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PmfPlanningItemId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>MCRPriceAlerts</Name>
			<Label>@MCR36251</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MCRPriceTimeFence</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>NetRequirements</Name>
			<Label>@SYS5803</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>displayReqDateDlv</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReqDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReqTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsExpiryDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>pdsCWOriginalQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OriginalQuantity</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>pdsCWReqQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>pdsCWCovQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CovQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OpenStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsDerivedDirectly</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>OrderGroup</Name>
			<Label>@SYS69861</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Other</Name>
			<Label>@SYS1284</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Direction</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Priority</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PlanVersion</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LastPlanRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReqProcessId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntercompanyPlannedOrder</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsDelayed</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PdsCatchWeight</Name>
			<Label>@PDS72</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>pdsCWReqQty</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PdsShelfLife</Name>
			<Label>@PRO945</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PdsExpiryDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsSellableDays</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PMFPlan</Name>
			<Label>@PRO1063</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PmfPlanPriorityCurrent</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PmfPlanGroupPriority</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PmfPlanGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PmfPlanGroupPrimaryIssue</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Route</Name>
			<Label>@SYS4190</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemRouteId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ActionDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ActionDate</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>ActionDays</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ActionDays</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ActionMarked</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>ReqSchedAction</ConfigurationKey>
			<Label>@SYS18067</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ActionQtyAdd</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ActionQtyAdd</ExtendedDataType>
			<GroupPrompt>@SYS14578</GroupPrompt>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ActionType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ActionType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BOMRefRecId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>BOMRefRecId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BOMType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>BOMType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CovInventDimId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqCovInventDimId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CovQty</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqQtyCoverage</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustAccountId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>CustAccount</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustGroupId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustGroupId</ExtendedDataType>
			<GroupPrompt>@SYS3815</GroupPrompt>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Direction</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>InventDirection</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>FuturesDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>FuturesDate</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>FuturesDays</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>FuturesDays</ExtendedDataType>
			<Label>@SYS92716</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>FuturesMarked</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS2711</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldTime">
			<Name>FuturesTime</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SchedTime</ExtendedDataType>
			<Label>@SYS56144</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>IntercompanyPlannedOrder</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Req</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS332328</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InventTransOrigin</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransOriginId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsDelayed</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqTransIsDelayed</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsDerivedDirectly</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqIsDerivedDirectly</ExtendedDataType>
			<Label>@SYS301857</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsForecastPurch</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqIsForecastPurch</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemBomId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BOMId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@SYS22298</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemRouteId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RouteId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Keep</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LastPlanRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>Level</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BOMLevel</ExtendedDataType>
			<Label>@SYS14422</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>MarkingRefInventTransOrigin</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransOriginId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>MCRPriceTimeFence</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Counter</ExtendedDataType>
			<Label>@MCR35907</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OpenStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ReqOpenStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>OprNum</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>OprNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>OriginalQuantity</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqOriginalQuantity</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>PdsExpiryDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsVendExpiryDate</ExtendedDataType>
			<Label>@SYS54367</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>PdsSellableDays</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsSellableDays</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PlanVersion</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PmfActionQtyAdd</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PMF</ConfigurationKey>
			<ExtendedDataType>ActionQtyAdd</ExtendedDataType>
			<GroupPrompt>@SYS14578</GroupPrompt>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PmfCoByRefRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>PmfCoByRefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PmfPlanGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqPlanGroupIdBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PmfPlanGroupPrimaryIssue</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PmfPlanGroupPrimaryIssueBase</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>PmfPlanGroupPriority</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqPlanGroupPriorityBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PmfPlanningItemId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PmfPlanningItemId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>PmfPlanPriorityCurrent</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PmfPlanPriorityCurrent</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>Priority</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Integer</ExtendedDataType>
			<Label>@SYS15156</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Qty</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RefId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransRefId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RefType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ReqRefType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ReqDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ReqDateDlvOrig</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqDateDlvOrig</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReqProcessId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqProcessId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldTime">
			<Name>ReqTime</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>RequisitionLine</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SupplyDemandSubClassification</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>SupplyDemandSubClassification</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsForcedItemBomId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsForcedItemRouteId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>FuturesCalculated</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PlanningPriority</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReqPlanningPriority</ExtendedDataType>
			<FeatureClass>ReqPriorityBasedPlanningFeature</FeatureClass>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VendId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemPrimaryVendId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>RefIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PlanVersion</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RefType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RefId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CovInventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>IsDelayed</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>SupplyDemandSubClassification</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Direction</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ItemIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PlanVersion</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CovInventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RefType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RefId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>FuturesIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PlanVersion</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>FuturesMarked</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ActionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>ReqSchedAction</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>PlanVersion</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ActionMarked</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>OpenIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PlanVersion</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>OpenStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CovInventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Direction</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ReqProcessIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PlanVersion</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ReqProcessId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PlanVersionRefIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PlanVersion</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RefId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CovInventDimId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RefType</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>KeepIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PlanVersion</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Keep</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RefType</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RefId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>RequisitionLineIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PlanVersion</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RequisitionLine</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>IntercompanyPlannedOrderIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>TradeInterCompany</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>PlanVersion</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RefType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>IntercompanyPlannedOrder</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>dataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>WrkCtrSchedulerOrder</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>RefId</MapField>
					<MapFieldTo>RefId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PlanVersion</MapField>
					<MapFieldTo>PlanVersion</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemId</MapField>
					<MapFieldTo>ItemId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventDimId</MapField>
					<MapFieldTo>CovInventDimId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CollectRefId</MapField>
					<MapFieldTo>RefId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CollectRefLevel</MapField>
					<MapFieldTo>Level</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Qty</MapField>
					<MapFieldTo>Qty</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation>
			<Name>BOM</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>BOM</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BomLine</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BOMRefRecId</Name>
					<Field>BOMRefRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BOMLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124113</EntityRelationshipRole>
			<RelatedTable>ReqPO</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PlannedOrderBOMLine</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefId</Name>
					<Field>RefId</Field>
					<RelatedField>RefId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PlanVersion</Name>
					<Field>PlanVersion</Field>
					<RelatedField>PlanVersion</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>RefType_Extern</Name>
					<RelatedField>RefType</RelatedField>
					<ValueStr>ReqRefType::BOMPlannedOrder</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BOMTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>BOMTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemBomId</Name>
					<Field>ItemBomId</Field>
					<RelatedField>BOMId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>NumIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustGroupId</Name>
					<Field>CustGroupId</Field>
					<RelatedField>CustGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustAccountId</Name>
					<Field>CustAccountId</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CovInventDimId</Name>
					<Field>CovInventDimId</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventOnhand</Name>
			<EntityRelationshipRole>@SYS124114</EntityRelationshipRole>
			<RelatedTable>InventSum</RelatedTable>
			<RelatedTableRole>OnhandInventory</RelatedTableRole>
			<RelationshipType>Link</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOrigin</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS127538</EntityRelationshipRole>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventoryTransactionOrigin</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransOrigin</Name>
					<Field>InventTransOrigin</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>Itemtable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124115</EntityRelationshipRole>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>Item</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>MarkingRefInventTransOrigin</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS127538</EntityRelationshipRole>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>MarkingInventoryTransactionOrigin</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MarkingRefInventTransOrigin</Name>
					<Field>MarkingRefInventTransOrigin</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PmfFormulaCoBy</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PmfFormulaCoBy</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PmfCoByRefRecId</Name>
					<Field>PmfCoByRefRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PmfFormulaLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ReqPO</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefId</Name>
					<Field>RefId</Field>
					<RelatedField>RefId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>RefType_Extern</Name>
					<RelatedField>RefType</RelatedField>
					<ValueStr>ReqRefType::PmfPlannedProdBatch</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PmfPlanGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PmfPlanGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PmfPlanGroupId</Name>
					<Field>PmfPlanGroupId</Field>
					<RelatedField>PmfPlanGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PmfPlanningItem</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PmfPlanningItemId</Name>
					<SourceEDT>PmfPlanningItemId</SourceEDT>
					<Field>PmfPlanningItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PmfProdCoBy</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PmfProdCoBy</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RefType</Name>
					<Field>RefType</Field>
					<ValueStr>ReqRefType::PmfCoProduct</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefId</Name>
					<Field>RefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>Production</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124113</EntityRelationshipRole>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProductionOrder</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefId</Name>
					<Field>RefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RefType</Name>
					<Field>RefType</Field>
					<ValueStr>ReqRefType::Production</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProductionLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124113</EntityRelationshipRole>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefId</Name>
					<Field>RefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RefType</Name>
					<Field>RefType</Field>
					<ValueStr>ReqRefType::ProdLine</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>Purch</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124113</EntityRelationshipRole>
			<RelatedTable>PurchTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefId</Name>
					<Field>RefId</Field>
					<RelatedField>PurchId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RefType</Name>
					<Field>RefType</Field>
					<ValueStr>ReqRefType::Purch</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ReqPlanVersion</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ReqPlanVersion</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>PlanVersion</RelatedTableRole>
			<RelationshipType>Composition</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PlanVersion</Name>
					<Field>PlanVersion</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ReqPlanVersionLastPlan</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ReqPlanVersion</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LastPlanVersions</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LastPlanRecId</Name>
					<Field>LastPlanRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ReqPo</Name>
			<Cardinality>OneMore</Cardinality>
			<EntityRelationshipRole>@SYS124113</EntityRelationshipRole>
			<RelatedTable>ReqPO</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OriginalPlannedOrder</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefType</Name>
					<Field>RefType</Field>
					<RelatedField>RefType</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefId</Name>
					<Field>RefId</Field>
					<RelatedField>RefId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PlanVersion</Name>
					<Field>PlanVersion</Field>
					<RelatedField>PlanVersion</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ReqPOPlannedIntercompanyDemand</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ReqPO</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PlannedIntercompanyIssue</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>PlannedIntercompanyReceipt</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RefType</Name>
					<Field>RefType</Field>
					<ValueStr>ReqRefType::PlannedIntercompanyDemand</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>IntercompanyPlannedOrder</Name>
					<Field>IntercompanyPlannedOrder</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ReqTransferDemand</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124113</EntityRelationshipRole>
			<RelatedTable>ReqTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DemandNetRequirement</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>NetRequirement</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RefType</Name>
					<Field>RefType</Field>
					<ValueStr>ReqRefType::TransferDemand</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefId</Name>
					<Field>RefId</Field>
					<RelatedField>RefId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PlanVersion</Name>
					<Field>PlanVersion</Field>
					<RelatedField>PlanVersion</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>RequisitionLine</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>PurchReqLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RequisitionLine</Name>
					<Field>RequisitionLine</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RefType</Name>
					<Field>RefType</Field>
					<ValueStr>ReqRefType::RequisitionLine</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RouteTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>RouteTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemRouteId</Name>
					<Field>ItemRouteId</Field>
					<RelatedField>RouteId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>NumIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesOrder</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124113</EntityRelationshipRole>
			<RelatedTable>SalesTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RefType</Name>
					<Field>RefType</Field>
					<ValueStr>ReqRefType::Sales</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefId</Name>
					<Field>RefId</Field>
					<RelatedField>SalesId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>