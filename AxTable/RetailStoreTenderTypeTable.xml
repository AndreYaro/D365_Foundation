<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailStoreTenderTypeTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class RetailStoreTenderTypeTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the name of the ledger dimension based on the account type.
    /// </summary>
    /// <returns>
    /// The name of the ledger dimension based on the account type.
    /// </returns>
    display Name accountName()
    {
        Name ret;

        switch (this.AccountType)
        {
            case RetailLedgerBank::Ledger  :   ret = MainAccount::findByLedgerDimension(this.LedgerDimension).localizedName();
                break;
            case RetailLedgerBank::Bank    :   ret = BankAccountTable::findByLedgerDimension(this.LedgerDimension).Name;
                break;
            // <GEERU>
            case RetailLedgerBank::RCash:
                ret = RCashTable::findByLedgerDimension(this.LedgerDimension).Name;
                break;
            // </GEERU>
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cardConfirmText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Confirms whether the change has to be applied for all card setup.
    /// </summary>
    /// <returns>
    /// The string value which has the message to confirm with the user whether the change has to apply for
    /// all card setup.
    /// </returns>
    str cardConfirmText()
    {
        return ("@RET4055" +
                "@RET4056");
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a record from <c>RetailStoreTenderTypeTable</c> table.
    /// </summary>
    /// <remarks>
    /// If replication of the record is allowed for the table, unprocessed(dead) records are removed from the distribution list.
    /// </remarks>
    public void delete()
    {
        RetailStoreTable   storeTable;
        RetailInfocodeTableSpecific    tableSpecificInfocode;

        #Retail

        ttsbegin;

        storeTable = RetailStoreTable::findRecId(this.Channel,true);

        if (storeTable)
        {
            if (storeTable.RemoveAddTender == this.TenderTypeId)
            {
                storeTable.RemoveAddTender = "";
                storeTable.update();
            }
        }

        delete_from tableSpecificInfocode
            where tableSpecificInfocode.RefTableId == this.TableId
               && tableSpecificInfocode.RefRelation == RetailStoreTable::findRecId(this.Channel).StoreNumber + #PlusOrMinus + this.TenderTypeId;

        super();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>differenceAccountForBigDifferenceName</Name>
				<Source><![CDATA[
    /*
    POSTableSpecPrintSetup.RESET;
    POSTableSpecPrintSetup.SETRANGE("Table No.",DATABASE::"Tender Type");
    POSTableSpecPrintSetup.SETRANGE(Key,"Primary Key");
    POSTableSpecPrintSetup.DELETEALL(TRUE);
    */
    /// <summary>
    /// Displays the account name for the difference account for the big difference ledger dimension.
    /// </summary>
    /// <returns>
    /// The account name for the difference account for the big difference ledger dimension.
    /// </returns>
    display AccountName differenceAccountForBigDifferenceName()
    {
        return MainAccount::findByLedgerDimension(this.DiffAccBigDiffLedgerDimension).localizedName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>differenceAccountName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the account name for the difference account ledger dimension.
    /// </summary>
    /// <returns>
    /// The account name for the difference account ledger dimension.
    /// </returns>
    display AccountName differenceAccountName()
    {
        return MainAccount::findByLedgerDimension(this.DifferenceAccLedgerDimension).localizedName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTenderTypeTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the field values from the <c>RetailTenderTypeTable</c> table.
    /// </summary>
    public void initFromTenderTypeTable()
    {
        RetailTenderTypeTable  tenderTypeTable = RetailTenderTypeTable::find(this.TenderTypeId);

        this.Name = tenderTypeTable.Name;
        this.Function = tenderTypeTable.DefaultFunction;
        this.updateGiftCardCompany();

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.fiscalPrinterTenderType_BR = tenderTypeTable.fiscalPrinterTenderType_BR;
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateGiftCardCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets 'Gift Card Company' field if selected operation is 'Pay Gift Card', otherwise clears value.
    /// </summary>
    public void updateGiftCardCompany()
    {
        // OperationId = 214 is defined in seed data as Pay by gift card operation.
        const int payByGiftCardOperationId = 214;
        this.GiftCardCompany = (this.posOperation == payByGiftCardOperationId) ? RetailParameters::find().GiftCardCompany : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the field values for the new record of <c>RetailTenderTypeTable</c> table.
    /// </summary>
    /// <remarks>
    /// Assigns values to the fields <c>TakenToBank</c> and <c>AllowUndertender</c>.
    /// </remarks>
    public void initValue()
    {
        this.AllowUndertender = true;

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows setting modified field value.
    /// </summary>
    /// <param name="_fieldName">
    /// Field name.
    /// </param>
    /// <param name="_arrayIndex">
    /// Array index.
    /// </param>
    public void modifiedFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        super(_fieldName, _arrayIndex);

        switch (_fieldName)
        {
            case fieldStr(RetailStoreTenderTypeTable, Function):
                // <GEERU>
                if (this.accountType == RetailLedgerBank::RCash)
                {
                    this.LedgerDimension = 0;
                    this.accountType = RetailLedgerBank::Ledger;
                }
                // </GEERU>
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>renamePrimaryKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the <c>errorOnRename</c> method of the <c>RetailConnActionManagement</c> class.
    /// </summary>
    public void renamePrimaryKey()
    {
        ;
        RetailConnActionManagement::errorOnRename(this);

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCardTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether it has card types defined.
    /// </summary>
    /// <returns>
    /// true if it has card types defined; false otherwise.
    /// </returns>
    public boolean hasCardTables()
    {
        boolean ret = false;

        if (this.function == RetailTenderFunction::Card)
        {
            RetailStoreTenderTypeCardTable cardTable;
            select firstonly RecId from cardTable
                        where cardTable.Channel == this.Channel
                            && cardTable.TenderTypeId == this.TenderTypeId;

            ret = cardTable.RecId != 0;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cascadeLedgerDimensionDownToCardTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cascade ledger dimension down to card table.
    /// </summary>
    public void cascadeLedgerDimensionDownToCardTable()
    {
        ttsbegin;

        RetailStoreTenderTypeCardTable cardTable;
        while select forupdate cardTable
            where cardTable.Channel == this.Channel
             && cardTable.TenderTypeId == this.TenderTypeId
        {
            cardTable.AccountType = this.AccountType;
            cardTable.LedgerDimension = this.LedgerDimension;
            cardTable.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cascadeDifferenceAccountLedgerDimensionDownToCardTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cascade difference account ledger dimension down to card table.
    /// </summary>
    public void cascadeDifferenceAccountLedgerDimensionDownToCardTable()
    {
        ttsbegin;

        RetailStoreTenderTypeCardTable cardTable;
        while select forupdate cardTable
            where cardTable.Channel == this.Channel
                && cardTable.TenderTypeId == this.TenderTypeId
        {
            cardTable.DifferenceAccLedgerDimension = this.DifferenceAccLedgerDimension;
            cardTable.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccountType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates account type.
    /// </summary>
    /// <returns>
    /// true if account type is valid; otherwise, false.
    /// </returns>
    public boolean validateAccountType_RU()
    {
        if (this.Function    != RetailTenderFunction::Normal            &&
            this.Function    != RetailTenderFunction::TenderRemoveFloat &&
            this.AccountType == RetailLedgerBank::RCash)
        {
            return checkFailed(
                strFmt("@SYS4002025", this.AccountType, RetailTenderFunction::Normal, RetailTenderFunction::TenderRemoveFloat));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBankOrSafeAccTypeIsNotRCash</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates bank bag or safe account type is not equal RCash.
    /// </summary>
    /// <param name="_accountType">
    /// The account type to be validated.
    /// </param>
    /// <returns>
    /// true if account type is not equal RCash; otherwise, false.
    /// </returns>
    public boolean validateBankOrSafeAccTypeIsNotRCash(RetailLedgerBank _accountType)
    {
        if (_accountType == RetailLedgerBank::RCash)
        {
            return checkFailed(strFmt("@SYS4002026", _accountType));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current record is valid and can be deleted from the database.
    /// </summary>
    /// <returns>
    /// true if the record is valid; otherwise false.
    /// </returns>
    /// <remarks>
    /// Confirms with user whether to delete card and all related card setups before record deletion.
    /// </remarks>
    public boolean validateDelete()
    {
        RetailStoreTenderTypeCardTable cardTable;
        RetailTransactionPaymentTrans  paymentTrans;

        boolean ret;

        ret = super();

        select firstonly cardTable
        where cardTable.Channel == this.Channel
        &&    cardTable.TenderTypeId == this.TenderTypeId;

        if (cardTable)
        {
            if (Box::yesNo(strFmt("@RET4059",this.TenderTypeId),DialogButton::No,"@RET4060","@RET4061") == DialogButton::No)
            {
                ret = checkFailed("@RET4062");
            }
        }

        // Do not allow deletion of Tender type when there are transactions in RetailTransactionPaymentTrans using the current tender type...
        select firstOnly RecId from paymentTrans
            where paymentTrans.tenderType        == this.tenderTypeId
               && paymentTrans.store             == RetailStoreTable::findRecId(this.Channel).StoreNumber;

        if (paymentTrans)
        {
            ret = checkFailed(strFmt("@SYS75284", tablePName(RetailTransactionPaymentTrans)));
        }
        
        // Last pay cash operation cannot be deleted when starting amount is set to required in the store functionality profile.
        boolean isPayCashOperation = this.posOperation == RetailPosOperationHelper::payCashOperation() || this.posOperation == RetailPosOperationHelper::payCashQuickOperation();
        
        if (isPayCashOperation && RetailStoreTenderTypeTable::isLastPayCashOperationInStore(this.Channel) && this.isRequireAmountDeclarationEnabledForStore())
        {
            return checkFailed("@Retail:StoreCashOperationDeleteValidationError");
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the value for the field <c>FieldId</c> is valid.
    /// </summary>
    /// <param name="_fieldIdToCheck">
    /// The field to be validated.
    /// </param>
    /// <returns>
    /// true if the field is valid; otherwise false.
    /// </returns>
    /// <remarks>
    /// Calls method <c>validateTenderTypeId</c> to validate field <c>TenderTypeId</c>.
    /// Calls method <c>validateDifferenceAccount</c> to validate field <c>DifferenceAccLedgerDimension</c>.
    /// Calls method <c>validateFunction</c> to validate field <c>Function</c>.
    /// Calls method <c>validateLineNumInTransaction</c> to validate field <c>LineNumInTransaction</c>.
    /// Calls method <c>validateAccountType</c> to validate field <c>AccountType</c>.
    /// Calls method <c>validateBankBagAccountType</c> to validate field <c>BankBagAccountType</c>.
    /// Calls method <c>validateSafeAccountType</c> to validate field <c>SafeAccountType</c>.
    /// </remarks>
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean ret;

        ret = super(_fieldIdToCheck);

        switch (fieldExt2Id(_fieldIdToCheck))
        {
            case fieldNum(RetailStoreTenderTypeTable, ConnectorName):
                ret = ret && this.validateConnectorName(this.ConnectorName);
                break;
            case fieldNum(RetailStoreTenderTypeTable, TenderTypeId):
                ret = this.validateTenderTypeId();
                break;
            case fieldNum(RetailStoreTenderTypeTable, Function):
                ret = this.validateFunction();
                break;
            case fieldNum(RetailStoreTenderTypeTable, LineNumInTransaction):
                ret = this.validateLineNumInTransaction();
                break;
            case fieldNum(RetailStoreTenderTypeTable, AccountType):
                // <GEERU>
                ret = this.validateAccountType_RU();
                if (!ret)
                    break;
                // </GEERU>
                break;
            case fieldNum(RetailStoreTenderTypeTable, BankBagAccountType):
                // <GEERU>
                ret = this.validateBankOrSafeAccTypeIsNotRCash(this.BankBagAccountType);
                if (!ret)
                    break;
                // </GEERU>
                break;
            case fieldNum(RetailStoreTenderTypeTable, SafeAccountType):
                // <GEERU>
                ret = this.validateBankOrSafeAccTypeIsNotRCash(this.safeAccountType);
                if (!ret)
                    break;
                // </GEERU>
                break;
            case fieldNum(RetailStoreTenderTypeTable, GiftCardItemId):
                // If the gift card item id has changed.
                if (this.orig().GiftCardItemId && this.orig().GiftCardItemId != this.GiftCardItemId)
                {
                    ret = this.canGiftCardItemIdBeChanged(this.orig().GiftCardItemId);
                }
                break;
            case fieldNum(RetailStoreTenderTypeTable, UseForDeclareStartAmount):
                // If the use for declare start amount toggle is enabled.
                if (this.UseForDeclareStartAmount)
                {
                    ret = this.canModifyUseForDeclareStartAmount();
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFunction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the <c>Function</c> field of the <c>RetailStoreTenderTypeTable</c> table.
    /// </summary>
    /// <returns>
    /// true if the field is valid; otherwise, false.
    /// </returns>
    boolean validateFunction()
    {
        RetailTransactionPaymentTrans  paymentTrans;
        RetailStoreTenderTypeTable     tenderType;
        RetailStoreTable               storeTable;

        select firstonly paymentTrans
        where   paymentTrans.TenderType == this.TenderTypeId
        && ((paymentTrans.store && paymentTrans.Store == RetailStoreTable::findRecId(this.Channel).StoreNumber)
        || (paymentTrans.Channel && paymentTrans.Channel == this.Channel));

        if (paymentTrans)
            return checkFailed("@RET4063");

        ttsbegin;

        if (this.Function == RetailTenderFunction::TenderRemoveFloat)
        {
            select firstonly tenderType
            where   tenderType.Function == RetailTenderFunction::TenderRemoveFloat
            &&      tenderType.Channel == this.Channel
            &&      tenderType.TenderTypeId != this.TenderTypeId;

            if (tenderType)
            {
                ttsabort;
                return checkFailed(strFmt("@RET4064",this.Function,this.TenderTypeId));
            }

            storeTable = RetailStoreTable::findRecId(this.Channel,true);
            if (storeTable)
            {
                storeTable.RemoveAddTender = this.TenderTypeId;
                storeTable.update();
            }
        }
        else
        {
            storeTable = RetailStoreTable::findRecId(this.Channel,true);
            if (storeTable && storeTable.RemoveAddTender == this.TenderTypeId)
            {
                storeTable.RemoveAddTender = "";
                storeTable.update();
            }
        }

        ttscommit;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLineNumInTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>LineNumInTransaction</c> field of the <c>RetailStoreTenderTypeTable</c>
    /// table is valid.
    /// </summary>
    /// <returns>
    /// true if the field is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Throws an error if the line number is already used in the transaction.
    /// </remarks>
    boolean validateLineNumInTransaction()
    {
        RetailStoreTenderTypeTable tenderType;

        select firstonly tenderType
        where tenderType.Channel == this.Channel
        &&      tenderType.LineNumInTransaction == this.LineNumInTransaction
        &&      tenderType.TenderTypeId != this.TenderTypeId;

        if (tenderType)
            return checkFailed(strFmt("@RET4065",this.LineNumInTransaction,this.TenderTypeId));

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTenderTypeId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the field <c>TenderTypeId</c> of table <c>RetailStoreTenderTypeTable</c>.
    /// </summary>
    /// <returns>
    /// true if the field is valid; otherwise false.
    /// </returns>
    /// <remarks>
    /// validates the field <c>Function</c> also in the method.
    /// </remarks>
    boolean validateTenderTypeId()
    {
        boolean ret = true;

        this.LineNumInTransaction = this.TenderTypeId;

        this.Function = RetailTenderTypeTable::find(this.TenderTypeId).DefaultFunction;
        ret = this.validateField(fieldNum(RetailStoreTenderTypeTable, Function));

        if (ret == true)
        {
            if (this.Function == RetailTenderFunction::Customer)
            {
                this.TakenToBank = false;
                this.CountingRequired = false;
            }

            if (this.Name == "")
                this.Name = RetailTenderTypeTable::find(this.TenderTypeId).Name;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLastPayCashOperationInStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if it is the last paycash operation in the channel.
    /// </summary>
    /// <param name="_channelId"> channel id of the store</param>
    /// <returns> true if is the last pay cash operation in channel; otherwise false.</returns>
    private static boolean isLastPayCashOperationInStore(RetailChannelRecId _channelId)
    {
        RetailStoreTenderTypeTable retailStoreTenderTypeTable1;
        select count(RecId) from retailStoreTenderTypeTable1
            where retailStoreTenderTypeTable1.channel == _channelId
            && (retailStoreTenderTypeTable1.posOperation == RetailPosOperationHelper::payCashOperation()
                || retailStoreTenderTypeTable1.posOperation == RetailPosOperationHelper::payCashQuickOperation());
     
        return retailStoreTenderTypeTable1.RecId == 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRequireAmountDeclarationEnabledForStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if Require Amount declaration is set for this store's functionality profile.
    /// </summary>
    /// <returns> true if Require Amount declaration is set; otherwise false.</returns>
    private boolean isRequireAmountDeclarationEnabledForStore()
    {
        RetailStoreTable retailStoreTable = RetailStoreTable::findRecId(this.Channel);

        return RetailFunctionalityProfile::find(retailStoreTable.functionalityProfile).RequireAmountDeclaration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the current record is valid and ready to be written to the database.
    /// </summary>
    /// <returns>
    /// true if the record is valid; otherwise false.
    /// </returns>
    /// <remarks>
    /// Validates the fields <c>MinimumAmountEntered</c> and <c>MinimumAmountAllowed</c> before writing to database.
    /// Validates the field <c>AccountRelation</c> in the method.
    /// </remarks>
    public boolean validateWrite()
    {
        boolean ret;
        const int payByGiftPOSOperationId = 214;

        RetailChannelTable          retailChannelTable;
        DimensionAttributeValue     dimensionAttributeValue;
        RetailStoreTenderTypeCardTable retailStoreTenderTypeCardTable;
        RetailTenderTypeCardTable retailTenderTypeCardTable;
        RetailParameters retailParameters;

        retailParameters = RetailParameters::find();

        ret = super();

        if (this.orig().RecId)
        {
            if (this.MinimumAmountEntered > this.MaximumAmountEntered)
                ret = checkFailed("@RET4066");
            else if (this.MinimumAmountAllowed > this.MaximumAmountAllowed)
                ret = checkFailed("@RET4067");
            else
                ret = this.validateField(fieldNum(RetailStoreTenderTypeTable, LineNumInTransaction));
        }

        // If this is a gift card related payment method
        // don't save the record if the operation is a gift card operation
        // and there are non GiftCard type cards in the card setup.
        if (this.posOperation == payByGiftPOSOperationId)
        {
            select retailStoreTenderTypeCardTable
                join cardTypeId, cardTypes from retailTenderTypeCardTable
                where retailStoreTenderTypeCardTable.cardTypeId == retailTenderTypeCardTable.cardTypeId &&
                    retailStoreTenderTypeCardTable.Channel == this.Channel &&
                    retailStoreTenderTypeCardTable.tenderTypeId == this.tenderTypeId &&
                    retailTenderTypeCardTable.cardTypes != RetailCardTypesBase::GiftCard;

            if (retailStoreTenderTypeCardTable)
            {
                return checkFailed("@Retail:GiftCardRelatedPaymentMethod"); // This is gift card related payment method.
                // Please remove card types that are not gift cards from the card setup and try again.
            }

            if (this.ConnectorName != "")
            {
                if (this.GiftCardItemId == "")
                {
                    ret = checkFailed("@Retail:GiftCardItemNumberNotSpecifiedErrorMessage");
                }
            }
            else
            {
                if (this.GiftCardItemId == "" && retailParameters.GiftcardItem == "" )
                {
                    ret = checkFailed("@Retail:GiftCardItemNumberNotSpecifiedErrorMessage");
                }
            }
        }

        // Clear the UseForDeclareStartAmount field, when it is already set but user changing operation to something other than pay cash.
        if (this.posOperation != RetailPosOperationHelper::payCashOperation() && this.UseForDeclareStartAmount)
        {
            this.UseForDeclareStartAmount = 0;
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)) && this.Channel)
        {
            retailChannelTable = RetailChannelTable::findByRecId(this.Channel);

            if (retailChannelTable && retailChannelTable.ChannelType == RetailChannelType::MCRCallCenter)
            {
                if (this.LedgerDimension && MainAccount::isBlockedForManualEntryByLedgerDimension(this.LedgerDimension))
                {
                    DimensionDisplayValue dimensionDisplayValue = DimensionAttributeValueCombination::find(this.LedgerDimension).DisplayValue;

                    ret = checkFailed(strFmt("@SYS319027", dimensionDisplayValue));
                }

                // Customer function does not require a ledger account for call center
                else if (!this.LedgerDimension && this.function != RetailTenderFunction::Customer)
                {
                    ret = checkFailed(strFmt("@MCR10845", this.TenderTypeId));
                }
            }
        }

        if (RetailCommercePaymentsFeatureHelper::isEnableCommercePayments())
        {
            ret = ret && this.validateForCommerce();
        }
             
        boolean originalPosOperationIsCash = this.Orig().PosOperation == RetailPosOperationHelper::payCashOperation()
                                                    || this.Orig().PosOperation == RetailPosOperationHelper::payCashQuickOperation();

        // last pay cash cannot be modified when starting amounts required.
        if (RetailStoreTenderTypeTable::isLastPayCashOperationInStore(this.Channel) && originalPosOperationIsCash
            && this.isRequireAmountDeclarationEnabledForStore() && this.posOperation != RetailPosOperationHelper::payCashOperation())
        {
            return checkFailed("@Retail:StoreCashOperationValidationError");
        }

        if (this.Function == RetailTenderFunction::Card && this.countingRequired && RetailTenderTypeCardSkipCountingRequiredToggle::instance().isEnabled())
        {
            return checkFailed("@Retail:CountingRequiredNotSupportedForCardType");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a record in the table <c>RetailStoreTenderTypeTable</c>.
    /// </summary>
    /// <param name="_channel">
    /// The current value of channel Id.
    /// </param>
    /// <param name="_tenderTypeId">
    /// The current value of tender type Id.
    /// </param>
    /// <param name="_forUpdate">
    /// A boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>RetailStoreTenderTypeTable</c> table;otherwise an empty record.
    /// </returns>
    /// <remarks>
    /// _storeId parameter was replaced with _channel in AX 2012 R3.
    /// </remarks>
    public static RetailStoreTenderTypeTable find(RetailChannelRecId _channel, RetailTenderTypeId _tenderTypeId, boolean _forUpdate = false)
    {
        RetailStoreTenderTypeTable storeTenderTypeTable;

        if (_channel && _tenderTypeId)
        {
            storeTenderTypeTable.selectForUpdate(_forUpdate);

            select firstonly storeTenderTypeTable
                index hint storeTypeIdx
                   where storeTenderTypeTable.TenderTypeId == _tenderTypeId
                    && storeTenderTypeTable.Channel == _channel;
        }

        return storeTenderTypeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAllInternalGiftCardItemIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the gift card item id for all internal gift cards.
    /// </summary>
    /// <param name = "newInternalGiftCardItemId">The new internal gift card item id.</param>
    public static void updateAllInternalGiftCardItemIds(str newInternalGiftCardItemId)
    {
        const int payByGiftCardOperationId = 214;
        RetailStoreTenderTypeTable retailStoreTenderTypeTable;

        // All internal gift cards can be identified as having the posOperation field set to 214 and
        // Having the connectorName as blank.
        update_recordset retailStoreTenderTypeTable
            setting GiftCardItemId = newInternalGiftCardItemId
            where retailStoreTenderTypeTable.posOperation == payByGiftCardOperationId &&
            retailStoreTenderTypeTable.ConnectorName == '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGiftCardItemIdBeChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if a gift card item id can be changed.
    /// This is only possible if its not been used yet.
    /// </summary>
    /// <param name = "giftCardItemIdToCheck">Gift card item number.</param>
    /// <returns>True when the gift card item id can be changed; False otherwise.</returns>
    public boolean canGiftCardItemIdBeChanged(ItemId giftCardItemIdToCheck)
    {
        SalesLine salesLine;
        RetailTransactionSalesTrans retailTransactionSalesTrans;
        boolean result = true;

        select firstonly1 ItemId from salesLine where salesLine.ItemId == giftCardItemIdToCheck;
        select firstonly1 ItemId from retailTransactionSalesTrans where retailTransactionSalesTrans.itemId == giftCardItemIdToCheck;

        if (salesLine.RecId != 0 || retailTransactionSalesTrans.RecId != 0)
        {
            // Item number cannot be changed when item transactions have been generated.
            // Delete line and create a new one with the new item number.
            warning("@SYS19376");
            result = false;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>write</Name>
				<Source><![CDATA[
    public void write()
    {
        const int payByGiftCardOperationId = 214;
        RetailParameters retailParameters;

        ttsbegin;

        // Check if the current record is associated to an internal gift card and has the gift card item id updated.
        if (this.orig().GiftCardItemId != this.GiftCardItemId && this.posOperation == payByGiftCardOperationId && this.ConnectorName == '')
        {
            // Update the RetailParameters table in case the gift card item id has been updated for the internal gift card.
            retailParameters = retailParameters::find();
            retailParameters.GiftcardItem = this.GiftCardItemId;
            retailParameters.update();

            // Update the other records in this table associated to internal gift cards.
            RetailStoreTenderTypeTable::updateAllInternalGiftCardItemIds(this.GiftCardItemId);
        }

        super();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForCommerce</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the tender type is valid to be used with Commerce payments. This is only checked during and for
    /// enablement of the Retail Commerce Payment Feature.
    /// </summary>
    /// <param name = "_throwsError">
    /// Disables throwing of warning when the param is true .
    /// </param>
    /// <returns>True when the tender type is valid; False otherwise.</returns>
    public boolean validateForCommerce(boolean _throwsError = true)
    {
        boolean result = true;

        switch (this.Function)
        {
            case RetailTenderFunction::Card:
                result = this.posOperation == RetailPosOperationHelper::payCardOperation()
                        || this.posOperation == RetailPosOperationHelper::payLoyaltyCardOperation()
                        || this.posOperation == RetailPosOperationHelper::payGiftCardOperation();
                break;
            case RetailTenderFunction::Check:
                result = this.posOperation == RetailPosOperationHelper::payCheckOperation();
                break;
            case RetailTenderFunction::Customer:
                result = this.posOperation == RetailPosOperationHelper::payCustomerAccountOperation();
                break;
            case RetailTenderFunction::Normal:
                result = this.posOperation == RetailPosOperationHelper::payCashOperation()
                        || this.posOperation == RetailPosOperationHelper::payCashQuickOperation()
                        || this.posOperation == RetailPosOperationHelper::payCurrencyOperation()
                        || this.posOperation == RetailPosOperationHelper::payCreditMemoOperation();
                break;
            default:
                result = true;
                break;
        }

        if (!result && _throwsError)
        {
            // If posOperationLabel is empty, set str to 'blank'
            str posOperationLabel = RetailPosOperationHelper::getPosOperationLabel(this.posOperation);
            posOperationLabel = posOperationLabel ? posOperationLabel : '@SYS24248';

            checkFailed(strFmt("@Retail:RetailStoreTenderTypeCommerceValidation", this.tenderTypeId, this.function, posOperationLabel, RetailChannelTable::findByRecId(this.Channel).name()));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAvailableForCommercePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the tender type is valid to be used with Commerce payments.
    /// </summary>
    /// <returns>True when the tender type is available to be used for Commerce order; False otherwise.</returns>
    public boolean isAvailableForCommercePayment()
    {
        boolean result;

        switch (this.posOperation)
        {
            case RetailPosOperationHelper::payCardOperation():
            case RetailPosOperationHelper::payLoyaltyCardOperation():
            case RetailPosOperationHelper::payGiftCardOperation():
            case RetailPosOperationHelper::payCheckOperation():
            case RetailPosOperationHelper::payCustomerAccountOperation():
            case RetailPosOperationHelper::payCashOperation():
            case RetailPosOperationHelper::payCashQuickOperation():
                result = this.validateForCommerce();
                break;
            default:
                result = false;
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canModifyUseForDeclareStartAmount</Name>
				<Source><![CDATA[
    private boolean canModifyUseForDeclareStartAmount()
    {
        RetailStoreTenderTypeTable tenderType;

        // Check whether UseForDeclareStartAmount is already enabled for any other payment method for that store.
        select firstonly tenderType
            where tenderType.Channel == this.Channel
                && tenderType.UseForDeclareStartAmount == NoYes::Yes
                && tenderType.TenderTypeId != this.TenderTypeId;

        if (tenderType)
        {
            return checkFailed(strFmt('@Retail:UnableToModifyUseForDeclareStartAmountErrorMessage', tenderType.tenderTypeId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateConnectorName</Name>
				<Source><![CDATA[
    private boolean validateConnectorName(str connectorNameToValidate)
    {
        boolean result = false;
        str callerName = 'RetailStoreTenderTypeTable';

        System.String[] connectorNames = RetailPaymentConnectorLookupTempTable::getArrayOfSupportedConnectors(callerName);
        if (connectorNameToValidate == '' || System.Array::IndexOf(connectorNames, connectorNameToValidate) >= 0)
        {
            result = true;
        }

        if(!result)
        {
            warning(strFmt('@Retail:UnableToLocateConnectorWithGivenNameWarningMessage', connectorNameToValidate));
        }

        return result;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Retail</ConfigurationKey>
	<DeveloperDocumentation>@RET260336</DeveloperDocumentation>
	<FormRef>RetailStoreTenderTypeTable</FormRef>
	<Label>@RET3253</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>Channel</TitleField1>
	<TitleField2>name</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>FoundAndEmpty</CacheLookup>
	<ClusteredIndex>storeTypeIdx</ClusteredIndex>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Payments</Modules>
	<PrimaryIndex>storeTypeIdx</PrimaryIndex>
	<ReplacementKey>storeTypeIdx</ReplacementKey>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>RetailStoreTenderTypeCardTable</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>RetailStoreTenderTypeCardTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>RetailTransactionPaymentTrans</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>RetailTransactionPaymentTrans</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>tenderTypeId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>function</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Channel</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>tenderTypeId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>function</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Channel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>tenderTypeId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Account</Name>
			<Label>@RET3084</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>accountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@SYS80094</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>lineNumInTransaction</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>askForDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>seekAuthorization</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>payAccountBill</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>allowReturnNegative</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GiftCardCompany</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountTypeGiftCardCompany</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimensionGiftCardCompany</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Amounts</Name>
			<Label>@RET4846</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>minimumAmountEntered</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>maximumAmountEntered</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>maximumAmountAllowed</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankBagAccount</Name>
			<Label>@RET4425</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ActiveAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankBagAccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankBagLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>bankTransactionType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ChangeSetup</Name>
			<Label>@RET3265</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>changeLineOnReceipt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>aboveMinimumTenderId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>minimumChangeAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>changeTenderId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Check</Name>
			<Label>@RET3266</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>endorseCheck</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>slipBackInPrinter</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>endorsmentLine1</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>endorsmentLine2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>frontOfCheck</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>slipFrontInPrinter</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>checkPayee</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Description</Name>
			<Label>@SYS7576</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>DifferenceAccount</Name>
			<Label>@RET3251</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DifferenceAccLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>differenceAccountName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>maxNormalDifferenceAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DiffAccBigDiffLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>differenceAccountForBigDifferenceName</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimensions</Name>
			<Label>@SYS5951</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>FiscalPrinter_BR</Name>
			<Label>@RET2765</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>fiscalPrinterTenderType_BR</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Function</Name>
			<Label>@RET3022</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>function</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GiftCard</Name>
			<Label>@RET4497</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>GiftCardItemId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Group1</Name>
			<Label>@RET4847</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>openDrawer</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>posCountEntries</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Group2</Name>
			<Label>@RET4848</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>compressPaymentEntries</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>countingRequired</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>multiplyInTenderOperations</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>allowFloat</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>takenToBank</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>takenToSafe</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>tenderTypeId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymTermId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>KeyboardEntry</Name>
			<Label>@RET3267</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>OverUnderTender</Name>
			<Label>@RET3268</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>allowOvertender</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>maximumOvertenderAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>allowUndertender</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>undertenderAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>RetailEx3</Name>
			<Label>@RET2690</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>posOperation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Rounding</Name>
			<Label>@RET4849</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>roundingMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>rounding</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SafeAccount</Name>
			<Label>@RET4850</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>safeActiveAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>safeAccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SafeAccLedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SignatureCapture</Name>
			<Label>@RET261077</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>sigCapEnabled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>sigCapMinAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TenderDeclaration</Name>
			<Label>@RET3609</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>maxCountingDifference</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>maxRecount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TenderFlowAccount_RU</Name>
			<Label>@RET3021</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TenderFlowLedgerDimension_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CashDrawerLimit</Name>
			<Label>@Retail:CashDrawerLimitId</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CashDrawerLimitEnabled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CashDrawerLimit</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GiftCardCashOutThresholdGroup</Name>
			<Label>@Retail:CashOutGiftCardLabel</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>GiftCardCashOutThreshold</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>NonReceiptReturns</Name>
			<Label>@Retail:NonReceiptReturns</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RestrictReturnsWithoutReceipt</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>UseForDeclareStartAmount</Name>
			<Label>@Retail:UseForDeclareStartAmount</Label>
			<Fields />
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>changeTenderId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailTenderTypeId</ExtendedDataType>
			<Label>@RET3254</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>aboveMinimumTenderId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailTenderTypeId</ExtendedDataType>
			<Label>@RET3255</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>accountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAccountType</ExtendedDataType>
			<EnumType>RetailLedgerBank</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AccountTypeGiftCardCompany</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAccountType</ExtendedDataType>
			<EnumType>RetailLedgerBank</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ActiveAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@RET4424</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>allowFloat</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAllowFloat</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>allowOvertender</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAllowOvertender</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>allowReturnNegative</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAllowReturnNegative</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>allowUndertender</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAllowUndertender</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>askForDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAskForDate</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankBagAccountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAccountType</ExtendedDataType>
			<EnumType>RetailLedgerBank</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankBagLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDynamicDefaultAccount</ExtendedDataType>
			<Label>@RET3330</Label>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>changeLineOnReceipt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailChangeLineOnReceipt</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Channel</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailChannelRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>checkPayee</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>RetailCheckPayee</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>compressPaymentEntries</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailCompressPaymentEntries</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ConnectorName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailConnectorName</ExtendedDataType>
			<Label>@Retail:RetailConnectorNameLabel</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>countingRequired</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailCountingRequired</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDefaultDimensionValueSet</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DiffAccBigDiffLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
			<Label>@RET4327</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DifferenceAccLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
			<Label>@RET3251</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>endorseCheck</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailEndorseCheck</ExtendedDataType>
			<Label>@RET3260</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>endorsmentLine1</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailEndorsmentLine</ExtendedDataType>
			<Label>@RET3261</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>endorsmentLine2</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailEndorsmentLine</ExtendedDataType>
			<Label>@RET3262</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>fiscalPrinterTenderType_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>RetailFiscalPrinterTenderType_BR</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>frontOfCheck</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailFrontOfCheck</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>function</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailTenderTypeFunction</ExtendedDataType>
			<EnumType>RetailTenderFunction</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>GiftCardCompany</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>DataAreaId</ExtendedDataType>
			<Label>@REX1552</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>GiftCardItemId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@Retail:GiftCardItemNumberLabel</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>GiftCardCashOutThreshold</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Amount</ExtendedDataType>
			<HelpText>@Retail:GiftCardCashOutThresholdHelpText</HelpText>
			<Label>@Retail:GiftCardCashOutThresholdLabel</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>HideCardInputDetailsInPOS</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@Retail:HideCardInputDetailsInPOSHelpText</HelpText>
			<Label>@Retail:HideCardInputDetailsInPOSLabel</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDynamicDefaultAccount</ExtendedDataType>
			<Label>@RET3330</Label>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimensionGiftCardCompany</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDynamicAccount</ExtendedDataType>
			<Label>@RET3330</Label>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>lineNumInTransaction</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailLineNumInTransaction</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>maxCountingDifference</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailMaxCountingDifference</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>maximumAmountAllowed</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAmountEnteredAllowed</ExtendedDataType>
			<Label>@Retail:MaxAmountPerTransaction</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>maximumAmountEntered</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAmountEnteredAllowed</ExtendedDataType>
			<Label>@Retail:MaxAmountPerLine</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>maximumOvertenderAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailOvertenderAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>maxNormalDifferenceAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailMaxDifferenceAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>maxRecount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailMaxRecount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>minimumAmountAllowed</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAmountEnteredAllowed</ExtendedDataType>
			<Label>@Retail:MinAmountPerTransaction</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>minimumAmountEntered</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAmountEnteredAllowed</ExtendedDataType>
			<Label>@Retail:MinAmountPerLine</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>minimumChangeAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailMinimumChangeAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>multiplyInTenderOperations</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailMultiplyInTenderOperations</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>name</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailTenderTypeName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>openDrawer</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailOpenDrawer</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>payAccountBill</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailPayAccountBill</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymTermId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymTermId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>posCountEntries</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailPosCountEntries</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>posOperation</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailOperationId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>rounding</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RoundOff</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>roundingMethod</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>RetailNoneNearestUpDown</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SafeAccLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDynamicDefaultAccount</ExtendedDataType>
			<Label>@RET4852</Label>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>safeAccountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailAccountType</ExtendedDataType>
			<EnumType>RetailLedgerBank</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>safeActiveAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@RET4853</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>seekAuthorization</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>RetailAuthorizationTypes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>sigCapEnabled</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailSigCapEnabled</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>sigCapMinAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailSigCapMinAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>slipBackInPrinter</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailSlipInPrinter</ExtendedDataType>
			<Label>@RET3263</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>slipFrontInPrinter</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailSlipInPrinter</ExtendedDataType>
			<Label>@RET3264</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>takenToBank</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailTakenToBank</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>takenToSafe</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailTakenToSafe</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TenderFlowLedgerDimension_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU,PL,CZ,HU,LT,LV,EE</CountryRegionCodes>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
			<Label>@GLS100985</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>tenderTypeId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailStoreTenderTypeId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>undertenderAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailUndertenderAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>bankTransactionType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankTransactionType</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LegacyConnectorName</Name>
			<ConfigurationKey>RetailCDXBackwardCompatibility</ConfigurationKey>
			<ExtendedDataType>RetailConnectorName</ExtendedDataType>
			<Label>@Retail_HF_3937382:LegacyConnectorName</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CashDrawerLimitEnabled</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CashDrawerLimit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Price</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RestrictReturnsWithoutReceipt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailRestrictReturnsWithoutReceipt</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UseForDeclareStartAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>storeTypeIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>Channel</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>tenderTypeId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueCombinationIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>LedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueCombinationIdx1</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>DifferenceAccLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueCombinationIdx2</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>DiffAccBigDiffLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueCombinationIdx3</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>BankBagLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueCombinationIdx4</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>SafeAccLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DimensionAttributeValueCombination</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimension</Name>
					<Field>LedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DimensionAttributeValueCombination1</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DifferenceAccLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DifferenceAccLedgerDimension</Name>
					<Field>DifferenceAccLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DimensionAttributeValueCombination2</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DiffAccBigDiffLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DiffAccBigDiffLedgerDimension</Name>
					<Field>DiffAccBigDiffLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DimensionAttributeValueCombination3</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankBagLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankBagLedgerDimension</Name>
					<Field>BankBagLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DimensionAttributeValueCombination4</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>SafeAccLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SafeAccLedgerDimension</Name>
					<Field>SafeAccLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DimensionAttributeValueCombinationGC</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerDimension1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimensionGiftCardCompany</Name>
					<Field>LedgerDimensionGiftCardCompany</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DimensionAttributeValueSet</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PaymTerm</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>PaymTerm</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymTermId</Name>
					<SourceEDT>PaymTermId</SourceEDT>
					<Field>PaymTermId</Field>
					<RelatedField>PaymTermId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TermIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RetailChannelTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RetailChannelTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Composition</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Channel</Name>
					<Field>Channel</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>RetailOperations</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RetailOperations</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>UserOperation_Extern</Name>
					<RelatedField>UserOperation</RelatedField>
					<Value>1</Value>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>posOperation</Name>
					<SourceEDT>RetailOperationId</SourceEDT>
					<Field>posOperation</Field>
					<RelatedField>OperationId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>RetailTenderTypeTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RetailTenderTypeTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>tenderTypeId</Name>
					<Field>tenderTypeId</Field>
					<RelatedField>tenderTypeId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RetailTenderTypeTable1</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>RetailTenderTypeTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>RetailTenderTypeTable1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>aboveMinimumTenderId</Name>
					<SourceEDT>RetailTenderTypeId</SourceEDT>
					<Field>aboveMinimumTenderId</Field>
					<RelatedField>tenderTypeId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>tenderTypeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RetailTenderTypeTable2</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>RetailTenderTypeTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>changeTender</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>changeTenderId</Name>
					<SourceEDT>RetailTenderTypeId</SourceEDT>
					<Field>changeTenderId</Field>
					<RelatedField>tenderTypeId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>tenderTypeIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TenderFlowLedgerDimension_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TenderFlowLedgerDimension_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>RetailStoreTenderTypeTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TenderFlowLedgerDimension_RU</Name>
					<Field>TenderFlowLedgerDimension_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>GiftCardItemId</Name>
					<Field>GiftCardItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>