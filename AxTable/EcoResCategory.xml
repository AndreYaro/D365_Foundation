<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>EcoResCategory</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class EcoResCategory extends common
{

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addToHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a category node to the hierarchy that is specified in the <c>CategoryHierarchy</c> field
    /// </summary>
    /// <returns>
    /// true if the specified category was successfully added; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The user must always call this method instead of the insert method to create a new record in this
    /// table. This category can be either new or existing.
    /// </remarks>
    public boolean addToHierarchy()
    {
        EcoResInstrumentationLogger logger = this.getLogger();
        using (var a = logger.category().addToHierarchy())
        {
            boolean ret = false;

            try
            {
                ttsbegin;

                if (this.RecId && EcoResCategory::exist(this.RecId))
                {
                    //if the record already exists, just update it.
                    if (this.validateWrite())
                    {
                        this.update();
                        ret = true;
                    }
                }
                else
                {
                    if (this.ParentCategory)
                    {
                        ret = this.addChildToHierarchy(logger);
                    }
                    else
                    {
                        ret = this.setRoot();
                    }
                }
                ttscommit;
            }
            catch
            {
                ret = false;
            }

            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChildToHierarchy</Name>
				<Source><![CDATA[
    private boolean addChildToHierarchy(EcoResInstrumentationLogger _logger)
    {
        // lock the root node to prevent concurrent modifications
        EcoResCategory rootCategory;
        select pessimisticlock firstonly RecId from rootCategory
            where rootCategory.CategoryHierarchy == this.CategoryHierarchy &&
                    rootCategory.NestedSetLeft     == 1;

        EcoResCategory parentCategory = EcoResCategory::find(this.ParentCategory, true);
        if (!parentCategory.RecId)
        {
            // parent specified is not valid or someone deleted it
            throw Global::error("@SYS134257");
        }
        
        return this.insertChild(parentCategory, _logger);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertChild</Name>
				<Source><![CDATA[
    private boolean insertChild(EcoResCategory _parentCategory, EcoResInstrumentationLogger _logger)
    {
        this.initFromParent(_parentCategory);
        this.NestedSetLeft  = _parentCategory.NestedSetRight;
        this.NestedSetRight = _parentCategory.NestedSetRight + 1;
        this.Level          = _parentCategory.Level + 1;

        if (this.validateWrite())
        {
            if (!this.isNestedSetValid())
            {
                _logger.logNestedSetValues(this);
            }

            this.addCategoryGapToNestedSetModel(this.CategoryHierarchy, this.NestedSetLeft, this.NestedSetRight);
            this.insert();
            this.insertProcCategoryModifier();

            // update all Procurement Catalogs by adding a corresponding node to each
            this.addToProcurementCatalogs(_parentCategory.Name);

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLogger</Name>
				<Source><![CDATA[
    private EcoResInstrumentationLogger getLogger()
    {
        return EcoResInstrumentationLogger::createLogger(tableStr(EcoResCategory));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNestedSetValid</Name>
				<Source><![CDATA[
    private boolean isNestedSetValid()
    {
        boolean isRightValid = this.NestedSetRight > 2; // right is at least the node count * 2

        if (this.Level == 1)
        {
            return this.NestedSetLeft == 1 && isRightValid;
        }

        return this.NestedSetLeft > 1 && isRightValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProcCategoryModifier</Name>
				<Source><![CDATA[
    private void insertProcCategoryModifier()
    {
        ProcCategoryModifier procCategory;
        procCategory.initValue();
        procCategory.Category = this.RecId;
        procCategory.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToProcurementCatalogs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a corresponding display category node in all procurement catalogs as a new node is added to
    /// the procurement category hierarchy.
    /// </summary>
    /// <param name="_ecoResCategoryName">
    /// The name of the newly added procurement category node.
    /// </param>
    private void addToProcurementCatalogs(EcoResCategoryName _ecoResCategoryName)
    {
        CatProcureCatalogTable          tblCatalog;
        CatDisplayCategoryTable         tblDCategory, tblDCParent;
        CatDisplayCategorySharedInfo    tblSharedData, tblSDParent;

        // update all Procurement Catalogs by adding a corresponding node to each
        while select forupdate * from tblCatalog where tblCatalog.ProcurementHierarchy == this.CategoryHierarchy
        {
            select forupdate firstonly * from tblDCParent
                where tblDCParent.Catalog == tblCatalog.RecId
                join * from tblSDParent
                where tblSDParent.RecId == tblDCParent.SharedData
                    && tblSDParent.Category == this.ParentCategory;

            tblSharedData = tblSDParent.cloneRecord(CatProcureCatalogTable::catalogToDisplayCategoryUpdateType(tblCatalog.UpdateType), this.RecId);
            tblSharedData.insert();
            tblDCategory = CatDisplayCategoryTable::initDisplayCategory(
                tblCatalog,
                CatDisplayCategoryTable::findNonExistNameInCatalog(tblCatalog.RecId, this.Name),
                tblDCParent,
                tblSharedData,
                (tblDCParent ? tblDCParent.UpdateType : tblCatalog.toDisplayCategoryUpdateType()),
                this
            );

            if (tblDCategory.validateWrite())
            {
                tblDCategory.insert();
            }
            else
            {
                throw Global::error(strFmt("@SYS138456", tblDCategory.IsHidden, tblCatalog.Name, this.Name, _ecoResCategoryName));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDefaultProjectGlobalCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the value of the project category.
    /// </summary>
    /// <returns>
    /// true if the value of the project category is valid; otherwise, false.
    /// </returns>
    private boolean checkDefaultProjectGlobalCategory()
    {
        SharedCategoryRoles     sharedCategoryRoles;
        SharedCategoryRoleType  sharedCategoryRoleType;
        CategoryTable           categoryTable;
        ProjCategory            projCategory;
        boolean                 retValue    = true;

        if (this.DefaultProjectGlobalCategory)
        {
            if (!EcoResCategoryHierarchy::find(this.CategoryHierarchy).allowEditProjectGlobalCategory())
            {
                retValue =  checkFailed("@SYS6144");
            }

            if (retValue)
            {
                select firstonly RecId from sharedCategoryRoles
                    where sharedCategoryRoles.GlobalCategory == this.DefaultProjectGlobalCategory
                    exists join sharedCategoryRoleType
                    where sharedCategoryRoleType.RecId == sharedCategoryRoles.GlobalCategoryRoleType &&
                          sharedCategoryRoleType.CategoryRoleType == CategoryRoleType::Project;

                if (!sharedCategoryRoles)
                {
                    retValue = checkFailed("@SYS190122");
                }
            }
            if (retValue)
            {
                select firstonly crossCompany CategoryId from categoryTable
                    where categoryTable.SharedCategory == this.DefaultProjectGlobalCategory &&
                        categoryTable.UseInProject == NoYes::Yes
                    exists join CategoryId from projCategory
                        where projCategory.CategoryId               == categoryTable.CategoryId     &&
                            (projCategory.CategoryType               == ProjCategoryType::Item  ||
                             projCategory.CategoryType               == ProjCategoryType::Cost  ||
                             projCategory.CategoryType               == ProjCategoryType::Hour)     &&
                            projCategory.SetupSubscription          == NoYes::No                    &&
                            projCategory.SetupEstimate              == NoYes::No                    &&
                            projCategory.PSACustPaymentRetention    == NoYes::No                    &&
                            projCategory.PSAIndirectComponent       == NoYes::No;

                if (!categoryTable.CategoryId)
                {
                    retValue = checkFailed("@SYS4005058");
                }
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides the delete method to check if <c>RetailCategoryContainmentLookup</c> table needs an update.
    /// </summary>
    public void delete()
    {
        super();

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            RetailCategoryContainmentLookup::checkAndDeleteReferencedCategoriesHierarchy(this.RecId);
        }

        EcoResCategoryTax::deleteByEcoResCategoryId(this.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSubTree</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the currently selected Category subtree.
    /// </summary>
    public void deleteSubTree()
    {
        EcoResInstrumentationLogger logger = this.getLogger();
        using (var a = logger.category().delete())
        {
            EcoResCategoryNestedSetLeft            delLeft  = this.NestedSetLeft;
            EcoResCategoryNestedSetRight           delRight = this.NestedSetRight;
            EcoResCategory                         ecoResCategory;
            EcoResCategory                         ecoResCategoryToDelete;
            RecId                                  derivedFinHierarchyRecId;
            dataAreaId                             dataAreaId;
            LedgerDerivedFinHierarchyFilterResults ledgerDerivedFinHierarchyFilterResults;
            LedgerDerivedFinHierarchyRuleCriteria  ledgerDerivedFinHierarchyRuleCriteria;
            LedgerDerivedFinHierarchyLegalEntities ledgerDerivedFinHierarchyLegalEntities;

            #EcoResCategoryDefaults

            ttsbegin;

            //lock the tree for further modifications
            EcoResCategory ecoResRootCategory;

            select pessimisticlock firstonly RecId from ecoResRootCategory
                        where ecoResRootCategory.CategoryHierarchy    == this.CategoryHierarchy &&
                                ecoResRootCategory.NestedSetLeft   == #ECORESROOTNESTEDLEFTVALUE;

            //make sure there were no modifications meanwhile
            ecoResCategory = EcoResCategory::find(this.RecId, true);
            if (!ecoResCategory.RecId)
            {
                // node specified is not valid, or already deleted
                throw Global::error("@SYS134263");
            }
            else if (   (ecoResCategory.NestedSetLeft != this.NestedSetLeft)   ||
                        (ecoResCategory.NestedSetRight != this.NestedSetRight) ||
                        (ecoResCategory.CategoryHierarchy != this.CategoryHierarchy) )
            {
                //the tree has been modified
                throw Global::error("@SYS134262");
            }

            if (EcoResCategoryHierarchyRole::findRoleHierarchyPair(EcoResCategoryNamedHierarchyRole::Financials, ecoResCategory.CategoryHierarchy).RecId != 0)
            {
                derivedFinHierarchyRecId = ecoResCategory.CategoryHierarchy;
            }
        
            // prompt user if category reference states should be check before deleting.
            boolean checkCategoryReferenceStates = this.categoryReferencePrompt();

            // delete the descendants
            EcoResCategory ecoResCategoryDescendents = ecoResCategory.getDescendants(true);
            while (ecoResCategoryDescendents)
            {
                if (checkCategoryReferenceStates)
                {
                    this.validateCategoryReference(ecoResCategoryDescendents.RecId);
                }

                if (ecoResCategoryDescendents.validateDelete())
                {
                    if (derivedFinHierarchyRecId != 0)
                    {
                        ledgerDerivedFinHierarchyLegalEntities = LedgerDerivedFinHierarchyLegalEntities::findByDerivedFinHierarchy(derivedFinHierarchyRecId);

                        while (ledgerDerivedFinHierarchyLegalEntities)
                        {
                            dataAreaId = CompanyInfo::findRecId(ledgerDerivedFinHierarchyLegalEntities.CompanyInfo).DataArea;

                            changecompany(dataAreaId)
                            {
                                ttsBegin;
                                delete_from ledgerDerivedFinHierarchyFilterResults
                        exists join ecoResCategoryToDelete
                            where ecoResCategoryToDelete.RecId == ledgerDerivedFinHierarchyFilterResults.EcoResCategory &&
                                ecoResCategoryToDelete.RecId == ecoResCategoryDescendents.RecId;
                                ttsCommit;
                            }

                            next ledgerDerivedFinHierarchyLegalEntities;
                        }

                        ledgerDerivedFinHierarchyLegalEntities = LedgerDerivedFinHierarchyLegalEntities::findByDerivedFinHierarchy(derivedFinHierarchyRecId);

                        while (ledgerDerivedFinHierarchyLegalEntities)
                        {
                            dataAreaId = CompanyInfo::findRecId(ledgerDerivedFinHierarchyLegalEntities.CompanyInfo).DataArea;

                            changecompany(dataAreaId)
                            {
                                ttsbegin;
                                delete_from ledgerDerivedFinHierarchyRuleCriteria
                        exists join ecoResCategoryToDelete
                            where ecoResCategoryToDelete.RecId == ledgerDerivedFinHierarchyRuleCriteria.EcoResCategory &&
                                ecoResCategoryToDelete.CategoryHierarchy == ecoResCategoryDescendents.RecId;
                                ttscommit;
                            }

                            next ledgerDerivedFinHierarchyLegalEntities;
                        }
                    }
                    ecoResCategoryDescendents.delete();
                }
                else
                {
                    throw Global::error("@SYS134261");
                }

                next ecoResCategoryDescendents;
            }

            if (checkCategoryReferenceStates)
            {
                this.validateCategoryReference(ecoResCategory.RecId);
            }

            //delete this node
            if (ecoResCategory.validateDelete())
            {
                if (derivedFinHierarchyRecId != 0)
                {
                    ledgerDerivedFinHierarchyLegalEntities = LedgerDerivedFinHierarchyLegalEntities::findByDerivedFinHierarchy(derivedFinHierarchyRecId);

                    while (ledgerDerivedFinHierarchyLegalEntities)
                    {
                        dataAreaId = CompanyInfo::findRecId(ledgerDerivedFinHierarchyLegalEntities.CompanyInfo).DataArea;

                        changecompany(dataAreaId)
                        {
                            ttsBegin;
                            delete_from ledgerDerivedFinHierarchyFilterResults
                        exists join ecoResCategoryToDelete
                            where ecoResCategoryToDelete.RecId == ledgerDerivedFinHierarchyFilterResults.EcoResCategory &&
                                ecoResCategoryToDelete.RecId == ecoResCategory.RecId;
                            ttsCommit;
                        }

                        next ledgerDerivedFinHierarchyLegalEntities;
                    }

                    ledgerDerivedFinHierarchyLegalEntities = LedgerDerivedFinHierarchyLegalEntities::findByDerivedFinHierarchy(derivedFinHierarchyRecId);

                    while (ledgerDerivedFinHierarchyLegalEntities)
                    {
                        dataAreaId = CompanyInfo::findRecId(ledgerDerivedFinHierarchyLegalEntities.CompanyInfo).DataArea;

                        changecompany(dataAreaId)
                        {
                            ttsbegin;
                            delete_from ledgerDerivedFinHierarchyRuleCriteria
                        exists join ecoResCategoryToDelete
                            where ecoResCategoryToDelete.RecId == ledgerDerivedFinHierarchyRuleCriteria.EcoResCategory &&
                                ecoResCategoryToDelete.CategoryHierarchy == ecoResCategory.RecId;
                            ttscommit;
                        }

                        next ledgerDerivedFinHierarchyLegalEntities;
                    }
                }
                ecoResCategory.delete();
            }
            else
            {
                throw Global::error("@SYS134261");
            }

            this.removeCategoryGapFromNestedSetModel(this.CategoryHierarchy, delLeft, delRight, logger);

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCategoryGapToNestedSetModel</Name>
				<Source><![CDATA[
    private void addCategoryGapToNestedSetModel(
        EcoResCategoryHierarchyId       _categoryHierarchyRecId,
        EcoResCategoryNestedSetLeft     _addingNestedSetLeft,
        EcoResCategoryNestedSetRight    _addingNestedSetRight)
    {
        int64 addingGap = _addingNestedSetRight - _addingNestedSetLeft + 1;

        this.shiftNestedSetLeftCategories(_categoryHierarchyRecId, _addingNestedSetLeft, addingGap);
        this.shiftNestedSetRightCategories(_categoryHierarchyRecId, _addingNestedSetLeft, addingGap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeCategoryGapFromNestedSetModel</Name>
				<Source><![CDATA[
    private void removeCategoryGapFromNestedSetModel(
        EcoResCategoryHierarchyId       _categoryHierarchyRecId,
        EcoResCategoryNestedSetLeft     _deletingNestedSetLeft,
        EcoResCategoryNestedSetRight    _deletingNestedSetRight,
        EcoResInstrumentationLogger     _logger)
    {
        int64 deletingGap = _deletingNestedSetRight - _deletingNestedSetLeft + 1;

        if (!this.isNestedSetValid() || deletingGap < 1)
        {
            _logger.logNestedSetValues(this);
        }

        this.shiftNestedSetLeftCategories(_categoryHierarchyRecId, _deletingNestedSetLeft, -deletingGap);
        this.shiftNestedSetRightCategories(_categoryHierarchyRecId, _deletingNestedSetRight, -deletingGap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shiftNestedSetLeftCategories</Name>
				<Source><![CDATA[
    private void shiftNestedSetLeftCategories(
        EcoResCategoryHierarchyId       _categoryHierarchyRecId,
        EcoResCategoryNestedSetLeft     _greaterThanNestedSetLeft,
        int64                           _gap)
    {
        EcoResCategory leftCategory;

        leftCategory.skipDataMethods(true);
        leftCategory.skipEvents(true);
        leftCategory.skipDatabaseLog(true);

        // The NestedSetLeft field is not included in a unique index, so there is no risk of duplicates while updating the value.
        update_recordset leftCategory
            setting NestedSetLeft = leftCategory.NestedSetLeft + _gap
            where leftCategory.NestedSetLeft        >= _greaterThanNestedSetLeft &&
                  leftCategory.CategoryHierarchy    == _categoryHierarchyRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shiftNestedSetRightCategories</Name>
				<Source><![CDATA[
    private void shiftNestedSetRightCategories(
        EcoResCategoryHierarchyId       _categoryHierarchyRecId,
        EcoResCategoryNestedSetRight    _greaterThanNestedSetRight,
        int64                           _gap)
    {
        EcoResCategory rightCategory;

        rightCategory.skipDataMethods(true);
        rightCategory.skipEvents(true);
        rightCategory.skipDatabaseLog(true);

        // The NestedSetRight field is not included in a unique index, so there is no risk of duplicates while updating the value.
        update_recordset rightCategory
            setting NestedSetRight = rightCategory.NestedSetRight + _gap
            where rightCategory.NestedSetRight      >= _greaterThanNestedSetRight &&
                  rightCategory.CategoryHierarchy   == _categoryHierarchyRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    edit EcoResCategoryDescription description(boolean _set, EcoResCategoryDescription _categoryDescription)
    {
        EcoResCategoryDescription categoryDescription = _categoryDescription;
        EcoResCategoryTranslation ecoResCategoryTranslation;
        if (_set)
        {
            if (categoryDescription)
            {
                ttsbegin;
                ecoResCategoryTranslation = EcoResCategoryTranslation::find(this.RecId, LanguageTable::defaultLanguage(), true);
                ecoResCategoryTranslation.Description = categoryDescription;

                EcoResCategoryTranslation::createOrUpdateCategoryTranslation(this.RecId,
                                                         ecoResCategoryTranslation.FriendlyName,
                                                         categoryDescription,
                                                         ecoResCategoryTranslation.SearchText,
                                                         LanguageTable::defaultLanguage()
                                                         );
                ttscommit;
            }
        }
        else
        {
            categoryDescription = EcoResCategoryTranslation::find(this.RecId, LanguageTable::defaultLanguage()).Description;
        }

        return categoryDescription;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByNameInCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a category with the specified name exists under this category in the <c>EcoResCategory</c> table.
    /// </summary>
    /// <param name="_ecoResCategoryNameFilter">
    /// The category name filter expression for filtering the records.
    /// </param>
    /// <param name="_activeOnly">
    /// A Boolean value that indicates whether to retrieve active categories only or not. optional.
    /// </param>
    /// <param name="_leafOnly">
    /// A Boolean value that indicates whether to retrieve leaf categories only or not. optional.
    /// </param>
    /// <param name="_lookupParameters">
    /// A lookup parameters object, to filter categories based on buying legal entity and receiving operating unit. optional.
    /// </param>
    /// <returns>
    /// A count of the number of records matching the filter criteria.
    /// </returns>
    public int64 existByNameInCategory(EcoResCategoryName        _ecoResCategoryNameFilter   = "@SYS327992",
                                       boolean                          _activeOnly                 = false,
                                       boolean                          _leafOnly                   = false,
                                       EcoResCategoryLookupParameters   _lookupParameters           = null)
    {
        EcoResCategory                      ecoResCategory =  null;
        ProcCategoryTmpPolicyRule           procCategoryTmpPolicyRule;
        ProcCategoryAccessPolicyParameter   procCategoryAccessPolicyParameter;
        int64                               retVal = 0;

        if (this.RecId && EcoResCategory::exist(this.RecId))
        {
            if (_lookupParameters == null)
            {
                if (_leafOnly)
                {
                    select count(RecId) from ecoResCategory
                            where ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                                && ecoResCategory.NestedSetLeft  >= this.NestedSetLeft
                                && ecoResCategory.NestedSetRight <= this.NestedSetRight
                                && (ecoResCategory.NestedSetLeft == ecoResCategory.NestedSetRight - 1)
                                && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly)
                                && ecoResCategory.Name like _ecoResCategoryNameFilter;
                }
                else
                {
                    select count(RecId) from ecoResCategory
                            where ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                                && ecoResCategory.NestedSetLeft  >= this.NestedSetLeft
                                && ecoResCategory.NestedSetRight <= this.NestedSetRight
                                && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly)
                                && ecoResCategory.Name like _ecoResCategoryNameFilter;
                }
                retVal = ecoResCategory.RecId;
            }
            else
            {
                procCategoryTmpPolicyRule = EcoResCategory::getProcCategoryRules(SysPolicyRuleTypeEnum::CategoryAccessPolicyRule,
                                                                                _lookupParameters.parmBuyingLegalEntity(),
                                                                                _lookupParameters.parmReceivingOperatingUnit(),
                                                                                _lookupParameters.parmOrganizationOption());
                if (_leafOnly && procCategoryTmpPolicyRule)
                {
                    select count(RecId) from procCategoryTmpPolicyRule
                        join RecId from procCategoryAccessPolicyParameter
                            where procCategoryAccessPolicyParameter.ProcurementCategoryAccessPolicyRule == procCategoryTmpPolicyRule.PolicyRule
                        join RecId from ecoResCategory
                            where ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                                && ecoResCategory.NestedSetLeft  >= this.NestedSetLeft
                                && ecoResCategory.NestedSetRight <= this.NestedSetRight
                                && (ecoResCategory.NestedSetLeft == ecoResCategory.NestedSetRight - 1)
                                && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly)
                                && ecoResCategory.Name like _ecoResCategoryNameFilter
                                && ecoResCategory.RecId == procCategoryAccessPolicyParameter.ProcurementCategory;
                }
                else if (procCategoryTmpPolicyRule)
                {
                    select count(RecId) from procCategoryTmpPolicyRule
                        join RecId from procCategoryAccessPolicyParameter
                            where procCategoryAccessPolicyParameter.ProcurementCategoryAccessPolicyRule == procCategoryTmpPolicyRule.PolicyRule
                        join RecId from ecoResCategory
                            where ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                                && ecoResCategory.NestedSetLeft  >= this.NestedSetLeft
                                && ecoResCategory.NestedSetRight <= this.NestedSetRight
                                && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly)
                                && ecoResCategory.Name like _ecoResCategoryNameFilter
                                && ecoResCategory.RecId == procCategoryAccessPolicyParameter.ProcurementCategory;
                }
                retVal = procCategoryTmpPolicyRule.RecId;
            }
        }
        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAscendants</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves all the ascendant categories of this given category.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record buffer of the <c>EcoResCategory</c> table if ascendants were found; otherwise, an empty
    ///    buffer.
    /// </returns>
    public EcoResCategory getAscendants(boolean _forUpdate = false)
    {
        EcoResCategory  ecoResCategory =  null;

        if (this.RecId && EcoResCategory::exist(this.RecId) )
        {
            ecoResCategory.selectForUpdate(_forUpdate);

            select * from ecoResCategory
                order by ecoResCategory.NestedSetLeft
                    where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                            && ecoResCategory.NestedSetLeft  < this.NestedSetLeft
                            && ecoResCategory.NestedSetRight > this.NestedSetRight;
        }
        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAscendantsOrderedByCodeAndName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves all the ascendant categories of this given category ordered by code and name.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record buffer of the <c>EcoResCategory</c> table if ascendants were found; otherwise, an empty
    /// buffer.
    /// </returns>
    public EcoResCategory getAscendantsOrderedByCodeAndName(boolean _forUpdate = false)
    {
        EcoResCategory  ecoResCategory =  null;

        if (this.RecId && EcoResCategory::exist(this.RecId) )
        {
            ecoResCategory.selectForUpdate(_forUpdate);

            select * from ecoResCategory
                order by ecoResCategory.Level, ecoResCategory.Code, ecoResCategory.Name
                    where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                            && ecoResCategory.NestedSetLeft  < this.NestedSetLeft
                            && ecoResCategory.NestedSetRight > this.NestedSetRight;
        }
        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildCount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the children count for the specified record in the <c>ecoResCategory</c> table.
    /// </summary>
    /// <param name="_activeOnly">
    ///    A Boolean value that indicates whether to retrieve only active child categories.
    /// </param>
    /// <param name="_levelLimit">
    ///    An <c>EcoResCategoryLevel</c> value that indicates the maximum level of children categories to retrieve.
    /// </param>
    /// <returns>
    ///    The number of children for the specified category.
    /// </returns>
    /// <remarks>When the <c>EcoResCategoryTreePerformanceContext</c> is enabled, the logic will be skipped in order to improve performance.</remarks>
    public int64 getChildCount(boolean _activeOnly = false, EcoResCategoryLevel _levelLimit = 0)
    {
        int64 childCount      = 0;
        
        if (this.RecId && !EcoResCategoryTreePerformanceContext::isPerformanceContextEnabled() && EcoResCategory::exist(this.RecId))
        {
            EcoResCategory  ecoResCategory  =  null;

            if (_levelLimit > 0)
            {
                select count(RecId) from ecoResCategory
                    where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                            && ecoResCategory.ParentCategory  == this.RecId
                            && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly)
                            && ecoResCategory.Level <= _levelLimit;
            }
            else
            {
                select count(RecId) from ecoResCategory
                    where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                            && ecoResCategory.ParentCategory  == this.RecId
                            && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly);
            }
            
            childCount = ecoResCategory.RecId;
        }

        return childCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildren</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves all the child Categories of this given Category.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_activeOnly">
    /// A Boolean value that indicates whether to retrieve active categories only.
    /// </param>
    /// <param name="_levelLimit">
    ///    An <c>EcoResCategoryLevel</c> value that indicates the maximum level of children categories to retrieve.
    /// </param>
    /// <returns>
    /// A record buffer of the <c>EcoResCategory</c> table if children found; otherwise, an empty buffer.
    /// </returns>
    /// <remarks>When the <c>EcoResCategoryTreePerformanceContext</c> is enabled, the logic will be skipped in order to improve performance.</remarks>
    public EcoResCategory getChildren(boolean _forUpdate = false, boolean _activeOnly = false, EcoResCategoryLevel _levelLimit = 0)
    {
        EcoResCategory  ecoResCategory =  null;

        if (this.RecId && !EcoResCategoryTreePerformanceContext::isPerformanceContextEnabled() && EcoResCategory::exist(this.RecId) )
        {
            ecoResCategory.selectForUpdate(_forUpdate);
            
            if (_levelLimit > 0)
            {
                if (FeatureStateProvider::isFeatureEnabled(RetailEnableDisplayOrderForMerchandisingFeature::instance()))
                {
                    // Order by DisplayOrder and Name
                    select * from ecoResCategory
                    order by ecoResCategory.DisplayOrder, ecoResCategory.Name
                        where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                                && ecoResCategory.ParentCategory  == this.RecId
                                && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly)
                                && ecoResCategory.Level <= _levelLimit;
                }
                else
                {
                    // Order by Name only
                    select * from ecoResCategory
                    order by ecoResCategory.Name
                        where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                                && ecoResCategory.ParentCategory  == this.RecId
                                && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly)
                                && ecoResCategory.Level <= _levelLimit;
                }
            }
            else
            {
                if (FeatureStateProvider::isFeatureEnabled(RetailEnableDisplayOrderForMerchandisingFeature::instance()))
                {
                    // Order by DisplayOrder and Name
                    select * from ecoResCategory
                    order by ecoResCategory.DisplayOrder, ecoResCategory.Name
                        where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                                && ecoResCategory.ParentCategory  == this.RecId
                                && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly);
                }
                else
                {
                    // Order by Name Only
                    select * from ecoResCategory
                    order by ecoResCategory.Name
                        where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                                && ecoResCategory.ParentCategory  == this.RecId
                                && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly);
                }
            }
        }

        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildrenOrderedByCodeAndName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves all the child Categories of this given Category ordered by Code and Name.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_activeOnly">
    /// A Boolean value that indicates whether to retrieve active categories only.
    /// </param>
    /// <returns>
    /// A record buffer of the <c>EcoResCategory</c> table if children found; otherwise, an empty buffer.
    /// </returns>
    public EcoResCategory getChildrenOrderedByCodeAndName(boolean _forUpdate = false, boolean _activeOnly = false)
    {
        EcoResCategory  ecoResCategory =  null;

        if (this.RecId && EcoResCategory::exist(this.RecId) )
        {
            ecoResCategory.selectForUpdate(_forUpdate);
            select * from ecoResCategory
                order by ecoResCategory.Code, ecoResCategory.Name
                    where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                            && ecoResCategory.ParentCategory  == this.RecId
                            && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly);
        }
        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDescendants</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves all the descendant Categories of this given Category.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_activeOnly">
    /// A Boolean value that indicates whether to retrieve active categories only.
    /// </param>
    /// <returns>
    /// A record buffer of the <c>EcoResCategory</c> table if descendants found; otherwise, an empty buffer.
    /// </returns>
    public EcoResCategory getDescendants(boolean _forUpdate = false, boolean _activeOnly = false)
    {
        EcoResCategory  ecoResCategory =  null;

        if (this.RecId && EcoResCategory::exist(this.RecId) )
        {
            ecoResCategory.selectForUpdate(_forUpdate);

            select * from ecoResCategory
                order by ecoResCategory.NestedSetLeft
                    where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                            && ecoResCategory.NestedSetLeft  > this.NestedSetLeft
                            && ecoResCategory.NestedSetRight < this.NestedSetRight
                            && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly);
        }

        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLeafNodes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves all the leaf Categories under this given Category.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_activeOnly">
    /// A Boolean value that indicates whether to retrieve active categories only.
    /// </param>
    /// <returns>
    /// A record buffer of the <c>EcoResCategory</c> table if leaf nodes are found; otherwise, an empty buffer.
    /// </returns>
    public EcoResCategory getLeafNodes(boolean _forUpdate = false, boolean _activeOnly = false)
    {
        EcoResCategory  ecoResCategory =  null;

        if (this.RecId && EcoResCategory::exist(this.RecId) )
        {
            ecoResCategory.selectForUpdate(_forUpdate);

            select * from ecoResCategory
                order by ecoResCategory.NestedSetLeft
                    where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                            && ecoResCategory.NestedSetLeft  >= this.NestedSetLeft
                            && ecoResCategory.NestedSetRight <= this.NestedSetRight
                            && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly)
                            && (ecoResCategory.NestedSetLeft == ecoResCategory.NestedSetRight -1);
        }

        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLevel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the level of this category in the category hierarchy.
    /// </summary>
    /// <returns>
    ///    The level of a category in the category hierarchy, counting the root as the first level.
    /// </returns>
    public EcoResCategoryLevel getLevel()
    {
        EcoResCategoryLevel ecoResCategoryLevel = 0;

        if (this.RecId && EcoResCategory::exist(this.RecId))
        {
            ecoResCategoryLevel = EcoResCategory::find(this.RecId).Level;
        }

        return ecoResCategoryLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLowestLevel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the lowest level node of this category subtree.
    /// </summary>
    /// <returns>
    ///    The lowest level of a category in the category hierarchy, counting the root as the first level.
    /// </returns>
    public EcoResCategoryLevel getLowestLevel()
    {
        EcoResCategory      ecoResCategory;
        EcoResCategoryLevel ret = 0;

        if (this.RecId && EcoResCategory::exist(this.RecId) )
        {
            ret = (select maxof(Level) from ecoResCategory
                        where ecoResCategory.CategoryHierarchy == this.CategoryHierarchy  &&
                                  ecoResCategory.NestedSetLeft >= this.NestedSetLeft &&
                                  ecoResCategory.NestedSetRight <= this.NestedSetRight &&
                                  ecoResCategory.NestedSetLeft == ecoResCategory.NestedSetRight - 1).Level;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the Parent Category for this Category.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// The Parent Category record from the <c>EcoResCategory</c> table if found; otherwise, an empty buffer.
    /// </returns>
    public EcoResCategory getParent(boolean _forUpdate = false)
    {
        EcoResCategory  ecoResCategory =  null;

        if (this.RecId && EcoResCategory::exist(this.RecId) && this.ParentCategory)
        {
            ecoResCategory = EcoResCategory::find(this.ParentCategory, _forUpdate);
        }
        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromParent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a child category record of the <c>EcoResCategory</c> table, based on the specified
    ///    parent category.
    /// </summary>
    /// <param name="_ecoResParentCategory">
    ///    The parent category record from the <c>EcoResCategory</c> table.
    /// </param>
    /// <remarks>
    ///    This method initializes the <c>Hierarchy</c>, <c>Parent</c>, and <c>Active</c> values, depending on
    ///    the parent specified.
    /// </remarks>
    public void initFromParent(EcoResCategory _ecoResParentCategory)
    {
        this.CategoryHierarchy  = _ecoResParentCategory.CategoryHierarchy;
        this.ParentCategory     = _ecoResParentCategory.RecId;
        this.IsActive           = _ecoResParentCategory.IsActive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a record of the <c>EcoResCategory</c> table.
    /// </summary>
    public void initValue()
    {
        super();
        this.IsActive       = NoYes::Yes;
        this.ChangeStatus   = EcoResCategoryChangeStatus::NotApplicable;

        // Procure Category's root node must have InheritAttributes==No
        if ( ! this.ParentCategory )
        {
            this.IsCategoryAttributesInherited = NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLeaf</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified category is a leaf node of the Hierarchy.
    /// </summary>
    /// <returns>
    /// true if the specified Category is a leaf; otherwise, false.
    /// </returns>
    /// <remarks>When the <c>EcoResCategoryTreePerformanceContext</c> is enabled, this method will skip checking for existence of this category for performance reasons.</remarks>
    public boolean isLeaf()
    {
        return this.RecId
               && (EcoResCategoryTreePerformanceContext::isPerformanceContextEnabled() || EcoResCategory::exist(this.RecId))
               && (this.NestedSetLeft == this.NestedSetRight - 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetailCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified category belongs to retail category hierarchies
    /// </summary>
    /// <param name="_category"> Category record Id </param>
    /// <returns>
    /// true if the specified category belongs to a retail category hierarchy; otherwise, false.
    /// </returns>
    public static boolean isRetailCategory(EcoResCategoryId _category)
    {
        EcoResCategory ecoResCategory;
        EcoResCategoryHierarchyRole ecoResCategoryHierarchyRole;

        select firstonly RecId from ecoResCategoryHierarchyRole
            exists join ecoResCategory 
                where ecoResCategory.CategoryHierarchy == ecoResCategoryHierarchyRole.CategoryHierarchy
                && ecoResCategory.recId == _category
                && ecoResCategoryHierarchyRole.NamedCategoryHierarchyRole == EcoResCategoryNamedHierarchyRole::Retail
                || ecoResCategoryHierarchyRole.NamedCategoryHierarchyRole == EcoResCategoryNamedHierarchyRole::RetailSpecialGroup
                || ecoResCategoryHierarchyRole.NamedCategoryHierarchyRole == EcoResCategoryNamedHierarchyRole::RetailChannelNavigation;

        return ecoResCategoryHierarchyRole.RecId? true: false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRoot</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified category is the root or very first category of the Hierarchy.
    /// </summary>
    /// <returns>
    /// true if the specified Category is the root; otherwise, false.
    /// </returns>
    public boolean isRoot()
    {
        #EcoResCategoryDefaults

        return (this.RecId && EcoResCategory::exist(this.RecId) && this.NestedSetLeft == #ECORESROOTNESTEDLEFTVALUE);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCategoryStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the Category Status to Active/Inactive.
    /// </summary>
    /// <param name="_status">
    /// A Boolean value that indicates whether to Activate or Deactivate this Category.
    /// </param>
    /// <param name="_onlyThisCategory">
    /// A Boolean value that indicates where to activate only this category or its sub categories also.
    /// </param>
    /// <remarks>
    /// When a Category is Deactivated, all its descendant Categories are also Deactivated.
    /// When a Category is Activated, in addition to Activating all its descendant Categories,
    ///  all its Ascendant Categories are also Activated.
    /// </remarks>
    public void setCategoryStatus(boolean _status , boolean _onlyThisCategory = false)
    {
        #EcoResCategoryDefaults
        EcoResCategory                  ecoResCategory;
        EcoResCategory                  ecoResRootCategory;
        CatProcureCatalogTable          tblCatalog;
        CatDisplayCategoryTable         tblDCategory;
        CatDisplayCategorySharedInfo    tblSharedData;
        NoYes                           isHidden = (_status ? NoYes::No : NoYes::Yes);

        if (this.RecId && EcoResCategory::exist(this.RecId))
        {
            ttsbegin;
            select pessimisticlock firstonly RecId from ecoResRootCategory
                    where ecoResRootCategory.CategoryHierarchy    == this.CategoryHierarchy
                        && ecoResRootCategory.NestedSetLeft   == #ECORESROOTNESTEDLEFTVALUE;

            ecoResCategory = EcoResCategory::find(this.RecId);
            if (!ecoResCategory.RecId)
            {
                // node specified is not valid
                throw Global::error("@SYS134259");
            }
            else if (   (this.NestedSetLeft != ecoResCategory.NestedSetLeft)   ||
                            (this.NestedSetRight != ecoResCategory.NestedSetRight) ||
                            (this.CategoryHierarchy != ecoResCategory.CategoryHierarchy) )
            {
                //make sure there are no modifications meanwhile
                throw Global::error("@SYS134260");
            }

            this.IsActive = _status;
            this.update();

            // update the descendents
            if ( !_onlyThisCategory )
            {
                update_recordset ecoResCategory
                    setting IsActive = _status
                        where ecoResCategory.NestedSetLeft  > this.NestedSetLeft
                            && ecoResCategory.NestedSetRight < this.NestedSetRight
                            && ecoResCategory.CategoryHierarchy == this.CategoryHierarchy;
            }

            // update all Procurement Catalogs in similar way
            // we do this by simply updating the corresponding CatDisplayCategoryTable *only*
            //  - CatDisplayCategoryTable.setIsHidden would cascade to the descendants/ancestors as needed
            // calling update_recordset on the whole CatDisplayCategoryTable subtree would cause bug AX6:64282).
            // we cannot use update_recordset since we must pass in the _unhideSubTree argument.
            while select forupdate * from tblDCategory
                    where tblDCategory.IsHidden != isHidden
                    join RecId from tblSharedData
                        where tblDCategory.SharedData == tblSharedData.RecId
                            && tblSharedData.Category == this.RecId
                    join RecId from tblCatalog
                        where tblDCategory.Catalog == tblCatalog.RecId
                            && tblCatalog.ProcurementHierarchy == this.CategoryHierarchy
            {
                tblDCategory.setIsHidden(isHidden, (!_onlyThisCategory));
            }

            if (_status)
            {
                // update inactive ascendants
                update_recordset ecoResCategory
                        setting IsActive = _status
                            where ecoResCategory.NestedSetLeft  < this.NestedSetLeft
                                && ecoResCategory.NestedSetRight > this.NestedSetRight
                                && ecoResCategory.IsActive == false
                                && ecoResCategory.CategoryHierarchy == this.CategoryHierarchy;
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRoot</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a new category root node to a hierarchy.
    /// </summary>
    /// <returns>
    ///    true if the specified root category was added; otherwise, false.
    /// </returns>
    public boolean setRoot()
    {
        EcoResCategory              ecoResCategory          = null;
        EcoResCategoryHierarchy     ecoResCategoryHierarchy = null;
        boolean                     ret                     = false;
        #EcoResCategoryDefaults

        try
        {
            ttsbegin;

            ecoResCategoryHierarchy = EcoResCategoryHierarchy::find(this.CategoryHierarchy);

            if (!ecoResCategoryHierarchy || !ecoResCategoryHierarchy.RecId)
            {
                // hierarchy specified is not valid
                throw Global::error("@SYS301577");
            }

            ecoResCategory = EcoResCategory::getRoot(ecoResCategoryHierarchy.RecId, true);
            if (ecoResCategory.RecId && ecoResCategory.RecId != this.RecId)
            {
                // a different root node already exists
                throw Global::error("@SYS301578");
            }

            if (this.ParentCategory)
            {
                // parent cannot be specified for root node
                throw Global::error("@SYS301579");
            }

            this.NestedSetLeft    = #ECORESROOTNESTEDLEFTVALUE;
            this.Level            = 1;

            if (!this.RecId)
            {
                this.NestedSetRight   = #ECORESROOTNESTEDLEFTVALUE + 1;

                if (this.validateWrite())
                {
                    this.insert();
                    this.insertProcCategoryModifier();
                    ret = true;
                }
            }
            else
            {
                if (this.validateWrite())
                {
                    this.update();
                    this.insertProcCategoryModifier();
                    ret = true;
                }
            }

            ttscommit;
        }
        catch
        {
            ret = false;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides the update method to check whether the <c>ParentCategory</c> or <c>IsVendorsInherited</c>
    /// fields have changed and performs the necessary insert or delete actions.
    /// </summary>
    public void update()
    {
        EcoResInstrumentationLogger logger = this.getLogger();
        using (var a = logger.category().update())
        {
            EcoResCategory          this_Orig = this.orig();
            ProcCategoryModifier    procCategory = ProcCategoryModifier::find(this.RecId);

            if (!(this is PCClass) && (!this.isNestedSetValid() || this_Orig.NestedSetLeft != this.NestedSetLeft || this_Orig.NestedSetRight != this.NestedSetRight))
            {
                logger.logNestedSetValues(this);
            }

            ttsbegin;
            // If ParentCategory field is changed while Is-Inherited is true
            // We first break the inheritance, and then add inheritance after reparenting
            if ((this_Orig.ParentCategory != this.ParentCategory))
            {
                if (procCategory.IsCriterionGroupInherited)
                {
                    VendReviewCategoryCriterionLookup::breakInheritanceAtCategory(this);
                }

                if (procCategory.IsVendorsInherited)
                {
                    VendProcurementCategoryStatus::breakInheritanceAtCategory(this);
                }
            }

            // do this *before* super():
            this.updateProcurementCatalogs();

            super();

            // If ParentCategory field is changed while Is-Inherited is true
            // We first break the inheritance, and then add inheritance after reparenting
            if ((this_Orig.ParentCategory != this.ParentCategory))
            {
                if (procCategory.IsCriterionGroupInherited)
                {
                    VendReviewCategoryCriterionLookup::addInheritanceAtCategory(this);
                }

                if (procCategory.IsVendorsInherited)
                {
                    VendProcurementCategoryStatus::addInheritanceAtCategory(this);
                }
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProcurementCatalogs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the name of the corresponding display category node in all of the procurement catalogs if
    /// the name matches the old name of the procurement category hierarchy node.
    /// </summary>
    private void updateProcurementCatalogs()
    {
        EcoResCategoryName              oldERCName = this.orig().Name;
        EcoResCategoryName              newERCName = this.Name;
        CatProcureCatalogTable          catalog;
        CatDisplayCategoryTable         displayCategory;
        CatDisplayCategorySharedInfo    sharedData;

        ttsbegin;
        // if and only if Name has changed, sync the change to all corresponding category nodes in Catalog's
        if (oldERCName != newERCName)
        {
            // update all Procurement Catalogs by adding a corresponding node to each
            while select forupdate * from displayCategory
                // don't touch the DisplayCategory that should *not* be "in sync" with EcoResCategory.Name
                where displayCategory.IsDescriptiveDataSynchronized == NoYes::Yes
                join RecId from catalog
                    where  catalog.ProcurementHierarchy == this.CategoryHierarchy
                        && catalog.RecId == displayCategory.Catalog
                join * from sharedData
                where  sharedData.RecId == displayCategory.SharedData
                    && sharedData.Category == this.RecId
            {
                displayCategory.setDisplayCategoryName(newERCName);
                displayCategory.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean                     ret;
        ProcCategoryCommodityCode   procCategoryCommodityCode;

        ret = super();

        if (ret)
        {
            //check if this category has records in the procCategoryCommodityCode
            select firstonly RecId from procCategoryCommodityCode
                where procCategoryCommodityCode.ProcurementCategory == this.RecId;

            ret = (procCategoryCommodityCode.RecId == 0);

            if (ret)
            {
                ret = this.validateDeleteSubTree();
            }

            if (!ret)
            {
                checkFailed(strFmt("@SYS128564", tableStr(EcoResCategory), tableStr(ProcCategoryCommodityCode)));
            }
        }
        else
        {
            ProcCategoryAccessPolicyParameter procCategoryAccessPolicyParameter;

            //check if this category has records in the ProcCategoryAccessPolicyParameter
            select firstonly RecId from procCategoryAccessPolicyParameter
                where procCategoryAccessPolicyParameter.ProcurementCategory == this.RecId;

            if (procCategoryAccessPolicyParameter.RecId)
            {
                warning("@SCM:ProcurementCategoryDeleteWarning");
            }
        }

        if (ret && EcoResCategory::isRetailCategory(this.RecId))
        {
            ret = this.confirmRetailCategoryDeletion(this.CategoryHierarchy);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDeleteSubTree</Name>
				<Source><![CDATA[
    private boolean validateDeleteSubTree()
    {
        EcoResCategory      ecoResCategoryDescendents;

        ecoResCategoryDescendents = this.getDescendants();
        while (ecoResCategoryDescendents)
        {
            if (!ecoResCategoryDescendents.validateDelete())
            {
                return false;
            }

            next ecoResCategoryDescendents;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a value for a field.
    /// </summary>
    /// <param name="_fieldIdToCheck">
    /// The field ID corresponding with the field being validated.
    /// </param>
    /// <returns>
    /// true if valid; otherwise, false.
    /// </returns>
    public boolean validateField(fieldId _fieldIdToCheck)
    {
        boolean ret;

        ret = super(_fieldIdToCheck);

        if (ret && _fieldIdToCheck == fieldNum(EcoResCategory, DefaultProjectGlobalCategory))
        {
            ret = this.checkDefaultProjectGlobalCategory();
        }

        switch(_fieldIdToCheck)
        {
            case fieldNum(EcoResCategory, HSNCodeTable_IN) :
            case fieldNum(EcoResCategory, ServiceAccountingCodeTable_IN) :
                if (this.HSNCodeTable_IN && this.ServiceAccountingCodeTable_IN)
                {
                    ret = ret && checkFailed("@TaxGST:HSNAndSACCodeCheck");
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        EcoResCategory          ecoResCategory;
        EcoResCategory          parentCategory;
        ProcCategoryModifier    procCategoryModifier;
        #EcoResCategoryDefaults

        this.Name = Global::strLRTrim(this.Name);
        this.Code = Global::strLRTrim(this.Code);

        boolean ret = super();
        if (ret && !(this is PCClass))
        {
            //duplicate code in the same hierarchy
            if (this.Code && (!this.RecId || (this.orig().Code != this.Code)))
            {
                select firstonly RecId from ecoResCategory
                    where ecoResCategory.Code == this.Code
                        && ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                        && ecoResCategory.RecId != this.RecId;

                if (ecoResCategory.RecId != 0)
                {
                    return checkFailed(strFmt("@SYS328648",
                                                tablePName(EcoResCategory),
                                                tableStr(EcoResCategory),
                                                fieldPName(EcoResCategory, Code),
                                                fieldStr(EcoResCategory, Code),
                                                this.Code));
                }
            }

            // parent is getting updated for an existing node.
            if (this.RecId && ( (this.orig().ParentCategory != this.ParentCategory) || (this.RecId == this.ParentCategory) )  )
            {
                return checkFailed("@SYS134255");
            }

            // Hierarchy is getting updated for an existing node.
            if (this.RecId && (this.orig().CategoryHierarchy != this.CategoryHierarchy))
            {
                return checkFailed("@SYS134256");
            }

            if (this.NestedSetLeft != #ECORESROOTNESTEDLEFTVALUE) //root doesn't have a parent
            {
                parentCategory = EcoResCategory::find(this.ParentCategory);

                if ( !parentCategory || !parentCategory.RecId)
                {
                    // parent specified is not valid or someone deleted it
                    return checkFailed("@SYS134257");
                }

                //parent and child must be from the same hierarchy
                if (parentCategory.CategoryHierarchy != this.CategoryHierarchy)
                {
                    return checkFailed("@SYS134258");
                }

                //if this is an active node, all its ancestors (except the root) should also be active.
                if (this.IsActive)
                {
                    select count(RecId) from ecoResCategory
                            where   ecoResCategory.CategoryHierarchy == this.CategoryHierarchy
                                    && ecoResCategory.NestedSetLeft  < this.NestedSetLeft
                                    && ecoResCategory.NestedSetRight > this.NestedSetRight
                                    && ecoResCategory.NestedSetLeft != #ECORESROOTNESTEDLEFTVALUE
                                    && ecoResCategory.IsActive == false;

                    if (ecoResCategory.RecId != 0)
                    {
                        return checkFailed("@SYS138249");
                    }
                }
            }

            // Procure Category's root node must have InheritAttributes==No
            if ( ! this.ParentCategory)
            {
                procCategoryModifier = ProcCategoryModifier::find(this.ParentCategory);
                if (NoYes::No != procCategoryModifier.IsProductAttributesInherited)
                {
                    return checkFailed(strFmt("@SYS135669", fieldId2name(tableNum(ProcCategoryModifier), fieldNum(ProcCategoryModifier, IsProductAttributesInherited)) ) );
                }
            }

            ret = this.checkDefaultProjectGlobalCategory();
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>codeAndName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates string with commodity code and name.
    /// </summary>
    /// <returns>
    /// Commodity code and name.
    /// </returns>
    public str codeAndName()
    {
        str ret = this.Name;

        if (this.Code)
        {
            ret = strFmt('[%1] %2', this.Code, ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCategoryRole</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified category is part of a hierarchy with the specified role.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    ///    The category ID in the <c>EcoResCategory</c> table.
    /// </param>
    /// <param name="_ecoResNamedCategoryHierarchyRole">
    ///    The category role in the <c>EcoResCategoryHierarchyRole</c> table.
    /// </param>
    /// <returns>
    ///    true if the specified category is part of a hierarchy with the specified role; otherwise, false and
    ///    it displays an error message.
    /// </returns>
    static boolean checkCategoryRole(EcoResCategoryId _ecoResCategoryId, EcoResCategoryNamedHierarchyRole _ecoResNamedCategoryHierarchyRole)
    {
        boolean ret = true;

        if (!EcoResCategoryHierarchyRole::existRoleHierarchyPair(
                                                _ecoResNamedCategoryHierarchyRole,
                                                EcoResCategory::find(_ecoResCategoryId).CategoryHierarchy))
        {
            ret = checkFailed(strFmt("@SYS129553", _ecoResNamedCategoryHierarchyRole));
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified category exists in the <c>EcoResCategory</c> table.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    ///    The category ID in the <c>EcoResCategory</c> table to check for existance.
    /// </param>
    /// <returns>
    ///    true if the specified record exists; otherwise, false and it displays an error message.
    /// </returns>
    public static boolean checkExist(EcoResCategoryId _ecoResCategoryId)
    {
        if (_ecoResCategoryId && EcoResCategory::exist(_ecoResCategoryId))
        {
            return true;
        }
        return checkFailed(strFmt(EcoResCategory::txtNotExist(), tablePName(EcoResCategory),_ecoResCategoryId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createHierarchyRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates the root category node for a given category hierarchy.
    /// </summary>
    /// <param name="_ecoResCategoryHierarchyId">
    /// The category hierarchy ID for which to retrieve in the <c>EcoResCategoryHierarchy</c> table.
    /// </param>
    /// <param name="_ecoResCategoryName">
    /// The root category name to be created in the specified category hierarchy.
    /// </param>
    /// <returns>
    /// The root category record of the <c>EcoResCategory</c> table if successfully created; otherwise, an
    /// empty buffer.
    /// </returns>
    public static EcoResCategory createHierarchyRoot(EcoResCategoryHierarchyId _ecoResCategoryHierarchyId, EcoResCategoryName _ecoResCategoryName = "@SYS136676")
    {
        EcoResCategory ecoResCategory = null;

        ttsbegin;

        if (!ecoResCategory || !ecoResCategory.RecId)
        {
            ecoResCategory.initValue();
            ecoResCategory.CategoryHierarchy= _ecoResCategoryHierarchyId;
        }

        ecoResCategory.Name = _ecoResCategoryName;

        ecoResCategory.setRoot();

        ttscommit;

        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified category is located in the <c>EcoResCategory</c> table.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    /// The category ID in the <c>EcoResCategory</c> table to check for existence.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean exist(EcoResCategoryId _ecoResCategoryId)
    {
        return _ecoResCategoryId &&
            (select RecId from ecoResCategory
                where ecoResCategory.RecId == _ecoResCategoryId
            ).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified category name is located in the specified hierarchy in the
    /// <c>EcoResCategory</c> table.
    /// </summary>
    /// <param name="_ecoResCategoryName">
    /// The category name in the <c>EcoResCategory</c> table to check for existence.
    /// </param>
    /// <param name="_ecoResCategoryHierarchyId">
    /// The category hierarchy ID in the <c>EcoResCategoryHierarchy</c> table.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean existByName(EcoResCategoryName _ecoResCategoryName, EcoResCategoryHierarchyId _ecoResCategoryHierarchyId)
    {
        if (_ecoResCategoryName)
        {
            return (select RecId from ecoResCategory
                        where ecoResCategory.Name == _ecoResCategoryName
                                && ecoResCategory.CategoryHierarchy == _ecoResCategoryHierarchyId).RecId != 0;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified category in the <c>EcoResCategory</c> table.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    ///    The category ID in the <c>EcoResCategory</c> table to retrieve.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record of the <c>EcoResCategory</c> table if found; otherwise, an empty buffer.
    /// </returns>
    public static EcoResCategory find(EcoResCategoryId _ecoResCategoryId, boolean _forUpdate = false)
    {
        EcoResCategory    ecoResCategory = null;

        if (_ecoResCategoryId)
        {
            ecoResCategory.selectForUpdate(_forUpdate);
            select firstonly * from ecoResCategory where ecoResCategory.RecId == _ecoResCategoryId;
        }

        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified category in the <c>EcoResCategory</c> table.
    /// </summary>
    /// <param name="_ecoResCategoryName">
    /// The category name for which to retrieve in the <c>EcoResCategory</c> table.
    /// </param>
    /// <param name="_ecoResCategoryHierarchyId">
    /// The category hierarchy ID in the <c>EcoResCategoryHierarchy</c> table.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>EcoResCategory</c> table if found; otherwise, an empty record.
    /// </returns>
    public static EcoResCategory findByName(EcoResCategoryName _ecoResCategoryName, EcoResCategoryHierarchyId _ecoResCategoryHierarchyId, boolean _forUpdate = false)
    {
        EcoResCategory    ecoResCategory = null;

        if (_ecoResCategoryName)
        {
            ecoResCategory.selectForUpdate(_forUpdate);
            select firstonly * from ecoResCategory
                where ecoResCategory.Name == _ecoResCategoryName
                    && ecoResCategory.CategoryHierarchy == _ecoResCategoryHierarchyId;
        }

        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCategoryByNameAndHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified category in the <c>EcoResCategory</c> table.
    /// </summary>
    /// <param name="_ecoResCategoryName">
    /// The category name for which to retrieve in the <c>EcoResCategory</c> table.
    /// </param>
    /// <param name="_ecoResCategoryHierarchyName">
    /// The category hierarchy name.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>EcoResCategory</c> table if found; otherwise, an empty record.
    /// </returns>
    public static EcoResCategory findCategoryByNameAndHierarchy(EcoResCategoryName _ecoResCategoryName, EcoResCategoryHierarchyName _ecoResCategoryHierarchyName, boolean _forUpdate = false)
    {
        EcoResCategory ecoResCategory;
        EcoResCategoryHierarchy categoryHierarchy;

        if (_ecoResCategoryName && _ecoResCategoryHierarchyName)
        {
            select firstonly * from ecoResCategory
                exists join categoryHierarchy
                where categoryHierarchy.Name      == _ecoResCategoryHierarchyName
                    && ecoResCategory.CategoryHierarchy == categoryHierarchy.RecId
                    && ecoResCategory.Name              == _ecoResCategoryName;
        }

        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNonExistByString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first String value so that in the table that is specified by the value of the <paramref
    /// name="_tableId" /> table, there is no existing record with the <paramref name="_matchingFieldId" />
    /// field's value matching the specified value of the <paramref name="_matchingFieldValue" />
    /// parameter, and the <paramref name="_strFieldId" /> field's value that matches the String value
    /// found.
    /// </summary>
    /// <param name="_tableId">
    /// The ID of table to search.
    /// </param>
    /// <param name="_matchingFieldId">
    /// The ID of field in the table to match.
    /// </param>
    /// <param name="_matchingFieldValue">
    /// The value with which to match the value of the <paramref name="_matchingFieldId" /> field.
    /// </param>
    /// <param name="_strFieldId">
    /// The ID of the String field in the table to match.
    /// </param>
    /// <param name="_strFieldType">
    /// The ID of the extended data type of a String field.
    /// </param>
    /// <param name="_strValueExactMatch">
    /// The exact value with which to match the <paramref name="_strFieldId" /> String field.
    /// </param>
    /// <param name="_strValueFormatter">
    /// The formatter for the value to match the <paramref name="_strFieldId" /> String field.
    /// </param>
    /// <param name="_excludedRecId">
    /// The record ID to exclude in search for non-exist name.
    /// </param>
    /// <returns>
    /// The first string value that does not match the string field of any existing record in the table.
    /// </returns>
    /// <remarks>
    ///  For example, if
    ///  <list type="bullet">
    ///   <item>
    ///    <description>
    ///    the table is <c>EcoResCategory</c> ,
    ///    </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_matchingFieldId" /> is CategoryHierarchy, </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_matchingFieldValue" /> is 12345678, </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_strFieldId" /> is Name, </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_strValueExactMatch" /> is "New Node", </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_strValueFormatter" /> is "New Node # %1", </description>
    ///   </item>
    ///   <item>
    ///   <description>the <paramref name="_excludedRecId" /> is 87654321, </description>
    ///   </item>
    ///  </list>
    ///   then,
    ///  <list type="number">
    ///   <item>
    ///    <description>
    ///    If the <c>EcoResCategory</c> table, excluding 87654321, has no record with
    ///    CategoryHierarchy=12345678 and Name="New Node", the return value would be "New Node".
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    If the <c>EcoResCategory</c> table, excluding 87654321, has no record with
    ///    CategoryHierarchy=12345678 and Name="New Node # 1", the return value would be "New Node # 1".
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    If the <c>EcoResCategory</c> table, excluding 87654321, has no record with
    ///    CategoryHierarchy=12345678 and Name="New Node # 2", -- return value would be "New Node # 2".
    ///    </description>
    ///   </item>
    ///  </list>
    ///   An exception is thrown if we cannot find one after exhausting all possibilities.The formatter
    ///  should take one argument, which will be replaced by an integer starting from 1 and incremented by 1
    ///  when searching for non-match.
    /// </remarks>
    public static str findNonExistByString(
        tableId         _tableId,
        fieldId         _matchingFieldId,
        anytype         _matchingFieldValue,
        fieldId         _strFieldId,
        extendedTypeId  _strFieldType,
        str             _strValueExactMatch,
        str             _strValueFormatter,
        recId           _excludedRecId = 0
    )
    {
        DictTable dictTable = new DictTable(_tableId);
        Common  common      = dictTable.makeRecord();
        int idx = 0;
        anytype result, firstStringValue;
        int     edtMaxLen = new DictType(_strFieldType).stringLen();

        result = _strValueExactMatch;

        do
        {
            select firstonly crossCompany common
            where  common.(_strFieldId)      == result
                && common.(_matchingFieldId) == _matchingFieldValue
                && common.RecId              != _excludedRecId
            ;
            if (!common.RecId)
            {
                break;
            }

            // we must detect infinite loop:
            if (1 == idx)
            {
                firstStringValue = common.(_strFieldId);
            }
            else if ((idx > 0) && (firstStringValue == common.(_strFieldId)))
            {
                throw error(
                    strFmt("@SYS330468",
                        _tableId, tableId2name(_tableId),
                        _matchingFieldId, fieldId2name(_tableId, _matchingFieldId), _matchingFieldValue,
                        _strFieldId, fieldId2name(_tableId, _strFieldId),
                        idx, firstStringValue
                    )
                );
            }

            idx++;
            result = strFmt(_strValueFormatter, idx);
            // trim as necessary
            if (strLen(result) > edtMaxLen)
            {
                result = subStr(result, 1, edtMaxLen);
            }
        }
        while (true);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNonExistNameInHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a name that does not match any existing record in the <c>EcoResCategory</c> table of the
    /// given hierarchy.
    /// </summary>
    /// <param name="_hierarchyRecId">
    /// The category hierarchy record ID.
    /// </param>
    /// <returns>
    /// A string that would not conflict with any existing name column of the <c>EcoResCategory</c> table
    /// of the record in the given hierarchy.
    /// </returns>
    /// <remarks>
    /// An exception is thrown if we cannot find one after exhausting all possibilities.
    /// </remarks>
    public static EcoResCategoryName findNonExistNameInHierarchy(EcoResCategoryHierarchyId _hierarchyRecId)
    {
        return EcoResCategory::findNonExistByString(
            tableNum(EcoResCategory),
            fieldNum(EcoResCategory, CategoryHierarchy),
            _hierarchyRecId,
            fieldNum(EcoResCategory, Name),
            extendedTypeNum(EcoResCategoryName),
            "@SYS134268", "@SYS136676"
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllNodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves all the categories of the specified category hierarchy.
    /// </summary>
    /// <param name="_ecoResCategoryHierarchyId">
    /// The category hierarchy ID for which to retrieve in the <c>EcoResCategoryHierarchy</c> table.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record buffer of the <c>EcoResCategory</c> table if found; otherwise, an empty buffer.
    /// </returns>
    public static EcoResCategory getAllNodes(EcoResCategoryHierarchyId _ecoResCategoryHierarchyId, boolean _forUpdate = false)
    {
        EcoResCategory  ecoResCategory =  null;
        #EcoResCategoryDefaults

        ecoResCategory.selectForUpdate(_forUpdate);
        select * from ecoResCategory
            order by ecoResCategory.NestedSetLeft
                where   ecoResCategory.CategoryHierarchy == _ecoResCategoryHierarchyId
                    &&  ecoResCategory.NestedSetLeft != #ECORESROOTNESTEDLEFTVALUE;

        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNearestAncestorWithNoInheritance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Queries the database to find the nearest ancestor, by tree level, that does not have the
    /// <c>IsCategoryAttributesInherited</c> field value set to yes.
    /// </summary>
    /// <param name="_category">
    /// An existing record of the <c>EcoResCategory</c> table for which to find the nearest
    /// stop-inheritance ancestor.
    /// </param>
    /// <returns>
    /// A record in the <c>EcoResCategory</c> table.
    /// </returns>
    /// <remarks>
    /// The record that is specified by the <paramref name="_cateogry" /> parameter must already be located
    /// in the database, cannot be the root node, and must have the <c>InheritCategoryAttributes</c>
    /// property set to the <c>NoYes::No</c> enumeration value. The query uses the nested set values and
    /// tree level information to find the nearest stop-inheritance ancestor. A record is guaranteed to be
    /// found.
    /// </remarks>
    public static EcoResCategory getNearestAncestorWithNoInheritance(EcoResCategory _category)
    {
        // find the nearest (proper) ancestor that
        //     (1) has IsCategoryAttributesInherited==NO
        //     (2) is the nearest - "proper ancestor" b/c this code won't execute for root which must have IsCategoryAttributesInherited==No.

        EcoResCategory  sdAncestor;
        EcoResCategory  rtv;

        if (_category.RecId == 0 || !EcoResCategory::checkExist(_category.RecId))
        {
            throw Global::error("@SYS329471");
        }

        if (_category.ParentCategory == 0) // must be non-root
        {
            throw Global::error(strFmt("@SYS329472", _category.Name));
        }

        if (NoYes::No ==_category.IsCategoryAttributesInherited) // must have _inheritanceFieldId==Yes
        {
            throw warning(strFmt("@SYS329473", fieldId2name(tableNum(EcoResCategory), fieldNum(EcoResCategory, IsCategoryAttributesInherited))));
        }

        select maxof(Level)
            from sdAncestor
            group by sdAncestor.CategoryHierarchy
            where sdAncestor.CategoryHierarchy == _category.CategoryHierarchy
                && sdAncestor.NestedSetLeft < _category.NestedSetLeft
                && sdAncestor.NestedSetLeft < _category.NestedSetRight
                && _category.NestedSetRight < sdAncestor.NestedSetRight
                && sdAncestor.IsCategoryAttributesInherited  == NoYes::No;

        // If we didn't find one, then it's because the root node does not have IsCategoryAttributesInherited==Yes, a violation of our assumption.
        // this check is OK since EcoResCategory root has Level=1
        if ( !sdAncestor.Level)
        {
            throw warning(strFmt("@SYS135669", fieldId2name(tableNum(EcoResCategory), fieldNum(EcoResCategory, IsCategoryAttributesInherited))));
        }
        else
        {
            // find the ancestor at the specific Level we found:
            select firstonly * from rtv
                where rtv.CategoryHierarchy == _category.CategoryHierarchy
                    && rtv.NestedSetLeft < _category.NestedSetLeft
                    && rtv.NestedSetLeft < _category.NestedSetRight
                    && _category.NestedSetRight < rtv.NestedSetRight
                    && rtv.IsCategoryAttributesInherited == NoYes::No
                    && rtv.Level == sdAncestor.Level;
        }

        return rtv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all the category and product attributes of the specified category.
    /// </summary>
    /// <param name="_categoryId">
    /// The category ID of the <c>EcoResCategory</c> record for which to retrieve the attributes.
    /// </param>
    /// <param name="_ecoResCategoryAttributeModifier">
    /// The <c>EcoResCategoryAttributeModifier</c> enumeration value for which to retrieve the attributes.
    /// </param>
    /// <param name="_includeInheritedAttributes">
    /// A Boolean value that indicates whether to include inheritance.
    /// </param>
    /// <returns>
    /// An array of the <c>EcoResAttribute</c> enumeration values; otherwise, an empty array.
    /// </returns>

    public static Array getProcCategoryAttributes (EcoResCategoryId _categoryId, EcoResCategoryAttributeModifier _ecoResCategoryAttributeModifier = EcoResCategoryAttributeModifier::Category, NoYes _includeInheritedAttributes = NoYes::Yes)
    {
        Array                   ecoResAttributesArray  = new Array(Types::Record);
        Counter                 arrayCount             = 0;
        Query                   q                      = new Query();
        EcoResCategory          category;
        QueryBuildDataSource    qbds0, qbds1, qbds2;
        QueryRun                qr;
        ProcCategoryModifier    procCategoryModifier;

        qbds0 = q.addDataSource(tableNum(EcoResAttribute));
        qbds1 = qbds0.addDataSource(tableNum(EcoResCategoryAttribute));
        qbds1.relations(false);
        qbds1.addLink(fieldNum(EcoResAttribute, RecId), fieldNum(EcoResCategoryAttribute, Attribute));
        qbds1.addRange(fieldNum(EcoResCategoryAttribute, Modifier)).value(queryValue(_ecoResCategoryAttributeModifier));
        qbds1.joinMode(JoinMode::ExistsJoin);

        switch (_includeInheritedAttributes)
        {
            case NoYes::No:
                qbds1.addRange(fieldNum(EcoResCategoryAttribute, Category)).value(queryValue(_categoryId));
                break;

            case NoYes::Yes:
                category                = EcoResCategory::find(_categoryId);
                procCategoryModifier    = ProcCategoryModifier::find(_categoryId);

                if ( ( (_ecoResCategoryAttributeModifier == EcoResCategoryAttributeModifier::Product) && (procCategoryModifier.IsProductAttributesInherited == NoYes::No) )
                        || ( (_ecoResCategoryAttributeModifier == EcoResCategoryAttributeModifier::Category) && (category.IsCategoryAttributesInherited == NoYes::No) ) )
                {
                    qbds1.addRange(fieldNum(EcoResCategoryAttribute, Category)).value(queryValue(_categoryId));
                }
                else
                {
                    qbds2 = qbds1.addDataSource(tableNum(EcoResCategory));
                    qbds2.relations(false);
                    qbds2.addLink(fieldNum(EcoResCategoryAttribute, Category), fieldNum(EcoResCategory, RecId));
                    qbds2.joinMode(JoinMode::InnerJoin);
                    EcoResCategoryAttribute::addCategoryRangeForAttributeInheritance(qbds2, category);
                }

                break;
        }

        qr = new QueryRun(q);
        while (qr.next())
        {
            arrayCount++;
            ecoResAttributesArray.value(arrayCount, qr.get(tableNum(EcoResAttribute)));
        }
        return ecoResAttributesArray;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryAvailability</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the availability of the specified category in the specified buying legal entity and
    ///    receiving operating unit.
    /// </summary>
    /// <param name="_categoryId">
    ///    The record ID of the <c>EcoResCategory</c> Record for which the availability should be retrieved.
    /// </param>
    /// <param name="_buyingLegalEntity">
    ///    The record ID of the legal entity in the <c>CompanyInfo</c> table for which the category
    ///    availability should be retrieved.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    ///    The record ID of the operating unit in the <c>OMOperatingUnit</c> table for which the category
    ///    availability should be retrieved; optional.
    /// </param>
    /// <param name="_organizationOption">
    ///    The record ID of the operating unit in the <c>OMOperatingUnit</c> table for which the category
    ///    availability should be retrieved; optional.
    /// </param>
    /// <returns>
    ///    true if the specified category is available in the specified legal entity and operating unit
    ///    combination; otherwise, false.
    /// </returns>
    public static boolean getProcCategoryAvailability (
                            EcoResCategoryId                _categoryId,
                            RefRecId                        _buyingLegalEntity,
                            RefRecId                        _receivingOperatingUnit = 0,
                            ProcCategoryOrganizationOption  _organizationOption = _receivingOperatingUnit
                                                                                    ? ProcCategoryOrganizationOption::ReceivingOperatingUnitCombination
                                                                                    : ProcCategoryOrganizationOption::BuyingLegalEntity)
    {
        ProcCategoryTmpPolicyRule           procCategoryTmpPolicyRule;
        ProcCategoryAccessPolicyParameter   procCategoryAccessPolicyParameter;
        EcoResCategory                      thisCategory;

        if (_buyingLegalEntity != 0 || _receivingOperatingUnit != 0)
        {
            procCategoryTmpPolicyRule = EcoResCategory::getProcCategoryRules(SysPolicyRuleTypeEnum::CategoryAccessPolicyRule,
                                                                            _buyingLegalEntity,
                                                                            _receivingOperatingUnit,
                                                                            _organizationOption);
        }
        select count(RecId) from procCategoryTmpPolicyRule;

        //when there are no category access rules, all categories should be available
        //when there is no LE and OU is specified, all categories should be available
        if ((_buyingLegalEntity == 0 && _receivingOperatingUnit == 0) || (!procCategoryTmpPolicyRule.RecId))
        {
            return true;
        }

        select firstonly * from procCategoryTmpPolicyRule
            order by procCategoryTmpPolicyRule.PolicyRuleRank
            join * from procCategoryAccessPolicyParameter
                where procCategoryTmpPolicyRule.PolicyRule == procCategoryAccessPolicyParameter.ProcurementCategoryAccessPolicyRule
                    && procCategoryAccessPolicyParameter.ProcurementCategory == _categoryId
            join RecId from thisCategory
                where thisCategory.RecId == procCategoryAccessPolicyParameter.ProcurementCategory;  // To find the Category is still exists in the EcoResCategory Table

        return (procCategoryAccessPolicyParameter.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryAvailableChildren</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves all the child categories of the specified category that are available for purchase in a
    ///    specified buying legal entity and receiving operating unit.
    /// </summary>
    /// <param name="_categoryId">
    ///    The category ID in the <c>EcoResCategory</c> table for which to retrieve the child categories.
    /// </param>
    /// <param name="_activeOnly">
    ///    A Boolean value that indicates whether to retrieve only active categories.
    /// </param>
    /// <param name="_buyingLegalEntity">
    ///    The legal entity in the <c>CompanyInfo</c> table for which to retrieve the category availability;
    ///    optional.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    ///    The operating unit in the <c>OMOperatingUnit</c> table for which to retrieve the category
    ///    availability; optional.
    /// </param>
    /// <param name="_organizationOption">
    ///    The value that is used to find the category ID in with the buying legal entity, the receiving
    ///    operating unit, or both.
    /// </param>
    /// <returns>
    ///    An array of record IDs for the child categories.
    /// </returns>
    /// <remarks>
    ///    If the values of both the <paramref name="_buyingLegalEntity" /> and <paramref
    ///    name="_receivingOperatingUnit" /> parameters are zero, the method returns all the child categories.
    /// </remarks>
    public static Array getProcCategoryAvailableChildren(
                                    EcoResCategoryId                _categoryId,
                                    boolean                         _activeOnly             = false,
                                    RefRecId                        _buyingLegalEntity      = 0,
                                    RefRecId                        _receivingOperatingUnit = 0,
                                    ProcCategoryOrganizationOption  _organizationOption     = _receivingOperatingUnit
                                                ? ProcCategoryOrganizationOption::ReceivingOperatingUnitCombination
                                                : ProcCategoryOrganizationOption::BuyingLegalEntity)
    {
        ProcCategoryTmpPolicyRule           procCategoryTmpPolicyRule;
        ProcCategoryAccessPolicyParameter   procCategoryAccessPolicyParameter;
        Array                               procCategoryArray       = new Array(Types::String);
        EcoResCategory                      ecoResCategory          = null;
        EcoResCategory                      ecoResParmCategory      = null;
        Counter                             arrayCount              = 1;
        Map                                 childCategoryMap        = new Map(Types::Int64, Types::Int64);
        EcoResCategory                      thisCategory, ancestorCategory;

        ecoResParmCategory = EcoResCategory::find(_categoryId);

        if (_buyingLegalEntity != 0 || _receivingOperatingUnit != 0)
        {
            procCategoryTmpPolicyRule = EcoResCategory::getProcCategoryRules(SysPolicyRuleTypeEnum::CategoryAccessPolicyRule,
                                                                                _buyingLegalEntity,
                                                                                _receivingOperatingUnit,
                                                                                _organizationOption);
        }
        select count(RecId) from procCategoryTmpPolicyRule;

        //when there are no category access rules, all categories should be available
        //when there is no LE and OU is specified, all categories should be available
        if ((_buyingLegalEntity == 0 && _receivingOperatingUnit == 0) || (!procCategoryTmpPolicyRule.RecId))
        {
            while select * from ecoResCategory
                order by ecoResCategory.NestedSetLeft
                    where   ecoResCategory.CategoryHierarchy == ecoResParmCategory.CategoryHierarchy
                            && ecoResCategory.ParentCategory  == ecoResParmCategory.RecId
                            && (ecoResCategory.IsActive == true || ecoResCategory.IsActive == _activeOnly)
            {
                procCategoryArray.value(arrayCount, int642str(ecoResCategory.RecId));
                arrayCount ++;
            }
        }
        else
        {
            while select PolicyRule from procCategoryTmpPolicyRule
                join RecId from procCategoryAccessPolicyParameter
                    where procCategoryTmpPolicyRule.PolicyRule == procCategoryAccessPolicyParameter.ProcurementCategoryAccessPolicyRule
                join RecId from thisCategory
                    where thisCategory.RecId == procCategoryAccessPolicyParameter.ProcurementCategory
                join RecId from ancestorCategory
                    where ancestorCategory.NestedSetLeft <= thisCategory.NestedSetLeft
                            && ancestorCategory.NestedSetRight >= thisCategory.NestedSetRight
                            && ancestorCategory.CategoryHierarchy == thisCategory.CategoryHierarchy
                            && ancestorCategory.ParentCategory == ecoResParmCategory.RecId
                            && (ancestorCategory.IsActive == true || ancestorCategory.IsActive == _activeOnly)
            {
                if (!childCategoryMap.exists(ancestorCategory.RecId))
                {
                    childCategoryMap.insert(ancestorCategory.RecId,ancestorCategory.RecId);
                    procCategoryArray.value(arrayCount, int642str(ancestorCategory.RecId));
                    arrayCount ++;
                }
            }
        }
        return procCategoryArray;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryCommodityCodes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the commodity codes that are associated with the specified category.
    /// </summary>
    /// <param name="_procurementCategory">
    ///    The <c>EcoResCategoryId</c> value in the <c>ProcCategoryCommodityCode</c> table for which the
    ///    commodity codes should be retrieved.
    /// </param>
    /// <returns>
    ///    An array of <c>ProcCategoryCommodityCode</c> records; otherwise, an empty array.
    /// </returns>

    public static Array getProcCategoryCommodityCodes(EcoResCategoryId _procurementCategory)
    {
        Array                       procCategoryCommodityCodesArray  = new Array(Types::Record);
        Counter                     arrayCount    = 0;
        ProcCategoryCommodityCode   procCategoryCommodityCode;
        EcoResCategory              ecoResCategory;

        if (Global::isConfigurationkeyEnabled(configurationKeyNum(ProcCategory)))
        {
            while select RecId from procCategoryCommodityCode
                where procCategoryCommodityCode.ProcurementCategory == _procurementCategory
                join ecoResCategory
                    where procCategoryCommodityCode.Commodity == ecoResCategory.RecId
            {
                arrayCount++;
                procCategoryCommodityCodesArray.value(arrayCount, ecoResCategory);
            }
        }

        return procCategoryCommodityCodesArray;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryDeductionRequirement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the deduction requirement that is associated with the specified category for the
    ///    specified legal entity and operating unit combination.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    ///    The category ID in the <c>EcoResCategory</c> table for which to retrieve the deduction requirement.
    /// </param>
    /// <param name="_buyingLegalEntity">
    ///    The legal entity in the <c>CompanyInfo</c> table for which to retrieve the deduction requirement.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    ///    The operating unit in the <c>OMOperatingUnit</c> table for which to retrieve the deduction
    ///    requirement; optional.
    /// </param>
    /// <param name="_organizationOption">
    ///    The option for the user to find the category ID.
    /// </param>
    /// <returns>
    ///    The deduction requirement associated with the category for the specified legal entity and operating
    ///    unit combination; otherwise, false.
    /// </returns>
    public static boolean getProcCategoryDeductionRequirement(EcoResCategoryId _ecoResCategoryId,
                                                              RefRecId         _buyingLegalEntity,
                                                              RefRecId         _receivingOperatingUnit = 0,
                                                              ProcCategoryOrganizationOption _organizationOption = _receivingOperatingUnit
                                                                                                                  ? ProcCategoryOrganizationOption::ReceivingOperatingUnitCombination
                                                                                                                  : ProcCategoryOrganizationOption::BuyingLegalEntity)
    {
        ProcCategoryPolicyParameter procCategoryPolicyParameter;

        procCategoryPolicyParameter = EcoResCategory::getProcCategoryPolicyParameter(_ecoResCategoryId, _buyingLegalEntity, _receivingOperatingUnit, _organizationOption);

        return  procCategoryPolicyParameter.HasDeductionRequirement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryPage</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>ProcCategoryPageTranslation</c> record that is associated with the specified
    ///    category for the specified legal entity and operating unit combination.
    /// </summary>
    /// <param name="_categoryRecId">
    ///    The category ID of the <c>EcoResCategory</c> record for which to retrieve the deduction requirement.
    /// </param>
    /// <param name="_legalEntity">
    ///    The legal entity in the <c>CompanyInfo</c> table for which to retrieve the deduction requirement.
    /// </param>
    /// <param name="_languageId">
    ///    The language ID value in the <c>LanguageTable</c> table for which to retrieve the deduction
    ///    requirement; optional.
    /// </param>
    /// <returns>
    ///    The <c>ProcCategoryPageTranslation</c> table buffer that is associated with the specified category
    ///    for the specified legal entity and operating unit combination if found; otherwise, false.
    /// </returns>
    public static ProcCategoryPageTranslation   getProcCategoryPage(EcoResCategoryId _categoryRecId,
                    RefRecId _legalEntity,
                    LanguageId _languageId = LanguageTable::defaultLanguage())
    {
        ProcCategoryPageTranslation     procCategoryPageTranslation;
        ProcCategoryPage                procCategoryPage;
        ProcCategoryCharterPagePolicy   procCategoryCharterPagePolicy;

        if (Global::isConfigurationkeyEnabled(configurationKeyNum(ProcCategory)))
        {
            select firstonly procCategoryPageTranslation
                where procCategoryPageTranslation.LanguageID == _languageId
                    join RecId from procCategoryPage
                            where procCategoryPageTranslation.ProcurementCategoryPage == procCategoryPage.RecId
                                &&  procCategoryPage.ProcurementCategory == _categoryRecId
                    join RecId from procCategoryCharterPagePolicy
                            where procCategoryCharterPagePolicy.ProcurementCategoryPage == procCategoryPage.RecId
                                && procCategoryCharterPagePolicy.BuyingLegalEntity == _legalEntity;
        }

        return procCategoryPageTranslation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryPolicyParameter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the specified <c>ProcCategoryPolicyParameter</c> record.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    ///    The category ID of the <c>EcoResCategory</c> record for which to retrieve the receiving requirement.
    /// </param>
    /// <param name="_buyingLegalEntity">
    ///    The legal entity of the <c>CompanyInfo</c> record for which to retrieve the receiving requirement.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    ///    The operating unit of the <c>OMOperatingUnit</c> record for which to retrieve the receiving
    ///    requirement; optional.
    /// </param>
    /// <param name="_organizationOption">
    ///    The reference record ID of the <c>OMOperatingUnit</c> record for which to retrieve the category
    ///    availability; optional.
    /// </param>
    /// <returns>
    ///    A <c>ProcCategoryPolicyParameter</c> record.
    /// </returns>
    public static ProcCategoryPolicyParameter getProcCategoryPolicyParameter(EcoResCategoryId _ecoResCategoryId,
                                                              RefRecId         _buyingLegalEntity,
                                                              RefRecId         _receivingOperatingUnit,
                                                              ProcCategoryOrganizationOption _organizationOption)
    {
        ProcCategoryTmpPolicyRule           procCategoryTmpPolicyRule;
        ProcCategoryPolicyParameter         procCategoryPolicyParameter, retProcCategoryPolicyParameter;
        EcoResCategory                      ecoResCategory, ecoResCategorySelected;

        retProcCategoryPolicyParameter.initValue();

        if (Global::isConfigurationkeyEnabled(configurationKeyNum(ProcCategory)))
        {
            procCategoryTmpPolicyRule = EcoResCategory::getProcCategoryRules(SysPolicyRuleTypeEnum::CategoryPolicyRule,
                                                                                _buyingLegalEntity,
                                                                                _receivingOperatingUnit,
                                                                                _organizationOption);

            ecoResCategorySelected = EcoResCategory::find(_ecoResCategoryId);
            while select * from procCategoryTmpPolicyRule
                order by procCategoryTmpPolicyRule.PolicyRuleRank, ecoResCategory.Level desc
                join * from ecoResCategory
                    where   ecoResCategory.CategoryHierarchy == ecoResCategorySelected.CategoryHierarchy
                        && ecoResCategory.NestedSetLeft  <= ecoResCategorySelected.NestedSetLeft
                        && ecoResCategory.NestedSetRight >= ecoResCategorySelected.NestedSetRight
                join * from procCategoryPolicyParameter
                    where procCategoryPolicyParameter.ProcurementCategory == ecoResCategory.RecId &&
                        procCategoryTmpPolicyRule.PolicyRule == procCategoryPolicyParameter.ProcurementCategoryPolicyRule
            {
                break;
            }

            if (procCategoryPolicyParameter.RecId != 0)
            {
                retProcCategoryPolicyParameter = procCategoryPolicyParameter;
            }
        }

        return retProcCategoryPolicyParameter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryQuestionnaires</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all the questionnaires that belong to a specific category.
    /// </summary>
    /// <param name="_procurementCategoryId">
    /// The specific procurement category for which we have to find the associated questionnaires.
    /// </param>
    /// <param name="_administrationActivity">
    /// The specific type of vendor value.
    /// </param>
    /// <param name="_buyingLegalEntity">
    /// The <c>LegelEntity</c> type that is required to find the associated questionnaires.
    /// </param>
    /// <returns>
    /// An array of questionnaires.
    /// </returns>
    public static Array getProcCategoryQuestionnaires(EcoResCategoryId _procurementCategoryId,
                                                            ProcCategoryAdministrationActivity _administrationActivity,
                                                            RefRecId _buyingLegalEntity)
    {
        Array                       procQuestionnaireArray  = new Array(Types::Record);
        Counter                     arrayCount    = 0;
        EcoResCategory              category;
        ProcCategoryModifier        procCategory;
        Query                       q = new Query();
        QueryBuildDataSource        qbds, qbds2, qbds3;
        QueryRun                    qr;
        EcoResCategory              tmpNearestStopInheritAncestor;

        category = EcoResCategory::find(_procurementCategoryId);
        procCategory = ProcCategoryModifier::find(_procurementCategoryId);
        if ( category.RecId ==0 )
        {
            throw Global::error("@SYS303685");
        }

        q.allowCrossCompany(true);

        qbds = q.addDataSource(tableNum(EcoResCategory));

        if (NoYes::No == procCategory.IsQuestionnairiesInherited)
        {
            qbds.addRange(fieldNum(EcoResCategory,RecId)).value(queryValue(category.RecId));
        }
        else
        {
            tmpNearestStopInheritAncestor = ProcCategoryModifier::getNearestAncestorWithInheritUnchecked(category, fieldNum(ProcCategoryModifier, IsQuestionnairiesInherited));
            if (qbds)
            {
                qbds.clearRanges();
                qbds.addRange(fieldNum(EcoResCategory,CategoryHierarchy)).value(queryValue(category.CategoryHierarchy));
                qbds.addRange(fieldNum(EcoResCategory,NestedSetLeft)).value(queryRange(tmpNearestStopInheritAncestor.NestedSetLeft, category.NestedSetLeft));
                qbds.addRange(fieldNum(EcoResCategory,NestedSetRight)).value(queryRange(category.NestedSetRight, tmpNearestStopInheritAncestor.NestedSetRight));
            }
        }

        qbds2 = qbds.addDataSource(tableNum(ProcCategoryQuestionnaire));
        qbds2.relations(true);
        qbds3 = qbds2.addDataSource(tableNum(KMCollection));
        qbds3.relations(true);
        qbds2.addRange(fieldNum(ProcCategoryQuestionnaire, AdministrationActivity)).value(queryValue(_administrationActivity));

        if (_buyingLegalEntity != 0)
        {
            q.addCompanyRange(CompanyInfo::findRecId(_buyingLegalEntity).DataArea);
        }

        qr = new QueryRun(q);
        while (qr.next())
        {
            arrayCount ++;
            procQuestionnaireArray.value(arrayCount, qr.get(tableNum(KMCollection)));
        }

        return procQuestionnaireArray;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryReceivingRequirement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the receiving requirement associated with the specified category for the specified legal
    ///    entity and operating unit combination.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    ///    The category ID of the <c>EcoResCategory</c> record for which to retrieve the receiving requirement.
    /// </param>
    /// <param name="_buyingLegalEntity">
    ///    The legal entity in the <c>CompanyInfo</c> table for which to retrieve the receiving requirement.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    ///    The operating unit in the <c>OMOperatingUnit</c> table for which to retrieve the receiving
    ///    requirement; optional.
    /// </param>
    /// <param name="_organizationOption">
    ///    The operating unit in the <c>OMOperatingUnit</c> table for which to retrieve the category
    ///    availability; optional.
    /// </param>
    /// <returns>
    ///    The receiving requirement associated with the category for the specified legal entity and operating
    ///    unit combination; otherwise, false.
    /// </returns>
    public static boolean getProcCategoryReceivingRequirement(EcoResCategoryId _ecoResCategoryId,
                                                              RefRecId         _buyingLegalEntity,
                                                              RefRecId         _receivingOperatingUnit = 0,
                                                              ProcCategoryOrganizationOption _organizationOption = _receivingOperatingUnit
                                                                                                                  ? ProcCategoryOrganizationOption::ReceivingOperatingUnitCombination
                                                                                                                  : ProcCategoryOrganizationOption::BuyingLegalEntity)
    {
        ProcCategoryPolicyParameter procCategoryPolicyParameter;

        procCategoryPolicyParameter = EcoResCategory::getProcCategoryPolicyParameter(_ecoResCategoryId, _buyingLegalEntity, _receivingOperatingUnit, _organizationOption);

        return  procCategoryPolicyParameter.HasReceivingRequirement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryRecExpOnGoodsReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the deduction requirement associated with the specified category for the specified legal
    ///    entity and operating unit combination.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    ///    The category ID in the <c>EcoResCategory</c> table for which to retrieve the deduction requirement.
    /// </param>
    /// <param name="_buyingLegalEntity">
    ///    The legal entity in the <c>CompanyInfo</c> table for which to retrieve the deduction requirement.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    ///    The operating unit in the <c>OMOperatingUnit</c> table for which to retrieve the deduction
    ///    requirement; optional.
    /// </param>
    /// <param name="_organizationOption">
    ///    The option for the user to find the category ID.
    /// </param>
    /// <returns>
    ///    The record associated with the specified category for the specified legal entity and operating unit
    ///    combination; otherwise, false.
    /// </returns>
    public static boolean getProcCategoryRecExpOnGoodsReceipt(EcoResCategoryId _ecoResCategoryId,
                                                              RefRecId         _buyingLegalEntity,
                                                              RefRecId         _receivingOperatingUnit = 0,
                                                              ProcCategoryOrganizationOption _organizationOption = _receivingOperatingUnit
                                                                                                                  ? ProcCategoryOrganizationOption::ReceivingOperatingUnitCombination
                                                                                                                  : ProcCategoryOrganizationOption::BuyingLegalEntity)
    {
        ProcCategoryPolicyParameter procCategoryPolicyParameter;

        procCategoryPolicyParameter = EcoResCategory::getProcCategoryPolicyParameter(_ecoResCategoryId, _buyingLegalEntity, _receivingOperatingUnit, _organizationOption);

        return  procCategoryPolicyParameter.RecordExpenditureOnGoodsReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcCategoryRules</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves all the rule IDs in a table.
    /// </summary>
    /// <param name="_ruleTypeEnum">
    ///    A <c>SysPolicyRuleTypeEnum</c> enumeration value.
    /// </param>
    /// <param name="_buyingLegalEntity">
    ///    The legal entity in the <c>CompanyInfo</c> table for which to retrieve the category availability;
    ///    optional
    /// </param>
    /// <param name="_receivingOperatingUnit">
    ///    The operating unit in the <c>OMOperatingUnit</c> table for which to retrieve the category
    ///    availability; optional.
    /// </param>
    /// <param name="_organizationOption">
    ///    The option for the user to find the category ID.
    /// </param>
    /// <returns>
    ///    An array of child categories
    /// </returns>
    public static ProcCategoryTmpPolicyRule getProcCategoryRules(SysPolicyRuleTypeEnum       _ruleTypeEnum,
                                                                    RefRecId                        _buyingLegalEntity,
                                                                    RefRecId                        _receivingOperatingUnit = 0,
                                                                    ProcCategoryOrganizationOption  _organizationOption     = _receivingOperatingUnit?
                                                                                                                                    ProcCategoryOrganizationOption::BuyingLegalEntityAndCombination:
                                                                                                                                    ProcCategoryOrganizationOption::BuyingLegalEntity)
    {
        ProcCategoryTmpPolicyRule   procCategoryTmpPolicyRule;
        int                         i, j;
        int64                       selectedLegalEntity[1];
        int64                       selectedOperatingUnit[2];
        Array                       categoryAccessPolicyRules;
        int64                       ruleType;

        if (Global::isConfigurationkeyEnabled(configurationKeyNum(ProcCategory)))
        {
            if (_buyingLegalEntity)
            {
                if (_organizationOption == ProcCategoryOrganizationOption::BuyingLegalEntity)
                {
                    selectedLegalEntity[1] = _buyingLegalEntity;
                }
                else if (_receivingOperatingUnit &&
                            (_organizationOption == ProcCategoryOrganizationOption::BuyingLegalEntityAndCombination ||
                                    _organizationOption == ProcCategoryOrganizationOption::ReceivingOperatingUnitCombination))
                {
                    selectedLegalEntity[1]   = _buyingLegalEntity;
                    selectedOperatingUnit[1] = _buyingLegalEntity;
                    selectedOperatingUnit[2] = _receivingOperatingUnit;
                }
                else
                {
                    throw Global::error("@SYS304931");
                }
            }
            else
            {
                throw Global::error("@SYS305149");
            }

            ruleType = SysPolicyRuleType::findByRuleTypePolicyType(_ruleTypeEnum, SysPolicyTypeEnum::PurchasingPolicy).RecId;

            if (_organizationOption == ProcCategoryOrganizationOption::BuyingLegalEntityAndCombination ||
                    _organizationOption == ProcCategoryOrganizationOption::ReceivingOperatingUnitCombination)
            {
                categoryAccessPolicyRules = SysPolicies::getPolicyRuleIDs(selectedOperatingUnit,
                                                  ruleType,
                                                  SysPolicyTypeEnum::PurchasingPolicy,
                                                  DateTimeUtil::minValue(),
                                                  true);

                for ( i = 1; i <= categoryAccessPolicyRules.lastIndex(); i++)
                {
                    procCategoryTmpPolicyRule.PolicyRule       = categoryAccessPolicyRules.value(i);
                    procCategoryTmpPolicyRule.PolicyRuleRank   = i;
                    procCategoryTmpPolicyRule.insert();
                }
            }

            if (_organizationOption == ProcCategoryOrganizationOption::BuyingLegalEntity ||
                    _organizationOption == ProcCategoryOrganizationOption::BuyingLegalEntityAndCombination)
            {
                categoryAccessPolicyRules = SysPolicies::getPolicyRuleIDs(
                                               (_organizationOption == ProcCategoryOrganizationOption::BuyingLegalEntity)
                                                    ? selectedLegalEntity : selectedOperatingUnit,
                                               ruleType,
                                               SysPolicyTypeEnum::PurchasingPolicy,
                                               DateTimeUtil::minValue(),
                                               false);

                for ( j = 1; j <= categoryAccessPolicyRules.lastIndex(); j++)
                {
                    procCategoryTmpPolicyRule.PolicyRule       = categoryAccessPolicyRules.value(j);
                    procCategoryTmpPolicyRule.PolicyRuleRank   = i + j;
                    procCategoryTmpPolicyRule.insert();
                }
            }
        }
        return procCategoryTmpPolicyRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcurementCategoryItemTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the item tax group that is associated with the specified category and for the specified
    /// organization.
    /// </summary>
    /// <param name="_procurementCategoryId">
    /// The category ID in the <c>EcoResCategoryId</c> table that the tax item group should be retrieved.
    /// </param>
    /// <param name="_buyingLegalEntity">
    /// The <c>LegalEntity</c> value.
    /// </param>
    /// <returns>
    /// A record in the <c>TaxItemGroupHeading</c> table that is associated with the specified category for
    /// the specified organization if found; otherwise, an empty buffer.
    /// </returns>
    public static TaxItemGroupHeading getProcurementCategoryItemTaxGroup(EcoResCategoryId _procurementCategoryId, RefRecId _buyingLegalEntity  = CompanyInfo::findDataArea(curext()).RecId)
    {
        return ProcCategoryItemTaxGroup::getProcCategoryItemTaxGroup(_procurementCategoryId, _buyingLegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcurementCategoryMatchingPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the deduction requirement associated with the specified category for the specified legal
    ///    entity and operating unit combination.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    ///    The category ID in the <c>EcoResCategory</c> table for which to retrieve the deduction requirement.
    /// </param>
    /// <param name="_buyingLegalEntity">
    ///    The legal entity in the <c>CompanyInfo</c> table for which to retrieve the deduction requirement.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    ///    The operating unit in the <c>OMOperatingUnit</c> table for which to retrieve the deduction
    ///    requirement; optional.
    /// </param>
    /// <param name="_organizationOption">
    ///    The option for the user to find the category ID.
    /// </param>
    /// <returns>
    ///    The matching policy value associated with the specified category for the specified legal entity and
    ///    operating unit combination; otherwise, false.
    /// </returns>
    public static PurchMatchingPolicyWithNotSetOption getProcurementCategoryMatchingPolicy(EcoResCategoryId _ecoResCategoryId,
                                                    RefRecId _buyingLegalEntity,
                                                    RefRecId _receivingOperatingUnit = 0,
                                                    ProcCategoryOrganizationOption _organizationOption = _receivingOperatingUnit
                                                                                                        ? ProcCategoryOrganizationOption::ReceivingOperatingUnitCombination
                                                                                                        : ProcCategoryOrganizationOption::BuyingLegalEntity)
    {
        ProcCategoryPolicyParameter procCategoryPolicyParameter;

        procCategoryPolicyParameter = EcoResCategory::getProcCategoryPolicyParameter(_ecoResCategoryId, _buyingLegalEntity, _receivingOperatingUnit, _organizationOption);

        if (procCategoryPolicyParameter.RecId != 0)
        {
            return  procCategoryPolicyParameter.MatchingPolicyOption;
        }

        return PurchMatchingPolicyWithNotSetOption::NotSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRoot</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the root or very first category of the hierarchy.
    /// </summary>
    /// <param name="_ecoResCategoryHierarchyId">
    ///    The category hierarchy ID in the <c>EcoResCategoryHierarchy</c> table to retrieve.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record of the <c>EcoResCategory</c> table if found; otherwise, an empty buffer.
    /// </returns>
    public static EcoResCategory getRoot(EcoResCategoryHierarchyId _ecoResCategoryHierarchyId, boolean _forUpdate = false)
    {
        EcoResCategory  ecoResCategory = null;
        #EcoResCategoryDefaults

        ecoResCategory.selectForUpdate(_forUpdate);
        select firstonly * from ecoResCategory
                where ecoResCategory.CategoryHierarchy     == _ecoResCategoryHierarchyId
                    && ecoResCategory.NestedSetLeft   == #ECORESROOTNESTEDLEFTVALUE;

        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDescendant</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified category is a descendant node of the given category.
    /// </summary>
    /// <param name="descendentCategoryId">
    /// The descendent category to be checked for descendancy.
    /// </param>
    /// <param name="ancestorCategoryId">
    /// The ancestor category ID.
    /// </param>
    /// <param name="checkIsActive">
    /// Determines whether the check on the <c>IsActive</c> field is required or not on the descendent
    /// category.
    /// </param>
    /// <returns>
    /// true if the specified category is a descendant or the two nodes are the same; otherwise, false.
    /// </returns>
    public static boolean isDescendant(recId descendentCategoryId, recId ancestorCategoryId, boolean checkIsActive)
    {
        EcoResCategory  childCategory;
        EcoResCategory  parentCategory;

        childCategory   = EcoResCategory::find(descendentCategoryId);
        parentCategory  = EcoResCategory::find(ancestorCategoryId);

        if (childCategory.CategoryHierarchy == parentCategory.CategoryHierarchy
            && childCategory.NestedSetLeft  >= parentCategory.NestedSetLeft
            && childCategory.NestedSetRight <= parentCategory.NestedSetRight
            && ((checkIsActive && (childCategory.IsActive == NoYes::Yes)) || (!checkIsActive)))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTangible</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified category is tangible or not.
    /// </summary>
    /// <param name="_categoryId">
    /// The Category ID (recId) in the <c>EcoResCategory</c> table for which the tangible property should be retrieved.
    /// </param>
    /// <returns>
    /// true if the specified Category is tangible; otherwise, false.
    /// </returns>
    public static boolean isTangible(EcoResCategoryId _categoryId)
    {
        EcoResCategory  ecoResCategory;

        select firstonly IsTangible from ecoResCategory
            where ecoResCategory.RecId == _categoryId;

        return ecoResCategory.IsTangible;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupCategoryForProcurement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and displays a lookup from which the user can select a Category ID from a specified
    /// Purchase agreement.
    /// </summary>
    /// <param name="_formReferenceControl">
    /// The calling form reference control.
    /// </param>
    /// <param name="_purchAgreementHeaderRecId">
    /// The record ID of a purchase agreement header
    /// </param>
    /// <returns>
    /// The selected record for record mode selection; otherwise, null.
    /// </returns>
    public static Common lookupCategoryForProcurement(FormReferenceControl    _formReferenceControl,
                                                                RecId                _purchAgreementHeaderRecId)
    {
        SysReferenceTableLookup sysReferenceTableLookup;
        Query                   query = new Query();
        QueryBuildDataSource    ecoResCategoryDS;
        QueryBuildDataSource    agreementLineDS;
        QueryBuildDataSource    agreemntHeaderDS;

        sysReferenceTableLookup = SysReferenceTableLookup::newParameters(tableNum(EcoResCategory), _formReferenceControl, true);

        ecoResCategoryDS = query.addDataSource(tableNum(EcoResCategory));
        agreementLineDS = ecoResCategoryDS.addDataSource(tableNum(AgreementLine));

        agreementLineDS.relations(true);

        agreemntHeaderDS = agreementLineDS.addDataSource(tableNum(AgreementHeader));
        agreemntHeaderDS.relations(true);
        agreemntHeaderDS.addRange(fieldNum(AgreementHeader, RecId)).value(SysQuery::value(_purchAgreementHeaderRecId));

        sysReferenceTableLookup.addLookupfield(fieldNum(EcoResCategory, Name));
        sysReferenceTableLookup.parmQuery(query);

        return sysReferenceTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupCategoryHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and displays a lookup from which the user can select a category ID from a specified
    /// category hierarchy.
    /// </summary>
    /// <param name="_formReferenceControl">
    /// The calling form reference control.
    /// </param>
    /// <param name="_ecoResCategoryHierarchy">
    /// A record of the <c>EcoResCategoryHierarchy</c> table that indicates the category hierarchy from
    /// which to fetch categories.
    /// </param>
    /// <param name="_leafNodeOnlySelect">
    /// A Boolean value that indicates whether only the leaf categories are selectable; optional.
    /// </param>
    /// <param name="_showActiveNodesOnly">
    /// A Boolean value that indicates whether only the active categories are shown in the tree view or
    /// not; optional.
    /// </param>
    /// <param name="_showCommodityCodeWithName">
    /// A Boolean value that indicates whether to show the commodity code and the category name in the tree
    /// view; optional.
    /// </param>
    /// <param name="_ecoResCategorySelectionValidator">
    /// An object that implements the <c>EcoResCategorySelectionValidator</c> interface that is used for
    /// validating the category selection; optional.
    /// </param>
    /// <param name="_buyingLegalEntity">
    /// The legal entity reference record ID in the <c>CompanyInfo</c> table for which the category
    /// availability can be retrieved; optional.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    /// The operating unit reference record ID in the <c>OMOperatingUnit</c> table for which the category
    /// availability can be retrieved; optional.
    /// </param>
    /// <param name="_organizationOption">
    /// The <c>ProcCategoryOrganizationOption</c> enumeration gives an option to the user to find the
    /// category ID.
    /// </param>
    /// <param name="_purchAgreementHeaderRecId">
    /// The PurchAgreementHeaderRecId (RefRecId) in the <c>PurchAgreement</c> table for which the category availability should be retrieved; optional.
    /// </param>
    /// <param name="_multiRoleSelectionSet">
    /// Container.
    /// </param>
    /// <param name="_selectedCategoryHierarchyId">
    /// The id of the currently selected category hierarchy. Optional.
    /// </param>
    /// <returns>
    /// The selected record for record mode selection; otherwise null.
    /// </returns>
    /// <remarks>
    /// The category ID can be found by buying the legal entity, which considers only buying the legal
    /// entity, by receiving the operating unit, which considers buying the legal entity and receiving the
    /// operating unit, and by both, which considers both buying the legal entity and buying the legal
    /// entity and receiving the operating unit combined.
    /// </remarks>
    public static Common lookupCategoryHierarchy(FormReferenceControl             _formReferenceControl,
                                                        EcoResCategoryHierarchy          _ecoResCategoryHierarchy,
                                                        boolean                          _leafNodeOnlySelect = false,
                                                        boolean                          _showActiveNodesOnly = true,
                                                        boolean                          _showCommodityCodeWithName = true,
                                                        EcoResCategorySelectionValidator _ecoResCategorySelectionValidator = null,
                                                        RefRecId                         _buyingLegalEntity = 0,
                                                        RefRecId                         _receivingOperatingUnit = 0,
                                                        ProcCategoryOrganizationOption   _organizationOption = _receivingOperatingUnit
                                                                                ? ProcCategoryOrganizationOption::BuyingLegalEntityAndCombination
                                                                                : ProcCategoryOrganizationOption::BuyingLegalEntity,
                                                        RecId                            _purchAgreementHeaderRecId = 0,
                                                        container                        _multiRoleSelectionSet = conNull(),
                                                        RefRecId                         _selectedCategoryHierarchyId = 0)
    {
        EcoResCategoryName             ecoResCategoryNameFilter;
        EcoResCategoryId               ecoResCategoryId;
        EcoResCategoryLookupParameters lookupParameters;
        EcoResCategory                 ecoResSelectedCategory = null;
        Args                           args;
        FormRun                        formRun;
        boolean                        callingControlChanged;
        AgreementLine                  agreementLine;

        if (!_formReferenceControl || _formReferenceControl.handle() != classNum(FormReferenceGroupControl) )
        {
            throw(error(strFmt("@SYS137393", Error::wrongUseOfFunction(funcName())) ));
        }

        if (!_ecoResCategoryHierarchy || !_ecoResCategoryHierarchy.RecId)
        {
            throw(error(strFmt("@SYS137392", Error::wrongUseOfFunction(funcName())) ));
        }

        ecoResCategoryNameFilter = _formReferenceControl.filterValue(AbsoluteFieldBinding::construct(fieldStr(EcoResCategory, Name), tableStr(EcoResCategory))).value();
        ecoResCategoryId         = str2int64(_formReferenceControl.valueStr());
        ecoResSelectedCategory   = EcoResCategory::find(ecoResCategoryId);
        callingControlChanged    = ((ecoResSelectedCategory.Name != ecoResCategoryNameFilter) ||
                                            (_formReferenceControl.hasChanged()));

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && ecoResCategoryNameFilter == "" && _purchAgreementHeaderRecId)
        {
            select firstonly Category from agreementLine
                order by Category asc
                where agreementLine.Agreement == _purchAgreementHeaderRecId;

            ecoResCategoryNameFilter = EcoResCategory::find(agreementLine.Category).Name;
        }

        if (callingControlChanged && !Global::strContains(ecoResCategoryNameFilter, "@SYS327992"))
        {
            ecoResCategoryNameFilter = ecoResCategoryNameFilter + "@SYS327992";
        }

        lookupParameters = EcoResCategory::getLookupParameters(_buyingLegalEntity,
                                                            _receivingOperatingUnit,
                                                            ecoResCategoryNameFilter,
                                                            _leafNodeOnlySelect,
                                                            _showActiveNodesOnly,
                                                            _showCommodityCodeWithName,
                                                            _ecoResCategorySelectionValidator,
                                                            _organizationOption,
                                                            _purchAgreementHeaderRecId,
                                                            _multiRoleSelectionSet,
                                                            _selectedCategoryHierarchyId);

        args = new Args();
        args.name(formStr(EcoResCategorySingleLookup));
        args.caller(_formReferenceControl);
        args.record(_ecoResCategoryHierarchy);
        args.lookupField(fieldNum(EcoResCategory, RecId));
        args.parmObject(lookupParameters);

        if (!callingControlChanged)
        {
            args.lookupValue(_formReferenceControl.valueStr());
        }

        formRun = classfactory.formRunClass(args);
        formRun.init();

        _formReferenceControl.performFormLookup(formRun);
        return formRun.selectRecordModeSelectedRecord();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLookupParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of lookup parameters to use for category controls from which the user can select a category ID from a specified
    /// category hierarchy.
    /// </summary>
    /// <param name="_buyingLegalEntity">
    /// The legal entity reference record ID in the <c>CompanyInfo</c> table for which the category
    /// availability can be retrieved; optional.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    /// The operating unit reference record ID in the <c>OMOperatingUnit</c> table for which the category
    /// availability can be retrieved; optional.
    /// </param>
    /// <param name="_ecoResCategoryNameFilter">
    /// The default filter for the control.
    /// </param>
    /// <param name="_leafNodeOnlySelect">
    /// A Boolean value that indicates whether only the leaf categories are selectable; optional.
    /// </param>
    /// <param name="_showActiveNodesOnly">
    /// A Boolean value that indicates whether only the active categories are shown in the tree view or
    /// not; optional.
    /// </param>
    /// <param name="_showCommodityCodeWithName">
    /// A Boolean value that indicates whether to show the commodity code and the category name in the tree
    /// view; optional.
    /// </param>
    /// <param name="_ecoResCategorySelectionValidator">
    /// An object that implements the <c>EcoResCategorySelectionValidator</c> interface that is used for
    /// validating the category selection; optional.
    /// </param>
    /// <param name="_organizationOption">
    /// The <c>ProcCategoryOrganizationOption</c> enumeration gives an option to the user to find the
    /// category ID.
    /// </param>
    /// <param name="_purchAgreementHeaderRecId">
    /// The PurchAgreementHeaderRecId (RefRecId) in the <c>PurchAgreement</c> table for which the category availability should be retrieved; optional.
    /// </param>
    /// <param name="_multiRoleSelectionSet">
    /// Container.
    /// </param>
    /// <param name="_selectedCategoryHierarchyId">
    /// The id of the currently selected category hierarchy. Optional.
    /// </param>
    /// <returns>
    /// The created instance of <c>EcoResCategoryLookupParameters</c>.
    /// </returns>
    /// <remarks>
    /// The category ID can be found by buying the legal entity, which considers only buying the legal
    /// entity, by receiving the operating unit, which considers buying the legal entity and receiving the
    /// operating unit, and by both, which considers both buying the legal entity and buying the legal
    /// entity and receiving the operating unit combined.
    /// </remarks>
    public static EcoResCategoryLookupParameters getLookupParameters( RefRecId                          _buyingLegalEntity = 0,
                                                                    RefRecId                            _receivingOperatingUnit = 0,
                                                                    EcoResCategoryName                  _ecoResCategoryNameFilter = '',
                                                                    boolean                             _leafNodeOnlySelect = false,
                                                                    boolean                             _showActiveNodesOnly = true,
                                                                    boolean                             _showCommodityCodeWithName = true,
                                                                    EcoResCategorySelectionValidator    _ecoResCategorySelectionValidator = null,
                                                                    ProcCategoryOrganizationOption      _organizationOption = _receivingOperatingUnit
                                                                                            ? ProcCategoryOrganizationOption::BuyingLegalEntityAndCombination
                                                                                            : ProcCategoryOrganizationOption::BuyingLegalEntity,
                                                                    RecId                               _purchAgreementHeaderRecId = 0,
                                                                    container                           _multiRoleSelectionSet = conNull(),
                                                                    RefRecId                            _selectedCategoryHierarchyId = 0)
    {
        EcoResCategoryLookupParameters lookupParameters;

        // Use PubSect tag for both PubSect and Retail.
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            lookupParameters = new EcoResCategoryLookupParameters(_leafNodeOnlySelect,
                                        _showCommodityCodeWithName,
                                        _showActiveNodesOnly,
                                        true,
                                        _ecoResCategoryNameFilter,
                                        _ecoResCategorySelectionValidator,
                                        _buyingLegalEntity,
                                        _receivingOperatingUnit,
                                        _organizationOption,
                                        _purchAgreementHeaderRecId, //PubSect param.
                                        _multiRoleSelectionSet,           //RETAIL param.
                                        _selectedCategoryHierarchyId);    //RETAIL param.
        }
        else if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            lookupParameters = new EcoResCategoryLookupParameters(_leafNodeOnlySelect,
                                        _showCommodityCodeWithName,
                                        _showActiveNodesOnly,
                                        true,
                                        _ecoResCategoryNameFilter,
                                        _ecoResCategorySelectionValidator,
                                        _buyingLegalEntity,
                                        _receivingOperatingUnit,
                                        _organizationOption,
                                        _purchAgreementHeaderRecId,
                                        conNull(),  // RETAIL default value.
                                        0);         // RETAIL default value.
        }
        else if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            lookupParameters = new EcoResCategoryLookupParameters(_leafNodeOnlySelect,
                                        _showCommodityCodeWithName,
                                        _showActiveNodesOnly,
                                        true,
                                        _ecoResCategoryNameFilter,
                                        _ecoResCategorySelectionValidator,
                                        _buyingLegalEntity,
                                        _receivingOperatingUnit,
                                        _organizationOption,
                                        0, // PubSect default value.
                                        _multiRoleSelectionSet,
                                        _selectedCategoryHierarchyId);
        }
        else
        {
            lookupParameters = new EcoResCategoryLookupParameters(_leafNodeOnlySelect,
                                        _showCommodityCodeWithName,
                                        _showActiveNodesOnly,
                                        true,
                                        _ecoResCategoryNameFilter,
                                        _ecoResCategorySelectionValidator,
                                        _buyingLegalEntity,
                                        _receivingOperatingUnit,
                                        _organizationOption,
                                        0,          // PubSect default value.
        conNull(),  // Retail default value.
        0);         // Retail default value.
        }
        return lookupParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupCategoryHierarchyRole</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and displays a lookup from which the user can select a category ID from a specified
    /// category hierarchy role.
    /// </summary>
    /// <param name="_formReferenceControl">
    /// The calling form reference control.
    /// </param>
    /// <param name="_ecoResCategoryNamedHierarchyRole">
    /// An <c>EcoResCategoryNamedHierarchyRole</c> enumeration value that indicates the category hierarchy
    /// from which to get the categories.
    /// </param>
    /// <param name="_leafNodeOnlySelect">
    /// A Boolean value that indicates whether only the leaf categories are selectable; optional.
    /// </param>
    /// <param name="_showActiveNodesOnly">
    /// A Boolean value that indicates whether only the active categories are shown in the tree view or
    /// not; optional.
    /// </param>
    /// <param name="_showCommodityCodeWithName">
    /// A Boolean value that indicates whether to show the commodity code and the category name in the tree
    /// view; optional.
    /// </param>
    /// <param name="_ecoResCategorySelectionValidator">
    /// An object that implements the <c>EcoResCategorySelectionValidator</c> interface that is used for
    /// validating the category selection; optional.
    /// </param>
    /// <param name="_buyingLegalEntity">
    /// The legal entity reference record ID in the <c>CompanyInfo</c> table for which the category
    /// availability can be retrieved; optional.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    /// The operating unit reference record ID in the <c>OMOperatingUnit</c> table for which the category
    /// availability can be retrieved; optional.
    /// </param>
    /// <param name="_organizationOption">
    /// The <c>ProcCategoryOrganizationOption</c> enumeration gives an option to the user to find the
    /// category ID.
    /// </param>
    /// <param name="_purchAgreementHeaderRecId">
    /// The PurchAgreementHeaderRecId (RefRecId) in the <c>PurchAgreement</c> table for which the category availability should be retrieved; optional.
    /// </param>
    /// <returns>
    /// The selected record for record mode selection; otherwise null.
    /// </returns>
    /// <remarks>
    /// The category ID can be found by buying the legal entity, which considers only buying the legal
    /// entity, by receiving the operating unit, which considers buying the legal entity and receiving the
    /// operating unit, and by both, which considers both buying the legal entity, and buying the legal
    /// entity and receiving the operating unit combined.
    /// </remarks>
    public static Common lookupCategoryHierarchyRole(FormReferenceControl             _formReferenceControl,
                                                            EcoResCategoryNamedHierarchyRole _ecoResCategoryNamedHierarchyRole,
                                                            boolean                          _leafNodeOnlySelect = false,
                                                            boolean                          _showActiveNodesOnly = true,
                                                            boolean                          _showCommodityCodeWithName = true,
                                                            EcoResCategorySelectionValidator _ecoResCategorySelectionValidator = null,
                                                            RefRecId                         _buyingLegalEntity = 0,
                                                            RefRecId                         _receivingOperatingUnit = 0,
                                                            ProcCategoryOrganizationOption   _organizationOption = _receivingOperatingUnit
                                                                                    ? ProcCategoryOrganizationOption::BuyingLegalEntityAndCombination
                                                                                    : ProcCategoryOrganizationOption::BuyingLegalEntity,
                                                            RecId                            _purchAgreementHeaderRecId = 0)

    {
        EcoResCategoryHierarchyRole ecoResCategoryHierarchyRole;
        EcoResCategoryHierarchy     ecoResCategoryHierarchy;
        EcoResCategory              retCategory = null;

        ecoResCategoryHierarchyRole = EcoResCategoryHierarchyRole::getHierarchiesByRole(_ecoResCategoryNamedHierarchyRole);
        ecoResCategoryHierarchy     = EcoResCategoryHierarchy::find(ecoResCategoryHierarchyRole.CategoryHierarchy);

        if (ecoResCategoryHierarchyRole && ecoResCategoryHierarchy.RecId)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                retCategory = EcoResCategory::lookupCategoryHierarchy(_formReferenceControl,
                                    ecoResCategoryHierarchy,
                                    _leafNodeOnlySelect,
                                    _showActiveNodesOnly,
                                    _showCommodityCodeWithName,
                                    _ecoResCategorySelectionValidator,
                                    _buyingLegalEntity,
                                    _receivingOperatingUnit,
                                    _organizationOption,
                                    _purchAgreementHeaderRecId);
            }
            else
            {
                retCategory = EcoResCategory::lookupCategoryHierarchy(_formReferenceControl,
                                                                     ecoResCategoryHierarchy,
                                                                     _leafNodeOnlySelect,
                                                                     _showActiveNodesOnly,
                                                                     _showCommodityCodeWithName,
                                                                     _ecoResCategorySelectionValidator,
                                                                     _buyingLegalEntity,
                                                                     _receivingOperatingUnit,
                                                                     _organizationOption);
            }
        }
        else
        {
            throw(error(strFmt("@SYS135043", _ecoResCategoryNamedHierarchyRole)));
        }

        return retCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupDefaultProjectGlobalCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a lookup functionality for a project category.
    /// </summary>
    /// <param name="_formReferenceControl">
    /// The calling form reference control.
    /// </param>
    /// <returns>
    /// The record in the <c>SharedCategory</c> table that is selected in the lookup.
    /// </returns>
    public static Common lookupDefaultProjectGlobalCategory(FormReferenceControl _formReferenceControl)
    {
        SysReferenceTableLookup sysReferenceTableLookup;
        Query                   query;
        QueryBuildDataSource    qbdsGlobalCategory;
        QueryBuildDataSource    qbdsCategoryTable;
        QueryBuildDataSource    qbdsProjCategory;

        sysReferenceTableLookup = SysReferenceTableLookup::newParameters(tableNum(SharedCategory), _formReferenceControl);
        sysReferenceTableLookup.addLookupfield(fieldNum(SharedCategory, CategoryId));
        sysReferenceTableLookup.addLookupfield(fieldNum(SharedCategory, CategoryName));

        query = new Query();
        query.allowCrossCompany(true);

        qbdsGlobalCategory = query.addDataSource(tableNum(SharedCategory));

        qbdsCategoryTable = qbdsGlobalCategory.addDataSource(tableNum(CategoryTable));
        qbdsCategoryTable.joinMode(JoinMode::ExistsJoin);
        qbdsCategoryTable.addLink(fieldNum(SharedCategory, RecId), fieldNum(CategoryTable, SharedCategory));
        qbdsCategoryTable.addRange(fieldNum(CategoryTable, UseInProject)).value(queryValue(NoYes::Yes));

        qbdsProjCategory = qbdsCategoryTable.addDataSource(tableNum(ProjCategory));
        qbdsProjCategory.joinMode(JoinMode::InnerJoin);
        qbdsProjCategory.addLink(fieldNum(CategoryTable, DataAreaId), fieldNum(ProjCategory, DataAreaId));
        qbdsProjCategory.addLink(fieldNum(CategoryTable, CategoryId), fieldNum(ProjCategory, CategoryId));
        qbdsProjCategory.addRange(fieldNum(ProjCategory, SetupSubscription)).value(queryValue(NoYes::No));
        qbdsProjCategory.addRange(fieldNum(ProjCategory, SetupEstimate)).value(queryValue(NoYes::No));
        qbdsProjCategory.addRange(fieldNum(ProjCategory, PSACustPaymentRetention)).value(queryValue(NoYes::No));
        qbdsProjCategory.addRange(fieldNum(ProjCategory, PSAIndirectComponent)).value(queryValue(NoYes::No));
        // Using !ProjCategoryType::Revenue is creating invalid query statement - "CategoryType = 0"
        // qbdsProjCategory.addRange(fieldNum(ProjCategory, CategoryType)).value(queryValue(!ProjCategoryType::Revenue));
        // Use OR statement for CategoryType to work around the invalid constraint which was created
        qbdsProjCategory.addRange(fieldNum(ProjCategory, CategoryType)).value(queryValue(ProjCategoryType::Hour));
        qbdsProjCategory.addRange(fieldNum(ProjCategory, CategoryType)).value(queryValue(ProjCategoryType::Cost));
        qbdsProjCategory.addRange(fieldNum(ProjCategory, CategoryType)).value(queryValue(ProjCategoryType::Item));

        sysReferenceTableLookup.parmQuery(query);

        return sysReferenceTableLookup.performFormLookup() as SharedCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildNestedSetTree</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the value of the <c>NestedSetRight</c> and <c>NestedSetLeft</c> fields by using
    /// information from the <c>ParentCategory</c> field.
    /// </summary>
    /// <param name="_ecoResCategoryHierarchyId">
    /// The category hierarchy ID for which to retrieve of the record in the <c>EcoResCategoryHierarchy</c>
    /// table.
    /// </param>
    /// <remarks>
    /// This method can be called to rebuild the nested set values. Before running this method, you must
    /// disable the unique index on the values of the <c>NestedSetRight</c> and <c>NestedSetLeft</c> fields.
    /// </remarks>
    public static void rebuildNestedSetTree(EcoResCategoryHierarchyId _ecoResCategoryHierarchyId)
    {
        EcoResCategoryNestedSetModelRebuilder::construct().rebuildNestedSetTree(_ecoResCategoryHierarchyId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveCategoryHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and displays a lookup from which the user can select a category ID from a specified
    /// category hierarchy.
    /// </summary>
    /// <param name="_formReferenceControl">
    /// The calling form reference control.
    /// </param>
    /// <param name="_ecoResCategoryHierarchy">
    /// An <c>EcoResCategoryHierarchy</c> table record that indicates the category hierarchy from which to
    /// fetch categories.
    /// </param>
    /// <param name="_leafNodeOnlySelect">
    /// A Boolean value that indicates whether only the leaf categories are selectable; optional.
    /// </param>
    /// <param name="_showActiveNodesOnly">
    /// A Boolean value that indicates whether only the active categories are shown in the tree view or
    /// not; optional.
    /// </param>
    /// <param name="_showCommodityCodeWithName">
    /// A Boolean value that indicates whether to show the commodity code and the category name in the tree
    /// view; optional.
    /// </param>
    /// <param name="_ecoResCategorySelectionValidator">
    /// An object that implements the <c>EcoResCategorySelectionValidator</c> interface that is used for
    /// validating the category selection; optional.
    /// </param>
    /// <param name="_buyingLegalEntity">
    /// The legal entity reference record ID in the <c>CompanyInfo</c> table for which the category
    /// availability can be retrieved; optional.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    /// The operating unit reference rec ID in the <c>OMOperatingUnit</c> table for which the category
    /// availability can be retrieved; optional.
    /// </param>
    /// <param name="_organizationOption">
    /// The <c>ProcCategoryOrganizationOption</c> enumeration gives an option to the user to find the
    /// category ID.
    /// </param>
    /// <returns>
    /// The selected record for record mode selection; otherwise null.
    /// </returns>
    /// <remarks>
    /// The category ID can be found by buying the legal entity, which considers only buying the legal
    /// entity, by receiving the operating unit, which considers buying the legal entity and receiving the
    /// operating unit, and by both, which considers both buying the legal entity, and buying the legal
    /// entity and receiving the operating unit combined.
    /// </remarks>
    public static Common resolveCategoryHierarchy(FormReferenceControl             _formReferenceControl,
                                                         EcoResCategoryHierarchy          _ecoResCategoryHierarchy,
                                                         boolean                          _leafNodeOnlySelect = false,
                                                         boolean                          _showActiveNodesOnly = true,
                                                         boolean                          _showCommodityCodeWithName = true,
                                                         EcoResCategorySelectionValidator _ecoResCategorySelectionValidator = null,
                                                         RefRecId                         _buyingLegalEntity = 0,
                                                         RefRecId                         _receivingOperatingUnit = 0,
                                                         ProcCategoryOrganizationOption   _organizationOption = _receivingOperatingUnit
                                                                                                                ? ProcCategoryOrganizationOption::BuyingLegalEntityAndCombination
                                                                                                                : ProcCategoryOrganizationOption::BuyingLegalEntity)

    {
        EcoResCategoryName  ecoResCategoryName;
        EcoResCategory      ecoResCategory =  null;

        if (!_formReferenceControl || _formReferenceControl.handle() != classNum(FormReferenceGroupControl) )
        {
            throw(error(strFmt("@SYS137393", Error::wrongUseOfFunction(funcName())) ));
        }

        if (!_ecoResCategoryHierarchy || !_ecoResCategoryHierarchy.RecId)
        {
            throw(error(strFmt("@SYS137392", Error::wrongUseOfFunction(funcName())) ));
        }

        ecoResCategoryName = _formReferenceControl.filterValue(AbsoluteFieldBinding::construct(fieldStr(EcoResCategory, Name), tableStr(EcoResCategory))).value();
        ecoResCategoryName = strLRTrim(ecoResCategoryName);

        ecoResCategory = EcoResCategory::findByName(ecoResCategoryName, _ecoResCategoryHierarchy.RecId);

        if ( ecoResCategory
                && (ecoResCategory.IsActive || !_showActiveNodesOnly)
                && (ecoResCategory.isLeaf() || !_leafNodeOnlySelect)
                && EcoResCategory::getProcCategoryAvailability(ecoResCategory.RecId, _buyingLegalEntity, _receivingOperatingUnit, _organizationOption ) )
        {
            if (!_ecoResCategorySelectionValidator || _ecoResCategorySelectionValidator.canSelectCategory(ecoResCategory) )
            {
                return ecoResCategory;
            }
        }

        // Return NULL directly so the kernel knows that the intent is to not clear the selected value.
        // Do not assign null to a record as it does not cause the kernel to receive a true NULL value, but rather
        // just an empty record.
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveCategoryHierarchyRole</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resolves a reference to a category name and finds a unique match or displays a lookup from which
    /// the user can select a category ID from a specified category hierarchy role.
    /// </summary>
    /// <param name="_formReferenceControl">
    /// The calling form reference control.
    /// </param>
    /// <param name="_ecoResCategoryNamedHierarchyRole">
    /// An <c>EcoResCategoryNamedHierarchyRole</c> enumeration value that indicates the category hierarchy
    /// from which to fetch categories.
    /// </param>
    /// <param name="_leafNodeOnlySelect">
    /// A Boolean value that indicates whether only the leaf categories are selectable; optional.
    /// </param>
    /// <param name="_showActiveNodesOnly">
    /// A Boolean value that indicates whether only the active categories are shown in the tree view or
    /// not; optional.
    /// </param>
    /// <param name="_showCommodityCodeWithName">
    /// A Boolean value that indicates whether to show the commodity code and the category name in the tree
    /// view; optional.
    /// </param>
    /// <param name="_ecoResCategorySelectionValidator">
    /// An object that implements the <c>EcoResCategorySelectionValidator</c> interface that is used for
    /// validating the category selection; optional.
    /// </param>
    /// <param name="_buyingLegalEntity">
    /// The legal entity reference record ID) in the <c>CompanyInfo</c> table for which the category
    /// availability can be retrieved; optional.
    /// </param>
    /// <param name="_receivingOperatingUnit">
    /// The operating unit reference record ID in the <c>OMOperatingUnit</c> table for which the category
    /// availability can be retrieved; optional.
    /// </param>
    /// <param name="_organizationOption">
    /// The <c>ProcCategoryOrganizationOption</c> enumeration gives an option to the user to find the
    /// category ID.
    /// </param>
    /// <returns>
    /// The selected record for record mode selection; otherwise null.
    /// </returns>
    /// <remarks>
    /// The category ID can be found by buying the legal entity, which considers only buying the legal
    /// entity, by receiving the operating unit, which considers buying the legal entity and receiving the
    /// operating unit, and by both, which considers both buying the legal entity, and buying the legal
    /// entity and receiving the operating unit combined.
    /// </remarks>
    public static EcoResCategory resolveCategoryHierarchyRole(
                            FormReferenceControl             _formReferenceControl,
                            EcoResCategoryNamedHierarchyRole _ecoResCategoryNamedHierarchyRole,
                            boolean                          _leafNodeOnlySelect         = false,
                            boolean                          _showActiveNodesOnly        = true,
                            boolean                          _showCommodityCodeWithName  = true,
                            EcoResCategorySelectionValidator _ecoResCategorySelectionValidator = null,
                            RefRecId                         _buyingLegalEntity = 0,
                            RefRecId                         _receivingOperatingUnit = 0,
                            ProcCategoryOrganizationOption   _organizationOption = _receivingOperatingUnit
                                                                                    ? ProcCategoryOrganizationOption::BuyingLegalEntityAndCombination
                                                                                    : ProcCategoryOrganizationOption::BuyingLegalEntity)

    {
        EcoResCategoryHierarchyRole ecoResCategoryHierarchyRole;
        EcoResCategoryHierarchy     ecoResCategoryHierarchy;
        EcoResCategory              retCategory = null;

        ecoResCategoryHierarchyRole = EcoResCategoryHierarchyRole::getHierarchiesByRole(_ecoResCategoryNamedHierarchyRole);
        ecoResCategoryHierarchy = EcoResCategoryHierarchy::find(ecoResCategoryHierarchyRole.CategoryHierarchy);
        if (ecoResCategoryHierarchyRole && ecoResCategoryHierarchy.RecId)
        {
            retCategory = EcoResCategory::resolveCategoryHierarchy(
                    _formReferenceControl,
                    ecoResCategoryHierarchy,
                    _leafNodeOnlySelect,
                    _showActiveNodesOnly,
                    _showCommodityCodeWithName,
                    _ecoResCategorySelectionValidator,
                    _buyingLegalEntity,
                    _receivingOperatingUnit,
                    _organizationOption);
        }
        else
        {
            throw(error(strFmt("@SYS135043", _ecoResCategoryNamedHierarchyRole)));
        }

        if (retCategory.RecId)
        {
            return retCategory;
        }
        else
        {
            // Return NULL directly so the kernel knows that the intent is to not clear the selected value.
            // Do not assign null to a record as it does not cause the kernel to receive a true NULL value, but rather
            // just an empty record.
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveDefaultProjectGlobalCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a record in the <c>SharedCategory</c> table that is referenced in the project category's
    /// form reference control.
    /// </summary>
    /// <param name="_formReferenceControl">
    /// The calling form reference control.
    /// </param>
    /// <returns>
    /// The <c>SharedCategory</c> record that is referenced in the form reference control.
    /// </returns>
    public static Common resolveDefaultProjectGlobalCategory(FormReferenceControl _formReferenceControl)
    {
        SharedCategory   sharedCategory;
        SharedCategoryId sharedCategoryId;

        sharedCategoryId = _formReferenceControl.filterValue(AbsoluteFieldBinding::construct(fieldStr(SharedCategory, CategoryId), tableStr(SharedCategory))).value();

        select firstonly sharedCategory where sharedCategory.CategoryId == sharedCategoryId;

        if (sharedCategory.RecId == 0)
        {
            return null;
        }

        return sharedCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCategoryRangeBasedOnInheritance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds ranges based on the complete inheritance of the specified category.
    /// </summary>
    /// <param name="_formDataSource">
    ///    The data source that contains the <c>EcoResCategory</c> table.
    /// </param>
    /// <param name="_category">
    ///    The category for which to find the inheritance
    /// </param>
    /// <param name="_inheritanceFieldId">
    ///    The field column for which to find the inheritance.
    /// </param>
    public static void setCategoryRangeBasedOnInheritance(FormDataSource _formDataSource,
                                                                EcoResCategory _category,
                                                                fieldId _inheritanceFieldId)
    {
        QueryBuildDataSource    qbds = _formDataSource.query().dataSourceTable(tableNum(EcoResCategory));
        EcoResCategory          tmpNearestStopInheritAncestor;

        if (qbds)
        {
            if (NoYes::No == _category.(_inheritanceFieldId))
            {
                qbds.addRange(fieldNum(EcoResCategory,RecId)).value(queryValue(_category.RecId));
            }
            else
            {
                tmpNearestStopInheritAncestor = EcoResCategory::getNearestAncestorWithNoInheritance(_category);
                qbds.addRange(fieldNum(EcoResCategory,CategoryHierarchy)).value(queryValue(_category.CategoryHierarchy));
                qbds.addRange(fieldNum(EcoResCategory,NestedSetLeft)).value(queryRange(tmpNearestStopInheritAncestor.NestedSetLeft, _category.NestedSetLeft));
                qbds.addRange(fieldNum(EcoResCategory,NestedSetRight)).value(queryRange(_category.NestedSetRight, tmpNearestStopInheritAncestor.NestedSetRight));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the message to use when a specific record in the <c>EcoResCategory</c> table does not exist.
    /// </summary>
    /// <returns>
    /// The message that states a record does not exist.
    /// </returns>
    public static str txtNotExist()
    {
        return "@SYS327065";
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>EcoResCategory</c> table by commodity code.
    /// </summary>
    /// <param name="_code">
    /// The commodity code of the record to find.
    /// </param>
    /// <param name="_commodityHierarchyId">
    /// The commodity hierarchy id; optional.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>EcoResCategory</c> table; otherwise, an empty record.
    /// </returns>
    public static EcoResCategory findByCode(EcoResCategoryCommodityCode _code,
        EcoResCategoryHierarchyId _commodityHierarchyId,
        boolean _forUpdate = false)
    {
        EcoResCategory category;

        if (_code && _commodityHierarchyId)
        {
            category.selectForUpdate(_forUpdate);

            select firstonly category
                where category.CategoryHierarchy == _commodityHierarchyId
                    && category.Code == _code;
        }

        return category;
    }

]]></Source>
			</Method>
			<Method>
				<Name>commodityCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the commodity code from the category.
    /// </summary>
    /// <param name="_categoryId">
    /// The record ID of the category.
    /// </param>
    /// <returns>
    /// Commodity code.
    /// </returns>
    public static EcoResCategoryCommodityCode commodityCode(EcoResCategoryId _categoryId)
    {
        return EcoResCategory::find(_categoryId).code;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryReferencePrompt</Name>
				<Source><![CDATA[
    private boolean categoryReferencePrompt()
    {
        boolean ret;

        if (EcoResCategoryHierarchyRole::existRoleHierarchyPair(EcoResCategoryNamedHierarchyRole::Procurement, this.CategoryHierarchy))           
        {
            ret = Box::YesNo("@SCM:CheckCategoryReferencePrompt", DialogButton::Yes) == DialogButton::Yes;
        }
        else if (EcoResCategoryCheckSalesCategoryReferenceBeforeDeletionFlight::instance().isEnabled()
            && EcoResCategoryHierarchyRole::existRoleHierarchyPair(EcoResCategoryNamedHierarchyRole::Sales, this.CategoryHierarchy))
        {
            ret = Box::YesNo("@SCM:CheckSalesCategoryReferencePrompt", DialogButton::Yes) == DialogButton::Yes;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCategoryReference</Name>
				<Source><![CDATA[
    private void validateCategoryReference(EcoResCategoryId _categoryRecId)
    {
        if (EcoResCategoryHierarchyRole::existRoleHierarchyPair(EcoResCategoryNamedHierarchyRole::Procurement, this.CategoryHierarchy))
        {
            this.validateNoPurchaseLineProcurementCategoryReference(_categoryRecId);
            this.validateNoPurchaseRequsitionLineProcurementCategoryReference(_categoryRecId);            
            this.validateNoPurchaseRFQCaseLineProcurementCategoryReference(_categoryRecId);
            this.validateNoPurchaseRFQLineProcurementCategoryReference(_categoryRecId);
            this.validateNoPurchaseAgreementLineProcurementCategoryReference(_categoryRecId);
        }
        else if (EcoResCategoryCheckSalesCategoryReferenceBeforeDeletionFlight::instance().isEnabled()
            && EcoResCategoryHierarchyRole::existRoleHierarchyPair(EcoResCategoryNamedHierarchyRole::Sales, this.CategoryHierarchy))
        {
            this.validateNoSalesLineSalesCategoryReference(_categoryRecId);
            this.validateNoSalesAgreementLineSalesCategoryReference(_categoryRecId);
            this.validateNoSalesQuotationLineSalesCategoryReference(_categoryRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoSalesQuotationLineSalesCategoryReference</Name>
				<Source><![CDATA[
    private void validateNoSalesQuotationLineSalesCategoryReference(EcoResCategoryId _categoryRecId)
    {
        SalesQuotationLine salesQuotationLine;
        select firstonly SalesCategory from salesQuotationLine
            where salesQuotationLine.SalesCategory == _categoryRecId
            && salesQuotationLine.QuotationStatus != SalesQuotationStatus::Cancelled;

        if (salesQuotationLine.SalesCategory)
        {
            throw error(strFmt("@SYS128564", tableStr(EcoResCategory), tableStr(SalesQuotationLine)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoSalesLineSalesCategoryReference</Name>
				<Source><![CDATA[
    private void validateNoSalesLineSalesCategoryReference(EcoResCategoryId _categoryRecId)
    {
        SalesLine salesLine;
        select firstonly SalesCategory from salesLine
            where salesLine.SalesCategory == _categoryRecId
            && salesLine.SalesStatus != SalesStatus::None
            && salesLine.SalesStatus != SalesStatus::Canceled;

        if (salesLine.SalesCategory)
        {
            throw error(strFmt("@SYS128564", tableStr(EcoResCategory), tableStr(SalesLine)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoSalesAgreementLineSalesCategoryReference</Name>
				<Source><![CDATA[
    private void validateNoSalesAgreementLineSalesCategoryReference(EcoResCategoryId _categoryRecId)
    {
        AgreementLine           salesAgreementLine;
        SalesAgreementHeader    salesAgreementHeader;
        
        select firstonly Category from salesAgreementLine
            join salesAgreementHeader
            where salesAgreementHeader.RecId == salesAgreementLine.Agreement
            && salesAgreementLine.Category   == _categoryRecId
            && salesAgreementLine.ExpirationDate >= DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone())
            && (   salesAgreementLine.AgreementLineType == CommitmentType::ProductCategory
                || salesAgreementLine.AgreementLineType == CommitmentType::ProductRootCategory);
                  
        if (salesAgreementLine.Category)
        {
            throw error(strFmt("@SYS128564", tableStr(EcoResCategory), tableStr(AgreementLine)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoPurchaseLineProcurementCategoryReference</Name>
				<Source><![CDATA[
    private void validateNoPurchaseLineProcurementCategoryReference(EcoResCategoryId _categoryRecId)
    {
        PurchLine purchLine;
        select firstonly ProcurementCategory from purchLine
            where purchLine.ProcurementCategory == _categoryRecId
              && (   purchLine.PurchStatus == PurchStatus::Backorder
                  || purchLine.PurchStatus == PurchStatus::Received);

        if (purchLine.ProcurementCategory)
        {
            throw error(strFmt("@SYS128564", tableStr(EcoResCategory), tableStr(PurchLine)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoPurchaseRequsitionLineProcurementCategoryReference</Name>
				<Source><![CDATA[
    private void validateNoPurchaseRequsitionLineProcurementCategoryReference(EcoResCategoryId _categoryRecId)
    {
        PurchReqLine purchReqLine;
        select firstonly ProcurementCategory from purchReqLine
            where purchReqLine.ProcurementCategory == _categoryRecId
              && (   purchReqLine.RequisitionStatus == PurchReqRequisitionStatus::Draft
                  || purchReqLine.RequisitionStatus == PurchReqRequisitionStatus::InReview
                  || purchReqLine.RequisitionStatus == PurchReqRequisitionStatus::Approved);

        if (purchReqLine.ProcurementCategory)
        {
            throw error(strFmt("@SYS128564", tableStr(EcoResCategory), tableStr(PurchReqLine)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoPurchaseRFQLineProcurementCategoryReference</Name>
				<Source><![CDATA[
    private void validateNoPurchaseRFQLineProcurementCategoryReference(EcoResCategoryId _categoryRecId)
    {
        PurchRFQLine purchRFQLine;

        select firstonly CategoryId from purchRFQLine
            where purchRFQLine.CategoryId == _categoryRecId
              && (   purchRFQLine.Status == PurchRFQStatus::Created
                  || purchRFQLine.Status == PurchRFQStatus::Received
                  || purchRFQLine.Status == PurchRFQStatus::Sent);

        if (purchRFQLine.CategoryId)
        {
            throw error(strFmt("@SYS128564", tableStr(EcoResCategory), tableStr(PurchRFQLine)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoPurchaseRFQCaseLineProcurementCategoryReference</Name>
				<Source><![CDATA[
    private void validateNoPurchaseRFQCaseLineProcurementCategoryReference(EcoResCategoryId _categoryRecId)
    {
        PurchRFQCaseLine purchRFQCaseLine;

        select firstonly CategoryId from purchRFQCaseLine
            where purchRFQCaseLine.CategoryId == _categoryRecId
              && (   purchRFQCaseLine.StatusHigh == PurchRFQStatus::Created
                  && purchRFQCaseLine.StatusLow  == PurchRFQStatus::Created);

        if (purchRFQCaseLine.CategoryId)
        {
            throw error(strFmt("@SYS128564", tableStr(EcoResCategory), tableStr(PurchRFQCaseLine)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoPurchaseAgreementLineProcurementCategoryReference</Name>
				<Source><![CDATA[
    private void validateNoPurchaseAgreementLineProcurementCategoryReference(EcoResCategoryId _categoryRecId)
    {
        AgreementLine           purchAgreementLine;
        PurchAgreementHeader    purchAgreementHeader;
        
        select firstonly Category from purchAgreementLine
            join purchAgreementHeader
            where purchAgreementHeader.RecId == purchAgreementLine.Agreement
            && purchAgreementLine.Category   == _categoryRecId
            && purchAgreementLine.ExpirationDate >= DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone())
            && (   purchAgreementLine.AgreementLineType == CommitmentType::ProductCategory
                || purchAgreementLine.AgreementLineType == CommitmentType::ProductRootCategory);
                  
        if (purchAgreementLine.Category)
        {
            throw error(strFmt("@SYS128564", tableStr(EcoResCategory), tableStr(AgreementLine)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupCategoryForVendorAccount</Name>
				<Source><![CDATA[
    public static Common lookupCategoryForVendorAccount(FormReferenceControl _formReferenceControl,
                                                        VendAccount _vendAccount)
    {
        SysReferenceTableLookup sysReferenceTableLookup;
        Query query = new Query();
        QueryBuildDataSource ecoResCategoryDS, vendCategoryDS, vendProcurementCategoryStatusDS;
        date currentDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());

        sysReferenceTableLookup = SysReferenceTableLookup::newParameters(tableNum(EcoResCategory), _formReferenceControl, true);

        ecoResCategoryDS = query.addDataSource(tableNum(EcoResCategory));

        vendCategoryDS = ecoResCategoryDS.addDataSource(tableNum(VendCategory));
        vendCategoryDS.relations(true);
        vendCategoryDS.addRange(fieldNum(VendCategory, VendorAccount)).value(SysQuery::value(_vendAccount));
        vendCategoryDS.addRange(fieldNum(VendCategory, VendorDataArea)).value(SysQuery::value(curExt()));

        vendProcurementCategoryStatusDS = vendCategoryDS.addDataSource(tableNum(VendProcurementCategoryStatus));
        vendProcurementCategoryStatusDS.relations(true);
        vendProcurementCategoryStatusDS.addRange(fieldNum(VendProcurementCategoryStatus, ValidFrom)).value(
            strFmt('%1.%2 <= %3', vendProcurementCategoryStatusDS.name(), fieldStr(VendProcurementCategoryStatus, ValidFrom), currentDate));
        vendProcurementCategoryStatusDS.addRange(fieldNum(VendProcurementCategoryStatus, ValidTo)).value(
            strFmt('%1.%2 >= %3', vendProcurementCategoryStatusDS.name(), fieldStr(VendProcurementCategoryStatus, ValidTo), currentDate));

        sysReferenceTableLookup.addLookupfield(fieldNum(EcoResCategory, Name));
        sysReferenceTableLookup.parmQuery(query);

        return sysReferenceTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirmRetailCategoryDeletion</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Launches confirmation dialog box with respective warning message while user trying to remove any category in retail hierarchies .
    /// </summary>
    /// <param name="_categoryHierarchy">
    /// The category hierarchy in the <c>EcoResCategory</c> table.
    /// </param>
    /// <returns>True if user confirms to delete; otherwise false.</returns>
    private boolean confirmRetailCategoryDeletion(EcoResCategoryHierarchyId _categoryHierarchy)
    {
        DialogButton dialogButton;
        boolean canDelete;

        if (EcoResCategoryHierarchyRole::existRoleHierarchyPair(EcoResCategoryNamedHierarchyRole::RetailChannelNavigation, _categoryHierarchy))
        {
            dialogButton = Box::yesNo("@Retail:RemoveNavigationHierarchyCategoryWarning", DialogButton::No);
            canDelete = (dialogButton == DialogButton::Yes);
        }
        else if (EcoResCategoryHierarchyRole::existRoleHierarchyPair(EcoResCategoryNamedHierarchyRole::Retail, _categoryHierarchy)
              || EcoResCategoryHierarchyRole::existRoleHierarchyPair(EcoResCategoryNamedHierarchyRole::RetailSpecialGroup, _categoryHierarchy))
        {
            dialogButton = Box::yesNo("@Retail:RemoveCommerceProductOrSupplementalHierarchyCategoryWarning", DialogButton::No);
            canDelete = (dialogButton == DialogButton::Yes);
        }
        else 
        {
            canDelete = true;
        }

        return canDelete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMaxCountOfCategoryInCategoryHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the maximum number of categories and throw warning if the categories are created more than 1000 for category hierarchy.
    /// </summary>
    /// <param name="_currentSelectedCategoryHierarchyRecId">
    /// Recid of current selected record of table buffer EcoResCategoryHierarchy.
    /// </param>
    internal static void validateMaxCountOfCategoryInCategoryHierarchy(RefRecId _currentSelectedCategoryHierarchyRecId)
    {
        int categoryMaxCount = 1000;
        EcoResCategory ecoResCategory;
        RetailOnlineChannelTable retailOnlineChannelTable;

        select firstonly RecId from retailOnlineChannelTable
            where retailOnlineChannelTable.CategoryHierarchy == _currentSelectedCategoryHierarchyRecId;

        if (!retailOnlineChannelTable)
        {
            return;
        }

        EcoResCategoryHierarchyRole hierarchyRole = EcoResCategoryHierarchyRole::findRoleHierarchyPair(EcoResCategoryNamedHierarchyRole::RetailChannelNavigation, _currentSelectedCategoryHierarchyRecId);

        if (!hierarchyRole)
        {
            return;
        }

        select count(RecId) from ecoResCategory
            where ecoResCategory.CategoryHierarchy == hierarchyRole.CategoryHierarchy;

        if (ecoResCategory.RecId >= categoryMaxCount)
        {
            warning(strFmt("@Retail:RetailMaxCategoriesWarningForCategoryHierarchy", EcoResCategoryHierarchy::find(_currentSelectedCategoryHierarchyRecId).Name));
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LogisticsBasic</ConfigurationKey>
	<DeveloperDocumentation>@SYS309798</DeveloperDocumentation>
	<FormRef>EcoResCategoryHierarchyDetails</FormRef>
	<Label>@SYS134266</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>Name</TitleField1>
	<TitleField2>Code</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>FoundAndEmpty</CacheLookup>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<InstanceRelationType>InstanceRelationType</InstanceRelationType>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>ProductInformationManagement</Modules>
	<ReplacementKey>NameIdx</ReplacementKey>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<SupportInheritance>Yes</SupportInheritance>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>AssetRuleEcoResCategory</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>AssetRuleEcoResCategory</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CatDisplayCategorySharedInfo</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CatDisplayCategorySharedInfo</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResCategoryAttribute</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResCategoryAttribute</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResCategoryInstanceValue</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResCategoryInstanceValue</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResCategoryTranslation</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResCategoryTranslation</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResProductCategory</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>EcoResProductCategory</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProcCategoryAccessPolicyParameter</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>ProcCategoryAccessPolicyParameter</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProcCategoryCharterPagePolicy</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>ProcCategoryCharterPagePolicy</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProcCategoryCommodityCode</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>ProcCategoryCommodityCode</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProcCategoryItemTaxGroup</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>ProcCategoryItemTaxGroup</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProcCategoryModifier</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>ProcCategoryModifier</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProcCategoryPage</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>ProcCategoryPage</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProcCategoryPolicyParameter</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>ProcCategoryPolicyParameter</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProcCategoryQuestionnaire</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>ProcCategoryQuestionnaire</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>PurchReqControlSubmissionParameter</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>PurchReqControlSubmissionParameter</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>VendCategory</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>VendCategory</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>VendReviewCategoryCriterionGroup</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>VendReviewCategoryCriterionGroup</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResCategoryIntrastat</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResCategoryIntrastat</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>EcoResCategoryAttributeGroup</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>EcoResCategoryAttributeGroup</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Code</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsActive</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ChangeStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NestedSetLeft</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NestedSetRight</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Level</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Code</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CategoryTree</Name>
			<Label>@SYS130847</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentCategory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Code</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsActive</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ChangeStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NestedSetLeft</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NestedSetRight</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Level</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsCategoryAttributesInherited</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InstanceRelationType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsTangible</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DisplayOrder</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>DefaultThreshold_PSN</Name>
			<Label>@SPS1794</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultThreshold_PSN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>FilterGroup</Name>
			<Label>@SYS300743</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Code</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsActive</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ChangeStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>NameDescription</Name>
			<Label>@SYS138549</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PKWiUCode</Name>
			<Label>@GLS220219</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PKWiUCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Project</Name>
			<Label>@SYS80304</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultProjectGlobalCategory</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CommodityCode</Name>
			<Label>@SYS8067</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Code</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GST_IN</Name>
			<Label>@TAXGST:GST</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>HSNCodeTable_IN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ServiceAccountingCodeTable_IN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Exempt_IN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NonGST_IN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CategoryHierarchy</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryHierarchyId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ChangeStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS300624</Label>
			<EnumType>EcoResCategoryChangeStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Code</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryCommodityCode</ExtendedDataType>
			<Label>@SYS300623</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultProjectGlobalCategory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Project</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>DefaultThreshold_PSN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CategoryThreshold_PSN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InstanceRelationType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RelationType</ExtendedDataType>
			<Label>@SYS133857</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsActive</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS26201</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsCategoryAttributesInherited</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS300984</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsTangible</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS319083</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Level</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryLevel</ExtendedDataType>
			<Label>@SYS300625</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryName</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>NestedSetLeft</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryNestedSetLeft</ExtendedDataType>
			<Label>@SYS300627</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>NestedSetRight</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryNestedSetRight</ExtendedDataType>
			<Label>@SYS300626</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ParentCategory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EcoResCategoryId</ExtendedDataType>
			<Label>@SYS130838</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PKWiUCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PlPKWiUCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>HSNCodeTable_IN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<HelpText>@TaxGST:EnterHSNCode</HelpText>
			<IsObsolete>Yes</IsObsolete>
			<Label>@TaxGST:HSNCodes</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ServiceAccountingCodeTable_IN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<HelpText>@TaxGST:EnterSAC</HelpText>
			<IsObsolete>Yes</IsObsolete>
			<Label>@TaxGST:SAC</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Exempt_IN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<HelpText>@TaxGST:HelpTextOfExempt</HelpText>
			<IsObsolete>Yes</IsObsolete>
			<Label>@SYS24552</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>NonGST_IN</Name>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
			<Label>@TaxGST:NonGST</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>DisplayOrder</Name>
			<ExtendedDataType>RetailEcoResCategoryDisplayOrder</ExtendedDataType>
			<Label>@Retail:RetailEcoResCategoryDisplayOrder</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ForceFullLookupSync</Name>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldGuid">
			<Name>ExternalId</Name>
			<ExtendedDataType>EcoResProductCategoryExternalId</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>ParentEcoResCategoryIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ParentCategory</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>NestedSetLeftIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>NestedSetLeft</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InstanceRelationType</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>NestedSetRightIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>NestedSetRight</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LevelIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Level</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ModifiedDateTimeIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>modifiedDateTime</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CommodityCode</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Code</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>NameIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>Name</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PartitionCategoryHierarchyIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InstanceRelationType</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DisplayOrderIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ParentCategory</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DisplayOrder</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Name</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>IsActive</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>EcoResCategoryPerfIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CategoryHierarchy</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>IsCategoryAttributesInherited</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>NestedSetLeft</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>NestedSetRight</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Level</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultProjectGlobalCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SharedCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultProjectGlobalCategory</Name>
					<Field>DefaultProjectGlobalCategory</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>EcoResCategoryHierarchy</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>EcoResCategoryHierarchy</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>BelongsTo</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>EcoResCategoryHierarchy_EcoResCategory</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CategoryHierarchy</Name>
					<Field>CategoryHierarchy</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ParentEcoResCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>EcoResCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DerivesFrom</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>EcoResCategory_EcoResCategory</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ParentCategory</Name>
					<Field>ParentCategory</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>HSNCodeTable_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HSNCodeTable_IN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HSNCodeTable_IN</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>HSNCodeTable_IN</Name>
					<Field>HSNCodeTable_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ServiceAccountingCodeTable_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ServiceAccountingCodeTable_IN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ServiceAccountingCodeTable_IN</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ServiceAccountingCodeTable_IN</Name>
					<Field>ServiceAccountingCodeTable_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>