<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkLine</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class WHSWorkLine extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>lastClosedPickLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the last work line  with status Closed of type Pick for a given work Id.
    /// </summary>
    /// <param name = "_workId">A work Id.</param>
    /// <returns>The last work line  with status Closed of type Pick for a given work Id if one exists.</returns>
    public static WHSWorkLine lastClosedPickLine(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by LineNum desc
            where workLine.WorkId == _workId
                && workLine.WorkType == WHSWorkType::Pick
                && workLine.workStatus == WHSWorkStatus::Closed;

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastPickLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the last work line of type Pick for a given work Id.
    /// </summary>
    /// <param name = "_workId">A work Id.</param>
    /// <returns>The last work line  with status Closed of type Pick for a given work Id if one exists.</returns>
    [Hookable(false)]
    internal static WHSWorkLine lastPickLine(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by LineNum desc
            where workLine.WorkId == _workId
                && workLine.WorkType == WHSWorkType::Pick;

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        return super(_fieldIdToCheck);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canWorkLineBeGrouped</Name>
				<Source><![CDATA[
    public boolean canWorkLineBeGrouped(WHSWorkLine _alreadyGroupedWorkLine)
    {
        return this.ItemId == _alreadyGroupedWorkLine.ItemId
            && this.WMSLocationId == _alreadyGroupedWorkLine.WMSLocationId
            && this.InventDimId == _alreadyGroupedWorkLine.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canClearWorkLinesGrouping</Name>
				<Source><![CDATA[
    public boolean canClearWorkLinesGrouping(WHSWorkLine _alreadyGroupedWorkLine)
    {

        return _alreadyGroupedWorkLine.RecId == this.RecId
            || (InventTable::find(_alreadyGroupedWorkLine.ItemId).isItemSerialNumberActivated()
               && WHSReservationHierarchyInventDimUtil::isSerialBelowLocation(InventTable::find(_alreadyGroupedWorkLine.ItemId))
               && WHSInventTable::captureSerial(_alreadyGroupedWorkLine.ItemId) == WHSRFWhenToCapture::Receiving)
            || !this.canWorkLineBeGrouped(_alreadyGroupedWorkLine)
            || _alreadyGroupedWorkLine.OrderCommittedInventDimId != this.OrderCommittedInventDimId
            || (InventTable::find(_alreadyGroupedWorkLine.ItemId).isItemBatchActivated()
                && !this.canBeGroupedByPickedBatchOnHand(_alreadyGroupedWorkLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeGroupedByPickedBatchOnHand</Name>
				<Source><![CDATA[
    private boolean canBeGroupedByPickedBatchOnHand(WHSWorkLine _alreadyGroupedWorkLine)
    {
        InventDim inventDimTo;

        if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(this.WorkId))
        {
            WHSWorkInventoryTransactionDescriptor inventoryTransactionDescriptor = WHSWorkInventoryTransactionQuery::newFromWorkId(_alreadyGroupedWorkLine.WorkId).registeredReceiptByWorkLine(
                _alreadyGroupedWorkLine.LineNum,
                WHSWorkInventoryTransactionQueryParameters::construct().setFirstOnly(true));

            WHSWorkInventoryTransactionDescriptorEnumerator enumerator = inventoryTransactionDescriptor.getEnumerator();

            if (enumerator.moveNext())
            {
                WHSWorkInventoryTransactionDescriptorElement inventoryTransactionDescriptorElement = enumerator.current();

                inventDimTo = inventoryTransactionDescriptorElement.parmInventoryDimensionsDescriptor().convertToInventDim();
            }
        }
        else
        {
            WHSWorkInventTrans workInventTrans;
            InventTrans inventTrans;
            InventTransOrigin inventTransOrigin;

            select firstonly inventDimTo
                    exists join inventTrans
                        where inventTrans.InventDimId == inventDimTo.InventDimId
                    exists join inventTransOrigin
                        where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                    exists join workInventTrans
                        where workInventTrans.InventTransIdTo == inventTransOrigin.InventTransId
                            && workInventTrans.WorkId == _alreadyGroupedWorkLine.WorkId
                            && workInventTrans.LineNum == _alreadyGroupedWorkLine.LineNum;
        }

        if (!inventDimTo.inventBatchId)
        {
            return true;
        }

        InventDim inventDimBatch = this.inventDim();
        inventDimBatch.wmsLocationId = this.wmsLocationId;
        inventDimBatch.inventBatchId = inventDimTo.inventBatchId;
        inventDimBatch = InventDim::findDim(inventDimBatch);

        if (WHSInventOnHand::getWorkPhysicalInventHandlingQty(this.ItemId, inventDimBatch.inventDimId) >= this.QtyRemain)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstOpenOrInProcessPickLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the first work line with status InProcess or Open work line of type Pick for a given work Id.
    /// </summary>
    /// <param name = "_workId">A work Id.</param>
    /// <returns>The first work line with status InProcess or Open work line of type Pick for a given work Id if one exists.</returns>
    public static WHSWorkLine firstOpenOrInProcessPickLine(WHSWorkId _workId)
    {
        return WHSWorkLine::firstOpenOrInProcessLine(_workId, WHSWorkType::Pick);
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstOpenOrInProcessCountLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the first work line with status Open or InProcess of type Count for a given work Id.
    /// </summary>
    /// <param name = "_workId">A work Id.</param>
    /// <returns>The first work line with status InProcess or Open work line of type Pick for a given work Id if one exists.</returns>
    public static WHSWorkLine firstOpenOrInProcessCountLine(WHSWorkId _workId)
    {
        return WHSWorkLine::firstOpenOrInProcessLine(_workId, WHSWorkType::Count);
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstOpenOrInProcessLineForUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the first work line with status Open or InProcess for a given work Id.
    /// Returned work line can be updated.
    /// </summary>
    /// <param name = "_workId">A work Id.</param>
    /// <returns>The first work line with status InProcess or Open work line for a given work Id if one exists.</returns>
    public static WHSWorkLine firstOpenOrInProcessLineForUpdate(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

        workLine.selectForUpdate(true);

        select firstonly workLine
            order by LineNum asc
            where workLine.WorkId			== _workId
                && (workLine.WorkStatus		== WHSWorkStatus::Open
                    || workLine.WorkStatus	== WHSWorkStatus::InProcess);

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstOpenOrInProcessPickOrPutLine</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static WHSWorkLine firstOpenOrInProcessPickOrPutLine(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by LineNum asc
            where workLine.WorkId			== _workId
                && (workLine.WorkType == WHSWorkType::Pick 
                    || workLine.WorkType == WHSWorkType::Put)
                && (workLine.WorkStatus		== WHSWorkStatus::Open
                    || workLine.WorkStatus	== WHSWorkStatus::InProcess);

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>combineWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Combines two compatible work lines.
    /// </summary>
    /// <param name="_combineWorkLine">
    /// The work line being combined onto the target work line.
    /// </param>
    /// <param name="_inventUnitId">
    /// The inventory unit of the item being combined.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Wrong use of function error thrown if work types are not the same.
    /// </exception>
    [Hookable(false)]
    internal void combineWorkLines(WHSWorkLine _combineWorkLine)
    {
        if (appl.ttsLevel() == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        WHSWorkLine         combineWorkLine = _combineWorkLine;
        Qty                 workQty;
    
        if (this.WorkType != _combineWorkLine.WorkType)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
    
        UnitOfMeasureSymbol inventUnitId = combineWorkLine.displayInventUnitId();
         
        // Compare combined workLine fields to see if they need to be cleared out
        if (this.ItemId != combineWorkLine.ItemId)
        {
            this.ItemId = '';
        }
    
        if (this.InventDimId != combineWorkLine.InventDimId)
        {
            this.InventDimId = '';
        }
    
        if (this.LoadId != combineWorkLine.LoadId)
        {
            this.LoadId = '';
        }
    
        if (this.LoadLineRefRecId != combineWorkLine.LoadLineRefRecId)
        {
            this.LoadLineRefRecId = 0;
        }
    
        if (this.InventTransId != combineWorkLine.InventTransId)
        {
            this.InventTransId = '';
        }
    
        if (this.InventTransOriginIdSupply != combineWorkLine.InventTransOriginIdSupply)
        {
            this.InventTransOriginIdSupply = 0;
        }
    
        EcoResReleasedProductUnitConverter unitConverter = EcoResReleasedProductUnitConverter::construct();

        // Increase qty buckets on workLine
        if (unitConverter.canBeConvertedGivenUnitSymbols(inventUnitId,
                                                        this.UnitId,
                                                        combineWorkLine.ItemId,
                                                        combineWorkLine.InventDimId))
        {
            workQty = unitConverter.convertGivenUnitSymbols(combineWorkLine.InventQtyRemain,
                                                            inventUnitId,
                                                            this.UnitId,
                                                            NoYes::No,
                                                            combineWorkLine.ItemId,
                                                            combineWorkLine.InventDimId);
        
            this.QtyRemain    += workQty;
            this.QtyWork      += workQty;
        }
        else
        {
            this.UnitId       = '';
            this.QtyRemain    += combineWorkLine.QtyRemain;
            this.QtyWork      += combineWorkLine.QtyWork;
        }
    
        this.InventQtyRemain  += combineWorkLine.InventQtyRemain;
        this.InventQtyWork    += combineWorkLine.InventQtyWork;
    
        this.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstOpenOrInProcessLine</Name>
				<Source><![CDATA[
    private static WHSWorkLine firstOpenOrInProcessLine(
        WHSWorkId _workId,
        WHSWorkType _workType)
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by LineNum asc
            where workLine.WorkId			== _workId
                && workLine.WorkType		== _workType
                && (workLine.WorkStatus		== WHSWorkStatus::Open
                    || workLine.WorkStatus	== WHSWorkStatus::InProcess);

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastNonPickLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the last work line for the specified work ID which is not a pick line and its status is not cancelled.
    /// </summary>
    /// <param name = "_workId">The work ID</param>
    /// <returns>The last non pick line which is not cancelled</returns>
    [SysObsolete('This method is deprecated and should not be used', false, 31\03\2018)]
    public static WHSWorkLine lastNonPickLine(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by LineNum desc
            where workLine.WorkId       == _workId
                && workLine.WorkType    != WHSWorkType::Pick
                && workLine.WorkStatus  != WHSWorkStatus::Cancelled;

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastClosedWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the last closed work line for the specified work ID.
    /// </summary>
    /// <param name = "_workId">
    /// The work ID.
    /// </param>
    /// <returns>
    /// The last closed work line.
    /// </returns>
    public static WHSWorkLine lastClosedWorkLine(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by LineNum desc
            where workLine.WorkId       == _workId
                && workLine.WorkStatus  == WHSWorkStatus::Closed;

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get last <c>WHSWorkLine</c> record line number of the specified work id.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the <c>WHSWorkLine</c> table.
    /// </param>
    /// <returns>
    /// Last line number of <c>WHSWorkLine</c> record with specified work id.
    /// </returns>
    public static LineNum lastLineNum(WHSWorkId _workId)
    {
        return (select maxOf(LineNum) from WHSWorkLine
                    where WHSWorkLine.WorkId == _workId).LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewLineNumForSplittedWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return new lineNum for splitted <c>WHSWorkLine</c> record.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the <c>WHSWorkLine</c> table.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the <c>WHSWorkLine</c> table.
    /// </param>
    /// <returns>
    /// New line number of <c>WHSWorkLine</c> record with specified work id.
    /// </returns>
    internal static LineNum getNewLineNumForSplittedWorkLine(WHSWorkId _workId, LineNum _lineNum)
    {
        #WHSLineNumSplit

        WHSWorkLine     otherSplitWorkLines;

        select count(RecId) from otherSplitWorkLines 
            where otherSplitWorkLines.WorkId == _workId
               && otherSplitWorkLines.LineNum > roundDown(_lineNum, 1)
               && otherSplitWorkLines.LineNum < roundDown(_lineNum + 1, 1);

        LineNum newLineNum = _lineNum + (#splitTmpWorkLine * (otherSplitWorkLines.RecId + 1));

        return newLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastNotCancelledLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get last not cancelled <c>WHSWorkLine</c> line number of the specified work id.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the <c>WHSWorkLine</c> table.
    /// </param>
    /// <returns>
    /// Last line number of not cancelled <c>WHSWorkLine</c> record with specified work id.
    /// </returns>
    public static LineNum lastNotCancelledLineNum(WHSWorkId _workId)
    {
        return (select maxOf(LineNum) from WHSWorkLine
                    where WHSWorkLine.WorkId     == _workId
                        && WHSWorkLine.WorkStatus != WHSWorkStatus::Cancelled).LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstLineNumWithWorkStatusAfterLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get first <c>WHSWorkLine</c> line number with the specified work status of the specified work id after the specified line number.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the <c>WHSWorkLine</c> table.
    /// </param>
    /// <param name="_workStatus">
    /// Work status of the work lines to find.
    /// </param>
    /// <param name="_afterLineNum">
    /// Line number, after which to search for work lines.
    /// </param>
    /// <returns>
    /// Line number of the first available line with the specified status.
    /// </returns>
    public static LineNum firstLineNumWithWorkStatusAfterLine(WHSWorkId _workId, WHSWorkStatus _workStatus, WHSLineNum _afterLineNum)
    {
        return (select minof(LineNum) from WHSWorkLine
                    where WHSWorkLine.WorkId        == _workId
                        && WHSWorkLine.WorkStatus   == _workStatus
                        && WHSWorkLine.LineNum      > _afterLineNum).LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPutBeforePick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if work has pick work line after put work line.
    /// </summary>
    /// <param name = "_workId">Work id of the <c>WHSWorkLine</c> table.</param>
    /// <returns>true, if work contains pick work line after put work line; otherwise, false.</returns>
    public static boolean hasPutBeforePick(WHSWorkId _workId)
    {
        WHSWorkLine     workLinePick;
        WHSWorkLine     workLinePut;

        select firstonly TableId from workLinePick
        where  workLinePick.WorkId      == _workId
            && (workLinePick.WorkStatus == WHSWorkStatus::Open
            ||  workLinePick.WorkStatus == WHSWorkStatus::InProcess)
            && workLinePick.WorkType    == WHSWorkType::Pick
        exists join workLinePut
        where  workLinePut.WorkId     == _workId
            && (workLinePut.WorkStatus == WHSWorkStatus::Open
            ||  workLinePut.WorkStatus == WHSWorkStatus::InProcess)
            && workLinePut.WorkType   == WHSWorkType::Put
            && workLinePut.LineNum    <  workLinePick.LineNum;

        return workLinePick ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUnFinishedReplenWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if there are any pending replenishment work orders for this work line.
    /// </summary>
    /// <returns>True, if there are still unfinished replenishment orders; otherwise, false.</returns>
    public boolean hasUnFinishedReplenWork()
    {
        WHSReplenWorkLink replenWorkLink;
        WHSWorkTable      replenWorkTable;

        // Can achieve the same with faster query by utilizing Status field on WHSReplenWorkLink.
        // Do not do it until all customers have that column populated with correct value.
        select firstonly RecId from replenWorkTable
            where replenWorkTable.WorkStatus != WHSWorkStatus::Closed
               && replenWorkTable.WorkStatus != WHSWorkStatus::Cancelled
               && replenWorkTable.WorkStatus != WHSWorkStatus::Combined
            exists join replenWorkLink
                where replenWorkLink.ReplenWorkId == replenWorkTable.WorkId
                    && replenWorkLink.DemandWorkId == this.WorkId
                    && replenWorkLink.DemandLineNum == this.LineNum;

        return replenWorkTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventQtyAvailableForReplenishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an inventory quantity which is still available for consumption (not used by permanent replenishment links yet) for current replenishment pick line.
    /// </summary>
    /// <returns>An inventory quantity which is available for consumption.</returns>
    public InventQty getInventQtyAvailableForReplenishment()
    {
        WHSReplenWorkLink sumWorkLink;

        select sum(InventQty) from sumWorkLink
            where sumWorkLink.ReplenWorkId      == this.WorkId
                && sumWorkLink.ReplenLineNum    == this.LineNum
                && sumWorkLink.WorkBuildId      == '';

        return this.InventQtyWork - sumWorkLink.InventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateInventQtyAvailableForReplenishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an inventory quantity which is still available for consumption (not used by permanent or
    ///  temporary replenishment links yet) for current replenishment pick line.
    /// </summary>
    /// <returns>An inventory quantity which is available for consumption.</returns>
    public InventQty calculateInventQtyAvailableForReplenishment()
    {
        WHSReplenWorkLink sumWorkLink;

        select sum(InventQty) from sumWorkLink
        where sumWorkLink.ReplenWorkId      == this.WorkId
            && sumWorkLink.ReplenLineNum    == this.LineNum;

        return this.InventQtyWork - sumWorkLink.InventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateOverPickPutQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the put quantity taking into account possible over pick.
    /// </summary>
    /// <returns>Put quantity in inventory unit.</returns>
    public InventQty calculateOverPickPutQuantity()
    {
        if (this.WorkType != WHSWorkType::Put)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        WHSWorkInventTrans workInventTrans;
        select sum(Qty) from workInventTrans
            where workInventTrans.WorkId        == this.WorkId
                  && workInventTrans.LineNum    == this.LineNum;

        return workInventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayInventUnitId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display unit id of the line.
    /// </summary>
    /// <returns>
    /// The unit id of the line.
    /// </returns>
    public display InventUnitId displayInventUnitId()
    {
        return InventTableModule::find(this.ItemId, ModuleInventPurchSales::Invent).UnitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handlingUnitId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the handling unit id for the current item.
    /// </summary>
    /// <returns>
    /// The handling unit id.
    /// </returns>
    public display InventHandlingUnitId handlingUnitId()
    {
        return WHSCatchWeightHelper::inventHandlingUnitId(this.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayItemName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display item name of the line.
    /// </summary>
    /// <returns>
    /// The item name of the line.
    /// </returns>
    public display ItemName displayItemName()
    {
        return InventTable::find(this.ItemId).itemName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayToLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display to location of the line.
    /// </summary>
    /// <returns>
    /// To location of the line.
    /// </returns>
    public display WMSLocationId displayToLocation()
    {
        return WHSWorkLine::find(this.WorkId, WHSWorkLine::getNextOppositeWorkLine(this.WorkId, this.LineNum, this.WorkType)).wmsLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWHSInventStatusId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display inventory status of the line.
    /// </summary>
    /// <returns>
    /// The inventory status of the line.
    /// </returns>
    public display WHSInventStatusId displayWHSInventStatusId()
    {
        return this.inventDim().InventStatusId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWHSPackingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display packing quantity of the load line.
    /// </summary>
    /// <returns>
    /// The packing quantity of the load line.
    /// </returns>
    public display WHSPackingQty displayWHSPackingQty()
    {
        return WHSLoadLine::findbyRecId(this.LoadLineRefRecId).PackingQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWHSWorkTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display work transaction type of the line.
    /// </summary>
    /// <returns>
    /// The work transaction type of the line.
    /// </returns>
    public display WHSWorkTransType displayWHSWorkTransType()
    {
        return this.whsWorkTable().WorkTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLocationProfileId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds location profile id of the line.
    /// </summary>
    /// <returns>
    /// The location profile id of the line.
    /// </returns>
    public WHSLocProfileId getLocationProfileId()
    {
        WMSLocation     wmsLocation;
        WHSWorkTable    workTable;

        workTable = WHSWorkTable::find(this.WorkId);

        wmsLocation = WMSLocation::find(this.wmsLocationId, workTable.InventLocationId);

        return wmsLocation.LocProfileId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLocType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds location type of the line.
    /// </summary>
    /// <returns>
    /// The location type of the line.
    /// </returns>
    public WHSLocType getLocType()
    {
        WMSLocation         wmsLocation;
        WHSWorkTable        workTable;
        WHSLocationProfile  locationProfile;

        workTable = WHSWorkTable::find(this.WorkId);

        select firstonly LocType from locationProfile
            join wmsLocationId, InventLocationId, LocProfileId from wmsLocation
            where wmsLocation.wmsLocationId         == this.wmsLocationId           &&
                  wmsLocation.InventLocationId      == workTable.InventLocationId   &&
                  wmsLocation.LocProfileId       == locationProfile.LocProfileId;

        return locationProfile.LocType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the related load line record from the work line.
    /// </summary>
    /// <param name="_forUpdate">Select record for update?</param>
    /// <returns>
    /// The load line of the line.
    /// </returns>
    private WHSLoadLine retrieveLoadLine(boolean _forUpdate = false)
    {
        WHSLoadLine loadLine;

        if (!this.LoadLineRefRecId
            && this.WorkType == WHSWorkType::Pick
            && WhsWorkTransactionType::singletonFromTypeOrDefault(this.whsWorkTable().WorkTransType).isForExternalInboundShipment()
            && !WHSWorkLine::isPutBefore(this.WorkId, this.LineNum))
        {
            WHSWorkLine putWorkLine = WHSWorkLine::find(this.WorkId, WHSWorkLine::getNextOppositeWorkLine(this.WorkId, this.LineNum, this.WorkType));
            loadLine = WHSLoadLine::findbyRecId(putWorkLine.LoadLineRefRecId, _forUpdate);
        }
        else
        {
            loadLine = WHSLoadLine::findbyRecId(this.LoadLineRefRecId, _forUpdate);
        }

        return loadLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasDimTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the workline has related dimTracking records.
    /// </summary>
    /// <returns>
    /// true if the workline has related dimTracking records; otherwise, false.
    /// </returns>
    public boolean hasDimTracking()
    {
        return (select firstonly RecId from whsDimTracking
                    where whsDimTracking.WorkId     == this.WorkId
                    &&    whsDimTracking.LineNum    == this.LineNum).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromWorkTemplateLineRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method that initialized fields on a work detail line using a work template line record.
    /// </summary>
    /// <param name="_workTemplateLine">
    /// The work template line record used for initializing data.
    /// </param>
    public void initFromWorkTemplateLineRecord(WHSWorkTemplateLine _workTemplateLine)
    {
        this.WorkType               = _workTemplateLine.WorkType;
        this.WorkStop               = _workTemplateLine.WorkStop;
        this.Mandatory              = _workTemplateLine.Mandatory;
        this.WorkClassId            = _workTemplateLine.WorkClassId;
        this.WorkTemplateLineRecId  = _workTemplateLine.RecId;
        this.WorkTypeCustomCode     = _workTemplateLine.WorkTypeCustomCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    public InventDim inventDim()
    {
        return InventDim::find(this.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimWithLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds dimension with the location specified in the record.
    /// </summary>
    /// <returns>
    /// The <c>InventDim</c> record with the location specified.
    /// </returns>
    public InventDim inventDimWithLocation()
    {
        InventDim   inventDim;

        inventDim = this.inventDim();
        inventDim.wmsLocationId = this.wmsLocationId;
        inventDim = InventDim::findOrCreate(inventDim);

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isActiveInSalesSerialProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if this work line is for sales and the serial number inventory dimension is active for sales process for the item in this work line.
    /// </summary>
    /// <returns>
    /// true if this work line is for sales and the serial number inventory dimension is active for sales process for the item in this work line; otherwise, false
    /// </returns>
    public boolean isActiveInSalesSerialProcess()
    {
        WHSWorkTable workTable = this.whsWorkTable();

        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromTypeOrDefault(workTable.WorkTransType);
        
        return (workTransactionType.isActiveInSalesSerialProcess() || this.isWorkTransTypeSalesCrossDocking(workTable))
              && InventTable::find(this.ItemId).isSalesProcessSerialActive();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkTransTypeSalesCrossDocking</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean isWorkTransTypeSalesCrossDocking(WHSWorkTable _workTable)
    {
        if (this.WorkId != _workTable.WorkId)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_workTable.WorkTransType == WHSWorkTransType::CrossDocking
            && this.WorkType == WHSWorkType::Pick)
        {
            WHSLoadLine loadLine = WHSLoadLine::findbyRecId(this.LoadLineRefRecId);

            return loadLine
                && loadLine.InventTransType == InventTransType::Sales;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSplitLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if this work line has splitted lineNum.
    /// </summary>
    /// <returns>
    /// true if this work line has splitted lineNum; otherwise, false
    /// </returns>
    internal protected boolean isSplitLine()
    {
        return (this.LineNum - roundDown(this.LineNum, 1)) > 0 ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFirstPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the first pick line is the current line.
    /// </summary>
    /// <returns>
    /// True if the line is the first work line with pick type.
    /// </returns>
    public boolean isFirstPick()
    {
        WHSWorkLineCache cache = WHSWorkLineCache::newFromWorkId(this.WorkId);

        return cache.isFirstPickWorkLine(this.LineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFirstPickLineInProgress</Name>
				<Source><![CDATA[
    /// <summary>
    /// The method used to check if current <c>WHSWorkLine</c> is the actual first line picked.
    /// </summary>
    /// <returns>
    /// True if the line is the actual fist line being picked, otherwise return false.
    /// </returns>
    public boolean isFirstPickLineInProgress()
    {
        LineNum          firstPutLine;
        WHSWorkLine      whsWorkLine;
        WHSWorkLineCache cache;

        if (this.WorkType != WHSWorkType::Pick || this.WorkStatus == WHSWorkStatus::Closed)
        {
            // current workline is not a pick line or it is closed already
            return false;
        }

        cache = WHSWorkLineCache::newFromWorkId(this.WorkId);
        firstPutLine = cache.parmFirstPutLineNum();

        if (this.LineNum > firstPutLine)
        {
            // current pick workline is not an initial pick line
            return false;
        }

        select firstOnly LineNum from whsWorkLine
        where whsWorkLine.WorkId       == this.WorkId
           && whsWorkLine.WorkType     == WHSWorkType::Pick
           && whsWorkLine.WorkStatus   == WHSWorkStatus::Closed;

        return !whsWorkLine.LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFirstUnskippedPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work line is the first un-skipped pick work line of the work.
    /// </summary>
    /// <returns>True if the current work line is the first un-skipped pick work line; otherwise false</returns>
    public boolean isFirstUnskippedPick()
    {
        LineNum firstPutLineNum = WHSWorkTable::getFirstPutWorkLine(this.WorkId).LineNum;
        WHSWorkLine firstUnSkippedPickLine;

        select firstonly LineNum from firstUnSkippedPickLine
            order by firstUnSkippedPickLine.LineNum
            where firstUnSkippedPickLine.WorkId      == this.WorkId
                && firstUnSkippedPickLine.WorkType   == WHSWorkType::Pick
                && firstUnSkippedPickLine.LineNum    <  firstPutLineNum
                && firstUnSkippedPickLine.WorkStatus != WHSWorkStatus::Cancelled
                && firstUnSkippedPickLine.WorkStatus != WHSWorkStatus::Combined
                && firstUnSkippedPickLine.WorkStatus != WHSWorkStatus::Skipped
                && !firstUnSkippedPickLine.Skipped;

        return firstUnSkippedPickLine.LineNum == this.LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFirstWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether current line is the first work line.
    /// </summary>
    /// <returns>
    /// True if the current line is the first work line.
    /// </returns>
    public boolean isFirstWorkLine()
    {
        WHSWorkLineCache cache = WHSWorkLineCache::newFromWorkId(this.WorkId);

        return cache.isFirstWorkLine(this.LineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFirstNonCancelledWorkLine</Name>
				<Source><![CDATA[
    internal boolean isFirstNonCancelledWorkLine()
    {
        WHSWorkLineCache cache = WHSWorkLineCache::newFromWorkId(this.WorkId);

        return cache.isFirstNonCancelledWorkLine(this.LineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLastRemainingPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether current work line is the last remaining pick line.
    /// </summary>
    /// <returns>
    /// True if the current line is the last remaining pick line.
    /// </returns>
    public boolean isLastRemainingPick()
    {
        WHSWorkLine     workLine;
        LineNum         firstPutLineNum;
        boolean         ret;
        WHSWorkLineCache cache = WHSWorkLineCache::newFromWorkId(this.WorkId);

        if (cache.hasPutLineBeforeLine(this.LineNum))
        {
            ret = true;
        }
        else
        {
            firstPutLineNum = cache.parmFirstPutLineNum();

            select RecId from workLine
                where workLine.WorkId        == this.WorkId               &&
                      workLine.WorkType      == WHSWorkType::Pick            &&
                      workLine.ReplenDemand  == NoYes::No                    &&
                      (workLine.WorkStatus   == WHSWorkStatus::Open          ||
                       workLine.WorkStatus   == WHSWorkStatus::InProcess)    &&
                      workLine.LineNum          != this.LineNum                 &&
                      workLine.LineNum           < firstPutLineNum;

            ret = workLine.RecId == 0;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLastWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the current line is the last work line.
    /// </summary>
    /// <returns>
    /// True if the current work line is the last work line.
    /// </returns>
    public boolean isLastWorkLine()
    {
        WHSWorkLineCache cache = WHSWorkLineCache::newFromWorkId(this.WorkId);

        return cache.isLastWorkLine(this.LineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransferKanban</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the Kanban job type of the current work line.
    /// </summary>
    /// <returns>
    /// true if the current line is for a transfer kanban job; otherwise, false.
    /// </returns>
    public boolean isTransferKanban()
    {
        return KanbanJobPickingListAll::findInventTransId(this.InventTransId, this.DataAreaId).Type == LeanKanbanJobType::Transfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWholeLPMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work line represents the movement of a whole License Plate.
    /// </summary>
    /// <returns>
    /// true if the work line represents the movement of a whole License Plate; otherwise, false.
    /// </returns>
    public boolean isWholeLPMovement()
    {
        return ((   this.WorkType == WHSWorkType::Pick
                 || this.WorkType == WHSWorkType::Put
                )
                && !this.ItemId
                && this.inventDim().LicensePlateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates work status of the line.
    /// </summary>
    /// <param name="_status">
    /// The new status of the work line.
    /// </param>
    public void updateStatus(WHSWorkStatus _status)
    {
        //we don't allow update of status on lines that are marked for replenishment except to cancelled
        if (!this.ReplenDemand || _status == WHSWorkStatus::Cancelled)
        {
            ttsbegin;

            this.WorkStatus = _status;

            if (_status == WHSWorkStatus::Closed
                && this.WorkType == WHSWorkType::Count
                    && this.shouldUpdateLastCountedDateTime())
            {
                this.updateWorkLineLocationLastCountedUTCDateTimeForNonPartialCycleCount();
            }

            this.write();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateLastCountedDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls if last counted date should be updated on location record.
    /// </summary>
    /// <returns>true if counting journal should be used; false, otherwise.</returns>
    [Wrappable(true)]
    internal boolean shouldUpdateLastCountedDateTime()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkLineLocationLastCountedUTCDateTimeForNonPartialCycleCount</Name>
				<Source><![CDATA[
    private void updateWorkLineLocationLastCountedUTCDateTimeForNonPartialCycleCount()
    {
        WHSWorkTable workTable = WHSWorkTable::find(this.WorkId);

        if (!workTable.IsPartialCycleCountWork)
        {
            WMSLocation location = WMSLocation::find(this.wmsLocationId, workTable.InventLocationId, true);

            if (location)
            {
                location.updateLastCountedDateAndUpdate(DateTimeUtil::utcNow());
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>anyCycleCountWorkExistsAtLocation</Name>
				<Source><![CDATA[
    internal static boolean anyCycleCountWorkExistsAtLocation(WMSLocation _location)
    {
        WHSWorkLine		workLine;
        WHSWorkTable	workTable;

        select firstonly RecId from workLine
            where workLine.wmsLocationId	== _location.wmsLocationId
                && workLine.WorkType		== WHSWorkType::Count
            exists join workTable
                where workTable.WorkId				== workLine.WorkId
                    && workTable.InventLocationId	== _location.InventLocationId
                    && workTable.InventSiteId		== _location.inventSiteId()
                    && workTable.WorkStatus			< WHSWorkStatus::Closed;

        return workLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        this.assertNonNegativeQuantities();

        this.clearWeightForConsolidatedLine();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkPutLocationOverridden</Name>
				<Source><![CDATA[
    private boolean isWorkPutLocationOverridden()
    {
        return this.orig().WMSLocationId != this.WMSLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unblockReplenishmentWorkForOriginalLocation</Name>
				<Source><![CDATA[
    private void unblockReplenishmentWorkForOriginalLocation(WMSLocationId _wmsLocationId)
    {
        WMSLocation wmsLocation = WMSLocation::find(_wmsLocationId, this.whsWorkTable().InventLocationId);

        if (wmsLocation.isReplenishmentOverflowEnabled())
        {
            wmsLocation.unblockReplenishmentOverflowWorkWithinCapacity();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>blockReplenishmentWorkForNewLocation</Name>
				<Source><![CDATA[
    private void blockReplenishmentWorkForNewLocation(WMSLocationId _wmsLocationId)
    {
        WMSLocation wmsLocation = WMSLocation::find(_wmsLocationId, this.whsWorkTable().InventLocationId);

        if (wmsLocation.isReplenishmentOverflowEnabled())
        {
            wmsLocation.blockReplenishmentOverflowWorkOverCapacity();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>WHSWorkLine</c> record and any dependent records.
    /// </summary>
    public void update()
    {
        WHSWorkBeingSplitValidator::validateWorkTableIsNotBeingSplit(this.WorkId);
       
        this.assertNonNegativeQuantities();

        this.clearWeightForConsolidatedLine();
        
        WHSWorkLine origWorkLine = this.orig();

        // We should not allow re-opening a closed work line
        if (origWorkLine.WorkStatus == WHSWorkStatus::Closed && this.canWorkLineStatusLineBeProcessed())
        {
            if (!WHSWorkLineUpdateContext::allowReopen())
            {
                throw error(strFmt("@WAX:Error_WorkLineStatusCannotBeChanged", origWorkLine.WorkStatus, this.WorkStatus));
            }
        }

        boolean replenChangePutLocation;

        if (this.whsWorkTable().WorkTransType == WHSWorkTransType::Replenishment
            && this.isLastWorkLine())
        {
            replenChangePutLocation = this.isWorkPutLocationOverridden();
        }
        
        super();
    
        if (replenChangePutLocation)
        {
            this.blockReplenishmentWorkForNewLocation(this.WMSLocationId);
            this.unblockReplenishmentWorkForOriginalLocation(origWorkLine.WMSLocationId);
        }
        
        if (this.shouldQtyLeftToLoadBeUpdated(origWorkLine))
        {
            this.updateQtyLeftToLoad();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldQtyLeftToLoadBeUpdated</Name>
				<Source><![CDATA[
    private boolean shouldQtyLeftToLoadBeUpdated(WHSWorkLine _origWorkLine)
    {
        return this.LoadId  // Only worklines that are assigned to load affect value of WhsPurchLine.QtyLeftToLoad
            && (_origWorkLine.InventQtyWork != this.InventQtyWork
            || this.workStatusChangedToCancelled(_origWorkLine))
            && this.whsWorkTable().WorkTransType == WHSWorkTransType::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workStatusChangedToCancelled</Name>
				<Source><![CDATA[
    private boolean workStatusChangedToCancelled(WHSWorkLine _origWorkLine)
    {
        return _origWorkLine.WorkStatus != this.WorkStatus && this.WorkStatus == WHSWorkStatus::Cancelled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQtyLeftToLoad</Name>
				<Source><![CDATA[
    private void updateQtyLeftToLoad()
    {
        ttsbegin;
        WHSPurchLine whsPurchLine = WHSPurchLine::find(this.InventTransId, true);

        if (whsPurchLine)
        {
            whsPurchLine.updateQtyLeftToLoad();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canWorkLineTypeBeCanceled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a work line type can be canceled.
    /// </summary>
    /// <returns>true, if the work line type can be canceled; otherwise, false.</returns>
    public boolean canWorkLineTypeBeCanceled()
    {
        return this.WorkType == WHSWorkType::Put;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canWorkLineStatusLineBeProcessed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a worker is able to process this work line based on the work status.
    /// </summary>
    /// <returns>true, if the work line status allows processing; otherwise, false.</returns>
    protected boolean canWorkLineStatusLineBeProcessed()
    {
        return this.WorkStatus == WHSWorkStatus::Open
            || this.WorkStatus == WHSWorkStatus::InProcess
            || this.WorkStatus == WHSWorkStatus::Skipped;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFinalPutLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the final put location meets requirements.
    /// </summary>
    /// <param name="_location">
    /// The location being validated.
    /// </param>
    /// <param name="_locationProfile">
    /// The location profile of the location to validate; optional.
    /// </param>
    /// <param name="_showInfo">
    /// A Boolean that determines if the error message text will be displayed or suppressed; optional.
    /// </param>
    /// <returns>
    /// true if the location for the final put workline meets all validation requirements; otherwise, false.
    /// </returns>
    public boolean validateFinalPutLocation(
        WMSLocation         _location,
        WHSLocationProfile  _locationProfile = null,
        boolean             _showInfo = true)
    {
        WHSLocationProfile  locationProfile = _locationProfile;
        WHSWorkTable        workTable;
        boolean             ret = true;
        str                 errorText;

        workTable = WHSWorkTable::find(this.WorkId);

        // The final Put location for transfer order issue and sales order work must be validated.
        if (this.WorkType == WHSWorkType::Put
        &&  WHSWorkLine::getNextOppositeWorkLine(this.WorkId, this.LineNum, this.WorkType) == 0)
        {
            [ret, errorText] = WHSLocationDirective::validateFinalPutLocationRequirements(_location, workTable.WorkTransType, locationProfile);
        }

        if (_showInfo
        && !ret)
        {
            error(errorText);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateStagingLocIsLPControlled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that a staging workline is for a License Plate controlled location.
    /// </summary>
    /// <param name="_locationProfile">
    /// The location profile of the workline to validate; optional.
    /// </param>
    /// <returns>
    /// true if the workline is either not a staging workline or has an lp controlled location; otherwise, false.
    /// </returns>
    public boolean validateStagingLocIsLPControlled(WHSLocationProfile _locationProfile = null)
    {
        WHSLocationProfile  locationProfile = _locationProfile;
        boolean             ret = true;

        if (!locationProfile)
        {
            locationProfile = this.inventDimWithLocation().wmsLocation().whsLocationProfile();
        }

        if (this.WorkType                   == WHSWorkType::Put
        &&  locationProfile.lpControlled    == NoYes::No
        &&  WHSWorkLine::getNextOppositeWorkLine(this.WorkId, this.LineNum, this.WorkType) > 0)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsWorkTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds work header record of the line.
    /// </summary>
    /// <param name="_forUpdate">Select record for update?</param>
    /// <returns>
    /// The work header record of the line.
    /// </returns>
    public WHSWorkTable whsWorkTable(boolean _forUpdate = false)
    {
        return WHSWorkTable::find(this.WorkId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelLineNoLoadLineUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels a work line fully or partially without doing updates to the load lines.
    /// </summary>
    /// <param name="_workId">
    /// The parameter of type <c>WHSWorkId</c>.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the work line to be cancelled.
    /// </param>
    /// <param name="_inventQty">
    /// Quantity of the line to be cancelled.
    /// </param>
    /// <param name="_itemId">
    /// Item id of the work line to be cancelled.
    /// </param>
    /// <param name="_unReserved">
    /// Boolean indicating that the quantity should be unreserved.
    /// </param>
    /// <param name="_allowUnmatchedWorkAndRemaining">
    /// Boolean indicating that if the line needs to be cancelled, it will still be cancelled even the remaining and work quantity do not match.
    /// </param>
    /// <param name="_allowCancelClosedHeader">
    /// Boolean indicating that if the header needs to be cancelled, it will still be cancelled even if it is closed already.
    /// </param>
    public static void cancelLineNoLoadLineUpdate(
        WHSWorkId   _workId,
        LineNum     _lineNum,
        InventQty   _inventQty,
        ItemId      _itemId,
        boolean     _unReserved = false,
        boolean     _allowUnmatchedWorkAndRemaining = false,
        boolean     _allowCancelClosedHeader = false)
    {
        WHSWorkLine::cancelLine(_workId, _lineNum, _inventQty, _itemId, false, _unReserved, _allowUnmatchedWorkAndRemaining, _allowCancelClosedHeader, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels a work line fully or partially.
    /// </summary>
    /// <param name="_workId">
    /// The parameter of type <c>WHSWorkId</c>.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the work line to be cancelled.
    /// </param>
    /// <param name="_inventQty">
    /// Quantity of the line to be cancelled.
    /// </param>
    /// <param name="_itemId">
    /// Item id of the work line to be cancelled.
    /// </param>
    /// <param name="_decrementLoadLine">
    /// Boolean indicating that load line quantity should be decremented.
    /// </param>
    /// <param name="_unReserved">
    /// Boolean indicating that the quantity should be unreserved.
    /// </param>
    /// <param name="_allowUnmatchedWorkAndRemaining">
    /// Boolean indicating that if the line needs to be cancelled, it will still be cancelled even the remaining and work quantity do not match.
    /// </param>
    /// <param name="_allowCancelClosedHeader">
    /// Boolean indicating that if the header needs to be cancelled, it will still be cancelled even if it is closed already.
    /// </param>
    /// <param name="_decrementLoadLineWorkCreatedQty">
    /// Boolean indicating if the load lines work created quantity should be decremented.
    /// </param>
    /// <param name="_canCancelDemandWorkLinesAndWork">
    /// Boolean indicating if it is allowed or not to cancel at this point the work line and work.
    /// </param>
    public static void cancelLine(
        WHSWorkId _workId,
        LineNum _lineNum,
        InventQty _inventQty,
        ItemId _itemId,
        boolean _decrementLoadLine = true,
        boolean _unReserved = false,
        boolean _allowUnmatchedWorkAndRemaining = false,
        boolean _allowCancelClosedHeader = false,
        boolean _decrementLoadLineWorkCreatedQty = true,
        boolean _canCancelDemandWorkLinesAndWork = true)
    {
        ttsBegin;
        WHSWorkLine cancelWorkLine = WHSWorkLine::find(_workId, _lineNum, true);

        if (!cancelWorkLine.canCancelLine(_allowUnmatchedWorkAndRemaining))
        {
            throw error("@WAX2136");
        }

        if (_canCancelDemandWorkLinesAndWork)
        {
            boolean complete = WHSWorkLine::updateWorkLineQuantitiesAndCancelLine(
                                                        cancelWorkLine,
                                                        _itemId,
                                                        _unReserved,
                                                        _inventQty,
                                                        _decrementLoadLine,
                                                        _allowCancelClosedHeader,
                                                        _decrementLoadLineWorkCreatedQty);

            if (complete)
            {
                // Update or remove the replenishment work link if needed.
                if (WHSReplenWorkLink::demandLineHasReplenishmentLink(cancelWorkLine.WorkId, cancelWorkLine.LineNum))
                {
                    WHSReplenWorkLink::decreaseReplenWorkLinkInventQty(cancelWorkLine, _inventQty);
                }

                if (cancelWorkLine.ContainerId != '')
                {
                    WHSContainerTable::recursiveCloseContainerForWorkLine(cancelWorkLine);
                }

                // Method WHSWorkLine::updateWorkLineQuantitiesAndCancelLine updates cancelWorkLine, so we need to reread it
                cancelWorkLine.reread();
                cancelWorkLine.removeReplenDemand();
            }
        }
        else
        {
            WHSWorkLine::updateWorkLineQuantities(
                                            cancelWorkLine,
                                            _itemId,
                                            _unReserved,
                                            _inventQty,
                                            _decrementLoadLine);
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkLineQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update pick work line quantities.
    /// </summary>
    /// <param name = "_workLineToUpdate">The pick work line to partially cancel.</param>
    /// <param name = "_itemId">The item Id of the item we are canceling work for.</param>
    /// <param name = "_unReserved">A boolean that determines if the work should be reserved or not.</param>
    /// <param name = "_inventQtyToCancel">The quantity of work being cancelled.</param>
    /// <param name = "_decrementLoadLine">A boolean that determines if the quantity of associated loadLines should also be reduced.</param>
    /// <returns>true, if the pick work line update was completed; otherwise, false.</returns>
    protected static boolean updateWorkLineQuantities(
                                            WHSWorkLine _workLineToUpdate,
                                            ItemId      _itemId,
                                            boolean     _unReserved,
                                            InventQty   _inventQtyToCancel,
                                            boolean     _decrementLoadLine)
    {
        boolean complete = false;

        if (_workLineToUpdate.InventQtyWork >= _inventQtyToCancel)
        {
            InventHandlingUnitId    handlingUnitId = _workLineToUpdate.handlingUnitId();
            WHSWorkLine             firstPutLine = WHSWorkTable::getFirstPutWorkLine(_workLineToUpdate.WorkId);

            WHSWorkLine::cancelLinePartial(_workLineToUpdate, _itemId, _unReserved, _inventQtyToCancel, _decrementLoadLine, handlingUnitId, firstPutLine, false);

            complete = true;
        }

        return complete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkLineQuantitiesAndCancelLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update pick work line quantities and cancel work and/or lines.
    /// </summary>
    /// <param name = "_workLineToUpdate">The pick work line to partially cancel.</param>
    /// <param name = "_itemId">The item Id of the item we are canceling work for.</param>
    /// <param name = "_unReserved">A boolean that determines if the work should be reserved or not.</param>
    /// <param name = "_inventQty">The quantity of work being cancelled.</param>
    /// <param name = "_decrementLoadLine">A boolean that determines if the quantity of associated loadLines should also be reduced.</param>
    /// <param name = "_allowCancelClosedHeader">A boolean indicating that if the header needs to be cancelled, it will still be cancelled even if it is closed already.</param>
    /// <param name = "_decrementLoadLineWorkCreatedQty">A boolean indicating if the load lines work created quantity should be decremented.</param>
    /// <returns>true, if the work and/or work line cancelled; otherwise, false.</returns>
    protected static boolean updateWorkLineQuantitiesAndCancelLine(
                                            WHSWorkLine _workLineToUpdate,
                                            ItemId      _itemId,
                                            boolean     _unReserved,
                                            InventQty   _inventQty,
                                            boolean     _decrementLoadLine,
                                            boolean     _allowCancelClosedHeader,
                                            boolean     _decrementLoadLineWorkCreatedQty)
    {
        // If this work has a single Pick and we're cancelling it in full, just call Cancel work.
        if (_workLineToUpdate.InventQtyWork == _inventQty
            && _workLineToUpdate.isTheOnlyInitialPickWorkLine())
        {
            WHSWorkTable::cancelWork(_workLineToUpdate.WorkId, true, _allowCancelClosedHeader, UnknownNoYes::Unknown, false, _decrementLoadLineWorkCreatedQty);
            return true;
        }

        // If the work is currently staged and we're cancelling it in full, just call Cancel work.
        if (_workLineToUpdate.ItemId
            && _workLineToUpdate.WorkType == WHSWorkType::Pick
            && _workLineToUpdate.InventQtyWork == _inventQty
            && WHSWorkLine::isPutBefore(_workLineToUpdate.WorkId, _workLineToUpdate.LineNum))
        {
            WHSWorkTable::cancelWork(_workLineToUpdate.WorkId, true, _allowCancelClosedHeader);
            return true;
        }

        InventHandlingUnitId    handlingUnitId = _workLineToUpdate.handlingUnitId();
        WHSWorkLine             firstPutLine = WHSWorkTable::getFirstPutWorkLine(_workLineToUpdate.WorkId);

        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(WHSWorkTable::find(_workLineToUpdate.WorkId).WorkTransType);
        if (workTransactionType)
        {
            // Should update the container line and container weight, if the full qty of the workline is cancelled the container line will be deleted.
            workTransactionType.adjustContainerLine(_workLineToUpdate, -_inventQty);
        }

        // If we're cancelling the line in full and there are multiple Pick's.
        if (_workLineToUpdate.InventQtyWork == _inventQty)
        {
            WHSWorkLine::cancelLineMultiPick(_itemId, _inventQty, _decrementLoadLine, _workLineToUpdate, handlingUnitId, firstPutLine, _decrementLoadLineWorkCreatedQty);
            return true;
        }

        // If we're partially cancelling the line.
        if (_workLineToUpdate.InventQtyWork > _inventQty)
        {
            WHSWorkLine::cancelLinePartial(_workLineToUpdate, _itemId, _unReserved, _inventQty, _decrementLoadLine, handlingUnitId, firstPutLine);
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTheOnlyInitialPickWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work line is the only initial pick work line of the work.
    /// </summary>
    /// <returns>True if the current work line is the only initial pick line; otherwise false</returns>
    public boolean isTheOnlyInitialPickWorkLine()
    {
        LineNum firstPutLineNum = WHSWorkTable::getFirstPutWorkLine(this.WorkId).LineNum;

        WHSWorkLine otherInitialPickLine;

        select RecId from otherInitialPickLine
            where otherInitialPickLine.WorkId == this.WorkId
                && otherInitialPickLine.WorkType == WHSWorkType::Pick
                && otherInitialPickLine.LineNum < firstPutLineNum
                && otherInitialPickLine.LineNum != this.LineNum
                && otherInitialPickLine.WorkStatus != WHSWorkStatus::Cancelled
                && otherInitialPickLine.InventQtyWork > 0;

        return !otherInitialPickLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInitialPickLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work line is an initial pick work line of the work.
    /// </summary>
    /// <returns>true if the current work line is an initial pick line; otherwise, false.</returns>
    /// <remarks>Initial pick line means that there are not put work lines before it.</remarks>
    public boolean isInitialPickLine()
    {
        return this.WorkId
            && this.LineNum
            && this.WorkType == WHSWorkType::Pick
            && !WHSWorkLine::isPutBefore(this.WorkId, this.LineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>areWorkLineItemsDifferent</Name>
				<Source><![CDATA[
    private static boolean areWorkLineItemsDifferent(WHSWorkLine _workLine, WHSWorkLine _otherWorkLine)
    {
        return _workLine.ItemId != _otherWorkLine.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areWorkLineProductDimensionsDifferent</Name>
				<Source><![CDATA[
    private static boolean areWorkLineProductDimensionsDifferent(WHSWorkLine _workLine, WHSWorkLine _otherWorkLine)
    {
        return _otherWorkLine.InventDimId && InventDim::areProductVariantsDifferent(_workLine.ItemId, _workLine.InventDimId, _otherWorkLine.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>areWorkLineInventDimDifferent</Name>
				<Source><![CDATA[
    private static boolean areWorkLineInventDimDifferent(WHSWorkLine _workLine, WHSWorkLine _otherWorkLine)
    {
        return _otherWorkLine.InventDimId && !InventDim::isInventDimEqual(_otherWorkLine.inventDim(), _workLine.inventDim());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemIdRemainingInitialPickWorkLines</Name>
				<Source><![CDATA[
    private static ItemId getItemIdRemainingInitialPickWorkLines(
        boolean _areItemsDifferent,
        boolean _areProductDimensionsDifferent,
        WHSWorkLine _workLine)
    {
        if (_areItemsDifferent || _areProductDimensionsDifferent)
        {
            return '';
        }

        return _workLine.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimIdRemainingInitialPickWorkLines</Name>
				<Source><![CDATA[
    private static InventDimId getInventDimIdRemainingInitialPickWorkLines(
        boolean _areProductDimensionsDifferent,
        boolean _areInventDimDifferent,
        WHSWorkLine _workLine)
    {
        return _areInventDimDifferent ?
                _areProductDimensionsDifferent ?
                    InventDim::inventDimIdBlank()
                    : InventDim::findOrCreateProductInventDimId(_workLine.ItemId, _workLine.inventDim())
                : _workLine.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemIdAndInventDimIdRemainingInitialPickWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the itemID and inventDimId from the non cancelled initial pick lines.
    /// </summary>
    /// <param name = "_cancelWorkLine">The work line which is being cancelled.</param>
    /// <param name = "_firstPutLine">The first put line for this work.</param>
    /// <returns>A container containing the itemID and inventDimId from the non cancelled initial pick lines.</returns>
    private static container getItemIdAndInventDimIdRemainingInitialPickWorkLines(WHSWorkLine _cancelWorkLine, WHSWorkLine _firstPutLine)
    {
        WHSWorkLine             currentWorkLine;
        WHSWorkLine             prevWorkLine;
        boolean                 areItemsDifferent;
        boolean                 areProductDimensionsDifferent;
        boolean                 areInventDimDifferent;

        while select currentWorkLine
            where currentWorkLine.WorkStatus    != WHSWorkStatus::Cancelled
                && currentWorkLine.WorkId     == _cancelWorkLine.WorkId
                && currentWorkLine.LineNum    <  _firstPutLine.LineNum
                && currentWorkLine.WorkType   == WHSWorkType::Pick
                && currentWorkLine.LineNum    != _cancelWorkLine.LineNum
        {
            if (prevWorkLine)
            {
                areItemsDifferent = areItemsDifferent || WHSWorkLine::areWorkLineItemsDifferent(currentWorkLine, prevWorkLine);
                areProductDimensionsDifferent = areProductDimensionsDifferent || WHSWorkLine::areWorkLineProductDimensionsDifferent(currentWorkLine, prevWorkLine);
                areInventDimDifferent = areInventDimDifferent || WHSWorkLine::areWorkLineInventDimDifferent(currentWorkLine, prevWorkLine);

                if (areProductDimensionsDifferent)
                {
                    break;
                }
            }
            prevWorkLine = currentWorkLine.data();
        }

        ItemId itemId = WHSWorkLine::getItemIdRemainingInitialPickWorkLines(areItemsDifferent, areProductDimensionsDifferent, prevWorkLine);
        InventDimId inventDimId = WHSWorkLine::getInventDimIdRemainingInitialPickWorkLines(areProductDimensionsDifferent, areInventDimDifferent, prevWorkLine);

        return [itemId, inventDimId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelLineMultiPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancel the work lines where there is more than one pick.
    /// </summary>
    /// <param name="_itemId">
    /// The item on the cancelled work line.
    /// </param>
    /// <param name="_inventQty">
    /// The amount of inventory on the work line in inventory units.
    /// </param>
    /// <param name="_decrementLoadLine">
    /// True if the quantity on the corresponding load line needs to be decreased, otherwise false.
    /// </param>
    /// <param name="_cancelWorkLine">
    /// The work line to be cancelled.
    /// </param>
    /// <param name="_inventUnitId">
    /// The inventory unit of measure for the item on the cancelled work line.
    /// </param>
    /// <param name="_firstPutLine">
    /// The work line record for the initial put work.
    /// </param>
    /// <param name="_decrementLoadLineWorkCreatedQty">
    /// True if the work created quantity on the corresponding load line needs to be decremented; otherwise false.
    /// </param>
    protected static void cancelLineMultiPick(
        ItemId              _itemId,
        Qty                 _inventQty,
        boolean             _decrementLoadLine,
        WHSWorkLine         _cancelWorkLine,
        UnitOfMeasureSymbol _inventUnitId,
        WHSWorkLine         _firstPutLine,
        boolean             _decrementLoadLineWorkCreatedQty = true)
    {
        UnitOfMeasureSymbol inventUnitId = _inventUnitId;
        WHSWorkLine         tmpWorkLine;
        WHSWorkLine         firstPutLine = _firstPutLine;
        WHSLoadLine         tmpLoadLine;
        WHSWorkLine         cancelWorkLine = _cancelWorkLine;
        WHSWorkTable        tmpWorkTable;
        Qty                 qtyLeftToCancel = _inventQty;
        Qty                 prevQty;
        Qty                 cancelQty;
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        ttsbegin;

        // Delete the WIT's to free up the inventory.
        WHSWorkInventTrans workInventTrans;
        delete_from workInventTrans
            where workInventTrans.WorkId    == cancelWorkLine.WorkId
                && workInventTrans.LineNum  == cancelWorkLine.LineNum
                && workInventTrans.ItemId   == _itemId
                && workInventTrans.InventQtyRemain > 0;

        // remove the reservation flag.
        update_recordset workInventTrans
            setting WorkHasReservation = NoYes::No
            where workInventTrans.WorkId    == cancelWorkLine.WorkId
                && workInventTrans.LineNum  == cancelWorkLine.LineNum
                && workInventTrans.ItemId   == _itemId;

        // If first put Line is after the line we are cancelling then we know we are canceling an initial pick
        // Else the line we are canceling is a staging pick so cancel the entire work.
        if (firstPutLine.LineNum > cancelWorkLine.LineNum)
        {
            ItemId                  itemIdInitialPickWorkLines;
            InventDimId             inventDimIdInitialPickWorkLines;

            [itemIdInitialPickWorkLines, inventDimIdInitialPickWorkLines] = WHSWorkLine::getItemIdAndInventDimIdRemainingInitialPickWorkLines(cancelWorkLine, firstPutLine);

            // Update the Qty on the remaining work lines.
            while select forupdate tmpWorkLine
                    where tmpWorkLine.WorkId == cancelWorkLine.WorkId
                        && (tmpWorkLine.LineNum >= firstPutLine.LineNum
                            || (tmpWorkLine.LineNum > cancelWorkLine.LineNum
                                && (tmpWorkLine.WorkType == WHSWorkType::Print
                                    || tmpWorkLine.WorkType == WHSWorkType::Custom)))
            {
                Qty quantityToDeduct;

                if (tmpWorkLine.UnitId)
                {
                    quantityToDeduct = releasedProductUnitConverter.convert(_inventQty,
                                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(inventUnitId),
                                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(tmpWorkLine.UnitId),
                                                                        NoYes::No,
                                                                        cancelWorkLine.ItemId,
                                                                        cancelWorkLine.InventDimId,
                                                                        NoYes::No);
                }
                else //if there is no unit we need to assume that quantities are in inventory unit
                {
                    quantityToDeduct = _inventQty;
                }

                tmpWorkLine.InventQtyWork -= _inventQty;
                tmpWorkLine.QtyWork  -= quantityToDeduct;

                //only reduce the remaining quantities if the work line still has something that needs to be processed
                if (tmpWorkLine.InventQtyRemain)
                {
                    tmpWorkLine.InventQtyRemain = tmpWorkLine.InventQtyWork;
                    tmpWorkLine.QtyRemain = tmpWorkLine.QtyWork;
                }

                //update itemId and inventDim if necessary after cancelling work line
                if (itemIdInitialPickWorkLines)
                {
                    tmpWorkLine.ItemId = itemIdInitialPickWorkLines;
                }

                if (inventDimIdInitialPickWorkLines)
                {
                    tmpWorkLine.InventDimId = inventDimIdInitialPickWorkLines;
                }

                if (!tmpWorkLine.InventQtyWork)
                {
                    tmpWorkLine.WorkStatus = WHSWorkStatus::Cancelled;
                }

                tmpWorkLine.update();
            }

            // Check to see if we need to cancel the work header.
            select firstonly tmpWorkLine
                    where tmpWorkLine.WorkStatus    != WHSWorkStatus::Cancelled
                          && tmpWorkLine.WorkId     == cancelWorkLine.WorkId
                          && tmpWorkLine.LineNum    != cancelWorkLine.LineNum
                          && tmpWorkLine.LineNum    <  firstPutLine.LineNum;

            if (!tmpWorkLine)
            {
                tmpWorkTable = WHSWorkTable::find(cancelWorkLine.WorkId, true);
                tmpWorkTable.WorkStatus = WHSWorkStatus::Cancelled;
                tmpWorkTable.update();
                tmpWorkTable.clear();

                update_recordSet tmpWorkLine
                    setting WorkStatus      = WHSWorkStatus::Cancelled,
                            InventQtyRemain = 0,
                            QtyRemain       = 0
                    where tmpWorkLine.WorkId        == cancelWorkLine.WorkId
                        && tmpWorkLine.WorkStatus   != WHSWorkStatus::Cancelled
                        && tmpWorkLine.LineNum      != cancelWorkLine.LineNum;
            }

            cancelWorkLine.WorkStatus = WHSWorkStatus::Cancelled;
            cancelWorkLine.InventQtyRemain = 0;
            cancelWorkLine.QtyRemain = 0;
            cancelWorkLine.update();

            // Update related loadLine
            if (_decrementLoadLineWorkCreatedQty)
            {
                switch (cancelWorkLine.whsWorkTable().WorkTransType)
                {
                    case WHSWorkTransType::ProdPick:
                        WHSProdBOMPool::adjustWavedHandlingQty(cancelWorkLine.InventTransId, -_inventQty);
                        break;

                    case WHSWorkTransType::KanbanPick:
                        WHSKanbanJobPickingListPool::reduceWavedQty(cancelWorkLine.InventTransId, _inventQty);
                        break;

                    default:
                        tmpLoadLine = cancelWorkLine.retrieveLoadLine(true);

                        if (tmpLoadLine.RecId)
                        {
                            tmpLoadLine.WorkCreatedQty -= _inventQty;
                            if (_decrementLoadLine)
                            {
                                tmpLoadLine.Qty -=  releasedProductUnitConverter.convert(_inventQty,
                                                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(inventUnitId),
                                                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(tmpLoadLine.uom),
                                                                                    NoYes::No,
                                                                                         tmpLoadLine.ItemId,
                                                                                         tmpLoadLine.InventDimId,
                                                                                    NoYes::No);
                            }
                            if (tmpLoadLine.Qty > 0)
                            {
                                tmpLoadLine.update();
                            }
                            else
                            {
                                tmpLoadLine.delete();
                            }
                        }
                        break;
                }
            }

            // Delete sort positions if the work line being cancelled was the only inventory assigned to that sort position.
            if (cancelWorkLine.OutboundSortPosition
            &&  !WHSOutboundSortPosition::isSortPositionInUseByOtherWorkLine(cancelWorkLine.OutboundSortPosition, cancelWorkLine.RecId))
            {
                WHSOutboundSortPosition sortPosition;

                delete_from sortPosition
                    where sortPosition.RecId == cancelWorkLine.OutboundSortPosition;
            }

            WHSWorkLine::cancelRelatedReplenishmentDemandWork(cancelWorkLine, _inventQty);
        }
        else
        {
            while select forupdate tmpWorkLine
                    where tmpWorkLine.WorkId         == cancelWorkLine.WorkId
                          && tmpWorkLine.LineNum     >= cancelWorkLine.LineNum
            {
                tmpWorkLine.WorkStatus = WHSWorkStatus::Cancelled;
                tmpWorkLine.update();
            }

            tmpWorkTable = WHSWorkTable::find(cancelWorkLine.WorkId, true);
            tmpWorkTable.WorkStatus = WHSWorkStatus::Cancelled;
            tmpWorkTable.update();

            switch (cancelWorkLine.whsWorkTable().WorkTransType)
            {
                case WHSWorkTransType::ProdPick:
                    WHSProdBOMPool::adjustWavedHandlingQty(cancelWorkLine.InventTransId, -_inventQty);
                    break;

                case WHSWorkTransType::KanbanPick:
                    WHSKanbanJobPickingListPool::reduceWavedQty(cancelWorkLine.InventTransId, _inventQty);
                    break;
                    
                default:
                    // Update Load Lines
                    while select forupdate tmpLoadLine
                        join tmpWorkLine
                        order by tmpWorkLine.LineNum asc
                        where tmpWorkLine.LoadLineRefRecId      == tmpLoadLine.RecId
                           && tmpWorkLine.WorkId                == cancelWorkLine.WorkId
                           && tmpLoadLine.ItemId                == _itemId
                    {
                        if (qtyLeftToCancel)
                        {
                            prevQty = tmpLoadLine.WorkCreatedQty;

                            tmpLoadLine.WorkCreatedQty = tmpLoadLine.WorkCreatedQty > qtyLeftToCancel ? tmpLoadLine.WorkCreatedQty - qtyLeftToCancel : 0;
                            cancelQty = prevQty - tmpLoadLine.WorkCreatedQty;
                            qtyLeftToCancel -= cancelQty;
                            if (_decrementLoadLine)
                            {
                                tmpLoadLine.Qty -= releasedProductUnitConverter.convert(cancelQty,
                                                                                   UnitOfMeasure::unitOfMeasureIdBySymbol(inventUnitId),
                                                                                   UnitOfMeasure::unitOfMeasureIdBySymbol(tmpLoadLine.uom),
                                                                                   NoYes::No,
                                                                                   tmpLoadLine.ItemId,
                                                                                   tmpLoadLine.InventDimId,
                                                                                   NoYes::No);
                            }
                            if (tmpLoadLine.Qty > 0)
                            {
                                tmpLoadLine.update();
                            }
                            else
                            {
                                tmpLoadLine.delete();
                            }
                        }
                    }
                    break;
            }

            // Cancel related demand work if this is replenishment
            if (WHSWorkTable::find(cancelWorkLine.WorkId).WorkTransType == WHSWorkTransType::Replenishment)
            {
                WHSWorkTable::cancelDemandWork(cancelWorkLine.WorkId);
            }
        }

        ttscommit;

        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelRelatedReplenishmentDemandWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels replenishment demand work related to the line being canceled.
    /// </summary>
    /// <param name = "_cancelWorkLine">
    /// The <c>WHSWorkLine</c> being canceled.
    /// </param>
    /// <param name = "_inventQty">
    /// The amount of inventory on the work line in inventory units.
    /// </param>
    protected static void cancelRelatedReplenishmentDemandWork(WHSWorkLine _cancelWorkLine, Qty _inventQty)
    {
        // Cancel related demand work if this is replenishment
        if (WHSWorkTable::find(_cancelWorkLine.WorkId).WorkTransType == WHSWorkTransType::Replenishment)
        {
            WHSWorkTable::cancelDemandWork(_cancelWorkLine.WorkId, _cancelWorkLine.LineNum, _inventQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyPartialWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies <paramref>_tmpWorkInventTrans</paramref> to <paramref>_newWorkInventTrans</paramref>,
    /// and updates the <c>Qty</c> based on the remaining quantity that should be canceled.
    /// </summary>
    /// <param name = "_tmpWorkInventTrans">
    /// The old <c>WHSWorkInventTrans</c> record.
    /// </param>
    /// <param name = "_newWorkInventTrans">
    /// The new <c>WHSWorkInventTrans</c> record.
    /// </param>
    /// <param name = "_qtyLeftToCancel">
    /// The remaining quantity to cancel.
    /// </param>
    protected static void copyPartialWorkInventTrans(
        WHSWorkInventTrans  _tmpWorkInventTrans,
        WHSWorkInventTrans  _newWorkInventTrans,
        Qty                 _qtyLeftToCancel)
    {
        buf2Buf(_tmpWorkInventTrans, _newWorkInventTrans);

        _newWorkInventTrans.InventQtyRemain  = _newWorkInventTrans.InventQtyRemain >= _qtyLeftToCancel ? _newWorkInventTrans.InventQtyRemain -  _qtyLeftToCancel : 0;
        _newWorkInventTrans.Qty              = _newWorkInventTrans.InventQtyRemain;

        _newWorkInventTrans.TransactionWeight = WhsInvent::defaultCatchWeightReserveQuantity(_newWorkInventTrans.ItemId, _newWorkInventTrans.Qty);
        _newWorkInventTrans.RemainingTransactionWeight = _newWorkInventTrans.TransactionWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelLinePartial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Partially cancels a pick workLine.
    /// </summary>
    /// <param name="_cancelWorkLine">
    /// The pick work line to partially cancel.
    /// </param>
    /// <param name="_itemId">
    /// The item Id of the item we are canceling work for.
    /// </param>
    /// <param name="_unReserved">
    /// A Boolean that determines if the work should be reserved or not.
    /// </param>
    /// <param name="_inventQty">
    /// The Qty of work being cancelled.
    /// </param>
    /// <param name="_decrementLoadLine">
    /// A Boolean that determines if the qty of associated loadLines should also be reduced.
    /// </param>
    /// <param name="_inventUnitId">
    /// The inventory unit of measure for the item.
    /// </param>
    /// <param name="_firstPutLine">
    /// The first put workLine of the work header.
    /// </param>
    /// <param name="_canUpdateLineStatus">
    /// True if it is allowed to update the work line status at this point; otherwise false.
    /// </param>
    /// <exception cref="Exception::Error">
    /// If a reserved workLine could not cancel the full qty to be cancelled then an error is thrown.
    /// </exception>
    protected static void cancelLinePartial(
        WHSWorkLine         _cancelWorkLine,
        ItemId              _itemId,
        boolean             _unReserved,
        Qty                 _inventQty,
        boolean             _decrementLoadLine,
        UnitOfMeasureSymbol _inventUnitId,
        WHSWorkLine         _firstPutLine,
        boolean             _canUpdateLineStatus = true)
    {
        WHSWorkLine         firstPutLine = _firstPutLine;
        WHSLoadLine         tmpLoadLine;
        WHSWorkLine         cancelWorkLine = _cancelWorkLine;
        WHSWorkInventTrans  newWorkInventTrans;
        WHSWorkInventTrans  tmpWorkInventTrans;
        Qty                 qtyLeftToCancel = _inventQty;
        InventQty           tmpQtyToCancel;

        ttsbegin;

        if (qtyLeftToCancel && !_unReserved)
        {
            while select forupdate tmpWorkInventTrans
                order by tmpWorkInventTrans.LineNum asc
                where tmpWorkInventTrans.WorkId     == cancelWorkLine.WorkId
                &&    tmpWorkInventTrans.LineNum    == cancelWorkLine.LineNum
                &&    tmpWorkInventTrans.ItemId     == _itemId
            {
                if (!qtyLeftToCancel)
                {
                    break;
                }

                WHSWorkLine::copyPartialWorkInventTrans(tmpWorkInventTrans, newWorkInventTrans, qtyLeftToCancel);

                qtyLeftToCancel -= (tmpWorkInventTrans.Qty - newWorkInventTrans.Qty);

                // Delete the old WIT.
                tmpWorkInventTrans.delete();

                if (newWorkInventTrans.Qty > 0)
                {
                    // Insert the new WIT.
                    newWorkInventTrans.insert();
                }
            }
            
            if (qtyLeftToCancel)
            {
                throw error("@WAX2210");
            }
        }

        WHSWorkLine workLineToUpdate;

        // Update the Qty on the remaining lines.
        // Previous pick work lines do not need to be updated.
        while select forupdate workLineToUpdate
            where workLineToUpdate.WorkId    == cancelWorkLine.WorkId
            &&    workLineToUpdate.LineNum   >= cancelWorkLine.LineNum
            &&    (workLineToUpdate.LineNum  == cancelWorkLine.LineNum
            ||    workLineToUpdate.LineNum   >= firstPutLine.LineNum
            ||    workLineToUpdate.WorkType  == WHSWorkType::Print
            ||    workLineToUpdate.WorkType  == WHSWorkType::Custom)
        {
            tmpQtyToCancel = min(workLineToUpdate.InventQtyWork, _inventQty);

            workLineToUpdate.InventQtyWork -= tmpQtyToCancel;
            workLineToUpdate.InventQtyRemain = workLineToUpdate.InventQtyWork;

            [workLineToUpdate.QtyWork, workLineToUpdate.QtyRemain, workLineToUpdate.UnitId] = WHSInventTable::getHighestCommonUnitQtyByUOMSeqGroup(workLineToUpdate.ItemId,
                                                                        workLineToUpdate.InventQtyWork,
                                                                        workLineToUpdate.InventQtyRemain,
                                                                        workLineToUpdate.handlingUnitId(),
                                                                        workLineToUpdate.InventDimId);

            if (workLineToUpdate.InventQtyWork == 0 && _canUpdateLineStatus)
            {
                workLineToUpdate.WorkStatus = WHSWorkStatus::Cancelled;
            }

            workLineToUpdate.update();
        }

        switch (cancelWorkLine.whsWorkTable().WorkTransType)
        {
            case WHSWorkTransType::ProdPick:
                WHSProdBOMPool::adjustWavedHandlingQty(cancelWorkLine.InventTransId, -_inventQty);
                break;

            case WHSWorkTransType::KanbanPick:
                WHSKanbanJobPickingListPool::reduceWavedQty(cancelWorkLine.InventTransId, _inventQty);
                break;

            default:
                // Update the load line so that the source order can have new work created for the qty cancelled.
                tmpLoadLine = cancelWorkLine.retrieveLoadLine(true);

                if (tmpLoadLine.RecId)
                {
                    if (cancelWorkLine.whsWorkTable().WorkTransType == WHSWorkTransType::CrossDocking)
                    {
                        WHSCrossDockLoadLine::updateQuantityForCrossDockLoadLine(tmpLoadLine.RecId, cancelWorkLine.InventTransOriginIdSupply, _inventQty);
                        tmpLoadLine.CrossDockEvaluatedQuantity = max(tmpLoadLine.CrossDockEvaluatedQuantity - _inventQty, 0);
                    }

                    WHSWorkLine::updateLoadLineWorkCreatedQty(_decrementLoadLine, tmpLoadLine, cancelWorkLine, _inventQty);

                    /*
                    If it is not possible to update the work line status at this point, we want to keep the load line qty, even if it is 0
                    because this quantity can be reallocated later in the process
                    */
                    if (tmpLoadLine.Qty <= 0 && _canUpdateLineStatus)
                    {
                        tmpLoadLine.delete();
                    }
                }
                break;
        }

        WHSWorkLine::cancelWorkLineQuantity(cancelWorkLine, _inventQty);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoadLineWorkCreatedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work created quantity of the specified load line.
    /// </summary>
    /// <param name = "_decrementLoadLine">
    /// Determines whether the quantity fields of the load line should be updated.
    /// </param>
    /// <param name = "_tmpLoadLine">
    /// The load line that should be updated.
    /// </param>
    /// <param name = "_cancelWorkLine">
    /// The pick work line to being canceled.
    /// </param>
    /// <param name = "_inventQty">
    /// The Qty of work being cancelled.
    /// </param>
    protected static void updateLoadLineWorkCreatedQty(
        boolean     _decrementLoadLine,
        WHSLoadLine _tmpLoadLine,
        WHSWorkLine _cancelWorkLine,
        Qty         _inventQty)
    {
        if (_decrementLoadLine)
        {
            WHSLoadLine::updateWorkCreatedQtyAndQty(_tmpLoadLine.RecId, -_inventQty, _cancelWorkLine.InventDimId);
        }
        else
        {
            WHSLoadLine::updateWorkCreatedQty(_tmpLoadLine.RecId, -_inventQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoadLineWorkCreatedQtyOnWorkCreation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work created quantity of the specified load line.
    /// </summary>
    /// <param name = "_workType">The <c>WHSWorkType</c> to be used for the update.</param>
    [Hookable(false)]
    internal void updateLoadLineWorkCreatedQtyOnWorkCreation(WHSWorkType _workType)
    {
        if (_workType == WHSWorkType::Pick)
        {
            if (this.LoadLineRefRecId != 0 && this.InventQtyWork > 0)
            {
                WHSScheduleWorkCreationLoadLineUpdWorkCreatedQtyContext updateLoadLineContext = WHSScheduleWorkCreationLoadLineUpdWorkCreatedQtyContext::current();
            
                if (updateLoadLineContext)
                {
                    updateLoadLineContext.addLoadLine(this.LoadLineRefRecId, this.InventQtyWork);
                }
                else
                {
                    WHSLoadLine::updateWorkCreatedQty(this.LoadLineRefRecId, this.InventQtyWork);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelWorkLineQuantity</Name>
				<Source><![CDATA[
    private static void cancelWorkLineQuantity(WHSWorkLine _cancelWorkLine, Qty _inventQty)
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(WHSWorkTable::find(_cancelWorkLine.WorkId).WorkTransType);

        if (workTransactionType)
        {
            workTransactionType.cancelWorkLineQuantity(_cancelWorkLine, _inventQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a specific <c>whsWorkLine</c> record exists.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the record.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the record.
    /// </param>
    /// <returns>
    /// True if the record exists.
    /// </returns>
    public static boolean exist(WHSWorkId   _workId,
                                LineNum     _lineNum)
    {
        return _workId && _lineNum &&
               (select firstonly RecId from whsWorkLine
                where whsWorkLine.WorkId    == _workId &&
                      whsWorkLine.LineNum   == _lineNum).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForInventTransIdNotClosed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that a record exists for a specified inventory transaction number on a non-closed work.
    /// </summary>
    /// <param name="_inventTransId">
    /// The inventory transaction to validate for.
    /// </param>
    /// <returns>
    /// true if the record exists; otherwise false.
    /// </returns>
    /// <remarks>
    /// Work line is considering as closed when both the work line and the work header has status closed.
    /// </remarks>
    public static boolean existForInventTransIdNotClosed(InventTransId _inventTransId)
    {
        WHSWorkLine     whsWorkLine;
        WHSWorkTable    whsWorkTable;

        if (_inventTransId && isConfigurationkeyEnabled(configurationKeyNum(WHSandTMS)))
        {
            select firstonly RecId
                from whsWorkLine
                where whsWorkLine.InventTransId == _inventTransId
                join TableId from whsWorkTable
                    where whsWorkTable.WorkId == whsWorkLine.WorkId
                       && (whsWorkLine.WorkStatus < WHSWorkStatus::Closed
                           || whsWorkTable.WorkStatus < WHSWorkStatus::Closed
                           );
        }

        return (whsWorkLine.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific <c>WHSWorkLine</c> record with given parameters.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the record.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the record.
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    public static WHSWorkLine find(WHSWorkId _workId,
                                   LineNum   _lineNum,
                                   boolean   _forupdate = false)
    {
        WHSWorkLine    workLine;

        if (_workId &&
            _lineNum)
        {
            workLine.selectForUpdate(_forupdate);

            select firstonly workLine
                where workLine.WorkId       == _workId &&
                      workLine.LineNum      == _lineNum;
        }

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByInventTransIdTo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find a work line record based on the <c>InventTransIdTo</c> column of the <c>WHSWorkInventTrans</c> table.
    /// </summary>
    /// <param name="_inventTransIdTo">
    /// The value of the <c>InventTransIdTo</c> to search for.
    /// </param>
    /// <param name="_forupdate">
    /// A <c>Boolean</c> value that indicates if the found record should be selected for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>WHSWorkInventTrans</c> table; otherwise, an empty record.
    /// </returns>
    public static WHSWorkLine findByInventTransIdTo(InventTransId _inventTransIdTo,
                                                    boolean       _forupdate = false)
    {
        WHSWorkLine           whsWorkLine;
        WHSWorkInventTrans    workInventTrans;

        if (_inventTransIdTo && isConfigurationkeyEnabled(configurationKeyNum(WHSandTMS)))
        {
            whsWorkLine.selectForUpdate(_forupdate);

            select firstonly whsWorkLine
                exists join workInventTrans
                where workInventTrans.InventTransIdTo == _inventTransIdTo
                   && whsWorkLine.WorkId == workInventTrans.WorkId
                   && whsWorkLine.LineNum == workInventTrans.LineNum;
        }

        return whsWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByLoadLineRefRecId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static WHSWorkLine findByLoadLineRefRecId(RefRecId _loadLineRefRecId, boolean _forUpdate = false)
    {
        WHSWorkLine workLine;

        if (_loadLineRefRecId)
        {
            workLine.selectForUpdate(_forUpdate);

            select firstonly workLine
                where workLine.LoadLineRefRecId == _loadLineRefRecId;
        }

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific <c>WHSWorkLine</c> record by id.
    /// </summary>
    /// <param name="_recId">
    /// Id of the record.
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    public static WHSWorkLine findByRecId(RefRecId  _recId,
                                          boolean   _forupdate = false)
    {
        WHSWorkLine    workLine;

        if (_recId)
        {
            workLine.selectForUpdate(_forupdate);

            select firstonly workLine
                where workLine.RecId == _recId;
        }

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextOppositeWorkLineFromWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds next workline with the opposite work line type based on the work line passed as argument.
    /// </summary>
    /// <param name="_workLine">
    ///     The work line to find opposite line for.
    /// </param>
    /// <param name="_forUpdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    ///     The opposite work line if one exist; otherwise, an empty buffer.
    /// </returns>
    public static WHSWorkLine getNextOppositeWorkLineFromWorkLine(
        WHSWorkLine _workLine,
        boolean     _forUpdate = false)
    {
        WHSWorkLine oppositeWorkLine;

        LineNum oppositeLineNum = WHSWorkLine::getNextOppositeWorkLine(_workLine.WorkId, _workLine.LineNum, _workLine.WorkType);

        if (oppositeLineNum)
        {
            oppositeWorkLine = WHSWorkLine::find(_workLine.WorkId, oppositeLineNum, _forUpdate);
        }

        return oppositeWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextOppositeWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Find the next workline with the opposite work line type.
    /// </summary>
    /// <param name="_workId">
    ///     WorkId for the related work lines.
    /// </param>
    /// <param name="_lineNum">
    ///     Line number for the original work line.
    /// </param>
    /// <param name="_workType">
    ///     Work type for the original work line.
    /// </param>
    /// <returns>
    ///     Line number of the original work line.
    /// </returns>
    public static LineNum getNextOppositeWorkLine(
        WHSWorkId   _workId,
        LineNum     _lineNum,
        WHSWorkType _workType)
    {
        WHSWorkLine workLine;
        WHSWorkType oppositeType;

        Debug::assert(_workType == WHSWorkType::Pick || _workType == WHSWorkType::Put);

        oppositeType = _workType == WHSWorkType::Put ? WHSWorkType::Pick : WHSWorkType::Put;

        select firstonly LineNum from workLine
            order by LineNum
            where workLine.WorkId        == _workId
                &&  workLine.LineNum     >  _lineNum
                &&  workLine.WorkType    == oppositeType
                &&  workLine.WorkStatus != WHSWorkStatus::Skipped
                &&  workLine.WorkStatus  != WHSWorkStatus::Cancelled;

        return workLine.LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrevOppositeWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Find the previous workline with the opposite work line type.
    /// </summary>
    /// <param name="_workId">
    ///     WorkId for the related work lines.
    /// </param>
    /// <param name="_lineNum">
    ///     Line number for the original work line.
    /// </param>
    /// <param name="_workType">
    ///     Work type for the original work line.
    /// </param>
    /// <returns>
    ///     <c>WHSWorkLine</c> buffer of the previous opposite work line.
    /// </returns>
    public static WHSWorkLine getPrevOppositeWorkLine(
        WHSWorkId   _workId,
        LineNum     _lineNum,
        WHSWorkType _workType)
    {
        WHSWorkLine workLine;
        WHSWorkType oppositeType;

        oppositeType = _workType == WHSWorkType::Put ? WHSWorkType::Pick : WHSWorkType::Put;

        select firstonly workLine
            order by LineNum desc
            where workLine.WorkId       == _workId
                &&  workLine.LineNum    <  _lineNum
                &&  workLine.WorkType   == oppositeType
                &&  workLine.WorkStatus != WHSWorkStatus::Skipped
                &&  workLine.WorkStatus != WHSWorkStatus::Cancelled;

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPutBefore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether there is a put line before the line number specified.
    /// </summary>
    /// <param name="_workId">
    /// Id of the work.
    /// </param>
    /// <param name="_lineNum">
    /// The line number specified as max threshold.
    /// </param>
    /// <returns>
    /// True if there is a put line before the line number specified.
    /// </returns>
    public static boolean isPutBefore(WHSWorkId _workId, LineNum _lineNum)
    {
        WHSWorkLineCache cache = WHSWorkLineCache::newFromWorkId(_workId);

        return cache.hasPutLineBeforeLine(_lineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skips a work line converting its status to open.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the skipped line.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the skipped line.
    /// </param>
    public static void skipWorkLine(WHSWorkId _workId, LineNum _lineNum)
    {
        WHSWorkLine     workLine;

        update_recordset workLine
            setting Skipped = NoYes::Yes,
                    WorkStatus = WHSWorkStatus::Open,
                    UserId = '',
                    WorkInProcessUTCDateTime = utcDateTimeNull(),
                    AskForNewLicensePlate = NoYes::No
            where workLine.WorkId    == _workId
                && workLine.LineNum      == _lineNum
                && workLine.ReplenDemand == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipWorkLinesTo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip all work lines to the specified converting their status to open.
    /// </summary>
    /// <param name="_workId">Work id of the skipped lines.</param>
    /// <param name="_userId">The user Id of the worker using the RF menu item.</param>
    /// <param name="_lineNum">Line number to which skip lines.</param>
    [Hookable(false)]
    internal static void skipWorkLinesTo(WHSWorkId _workId, UserId _userId, LineNum _lineNum)
    {
        LineNum firstPutLineNum = WHSWorkTable::getFirstPutWorkLine(_workId).LineNum;

        WHSWorkLine workLine;

        ttsbegin;

        update_recordset workLine
            setting WorkStatus = WHSWorkStatus::Open,
                    UserId = '',
                    WorkInProcessUTCDateTime = utcDateTimeNull(),
                    AskForNewLicensePlate = NoYes::No,
                    Skipped = NoYes::No
            where workLine.WorkId == _workId
                && workLine.LineNum < firstPutLineNum
                && workLine.WorkType == WHSWorkType::Pick
                && workLine.ReplenDemand == NoYes::No
                && (workLine.WorkStatus == WHSWorkStatus::Open
                   || (workLine.WorkStatus == WHSWorkStatus::InProcess && workLine.UserId == _userId));

        update_recordset workLine
            setting Skipped = NoYes::Yes
            where workLine.WorkId == _workId
                && workLine.WorkType == WHSWorkType::Pick
                && workLine.WorkStatus == WHSWorkStatus::Open
                && workLine.LineNum < _lineNum
                && workLine.ReplenDemand == NoYes::No;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipGroupedWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skips the current group of pick lines.
    /// </summary>
    /// <param name = "_workId">
    /// <c>WHSWorkId</c> record.
    /// </param>
    /// <param name = "_lineNum">
    /// <c>LineNum</c> record for first pick line of the group.
    /// </param>
    [Hookable(false)]
    internal static void skipGroupedWorkLines(WHSWorkId _workId, LineNum _lineNum)
    {
        WHSWorkLine firstWorkLineGroupPick = WHSWorkLine::find(_workId, _lineNum);
        WHSWorkLine groupWorkLine;

        while select groupWorkLine
            where groupWorkLine.WorkId == firstWorkLineGroupPick.WorkId
                && groupWorkLine.LineNum >= firstWorkLineGroupPick.LineNum
                && (groupWorkLine.WorkStatus == WHSWorkStatus::Open
                    || groupWorkLine.WorkStatus == WHSWorkStatus::InProcess)
        {
            if (!WHSWorkLine::canWorkLineBeGroupPicked(firstWorkLineGroupPick, groupWorkLine))
            {
                break;
            }

            WHSWorkLine::skipWorkLine(groupWorkLine.WorkId, groupWorkLine.LineNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCancelLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the current work line can be cancelled.
    /// </summary>
    /// <param name="_allowUnmatchedWorkAndRemaining">
    /// Boolean indicating that if the line needs to be cancelled, it will still be cancelled even the remaining and work quantity do not match.
    /// </param>
    /// <returns>
    /// true, if the current work line can be cancelled; otherwise, false.
    /// </returns>
    public boolean canCancelLine(boolean _allowUnmatchedWorkAndRemaining = false)
    {
        if ((!_allowUnmatchedWorkAndRemaining && this.InventQtyRemain != this.InventQtyWork)
            || !this.ItemId
            || this.WorkStatus == WHSWorkStatus::Cancelled
            || this.WorkStatus == WHSWorkStatus::InProcess
            || this.WorkType != WHSWorkType::Pick
            || WHSWorkLine::isPutBefore(this.WorkId, this.LineNum))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventDimBlankOrProductDimensionOnly</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if no dimensions or only product dimensions are specified.
    /// </summary>
    /// <param name="_inventDimId">
    /// The <c>InventDimId</c> ID of the dimension record to check.
    /// </param>
    /// <returns>
    /// true if any product dimension is specified; otherwise, false
    /// </returns>
    public static boolean isInventDimBlankOrProductDimensionOnly(InventDimId _inventDimId)
    {
        if (!WHSWorkLine::isInventDimIdBlank(_inventDimId))
        {
            return InventDim::find(_inventDimId).onlyProductDimensionSpecified();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventDimIdBlank</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if inventory dimension ID is blank.
    /// </summary>
    /// <param name="_inventDimId">
    /// The <c>InventDimId</c> ID of the dimension record to check.
    /// </param>
    /// <returns>
    /// true if inventory dimension ID is blank; otherwise, false
    /// </returns>
    public static boolean isInventDimIdBlank(InventDimId _inventDimId)
    {
        return (!_inventDimId || _inventDimId == InventDim::inventDimIdBlank());
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeLoadLineReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove the FK reference to <c>WHSLoadLine</c> on all relevant work lines.
    /// </summary>
    /// <param name="_loadLineRefRecId">
    /// Id of the load line, for which work line references need to be removed.
    /// </param>
    /// <remarks>
    /// Used when a load line is removed to ensure we don't have any dangling references from the work lines.
    /// </remarks>
    public static void removeLoadLineReference(WHSLoadLineRefRecId _loadLineRefRecId)
    {
        if (!_loadLineRefRecId)
        {
            return;
        }

        ttsBegin;

        WHSWorkLine workLine;
        workLine.skipDataMethods(true);
        update_recordset workLine
            setting LoadLineRefRecId = 0
            where workLine.LoadLineRefRecId == _loadLineRefRecId;
        
        WHSWorkLineLoadLineDetails workLineLoadLineDetails;
        delete_from workLineLoadLineDetails
            where workLineLoadLineDetails.LoadLineRefRecId == _loadLineRefRecId;

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInventTransDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>InventDim</c> record of <c>InventTrans</c> based on the current work line.
    /// </summary>
    /// <returns>
    /// The <c>InventDim</c> record.
    /// </returns>
    public InventDim findInventTransDim()
    {
        InventDim           inventTransDim;
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        WHSWorkTable        whsWorkTable;
        WHSWorkInventTrans  workInventTrans;

        whsWorkTable = this.whsWorkTable();

        if (WHSWorkLineFindInventTransDimFromPickReceiptFlight::instance().isEnabled())
        {
            if (WHSInventoryTransactionConfigurationProvider::shouldUseWorkInventoryTransactionQuery(this.WorkId))
            {
                // Find the receipt transaction from the pick, so we print batch/serial number related to what we pick and any unrelated batch/serial number
                // that was received on the pick location.
                WHSWorkInventoryTransactionDescriptor inventoryTransactionDescriptor = WHSWorkInventoryTransactionQuery::newFromWorkId(this.WorkId).registeredReceiptByWorkLine(
                        this.firstPickLineNumForItem(this.WorkId, this.ItemId),
                        WHSWorkInventoryTransactionQueryParameters::construct().setFirstOnly(true));

                WHSWorkInventoryTransactionDescriptorElement inventoryTransactionDescriptorElement = inventoryTransactionDescriptor.firstOrDefault();

                if (inventoryTransactionDescriptorElement)
                {
                    inventTransDim = inventoryTransactionDescriptorElement.parmInventoryDimensionsDescriptor().convertToInventDim(true);
                }
            }
            else if (!WHSWorkLineFindInventTransDimFromPickReceiptForPutRAFOnlyFlight::instance().isEnabled() || ProdPutWorkCreationContext::instanceExists())
            {
                LineNum firstPickLineNum = this.firstPickLineNumForItem(this.WorkId, this.ItemId);

                select firstOnly TableId from workInventTrans
                    where workInventTrans.WorkId == this.WorkId
                       && workInventTrans.LineNum == firstPickLineNum
                    join TableId from inventTransOrigin
                        where inventTransOrigin.InventTransId == workInventTrans.InventTransIdTo
                    join TableId from inventTrans
                        where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                    join inventTransDim
                        where inventTransDim.inventDimId == inventTrans.inventDimId;
            }
        }
                
        if (inventTransDim.RecId == 0 && this.InventTransId)
        {
            select firstOnly RecId from inventTrans
                join RecId from inventTransOrigin
                where  inventTrans.InventTransOrigin   == inventTransOrigin.RecId
                    && inventTransOrigin.InventTransId == this.InventTransId
                join inventTransDim
                where  inventTransDim.inventDimId      == inventTrans.inventDimId
                    && inventTransDim.InventSiteId     == whsWorkTable.InventSiteId
                    && inventTransDim.InventLocationId == whsWorkTable.InventLocationId
                    && inventTransDim.LicensePlateId   == whsWorkTable.TargetLicensePlateId;
        }

        if (inventTransDim.RecId == 0)
        {
            if (WHSInventoryTransactionConfigurationProvider::shouldUseWorkInventoryTransactionQuery(this.WorkId))
            {
                WHSWorkInventoryTransactionDescriptor inventoryTransactionDescriptor = WHSWorkInventoryTransactionQuery::newFromWorkId(this.WorkId).registeredIssueByWorkLine(
                    this.firstPickLineNumForItem(this.WorkId, this.ItemId),
                    WHSWorkInventoryTransactionQueryParameters::construct().setFirstOnly(true));

                WHSWorkInventoryTransactionDescriptorElement inventoryTransactionDescriptorElement = inventoryTransactionDescriptor.firstOrDefault();

                if (inventoryTransactionDescriptorElement)
                {
                    inventTransDim = inventoryTransactionDescriptorElement.parmInventoryDimensionsDescriptor().convertToInventDim(true);
                }
            }
            else
            {
                // Search the workInventTrans record for first pick workline in table WHSWorkInventTrans
                // to get the original inventdim from where the item is picked from.
                select firstOnly InventTransIdFrom from workInventTrans
                    where workInventTrans.WorkId == this.WorkId
                        && workInventTrans.LineNum == this.firstPickLineNumForItem(this.WorkId, this.ItemId)
                    join RecId from inventTransOrigin
                        where inventTransOrigin.InventTransId == workInventTrans.InventTransIdFrom
                    join RecId from inventTrans
                        where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                    join inventTransDim
                        where  inventTransDim.inventDimId == inventTrans.inventDimId
                            && inventTransDim.InventSiteId == whsWorkTable.InventSiteId
                            && inventTransDim.InventLocationId == whsWorkTable.InventLocationId;
            }
        }

        if (inventTransDim.RecId == 0)
        {
            inventTransDim  = InventDim::find(InventTrans::findTransId(this.InventTransId).InventDimId);
        }

        return inventTransDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstPickLineNumForItem</Name>
				<Source><![CDATA[
    private LineNum firstPickLineNumForItem(WHSWorkId _workId, ItemId _itemId)
    {
        WHSWorkLine workLine;

        select firstonly LineNum from workLine
            order by LineNum
            where workLine.WorkId == _workId
                &&  workLine.ItemId == _itemId
                &&  workLine.WorkType == WHSWorkType::Pick
                &&  workLine.WorkStatus != WHSWorkStatus::Skipped
                &&  workLine.WorkStatus != WHSWorkStatus::Cancelled;

        return workLine.LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayNotes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the notes associated with the current work line.
    /// Only the initial pick lines are considered.
    /// </summary>
    /// <returns>Notes related to <c>WHSWorkLine</c> record.</returns>
    public display Notes displayNotes()
    {
        if (this.WorkType == WHSWorkType::Pick && this.InventTransId != '')
        {
            WHSWorkLineCache workLineCache = WHSWorkLineCache::newFromWorkId(this.WorkId);

            if (this.LineNum < workLineCache.parmFirstPutLineNum())
            {
                Common sourceDocLine;

                WhsWorkTransactionType workTransactiontype = WhsWorkTransactionType::singletonFromTypeOrDefault(this.whsWorkTable().WorkTransType);

                if (workTransactiontype.isForOutboundShipment())
                {
                    sourceDocLine = workTransactiontype.findSourceOrderLineByInventTransId(this.InventTransId);
                }


                if (sourceDocLine)
                {
                    WHSParameters whsParameters = WHSParameters::find();

                    DocuRefSearch docuRefLine = DocuRefSearch::newTypeIdAndRestriction(sourceDocLine,
                        whsParameters.ShipPickListNoteType,
                        DocuRestriction::Internal);

                    return Docu::concatDocuRefNotes(docuRefLine);
                }
            }
        }
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMultipleFinalPuts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see if there are still multiple final puts in the current work.
    /// </summary>
    /// <returns>
    /// true if there are multiple puts; otherwise, false.
    /// </returns>
    public boolean hasMultipleFinalPuts()
    {
        WHSWorkLine workLine;
        WHSWorkLine pickLine;
        boolean     ret;

        select firstOnly LineNum from pickLine
            order by LineNum desc
            where pickLine.WorkId   == this.WorkId
                && pickLine.WorkType == WHSWorkType::Pick;

        if (pickLine.LineNum)
        {
            select count(RecId) from workLine
                order by LineNum
                where workLine.WorkId    == this.WorkId
                    && workLine.WorkType  == WHSWorkType::Put
                    && workLine.LineNum    > pickLine.LineNum
                    && workLine.WorkStatus < WHSWorkStatus::Closed;

            ret = workLine.RecId > 1 ? true : false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPickLineAfter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see if there is another pick after the current line.
    /// </summary>
    /// <returns>
    /// True if a pick work line exists after the current work line, otherwise false.
    /// </returns>
    public boolean isPickLineAfter()
    {
        return (select firstOnly RecId from whsWorkLine
                where whsWorkLine.WorkId   == this.WorkId
                    && whsWorkLine.WorkType == WHSWorkType::Pick
                    && whsWorkLine.LineNum   > this.LineNum).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStatusInProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the current work line status to in process, calculates in process time.
    /// </summary>
    /// <param name = "_workProcessingTimeCalculationStrategy">Strategy that should be used to calculate in process time</param>
    [Hookable(false)]
    internal void setStatusInProcess(WHSWorkProcessingTimeCalculationStrategy _workProcessingTimeCalculationStrategy = WHSWorkTable::workProcessingTimeCalculationStrategy())
    {
        this.WorkStatus                 = WHSWorkStatus::InProcess;
        this.WorkInProcessUTCDateTime   = _workProcessingTimeCalculationStrategy.calculateNewInProcessDateTime(WHSWorkProcessingTimeSource::newFromBuffer(this));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStatusClosed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the current work line status to closed, calculates closed and actual times.
    /// </summary>
    /// <param name = "_workProcessingTimeCalculationStrategy">Strategy that should be used to calculate closed time</param>
    [Hookable(false)]
    internal void setStatusClosed(WHSWorkProcessingTimeCalculationStrategy _workProcessingTimeCalculationStrategy = WHSWorkTable::workProcessingTimeCalculationStrategy())
    {
        this.WorkStatus            = WHSWorkStatus::Closed;
        this.WorkClosedUTCDateTime = _workProcessingTimeCalculationStrategy.calculateNewClosedDateTime(WHSWorkProcessingTimeSource::newFromBuffer(this));
        this.ActualTime            = str2num(int642str(DateTimeUtil::getDifference(this.WorkClosedUTCDateTime, this.WorkInProcessUTCDateTime)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits the current work line when changing the location after some qty has already been put down.
    /// </summary>
    /// <param name="_locationId">
    /// The new <c>WMSLocationId</c> for the new work line.
    /// </param>
    /// <returns>
    /// The newly created <c>WHSWorkLine</c>.
    /// </returns>
    public WHSWorkLine splitWorkLine(WMSLocationId   _locationId)
    {
        WHSWorkLine         newWorkLine;
        WHSWorkInventTrans  newWorkInventTrans;
        WHSWorkInventTrans  origWorkInventTrans;
        InventDim           newDimTo;

        ttsBegin;

        // Need to increase all the line numbers by one that are after the line that we are splitting.
        while select forUpdate newWorkLine
            order by LineNum desc
            where newWorkLine.WorkId == this.WorkId
                && newWorkLine.LineNum > this.LineNum
        {
            newWorkInventTrans = WHSWorkInventTrans::findbyWorkIdLineNumItemIdTransIdParent(newWorkLine.WorkId, newWorkLine.LineNum, newWorkLine.ItemId, newWorkLine.InventTransId, true);

            newWorkLine.LineNum++;
            newWorkLine.update();

            newWorkInventTrans.LineNum++;
            newWorkInventTrans.update();
        }

        newWorkLine.clear();
        newWorkInventTrans.clear();

        buf2Buf(this, newWorkLine);

        this.selectForUpdate(true);
        this.InventQtyWork     -= this.InventQtyRemain;
        this.InventQtyRemain    = 0;
        this.QtyWork           -= this.QtyRemain;
        this.QtyRemain          = 0;
        this.setStatusClosed();
        this.update();

        origWorkInventTrans = WHSWorkInventTrans::findbyWorkIdLineNumItemIdTransIdParent(this.WorkId, this.LineNum, this.ItemId, this.InventTransId, true);

        buf2Buf(origWorkInventTrans, newWorkInventTrans);

        origWorkInventTrans.Qty = this.InventQtyWork;
        origWorkInventTrans.update();

        newWorkLine.LineNum++;
        newWorkLine.InventQtyWork            = newWorkLine.InventQtyRemain;
        newWorkLine.QtyWork                  = newWorkLine.QtyRemain;
        newWorkLine.WMSLocationId            = _locationId;
        newWorkLine.WorkStatus               = WHSWorkStatus::Open;
        newWorkLine.WorkInProcessUTCDateTime = utcDateTimeNull();

        newWorkLine.insert();

        // Make the new inventDim for the new WIT.
        newDimTo = InventDim::find(newWorkInventTrans.InventDimIdTo);
        newDimTo.wMSLocationId = _locationId;
        newDimTo = InventDim::findOrCreate(newDimTo);

        newWorkInventTrans.LineNum++;
        newWorkInventTrans.Qty              = newWorkInventTrans.InventQtyRemain;
        newWorkInventTrans.InventDimIdTo    = newDimTo.inventDimId;
        newWorkInventTrans.insert();

        ttsCommit;

        return newWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesQualityCheckIncludeCatchWeightItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a quality check work line includes a catch weight enabled item.
    /// </summary>
    /// <returns>true if a catch weight item is included; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean doesQualityCheckIncludeCatchWeightItem()
    {
        if (this.worktype != WHSWorkType::QualityCheck)
        {
            return false;
        }

        WHSInstrumentationLogger instrumentationLogger = WHSWorkLine::instrumentationLogger();

        using (var activityContext = instrumentationLogger.qualityCheckActivities().verifyQualityCheckWithCatchWeightItem())
        {
            instrumentationLogger.logRecordInformation(this);

            boolean isCWItemIncluded;

            WHSWorkLine         workLine;
            WHSWorkInventTrans  workInventTrans;

            while select ItemId from workInventTrans
                order by LineNum desc
                where workInventTrans.WorkId  == this.WorkId
                    && workInventTrans.LineNum < this.LineNum
                    && workInventTrans.Qty > 0
                exists join workLine
                    where workLine.WorkId == workInventTrans.WorkId
                        && workLine.LineNum == workInventTrans.LineNum
                        && workLine.WorkType == WHSWorkType::Pick
            {
                isCWItemIncluded = InventTable::isItemCatchWeightAndWarehouseProcessEnabled(workInventTrans.ItemId);
            
                if (isCWItemIncluded)
                {
                    break;
                }
            }

            instrumentationLogger.qualityCheckActivities().verifiedQualityCheckWithCatchWeightItem(activityContext , isCWItemIncluded);

            return isCWItemIncluded;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQualityInWork</Name>
				<Source><![CDATA[
    private WHSWorkBuildId createQualityInWork(
        WMSLocationId   _startLocationId)
    {
        WHSWorkCreateQualityIn workCreateQualityIn = WHSWorkCreateQualityIn::newFromParms(this);
        workCreateQualityIn.parmStartLocationId(_startLocationId);
        workCreateQualityIn.createWork();
    
        return workCreateQualityIn.parmWorkCreateId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>consecutivePutLineNumbersForWork</Name>
				<Source><![CDATA[
    private Enumerator consecutivePutLineNumbersForWork(LineNum _firstPutLineNum)
    {
        List list = new List(Types::Real);

        WHSWorkLine putWorkLine;
        while select LineNum, WorkType from putWorkLine
            order by LineNum
            where  putWorkLine.WorkId     == this.WorkId
                && putWorkLine.LineNum    >= _firstPutLineNum
                && putWorkLine.WorkStatus != WHSWorkStatus::Closed
                && putWorkLine.WorkStatus != WHSWorkStatus::Cancelled
        {
            if (putWorkLine.WorkType != WHSWorkType::Put)
            {
                break;
            }

            list.addEnd(putWorkLine.LineNum);
        }

        return list.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>rejectQualityCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rejects the quality check for the work line.
    /// </summary>
    /// <param name = "_userId">The ID of the user rejecting the quality check.</param>
    /// <param name = "_licensePlateId">The license plate for the work line.</param>
    /// <returns>The next work line.</returns>
    public WHSWorkLine rejectQualityCheck(UserId _userId, WHSLicensePlateId _licensePlateId)
    {
        this.saveQualityCheckResult(WHSAcceptReject::Reject);
    
        WhsWorkExecute workExecute = WhsWorkExecute::construct();

        // Update put location back to last pick location
        WHSWorkLine prevPickLine = WHSWorkLine::lastClosedPickLine(this.WorkId);
            
        // Retrieve the first putline following the last pick.
        LineNum firstPutLineNum = WHSWorkLine::getNextOppositeWorkLine(this.WorkId, prevPickLine.LineNum, prevPickLine.WorkType);
        // In case of multiple puts, retrieve the last put line that follows the last pick.
        LineNum lastPutLineNum = WHSWorkTable::getLastPutLineNumberForSpecificPickPutPair(this.WorkId, prevPickLine.LineNum);

        WHSWorkLine lastPutLine = WHSWorkLine::find(this.WorkId, lastPutLineNum);

        // Cancel any lines after the last put line.
        workExecute.cancelWorkLinesAfterRejectedQualityCheck(lastPutLine);

        // Loop through all the put lines and update the final location.
        Enumerator putLines = this.consecutivePutLineNumbersForWork(firstPutLineNum);
        while (putLines.moveNext())
        {
            // Update put location back to pick location
            workExecute.updateWorkLineLocation(this.WorkId,
                                               putLines.current(),
                                               prevPickLine.WMSLocationId);
        }
            
        // Close WorkLine and write work transaction and get next open work line
        WHSWorkLine nextWorkLine = workExecute.confirmCustomWork(this.WorkId, this.LineNum, _userId);
    
        // Create Quality Order if needed.
        List qualityOrderIdList = WHSQualityCheckTemplate::createQualityOrderFromQualityCheck(this);
    
        // Create QualityIn work
        WHSWorkBuildId qualityInWorkBuildId = this.createQualityInWork(prevPickLine.WMSLocationId);
    
        // Find first open workLine for qualityIn work
        WHSWorkLine tmpWorkLine = WHSWorkTable::getFirstWorkLineByWorkBuildId(qualityInWorkBuildId, _userId);
    
        // If we have work then have the user start that work
        if (tmpWorkLine)
        {
            if (firstPutLineNum < lastPutLineNum)
            {
                putLines.reset();
                while (putLines.moveNext())
                {
                    // Only part of the qty on the user is being put away
                    workExecute.putAwayToLocation(this.WorkId,
                                                  putLines.current(),
                                                  prevPickLine.WMSLocationId,
                                                  WHSWorkPutFlow::SplitQuantity,
                                                  _userId,
                                                  _licensePlateId,
                                                  _licensePlateId);
                }
            }
            else
            {
                // Process put on original work.
                workExecute.putAwayToLocation(this.WorkId,
                                              firstPutLineNum,
                                              prevPickLine.WMSLocationId,
                                              WHSWorkPutFlow::MoveAll,
                                              _userId,
                                              _licensePlateId,
                                              _licensePlateId);
            }

            if (qualityOrderIdList)
            {
                WHSQualityOrderInventory::setQualityOrderListWorkId(qualityOrderIdList, tmpWorkLine.WorkId);
            }

            InventDim inventDim = tmpWorkLine.inventDimWithLocation();
            inventDim.LicensePlateId = _licensePlateId;
            inventDim = InventDim::findOrCreate(inventDim);

            // Process pick on quality check in work
            nextWorkLine = workExecute.pickFromLicensePlate(_licensePlateId,
                                                        tmpWorkLine.WorkId,
                                                        tmpWorkLine.LineNum,
                                                        _userId,
                                                        inventDim,
                                                        _licensePlateId);
        }
        else
        {
            WHSWorkTable workTable = this.whsWorkTable();
            putLines.reset();
            while (putLines.moveNext())
            {
                // If work wasn't created then update put to default QC location.
                workExecute.updateWorkLineLocation(this.WorkId,
                                                   putLines.current(),
                                                   InventLocation::find(workTable.InventLocationId).DefaultQualityMaintenanceLocation);
            }
            
            if (qualityOrderIdList)
            {
                WHSQualityOrderInventory::updateQualityOrderListToDefaultQCLoc(qualityOrderIdList, workTable.InventLocationId);
            }
        }

        return nextWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>approveQualityCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Approves the quality check for the work line.
    /// </summary>
    /// <param name = "_userId">The ID of the user approving the quality check.</param>
    /// <returns>The next work line.</returns>
    public WHSWorkLine approveQualityCheck(UserId _userId)
    {
        this.saveQualityCheckResult(WHSAcceptReject::Accept);

        WhsWorkExecute workExecute = WhsWorkExecute::construct();

        // Close WorkLine, right work transaction, get next open workLine
        return workExecute.confirmCustomWork(this.WorkId, this.LineNum, _userId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveQualityCheckResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the results of a quality check.
    /// </summary>
    /// <param name = "_result">The result of the quality check.</param>
    internal void saveQualityCheckResult(WHSAcceptReject _result)
    {
        WHSQualityCheckResult::saveResult(this, _result);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasHandlingUnitWorkTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a handling unit <c>WHSWorkInventTrans</c> record exists for the work line.
    /// </summary>
    /// <returns>
    /// Boolean, true is a WorkInventTrans record exists, otherwise false
    /// </returns>
    public boolean hasHandlingUnitWorkTransaction()
    {
        WHSWorkInventTrans  workInventTrans;

        if (this.WorkId
            &&  this.LineNum
            &&  WHSWorkTable::allowsExtraHandlingUnitQty(this.WorkId))
        {
            if (this.ExtraInventHandlingQty != 0)
            {
                select firstOnly RecId from workInventTrans
                    where workInventTrans.WorkId                    == this.WorkId
                        &&    workInventTrans.LineNum               == this.LineNum
                        &&    workInventTrans.InventTransIdParent   != this.InventTransId;
            }
        }

        return workInventTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the work quantity on the work line in inventory units.
    /// </summary>
    /// <returns>
    /// Quantity on the work line in inventory units.
    /// </returns>
    public InventQty getInventoryQuantity()
    {
        return this.convertWorkQuantity(this.displayInventUnitId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>workHandlingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the work quantity on the work line in handling units.
    /// </summary>
    /// <returns>
    /// The quantity on the work line in handling units.
    /// </returns>
    [Hookable(false)]
    internal InventHandlingQty workHandlingQuantity()
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), this.ItemId))
        {
            return this.getInventoryQuantity();
        }

        return this.convertWorkQuantity(this.handlingUnitId());

    }

]]></Source>
			</Method>
			<Method>
				<Name>convertWorkQuantity</Name>
				<Source><![CDATA[
    private InventHandlingQty convertWorkQuantity(UnitOfMeasureSymbol _toUnitId)
    {
        EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        InventHandlingQty handlingQty = releasedProductUnitConverter.convert(
                                        this.QtyWork,
                                        UnitOfMeasure::unitOfMeasureIdBySymbol(this.UnitId),
                                        UnitOfMeasure::unitOfMeasureIdBySymbol(_toUnitId),
                                        NoYes::No,
                                        this.ItemId,
                                        this.InventDimId,
                                        NoYes::No);

        return handlingQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreviousOppositePredecessorSameTypeWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a workline that is the predecessor and of same type of the previous opposite work line.
    /// </summary>
    /// <param name = "_whsWorkLineCurrent">The work line for which the predecessor should be found. </param>
    /// <returns>A workline that is the predecessor and of same type of the previous opposite work line. If no line is found and empty buffer is returned.</returns>
    public static WHSWorkLine getPreviousOppositePredecessorSameTypeWorkLine(WHSWorkLine _whsWorkLineCurrent)
    {
        WHSWorkLine workLinePrevOpposite = WHSWorkLine::getPrevOppositeWorkLine(_whsWorkLineCurrent.WorkId, _whsWorkLineCurrent.LineNum, _whsWorkLineCurrent.WorkType);

        if (workLinePrevOpposite)
        {
            //now get the next prev opposite line. So first we found the prev opposite,e.g. a PICK then we find the next prev Pick
            workLinePrevOpposite = WHSWorkLine::getPrevOppositeWorkLine(_whsWorkLineCurrent.WorkId, workLinePrevOpposite.LineNum, _whsWorkLineCurrent.WorkType);
        }

        return workLinePrevOpposite;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOriginWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a work line is an origin for a consolidated work.
    /// </summary>
    /// <returns>
    /// true if the work line is an origin; otherwise, false.
    ///</returns>
    public boolean isOriginWorkLine()
    {
        WHSConsolidatedWorkLine consolidatedWorkLine;

        select firstonly RecId from consolidatedWorkLine
            where consolidatedWorkLine.OriginWorkLine == this.RecId;

        return (consolidatedWorkLine.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustWorkLineQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the quantities of the current work line record.
    /// </summary>
    /// <param name = "_inventQtyToAdjust">The inventory quantity to adjust</param>
    /// <param name = "_canUpdateStatus">True if it is allowed to update the work line status; otherwise false</param>
    /// <param name = "_newStatusIfNoQtyRemain">The new status to update the line to, if allowed</param>
    public void adjustWorkLineQuantities(
        Qty             _inventQtyToAdjust,
        boolean         _canUpdateStatus = true,
        WHSWorkStatus   _newStatusIfNoQtyRemain = WHSWorkStatus::Closed)
    {
        ttsbegin;

        this.InventQtyWork += _inventQtyToAdjust;
        this.InventQtyRemain += _inventQtyToAdjust;

        [this.QtyWork, this.QtyRemain, this.UnitId] = WHSInventTable::getHighestCommonUnitQtyByUOMSeqGroup(this.ItemId,
                                                                        this.InventQtyWork,
                                                                        this.InventQtyRemain,
                                                                        this.handlingUnitId(),
                                                                        this.InventDimId);

        if (_canUpdateStatus && !this.InventQtyRemain)
        {
            this.WorkStatus = _newStatusIfNoQtyRemain;
        }

        this.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustWorkInventTransQuantitiesAndToLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the quantities of all the <c>WHSWorkInventTrans</c> records related to the current work line.
    /// </summary>
    /// <param name = "_originInventTransId">The origin invent trans ID</param>
    /// <param name = "_inventQtyToAdjust">The inventory quantity to adjust</param>
    /// <param name = "_toLocationId">The to location ID to be set in the to inventDim of the work invent trans if no quantity is remaining</param>
    public void adjustWorkInventTransQuantitiesAndToLocation(
                                                InventTransId   _originInventTransId,
                                                Qty             _inventQtyToAdjust,
                                                WMSLocationId   _toLocationId)
    {
        WHSWorkInventTrans workInventTrans;

        ttsbegin;

        while select forUpdate workInventTrans
                where workInventTrans.WorkId                == this.WorkId
                    && workInventTrans.LineNum               == this.LineNum
                    && workInventTrans.ItemId                == this.ItemId
                    && workInventTrans.InventTransIdParent   == _originInventTransId
        {
            workInventTrans.adjustHandlingQuantity(_inventQtyToAdjust, _toLocationId);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustFollowingPrintAndCustomLineQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the quantities of the following print and custom work lines.
    /// </summary>
    /// <param name = "_lastLineNumToAdjust">The last work line number that can be updated</param>
    /// <param name = "_inventQtyToAdjust">The inventory quantity to adjust</param>
    /// <param name = "_newStatusIfNoQtyRemain">The new status to update the line to, if no quantity is remaining</param>
    public void adjustFollowingPrintAndCustomLineQuantities(
                                            LineNum         _lastLineNumToAdjust,
                                            Qty             _inventQtyToAdjust,
                                            WHSWorkStatus   _newStatusIfNoQtyRemain = WHSWorkStatus::Closed)
    {
        WHSWorkLine workLineToAdjust;

        ttsbegin;

        while select forUpdate workLineToAdjust
            where workLineToAdjust.WorkId  == this.WorkId
            && workLineToAdjust.LineNum    >  this.LineNum
            && workLineToAdjust.LineNum    <  (_lastLineNumToAdjust + 1)
            && workLineToAdjust.WorkStatus == WHSWorkStatus::Open
            && (workLineToAdjust.WorkType   == WHSWorkType::Print
            || workLineToAdjust.WorkType   == WHSWorkType::Custom)
        {
            workLineToAdjust.adjustWorkLineQuantities(_inventQtyToAdjust, true, _newStatusIfNoQtyRemain);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowPickWithFullQtyZero</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the work line can be processed using full quantity set to zero.
    /// </summary>
    /// <returns>
    /// True if the line can be processed with full quantity set to zero; false otherwise
    /// </returns>
    [SysObsolete('use WHSWorkTable.anyPicksBeforeFirstPutCompleted() instead', false, 30\06\2018)]
    public boolean allowPickWithFullQtyZero()
    {
        return WHSWorkTable::anyPicksBeforeFirstPutCompleted(this.WorkId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalNumberOfWorkLinesForWorkType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the total number of work lines of the given work type and on the work ID that are not cancelled/combined.
    /// </summary>
    /// <param name = "_workId">The <c>WHSWorkId</c> to get the number of lines.</param>
    /// <param name = "_workType">The work type to count lines.</param>
    /// <returns>The number of uncancelled work lines.</returns>
    public static int getTotalNumberOfWorkLinesForWorkType(
        WHSWorkId	_workId,
        WHSWorkType	_workType)
    {
        WHSWorkLine workLine;

        select count(RecId) from workLine
            where workLine.WorkId		== _workId
            &&	  workLine.WorkType		== _workType
            &&	  workLine.WorkStatus	 < WHSWorkStatus::Cancelled;

        return workLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForInventTransIdNotCancelledClosed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a specific <c>WHSWorkLine</c> record exists that is not closed or cancelled.
    /// </summary>
    /// <param name="_inventTransId">
    /// Inventory transaction ID of the record.
    /// </param>
    /// <returns>
    /// true if the record exists; otherwise, false.
    /// </returns>
    public static boolean existForInventTransIdNotCancelledClosed(InventTransId _inventTransId)
    {
        return _inventTransId
            && (select firstonly RecId from whsWorkLine
                    where whsWorkLine.InventTransId == _inventTransId
                       && whsWorkLine.WorkStatus    != WHSWorkStatus::Cancelled
                       && whsWorkLine.WorkStatus    != WHSWorkStatus::Closed).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAssertNonNegativeQuantities</Name>
				<Source><![CDATA[
    private boolean shouldAssertNonNegativeQuantities()
    {
        return this.WorkType == WHSWorkType::Pick
            || this.WorkType == WHSWorkType::Put;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertNonNegativeQuantities</Name>
				<Source><![CDATA[
    private void assertNonNegativeQuantities()
    {
        if (this.shouldAssertNonNegativeQuantities())
        {
            this.assertNonNegativeExtraInventHandlingQty();
            this.assertNonNegativeQtyWork();
            this.assertNonNegativeInventQtyWork();
            this.assertNonNegativeQtyRemain();
            this.assertNonNegativeInventQtyRemain();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertNonNegativeExtraInventHandlingQty</Name>
				<Source><![CDATA[
    private void assertNonNegativeExtraInventHandlingQty()
    {
        if (this.ExtraInventHandlingQty < 0)
        {
            throw error("@WAX:WorkQuantityCannotBeNegative");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertNonNegativeQtyWork</Name>
				<Source><![CDATA[
    private void assertNonNegativeQtyWork()
    {
        if (this.QtyWork < 0)
        {
            throw error("@WAX:WorkQuantityCannotBeNegative");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertNonNegativeInventQtyWork</Name>
				<Source><![CDATA[
    private void assertNonNegativeInventQtyWork()
    {
        if (this.InventQtyWork < 0)
        {
            throw error("@WAX:WorkQuantityCannotBeNegative");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertNonNegativeQtyRemain</Name>
				<Source><![CDATA[
    private void assertNonNegativeQtyRemain()
    {
        if (this.QtyRemain < 0)
        {
            throw error("@WAX:WorkQuantityCannotBeNegative");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertNonNegativeInventQtyRemain</Name>
				<Source><![CDATA[
    private void assertNonNegativeInventQtyRemain()
    {
        if (this.InventQtyRemain < 0)
        {
            throw error("@WAX:WorkQuantityCannotBeNegative");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearWeightForConsolidatedLine</Name>
				<Source><![CDATA[
    private void clearWeightForConsolidatedLine()
    {
        if (!this.ItemId)
        {
            this.capturedWeight = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canWorkLineBeGroupPicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the next work line can be grouped with a previously grouped work line.
    /// </summary>
    /// <param name = "_alreadyGroupedWorkLine">
    /// <c>WHSWorkLine</c> record that has already been grouped.
    /// </param>
    /// <param name = "_nextWorkLine">
    /// <c>WHSWorkLine</c> record that is next in sequence.
    /// </param>
    /// <returns>
    /// true if the work line can be grouped; otherwise, false.
    /// </returns>
    public static boolean canWorkLineBeGroupPicked(WHSWorkLine _alreadyGroupedWorkLine, WHSWorkLine _nextWorkLine)
    {
        if (WHSWorkLine::isPutBefore(_nextWorkLine.WorkId, _nextWorkLine.LineNum))
        {
            return false;
        }

        if (_nextWorkLine.WorkType != WHSWorkType::Pick
            || _nextWorkLine.ItemId != _alreadyGroupedWorkLine.ItemId
            || _nextWorkLine.WMSLocationId != _alreadyGroupedWorkLine.WMSLocationId
            || _nextWorkLine.InventDimId != _alreadyGroupedWorkLine.InventDimId
            || _nextWorkLine.OrderCommittedInventDimId != _alreadyGroupedWorkLine.OrderCommittedInventDimId)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrderCommitedLicensePlateFromWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get order-committed license plate id
    /// </summary>
    /// <returns> Order-committed license plate id.</returns>
    [Hookable(false)]
    internal WHSLicensePlateId findOrderCommitedLicensePlateFromWorkInventTrans()
    {
        WHSLicensePlateId licensePlateId;

        if (WHSReservationHierarchyElementPolicyProvider::singleton().isReservationOnDemandOrderEnabled(InventTable::find(this.ItemId).whsReservationHierarchy(), fieldNum(InventDim, LicensePlateId)))
        {
            licensePlateId = this.findLicensePlateFromWorkInventTrans();
        }

        return licensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLicensePlateFromWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get license plate id
    /// </summary>
    /// <returns> License plate id.</returns>
    [Hookable(false)]
    internal WHSLicensePlateId findLicensePlateFromWorkInventTrans()
    {
        WHSLicensePlateId	licensePlateId;

        if (this.WorkType == WHSWorkType::Pick)
        {
            WHSWorkInventTrans  workInventTrans;
            InventDim           inventDim;

            select firstonly LicensePlateId from inventDim
            exists join workInventTrans
            where  workInventTrans.InventDimIdFrom  == inventDim.inventDimId
                && workInventTrans.WorkId           == this.WorkId
                && workInventTrans.LineNum          == this.LineNum;

            licensePlateId = inventDim.LicensePlateId;
        }

        return licensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOpenPickBeforePutLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the workline is an open pick before the passed put line.
    /// </summary>
    /// <param name = "_putLineNum">The number of the put line</param>
    /// <returns> true if the workline is an open pick before the put line; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean isOpenPickBeforePutLine(LineNum _putLineNum)
    {
        return this.WorkStatus == WHSWorkStatus::Open
            && this.WorkType   == WHSWorkType::Pick
            && this.LineNum    < _putLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getToStorageDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the 'to' storage dimensions related to this work line.
    /// </summary>
    /// <returns>An <c>InventDim></c> table buffer containing the 'to' storage dimensions.</returns>
    [Hookable(false)]
    internal InventDim getToStorageDimensions()
    {
        InventDim inventDim;

        if (WHSInventoryTransactionConfigurationProvider::shouldUseWorkInventoryTransactionQuery(this.WorkId))
        {
            WHSWorkInventoryTransactionDescriptor inventoryTransactionDescriptor = WHSWorkInventoryTransactionQuery::newFromWorkId(this.WorkId).registeredReceiptByWorkLine(
                this.LineNum,
                WHSWorkInventoryTransactionQueryParameters::construct().setFirstOnly(true));

            WHSWorkInventoryTransactionDescriptorElement inventoryTransactionDescriptorElement = inventoryTransactionDescriptor.firstOrDefault();

            if (inventoryTransactionDescriptorElement)
            {
                inventDim = inventoryTransactionDescriptorElement
                    .parmInventoryDimensionsDescriptor()
                    .convertToInventDim(true);
            }
        }
        else
        {
            WHSWorkInventTrans workInventTrans;
            InventTrans inventTrans;
            InventTransOrigin inventTransOrigin;

            select firstonly inventDim
                exists join inventTrans
                    where inventTrans.InventDimId == inventDim.InventDimId
                exists join inventTransOrigin
                    where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                exists join workInventTrans
                    where workInventTrans.InventTransIdTo == inventTransOrigin.InventTransId
                        && workInventTrans.WorkId == this.WorkId
                        && workInventTrans.LineNum == this.LineNum;

            inventDim.clearProductDimensions();
            inventDim.clearTrackingDimensions();
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    private static WHSInstrumentationLogger instrumentationLogger()
    {
        return WHSInstrumentationLogger::createLogger(tableStr(WHSWorkLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates an item key object based on the product associated with the current line.
    /// </summary>
    /// <returns>
    /// The <c>InventItemKey</c> object.
    /// </returns>
    [Hookable(false)]
    final public InventItemKey itemKey()
    {
        return InventItemKey::newFromItem(this.ItemId, this.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>renumberWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Renumbers the work lines for a specific work Id.
    /// </summary>
    /// <param name = "_workId">A work Id.</param>
    /// <param name = "_startLineNum">Renumber starting from this value.</param>
    /// <param name = "_incrementBy">Value to increment.</param>
    [Hookable(false)]
    internal static void renumberWorkLines(
        WHSWorkId   _workId,
        LineNum     _startLineNum,
        Counter     _incrementBy)
    {
        ttsbegin;
        
        WHSWorkLine workLine;
        
        while select forupdate workLine
            order by workLine.LineNum desc
            where workLine.WorkId == _workId
            &&    workLine.LineNum >= _startLineNum
        {
            workLine.LineNum = workLine.LineNum + _incrementBy;
            workLine.update();
        }
        
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayItemWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display the weight of a work line.
    /// </summary>
    /// <returns>The weight of a work line.</returns>
    [Hookable(false)]
    internal display Weight displayItemWeight()
    {
        WHSPhysDimUOM whsPhysDimUOM = WHSPhysDimUOM::getPhysDimUOMByItem(this.ItemId, this.UnitId);

        if (whsPhysDimUOM)
        {
            return whsPhysDimUOM.Weight * this.QtyRemain;
        }

        return InventTable::find(this.ItemId).grossWeight() * this.InventQtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayItemVolume</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display the volume of a work line.
    /// </summary>
    /// <returns>The volume of a work line.</returns>
    [Hookable(false)]
    internal display Volume displayItemVolume()
    {
        WHSPhysDimUOM whsPhysDimUOM = WHSPhysDimUOM::getPhysDimUOMByItem(this.ItemId, this.UnitId);

        if (whsPhysDimUOM)
        {
            return whsPhysDimUOM.displayVolume() * this.QtyRemain;
        }

        return InventTable::find(this.ItemId).UnitVolume * this.InventQtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeReplenDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// If the work line is marked as needing replenishment, but there are no more open replenishment work orders for this line, reset the flag.
    /// </summary>
    private void removeReplenDemand()
    {
        if (this.ReplenDemand == NoYes::Yes && !this.hasUnFinishedReplenWork())
        {
            this.ReplenDemand = NoYes::No;
            this.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    [Hookable(false)]
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedTablesLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the reference and line number in related tables for the original <c>WHSWorkLine</c> record.
    /// </summary>
    /// <param name="_workIdOrig">
    ///    The original Work ID of the <c>WHSWorkLine</c> record related tables are associated with.
    /// </param>
    /// <param name="_lineNumOrig">
    ///    The original line number of the <c>WHSWorkLine</c> record related tables are associated with.
    /// </param>
    public void updateRelatedTablesLineNum(WHSWorkId _workIdOrig, LineNum _lineNumOrig)
    {
        WHSWorkInventTrans::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WHSDimTracking::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WHSReplenWorkLink::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WHSWorkTrans::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WHSWorkExceptionLog::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WhsWorkQuarantine::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WHSWorkLineLoadLineDetails::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WhsWorkLineCycleCount::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WhsWorkLineCustom::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WhsWaveLabel::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WhsSplitLoadReference::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
        WhsQualityCheckResult::moveToNewWorkLine(_workIdOrig, _lineNumOrig, this.WorkId, this.LineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildItemSetOnPutLineBasedOnPreviousPicks</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void rebuildItemSetOnPutLineBasedOnPreviousPicks(WHSWorkId _workId, WHSLineNum _lineNum)
    {
        if (!WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_workId))
        {
            return;
        }

        WHSWorkLine workLine = WHSWorkLine::find(_workId, _lineNum);

        if (workLine.WorkType != WHSWorkType::Put)
        {
            return;
        }

        Map witToItemSetIdMap = WHSWorkLine::generateNewItemSetIdOnWorkInventTrans(workLine.WorkId, workLine.LineNum);

        WHSLineNum pickFromLineNum, pickToLineNum;

        [pickFromLineNum, pickToLineNum] = WhsWorkExecute::construct().getPrevLineRange(
            workLine.WorkId,
            workLine.LineNum,
            WHSWorkType::Pick);

        // loop through the previous pick lines and put the information about what has been picked into the put line's item set.
        for (int pickLineNum = pickFromLineNum; pickLineNum <= pickToLineNum; pickLineNum++)
        {
            var inventoryDescriptor = WHSWorkInventoryTransactionQuery::newFromWorkId(workLine.WorkId).registeredReceiptByWorkLine(
                pickLineNum,
                WHSWorkInventoryTransactionQueryParameters::construct());

            var inventoryDescriptorEnumerator = inventoryDescriptor.getEnumerator();
            while (inventoryDescriptorEnumerator.moveNext())
            {
                WHSWorkInventoryTransactionDescriptorElement inventoryDescriptorElement = inventoryDescriptorEnumerator.current();

                boolean pickWorkInventTransHasRemainQty = WHSWorkLine::workInventTransHasRemainQty(
                    workLine.WorkId,
                    pickLineNum,
                    inventoryDescriptorElement.parmItemId(),
                    inventoryDescriptorElement.parmInventTransIdParent());

                // when there is remaining qty on pick WIT, than don't include what has been picked by it onto the put WIT
                // since that happens once when the whole pick WIT is completed.
                if (!pickWorkInventTransHasRemainQty)
                {
                    WHSInventoryItemSetId itemSetId = WHSWorkLine::findMatchingItemSetId(
                        witToItemSetIdMap,
                        inventoryDescriptorElement);

                    if (itemSetId != emptyGuid())
                    {
                        WHSInventoryItemSetElement::insertItemSetElement(
                            itemSetId,
                            inventoryDescriptorElement.parmItemId(),
                            inventoryDescriptorElement.parmInventoryDimensionsDescriptor().convertToInventDim(),
                            inventoryDescriptorElement.parmHandlingQty(),
                            inventoryDescriptorElement.parmHandlingWeight());
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMatchingItemSetId</Name>
				<Source><![CDATA[
    private static WHSInventoryItemSetId findMatchingItemSetId(Map _witToItemSetIdMap, WHSWorkInventoryTransactionDescriptorElement _issueInventoryDescriptorElement)
    {
        container witToItemSetIdMapKey =
            [_issueInventoryDescriptorElement.parmItemId(), _issueInventoryDescriptorElement.parmInventTransIdParent()];

        if (_witToItemSetIdMap.exists(witToItemSetIdMapKey))
        {
            Map witToItemSetIdByInventDimIdFromMap = _witToItemSetIdMap.lookup(witToItemSetIdMapKey);

            MapEnumerator witToItemSetIdByInventDimIdFromMapEnumerator = witToItemSetIdByInventDimIdFromMap.getEnumerator();

            // if there is just a single element, can avoid the dimension checks.
            if (witToItemSetIdByInventDimIdFromMap.elements() == 1)
            {
                witToItemSetIdByInventDimIdFromMapEnumerator.moveNext();

                return witToItemSetIdByInventDimIdFromMapEnumerator.currentValue();
            }
            else
            {
                while (witToItemSetIdByInventDimIdFromMapEnumerator.moveNext())
                {
                    InventDim inventDimFrom = InventDim::find(witToItemSetIdByInventDimIdFromMapEnumerator.currentKey());

                    InventDim issueInventDim = _issueInventoryDescriptorElement
                        .parmInventoryDimensionsDescriptor()
                        .convertToInventDim();

                    // check if dimensions match. In case of batch-above, for example, it is possible that the same sales line reserves several different batches.
                    if (InventDim::isInventDimEqualWHSNonWork(inventDimFrom, issueInventDim, _issueInventoryDescriptorElement.parmItemId()))
                    {
                        return witToItemSetIdByInventDimIdFromMapEnumerator.currentValue();
                    }
                }
            }
        }

        return emptyGuid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>workInventTransHasRemainQty</Name>
				<Source><![CDATA[
    private static boolean workInventTransHasRemainQty(
        WHSWorkId _workId,
        WHSLineNum _lineNum,
        ItemId _itemId,
        InventTransId _inventTransIdParent)
    {
        WHSWorkInventTrans workInventTrans = WHSWorkInventTrans::findbyWorkIdLineNumItemIdTransIdParent(
            _workId,
            _lineNum,
            _itemId,
            _inventTransIdParent);

        return workInventTrans.InventQtyRemain != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateNewItemSetIdOnWorkInventTrans</Name>
				<Source><![CDATA[
    private static Map generateNewItemSetIdOnWorkInventTrans(WHSWorkId _workId, WHSLineNum _lineNum)
    {
        Map witToItemSetIdMap = new Map(Types::Container, Types::Class);

        ttsbegin;

        WHSWorkInventTrans workInventTrans;

        workInventTrans.skipDataMethods(true);

        while select forupdate workInventTrans
            where  workInventTrans.WorkId == _workId
                && workInventTrans.LineNum == _lineNum
        {
            var oldItemSetId = workInventTrans.ItemSetId;

            workInventTrans.ItemSetId = WHSSequentialGuidGenerator::generateSequentialGuid();
            workInventTrans.update();

            WHSInventoryItemSetElement::cleanUpInventoryItemSetElement(oldItemSetId);

            container itemAndTransIdParentKey = [workInventTrans.ItemId, workInventTrans.InventTransIdParent];
            Map witToItemSetIdByInventDimIdFromMap;

            if (witToItemSetIdMap.exists(itemAndTransIdParentKey))
            {
                witToItemSetIdByInventDimIdFromMap = witToItemSetIdMap.lookup(itemAndTransIdParentKey);
            }
            else
            {
                witToItemSetIdByInventDimIdFromMap = new Map(Types::String, Types::Guid);
                witToItemSetIdMap.insert(itemAndTransIdParentKey, witToItemSetIdByInventDimIdFromMap);
            }

            witToItemSetIdByInventDimIdFromMap.add(
                workInventTrans.InventDimIdFrom,
                workInventTrans.ItemSetId);
        }

        ttscommit;

        return witToItemSetIdMap;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>WHSandTMS</ConfigurationKey>
	<DeveloperDocumentation>@WAX4496</DeveloperDocumentation>
	<FormRef>WHSWorkTable</FormRef>
	<Label>@WAX418</Label>
	<TableGroup>WorksheetLine</TableGroup>
	<TitleField1>WorkId</TitleField1>
	<TitleField2>LineNum</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>WorkIdLineNumIdx</ClusteredIndex>
	<CreatedDateTime>Yes</CreatedDateTime>
	<CreatedTransactionId>Yes</CreatedTransactionId>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Inventory</Modules>
	<PrimaryIndex>WorkIdLineNumIdx</PrimaryIndex>
	<ReplacementKey>WorkIdLineNumIdx</ReplacementKey>
	<TableContents>DefaultData</TableContents>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>WHSWorkLineCustom</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>WHSWorkLineCustom</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>WHSWorkInventTrans</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>WHSWorkInventTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>WHSWorkTrans</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>WHSWorkTrans</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LocatedLPId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsAnchored</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WMSLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtyRemain</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventQtyRemain</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventQtyWork</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UnitId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UserId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkStop</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkTypeCustomCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AskForNewLicensePlate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Mandatory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkTemplateLineRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkClassId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtyWork</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadLineRefRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShipmentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Skipped</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AvailPhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReplenDemand</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EstimatedTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActualTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FEFOBatchId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkInProcessUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkClosedUTCDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@WAX2277</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsAnchored</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WMSLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtyRemain</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventQtyRemain</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventQtyWork</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UnitId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UserId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkStop</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkTypeCustomCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AskForNewLicensePlate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Mandatory</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkTemplateLineRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkClassId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtyWork</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadLineRefRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShipmentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Skipped</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AvailPhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReplenDemand</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EstimatedTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActualTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FEFOBatchId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LocatedLPId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkInProcessUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkClosedUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>sortCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ZoneId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExtraInventHandlingQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderCommittedInventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCreationFailedOnReservation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AllocatedWMSLocationId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>LaborStandards</Name>
			<Label>@WAX3944</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>EstimatedTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActualTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ActualTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSActualTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AskForNewLicensePlate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSAskForNewLicensePlate</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AvailPhysical</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventQtyAvailPhysical</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContainerId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EstimatedTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSEstimatedTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>FEFOBatchId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSFEFOBatchId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>InventQtyRemain</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSInventQtyRemain</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>InventQtyWork</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSInventQtyWork</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransId</Name>
			<AssetClassification>OII</AssetClassification>
			<ExtendedDataType>InventTransId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsAnchored</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSIsAnchored</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LineNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LineNum</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LoadId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLoadId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LoadLineRefRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@WAX:ReferenceLoadLineId</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LocatedLPId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLocatedLPId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Mandatory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSMandatory</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OrderNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSOrderNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>QtyRemain</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSQtyRemain</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>QtyWork</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSQtyWork</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReplenDemand</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSReplenDemand</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ShipmentId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSShipmentId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Skipped</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSSkipped</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>sortCode</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WMSSortCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>UnitId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>UnitOfMeasureSymbol</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>UserId</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>WHSUserId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WMSLocationId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WMSLocationId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkClassId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkClassId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>WorkClosedUTCDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkClosedUTCDateTime</ExtendedDataType>
			<Label>@WAX5466</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>WorkInProcessUTCDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkInProcessUTCDateTime</ExtendedDataType>
			<Label>@WAX5465</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>WHSWorkStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkStop</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkStop</ExtendedDataType>
			<Label>@WAX5464</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>WorkTemplateLineRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Mandatory>Yes</Mandatory>
			<EnumType>WHSWorkType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkTypeCustomCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkTypeCustomCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ZoneId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSZoneId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExtraInventHandlingQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSExtraInventHandlingQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CapturedWeight</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSCapturedWeight</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OutboundSortPosition</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSOutboundSortPositionRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InventTransOriginIdSupply</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransOriginIdMarked</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OrderCommittedInventDimId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AllocatedWMSLocationId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WMSLocationId</ExtendedDataType>
			<Label>@WAX:WorkLineAllocatedLocation</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkCreationFailedOnReservation</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkCreationFailedOnReservation</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OrigPackingWorkTargetLicensePlateId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLicensePlateId</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>WorkIdLineNumIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNum</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LoadIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LoadId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WMSLocationId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LoadLineRefRecIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LoadLineRefRecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WorkTypeLocationIdItemWorkStatusIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WMSLocationId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WorkTypeLocationidWorkStatusUnitIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WMSLocationId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>UnitId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNum</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WorkClassTableIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkClassId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ShipmentIdWorkIdRecIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ShipmentId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventTransIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LocatedLPId</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LocatedLPId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ContainerIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ContainerId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ReplenishmentIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventQtyWork</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WMSLocationId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WorkIdTypeStatusIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>OutboundSortPositionRecIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>OutboundSortPosition</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimId</Name>
					<SourceEDT>InventDimId</SourceEDT>
					<Field>InventDimId</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<SourceEDT>ItemId</SourceEDT>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ItemIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOrigin</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransId</Name>
					<SourceEDT>InventTransId</SourceEDT>
					<Field>InventTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventTransIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SalesTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>SalesId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>UnitOfMeasure</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UnitOfMeasure</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>UnitId</Name>
					<Field>UnitId</Field>
					<RelatedField>Symbol</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSContainerTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSContainerTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContainerId</Name>
					<SourceEDT>WHSContainerId</SourceEDT>
					<Field>ContainerId</Field>
					<RelatedField>ContainerId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSLicensePlate</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSLicensePlate</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LocatedLPId</Name>
					<SourceEDT>WHSLocatedLPId</SourceEDT>
					<Field>LocatedLPId</Field>
					<RelatedField>LicensePlateId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSLoadLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSLoadLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LoadLineRefRecId</Name>
					<Field>LoadLineRefRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSLoadTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSLoadTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LoadId</Name>
					<SourceEDT>WHSLoadId</SourceEDT>
					<Field>LoadId</Field>
					<RelatedField>LoadId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSShipmentTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSShipmentTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ShipmentId</Name>
					<SourceEDT>WHSShipmentId</SourceEDT>
					<Field>ShipmentId</Field>
					<RelatedField>ShipmentId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>WHSWorkTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Composition</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkId</Name>
					<SourceEDT>WHSWorkId</SourceEDT>
					<Field>WorkId</Field>
					<RelatedField>WorkId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkTemplateLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWorkTemplateLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkTemplateLineRecId</Name>
					<Field>WorkTemplateLineRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkTypeCustom</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSWorkTypeCustom</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkTypeCustomCode</Name>
					<SourceEDT>WHSWorkTypeCustomCode</SourceEDT>
					<Field>WorkTypeCustomCode</Field>
					<RelatedField>WorkTypeCustomCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkUser</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSWorkUser</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>UserId</Name>
					<SourceEDT>WHSUserId</SourceEDT>
					<Field>UserId</Field>
					<RelatedField>UserId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WMSLocation</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WMSLocation</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WMSLocationId</Name>
					<Field>WMSLocationId</Field>
					<RelatedField>wMSLocationId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OutboundSortPosition</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSOutboundSortPosition</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OutboundSortPosition</Name>
					<Field>OutboundSortPosition</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTransOriginIdSupply</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransOriginIdSupply</Name>
					<Field>InventTransOriginIdSupply</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>