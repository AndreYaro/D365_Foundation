<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PayrollPayStatementLine</Name>
	<SourceCode>
		<Declaration><![CDATA[
public abstract class PayrollPayStatementLine extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createProjectAccountingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates project accounting distributions.
    /// </summary>
    /// <param name="_templateRecIdMap">
    ///     A map of accountingDistributionTemplateRecId and its project information.
    /// </param>
    public void createProjectAccountingDistribution(Map _templateRecIdMap)
    {
        AccountingDistribution                  accountingDistribution;
        ProjectAccountingDistribution           projectAccountingDistribution;
        container                               projInfo;
        Map                                     accountingDistributionTempDetailMap;
        MapIterator                             accountingDistributionTempDetailMapIterator;

        accountingDistributionTempDetailMap = this.getAccountingDistribTemplateDetailsMap(_templateRecIdMap);

        if (accountingDistributionTempDetailMap)
        {
            accountingDistributionTempDetailMapIterator = new MapIterator(accountingDistributionTempDetailMap);

            while (accountingDistributionTempDetailMapIterator.more())
            {
                projInfo = _templateRecIdMap.lookup(accountingDistributionTempDetailMapIterator.key());

                if (conPeek(projInfo, 1) != 0
                    || conPeek(projInfo, 2) != 0
                    || conPeek(projInfo, 3) != 0
                    || conPeek(projInfo, 4) != 0
                    || conPeek(projInfo, 5) != 0)
                {
                    accountingDistribution = accountingDistributionTempDetailMapIterator.value();

                    projectAccountingDistribution.clear();
                    projectAccountingDistribution.AccountingDistribution = accountingDistribution.RecId;
                    projectAccountingDistribution.ProjTable = conPeek(projInfo, 1);
                    projectAccountingDistribution.ProjCategory = this.getProjCategoryRecId(conPeek(projInfo, 2));

                    projectAccountingDistribution.SmmActivities = conPeek(projInfo, 3);
                    projectAccountingDistribution.ProjFundingSource = conPeek(projInfo, 4);
                    projectAccountingDistribution.ProjLineProperty = conPeek(projInfo, 5);
                    projectAccountingDistribution.Currency = Currency::find(accountingDistribution.TransactionCurrency).RecId;
                    ProjectAccountingDistribution::fieldModifiedCategoryIdPost(accountingDistribution, projectAccountingDistribution);

                    if (projectAccountingDistribution.validateWrite())
                    {
                        projectAccountingDistribution.insert();
                    }
                }

                accountingDistributionTempDetailMapIterator.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingDistribTemplateDetailsMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a map between accountingDistributionTemplateDetails and accounting distributions.
    /// </summary>
    /// <param name="_templateRecIdMap">
    ///     A map of accountingDistributionTemplateRecId and its project information.
    /// </param>
    /// <returns>
    ///     A map of accountingDistributionTemplateDetailRecId and its AccountingDistribution buffer.
    /// </returns>
    public Map getAccountingDistribTemplateDetailsMap(Map _templateRecIdMap)
    {
        AccountingDistributionTemplateDetail    accountingDistributionTemplateDetail;
        AccountingDistribution                  accountingDistribution;
        DimensionDefault                        defaultDimension;
        map                                     accountingDistributionMap;

        if (_templateRecIdMap)
        {
            accountingDistributionMap = new Map (Types::Int64, Types::Record);

            while select accountingDistribution
                where accountingDistribution.SourceDocumentHeader == this.payrollPayStatement().SourceDocumentHeader
                      && accountingDistribution.SourceDocumentLine == this.SourceDocumentLine
            {
                defaultDimension = DimensionAttributeValueSetStorage::getDefaultDimensionFromDimensionCombination(accountingDistribution.LedgerDimension);

                while select RecId from accountingDistributionTemplateDetail
                    where accountingDistributionTemplateDetail.DistributionTemplate == this.AccountingDistributionTemplate
                          && accountingDistributionTemplateDetail.DefaultDimension == defaultDimension
                          && accountingDistributionTemplateDetail.DistributionPercent == (accountingDistribution.AllocationFactor * 100)
                {
                    if (!accountingDistributionMap.exists(accountingDistributionTemplateDetail.RecId))
                    {
                        accountingDistributionMap.insert(accountingDistributionTemplateDetail.RecId, accountingDistribution);
                        break;
                    }
                }
            }
        }

        return accountingDistributionMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayBudgetCheckResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the budget check result value for the record.
    /// </summary>
    /// <returns>
    /// The budget check result value for the record.
    /// </returns>
    public display BudgetCheckResult displayBudgetCheckResult()
    {
        return this.getBudgetCheckResult();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayBudgetCheckResultText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the text that represents the budget check result value for the <c>PayrollPayStatementLine</c>
    /// record.
    /// </summary>
    /// <returns>
    /// The text that represents the budget check result value for the <c>PayrollPayStatementLine</c> record.
    /// </returns>
    public display BudgetCheckResultText displayBudgetCheckResultText()
    {
        return BudgetControlResult::getBudgetCheckResultToolTip(this.getBudgetCheckResult());
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayIncludedInVendInvoiceImage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether or not the pay statement line has been included in a vendor invoice.
    /// </summary>
    /// <returns>
    /// A green checked icon if the pay statement line has been included in a vendor invoice; otherwise, a blank icon.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display ImageRes displayIncludedInVendInvoiceImage()
    {
        #resAppl
        #define.IsIncludedImage(12711)
        ImageRes imageRes = 0;

        if (this.VendTrans != 0)
        {
            imageRes = #IsIncludedImage;
        }
        else
        {
            imageRes = #ImageBlank2;
        }

        return imageRes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayVendorInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the vendor invoice id from the transaction's invoice.
    /// </summary>
    /// <returns>
    ///     A vendor invoice id.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display VendInvoiceId displayVendorInvoice()
    {
        return VendTrans::find(this.VendTrans).Invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetCheckResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the <c>BudgetCheckResult</c> value for the specified <c>PayrollPayStatementLine</c> record.
    /// </summary>
    /// <returns>
    /// A <c>BudgetCheckResult</c> value which is calculated using the query.
    /// </returns>
    public BudgetCheckResult getBudgetCheckResult()
    {
        return BudgetSourceSourceDocumentLine::findBudgetCheckResult(this.SourceDocumentLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjCategoryRecId</Name>
				<Source><![CDATA[
    private RefRecId getProjCategoryRecId(RefRecId _projCategoryRecId)
    {
        ProjCategoryId                      projCategoryId;
        RefRecId                            projCategoryRecId;
        PayrollPayStatementBenefitLine      payStatementBenefitLine;
        PayrollPayStatementTaxLine          payStatementTaxLine;
        PayrollTaxCode                      taxCode;
        PayrollTaxCodeDefaultDimension      taxCodeDefaultDimension;
        HcmBenefit                          benefit;
        PayrollBenefitPlanDefaultDimension  benefitPlanDefaultDimension;
        LegalEntityRecId                    currLE;

        currLE = CompanyInfo::current();
        if (this.getInstanceRelationType() == tableStr(PayrollPayStatementBenefitLine))
        {
            payStatementBenefitLine = PayrollPayStatementBenefitLine::find(this.RecId);
            benefit = HcmBenefit::find(payStatementBenefitLine.Benefit);
            benefitPlanDefaultDimension = PayrollBenefitPlanDefaultDimension::findByBenefitPlanLegalEntity(benefit.BenefitPlan, currLE);
            projCategoryId = benefitPlanDefaultDimension.CategoryId;
            projCategoryRecId = ProjCategory::find(projCategoryId).RecId;
            if (!projCategoryRecId)
            {
                throw error(strFmt("@Payroll:NoPayStatementWasCreatedForWorker1OneOrMoreBenefitLinesThatA", HcmWorker::find(this.payrollPayStatement().Worker).PersonnelNumber));
            }
        }
        else if (this.getInstanceRelationType() == tableStr(PayrollPayStatementTaxLine))
        {
            payStatementTaxLine = PayrollPayStatementTaxLine::find(this.RecId);
            taxCode = PayrollTaxCode::find(payStatementTaxLine.TaxCode);
            taxCodeDefaultDimension = PayrollTaxCodeDefaultDimension::findByPayrollTaxCodeLegalEntity(taxCode.RecId, currLE);
            projCategoryId = taxCodeDefaultDimension.CategoryID;
            projCategoryRecId = ProjCategory::find(projCategoryId).RecId;
            if (!projCategoryRecId)
            {
                throw error(strFmt("@Payroll:NoPayStatementWasCreatedForWorker1OneOrMoreTaxLinesThatAreAs", HcmWorker::find(this.payrollPayStatement().Worker).PersonnelNumber));
            }
        }
        else
        {
            projCategoryRecId = _projCategoryRecId;
        }

        return projCategoryRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Manages the insertion of a new <c>PayrollPayStatementLine</c> table buffer.
    /// </summary>
    /// <param name="_earningStatementLines">
    ///     A list of <c>RecId</c> values containing the <c>PayrollEarningStatementLine</c> records for which
    ///     this record is based on.
    /// </param>
    /// <param name="_createSourceDocument">
    ///     Whether or not to create the related source document record.
    /// </param>
    public void insert(List _earningStatementLines = null, boolean _createSourceDocument=true)
    {
        #OCCRetryCount
        PayrollEarningStatementLine payrollEarningStatementLine;
        Enumerator                  earningStatementLinesEnumerator;
        PayrollPayStatementLine     payStatementLineConcrete, payStatementLineBase;

        try
        {
            if (this.LineNum == 0)
            {
                this.LineNum = PayrollPayStatementLine::lastLineNum(this.PayStatement) + 1;
            }

            super();
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                // set LineNum to 0 so it will be recalculated again
                this.LineNum = 0;
                retry;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::DuplicateKeyException;
            }
            else
            {
                // set LineNum to 0 so it will be recalculated again
                this.LineNum = 0;
                retry;
            }
        }

        if (this.getInstanceRelationType() == tableStr(PayrollPayStatementEarningLine) &&
            _earningStatementLines != null)
        {
            earningStatementLinesEnumerator = _earningStatementLines.getEnumerator();
            while (earningStatementLinesEnumerator.moveNext())
            {
                payrollEarningStatementLine = PayrollEarningStatementLine::find(earningStatementLinesEnumerator.current(), true);

                payrollEarningStatementLine.PayStatementEarningLine = this.RecId;
                payrollEarningStatementLine.PaymentStatus = PayrollPaymentProcessingStatus::Processed;
                payrollEarningStatementLine.update(true);
            }
        }

        if (_createSourceDocument)
        {
            PayrollPayStatement payStatement;

            select firstonly RecId, SourceDocumentHeader from payStatement
                where payStatement.RecId == this.PayStatement;

            // Ensure that a source document header has been created for the parent pay statement before
            // attempting to generate source documents for the new line.
            if (payStatement.SourceDocumentHeader != 0)
            {
                //
                // This is required in order for the SourceDocumentLineImplementation map to correctly
                // hook up to the PayrollPayStatementLine table since the table participates in
                // table inheritance.
                //
                payStatementLineConcrete = PayrollPayStatementLine::find(this.RecId, true);
                payStatementLineBase.data(payStatementLineConcrete);

                // Attempt to fully distribute the source document line as soon as it is created
                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(
                    payStatementLineBase, true, SourceDocumentLineAccountingStatus::FullyDistributed);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRateDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the exchange rate date used by the source document framework.
    /// </summary>
    /// <returns>
    /// The value of the exchange rate date.
    /// </returns>
    public AccountingDate parmExchangeRateDate()
    {
        return this.AccountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the parent source document line.
    /// </summary>
    /// <returns>
    /// The value of parent source document line.
    /// </returns>
    public SourceDocumentLine parmParentSourceDocumentLine()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineTypeEnumName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source document line type enum name.
    /// </summary>
    /// <returns>
    /// The value of the source document line type enum name.
    /// </returns>
    public EnumName parmSourceDocLineTypeEnumName()
    {
        return enumStr(SourceDocumentLine_PayrollPayStatement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineTypeEnumValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source document line type enum value for a record.
    /// </summary>
    /// <returns>
    /// The value of the source document line type enum.
    /// </returns>
    public SourceDocumentTypeEnumValue parmSourceDocLineTypeEnumValue()
    {
        PayrollPayStatementLine payStatementLine;
        SourceDocumentTypeEnumValue enumValue;

        //
        // In order to properly connect the PayrollPayStatementLine buffer to the
        // SourceDocumentLineImplementation map, we do a .data() call which loses
        // the InstanceRelationType value. Therefore, this extra find is needed
        // to determine which child table the line represents.
        //
        payStatementLine = PayrollPayStatementLine::find(this.RecId);

        switch (payStatementLine.getInstanceRelationType())
        {
            case tableStr(PayrollPayStatementEarningLine):
                enumValue = SourceDocumentLine_PayrollPayStatement::PayStatementEarningLine;
                break;
            case tableStr(PayrollPayStatementBenefitLine):
                enumValue = SourceDocumentLine_PayrollPayStatement::PayStatementBenefitLine;
                break;
            case tableStr(PayrollPayStatementTaxLine):
                enumValue = SourceDocumentLine_PayrollPayStatement::PayStatementTaxLine;
                break;
        }

        return enumValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the related source document header.
    /// </summary>
    /// <returns>
    /// The related record from the <c>SourceDocumentHeader</c> table.
    /// </returns>
    public SourceDocumentHeader parmSourceDocumentHeader()
    {
        return SourceDocumentHeader::find(this.payrollPayStatement().SourceDocumentHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>statusIcon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates the pay statement line status of the current record in the <c>PayrollPayStatementLine</c> table.
    /// </summary>
    /// <returns>
    /// The payroll pay statement line status icon.
    /// </returns>
    display container statusIcon()
    {
        ImageReference imgRef;
        str imageName;
        container imgContainer;

        if (this.IsLineLocked)
        {
            imageName = identifierstr(NotAvailable);
        }
        else if (this.IsPayStatementLineOverridden)
        {
            imageName = identifierstr(Edit);
        }

        if (imageName)
        {
            imgRef = ImageReference::constructForSymbol(imageName);
            imgContainer = imgRef.pack();
        }

        return imgContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>PayrollPayStatementLine</c> record in the database.
    /// </summary>
    /// <remarks>
    /// If a line is marked for removal then corresponding source document line record is deleted.
    /// </remarks>

    public void update()
    {
        boolean isMarkedForRemovalChanged = false;
        boolean isAmountChanged = false;
        boolean isDateChanged = false;
        SourceDocumentLine sourceDocumentLine;
        PayrollPayStatement payStatement = PayrollPayStatement::find(this.PayStatement);
        boolean doAccounting = (payStatement.SourceDocumentHeader != 0);

        ttsbegin;

        if (this.IsMarkedForRemoval && !this.orig().IsMarkedForRemoval)
        {
            isMarkedForRemovalChanged = true;
        }

        if (this.AccountingCurrencyAmount != this.orig().AccountingCurrencyAmount)
        {
            isAmountChanged = true;
        }

        if (this.AccountingDate != this.orig().AccountingDate)
        {
            isDateChanged = true;
        }

        if (isMarkedForRemovalChanged && doAccounting)
        {
            // The source document line should be removed
            sourceDocumentLine = SourceDocumentLine::find(this.SourceDocumentLine, true);
            sourceDocumentLine.delete();
            this.SourceDocumentLine = 0;
        }

        super();

        ttscommit;

        if ((isAmountChanged || isDateChanged) && doAccounting && !isMarkedForRemovalChanged)
        {
            // If the line's amount or accounting date has changed, call the SD framework to update the distributions
            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, false, SourceDocumentLineAccountingStatus::FullyDistributed);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a record ID exists in <c>PayrollPayStatementLine</c> table and shows an infolog message if record does not exist.
    /// </summary>
    /// <param name="_recId">
    /// The value of the record ID to check.
    /// </param>
    /// <returns>
    /// true if the record ID exists; otherwise, false.
    /// </returns>
    public static boolean checkExist(PayrollPayStatementLineRecId _recId)
    {
        boolean ret = true;

        if (!PayrollPayStatementLine::exist(_recId))
        {
            ret = checkFailed(strFmt(PayrollPayStatementLine::txtNotExist(), tableStr(PayrollPayStatementLine)));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAccountingDistributionDetail</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates accounting distribution detail records containing the distribution information
    ///     based on the pay statement and the distribution template.
    /// </summary>
    /// <param name="_payStatement">
    ///     The pay statement header.
    /// </param>
    /// <param name="_accountingDistributionTemplRecId">
    ///     The record ID of accouting distribution template.
    /// </param>
    /// <param name="_positiveLines">
    ///     True if the template is for positive earning lines; false, if it is for negative earning lines
    /// </param>
    /// <returns>
    ///     A map of the project accounting distribution information.
    /// </returns>
    public static Map createAccountingDistributionDetail(
        PayrollPayStatement _payStatement,
        AccountingDistributionTemplateRecId _accountingDistributionTemplRecId,
        boolean _positiveLines = true)
    {
        PayrollPayStatementEarningLine payStatementEarningLine;
        List sourceDocumentLines = new List(Types::Int64);
        Map templateRecIdMap = null;

        if (_positiveLines)
        {
            while select SourceDocumentLine from payStatementEarningLine
                where payStatementEarningLine.PayStatement == _payStatement.RecId
                &&    payStatementEarningLine.AccountingCurrencyAmount > 0
                &&    payStatementEarningLine.Source != PayrollPayStatementLineSource::FringeBenefitRecover
            {
                sourceDocumentLines.addEnd(payStatementEarningLine.SourceDocumentLine);
            }
        }
        else
        {
            while select SourceDocumentLine from payStatementEarningLine
                where payStatementEarningLine.PayStatement == _payStatement.RecId
                &&    payStatementEarningLine.AccountingCurrencyAmount < 0
                &&    payStatementEarningLine.Source != PayrollPayStatementLineSource::FringeBenefitRecover
            {
                sourceDocumentLines.addEnd(payStatementEarningLine.SourceDocumentLine);
            }
        }

        if (sourceDocumentLines.elements() > 0)
        {
            templateRecIdMap = PayrollPayStatementLine::createAcctDistDetailFromSourceDocLines(sourceDocumentLines, _accountingDistributionTemplRecId);
        }
        else
        {
            // Pay statements can have no or zero earnings lines; determine the distributions from the primary position of the worker.
            templateRecIdMap = PayrollPayStatementLine::createAcctDistDetailFromPrimaryPos(_payStatement, _accountingDistributionTemplRecId);
        }

        return templateRecIdMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAccountingDistributionTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates an accounting accounting distribution template used during the
    ///     creation of pay statement line.
    /// </summary>
    /// <returns>
    ///     The record ID of the accounting distribution template.
    /// </returns>
    /// <remarks>
    ///     This method guarantees that a new template record will be created by doing a
    ///     retry on any <c>DuplicateKeyException</c>.
    /// </remarks>
    public static AccountingDistributionTemplateRecId createAccountingDistributionTemplate()
    {
        AccountingDistributionTemplate accountingDistTemplate;

        try
        {
            ttsbegin;

            accountingDistTemplate.clear();
            accountingDistTemplate.Name = guid2str(newGuid());
            accountingDistTemplate.insert();

            ttscommit;
        }
        catch(Exception::DuplicateKeyException)
        {
            retry;
        }

        return accountingDistTemplate.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAcctDistDetailFromSourceDocLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates accounting distribution detail records containing the distribution information
    ///     based on the pay statement source document lines and the distribution template.
    /// </summary>
    /// <param name="_sourceDocumentLines">
    ///     A <c>List</c> containing the record IDs of <c>SourceDocumentLine</c> records of the
    ///     statement records used to base distributions upon.
    /// </param>
    /// <param name="_accountingDistributionTemplRecId">
    ///     The record ID of accouting distribution template.
    /// </param>
    /// <param name="_flipSign">
    ///     Indicates that the amount sign should be inverted.
    /// </param>
    /// <returns>
    ///     A map of the project accounting distribution information.
    /// </returns>
    public static Map createAcctDistDetailFromSourceDocLines(List _sourceDocumentLines, AccountingDistributionTemplateRecId _accountingDistributionTemplRecId, boolean _flipSign=false)
    {
        #PayrollConstants

        AccountingDistribution                  accountingDistribution;
        AccountingDistributionTemplateDetail    accountingDistTemplateDetail;
        ProjectAccountingDistribution           projectAccountingDistribution;
        DimensionDefault                        defaultDimension;
        AmountCur                               transactionCurrencyAmount;
        AccountingDistribution                  accountingDistributionTotal;
        PayrollPayStatementEarningLine          payStatementEarningLine;
        HcmPositionDefaultDimension             positionDefaultDimension;

        container       projInfo;
        container       compareProjInfo;
        container       templateLines;
        Map             defaultDimensionMap = new Map(Types::Int64, Types::Container);
        Map             templateAmountMap = new Map(Types::Integer, Types::Real);
        Map             templateProjInfoMap = new Map(Types::Integer, Types::Container);
        Map             templateRecIdMap = new Map(Types::Int64, Types::Container);
        MapEnumerator   defaultDimensionMapEnum;
        ListIterator    sourceDocumentLinesIterator;

        AmountCur   currentAmount;
        AmountCur   totalAmount;
        Counter     defaultDimensionCount;
        Counter     templateLineIdx;
        real        percent = 0;
        real        totalPercent = 0;
        int         templateLine = 0;
        int         lineNum = 1;
        boolean     addNewTemplateLine;
        boolean     isMatchingLineFound;

        // Process the source document lines supplied
        sourceDocumentLinesIterator = new ListIterator(_sourceDocumentLines);
        while (sourceDocumentLinesIterator.more())
        {
            // The amounts on individual distribution lines may have been rounded, so we need to the total amount to get the precise value
            select sum(TransactionCurrencyAmount) from accountingDistributionTotal
                where accountingDistributionTotal.SourceDocumentLine == sourceDocumentLinesIterator.value();

            //
            // Get the position's default dimension so that it can be merged below since the account structure may be different for
            // benefit and tax lines than for earning lines.  Only benefit and tax line template creation logic will run this method so
            // no need to explicitly exclude pay statement earning lines.
            //
            select firstonly Position from payStatementEarningLine
                where payStatementEarningLine.SourceDocumentLine == sourceDocumentLinesIterator.value();
            positionDefaultDimension = HcmPositionDefaultDimension::findByPositionLegalEntity(payStatementEarningLine.Position, CompanyInfo::current());

            while select RecId, LedgerDimension, AllocationFactor from accountingDistribution
                where accountingDistribution.SourceDocumentLine == sourceDocumentLinesIterator.value()
            {
                projectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(accountingDistribution.RecId);
                defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountingDistribution.LedgerDimension);

                // Merge the default dimension (which has priority) with the position's default dimension
                defaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(defaultDimension, positionDefaultDimension.DefaultDimension);

                projInfo = [projectAccountingDistribution.ProjTable,
                            projectAccountingDistribution.ProjCategory,
                            projectAccountingDistribution.SmmActivities,
                            projectAccountingDistribution.ProjFundingSource,
                            projectAccountingDistribution.ProjLineProperty];

                transactionCurrencyAmount = accountingDistributionTotal.TransactionCurrencyAmount * accountingDistribution.AllocationFactor;
                if (_flipSign)
                {
                    transactionCurrencyAmount = -1 * accountingDistributionTotal.TransactionCurrencyAmount * accountingDistribution.AllocationFactor;
                }

                addNewTemplateLine = false;
                if (defaultDimensionMap.exists(defaultDimension))
                {
                    isMatchingLineFound = false;
                    templateLines = defaultDimensionMap.lookup(defaultDimension);
                    for (templateLineIdx = 1; templateLineIdx <= conLen(templateLines); templateLineIdx++)
                    {
                        templateLine = conPeek(templateLines, templateLineIdx);
                        compareProjInfo = templateProjInfoMap.lookup(templateLine);
                        if (conPeek(projInfo, 1) == conPeek(compareProjInfo, 1)
                            && conPeek(projInfo, 2) == conPeek(compareProjInfo, 2)
                            && conPeek(projInfo, 3) == conPeek(compareProjInfo, 3)
                            && conPeek(projInfo, 4) == conPeek(compareProjInfo, 4)
                            && conPeek(projInfo, 5) == conPeek(compareProjInfo, 5))
                        {
                            // The project information is the same, so simply add this amount to the existing template line
                            currentAmount = templateAmountMap.lookup(templateLine);
                            templateAmountMap.insert(templateLine, currentAmount + transactionCurrencyAmount);
                            isMatchingLineFound = true;
                            break;
                        }
                    }

                    if (!isMatchingLineFound)
                    {
                        addNewTemplateLine = true;

                        // Add the new template line to the map for the DefaultDimension
                        templateLines += lineNum;
                        defaultDimensionMap.insert(defaultDimension, templateLines);
                    }
                }
                else
                {
                    // The DefaultDimension does not exist in the template, so add the new template line
                    defaultDimensionMap.insert(defaultDimension, [lineNum]);
                    addNewTemplateLine = true;
                }

                if (addNewTemplateLine)
                {
                    templateAmountMap.insert(lineNum, transactionCurrencyAmount);
                    templateProjInfoMap.insert(lineNum, projInfo);
                }
                lineNum++;
                totalAmount += transactionCurrencyAmount;
            }

            // Advance the source document lines list iterator
            sourceDocumentLinesIterator.next();
        }

        if (totalAmount != 0)
        {
            defaultDimensionMapEnum = new MapEnumerator(defaultDimensionMap);
            while (defaultDimensionMapEnum.moveNext())
            {
                templateLines = defaultDimensionMapEnum.currentValue();
                defaultDimensionCount++;
                for (templateLineIdx = 1; templateLineIdx <= conLen(templateLines); templateLineIdx++)
                {
                    templateLine = conPeek(templateLines, templateLineIdx);

                    percent = decRound(templateAmountMap.lookup(templateLine) / totalAmount * 100.0, #RateDecimalPlaces);
                    totalPercent += percent;

                    if (defaultDimensionCount == defaultDimensionMap.elements() && templateLineIdx == conLen(templateLines))
                    {
                        // Adjust for rounding error
                        percent += 100 - totalPercent;
                    }

                    accountingDistTemplateDetail.DistributionTemplate = _accountingDistributionTemplRecId;
                    accountingDistTemplateDetail.DistributionPercent = percent;
                    accountingDistTemplateDetail.DefaultDimension = defaultDimensionMapEnum.currentKey();
                    accountingDistTemplateDetail.insert();

                    // Map the created template RecId with the project info
                    projInfo = templateProjInfoMap.lookup(templateLine);
                    templateRecIdMap.insert(accountingDistTemplateDetail.RecId, projInfo);
                }
            }
        }

        return templateRecIdMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAcctDistDetailFromPrimaryPos</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates accounting distribution detail records containing the distribution information
    ///     based on the pay statement worker's primary position and its distribution template.
    /// </summary>
    /// <param name="_payStatement">
    ///     The pay statement header.
    /// </param>
    /// <param name="_accountingDistributionTemplRecId">
    ///     The record ID of accounting distribution template.
    /// </param>
    /// <returns>
    ///     A map of the accounting distribution information.
    /// </returns>
    /// <remarks>
    ///     There will not be any project accounting distribution information in the returned map
    ///     because the distributions were determined from the primary position and not earnings.
    /// </remarks>
    public static Map createAcctDistDetailFromPrimaryPos(
        PayrollPayStatement _payStatement,
        AccountingDistributionTemplateRecId _accountingDistributionTemplRecId)

    {
        real percent = 100.00;
        AccountingDistributionTemplateDetail accountingDistTemplateDetail;

        Map templateRecIdMap = new Map(Types::Int64, Types::Container);
        PayrollPayPeriod payPeriod = PayrollPayPeriod::find(_payStatement.PayPeriod);

        utcDateTime periodEndDateTime = DateTimeUtil::newDateTime(payPeriod.PeriodEndDate, 0);
        utcDateTime primaryPositionDateTime = HcmDateTimeUtil::endOfCompanyDay(periodEndDateTime);

        HcmPositionRecId workerPrimaryPosition = HcmWorkerHelper::getPrimaryPosition(_payStatement.Worker, primaryPositionDateTime);
        HcmPositionDefaultDimension primaryPositionDefaultDimension = HcmPositionDefaultDimension::findByPositionLegalEntity(workerPrimaryPosition, CompanyInfo::current());

        if (primaryPositionDefaultDimension.RecId != 0)
        {
            // No project accounting distribution information is expected when distributions are generated from primary position.
            container emptyProjInfo = [0, 0, 0, 0, 0];

            if (primaryPositionDefaultDimension.AccountingDistributionTemplate)
            {
                AccountingDistributionTemplateDetail primaryPositionAcctDistTempDetail;

                // Create the accounting distributions using the position's distribution template.
                while select DefaultDimension, DistributionPercent from primaryPositionAcctDistTempDetail
                    where primaryPositionAcctDistTempDetail.DistributionTemplate == primaryPositionDefaultDimension.AccountingDistributionTemplate
                {
                    // Merge the position's template default dimension (which has priority) with the position's default dimension.
                    DimensionDefault defaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(
                        primaryPositionAcctDistTempDetail.DefaultDimension,
                        primaryPositionDefaultDimension.DefaultDimension);

                    accountingDistTemplateDetail.DistributionTemplate = _accountingDistributionTemplRecId;
                    accountingDistTemplateDetail.DistributionPercent = primaryPositionAcctDistTempDetail.DistributionPercent;
                    accountingDistTemplateDetail.DefaultDimension = defaultDimension;
                    accountingDistTemplateDetail.insert();

                    templateRecIdMap.insert(accountingDistTemplateDetail.RecId, emptyProjInfo);
                }
            }
            else
            {
                // Create the accounting distributions using the position's default distributions.
                accountingDistTemplateDetail.DistributionTemplate = _accountingDistributionTemplRecId;
                accountingDistTemplateDetail.DistributionPercent = percent;
                accountingDistTemplateDetail.DefaultDimension = primaryPositionDefaultDimension.DefaultDimension;
                accountingDistTemplateDetail.insert();

                templateRecIdMap.insert(accountingDistTemplateDetail.RecId, emptyProjInfo);
            }
        }

        return templateRecIdMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a record ID exists in <c>PayrollPayStatementLine</c> table.
    /// </summary>
    /// <param name="_recId">
    /// The value of the record ID to check.
    /// </param>
    /// <returns>
    /// true if the record ID exists; otherwise, false.
    /// </returns>
    public static boolean exist(PayrollPayStatementLineRecId _recId)
    {
        return _recId && (select firstonly RecId from payrollPayStatementLine
                    where payrollPayStatementLine.RecId == _recId).RecId!= 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a record in the <c>PayrollPayStatementLine</c> table based on a record ID value.
    /// </summary>
    /// <param name="_recId">
    /// The value of the record ID to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that specifies whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// An enumeration value that indicates whether concurrency setting to be used on the table; optional.
    /// </param>
    /// <returns>
    /// A record from the <c>PayrollPayStatementLine</c> table.
    /// </returns>
    public static PayrollPayStatementLine find(
        PayrollPayStatementLineRecId         _recId,
        boolean             _forUpdate = false,
        ConcurrencyModel    _concurrencyModel = ConcurrencyModel::Auto)
    {
        PayrollPayStatementLine payrollPayStatementLine;

        payrollPayStatementLine.selectForUpdate(_forUpdate );
        if (_forUpdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            payrollPayStatementLine.concurrencyModel(_concurrencyModel);
        }

        select firstonly payrollPayStatementLine
             where payrollPayStatementLine.RecId == _recId;

        return payrollPayStatementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a record in the <c>PayrollPayStatementLine</c> table based on supplied value of the <c>SourceDocumentLine</c> field.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    /// The value of the <c>SourceDocumentLine</c> field to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that specifies whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// An enumeration value that indicates whether concurrency setting to be used on the table; optional.
    /// </param>
    /// <returns>
    /// A record from the <c>PayrollPayStatementLine</c> table.
    /// </returns>
    public static PayrollPayStatementLine findBySourceDocumentLine(
        SourceDocumentLineRecId _sourceDocumentLine,
        boolean             _forUpdate = false,
        ConcurrencyModel    _concurrencyModel = ConcurrencyModel::Auto)
    {
        PayrollPayStatementLine payrollPayStatementLine;

        payrollPayStatementLine.selectForUpdate(_forUpdate );
        if (_forUpdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            payrollPayStatementLine.concurrencyModel(_concurrencyModel);
        }

        select firstonly payrollPayStatementLine
            where payrollPayStatementLine.SourceDocumentLine == _sourceDocumentLine;

        return payrollPayStatementLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaystatmentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Change the status of <c>PayrollPayStatement</c> to reclaculate required.
    /// </summary>
    /// <param name="_sourceDocumentRecId">
    ///     Record id of the <c>SourceDocument</c>.
    /// </param>
    public static void setPaystatmentHeader(SourceDocumentHeaderRecId _sourceDocumentRecId)
    {
        PayrollPayStatement payStatement;

        payStatement = PayrollPayStatement::findBySourceDocumentHeader(_sourceDocumentRecId, true);

        ttsbegin;
        payStatement.PaymentStatus = PayrollPaymentStatus::RequiresRecalculation;
        payStatement.write();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    public static TxtNotExist txtNotExist()
    {
        return "@SYS321009";
    }

]]></Source>
			</Method>
			<Method>
				<Name>PayrollPayStatement</Name>
				<Source><![CDATA[
    public PayrollPayStatement PayrollPayStatement(PayrollPayStatement _relatedTable = null)
    {
        if (prmIsDefault(_relatedTable))
        {
            return this.setLink('PayrollPayStatement');
        }
        else
        {
            return this.setLink('PayrollPayStatement', _relatedTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjAccountDistForEarnings</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates project accounting distributions for pay statement earnings lines.
    /// </summary>
    public void createProjAccountDistForEarnings()
    {
        AccountingDistribution          accountingDistribution;
        ProjectAccountingDistribution   originalProjectAccountingDistribution,
                                        newProjectAccountingDistribution;

        RecordInsertList                projectAccountingDistributionList;

        projectAccountingDistributionList = new RecordInsertList(tableNum(ProjectAccountingDistribution));

        // Retrieve the accounting distributions off the newly created pay statement earning line
        while select accountingDistribution
            where accountingDistribution.SourceDocumentLine == this.SourceDocumentLine
        {
			//
			// Retrieve project information associated with the original earning statement line accounting distribution. Even if
			// there had been more than one accounting distribution on the original earning statement line, it is accurate to reference
			// back to a single accounting distribution since any consolidating when creating the current pay statement earning line's
			// accounting distributions would have consolidated by the same attributes.
			//
			originalProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(accountingDistribution.ReferenceDistribution);

            if (originalProjectAccountingDistribution.ProjTable != 0
                || originalProjectAccountingDistribution.ProjCategory != 0
                || originalProjectAccountingDistribution.SmmActivities != 0
                || originalProjectAccountingDistribution.ProjFundingSource != 0
                || originalProjectAccountingDistribution.ProjLineProperty != 0)
            {
                newProjectAccountingDistribution.clear();
                newProjectAccountingDistribution.AccountingDistribution = accountingDistribution.RecId;
                newProjectAccountingDistribution.ProjTable              = originalProjectAccountingDistribution.ProjTable;
                newProjectAccountingDistribution.ProjCategory           = originalProjectAccountingDistribution.ProjCategory;

                newProjectAccountingDistribution.SmmActivities          = originalProjectAccountingDistribution.SmmActivities;
                newProjectAccountingDistribution.ProjFundingSource      = originalProjectAccountingDistribution.ProjFundingSource;
                newProjectAccountingDistribution.ProjLineProperty       = originalProjectAccountingDistribution.ProjLineProperty;
                newProjectAccountingDistribution.Currency = Currency::find(accountingDistribution.TransactionCurrency).RecId;

                // Update the accounting distribution for the pay statement earning line with the new project information
                ProjectAccountingDistribution::fieldModifiedCategoryIdPost(accountingDistribution, newProjectAccountingDistribution);

                if (newProjectAccountingDistribution.validateWrite())
                {
                    projectAccountingDistributionList.add(newProjectAccountingDistribution);
                }
            }
        }
        projectAccountingDistributionList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last line number of a paystatement.
    /// </summary>
    /// <param name="_payStatementRecId">
    /// A paystatement recId.
    /// </param>
    /// <returns>
    /// The line number of the last line in the paystatement, if one exists; otherwise, zero.
    /// </returns>
    public static LineNum lastLineNum(PayrollPayStatementRecId _payStatementRecId)
    {
        PayrollPayStatementLine payrollPayStatementLine;

        return (select maxof(LineNum) from payrollPayStatementLine
                   where payrollPayStatementLine.PayStatement == _payStatementRecId).LineNum;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>PayrollAdministration</ConfigurationKey>
	<DeveloperDocumentation>@Payroll:ThePayrollpaystatementlineTableHoldsThePayStatementLines</DeveloperDocumentation>
	<Label>@Payroll:PayStatementLines</Label>
	<SingularLabel>@Payroll:PayStatementLine</SingularLabel>
	<TableGroup>WorksheetLine</TableGroup>
	<TitleField1>PayStatement</TitleField1>
	<TitleField2>Position</TitleField2>
	<Abstract>Yes</Abstract>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<InstanceRelationType>InstanceRelationType</InstanceRelationType>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Payroll</Modules>
	<SupportInheritance>Yes</SupportInheritance>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>SourceDocumentLine</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>SourceDocumentLine</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountingDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Position</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountingCurrencyAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@Payroll:Overview1</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountingCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountingDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountingDistributionTemplate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsEmployer</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsLineLocked</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsMarkedForRemoval</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsPayStatementLineOverridden</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayStatement</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Position</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Source</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AccountingCurrencyAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PayrollStatementAccountingCurrencyAmount</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>AccountingDate</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AccountingDate</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>AccountingDistributionTemplate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AccountingDistributionTemplateRecId</ExtendedDataType>
			<Label>@SYS30829</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InstanceRelationType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RelationType</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsEmployer</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@Payroll:EmployerContribution</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsLineLocked</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@Payroll:LineLocked</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsMarkedForRemoval</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@Payroll:LineToRemove</Label>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsPayStatementLineOverridden</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@Payroll:LineLocked</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PayStatement</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PayrollPayStatementRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Position</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>HcmPositionRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ReversedPayStatementLine</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PayrollPayStatementLineRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Source</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<EnumType>PayrollPayStatementLineSource</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceDocumentLine</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>SourceDocumentLineRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>VendTrans</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VendTransRefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LineNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>LineNum</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>SourceDocumentLineIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceDocumentLine</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>dataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PayStatementIsMarkedForRemovalIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>PayStatement</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>IsMarkedForRemoval</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InstanceRelationType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Source</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LineNumIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>PayStatement</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNum</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SourceDocumentLineImplementation</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>SourceDocumentLine</MapField>
					<MapFieldTo>SourceDocumentLine</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AccountingDistributionTemplate_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>AccountingDistributionTemplate</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountingDistributionTemplate</Name>
					<Field>AccountingDistributionTemplate</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PayStatement_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<CreateNavigationPropertyMethods>Yes</CreateNavigationPropertyMethods>
			<RelatedTable>PayrollPayStatement</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PayStatement</Name>
					<Field>PayStatement</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Position_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmPosition</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Position</Name>
					<Field>Position</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ReversedPayStatementLine_FK</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>PayrollPayStatementLine</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>PayrollPayStatementLine</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReversedPayStatementLine</Name>
					<Field>ReversedPayStatementLine</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SourceDocumentLine_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SourceDocumentLine</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceDocumentLine</Name>
					<Field>SourceDocumentLine</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VendTrans_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendTrans</Name>
					<SourceEDT>VendTransRefRecId</SourceEDT>
					<Field>VendTrans</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>