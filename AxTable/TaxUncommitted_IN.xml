<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxUncommitted_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class TaxUncommitted_IN extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>initFromTmpTaxWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method copies all of the fields from TmpTaxWorkTrans (in-memory table) to <c>TaxUncommitted_IN</c>.
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    ///    The buffer for TmpTaxWorkTrans which has the record to be copied.
    /// </param>
    /// <param name="_taxCode">
    ///    The tax code for current line. Optional.
    /// </param>
    public void initFromTmpTaxWorkTrans(
        TmpTaxWorkTrans _tmpTaxWorkTrans,
        TaxCode         _taxCode = '')
    {
        TaxCode             taxCode = (_taxCode) ? _taxCode : _tmpTaxWorkTrans.TaxCode;
        LedgerJournalTrans  ledgerJournalTrans;
        TaxTable            taxTable = TaxTable::find(_taxCode);

        this.FormulaID                              = _tmpTaxWorkTrans.FormulaID_IN;
        this.CustomsDuty                            = _tmpTaxWorkTrans.CustomsDuty_IN;
        this.EximTaxAmount                          = _tmpTaxWorkTrans.EximTaxAmount_IN;
        this.TaxAccountType                         = _tmpTaxWorkTrans.TaxAccountType_IN;
        this.EximDEPBAmount                         = _tmpTaxWorkTrans.EximDEPBAmount_IN;
        this.AbatementAmount                        = _tmpTaxWorkTrans.AbatementAmount_IN;
        this.EximTaxAmountCur                       = _tmpTaxWorkTrans.EximTaxAmountCur_IN;
        this.EximDEPBAmountCur                      = _tmpTaxWorkTrans.EximDEPBAmountCur_IN;
        this.EximIncentiveScheme                    = _tmpTaxWorkTrans.EximIncentiveScheme_IN;
        this.EximBalanceTaxAmount                   = _tmpTaxWorkTrans.EximBalanceTaxAmount_IN;
        this.EximTaxCorrectedAmount                 = _tmpTaxWorkTrans.EximTaxCorrectedAmount_IN;
        this.EximAuthorizationId                    = _tmpTaxWorkTrans.EximAuthorizationId_IN;
        this.EximBalanceTaxAmountCur                = _tmpTaxWorkTrans.EximBalanceTaxAmountCur_IN;
        this.EximTaxCorrectedAmountCur              = _tmpTaxWorkTrans.EximTaxCorrectedAmountCur_IN;
        this.SourceRegulateAmountCustoms            = _tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN;
        this.EximBalanceTaxCorrectedAmount          = _tmpTaxWorkTrans.EximBalanceTaxCorrectedAmount_IN;
        this.EximBalanceTaxCorrectedAmountCur       = _tmpTaxWorkTrans.EximBalanceTaxCorrectedAmountCur_IN;

        if (_tmpTaxWorkTrans.SourceTableId         == tableNum(LedgerJournalTrans)
            && TaxTable::find(_taxCode).TaxType_IN == TaxType_IN::ServiceTax )
        {
            ledgerJournalTrans = LedgerJournalTrans::findRecId(_tmpTaxWorkTrans.SourceRecId, false);
            if (ledgerJournalTrans.isPaymentJournal_IN())
            {
                this.MainVoucher = ledgerJournalTrans.Voucher;
            }
        }

        if (TaxTable::find(taxCode).TaxType_IN != TaxType_IN::None)
        {
            this.LoadOnInventoryTax =
                _tmpTaxWorkTrans.TaxAutogenerated ? _tmpTaxWorkTrans.TaxInCostPrice : _tmpTaxWorkTrans.TaxInCostPriceRegulated;
        }

        this.IsScrapQtyLine_IN                      = _tmpTaxWorkTrans.IsScrapQtyLine_IN;
        this.ClaimPercentage                        = _tmpTaxWorkTrans.ClaimPercentage_IN;
        this.TaxRegistrationNumberTable_IN          = _tmpTaxWorkTrans.TaxRegistrationNumberTable_IN;
        if (taxTable.TaxType_IN == TaxType_IN::ServiceTax)
        {
            this.ServiceTaxReverseChargePercentage   = _tmpTaxWorkTrans.ServiceTaxReverseChargePercentage_IN;
            this.ServTaxRevChargeOriginAmountCur_IN  = _tmpTaxWorkTrans.SourceRegulateAmountCur;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomsDutyPerExchangeRate_IN</Name>
				<Source><![CDATA[
    private TmpTaxWorkTrans updateCustomsDutyPerExchangeRate_IN(TmpTaxWorkTrans _tmpTaxWorkTrans)
    {
        AllocationFactor          factor;
        PurchQty                  invoiceQtyMinusBOEQty;
        TmpTaxWorkTrans           tmpTaxWorkTrans;
        EximVendBOESubTrans_IN    eximVendBOESubTrans;
        CustomsVendBOETrans_IN    customsVendBOETrans;
        CustomsVendBOESubTrans_IN customsVendBOESubTrans;
        VendInvoiceInfoLine       vendInvoiceInfoLineCopy;

        #LocalMacro.BOESubTransFieldList
            RecId,
            BOETransRefRecId,
            SourceTaxAmountCur,
            TaxAmountCur,
            SourceRegulateAmountCur,
            SourceBaseAmountCurRegulated,
            SourceTaxAmountCurReal,
            CustomsDuty,
            SourceRegulateAmountCustoms_IN
        #EndMacro

        #LocalMacro.BOETransFieldList
            RemainingQty,
            BillOfEntryQty
        #EndMacro

        vendInvoiceInfoLineCopy = VendInvoiceInfoLine::findRecId(_tmpTaxWorkTrans.SourceRecId);
        customsVendBOETrans = VendDocumentLineMap::getCustomsVendBOETrans_IN(vendInvoiceInfoLineCopy.RecId, vendInvoiceInfoLineCopy.ParmId, vendInvoiceInfoLineCopy.TableId);

        tmpTaxWorkTrans = _tmpTaxWorkTrans;
        invoiceQtyMinusBOEQty = vendInvoiceInfoLineCopy.ReceiveNow;
        if (!invoiceQtyMinusBOEQty)
        {
            invoiceQtyMinusBOEQty = PurchLine::findRecId(vendInvoiceInfoLineCopy.PurchLineRecId).PurchQty;
        }
        while select #BOESubTransFieldList from customsVendBOESubTrans
            order by RecId, BillOfEntryDate
            where customsVendBOESubTrans.InventTransId == _tmpTaxWorkTrans.InventTransId
                && customsVendBOESubTrans.TaxCode      == _tmpTaxWorkTrans.TaxCode
                && customsVendBOESubTrans.boeTransRefRecId == customsVendBOETrans.RecId
        {
            if (invoiceQtyMinusBOEQty <= 0)
            {
                break;
            }
            else if (abs(customsVendBOETrans.RemainingQty) > 0)
            {
                if (invoiceQtyMinusBOEQty >= 0)
                {
                    factor = (invoiceQtyMinusBOEQty >= customsVendBOETrans.RemainingQty) ?
                                (customsVendBOETrans.RemainingQty / customsVendBOETrans.BillOfEntryQty)
                                : (abs(invoiceQtyMinusBOEQty) / customsVendBOETrans.BillOfEntryQty);
                }
                tmpTaxWorkTrans.SourceTaxAmountCur              += (factor * customsVendBOESubTrans.SourceTaxAmountCur);
                tmpTaxWorkTrans.TaxAmountCur                    += (factor * customsVendBOESubTrans.TaxAmountCur);
                tmpTaxWorkTrans.SourceRegulateAmountCur         += (factor * customsVendBOESubTrans.SourceRegulateAmountCur);
                tmpTaxWorkTrans.SourceBaseAmountCurRegulated    += (factor * customsVendBOESubTrans.SourceBaseAmountCurRegulated);
                tmpTaxWorkTrans.SourceTaxAmountCurReal          += (factor * customsVendBOESubTrans.SourceTaxAmountCurReal);
                tmpTaxWorkTrans.CustomsDuty_IN                  += (factor * customsVendBOESubTrans.CustomsDuty);
                tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN  += (factor * customsVendBOESubTrans.SourceRegulateAmountCustoms_IN);

                eximVendBOESubTrans = EximVendBOESubTrans_IN::findRefRecId(customsVendBOESubTrans.RecId);
                if (eximVendBOESubTrans.IncentiveScheme != EximIncentiveScheme_IN::None)
                {
                    tmpTaxWorkTrans.EximBalanceTaxCorrectedAmount_IN    += (factor * eximVendBOESubTrans.BalanceTaxCorrectedAmount);
                    tmpTaxWorkTrans.EximTaxCorrectedAmountCur_IN        += (factor * eximVendBOESubTrans.TaxCorrectedAmountCur);
                    tmpTaxWorkTrans.EximBalanceTaxCorrectedAmountCur_IN += (factor * eximVendBOESubTrans.BalanceTaxCorrectedAmountCur);
                    tmpTaxWorkTrans.EximIncentiveScheme_IN              = eximVendBOESubTrans.IncentiveScheme;
                    tmpTaxWorkTrans.EximTaxAmountCur_IN                 += (factor * eximVendBOESubTrans.TaxAmountCur);
                    tmpTaxWorkTrans.EximTaxAmount_IN                    += (factor * eximVendBOESubTrans.TaxAmount);
                    tmpTaxWorkTrans.EximTaxCorrectedAmount_IN           += (factor * eximVendBOESubTrans.TaxCorrectedAmount);
                    tmpTaxWorkTrans.EximBalanceTaxAmountCur_IN          += (factor * eximVendBOESubTrans.BalanceTaxAmountCur);
                    tmpTaxWorkTrans.EximBalanceTaxAmount_IN             += (factor * eximVendBOESubTrans.BalanceTaxAmount);
                    tmpTaxWorkTrans.EximDEPBAmountCur_IN                += (factor * eximVendBOESubTrans.depbAmountCur);
                    tmpTaxWorkTrans.EximDEPBAmount_IN                   += (factor * eximVendBOESubTrans.depbAmount);
                }

                invoiceQtyMinusBOEQty = (invoiceQtyMinusBOEQty - customsVendBOETrans.RemainingQty);
            }
        }

        return tmpTaxWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Creates the <c>TaxUncommitted_IN</c> records for India.
    /// </summary>
    /// <param name="_taxCalculation">
    ///   The instance of the tax calculation class used to calculate taxes.
    /// </param>
    /// <param name="_skipNotExistsCheck">
    ///   true if the calling code has verified already that no tax uncommitted records exist and the query
    ///   to find them can be skipped; otherwise, false.
    /// </param>
    public static void createTaxUncommitted(Tax _taxCalculation, boolean _skipNotExistsCheck = false)
    {
        TmpTaxWorkTrans     tmpTaxWorkTrans = _taxCalculation.tmpTaxWorkTrans();
        TaxUncommitted      taxUncommittedLoc;
        TaxUncommitted_IN   taxUncommittedIN;
        TaxUncommitted_IN   taxUncommitted_INExists;
        RecordInsertList    taxUncommitted_INList;

        taxUncommitted_INList = new RecordInsertList(tableNum(TaxUncommitted_IN));

        ttsbegin;

        // Update existed records in TaxUncommitted_IN
        if (_taxCalculation.getMaintainExistingTaxUncommitted())
        {
            while select * from tmpTaxWorkTrans
                    where tmpTaxWorkTrans.HeadingRecId      == _taxCalculation.headingRecId()
                       && tmpTaxWorkTrans.HeadingTableId    == _taxCalculation.headingTableId()
                join TaxCode, RecId from taxUncommittedLoc
                    where tmpTaxWorkTrans.SourceTableId == taxUncommittedLoc.SourceTableId
                       && tmpTaxWorkTrans.SourceRecId   == taxUncommittedLoc.SourceRecId
                       && tmpTaxWorkTrans.TaxCode       == taxUncommittedLoc.TaxCode
                join forupdate taxUncommittedIN
                    where taxUncommittedIN.TaxUncommitted == taxUncommittedLoc.RecId
            {
                taxUncommittedIN.initFromTmpTaxWorkTrans(tmpTaxWorkTrans, taxUncommittedLoc.TaxCode);
                taxUncommittedIN.update();
            }
        }

        // Insert record in TaxUncommitted_IN for new created TaxUncommitted records
        if (_skipNotExistsCheck)
        {
            while select * from tmpTaxWorkTrans
                    where tmpTaxWorkTrans.HeadingRecId == _taxCalculation.headingRecId()
                       && tmpTaxWorkTrans.HeadingTableId == _taxCalculation.headingTableId()
                join TaxCode, RecId from taxUncommittedLoc
                    where tmpTaxWorkTrans.SourceTableId == taxUncommittedLoc.SourceTableId
                       && tmpTaxWorkTrans.SourceRecId   == taxUncommittedLoc.SourceRecId
                       && tmpTaxWorkTrans.TaxCode       == taxUncommittedLoc.TaxCode
            {
                taxUncommittedIN.clear();
                taxUncommittedIN.initFromTmpTaxWorkTrans(tmpTaxWorkTrans, taxUncommittedLoc.TaxCode);
                taxUncommittedIN.TaxUncommitted = taxUncommittedLoc.RecId;

                taxUncommitted_INList.add(taxUncommittedIN);
            }
        }
        else
        {
            while select * from tmpTaxWorkTrans
                    where tmpTaxWorkTrans.HeadingRecId == _taxCalculation.headingRecId()
                       && tmpTaxWorkTrans.HeadingTableId == _taxCalculation.headingTableId()
                join TaxCode, RecId from taxUncommittedLoc
                    where tmpTaxWorkTrans.SourceTableId == taxUncommittedLoc.SourceTableId
                       && tmpTaxWorkTrans.SourceRecId   == taxUncommittedLoc.SourceRecId
                       && tmpTaxWorkTrans.TaxCode       == taxUncommittedLoc.TaxCode
                notexists join taxUncommitted_INExists
                    where taxUncommitted_INExists.TaxUncommitted == taxUncommittedLoc.RecId
            {
                taxUncommittedIN.clear();
                taxUncommittedIN.initFromTmpTaxWorkTrans(tmpTaxWorkTrans, taxUncommittedLoc.TaxCode);
                taxUncommittedIN.TaxUncommitted = taxUncommittedLoc.RecId;

                taxUncommitted_INList.add(taxUncommittedIN);
            }
        }

        taxUncommitted_INList.insertDatabase();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteByMainVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the specified <c>TaxUncommitted</c> and <c>TaxUncommitted_IN</c>records for 'SERVICE TAX'.
    /// A new field for service tax called 'MainVoucher' (currently service tax only uses it) is added to TAxUncommitted_IN. This stores the LedgerJournalTrans.Voucher
    /// Which is different from TaxUncommitted.voucher for service tax. For other taxes this will be blank as TaxUncommitted.voucher == LJTrans.voucher
    /// </summary>
    /// <param name="_documentTableId">
    /// The document table ID.
    /// </param>
    /// <param name="_documentId">
    /// The document record ID.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    public static void deleteByMainVoucher(
        RefTableId _documentTableId,
        RefRecId _documentId,
        Voucher _voucher)
    {
        TaxUncommitted      taxUncommitted;
        TaxUncommitted_IN   taxUncommittedIN;

        ttsBegin;

        delete_from taxUncommitted
            where taxUncommitted.HeadingRecId   == _documentId
               && taxUncommitted.HeadingTableId == _documentTableId
            exists join taxUncommittedIN
                where taxUncommittedIN.TaxUncommitted == taxUncommitted.RecId
                   && taxUncommittedIN.MainVoucher    == _voucher;

        delete_from taxUncommittedIN
            where taxUncommittedIN.MainVoucher == _voucher;

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if there is any uncommitted tax.
    /// </summary>
    /// <param name="_recId">
    /// The rec id.
    /// </param>
    /// <returns>
    /// Returns true if there is any uncommitted tax.
    /// </returns>
    public static boolean exist(RefRecId _recId )
    {
        boolean found;

        found = (select firstonly
                     RecId
                from
                     taxUncommitted_IN
                 where
                     taxUncommitted_IN.TaxUncommitted == _recId).RecId != 0;

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>TaxUncommitted_IN</c> record.
    /// </summary>
    /// <param name="_taxUncommitted">
    ///    A <c>TaxUncommitted</c> record RecId.
    /// </param>
    /// <returns>
    ///    A <c>TaxUncommitted_IN</c> record.
    /// </returns>
    static public TaxUncommitted_IN findByTaxUncommitted(RefRecId _taxUncommitted)
    {
        TaxUncommitted_IN     taxUncommittedIN;

        select firstonly taxUncommittedIN
            where taxUncommittedIN.TaxUncommitted == _taxUncommitted;

        return taxUncommittedIN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomsDuty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates total customs duty for sourceTableId and sourceRecId.
    /// </summary>
    /// <param name="_sourceTableId">
    /// Source Table ID of VendinVoice table
    /// </param>
    /// <param name="_sourceRecId">
    /// Source RecID ID of VendinVoice table
    /// </param>
    /// <param name="_ledgerVoucherObjectForChargeAsExpense">
    /// LedgerVoucher Object which is used for Posting Expense Account.
    /// </param>
    /// <returns>
    /// Total Customs Amount excluding Expense amount if any.
    /// </returns>
    /// <remarks>
    /// Calculates total customs duty for sourceTableId and sourceRecId.
    /// </remarks>
    public static TaxAmount getCustomsDuty_IN(
        RefTableId  _sourceTableId,
        RefRecId    _sourceRecId,
        LedgerVoucherObject _ledgerVoucherObjectForChargeAsExpense = null)
    {
        CurrencyExchangeHelper  exchangeRateHelper;
        PurchLine               purchLineLoc;
        LedgerPostingType       ledgerPostingType;
        LedgerDimensionAccount  purchExpforProductledgerDimension;
        TaxUncommitted          taxUncommitted;
        TaxUncommitted_IN       taxUncommittedIn;
        TaxTable                taxTable;
        TaxOnItem               taxOnItem;
        CustomsAmount_IN        customsAmount; // Total Customs Amount excluding Expense amount if any.
        CustomsAmount_IN        customsExpenseAmount; // Expense Amount for each Invoice Line taxes.
        CustomsAmount_IN        customsAmountForCalculation; // Base Tax Amount which is used to Bifurcate.
        CustomsAmount_IN        customsAmountForPEFP; // Intermidiate Customs Amount which is used to build the total amount.
        Transdate               billOfEntryDate;
        Transdate               documentDate;
        CurrencyExchangeRate    billOfEntryExchRate;
        CurrencyExchangeRate    billOfEntryExchRate1;
        VendInvoiceInfoLine     vendInvoiceInfoLine;
        CustomsVendBOETrans_IN  customsVendBOETrans;
        CustomsVendBOESubTrans_IN customsVendBOESubTrans;
        EximAuthorizationType_IN    authorizationType;
        boolean                     isPostEximVouchers;

        LedgerVoucherTransObject ledgerVoucherTransObject;

        if (_ledgerVoucherObjectForChargeAsExpense)
        {
            _ledgerVoucherObjectForChargeAsExpense.parmTrackTransactionAmountsByCurrency(true);
        }

        purchLineLoc = VendInvoiceInfoLine::findRecId(_sourceRecId).purchLine();

        if (purchLineLoc.isStocked())
        {
            ledgerPostingType = LedgerPostingType::PurchConsump;
        }
        else
        {
            ledgerPostingType = LedgerPostingType::PurchExpense;
        }

        if (purchLineLoc)
        {
            purchExpforProductledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(purchLineLoc.ledgerDimensionConsumption(), purchLineLoc.DefaultDimension);
            billOfEntryDate = CustomsVendBOETrans_IN::getCustomsBillOfEntryDate_IN(_sourceTableId, _sourceRecId);
            documentDate = VendInvoiceInfoLine::findRecId(_sourceRecId).vendInvoiceInfoTable().DocumentDate;

            vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(_sourceRecId);
            customsVendBOETrans = VendDocumentLineMap::getCustomsVendBOETrans_IN(vendInvoiceInfoLine.RecId, vendInvoiceInfoLine.ParmId, vendInvoiceInfoLine.TableId);

            if (customsVendBOETrans)
            {
                select ExchangeRate from customsVendBOESubTrans
                    where customsVendBOESubTrans.BOETransRefRecId == customsVendBOETrans.reciD;

                billOfEntryExchRate1 = customsVendBOESubTrans.ExchangeRate;
            }
            exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
        }

        // All the Custom Taxes having Exim Transaction except EPCG
        while select SourceRegulateAmountCustoms, CustomsDuty, EximTaxCorrectedAmount, EximTaxAmount, EximIncentiveScheme from taxUncommittedIn
            join TaxCode, TransDate, CurrencyCode, SourceCurrencyCode, LedgerDimension from taxUncommitted
                where taxUncommittedIn.TaxUncommitted == taxUncommitted.RecId
                    && taxUncommittedIn.EximIncentiveScheme != EximIncentiveScheme_IN::EPCG
                    && taxUncommitted.SourceTableId == _sourceTableId
                    && taxUncommitted.SourceRecId == _sourceRecId
            join CustomsChargeAsExpensePercent_IN from taxOnItem
                where taxUncommitted.TaxItemGroup == taxOnItem.TaxItemGroup
                    && taxUncommitted.TaxCode ==     taxOnItem.TaxCode
            exists join TaxType_IN from taxTable
                where taxTable.TaxCode == taxUncommitted.TaxCode
                    && taxTable.TaxType_IN == TaxType_IN::Customs
        {
            exchangeRateHelper.parmExchangeDate(billOfEntryDate ? billOfEntryDate : documentDate ? documentDate : taxUncommitted.TransDate);

            billOfEntryExchRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN((taxUncommitted.CurrencyCode == CompanyInfoHelper::standardCurrency()) ? taxUncommitted.CurrencyCode : CompanyInfoHelper::standardCurrency(),
                                                            Direction_IN::Import,
                                                            billOfEntryDate ? billOfEntryDate : documentDate ? documentDate :taxUncommitted.TransDate);

            exchangeRateHelper.parmExchangeRate1(billOfEntryExchRate);

            if (!billOfEntryExchRate1)
            {
                billOfEntryExchRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN(taxUncommitted.SourceCurrencyCode,
                                                                Direction_IN::Import,
                                                                billOfEntryDate ? billOfEntryDate : documentDate ? documentDate : taxUncommitted.TransDate);
            }
            else
            {
                billOfEntryExchRate = billOfEntryExchRate1;
            }
            exchangeRateHelper.parmExchangeRate2(billOfEntryExchRate);

            customsExpenseAmount =0;
            customsAmountForPEFP =0;
            customsAmountForCalculation =0;

            if (taxUncommittedIn.SourceRegulateAmountCustoms
                || taxUncommittedIn.CustomsDuty)
            {
                customsAmountForCalculation = taxUncommittedIn.SourceRegulateAmountCustoms ? taxUncommittedIn.SourceRegulateAmountCustoms : taxUncommittedIn.CustomsDuty;

                isPostEximVouchers = EximParameters_IN::checkParameterForPosting(str2enum(authorizationType, enum2str(taxUncommittedIN.EximIncentiveScheme)));

                if (!isPostEximVouchers && customsAmountForCalculation)
                {
                    customsAmountForCalculation -= taxUncommittedIn.EximTaxCorrectedAmount ? taxUncommittedIn.EximTaxCorrectedAmount : taxUncommittedIn.EximTaxAmount;
                }
                customsAmountForCalculation = exchangeRateHelper.calculateAccountingToTransaction(taxUncommitted.SourceCurrencyCode, customsAmountForCalculation, true);
                if (taxOnItem.CustomsChargeAsExpensePercent_IN)
                {
                    customsAmountForPEFP = roundZeroDec(customsAmountForCalculation * (100 - taxOnItem.CustomsChargeAsExpensePercent_IN)/ 100, 2);
                    customsAmount += customsAmountForPEFP;
                    customsExpenseAmount = customsAmountForCalculation - customsAmountForPEFP;
                }
                else
                {
                    customsAmount += customsAmountForCalculation;
                }
                if (customsExpenseAmount && _ledgerVoucherObjectForChargeAsExpense)
                {
                    // Expence Account posting debit entry
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObjectForChargeAsExpense,
                                                                                                    LedgerPostingType::Customs_IN,
                                                                                                    taxUncommitted.LedgerDimension,
                                                                                                    taxUncommitted.SourceCurrencyCode,
                                                                                                    customsExpenseAmount,
                                                                                                    exchangeRateHelper);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::AsDefault);
                    _ledgerVoucherObjectForChargeAsExpense.addTrans(ledgerVoucherTransObject);

                    // Purchase expenditure for Product posting credit entry
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObjectForChargeAsExpense,
                                                                                                    ledgerPostingType,
                                                                                                    purchExpforProductledgerDimension,
                                                                                                    taxUncommitted.SourceCurrencyCode,
                                                                                                    -customsExpenseAmount,
                                                                                                    exchangeRateHelper);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::AsDefault);
                    _ledgerVoucherObjectForChargeAsExpense.addTrans(ledgerVoucherTransObject);
                }
            }
        }

        // All the Custom Taxes having Exim EPCG Transaction
        while select EximTaxCorrectedAmount,
                EximBalanceTaxCorrectedAmount,
                EximTaxAmount,
                EximBalanceTaxAmount,
                EximIncentiveScheme
                from taxUncommittedIn
            join TaxCode, TransDate, CurrencyCode, SourceCurrencyCode, LedgerDimension from taxUncommitted
                where taxUncommittedIn.TaxUncommitted == taxUncommitted.RecId
                    && taxUncommittedIn.EximIncentiveScheme == EximIncentiveScheme_IN::EPCG
                    && taxUncommitted.SourceTableId == _sourceTableId
                    && taxUncommitted.SourceRecId == _sourceRecId
            join CustomsChargeAsExpensePercent_IN from taxOnItem
                where taxUncommitted.TaxItemGroup == taxOnItem.TaxItemGroup
                    && taxUncommitted.TaxCode ==     taxOnItem.TaxCode
            exists join TaxType_IN from taxTable
                where taxTable.TaxCode == taxUncommitted.TaxCode
                    && taxTable.TaxType_IN == TaxType_IN::Customs
        {
            isPostEximVouchers = EximParameters_IN::checkParameterForPosting(str2enum(authorizationType, enum2str(taxUncommittedIN.EximIncentiveScheme)));
            exchangeRateHelper.parmExchangeDate(billOfEntryDate ? billOfEntryDate : documentDate ? documentDate : taxUncommitted.TransDate);

            billOfEntryExchRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN((taxUncommitted.CurrencyCode == CompanyInfoHelper::standardCurrency()) ? taxUncommitted.CurrencyCode : CompanyInfoHelper::standardCurrency(),
                                                            Direction_IN::Import,
                                                            billOfEntryDate ? billOfEntryDate : documentDate ? documentDate : taxUncommitted.TransDate);

            exchangeRateHelper.parmExchangeRate1(billOfEntryExchRate);

            if (!billOfEntryExchRate1)
            {
                billOfEntryExchRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN(taxUncommitted.SourceCurrencyCode,
                                                                Direction_IN::Import,
                                                                billOfEntryDate ? billOfEntryDate : documentDate ? documentDate : taxUncommitted.TransDate);
            }
            else
            {
                billOfEntryExchRate = billOfEntryExchRate1;
            }
            exchangeRateHelper.parmExchangeRate2(billOfEntryExchRate);

            customsExpenseAmount =0;
            customsAmountForPEFP =0;
            customsAmountForCalculation =0;

            if (taxUncommittedIn.EximTaxCorrectedAmount
                || taxUncommittedIn.EximBalanceTaxCorrectedAmount)
            {
                customsAmountForCalculation = (taxUncommittedIn.EximTaxCorrectedAmount
                                                + taxUncommittedIn.EximBalanceTaxCorrectedAmount);

                if (!isPostEximVouchers && customsAmountForCalculation)
                {
                    customsAmountForCalculation -= taxUncommittedIn.EximTaxCorrectedAmount;
                }
                customsAmountForCalculation = exchangeRateHelper.calculateAccountingToTransaction(taxUncommitted.SourceCurrencyCode, customsAmountForCalculation, true);
                if (taxOnItem.CustomsChargeAsExpensePercent_IN)
                {
                    customsAmountForPEFP = roundZeroDec(customsAmountForCalculation * (100 - taxOnItem.CustomsChargeAsExpensePercent_IN)/ 100, 2);
                    customsAmount += customsAmountForPEFP;
                    customsExpenseAmount = customsAmountForCalculation - customsAmountForPEFP;
                }
                else
                {
                    customsAmount += customsAmountForCalculation;
                }

                if (customsExpenseAmount && _ledgerVoucherObjectForChargeAsExpense)
                {
                    // Expence Account posting debit entry
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObjectForChargeAsExpense,
                                                                                                    LedgerPostingType::Customs_IN,
                                                                                                    taxUncommitted.LedgerDimension,
                                                                                                    taxUncommitted.SourceCurrencyCode,
                                                                                                    customsExpenseAmount,
                                                                                                    exchangeRateHelper);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::AsDefault);
                    _ledgerVoucherObjectForChargeAsExpense.addTrans(ledgerVoucherTransObject);

                    // Purchase expenditure for Product posting credit entry
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObjectForChargeAsExpense,
                                                                                                    ledgerPostingType,
                                                                                                    purchExpforProductledgerDimension,
                                                                                                    taxUncommitted.SourceCurrencyCode,
                                                                                                    -customsExpenseAmount,
                                                                                                    exchangeRateHelper);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::AsDefault);
                    _ledgerVoucherObjectForChargeAsExpense.addTrans(ledgerVoucherTransObject);
                }
            }
            else if (taxUncommittedIn.EximTaxAmount
                || taxUncommittedIn.EximBalanceTaxAmount)
            {
                customsAmountForCalculation = (taxUncommittedIn.EximTaxAmount
                                                + taxUncommittedIn.EximBalanceTaxAmount);

                if (!isPostEximVouchers && customsAmountForCalculation)
                {
                    customsAmountForCalculation -= taxUncommittedIn.EximTaxAmount;
                }
                customsAmountForCalculation = exchangeRateHelper.calculateAccountingToTransaction(taxUncommitted.SourceCurrencyCode, customsAmountForCalculation, true);
                if (taxOnItem.CustomsChargeAsExpensePercent_IN)
                {
                    customsAmountForPEFP = roundZeroDec(customsAmountForCalculation * (100 - taxOnItem.CustomsChargeAsExpensePercent_IN)/ 100, 2);
                    customsAmount += customsAmountForPEFP;
                    customsExpenseAmount = customsAmountForCalculation - customsAmountForPEFP;
                }
                else
                {
                    customsAmount += customsAmountForCalculation;
                }
                if (customsExpenseAmount && _ledgerVoucherObjectForChargeAsExpense)
                {
                    // Expence Account posting debit entry
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObjectForChargeAsExpense,
                                                                                                    LedgerPostingType::Customs_IN,
                                                                                                    taxUncommitted.LedgerDimension,
                                                                                                    taxUncommitted.SourceCurrencyCode,
                                                                                                    customsExpenseAmount,
                                                                                                    exchangeRateHelper);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::AsDefault);
                    _ledgerVoucherObjectForChargeAsExpense.addTrans(ledgerVoucherTransObject);

                    // Purchase expenditure for Product posting credit entry
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObjectForChargeAsExpense,
                                                                                                    ledgerPostingType,
                                                                                                    purchExpforProductledgerDimension,
                                                                                                    taxUncommitted.SourceCurrencyCode,
                                                                                                    -customsExpenseAmount,
                                                                                                    exchangeRateHelper);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::AsDefault);
                    _ledgerVoucherObjectForChargeAsExpense.addTrans(ledgerVoucherTransObject);
                }
            }
        }
        if (_ledgerVoucherObjectForChargeAsExpense)
        {
            _ledgerVoucherObjectForChargeAsExpense.parmTrackTransactionAmountsByCurrency(false);
        }
        return exchangeRateHelper.calculateTransactionToAccounting(taxUncommitted.SourceCurrencyCode, customsAmount, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendorBalanceForCustoms_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns the Vendor balance in transaction currency after deducting the Customs duty for both adjustment and normal scenario.
    /// </summary>
    /// <param name="_amountCur">The invoice amount which contains base amount with tax, Misc. charges etc.</param>
    /// <param name="_common">Identifies incoming the source table.</param>
    /// <returns>returns _amountCur vendorBalance deducting customs duty.</returns>
    public static AmountCur getVendorBalanceForCustoms_IN(
        AmountCur _amountCur,
        Common _common)
    {
        TaxUncommitted_IN       taxUncommittedIN;
        TaxUncommitted          taxUncommittedLoc;
        AmountCur               amountCur;
        LedgerJournalTrans      ledgerJournalTransLoc;
        TaxAmountCur            adjustedAmount;
        TaxTable                taxTableLoc;
        TransTaxInformation     transTaxInformation;

        amountCur = _amountCur;
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return amountCur;
        }
        // This case can be extended for other Order lines supporting 'TaxUncommitted' like CustInvoiceLine & PurchLine in future when required.
        switch (_common.TableId)
        {
            case tableNum(LedgerJournalTrans) : ledgerJournalTransLoc = _common; break;
        }
        // If there is adjustment then the Tax amount adjusted against customs taxcode becomes fully Customs (in transaction currency),
        // and should be taken only from 'SourceRegulateAmountCur' field since Adjustment has top most priority compared to AutoGenerated tax.
        select sum(SourceTaxAmountCur), sum(SourceRegulateAmountCur), TaxCode from taxUncommittedLoc
            where taxUncommittedLoc.SourceTableId  == ledgerJournalTransLoc.TableId
                && taxUncommittedLoc.SourceRecId   == ledgerJournalTransLoc.RecId
                && taxUncommittedLoc.SourceRegulateAmountCur
            join  RecId from taxUncommittedIN
                where taxUncommittedIN.TaxUncommitted == taxUncommittedLoc.RecId
            join RecId from taxTableLoc// Required as the user can combine Customs with other TaxTypes in Sales\ItemSalesTax Group.
                where taxTableLoc.TaxCode == taxUncommittedLoc.TaxCode
                    &&  taxTableLoc.TaxType_IN == TaxType_IN::Customs;
        // For Non-Adjustment case the difference will always be Zero, as both fields by default will have same value 'unlike' AX2009.
        adjustedAmount = (taxUncommittedLoc.SourceRegulateAmountCur - taxUncommittedLoc.SourceTaxAmountCur);
        // Get the total Customs duty (CompanyCurrency with Customs ExchangeRate) for the current order line.
        select sum(CustomsDuty) from taxUncommittedIN
            where taxUncommittedIN.TaxUncommitted
            join  RecId from taxUncommittedLoc
                    where taxUncommittedLoc.SourceTableId  == ledgerJournalTransLoc.TableId
                        && taxUncommittedLoc.SourceRecId   == ledgerJournalTransLoc.RecId
                        && taxUncommittedIN.TaxUncommitted == taxUncommittedLoc.RecId;

        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(ledgerJournalTransLoc);

        // Customs Duty does not hit the Customer or Vendor
        amountCur = amountCur + adjustedAmount + CurrencyHelper_IN::customsCurAmount_IN(taxUncommittedIN.CustomsDuty,
                                                        ledgerJournalTransLoc.CurrencyCode,
                                                        transTaxInformation.CustomsTariffDirection,
                                                        ledgerJournalTransLoc.TransDate);
        // Vendor balance after deducting all Customs duty against the order.
        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPostedBillOfEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize from posted bill of entry.
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    /// The temporary work transaction.
    /// </param>
    /// <param name="_purchLineRecId">
    /// The purch line RecId.
    /// </param>
    /// <param name="_isFromVendInvoiceInfoline">
    /// If 'True', the transaction is from vend invoice info line.
    /// </param>
    /// <returns>
    /// The instance of the <c>TmpTaxWorkTrans</c> class.
    /// </returns>
    public static TmpTaxWorkTrans initFromPostedBillOfEntry(
        TmpTaxWorkTrans _tmpTaxWorkTrans,
        RefRecId        _purchLineRecId = 0,
        boolean         _isFromVendInvoiceInfoline = false)
    {
        AllocationFactor          factor;
        PurchQty                  invoiceQtyMinusBOEQty;
        TmpTaxWorkTrans           tmpTaxWorkTrans;
        EximVendBOESubTrans_IN    eximVendBOESubTrans;
        CustomsVendBOETrans_IN    customsVendBOETrans;
        CustomsVendBOESubTrans_IN customsVendBOESubTrans;
        VendInvoiceInfoLine       vendInvoiceInfoLineCopy;
        TaxUncommitted_IN         taxUncommittedCopy;

        #LocalMacro.BOESubTransFieldList
            RecId,
            BOETransRefRecId,
            SourceTaxAmountCur,
            TaxAmountCur,
            SourceRegulateAmountCur,
            SourceBaseAmountCurRegulated,
            SourceTaxAmountCurReal,
            CustomsDuty,
            SourceRegulateAmountCustoms_IN
        #EndMacro

        #LocalMacro.BOETransFieldList
            RemainingQty,
            BillOfEntryQty
        #EndMacro

        if (_isFromVendInvoiceInfoline)
        {
            vendInvoiceInfoLineCopy = VendInvoiceInfoLine::findRecId(_tmpTaxWorkTrans.SourceRecId);
            tmpTaxWorkTrans = taxUncommittedCopy.updateCustomsDutyPerExchangeRate_IN(_tmpTaxWorkTrans);
        }
        else
        {
            tmpTaxWorkTrans = _tmpTaxWorkTrans;
            invoiceQtyMinusBOEQty = VendInvoiceInfoLine::findByPurchLineRefRecId(_purchLineRecId).ReceiveNow;
            if (!invoiceQtyMinusBOEQty)
            {
                invoiceQtyMinusBOEQty = PurchLine::findRecId(_purchLineRecId).PurchQty;
            }
            while select #BOESubTransFieldList from customsVendBOESubTrans
                order by RecId, BillOfEntryDate
                where customsVendBOESubTrans.InventTransId == _tmpTaxWorkTrans.InventTransId
                    && customsVendBOESubTrans.TaxCode      == _tmpTaxWorkTrans.TaxCode
                join #BOETransFieldList from customsVendBOETrans
                    where customsVendBOETrans.RecId  == customsVendBOESubTrans.boeTransRefRecId
                    &&    customsVendBOETrans.Status != CustomsVendBOEStatus_IN::Canceled
            {
                if (invoiceQtyMinusBOEQty <= 0)
                {
                    break;
                }
                else if (abs(customsVendBOETrans.RemainingQty) > 0)
                {
                    if (invoiceQtyMinusBOEQty >= 0)
                    {
                        factor = (invoiceQtyMinusBOEQty >= customsVendBOETrans.RemainingQty) ?
                                    (customsVendBOETrans.RemainingQty / customsVendBOETrans.BillOfEntryQty)
                                    : (abs(invoiceQtyMinusBOEQty) / customsVendBOETrans.BillOfEntryQty);
                    }
                    tmpTaxWorkTrans.SourceTaxAmountCur              += (factor * customsVendBOESubTrans.SourceTaxAmountCur);
                    tmpTaxWorkTrans.TaxAmountCur                    += (factor * customsVendBOESubTrans.TaxAmountCur);
                    tmpTaxWorkTrans.SourceRegulateAmountCur         += (factor * customsVendBOESubTrans.SourceRegulateAmountCur);
                    tmpTaxWorkTrans.SourceBaseAmountCurRegulated    += (factor * customsVendBOESubTrans.SourceBaseAmountCurRegulated);
                    tmpTaxWorkTrans.SourceTaxAmountCurReal          += (factor * customsVendBOESubTrans.SourceTaxAmountCurReal);
                    tmpTaxWorkTrans.CustomsDuty_IN                  += (factor * customsVendBOESubTrans.CustomsDuty);
                    tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN  += (factor * customsVendBOESubTrans.SourceRegulateAmountCustoms_IN);

                    eximVendBOESubTrans = EximVendBOESubTrans_IN::findRefRecId(customsVendBOESubTrans.RecId);
                    if (eximVendBOESubTrans.IncentiveScheme != EximIncentiveScheme_IN::None)
                    {
                        tmpTaxWorkTrans.EximBalanceTaxCorrectedAmount_IN    += (factor * eximVendBOESubTrans.BalanceTaxCorrectedAmount);
                        tmpTaxWorkTrans.EximTaxCorrectedAmountCur_IN        += (factor * eximVendBOESubTrans.TaxCorrectedAmountCur);
                        tmpTaxWorkTrans.EximBalanceTaxCorrectedAmountCur_IN += (factor * eximVendBOESubTrans.BalanceTaxCorrectedAmountCur);
                        tmpTaxWorkTrans.EximIncentiveScheme_IN              = eximVendBOESubTrans.IncentiveScheme;
                        tmpTaxWorkTrans.EximTaxAmountCur_IN                 += (factor * eximVendBOESubTrans.TaxAmountCur);
                        tmpTaxWorkTrans.EximTaxAmount_IN                    += (factor * eximVendBOESubTrans.TaxAmount);
                        tmpTaxWorkTrans.EximTaxCorrectedAmount_IN           += (factor * eximVendBOESubTrans.TaxCorrectedAmount);
                        tmpTaxWorkTrans.EximBalanceTaxAmountCur_IN          += (factor * eximVendBOESubTrans.BalanceTaxAmountCur);
                        tmpTaxWorkTrans.EximBalanceTaxAmount_IN             += (factor * eximVendBOESubTrans.BalanceTaxAmount);
                        tmpTaxWorkTrans.EximDEPBAmountCur_IN                += (factor * eximVendBOESubTrans.depbAmountCur);
                        tmpTaxWorkTrans.EximDEPBAmount_IN                   += (factor * eximVendBOESubTrans.depbAmount);
                    }

                    invoiceQtyMinusBOEQty = (invoiceQtyMinusBOEQty - customsVendBOETrans.RemainingQty);
                }
            }
        }
        return tmpTaxWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>proratedBOECustomsDuty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cumulative prorated Customs duty of all BOEs for the current purchLine for the current TaxCode, for Accounting and reporting currency.
    /// </summary>
    /// <param name="_taxCons">
    /// Container that holds the TaxUncommitted buffers and the factored quantities. This container should be created using MAP only.
    /// </param>
    /// <param name="_updateRecord">
    /// Boolean that instructs whether to update the BOE Trans table for consumed BOE quantity.
    /// </param>
    /// <param name="_amount">
    /// The transaction currency amount, default value is 0.
    /// </param>
    /// <param name="_reportingCurrency">
    /// The reporting currency attached to the company/Ledger.
    /// </param>
    /// <returns>
    /// Updates the partial billof entry table for the remaining quantity after consumption by purchase order invoicing.
    /// Cumulative Customs duty (after prorating if required)considering multiple partial BOEs, each with possibly different
    /// customs exchange rate; for the current TaxCode being posted; for both Accounting currency and reporting currency.
    /// </returns>
    public static TaxAmount proratedBOECustomsDuty(
        container    _taxCons,
        boolean      _updateRecord = false,
        Amount       _amount = 0,
        CurrencyCode _reportingCurrency = Ledger::accountingCurrency())
    {
        PurchQty                    invoiceQtyMinusBOEQty;
        PurchQty                    invoiceQty;
        AllocationFactor            factor;
        TaxAmount                   customsDutyProrated;
        TaxAmount                   customsDutyProratedReporting;
        TaxAmount                   taxAmountEPCG;
        CustomsVendBOETrans_IN      customsVendBOETrans;
        CustomsVendBOESubTrans_IN   customsVendBOESubTrans;
        TaxUncommitted              taxUncommittedLoc;
        Map                         customsMap = Map::create(_taxCons);
        MapIterator                 iterator = new MapIterator(customsMap);
        TaxUncommitted_IN           taxUncommittedIN;
        EximVendBOESubTrans_IN      eximVendBOESubTrans;
        EximAuthorizationType_IN    authorizationType;
        boolean                     isPostEximVouchers;
        #LOCALMACRO.fieldList
            RecId,
            InventTransId,
            RemainingQty,
            BillOfEntryQty
        #ENDMACRO

        ttsbegin;

        while (iterator.more())
        {
            taxUncommittedLoc     = iterator.key();
            invoiceQty = iterator.value();
            invoiceQtyMinusBOEQty = invoiceQty;
            taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(taxUncommittedLoc.RecId);
            if (taxUncommittedIN.EximIncentiveScheme != EximIncentiveScheme_IN::None)
            {
                isPostEximVouchers = EximParameters_IN::checkParameterForPosting(str2enum(authorizationType, enum2str(taxUncommittedIN.EximIncentiveScheme)));
            }
            // Loop customsVendBOETrans header for each partial BOE done. customsVendBOESubTrans is the postedBOE tax table with
            // number of records equal to the number of Taxcodes that can create customs duty. customsVendBOETrans is the header to
            // customsVendBOESubTrans and will create one record for each BOE, its record count says how many partial BOEs are done.
            while select RecId, boeTransRefRecId, CustomsDuty, SourceRegulateAmountCustoms_IN, SourceTaxAmountCur, SourceRegulateAmountCustomsCur_IN
                from customsVendBOESubTrans
                order by RecId, BillOfEntryDate// [InventTransId + TaxCode + BOETransRefRecId = Unique for the subtrans table]
                where customsVendBOESubTrans.InventTransId == taxUncommittedLoc.InventTransId
                    && customsVendBOESubTrans.TaxCode      == taxUncommittedLoc.TaxCode
                join forupdate #fieldList from customsVendBOETrans
                    where customsVendBOETrans.RecId  == customsVendBOESubTrans.boeTransRefRecId
                    &&    customsVendBOETrans.Status != CustomsVendBOEStatus_IN::Canceled
            {
                // Before any Invoice is done [Remaining Qty equals BillOfEntryQty]. With each invoice the corresponding BOE's
                // RemainingQty is reduced by the amount BOE done.

                if ((invoiceQty < 0 && invoiceQtyMinusBOEQty >= 0) || (invoiceQty > 0 && invoiceQtyMinusBOEQty <= 0))
                {
                    // Variable is Negative only when a situation is reached where the processed BOE line can supply more +ve quantity
                    // than required to fulfill the actual invoice quantity OR it can supply more -ve quantity than required(credit note).
                    // Since the just previous BOE line made the variable negative or +ve (as case of normal PO or credit note)
                    // the same has fullfilled the invoice quantity. So we can safely stop the processing of further BOEs.

                    // I already changed my original SIGN!!!, I won't process further partial bill of entries.
                    break;
                }
                // Skip consumed partial BOEs.
                else if (abs(customsVendBOETrans.RemainingQty) > 0)
                {
                    // Current partial BOE is underutilized for invoicing. Eg, we have 4 BOEs with Qty 10, 20, 30, 40.
                    // Total Qty available for invoice = 100. Do a partial Invoice of 35 Qty. Then BOE1 & BOE2 will be fully utilized.
                    // But only 5 Qty should be consumed from BOE3. We have to prorate the CustomsDuty for 5 Qty from total customs duty
                    // (ie,30 Qty). Also BOE4 should be skipped.

                    // factor will be >0 & <= 1 always.
                    if ((invoiceQty > 0 && invoiceQtyMinusBOEQty >= 0) || (invoiceQty < 0 && invoiceQtyMinusBOEQty <= 0))
                    {
                        factor = (invoiceQtyMinusBOEQty >= customsVendBOETrans.RemainingQty) ?
                                    (customsVendBOETrans.RemainingQty / customsVendBOETrans.BillOfEntryQty)
                                    : (abs(invoiceQtyMinusBOEQty) / customsVendBOETrans.BillOfEntryQty);
                    }
                    eximVendBOESubTrans = EximVendBOESubTrans_IN::findRefRecId(customsVendBOESubTrans.RecId);
                    if (_reportingCurrency
                       && (_reportingCurrency != Ledger::accountingCurrency()))
                    {
                        if (taxUncommittedIN.EximIncentiveScheme == EximIncentiveScheme_IN::EPCG)
                        {
                            // EPCG taxes will have TaxAmountCur + BalanceTaxAmountCur. Which will not be equal to SourceTaxAmountCur(CustomsDuty).
                            taxAmountEPCG = (eximVendBOESubTrans.TaxCorrectedAmountCur + eximVendBOESubTrans.BalanceTaxCorrectedAmountCur)
                                                                ? (eximVendBOESubTrans.TaxCorrectedAmountCur + eximVendBOESubTrans.BalanceTaxCorrectedAmountCur)
                                                                : (eximVendBOESubTrans.TaxAmountCur + eximVendBOESubTrans.BalanceTaxAmountCur);
                        }

                        customsDutyProratedReporting   = CurrencyHelper_IN::customsReportingMSTAmount_IN(taxAmountEPCG ? (factor * taxAmountEPCG)
                                                                                                            :
                                                                                                            (customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN
                                                                                                                ? (factor * customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN)
                                                                                                                : (factor * customsVendBOESubTrans.SourceTaxAmountCur)),
                                                                                                            _reportingCurrency,
                                                                                                            Direction_IN::Import,
                                                                                                            customsVendBOESubTrans.TransDate, // BOE date
                                                                                                            true,
                                                                                                            customsVendBOESubTrans.ExchangeRate);
                        customsDutyProrated += customsDutyProratedReporting;
                    }
                    else
                    {
                        if (taxUncommittedIN.EximIncentiveScheme == EximIncentiveScheme_IN::EPCG)
                        {
                            taxAmountEPCG = (eximVendBOESubTrans.TaxCorrectedAmount + eximVendBOESubTrans.BalanceTaxCorrectedAmount)
                                                                ? (eximVendBOESubTrans.TaxCorrectedAmount + eximVendBOESubTrans.BalanceTaxCorrectedAmount)
                                                                : (eximVendBOESubTrans.TaxAmount + eximVendBOESubTrans.BalanceTaxAmount);
                        }

                        customsDutyProrated  += taxAmountEPCG
                            ?
                                (factor * taxAmountEPCG)
                            :
                                (customsVendBOESubTrans.SourceRegulateAmountCustoms_IN
                        ?
                            (factor * customsVendBOESubTrans.SourceRegulateAmountCustoms_IN)
                        : (factor * customsVendBOESubTrans.CustomsDuty));
                    }
                    // when Post Financial voucher is unmarked,
                    // The Exim TaxAmount should be deducted from the Customs duty else the accounting currency will reflect the complete cusoms duty and not the exim deducted tax amount.
                    //in this solution it is calculated as per the prorate basis as this will be applicable for the partial invoices as well.
                    eximVendBOESubTrans = EximVendBOESubTrans_IN::findRefRecId(customsVendBOESubTrans.RecId);
                    if (eximVendBOESubTrans.RecId && !isPostEximVouchers)
                    {
                        customsDutyProrated = (factor == 1 )
                            ? (customsDutyProrated - (factor * (customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN != customsVendBOESubTrans.SourceTaxAmountCur) ? eximVendBOESubTrans.TaxCorrectedAmount : eximVendBOESubTrans.TaxAmount))
                              : (customsDutyProrated - ((1 - factor) * (customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN != customsVendBOESubTrans.SourceTaxAmountCur) ? eximVendBOESubTrans.TaxCorrectedAmount : eximVendBOESubTrans.TaxAmount));
                    }
                    if (customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN != customsVendBOESubTrans.SourceTaxAmountCur)
                    {
                        // If adjustment is there then the tax entry is visited again with TransactionCurrencyAmount = OrigValue - Adjusted amount.
                        // If factor is not halved here, the accounting & reporting currency will show double values.
                        customsDutyProrated = abs(customsDutyProrated / 2) * (_amount ? _amount/ abs(_amount) : 1);
                    }
                    invoiceQtyMinusBOEQty = (invoiceQtyMinusBOEQty - customsVendBOETrans.RemainingQty);
                    // Update Remain Qty only during actual invoice, not during SLJL preview.
                    customsVendBOETrans.RemainingQty = (invoiceQtyMinusBOEQty >= 0) ? 0 : abs(invoiceQtyMinusBOEQty);
                    if (_updateRecord)// For SLJL preview do not commit the changes.
                    {
                        customsVendBOETrans.update();
                    }
                }
            }
            iterator.next();
        }
        ttscommit;

        return CurrencyExchangeHelper::amount(customsDutyProrated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTaxValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows the tax value information.
    /// </summary>
    /// <param name="_salesPurchJournalLine">
    /// The sales purch journal line.
    /// </param>
    /// <param name="_taxModuleType">
    /// The tax module type.
    /// </param>
    /// <param name="_inventTransId">
    /// The invent trans id.
    /// </param>
    /// <param name="_taxCode">
    /// The tax code.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The tax item group.
    /// </param>
    /// <param name="_calculationDate">
    /// The calculation date.
    /// </param>
    /// <param name="_taxBaseAmount">
    /// The tax base amount.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxValue</c> class.
    /// </returns>
    public static TaxValue showTaxValue(SalesPurchJournalLine  _salesPurchJournalLine,
            TaxModuleType   _taxModuleType,
            InventTransId   _inventTransId,
            TaxCode         _taxCode,
            TaxItemGroup    _taxItemGroup,
            date            _calculationDate,
            TaxBase         _taxBaseAmount)
    {
        TaxValue                    taxValue;
        TaxTrans                    taxTrans;
        CustInvoiceJour             custInvoiceJour;
        VendInvoiceJour             vendInvoiceJour;
        TaxData                     taxData;
        SalesPurchJournalLine       salesPurchJournalLine;
        SalesLine                   salesLineLoc;
        SalesLine_IN                salesLineLoc_IN;
        PurchLine                   purchLineLoc;
        PurchLine_IN                purchLineLoc_IN;
        SalesLine                   salesLineICompany;
        SalesLine                   salesLineOriginal;
        InventRefTransId            inventRefId;
        PurchLine                   purchLineOriginal;
        PurchLine_IN                purchLineOriginal_IN;
        SalesTable                  salesTableLoc;

        switch (_taxModuleType)
        {
            case TaxModuleType::Sales :
                salesPurchJournalLine   = SalesLine::findInventTransId(_inventTransId) as Common;
                salesLineLoc            = SalesLine::findRecId(_salesPurchJournalLine.SourceRecId);
                salesLineLoc_IN         = salesLineLoc.salesLine_IN();
                if (salesPurchJournalLine)
                {
                    if (salesLineLoc_IN.TaxAsPerOriginalInvoice)
                    {
                        select custInvoiceJour
                            where custInvoiceJour.SalesId       == salesLineLoc.InventRefId
                               && custInvoiceJour.LedgerVoucher == salesLineLoc_IN.TaxWithholdVoucher;
                        if (custInvoiceJour)
                        {
                            select taxTrans
                                where taxTrans.Voucher      == custInvoiceJour.InvoiceId    &&
                                      taxTrans.TransDate    == custInvoiceJour.InvoiceDate  &&
                                      taxTrans.TaxCode      == _taxCode                 &&
                                      taxTrans.TaxItemGroup == _taxItemGroup;
                            if (taxTrans)
                            {
                                taxValue = taxTrans.TaxValue;
                            }
                        }

                        salesTableLoc = SalesTable::find(salesLineLoc.SalesId);
                        if (salesLineLoc.SalesType == SalesType::ReturnItem
                            && (salesTableLoc.InterCompanyDirectDelivery
                            || salesTableLoc.InterCompanyDirectDeliveryOrig)
                            || (!custInvoiceJour
                            || !salesLineLoc.InventRefId))
                        {
                            if (salesLineLoc.InterCompanyInventTransId)
                            {
                                changecompany(salesTableLoc.InterCompanyCompanyId)
                                {
                                    select firstonly InventTransIdReturn
                                        from salesLineICompany
                                        where salesLineICompany.InventRefTransId == salesLineLoc.InterCompanyInventTransId;
                                    if (salesLineICompany)
                                    {
                                        inventRefId = SalesLine::findInventTransId(salesLineICompany.InventTransIdReturn).InventRefTransId;
                                    }
                                }
                                select firstonly InventTransId
                                    from salesLineOriginal
                                    where salesLineOriginal.InterCompanyInventTransId == inventRefId;
                                if (salesLineOriginal)
                                {
                                    select firstonly InvoiceId, InvoiceDate
                                        from custInvoiceJour
                                        where custInvoiceJour.SalesId       == SalesLine::findInventTransId(salesLineOriginal.InventTransId).SalesId
                                           && custInvoiceJour.LedgerVoucher == salesLineLoc_IN.TaxWithholdVoucher;
                                }
                            }
                            else
                            {
                                select firstonly InvoiceId, InvoiceDate
                                    from custInvoiceJour
                                    where custInvoiceJour.SalesId       == SalesLine::findInventTransId(salesLineLoc.InventTransIdReturn).SalesId
                                       && custInvoiceJour.LedgerVoucher == salesLineLoc_IN.TaxWithholdVoucher;
                            }
                            if (custInvoiceJour)
                            {
                                select firstonly TaxValue
                                    from taxTrans
                                    where taxTrans.Voucher      == custInvoiceJour.InvoiceId
                                       && taxTrans.TransDate    == custInvoiceJour.InvoiceDate
                                       && taxTrans.TaxCode      == _taxCode
                                       && taxTrans.TaxItemGroup == _taxItemGroup;
                                if (taxTrans)
                                {
                                    taxValue = taxTrans.TaxValue;
                                }
                            }
                        }
                    }
                    else
                    {
                        taxValue  = taxData.percentForTax_IN(_taxCode,
                                                             _calculationDate,
                                                             _taxBaseAmount,
                                                             _salesPurchJournalLine);
                    }
                }
                else
                {
                    taxValue  = taxData.percentForTax_IN(_taxCode,
                                                         _calculationDate,
                                                         _taxBaseAmount,
                                                         _salesPurchJournalLine);
                }
                break;

            case TaxModuleType::Purch :
                purchLineLoc = PurchLine::findRecId(_salesPurchJournalLine.SourceRecId);
                purchLineLoc_IN = purchLineLoc.purchLine_IN();
                if (purchLineLoc_IN.TaxAsPerOriginalInvoice)
                {
                    select vendInvoiceJour
                        where vendInvoiceJour.PurchId       == purchLineLoc.InventRefId
                           && vendInvoiceJour.LedgerVoucher == purchLineLoc_IN.TaxWithholdVoucher;
                    if (vendInvoiceJour)
                    {
                        select taxTrans
                            where taxTrans.Voucher      == vendInvoiceJour.LedgerVoucher
                               && taxTrans.TransDate    == vendInvoiceJour.InvoiceDate
                               && taxTrans.TaxCode      == _taxCode
                               && taxTrans.TaxItemGroup == _taxItemGroup;
                        if (taxTrans)
                        {
                            taxValue = taxTrans.TaxValue;
                        }
                    }

                    if (purchLineLoc.PurchaseType == PurchaseType::ReturnItem
                        && PurchTable::find(purchLineLoc.PurchId).InterCompanyDirectDelivery
                        && !vendInvoiceJour)
                    {
                        select firstonly LedgerVoucher, InvoiceDate
                            from vendInvoiceJour
                            where vendInvoiceJour.PurchId       == PurchLine::findInventTransId(SalesLine::findInventTransId(SalesLine::findInventTransId(purchLineLoc.InventRefTransId).InventTransIdReturn).InventRefTransId).PurchId
                               && vendInvoiceJour.LedgerVoucher == purchLineLoc_IN.TaxWithholdVoucher;
                        if (vendInvoiceJour)
                        {
                            select firstonly TaxValue
                                from taxTrans
                                where taxTrans.Voucher      == vendInvoiceJour.LedgerVoucher
                                   && taxTrans.TransDate    == vendInvoiceJour.InvoiceDate
                                   && taxTrans.TaxCode      == _taxCode
                                   && taxTrans.TaxItemGroup == _taxItemGroup;
                            if (taxTrans)
                            {
                                taxValue = taxTrans.TaxValue;
                            }
                        }
                        else
                        {
                            select firstonly InventRefTransId
                                from purchLineOriginal
                                where purchLineOriginal.InventRefId == purchLineLoc.InventRefId
                                   && purchLineOriginal.QtyOrdered  == -purchLineLoc.QtyOrdered
                                   && purchLineOriginal.ItemId      == purchLineLoc.ItemId
                                   && ReturnDispositionCode::find(purchLineLoc.ReturnDispositionCodeId).DispositionAction == DispositionAction::ReturnToCust
                                outer join TaxWithholdVoucher
                                    from purchLineOriginal_IN
                                    where purchLineOriginal_IN.PurchLine == purchLineOriginal.recid;
                            if (purchLineOriginal)
                            {
                                select firstonly LedgerVoucher, InvoiceDate
                                from vendInvoiceJour
                                where vendInvoiceJour.PurchId       == PurchLine::findInventTransId(SalesLine::findInventTransId(SalesLine::findInventTransId(purchLineOriginal.InventRefTransId).InventTransIdReturn).InventRefTransId).PurchId
                                   && vendInvoiceJour.LedgerVoucher == purchLineOriginal_IN.TaxWithholdVoucher;
                                if (vendInvoiceJour)
                                {
                                    select firstonly TaxValue
                                        from taxTrans
                                        where taxTrans.Voucher      == vendInvoiceJour.LedgerVoucher
                                           && taxTrans.TransDate    == vendInvoiceJour.InvoiceDate
                                           && taxTrans.TaxCode      == _taxCode
                                           && taxTrans.TaxItemGroup == _taxItemGroup;
                                    if (taxTrans)
                                    {
                                        taxValue = taxTrans.TaxValue;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    taxValue  = taxData.percentForTax_IN(_taxCode,
                                                         _calculationDate,
                                                         _taxBaseAmount,
                                                         _salesPurchJournalLine);
                }
                break;

            default :
                taxValue  = taxData.percentForTax_IN(_taxCode,
                                                     _calculationDate,
                                                     _taxBaseAmount,
                                                     _salesPurchJournalLine);
                break;
        }

        return taxValue;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<CountryRegionCodes>IN</CountryRegionCodes>
	<DeveloperDocumentation>@SYS134155</DeveloperDocumentation>
	<Label>@SYS134153</Label>
	<TableGroup>WorksheetLine</TableGroup>
	<TitleField1>TaxAccountType</TitleField1>
	<TitleField2>FormulaID</TitleField2>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>TaxUncommittedIdx</ClusteredIndex>
	<Modules>Tax</Modules>
	<ReplacementKey>TaxUncommittedIdx</ReplacementKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxUncommitted</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxAccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FormulaID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EximIncentiveScheme</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxUncommitted</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AbatementAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ClaimPercentage</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Percent</ExtendedDataType>
			<Label>@GLS5257</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CustomsDuty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustomsAmount_IN</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>EximAuthorizationId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>EximAuthorizationId_IN</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EximBalanceTaxAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EximBalanceTaxAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EximBalanceTaxCorrectedAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EximBalanceTaxCorrectedAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EximDEPBAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EximDEPBAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>EximIncentiveScheme</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>EximIncentiveScheme_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EximTaxAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EximTaxAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EximTaxCorrectedAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EximTaxCorrectedAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>FormulaID</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ID_IN</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsScrapQtyLine_IN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LoadOnInventoryTax</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountCur</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MainVoucher</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>Voucher</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ServiceTaxReverseChargePercentage</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ServiceTaxRevPercentage_IN</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ServTaxRevChargeOriginAmountCur_IN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxRegulationAmountCur</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>SourceRegulateAmountCustoms</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxAccountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>TaxAccountType_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxRegistrationNumberTable_IN</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS59571</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxUncommitted</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
			<Visible>No</Visible>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TaxUncommittedIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>TaxUncommitted</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>MainVoucherIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>MainVoucher</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxRegistrationNumberTable_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxRegistrationNumbers_IN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxRegistrationNumberTable_IN</Name>
					<Field>TaxRegistrationNumberTable_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxUncommitted</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>TaxUncommitted</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>TaxUncommitted</RelatedTableRole>
			<RelationshipType>Composition</RelationshipType>
			<Role>TaxUncommitted_IN</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxUncommitted</Name>
					<Field>TaxUncommitted</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>