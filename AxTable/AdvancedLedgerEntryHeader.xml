<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AdvancedLedgerEntryHeader</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class AdvancedLedgerEntryHeader extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canSubmitToWorkflow</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the advanced ledger entry line in order to activate the workflow on <c>AdvancedLedgerEntry</c> form.
    /// </summary>
    /// <param name="_workflowType">
    ///     Workflow type.
    /// </param>
    /// <returns>
    ///     true if atleast one advanced ledger entry line exists and  the <c>WorkflowApprovalState</c>
    ///     field on <c>AdvancedLedgerEntryHeader</c> table is equal to the <c>AdvancedLedgerEntryWFApprovalState::NotSubmitted</c>
    ///     enumeration value; otherwise, false.
    /// </returns>
    public boolean canSubmitToWorkflow(str _workflowType = '')
    {
        AdvancedLedgerEntryLine advancedLedgerEntryLine;
        boolean                 canSubmit = false;

        if (this.TransactionStatus != AdvancedLedgerEntryTransactionStatus::Posted
            && this.WorkflowApprovalState == AdvancedLedgerEntryWFApprovalState::NotSubmitted)
        {
            select firstonly RecId from advancedLedgerEntryLine
                where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == this.RecId;

            if (advancedLedgerEntryLine.RecId != 0)
            {
                canSubmit = true;
            }
        }

        return canSubmit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBudget</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks budget for all the advanced ledger entry lines.
    /// </summary>
    /// <param name="_checkAdvancedLedgerEntryBudgetControlStatus">
    ///     A boolean to indicate whether or not the budgetary control setting for performing budget check on advanced ledger entry line save should be considered
    ///     in determining whether budgetary control is required for advanced ledger entry.
    /// </param>
    /// <param name="_displayResultErrorWarnings">
    ///     A boolean value to indicate whether any errors or warnings from budget check result should be displayed in <c>Infolog</c>; optional, default is true.
    /// </param>
    public void checkBudget(
        boolean _checkAdvancedLedgerEntryBudgetControlStatus = true,
        boolean _displayResultErrorWarnings = true)
    {
        AdvancedLedgerEntryManager advancedLedgerEntryManager = AdvancedLedgerEntryManager::newForAdvancedLedgerEntryDocument(this);

        advancedLedgerEntryManager.checkBudgetDocument(_checkAdvancedLedgerEntryBudgetControlStatus, _displayResultErrorWarnings);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Defaults a value for a field.
    /// </summary>
    /// <param name="_fieldId">
    ///     The field ID that corresponds with the field that is being defaulted.
    /// </param>
    /// <param name="_axAdvancedLedgerEntryHeader">
    ///     An instance of the <c>AxAdvancedLedgerEntryHeader</c> class that is associated with the field that is
    ///     being defaulted; optional.
    /// </param>
    public void defaultField(
        FieldId _fieldId,
        AxAdvancedLedgerEntryHeader _axAdvancedLedgerEntryHeader = null)
    {
        AdvancedLedgerEntryHeaderUtil advancedLedgerEntryHeaderUtil;
        AxAdvancedLedgerEntryHeader axAdvancedLedgerEntryHeader;

        axAdvancedLedgerEntryHeader = _axAdvancedLedgerEntryHeader;
        if (axAdvancedLedgerEntryHeader == null)
        {
            axAdvancedLedgerEntryHeader = new AxAdvancedLedgerEntryHeader();
            axAdvancedLedgerEntryHeader.advancedLedgerEntryHeader(this);
        }

        advancedLedgerEntryHeaderUtil = AdvancedLedgerEntryHeaderUtil::construct(axAdvancedLedgerEntryHeader);
        advancedLedgerEntryHeaderUtil.defaultField(_fieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultRow</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Defaults the field values for a <c>AdvancedLedgerEntryHeader</c> record.
    /// </summary>
    /// <param name="_axAdvancedLedgerEntryHeader">
    ///    The <c>AxAdvancedLedgerEntryHeader</c> class instance that is associated with the row being
    ///    defaulted; optional.
    /// </param>
    public void defaultRow(AxAdvancedLedgerEntryHeader _axAdvancedLedgerEntryHeader = null)
    {
        AdvancedLedgerEntryHeaderUtil advancedLedgerEntryHeaderUtil;
        AxAdvancedLedgerEntryHeader axAdvancedLedgerEntryHeader;

        axAdvancedLedgerEntryHeader = _axAdvancedLedgerEntryHeader;

        if (axAdvancedLedgerEntryHeader == null)
        {
            axAdvancedLedgerEntryHeader = new AxAdvancedLedgerEntryHeader();
            axAdvancedLedgerEntryHeader.advancedLedgerEntryHeader(this);
        }

        advancedLedgerEntryHeaderUtil = AdvancedLedgerEntryHeaderUtil::construct(axAdvancedLedgerEntryHeader);
        advancedLedgerEntryHeaderUtil.defaultRow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Prevents deletion of a header if the document has been submitted to workflow.
    /// </summary>
    public void delete()
    {
        if (this.WorkFlowStatus == AdvancedLedgerEntryWFApprovalStatus::Submitted)
            throw error(strFmt("@SPS1602", this.TransactionNumber));

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayAttachmentExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the existence of an attachment.
    /// </summary>
    /// <returns>
    ///     Attachments image number.
    /// </returns>
    public display ImageRes displayAttachmentExists()
    {
        boolean isAttached;
        int     image;
        #define.ImageNum(2505)

        if (hasTableAccess(tableNum(DocuRef)))
        {
            isAttached = DocuRef::exist(curext(), this.TableId, this.RecId);

            if (isAttached)
            {
                image = #ImageNum;
            }
        }

        return image;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayBudgetCheckResult</Name>
				<Source><![CDATA[
    /// <summary>
/// Gets the budget check result value for the record.
/// </summary>
/// <returns>
/// The budget check result value for the record.
/// </returns>
public display BudgetCheckResult displayBudgetCheckResult()
{
	return this.getBudgetCheckResult();
}

]]></Source>
			</Method>
			<Method>
				<Name>displayCompanyCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the company currency.
    /// </summary>
    /// <returns>
    ///     Accounting currency of the current company.
    /// </returns>
    public display CurrencyCode displayCompanyCurrency()
    {
        CurrencyCode accountingCurrency;

        if (hasTableAccess(tableNum(Ledger)))
        {
            accountingCurrency = Ledger::accountingCurrency();
        }

        return accountingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the total credit of advanced ledger entry lines.
    /// </summary>
    /// <returns>
    ///     The credit sum of advanced ledger entry lines.
    /// </returns>
    public display AmountMST displayTotalCredit()
    {
        AmountMST               amountMST;
        AdvancedLedgerEntryLine advancedLedgerEntryLine;

        if (hasTableAccess(tableNum(AdvancedLedgerEntryLine)) && hasTableAccess(tableNum(CompanyInfo)))
        {
            while select sum(AmountCurCredit), TransactionCurrency from advancedLedgerEntryLine
                group by TransactionCurrency
                where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == this.RecId
            {
                amountMST += AdvancedLedgerEntryManager::calculateTransAmountToAccountingAmount(advancedLedgerEntryLine.AmountCurCredit,
                                advancedLedgerEntryLine.TransactionCurrency,
                                this.AccountingDate);
            }
        }

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalDebit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the total debit of advanced ledger entry lines.
    /// </summary>
    /// <returns>
    ///     The debit sum of advanced ledger entry lines.
    /// </returns>
    public display AmountMST displayTotalDebit()
    {
        AmountMST               amountMST;
        AdvancedLedgerEntryLine advancedLedgerEntryLine;

        if (hasTableAccess(tableNum(AdvancedLedgerEntryLine)) && hasTableAccess(tableNum(CompanyInfo)))
        {
            while select sum(AmountCurDebit), TransactionCurrency from advancedLedgerEntryLine
                group by TransactionCurrency
                where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == this.RecId
            {
                amountMST += AdvancedLedgerEntryManager::calculateTransAmountToAccountingAmount(advancedLedgerEntryLine.AmountCurDebit,
                                advancedLedgerEntryLine.TransactionCurrency,
                                this.AccountingDate);
            }
        }

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTransDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Concatenates the transaction number and transaction text.
    /// </summary>
    /// <returns>
    ///     A conactenated string of transaction number and transaction text.
    /// </returns>
    public display AdvancedLedgerEntryTransText displayTransDetails()
    {
        str concatenatedTxt;

        if (hasTableAccess(tableNum(AdvancedLedgerEntryHeader)))
        {
            concatenatedTxt = strFmt("@SPS1277", this.TransactionNumber, this.TransactionText);
        }

        return concatenatedTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editReasonCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets a reason code.
    /// </summary>
    /// <param name="_set">
    ///     A boolean value that specifies whether the reason code is set.
    /// </param>
    /// <param name="_reasonCode">
    ///     The new reason code when the <paramref name="_set" /> parameter is true.
    /// </param>
    /// <returns>
    ///     The reason code of the record in the <c>ReasonTableRef</c> table.
    /// </returns>
    public edit ReasonCode editReasonCode(
        boolean    _set,
        ReasonCode _reasonCode)
    {
        boolean        isValid = true;
        ReasonCode     reasonCode;
        ReasonCode     originalReasonCode;
        int64          originalReasonTableRef;
        FormDataSource formAdvancedLedgerEntryHeader;

        if (_set && hasTableAccess(tableNum(ReasonTableRef), AccessType::Edit))
        {
            reasonCode = strLRTrim(_reasonCode);

            if (reasonCode != '')
            {
                // The reason code value is not blank.
                // Get the original reason code before attempting to update it.
                originalReasonCode = ReasonTableRef::find(this.ReasonTableRef).Reason;

                // Save the current ReasonRefRecID for comparison.
                originalReasonTableRef = this.ReasonTableRef;

                // If the ReasonTableRef is 0, then create a new ReasonTableRef record
                // otherwise, update the existing record.
                if (originalReasonTableRef == 0)
                {
                    this.ReasonTableRef = ReasonTableRef::createFromCode(reasonCode);
                }
                else
                {
                    this.ReasonTableRef = ReasonTableRef::updateCode(reasonCode, this.ReasonTableRef);
                }

                if (ReasonTableRef::find(this.ReasonTableRef).validateField(fieldNum(ReasonTableRef, Reason)) &&
                    this.validateField(fieldNum(AdvancedLedgerEntryHeader, ReasonTableRef)))
                {
                    if (this.ReasonTableRef == originalReasonTableRef &&
                        FormDataUtil::getFormDataSource(this))
                    {
                        // The reason code has changed but the referenced record ID has not.
                        // Get the current FormDataSource and set forceWrite() to true so that
                        // data validation (validateWrite()) is performed on the updated reason code.
                        formAdvancedLedgerEntryHeader = FormDataUtil::getFormDataSource(this);
                        formAdvancedLedgerEntryHeader.forceWrite(true);
                    }
                }
                else
                {
                    // Validation failed; set the reason code and reference back to the original values
                    if (originalReasonTableRef == 0)
                    {
                        this.ReasonTableRef = 0;
                    }
                    else
                    {
                        this.ReasonTableRef = ReasonTableRef::updateCode(originalReasonCode, originalReasonTableRef);
                    }

                    isValid = false;
                }
            }
            else
            {
                // The reason code is blank.
                this.ReasonTableRef = ReasonTableRef::updateCode(reasonCode, this.ReasonTableRef);
            }

            if (isValid && hasTableAccess(tableNum(ReasonTable)))
            {
                // Update the reason comment with the default comment value for the updated reason code.
                // A blank reasonCode will result in a blank comment because a blank reasonCode
                // will return an empty reasonTable buffer.
                this.editReasonComment(true, ReasonTable::find(reasonCode).Description);
            }
        }

        if (hasTableAccess(tableNum(ReasonTableRef)))
        {
            reasonCode = ReasonTableRef::find(this.ReasonTableRef).Reason;
        }

        return reasonCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editReasonComment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets a reason comment.
    /// </summary>
    /// <param name="_set">
    ///     A boolean value that specifies whether the reason comment is set.
    /// </param>
    /// <param name="_reasonComment">
    ///     The new reason comment when the <paramref name="set" /> parameter is true.
    /// </param>
    /// <returns>
    ///     The reason comment of the record in the <c>ReasonTableRef</c> table.
    /// </returns>
    public edit ReasonComment editReasonComment(
        boolean       _set,
        ReasonComment _reasonComment)
    {
        ReasonComment reasonComment;

        if (_set && hasTableAccess(tableNum(ReasonTableRef), AccessType::Edit))
        {
            reasonComment = _reasonComment;

            // If the ReasonTableRef is 0, then create a new ReasonTableRef record
            // otherwise, update the existing record.
            if (this.ReasonTableRef == 0)
            {
                this.ReasonTableRef = ReasonTableRef::createFromComment(reasonComment);
            }
            else
            {
                this.ReasonTableRef = ReasonTableRef::updateComment(reasonComment, this.ReasonTableRef);
            }
        }

        if (hasTableAccess(tableNum(ReasonTableRef)))
        {
            reasonComment = ReasonTableRef::find(this.ReasonTableRef).ReasonComment;
        }

        return reasonComment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetCheckResult</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the <c>BudgetCheckResult</c> value for the given <c>AdvancedLedgerEntryHeader</c> record.
    /// </summary>
    /// <returns>
    ///     A <c>BudgetCheckResult</c> value which is calculated using the query.
    /// </returns>
    public BudgetCheckResult getBudgetCheckResult()
    {
        return AdvancedLedgerEntryBudgetControl::getBudgetSourceBudgetCheckResult(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Submits the advanced ledger entry source document header implementation for processing in an accounting process.
    /// </summary>
    /// <remarks>
    ///     This method has been overridden to create source document header record corresponding to the advanced ledger entry source document.
    /// </remarks>
    public void insert()
    {
        SourceDocumentProcessorFacade::submitSourceDocumentImplementation(this);

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAccountingDistributionEditable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if accounting distribution is editable or not
    /// </summary>
    /// <returns>
    /// true if accounting distribution is editable; otherwise, false.
    /// </returns>
    public boolean isAccountingDistributionEditable()
    {
        boolean isEditable = false;

        if (this.WorkFlowStatus == AdvancedLedgerEntryWFApprovalStatus::Draft ||
                this.WorkFlowStatus == AdvancedLedgerEntryWFApprovalStatus::Rejected ||
                    this.WorkFlowStatus == 0)
        {
            isEditable = true;
        }

        else if (this.WorkFlowStatus == AdvancedLedgerEntryWFApprovalStatus::PendingCompletion ||
                    this.WorkFlowStatus == AdvancedLedgerEntryWFApprovalStatus::PendingApproval)
        {
            isEditable = WorkflowWorkItem::isUserTaskOwner(this);

            if (!isEditable)
            {
                isEditable = WorkflowWorkItem::isUserApprovalOwner(this);
            }
        }

        return isEditable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUserApprovalOwner</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets pending approval work item status for a user.
    /// </summary>
    /// <returns>
    ///     A Boolean value that indicates if the user has a pending work item of type <c>approval</c>.
    /// </returns>
    public boolean isUserApprovalOwner()
    {
        return WorkflowWorkItem::isUserApprovalOwner(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUserTaskOwner</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets pending task work item status for a user.
    /// </summary>
    /// <returns>
    ///     A Boolean value that indicates if the user has a pending work item of type <c>task</c>.
    /// </returns>
    public boolean isUserTaskOwner()
    {
        return WorkflowWorkItem::isUserTaskOwner(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements the custom logic to be executed corresponding to the field modified.
    /// </summary>
    /// <param name="_fieldId">
    /// A field ID of the field being modified.
    /// </param>
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);

        if (_fieldId == fieldNum(AdvancedLedgerEntryHeader, AccountingDate))
        {
            this.FiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(Ledger::fiscalCalendar(CompanyInfo::current()),
                this.AccountingDate, FiscalPeriodType::Operating).RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>netTransactionDifference</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the net difference of total debit and credit amounts.
    /// </summary>
    /// <returns>
    ///     Returns the difference of total debit and credit amounts.
    /// </returns>
    public AmountCur netTransactionDifference()
    {
        AdvancedLedgerEntryLine advancedLedgerEntryLine;

        select sum(AmountCurCredit), sum(AmountCurDebit) from advancedLedgerEntryLine
            where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == this.RecId;

        return (abs(advancedLedgerEntryLine.AmountCurDebit) - abs(advancedLedgerEntryLine.AmountCurCredit));
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the number of lines that are associated with this advanced ledger entry header.
    /// </summary>
    /// <returns>
    ///     The number of lines that are associated with this advanced ledger entry header.
    /// </returns>
    public int numOfLines()
    {
        AdvancedLedgerEntryLine advancedLedgerEntryLine;

        select count(RecId) from advancedLedgerEntryLine
            where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == this.RecId;

        return any2int(advancedLedgerEntryLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the parent source document line.
    /// </summary>
    /// <returns>
    ///     A <c>SourceDocumentLine</c> buffer.
    /// </returns>
    public SourceDocumentLine parmParentSourceDocumentLine()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocHeaderTypeEnumName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the source document header type name.
    /// </summary>
    /// <returns>
    ///     Always returns SourceDocument_AdvancedLedgerEntry.
    /// </returns>
    public EnumName parmSourceDocHeaderTypeEnumName()
    {
        return enumStr(SourceDocument_AdvancedLedgerEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocHeaderTypeEnumValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the source document header type enum value.
    /// </summary>
    /// <returns>
    ///     Always returns SourceDocument_AdvancedLedgerEntry::AdvancedLedgerEntry.
    /// </returns>
    public SourceDocumentTypeEnumValue parmSourceDocHeaderTypeEnumValue()
    {
        return SourceDocument_AdvancedLedgerEntry::AdvancedLedgerEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineTypeEnumName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a source document line type enum name.
    /// </summary>
    /// <returns>
    ///     Always returns SourceDocumentLine_AdvancedLedgerEntry.
    /// </returns>
    public EnumName parmSourceDocLineTypeEnumName()
    {
        return enumStr(SourceDocumentLine_AdvancedLedgerEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineTypeEnumValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a source document type enum value.
    /// </summary>
    /// <returns>
    ///     Always returns SourceDocumentLine_AdvancedLedgerEntry::AdvancedLedgerEntryLine.
    /// </returns>
    public SourceDocumentTypeEnumValue parmSourceDocLineTypeEnumValue()
    {
        return SourceDocumentLine_AdvancedLedgerEntry::AdvancedLedgerEntryLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the source document header record associated with this record.
    /// </summary>
    /// <returns>
    ///     A <c>SourceDocumentHeader</c> buffer.
    /// </returns>
    public SourceDocumentHeader parmSourceDocumentHeader()
    {
        SourceDocumentHeader sourceDocumentHeader;

        sourceDocumentHeader = SourceDocumentHeader::find(this.SourceDocumentHeader);

        return sourceDocumentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceDocumentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the accounting status of the source document header corresponding to this record.
    /// </summary>
    /// <returns>
    ///     The source document header accounting status.
    /// </returns>
    display SourceDocumentAccountingStatus sourceDocumentStatus()
    {
        SourceDocumentHeader sourceDocumentHeader;

        sourceDocumentHeader = SourceDocumentHeader::find(this.SourceDocumentHeader);

        return sourceDocumentHeader.AccountingStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the record of Advanced Ledger Entry Header and Exchange Rate Date of associated Source Document Header.
    /// </summary>
    public void update()
    {
        boolean doALELineDistributionUpdate = this.isALELineDistributionUpdateRequired(this.orig());
        
        super();

        if (doALELineDistributionUpdate)
        {
            this.updateALELineDistributions();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean isValid;
        isValid = super();

        // Only Draft transactions can be deleted.
        isValid = isValid && AdvancedLedgerEntryManager::checkTransactionStatusForDelete(this.TransactionStatus, this.TransactionNumber);

        // Transactions with workflow status of Rejected or Submitted can't be deleted.
        isValid = isValid && AdvancedLedgerEntryManager::checkWorkflowStatusForDeleteUpdate(this.WorkFlowStatus, this.TransactionNumber);

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Handles the advanced ledger entry header field validations.
    /// </summary>
    /// <param name="_fieldIdToCheck">
    ///     ID of the table field which is being validated.
    /// </param>
    /// <param name="_axAdvancedLedgerEntryHeader">
    ///     An <c>AxAdvancedLedgerEntryHeader</c> instance to be used for validation.
    /// </param>
    /// <returns>
    ///     true if the field value is valid; otherwise, false.
    /// </returns>
    public boolean validateField(
        FieldId                     _fieldIdToCheck,
        AxAdvancedLedgerEntryHeader _axAdvancedLedgerEntryHeader = null)
    {
        boolean                     isValid;
        AxAdvancedLedgerEntryHeader axAdvancedLedgerEntryHeader;

        axAdvancedLedgerEntryHeader = _axAdvancedLedgerEntryHeader;
        if (axAdvancedLedgerEntryHeader == null)
        {
            axAdvancedLedgerEntryHeader = new AxAdvancedLedgerEntryHeader();
            axAdvancedLedgerEntryHeader.advancedLedgerEntryHeader(this);
        }

        isValid = AdvancedLedgerEntryHeaderUtil::construct(axAdvancedLedgerEntryHeader).validateField(_fieldIdToCheck);

        isValid = isValid && super(_fieldIdToCheck);

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean isValid;

        isValid = super();

        isValid = isValid && AdvancedLedgerEntryManager::checkTransactionStatusForWrite(this.TransactionStatus, this.TransactionNumber);

        if (isValid && (this.ReverseEntry == NoYes::Yes && this.ReverseDate == dateNull()))
        {
            isValid = AifFault::checkFailedLogFault(strFmt("@SPS1378", fieldPName(AdvancedLedgerEntryHeader, ReverseDate)));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>write</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults the <c>FiscalCalendarPeriod</c> field to the operating period for the accounting date, if the <c>FiscalCalendarPeriod</c> field is not set.
    /// </summary>
    /// <remarks>
    /// Needed for the advanced ledger entry document service, if the consumer does not set the <c>FiscalCalendarPeriod</c> field.
    /// </remarks>
    public void write()
    {
        if (!this.FiscalCalendarPeriod)
        {
            this.FiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(Ledger::fiscalCalendar(CompanyInfo::findDataArea(this.DataAreaId).RecId),
                this.AccountingDate, FiscalPeriodType::Operating).RecId;
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    public static boolean checkExist(RecId _recId)
    {
        boolean doesExist = true;

        if (!AdvancedLedgerEntryHeader::exist(_recId))
        {
            doesExist = checkFailed(strFmt(AdvancedLedgerEntryHeader::txtNotExist(), _recId));
        }

        return doesExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the specified record in the <c>AdvancedLedgerEntryHeader</c> table exists.
    /// </summary>
    /// <param name="_recId">
    ///     The record ID of the <c>AdvancedLedgerEntryHeader</c> table to check for existence.
    /// </param>
    /// <returns>
    ///     true if the specified record exists, otherwise, false.
    /// </returns>
    public static boolean exist(RecId _recId)
    {
        AdvancedLedgerEntryHeader advancedLedgerEntryHeader;

        select firstonly RecId from advancedLedgerEntryHeader
            where advancedLedgerEntryHeader.RecId == _recId;

        return advancedLedgerEntryHeader.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the specified record in the <c>AdvancedLedgerEntryHeader</c> table.
    /// </summary>
    /// <param name="_recId">
    ///     The record ID of the <c>AdvancedLedgerEntryHeader</c> table to find.
    /// </param>
    /// <param name="_forUpdate">
    ///     A boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    ///     The concurrency model option to be used when reading the record; optional.
    /// </param>
    /// <returns>
    ///     The record of the <c>AdvancedLedgerEntryHeader</c> table if found; otherwise, an empty buffer.
    /// </returns>
    public static AdvancedLedgerEntryHeader find(
        RecId             _recId,
        boolean           _forUpdate = false,
        ConcurrencyModel  _concurrencyModel = ConcurrencyModel::Auto)
    {
        AdvancedLedgerEntryHeader advancedLedgerEntryHeader;

        if (_forUpdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            advancedLedgerEntryHeader.concurrencyModel(_concurrencyModel);
        }

        if (_recId)
        {
            advancedLedgerEntryHeader.selectForUpdate(_forUpdate);

            select firstOnly advancedLedgerEntryHeader
                where advancedLedgerEntryHeader.RecId == _recId;
        }

        return advancedLedgerEntryHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySourceDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds a <c>AdvancedLedgerEntryHeader</c> record by <c>SourceDocument</c>.
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    ///     A <c>SourceDocument</c> record id.
    /// </param>
    /// <returns>
    ///     A <c>AdvancedLedgerEntryHeader</c> record.
    /// </returns>
    public static AdvancedLedgerEntryHeader findBySourceDocumentHeader(RefRecId _sourceDocumentHeader)
    {
        AdvancedLedgerEntryHeader advancedLedgerEntryHeader;

        select firstOnly advancedLedgerEntryHeader
            where advancedLedgerEntryHeader.SourceDocumentHeader == _sourceDocumentHeader;

        return advancedLedgerEntryHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByTransactionNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the record in the <c>AdvancedLedgerEntryHeader</c> table by transaction number.
    /// </summary>
    /// <param name="_transactionNumber">
    ///     The transaction number of the <c>AdvancedLedgerEntryHeader</c> record to find.
    /// </param>
    /// <param name="_forupdate">
    ///     A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    ///     The concurrency model option to use when reading the record; optional.
    /// </param>
    /// <returns>
    ///     A record in the <c>AdvancedLedgerEntryHeader</c> table; otherwise, an empty record.
    /// </returns>
    public static AdvancedLedgerEntryHeader findByTransactionNumber(
        AdvancedLedgerEntryId   _transactionNumber,
        boolean                 _forupdate = false,
        ConcurrencyModel        _concurrencyModel = ConcurrencyModel::Auto)
    {
        AdvancedLedgerEntryHeader advancedLedgerEntryHeader;

        advancedLedgerEntryHeader.selectForUpdate(_forupdate);
        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            advancedLedgerEntryHeader.concurrencyModel(_concurrencyModel);
        }

        select firstOnly advancedLedgerEntryHeader
            where advancedLedgerEntryHeader.TransactionNumber == _transactionNumber;

        return advancedLedgerEntryHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numRefAdvancedLedgerEntryId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a number sequence reference for the advanced ledger entry <c>AdvancedLedgerEntryId</c> extended data
    /// type.
    /// </summary>
    /// <returns>
    /// An instance of the <c>NumberSequenceReference</c> class.
    /// </returns>
    public static final NumberSequenceReference numRefAdvancedLedgerEntryId()
    {
        return NumberSeqReference::findReference(extendedtypenum(AdvancedLedgerEntryId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSourceDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds an advanced ledger entry header by source document header.
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    ///     A record ID of source document header.
    /// </param>
    /// <returns>
    ///     An <c>AdvancedLedgerEntryHeader</c> buffer.
    /// </returns>
    public static AdvancedLedgerEntryHeader findSourceDocumentHeader(RefRecId _sourceDocumentHeader)
    {
        AdvancedLedgerEntryHeader advancedLedgerEntryHeader;

        select firstOnly advancedLedgerEntryHeader
            where advancedLedgerEntryHeader.SourceDocumentHeader == _sourceDocumentHeader;

        return advancedLedgerEntryHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasProjectLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if there are project lines associated with the passed in <c>AdvancedLedgerEntryHeader</c> record.
    /// </summary>
    /// <param name="_advancedLedgerEntryHeaderRecId">
    /// The record ID of the <c>AdvancedLedgerEntryHeader</c> record to query.
    /// </param>
    /// <returns>
    /// true if there are project lines associated with the passed in <c>AdvancedLedgerEntryHeader</c> record; otherwise false.
    /// </returns>
    static boolean hasProjectLines(AdvanceLedgerEntryHeaderRecId _advancedLedgerEntryHeaderRecId)
    {
        AdvancedLedgerEntryLine advancedLedgerEntryLine;

        select firstOnly RecId from advancedLedgerEntryLine
            where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == _advancedLedgerEntryHeaderRecId
            && advancedLedgerEntryLine.ProjId != '';

        return (advancedLedgerEntryLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWorkflowState</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the workflow status for the advanced ledger entry header.
    /// </summary>
    /// <param name="_advancedLedgerEntryHeaderRecId">
    ///     The record ID of the <c>AdvancedLedgerEntryHeader</c> record for which to set the workflow status.
    /// </param>
    /// <param name="_workflowState">
    ///     The workflow state to set.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///     The element of the <c>AdvancedLedgerEntryWFApprovalState</c> enum that passed into the method was not expected.
    /// </exception>
    public static void setWorkflowState(
        RecId                              _advancedLedgerEntryHeaderRecId,
        AdvancedLedgerEntryWFApprovalState _workflowState)
    {
        AdvancedLedgerEntryHeader           advancedLedgerEntryHeader;
        AdvancedLedgerEntryWFApprovalStatus newWorkflowStatus;

        switch (_workflowState)
        {
            case AdvancedLedgerEntryWFApprovalState::Submitted:
                newWorkflowStatus = AdvancedLedgerEntryWFApprovalStatus::Submitted;
                break;

            case AdvancedLedgerEntryWFApprovalState::NotSubmitted:
                newWorkflowStatus = AdvancedLedgerEntryWFApprovalStatus::Draft;
                break;

            case AdvancedLedgerEntryWFApprovalState::PendingComplete:
                newWorkflowStatus = AdvancedLedgerEntryWFApprovalStatus::PendingCompletion;
                break;

            case AdvancedLedgerEntryWFApprovalState::Completed:
                newWorkflowStatus = AdvancedLedgerEntryWFApprovalStatus::Completed;
                break;

            case AdvancedLedgerEntryWFApprovalState::PendingApproval:
                newWorkflowStatus = AdvancedLedgerEntryWFApprovalStatus::PendingApproval;
                break;

            case AdvancedLedgerEntryWFApprovalState::Approved:
            case AdvancedLedgerEntryWFApprovalState::WorkflowCompleted:
                newWorkflowStatus = AdvancedLedgerEntryWFApprovalStatus::Approved;
                break;

            case AdvancedLedgerEntryWFApprovalState::Returned:
                newWorkflowStatus = AdvancedLedgerEntryWFApprovalStatus::Rejected;
                break;

            case AdvancedLedgerEntryWFApprovalState::ChangeRequested:
                newWorkflowStatus = AdvancedLedgerEntryWFApprovalStatus::ChangeRequested;
                break;

            case AdvancedLedgerEntryWFApprovalState::PendingCancellation:
                newWorkflowStatus = AdvancedLedgerEntryWFApprovalStatus::PendingCancellation;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        ttsBegin;

        advancedLedgerEntryHeader.skipDataMethods(true);

        update_recordSet advancedLedgerEntryHeader
            setting WorkflowApprovalState = _workflowState, WorkflowStatus = newWorkflowStatus
            where advancedLedgerEntryHeader.RecId == _advancedLedgerEntryHeaderRecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    public static TxtNotExist txtNotExist()
    {
        return "@SPS1280";
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a lookup of the <c>Currency</c> table.
    /// </summary>
    /// <param name="_control">
    /// The form reference control to perform the lookup for.
    /// </param>
    public static void lookupCurrency(FormStringControl _control)
    {
        SysTableLookup currencyLookup;

        // Set up the lookup form.
        currencyLookup = SysTableLookup::newParameters(tableNum(Currency), _control, true);

        // Add the fields to be shown in the lookup form.
        currencyLookup.addLookupfield(fieldNum(Currency, CurrencyCode));
        currencyLookup.addLookupfield(fieldNum(Currency, Txt));

        // Perform the lookup.
        currencyLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isALELineDistributionUpdateRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a change to the <c>AdvancedLedgerEntryHeader</c> table should update the record in the
    /// <c>AccountingDistribution</c> table that is associated with <c>AdvancedLedgerEntryLine</c> records.
    /// </summary>
    /// <param name = "_advancedLedgerEntryHeaderOriginal">
    /// An <c>AdvancedLedgerEntryHeader</c> table buffer that contains the values
    /// of the record prior to the update of the record that triggered this method.
    /// </param>
    /// <returns>
    /// true if the <c>AccountingDistribution</c> table records that are associated to the  
    /// <c>AdvancedLedgerEntryHeader</c> table record need to be updated; otherwise, false.
    /// </returns>
    private boolean isALELineDistributionUpdateRequired(AdvancedLedgerEntryHeader _advancedLedgerEntryHeaderOriginal)
    {
        return (_advancedLedgerEntryHeaderOriginal.AccountingDate != this.AccountingDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateALELineDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the submission to the accounting framework for all lines to
    /// update the <c>AccountingDistribution</c> records.
    /// </summary>
    private void updateALELineDistributions()
    {
        AdvancedLedgerEntryLine advancedLedgerEntryLine;
        SourceDocumentLine sourceDocumentLine;
 
        while select advancedLedgerEntryLine
            where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == this.Recid
            exists join sourceDocumentLine
                where sourceDocumentLine.RecId == advancedLedgerEntryLine.SourceDocumentLine
                && sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Completed
        {
            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(advancedLedgerEntryLine);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>AdvancedLedgerEntry</ConfigurationKey>
	<DeveloperDocumentation>@SPS2506</DeveloperDocumentation>
	<FormRef>AdvancedLedgerEntry</FormRef>
	<Label>@SPS1211</Label>
	<SingularLabel>@SPS1174</SingularLabel>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>TransactionNumber</TitleField1>
	<TitleField2>TransactionText</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>Found</CacheLookup>
	<CreatedBy>Yes</CreatedBy>
	<Modules>Ledger</Modules>
	<ReplacementKey>TransactionNumberIdx</ReplacementKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransactionText</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalizingDefinition</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransactionNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AdvancedLedgerEntryHeader</Name>
			<Label>@SPS1211</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>displayAttachmentExists</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransactionNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransactionText</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountingDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReasonTableRef</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkFlowStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransactionStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReverseEntry</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReverseDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>createdBy</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AssignedSettings</Name>
			<Label>@SPS1910</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JournalizingDefinition</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransactionCurrency</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>General</Name>
			<Label>@SPS1232</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerVoucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceDocumentHeader</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reason</Name>
			<Label>@SPS1233</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReasonTableRef</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reference</Name>
			<Label>@SPS1234</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SourceDocumentHeader</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>JournalizingDefinition</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountingDistributionTemplate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReasonTableRef</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerVoucher</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReversingEntry</Name>
			<Label>@SPS1235</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReverseEntry</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReverseDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Status</Name>
			<Label>@SPS1236</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransactionStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkFlowStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction</Name>
			<Label>@SPS1237</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountingDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransactionNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransactionText</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FiscalCalendarPeriod</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>AccountingDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SPS1227</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>AccountingDistributionTemplate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AccountingDistributionTemplateRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDefault</ExtendedDataType>
			<Visible>No</Visible>
<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>FiscalCalendarPeriod</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>JournalizingDefinition</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SPS1229</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LedgerVoucher</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Voucher</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ReasonTableRef</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReasonRefRecID</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ReverseDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SPS1230</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReverseEntry</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SPS1235</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceDocumentHeader</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransactionCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransactionNumber</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AdvancedLedgerEntryId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TransactionStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>AdvancedLedgerEntryTransactionStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransactionText</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AdvancedLedgerEntryTransText</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkflowApprovalState</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>AdvancedLedgerEntryWFApprovalState</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkFlowStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>AdvancedLedgerEntryWFApprovalStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>FinTag</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>FinTagRecId</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TransactionNumberIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>TransactionNumber</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueSetIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>DefaultDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SourceDocumentHeaderIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceDocumentHeader</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>dataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>VoucherAccountingDateTranNumIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>AccountingDate</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LedgerVoucher</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransactionNumber</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SourceDocumentHeaderImplementation</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>SourceDocumentHeader</MapField>
					<MapFieldTo>SourceDocumentHeader</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AccountingDistributionTemplate</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>AccountingDistributionTemplate</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountingDistributionTemplate</Name>
					<Field>AccountingDistributionTemplate</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TransactionCurrency</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>TransactionCurrency</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>FiscalCalendarPeriod</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>FiscalCalendarPeriod</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FiscalCalendarPeriod</Name>
					<Field>FiscalCalendarPeriod</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>JournalizingDefinition</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>JournalizingDefinition</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JournalizingDefinition</Name>
					<Field>JournalizingDefinition</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ReasonTableRef</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ReasonTableRef</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReasonTableRef</Name>
					<SourceEDT>ReasonRefRecID</SourceEDT>
					<Field>ReasonTableRef</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SourceDocumentHeader</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SourceDocumentHeader</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceDocumentHeader</Name>
					<Field>SourceDocumentHeader</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>FinTag</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>FinTag</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>FinTag</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FinTag</Name>
					<Field>FinTag</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>