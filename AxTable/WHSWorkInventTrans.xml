<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkInventTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class WHSWorkInventTrans extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkFieldsUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks to make sure fields updated are allowed to be updated.
    /// </summary>
    /// <returns>
    ///     true if fields can be updated; otherwise, false
    /// </returns>
    boolean checkFieldsUpdated()
    {
        boolean ret = true;

        // These fields cannot be updated
        if (this.orig().InventTransIdFrom            != this.InventTransIdFrom   ||
            this.orig().InventTransIdTo              != this.InventTransIdTo     ||
            this.orig().ItemId                       != this.ItemId              ||
            this.orig().InventTransIdParent          != this.InventTransIdParent ||
            this.orig().InventQtyRemain              != this.InventQtyRemain     ||
            this.orig().InventoryTransactionOriginId != this.InventoryTransactionOriginId)
        {
            ret = checkFailed("@WAX2936");
        }
        else
        {
            // Quantity field cannot be negative
            if (this.Qty < 0)
            {
                ret = checkFailed(strFmt("@WAX:WorkInventTransQtyNegativeError", this.WorkId, this.LineNum, this.ItemId, this.Qty));
            }
            else
            {
                // Update to Qty cannot take remaining quantity negative
                if ((this.orig().Qty > this.Qty) &&
                    ((this.orig().Qty - this.Qty) > this.InventQtyRemain))
                {
                    ret = checkFailed(strFmt("@WAX2938", this.orig().Qty - this.Qty));
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    void delete()
    {
        if (this.InventQtyRemain != this.Qty && !WHSWorkInventTransDeletionContext::allowDeleteWhenInventQtyRemainNotEqualQty())
        {
            throw error(strFmt("@WAX2238", this.WorkId, this.LineNum, this.InventTransIdParent));
        }

        WHSWorkBeingSplitValidator::validateWorkTableIsNotBeingSplit(this.WorkId);

        if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(this.WorkId))
        {
            InventDim inventDimFrom = InventDim::find(this.InventDimIdFrom);

            // remove reservation.
            if (   this.InventQtyRemain
                && inventDimFrom.wmsLocationId)
            {
                WHSInventoryTransactionSource source = WHSInventoryTransactionSource::newFromValues(
                    WHSInventoryTransactionReferenceCategoryEnum::Work,
                    this.WorkId,
                    this.InventoryTransactionOriginId);

                WHSInventoryTransactionActionRemoveReservationParameters actionParams = WHSInventoryTransactionActionRemoveReservationParameters::newFromValues(
                    source,
                    this.constructInventoryItemSet(this.InventQtyRemain, this.RemainingTransactionWeight, inventDimFrom),
                    WHSInventoryStorageDimensions::newFromInventDim(inventDimFrom));
                
                WHSInventoryTransactionActionResult result = WHSInventoryTransactionRemoveReservationAction::construct().execute(actionParams);
            }
        }
        else
        {
            InventUpd_DeleteMovement::newMovement(InventMovement::construct(this)).updateNow();
            InventUpd_DeleteMovement::newMovement(InventMovement::construct(this,InventMovSubType::TransferReceipt)).updateNow();
        }

        // Transfer reservation back to the demand order
        this.updateOrderCommittedReservation(this.InventQtyRemain);

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>increaseQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increases current quantity.
    /// </summary>
    /// <param name="_qty">
    /// Quantity to be added.
    /// </param>
    /// <remarks>
    /// It doesn't allow negative quantities.
    /// </remarks>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the increaseQuantities method. Please file an extensibility request if other access is required.', false, 30\9\2019)]
    public void increaseQty(InventQty _qty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), this.ItemId);

        this.increaseTransactionQuantities(_qty, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>increaseQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increases current quantity.
    /// </summary>
    /// <param name="_addHandlingQty">
    /// A handling quantity to be added.
    /// </param>
    /// <param name="_addHandlingWeight">
    /// A weight of the handling quantity to be added.
    /// </param>
    /// <remarks>
    /// It doesn't allow negative quantities.
    /// </remarks>
    [Hookable(false)]
    final public void increaseQuantities(
        InventHandlingQty   _addHandlingQty,
        WHSTransWeight      _addHandlingWeight)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), this.ItemId, _addHandlingWeight))
        {
            this.increaseQty(_addHandlingQty);
        }
        else
        {
            this.increaseTransactionQuantities(_addHandlingQty, _addHandlingWeight);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>increaseTransactionQuantities</Name>
				<Source><![CDATA[
    private void increaseTransactionQuantities(
        InventHandlingQty   _addHandlingQty,
        WHSTransWeight      _addHandlingWeight)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), this.ItemId, _addHandlingQty, _addHandlingWeight);
        
        if (_addHandlingQty > 0 || _addHandlingWeight > 0)
        {
            ttsbegin;
            this.Qty += _addHandlingQty;

            // For catch weight we typical update weight remaining without changing TransactionWeight because weight values change as we process.
            // In this scenario we want to update TransactionWeight also because it's an unprocessed WIT.
            this.TransactionWeight          += _addHandlingWeight;
            this.RemainingTransactionWeight += _addHandlingWeight;

            this.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the record from another <c>WHSWorkInventTrans</c> record.
    /// </summary>
    /// <param name="_workInventTrans">
    /// The record to be used to initialize.
    /// </param>
    void initFromWorkInventTrans(WHSWorkInventTrans _workInventTrans)
    {
        this.WorkId                 = _workInventTrans.WorkId;
        this.ItemId                 = _workInventTrans.ItemId;
        this.InventDimIdFrom        = _workInventTrans.InventDimIdTo;
        this.InventTransIdParent    = _workInventTrans.InventTransIdParent;
        this.Qty                    = _workInventTrans.Qty;
        this.InventQtyRemain        = _workInventTrans.Qty;

        this.TransactionWeight              = _workInventTrans.TransactionWeight;
        this.RemainingTransactionWeight     = _workInventTrans.TransactionWeight;

        this.TransDateTime          = DateTimeUtil::utcNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventTrans</Name>
				<Source><![CDATA[
    private InventUpd_Estimated createInventTrans(
        InventHandlingQty   _handlingQty,
        WHSTransWeight      _handlingWeight,
        InventDim           _inventDimSpecific,
        InventMovSubtype    _inventMovSubType,
        boolean             _skipInventTransSumUp,
        boolean             _skipUseOfRecordViewCache = true)
    {
        InventUpd_Estimated     estimated;
        WHSInventMov_Work       movementWork;

        movementWork = InventMovement::construct(this,_inventMovSubType) as WHSInventMov_Work;
        movementWork.parmSkipUseOfRecordViewCache(_skipUseOfRecordViewCache);

        estimated = InventUpd_Estimated::newInventMovement(movementWork);
        estimated.parmInventDim(_inventDimSpecific);

        if (!movementWork.pdsCWItem())
        {
            estimated.parmEstimated(_handlingQty);
            estimated.parmPdsCWEstimated(0);
        }
        else
        {
            estimated.parmEstimated(_handlingWeight);
            estimated.parmPdsCWEstimated(_handlingQty);
        }

        estimated.parmUseInventDimForNewTransactions(true);

        //performance related settings
        estimated.parmSkipUpdateDimensionFieldChange(true);
        estimated.parmSkipInventTransSumUp(_skipInventTransSumUp);
        estimated.updateNow();

        return estimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransForSpecificDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates quantity and creates related inventory transactions with the specified inventory dimensions.
    /// </summary>
    /// <param name="_inventQty">
    /// The inventory quantity.
    /// </param>
    /// <param name="_inventDimFromSpecific">
    /// The specific from dimension. This is used if the transactions has multiple inventory transactions with different dimensions.
    /// </param>
    /// <param name="_inventDimToSpecific">
    /// The specific to dimension. This is used if the transactions has multiple inventory transactions with different dimensions.
    /// </param>
    /// <param name="_reserve">
    /// A boolean that determines if reservation should be done.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the changeQuantitiesForSpecificDimensions method. Please file an extensibility request if other access is required.', false, 30\9\2019)]
    public void createTransForSpecificDimensions(
        InventQty   _inventQty,
        InventDim   _inventDimFromSpecific,
        InventDim   _inventDimToSpecific,
        boolean     _reserve = false)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), this.ItemId);

        this.updateQuantitiesForSpecificDimensions(_inventQty, 0, _inventDimFromSpecific, _inventDimToSpecific, _reserve);
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeQuantitiesForSpecificDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes quantities with the specified inventory dimensions.
    /// </summary>
    /// <param name="_handlingQty">
    /// The handling quantity.
    /// </param>
    /// <param name="_handlingWeight">
    /// The weight of the handling quantity.
    /// </param>
    /// <param name="_fromSpecificInventDim">
    /// The specific from dimension. This is used if the transactions has multiple inventory transactions with different dimensions.
    /// </param>
    /// <param name="_toSpecificInventDim">
    /// The specific to dimension. This is used if the transactions has multiple inventory transactions with different dimensions.
    /// </param>
    /// <param name="_reserve">
    /// A boolean that determines if reservation should be done.
    /// </param>
    public void changeQuantitiesForSpecificDimensions(
        InventHandlingQty   _handlingQty,
        WHSTransWeight      _handlingWeight,
        InventDim           _fromSpecificInventDim,
        InventDim           _toSpecificInventDim,
        boolean             _reserve)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), this.ItemId, _handlingWeight))
        {
            this.createTransForSpecificDimensions(_handlingQty, _fromSpecificInventDim, _toSpecificInventDim, _reserve);
        }
        else
        {
            this.updateQuantitiesForSpecificDimensions(_handlingQty, _handlingWeight, _fromSpecificInventDim, _toSpecificInventDim, _reserve);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuantitiesForSpecificDimensions</Name>
				<Source><![CDATA[
    private void updateQuantitiesForSpecificDimensions(
        InventHandlingQty   _handlingQty,
        WHSTransWeight      _handlingWeight,
        InventDim           _inventDimFromSpecific,
        InventDim           _inventDimToSpecific,
        boolean             _reserve = false)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), this.ItemId, _handlingQty, _handlingWeight);
        
        InventQty       inventQty;
        PdsInventQty    cwQty;

        if (!PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            inventQty   = _handlingQty;
            cwQty       = 0;
        }
        else
        {
            inventQty   = _handlingWeight;
            cwQty       = _handlingQty;
        }

        ttsbegin;

        this.InventQtyRemain += _handlingQty;
        this.qty             += _handlingQty;

        if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(this.WorkId))
        {
            if (_reserve)
            {
                // Undo reserve for the demand inventDimId since new reservation will be created for the WHSWorkInventTrans
                this.updateOrderCommittedReservation(-_handlingQty);

                // This way we ignore the reservations on specific dimensions and make reservations on the same dimensions as stamped on WHSWorkInventTrans.
                // This is a precaution - just in case we encounter data corruptions caused by mismatch of "Reservation"-"RemoveReservation" pair.
                InventDim inventDimToReserve = _inventDimFromSpecific;

                if (inventDimToReserve.inventDimId != this.InventDimIdFrom)
                {
                    // We want to be able to detect such executions because without correct subsequent code this can cause data corruptions.
                    // We don't see such cases in the core WHS solution, but we cannot guarantee that the extensions do the same.
                    this.logReservationOnSpecificDimensions(funcName(), inventDimToReserve.RecId, InventDim::find(this.InventDimIdFrom).RecId);
                }

                WHSInventoryTransactionSource source = WHSInventoryTransactionSource::newFromValues(
                    WHSInventoryTransactionReferenceCategoryEnum::Work,
                    this.WorkId,
                    this.InventoryTransactionOriginId);

                WHSInventoryTransactionCreateReservationAction::construct().execute(WHSInventoryTransactionActionCreateReservationParameters::newFromValues(
                    source,
                    this.constructInventoryItemSet(_handlingQty, _handlingWeight, inventDimToReserve),
                    WHSInventoryStorageDimensions::newFromInventDim(inventDimToReserve)));
            }
        }
        else
        {
            //use recordViewCache if reservation is done since the call to reservation code will benefit from the cache
            boolean skipUseOfRecordViewCache = !_reserve;

            InventUpd_Estimated estimatedFrom = this.createInventTrans(-_handlingQty, -_handlingWeight, _inventDimFromSpecific, InventMovSubType::None, true, skipUseOfRecordViewCache);

            if (_reserve)
            {
                estimatedFrom.reserveQuantities(-inventQty, -cwQty, true);
            }
          
            if (_reserve)
            {
                // Undo reserve for the demand inventDimId since new reservation will be created for the WHSWorkInventTrans
                this.updateOrderCommittedReservation(-_handlingQty);
            }
            

            this.createInventTrans(_handlingQty, _handlingWeight, _inventDimToSpecific, InventMovSubType::TransferReceipt, true, true);
        }

        this.doUpdate();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventTransIds</Name>
				<Source><![CDATA[
    private void setInventTransIds()
    {
        NumberSeq numberSeq = NumberSeq::newGetNum(InventParameters::numRefInventTransId());

        this.InventTransIdFrom  = numberSeq.num();
        this.InventTransIdTo    = numberSeq.num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureRequiredIdsAreGenerated</Name>
				<Source><![CDATA[
    private void ensureRequiredIdsAreGenerated()
    {
        this.InventoryTransactionOriginId = WHSSequentialGuidGenerator::generateSequentialGuid();

        if (!this.ItemSetId)
        {
            this.ItemSetId = WHSSequentialGuidGenerator::generateSequentialGuid();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructInventoryItemSet</Name>
				<Source><![CDATA[
    private WHSInventoryItemSetId constructInventoryItemSet(
        ProductQuantity _qty,
        WHSTransWeight  _transactionWeight,
        InventDim       _fromInventDim)
    {
        WHSInventoryItemSetElement itemSetElement = WHSInventoryItemSetElement::insertItemSetElement(
            WHSSequentialGuidGenerator::generateSequentialGuid(),
            this.ItemId,
            _fromInventDim,
            _qty,
            _transactionWeight);

        return itemSetElement.ItemSetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWithSpecificDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the record and its related inventory transactions.
    /// </summary>
    /// <param name="_inventQty">
    /// The inventory quantity.
    /// </param>
    /// <param name="_inventDimFrom">
    /// The from dimension.
    /// </param>
    /// <param name="_inventDimTo">
    /// The to dimensions.
    /// </param>
    /// <param name="_inventDimFromSpecific">
    /// The specific from dimension. This is used if the transactions has multiple inventory transactions with different dimensions.
    /// </param>
    /// <param name="_inventDimToSpecific">
    /// The specific to dimension. This is used if the transactions has multiple inventory transactions with different dimensions.
    /// </param>
    /// <param name="_reserve">
    /// A boolean that determines if reservation should be done.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the createQuantitiesWithSpecificDimensions method. Please file an extensibility request if other access is required.', false, 30\9\2019)]
    public void insertWithSpecificDimensions(
        InventQty   _inventQty,
        InventDim   _inventDimFrom,
        InventDim   _inventDimTo,
        InventDim   _inventDimFromSpecific,
        InventDim   _inventDimToSpecific,
        boolean     _reserve = false)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), this.ItemId);

        this.insertQuantitiesWithSpecificDimensions(_inventQty, 0, _inventDimFrom, _inventDimTo, _inventDimFromSpecific, _inventDimToSpecific, _reserve);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQuantitiesWithSpecificDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates quantities with the related inventory transactions.
    /// </summary>
    /// <param name="_handlingQty">
    /// The handling quantity.
    /// </param>
    /// <param name="_handlingWeight">
    /// The weight of the handling quantity.
    /// </param>
    /// <param name="_fromInventDim">
    /// The from dimension.
    /// </param>
    /// <param name="_toInventDim">
    /// The to dimensions.
    /// </param>
    /// <param name="_fromSpecificInventDim">
    /// The specific from dimension. This is used if the transactions has multiple inventory transactions with different dimensions.
    /// </param>
    /// <param name="_toSpecificInventDim">
    /// The specific to dimension. This is used if the transactions has multiple inventory transactions with different dimensions.
    /// </param>
    /// <param name="_reserve">
    /// A Boolean that determines if reservation should be done.
    /// </param>
    public void createQuantitiesWithSpecificDimensions(
        InventHandlingQty   _handlingQty,
        WHSTransWeight      _handlingWeight,
        InventDim           _fromInventDim,
        InventDim           _toInventDim,
        InventDim           _fromSpecificInventDim,
        InventDim           _toSpecificInventDim,
        boolean             _reserve)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), this.ItemId, _handlingWeight))
        {
            this.insertWithSpecificDimensions(_handlingQty, _fromInventDim, _toInventDim, _fromSpecificInventDim, _toSpecificInventDim, _reserve);
        }
        else
        {
            this.insertQuantitiesWithSpecificDimensions(_handlingQty, _handlingWeight, _fromInventDim, _toInventDim, _fromSpecificInventDim, _toSpecificInventDim, _reserve);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertQuantitiesWithSpecificDimensions</Name>
				<Source><![CDATA[
    private void insertQuantitiesWithSpecificDimensions(
        InventHandlingQty   _handlingQty,
        WHSTransWeight      _handlingWeight,
        InventDim           _fromInventDim,
        InventDim           _toInventDim,
        InventDim           _fromSpecificInventDim,
        InventDim           _toSpecificInventDim,
        boolean             _reserve)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), this.ItemId, _handlingQty, _handlingWeight);
        
        InventQty       inventQty;
        PdsInventQty    cwQty;

        if (!PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            inventQty   = _handlingQty;
            cwQty       = 0;
        }
        else
        {
            inventQty   = _handlingWeight;
            cwQty       = _handlingQty;
        }

        ttsbegin;

        this.InventDimIdFrom = _fromInventDim.inventdimId;
        this.InventDimIdTo   = _toInventDim.inventDimId;

        this.InventQtyRemain = _handlingQty;
        this.Qty             = _handlingQty;

        if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(this.WorkId))
        {
            if (WHSWorkInventTransInsertWithDimInventTransMechanismValidationFlight::instance().isEnabled())
            {
                this.validateInventoryTransactionMechanismOnWorkHeader(WHSInventoryTransactionMechanismEnum::WHSInventoryTransaction);
            }

            this.ensureRequiredIdsAreGenerated();

            if (_reserve)
            {
                // We should never hit a scenario when specific dimensions are not specifying the location.
                Debug::assert(_fromSpecificInventDim.wmsLocationId != '');

                // Undo reserve for the demand inventDimId since new reservation will be created for the WHSWorkInventTrans
                this.updateOrderCommittedReservation(-this.Qty);

                // This way we ignore the reservations on specific dimensions and make reservations on the same dimensions as stamped on WHSWorkInventTrans.
                // This is a precaution - just in case we encounter data corruptions caused by mismatch of "Reservation"-"RemoveReservation" pair.
                InventDim inventDimToReserve = _fromSpecificInventDim;

                if (inventDimToReserve.inventDimId != _fromInventDim.inventDimId)
                {
                    // We want to be able to detect such executions because without correct subsequent code this can cause data corruptions.
                    // We don't see such cases in the core WHS solution, but we cannot guarantee that the extensions do the same.
                    this.logReservationOnSpecificDimensions(funcName(), inventDimToReserve.RecId, _fromInventDim.RecId);
                }

                WHSInventoryTransactionSource source = WHSInventoryTransactionSource::newFromValues(
                    WHSInventoryTransactionReferenceCategoryEnum::Work,
                    this.WorkId,
                    this.InventoryTransactionOriginId);

                WHSInventoryTransactionCreateReservationAction::construct().execute(WHSInventoryTransactionActionCreateReservationParameters::newFromValues(
                    source,
                    this.constructInventoryItemSet(this.Qty, this.TransactionWeight, inventDimToReserve),
                    WHSInventoryStorageDimensions::newFromInventDim(inventDimToReserve),
                    WHSInventoryTransactionActionValidationParameters::newCreateReservation().setCheckOnHand(WHSWorkInventTrans::mustCheckOnHandDuringReservationCreation())));
            }

            this.doInsert();
        }
        else
        {
            if (WHSWorkInventTransInsertWithDimInventTransMechanismValidationFlight::instance().isEnabled())
            {
                this.validateInventoryTransactionMechanismOnWorkHeader(WHSInventoryTransactionMechanismEnum::InventTrans);
            }

            this.setInventTransIds();

            //use recordViewCache if reservation is done since the call to reservation code will benefit from the cache
            boolean skipUseOfRecordViewCache = !_reserve;

            InventUpd_Estimated estimatedFrom = this.createInventTrans(-_handlingQty, -_handlingWeight, _fromSpecificInventDim, InventMovSubType::None, true, skipUseOfRecordViewCache);

            if (_reserve)
            {
                estimatedFrom.reserveQuantities(-inventQty, -cwQty, true);
            }
           
            if (_reserve)
            {
                // Undo reserve for the demand inventDimId since new reservation will be created for the WHSWorkInventTrans
                this.updateOrderCommittedReservation(-this.Qty);
            }
            

            InventUpd_Estimated estimatedTo = this.createInventTrans(_handlingQty, _handlingWeight, _toSpecificInventDim, InventMovSubType::TransferReceipt, true, false);

            this.doInsert();

            estimatedFrom.updateOwnerRelationship();
            estimatedTo.updateOwnerRelationship();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReplenishmentQtyDemand</Name>
				<Source><![CDATA[
    public void setReplenishmentQtyDemand(InventQty _inventQty)
    {
        this.Qty = _inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the record from an <c>WHSWorkLine</c> record.
    /// </summary>
    /// <param name="_workLine">
    /// The record to be used to initialize.
    /// </param>
    void initFromWorkLine(WHSWorkLine _workLine)
    {
        InventDim       inventDim;

        if (_workLine.OrderCommittedInventDimId)
        {
            inventDim = InventDim::find(_workLine.OrderCommittedInventDimId);
        }
        else
        {
            // Create the location level dimensions for the from location.
            // WorkLine inventDim should hold all dimensions values above location.
            inventDim = InventDim::find(_workLine.InventDimId);
            inventDim.wmsLocationId = _workLine.wmsLocationId;
            inventDim = InventDim::findOrCreate(inventDim);
        }

        this.WorkId                 = _workLine.WorkId;
        this.LineNum                = _workLine.LineNum;
        this.ItemId                 = _workLine.ItemId;

        ProductQuantity quantity = (_workLine.ReplenDemand ? (_workLine.AvailPhysical > 0 ? _workLine.AvailPhysical : 0) :_workLine.InventQtyWork);
        
        this.setInitialQuantityAndWeightValues(quantity, WhsInvent::defaultCatchWeightReserveQuantity(this.ItemId, quantity));
        
        this.InventDimIdTo          = _workLine.InventDimId;
        this.InventDimIdFrom        = inventDim.InventDimId;
        this.InventTransIdParent    = _workLine.InventTransId;
        this.TransDateTime          = DateTimeUtil::utcNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInitialQuantityAndWeightValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the initial quantity and weight values.
    /// </summary>
    /// <param name = "_quantity">The initial quantity.</param>
    /// <param name = "_weight">The initial weight.</param>
    [Hookable(false)]
    internal void setInitialQuantityAndWeightValues(
        ProductQuantity     _quantity,
        WHSHandlingWeight   _weight)
    {
        this.Qty                        = _quantity;
        this.InventQtyRemain            = this.Qty;
        this.TransactionWeight          = _weight;
        this.RemainingTransactionWeight = this.TransactionWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertItemIdInventTransIdParentInSync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assert that for the specified <c>InventTransIdParent</c> the origin <c>ItemId</c> matches the one on this record.
    /// </summary>
    private void assertItemIdInventTransIdParentInSync()
    {
        if (this.InventTransIdParent)
        {
            InventTransOrigin inventTransOrigin = InventTransOrigin::findByInventTransId(this.InventTransIdParent);

            if (inventTransOrigin && inventTransOrigin.ItemId != this.ItemId)
            {
                throw error(strFmt("@WAX:WorkInventTrans_OutOfSync", inventTransOrigin.ItemId, this.InventTransIdParent, this.ItemId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertQuantityNonNegative</Name>
				<Source><![CDATA[
    private void assertQuantityNonNegative()
    {
        if (this.Qty < 0)
        {
            throw error(strFmt("@WAX:WorkInventTransQtyNegativeError", this.WorkId, this.LineNum, this.ItemId, this.Qty));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveSkipOnHandCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inventory reservation update with skip on hand check.
    /// </summary>
    /// <param name = "_inventUpdEstimated">An instance of <c>InventUpd_Estimated</c> class.</param>
    protected void reserveSkipOnHandCheck(InventUpd_Estimated _inventUpdEstimated)
    {
        InventDimParm   inventDimParm;
        InventDim       inventDim = _inventUpdEstimated.movement().inventdim();
        
        inventDimParm.initFromInventDim(inventDim);
        
        InventUpd_Reservation reservation = InventUpd_Reservation::newParameters(_inventUpdEstimated.movement(),
                                                                                  inventDim,
                                                                                  inventDimParm,
                                                                                  InventDimFixedClass::inventDimParm2InventDimFixed(inventDimParm),
                                                                                  _inventUpdEstimated.parmEstimated(),
                                                                                  false,
                                                                                  false,
                                                                                  _inventUpdEstimated.parmPdsCWEstimated());
        
        InventUpdateReservationParameters reservationParameters = InventUpdateReservationParameters::construct();
        
        InventUpd_WHSReservation whsReservation = reservation as InventUpd_WHSReservation;
        
        boolean enforceOnHandCheck = 
            whsReservation &&
            WHSWorkInventTrans::mustCheckOnHandDuringReservationCreation();

        if (enforceOnHandCheck)
        {
            reservationParameters.SkipOnHandCheck = false;
            whsReservation.parmThrowOnInsufficientOnHand(false);
            
            //Do not support recovering from partial reservation.            
            whsReservation.parmThrowOnPartialReserve(true);
        }
        else
        {
            reservationParameters.SkipOnHandCheck = true;
        }

        reservation.parmReservationParameters(reservationParameters);
        // When inserting the line we reserve the actual quantity from the workInventTrans since assumption is that it was created with correct values.
        reservation.parmPdsCWForceActual(this.RecId == 0);
        
        reservation.updateNow();

        if (enforceOnHandCheck &&
            whsReservation.parmReservationFailed())
        {
            WHSWorkCreateReservationContext::current().ReservationFailed = true;;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the record into database.
    /// </summary>
    void insert()
    {
        this.assertQuantityNonNegative();
        this.assertItemIdInventTransIdParentInSync();

        try
        {
            ttsbegin;

            if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(this.WorkId))
            {
                if (WHSInventoryTransactionMechanismValidationFlight::instance().isEnabled())
                {
                    this.validateInventoryTransactionMechanismOnWorkHeader(WHSInventoryTransactionMechanismEnum::WHSInventoryTransaction);
                }

                this.ensureRequiredIdsAreGenerated();

                InventDim inventDimFrom = InventDim::find(this.InventDimIdFrom);

                // If the location isn't specified then we don't need to reserve.
                // Reservation will occur once the location is known.
                if (inventDimFrom.wmsLocationId)
                {
                    // Undo reserve for the demand inventDimId since new reservation will be created for the WHSWorkInventTrans
                    this.updateOrderCommittedReservation(-this.InventQtyRemain);

                    WHSInventoryTransactionSource source = WHSInventoryTransactionSource::newFromValues(
                        WHSInventoryTransactionReferenceCategoryEnum::Work,
                        this.WorkId,
                        this.InventoryTransactionOriginId);

                    WHSInventoryTransactionCreateReservationAction::construct().execute(WHSInventoryTransactionActionCreateReservationParameters::newFromValues(
                        source,
                        this.constructInventoryItemSet(this.Qty, this.TransactionWeight, inventDimFrom),
                        WHSInventoryStorageDimensions::newFromInventDim(inventDimFrom),
                        WHSInventoryTransactionActionValidationParameters::newCreateReservation().setCheckOnHand(WHSWorkInventTrans::mustCheckOnHandDuringReservationCreation())));
                }

                super();
            }
            else
            {
                if (WHSInventoryTransactionMechanismValidationFlight::instance().isEnabled())
                {
                    this.validateInventoryTransactionMechanismOnWorkHeader(WHSInventoryTransactionMechanismEnum::InventTrans);
                }

                this.setInventTransIds();

                InventUpd_Estimated estimatedFrom = InventUpd_Estimated::newInventMovement(InventMovement::construct(this));
                estimatedFrom.updateNow();

                // The InventUpd_Estimated call above can change the InventDimIdFrom.
                InventDim inventDimFrom = InventDim::find(this.InventDimIdFrom);

                // If the location isn't specified then we don't need to reserve.
                // Reservation will occur once the location is known.
                if (inventDimFrom.wmsLocationId)
                {
                    // Undo reserve for the demand inventDimId since new reservation will be created for the WHSWorkInventTrans
                    this.updateOrderCommittedReservation(-this.InventQtyRemain);

                    this.reserveSkipOnHandCheck(estimatedFrom);
                }

                InventUpd_Estimated estimatedTo = InventUpd_Estimated::newInventMovement(InventMovement::construct(this, InventMovSubType::TransferReceipt));
                estimatedTo.updateNow();

                super();

                estimatedFrom.updateOwnerRelationship();
                estimatedTo.updateOwnerRelationship();
            }

            ttscommit;
        }
        catch (Exception::Error)
        {
            this.InventTransIdTo = '';
            this.InventTransIdFrom = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventoryTransactionMechanismOnWorkHeader</Name>
				<Source><![CDATA[
    private void validateInventoryTransactionMechanismOnWorkHeader(WHSInventoryTransactionMechanismEnum _inventoryTransactionMechanism)
    {
        if (WHSWorkTable::find(this.WorkId).InventoryTransactionMechanism != _inventoryTransactionMechanism)
        {
            throw error("@WAX:WorkInventTransTransactionMechanismNotMatchingWorkHeaderError");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>type</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>WHSWorkLineType</c> record using this record.
    /// </summary>
    /// <returns>
    /// A newly created <c>WHSWorkLineType</c> record.
    /// </returns>
    public WHSWorkLineType type()
    {
        return WHSWorkLineType::construct(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        if (!this.checkFieldsUpdated())
        {
            throw error("@WAX2939");
        }

        // do not use directly - use the lazy-loading function getInventDimFrom() instead.
        InventDim _inventDimFromCache;

        // perf optimization - allows to lazy-load (query only once and if needed) the from InventDim record.
        InventDim getInventDimFrom()
        {
            if (!_inventDimFromCache)
            {
                _inventDimFromCache = InventDim::find(this.InventDimIdFrom);
            }

            return _inventDimFromCache;
        }

        ttsbegin;

        WHSWorkBeingSplitValidator::validateWorkTableIsNotBeingSplit(this.WorkId);

        Qty qtyUpdate = this.orig().Qty - this.Qty;

        if (qtyUpdate)
        {
            this.InventQtyRemain -= qtyUpdate;

            if (this.InventQtyRemain == 0)
            {
                //When work is split the WHS transaction will be split too and the remaining quantity set to zero. The remaining weight should be zero too.
                this.RemainingTransactionWeight = 0;
            }
        }

        WHSHandlingWeight weightUpdate = this.orig().RemainingTransactionWeight - this.RemainingTransactionWeight;

        boolean wmsLocationAdded;
        if (this.InventDimIdFrom != this.orig().InventDimIdFrom)
        {
            WHSAllowNegative locAllowNeg = getInventDimFrom().wmsLocation() && getInventDimFrom().wmsLocation().whsLocationProfile().AllowNegative;
            InventTable inventTable = InventTable::find(this.ItemId);

            // If the item allows negative and so does the location then you don't need to check if qty is available.
            if ((!locAllowNeg || !inventTable.whsAllowPhysNeg())
                && this.InventQtyRemain > WHSInventOnHand::getPhysicalAvailHandlingQty(this.ItemId, getInventDimFrom(), true, true))
            {
                throw error("@WAX3372");
            }

            if (getInventDimFrom().wmsLocationId
                && !InventDim::find(this.orig().InventDimIdFrom).wmsLocationId)
            {
                wmsLocationAdded = true;
            }
        }

        if (qtyUpdate || weightUpdate ||
            this.InventDimIdFrom != this.orig().InventDimIdFrom || this.InventDimIdTo != this.orig().InventDimIdTo)
        {
            if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(this.WorkId))
            {
                // Transfer reservation back to the demand order or Undo reserve for the demand inventDimId
                if (qtyUpdate)
                {
                    this.updateOrderCommittedReservation(this.orig().InventQtyRemain - this.InventQtyRemain);
                }

                WHSInventoryTransactionSource source = WHSInventoryTransactionSource::newFromValues(
                    WHSInventoryTransactionReferenceCategoryEnum::Work,
                    this.WorkId,
                    this.InventoryTransactionOriginId);

                if (this.InventDimIdFrom != this.orig().InventDimIdFrom)
                {
                    if (!wmsLocationAdded && (this.orig().InventQtyRemain > 0 || this.orig().RemainingTransactionWeight > 0))
                    {
                        InventDim origFromInventDim = InventDim::find(this.orig().InventDimIdFrom);

                        if (origFromInventDim.wmsLocationId)
                        {
                            WHSInventoryTransactionRemoveReservationAction::construct().execute(WHSInventoryTransactionActionRemoveReservationParameters::newFromValues(
                                source,
                                this.constructInventoryItemSet(this.orig().InventQtyRemain, this.orig().RemainingTransactionWeight, origFromInventDim),
                                WHSInventoryStorageDimensions::newFromInventDim(origFromInventDim)));
                        }
                    }

                    if (getInventDimFrom().wmsLocationId && (this.InventQtyRemain > 0 || this.RemainingTransactionWeight > 0))
                    {
                        WHSInventoryTransactionCreateReservationAction::construct().execute(WHSInventoryTransactionActionCreateReservationParameters::newFromValues(
                            source,
                            this.constructInventoryItemSet(this.InventQtyRemain, this.RemainingTransactionWeight, getInventDimFrom()),
                            WHSInventoryStorageDimensions::newFromInventDim(getInventDimFrom()),
                            WHSInventoryTransactionActionValidationParameters::newCreateReservation().setCheckOnHand(WHSWorkInventTrans::mustCheckOnHandDuringReservationCreation())));
                    }

                }
                else if ((qtyUpdate > 0 || weightUpdate > 0) && getInventDimFrom().wmsLocationId)
                {
                    Debug::assert(qtyUpdate >= 0);
                    Debug::assert(weightUpdate >= 0);

                    // here we generate a new transaction and new transaction detail for the reservation quantity being reduced.
                    WHSInventoryTransactionRemoveReservationAction::construct().execute(
                        WHSInventoryTransactionActionRemoveReservationParameters::newFromValues(
                            source,
                            this.constructInventoryItemSet(abs(qtyUpdate), abs(weightUpdate), getInventDimFrom()),
                            WHSInventoryStorageDimensions::newFromInventDim(getInventDimFrom())));
                }
                else if ((qtyUpdate < 0 || weightUpdate < 0) && getInventDimFrom().wmsLocationId)
                {
                    Debug::assert(qtyUpdate <= 0);
                    Debug::assert(weightUpdate <= 0);

                    // here we generate a new transaction and new transaction detail for the extra qty being reserved.
                    WHSInventoryTransactionCreateReservationAction::construct().execute(
                        WHSInventoryTransactionActionCreateReservationParameters::newFromValues(
                            source,
                            this.constructInventoryItemSet(abs(qtyUpdate), abs(weightUpdate), getInventDimFrom()),
                            WHSInventoryStorageDimensions::newFromInventDim(getInventDimFrom()),
                            WHSInventoryTransactionActionValidationParameters::newCreateReservation().setCheckOnHand(WHSWorkInventTrans::mustCheckOnHandDuringReservationCreation())));
                }
            }
            else
            {
                InventUpd_Estimated estimatedFrom = InventUpd_Estimated::newInventMovement(InventMovement::construct(this));
                estimatedFrom.updateNow();

                // Transfer reservation back to the demand order or Undo reserve for the demand inventDimId
                if (qtyUpdate)
                {
                    this.updateOrderCommittedReservation(this.orig().InventQtyRemain - this.InventQtyRemain);
                }

                if (qtyUpdate < 0 || weightUpdate < 0 || wmsLocationAdded)
                {
                    // If location was blank before but has now been added then we need to reserve the full amount of the work invent trans.
                    if (wmsLocationAdded)
                    {
                        InventQty       reserveQty;
                        PdsCWInventQty  reserveCWQty;

                        if (!PdsGlobal::pdsIsCWItem(this.ItemId))
                        {
                            reserveQty      = -this.Qty;
                            reserveCWQty    = 0;
                        }
                        else
                        {
                            reserveQty      = -this.RemainingTransactionWeight;
                            reserveCWQty    = -this.Qty;
                        }

                        estimatedFrom.reserveQuantities(reserveQty, reserveCWQty, false);
                    }
                    else
                    {
                        estimatedFrom.reserveEstimatedQuantities();
                    }
                }

                InventUpd_Estimated estimatedTo = InventUpd_Estimated::newInventMovement(InventMovement::construct(this, InventMovSubType::TransferReceipt));
                estimatedTo.updateNow();
            }
        }

        super();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a specific <c>whsWorkInventTrans</c> record exists.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the record.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the record.
    /// </param>
    /// <param name="_itemId">
    /// Item number of the record.
    /// </param>
    /// <param name="_inventTransIdParent">
    /// Parent transaction id of the record.
    /// </param>
    /// <param name="_dimIdFrom">
    /// Dimension id of the removing transaction.
    /// </param>
    /// <returns>
    /// True if the record exists.
    /// </returns>
    public static boolean exist(WHSWorkId           _workId,
                                LineNum             _lineNum,
                                ItemId              _itemId,
                                InventTransId       _inventTransIdParent,
                                WHSInventDimIdFrom  _dimIdFrom)
    {
        return (_workId && _lineNum && _itemId && _inventTransIdParent && _dimIdFrom) &&
               (select firstonly RecId from whsWorkInventTrans
                where whsWorkInventTrans.WorkId                 == _workId                  &&
                      whsWorkInventTrans.LineNum                == _lineNum                 &&
                      whsWorkInventTrans.ItemId                 == _itemId                  &&
                      whsWorkInventTrans.InventTransIdParent    == _inventTransIdParent     &&
                      whsWorkInventTrans.InventDimIdFrom        == _dimIdFrom).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific <c>WHSWorkInventTrans</c> record with given parameters.
    /// </summary>
    /// <param name="_workId">
    /// Work id of the record.
    /// </param>
    /// <param name="_lineNum">
    /// Line number of the record.
    /// </param>
    /// <param name="_itemId">
    /// Item number of the record.
    /// </param>
    /// <param name="_inventTransIdParent">
    /// Parent transaction id of the record.
    /// </param>
    /// <param name="_dimIdFrom">
    /// Dimension id of the removing transaction.
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    public static WHSWorkInventTrans find(WHSWorkId             _workId,
                                          LineNum               _lineNum,
                                          ItemId                _itemId,
                                          InventTransId         _inventTransIdParent,
                                          WHSInventDimIdFrom    _dimIdFrom,
                                          boolean               _forupdate = false)
    {
        WHSWorkInventTrans    workInventTrans;

        if (_workId                 &&
            _lineNum                &&
            _itemId                 &&
            _dimIdFrom)
        {
            workInventTrans.selectForUpdate(_forupdate);

            select firstonly workInventTrans
                where workInventTrans.WorkId                == _workId              &&
                      workInventTrans.LineNum               == _lineNum             &&
                      workInventTrans.ItemId                == _itemId              &&
                      workInventTrans.InventTransIdParent   == _inventTransIdParent &&
                      workInventTrans.InventDimIdFrom       == _dimIdFrom;
        }

        return workInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId</Name>
				<Source><![CDATA[
    public static WHSWorkInventTrans findByRecId(RecId _recId,
                                                 boolean _forUpdate = false)
    {
        WHSWorkInventTrans workInventTrans;

        if (_recId)
        {
            workInventTrans.selectForUpdate(_forUpdate);

            select firstonly workInventTrans
                where workInventTrans.RecId == _recId;
        }

        return workInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findbyWorkIdLineNumItemIdTransIdParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds all WIT's associated to a workLine/parent inventTrans.
    /// </summary>
    /// <param name="_workId">
    /// The work ID.
    /// </param>
    /// <param name="_lineNum">
    /// The line number of the work.
    /// </param>
    /// <param name="_itemId">
    /// Item number of the record.
    /// </param>
    /// <param name="_inventTransIdParent">
    /// The parent invent trans ID.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// All WIT's associated to a workLine/parent inventTrans.
    /// </returns>
    public static WHSWorkInventTrans findbyWorkIdLineNumItemIdTransIdParent(WHSWorkId       _workId,
                                                                            LineNum         _lineNum,
                                                                            ItemId          _itemId,
                                                                            InventTransId   _inventTransIdParent,
                                                                            boolean         _forupdate = false)
    {
        WHSWorkInventTrans    workInventTrans;

        if (_workId             &&
            _lineNum)
        {
            workInventTrans.selectForUpdate(_forupdate);

            select workInventTrans
                where workInventTrans.WorkId    ==          _workId     &&
                      workInventTrans.LineNum   ==          _lineNum    &&
                      workInventTrans.ItemId    ==          _itemId     &&
                      workInventTrans.InventTransIdParent == _inventTransIdParent;
        }

        return workInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByInventoryTransactionOriginId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static WHSWorkInventTrans findByInventoryTransactionOriginId(WHSInventoryTransactionOriginId _transactionOriginId, boolean _forupdate = false)
    {
        WHSWorkInventTrans workInventTrans;

        if (_transactionOriginId != emptyGuid())
        {
            workInventTrans.selectForUpdate(_forupdate);

            select firstonly workInventTrans
                where workInventTrans.InventoryTransactionOriginId == _transactionOriginId;
        }

        return workInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveToNewWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Moves all <c>WHSWorkInventTrans</c> records associated with a work line to a new work line.
    /// </summary>
    /// <param name="_currentWorkId">
    ///    The Work ID the <c>WHSWorkInventTrans</c> records are currently associated with.
    /// </param>
    /// <param name="_currentLineNum">
    ///    The line number the <c>WHSWorkInventTrans</c> records are currently associated with.
    /// </param>
    /// <param name="_newWorkId">
    ///    The new Work ID the <c>WHSWorkInventTrans</c> records must be associated with.
    /// </param>
    /// <param name="_newLineNum">
    ///    The new line number the <c>WHSWorkInventTrans</c> records must be associated with.
    /// </param>
    /// <remarks>
    ///    If the <c>WHSWorkInventTrans</c> are moved across work, then the reference on <c>InventTransOrigin</c> is also updated.
    /// </remarks>
    public static void moveToNewWorkLine(
        WHSWorkId   _currentWorkId,
        LineNum     _currentLineNum,
        WHSWorkId   _newWorkId,
        LineNum     _newLineNum
    )
    {
        WHSWorkInventTrans workInventTrans;

        if (!_currentWorkId || !_newWorkId)
        {
            return;
        }

        ttsbegin;

        if (_currentWorkId != _newWorkId)
        {
            if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_currentWorkId))
            {
                WHSInventoryTransaction inventoryTransaction;

                inventoryTransaction.skipDataMethods(true);
                inventoryTransaction.skipEvents(true);

                update_recordset inventoryTransaction
                    setting ReferenceId = _newWorkId
                    exists join workInventTrans
                    where  workInventTrans.WorkId   == _currentWorkId
                        && workInventTrans.LineNum  == _currentLineNum
                        && workInventTrans.InventoryTransactionOriginId == inventoryTransaction.InventoryTransactionOriginId;
            }
            else
            {
                InventTransOrigin inventTransOrigin;

                // Split combined update statement into two seperate updates due to locking problems with
                // the combined statement.  Do not merge.
                update_recordset inventTransOrigin
                    setting ReferenceId = _newWorkId
                    exists join workInventTrans
                    where workInventTrans.WorkId    == _currentWorkId
                        && workInventTrans.LineNum  == _currentLineNum
                        && workInventTrans.InventTransIdFrom == inventTransOrigin.InventTransId;

                update_recordset inventTransOrigin
                    setting ReferenceId = _newWorkId
                    exists join workInventTrans
                    where workInventTrans.WorkId    == _currentWorkId
                        && workInventTrans.LineNum  == _currentLineNum
                        && workInventTrans.InventTransIdTo == inventTransOrigin.InventTransId;
            }
        }

        workInventTrans.skipDataMethods(true);

        update_recordset workInventTrans
            setting WorkId  = _newWorkId,
                    LineNum = _newLineNum
            where workInventTrans.WorkId    == _currentWorkId
               && workInventTrans.LineNum   == _currentLineNum;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Adjusts the quantity of the current work inventory transaction record.
    /// </summary>
    /// <param name="_inventQtyToAdjust">
    ///    The inventory quantity to adjust.
    /// </param>
    /// <param name="_toLocationId">
    ///    The location ID to be set on the to inventDim record, if there will be not any quantity remaining.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the adjustHandlingQuantity method. Please file an extensibility request if other access is required.', false, 30\9\2019)]
    public void adjustQuantity(Qty _inventQtyToAdjust, WMSLocationId _toLocationId)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), this.ItemId);
    
        this.adjustQuantities(_inventQtyToAdjust, _toLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustHandlingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the handling quantity of the current work inventory transaction record.
    /// </summary>
    /// <param name="_qtyToAdjust">
    /// The handling quantity to adjust.
    /// </param>
    /// <param name="_toLocationId">
    /// The location ID to be set on the to inventDim record, if there will be not any quantity remaining.
    /// </param>
    [Hookable(false)]
    final public void adjustHandlingQuantity(InventHandlingQty _qtyToAdjust, WMSLocationId _toLocationId)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), this.ItemId))
        {
            this.adjustQuantity(_qtyToAdjust, _toLocationId);
        }
        else
        {
            this.adjustQuantities(_qtyToAdjust, _toLocationId);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustQuantities</Name>
				<Source><![CDATA[
    private void adjustQuantities(InventHandlingQty _qtyToAdjust, WMSLocationId _toLocationId)
    {
        ttsbegin;

        this.Qty += _qtyToAdjust;

        WHSHandlingWeight diffWeight = WhsInvent::defaultCatchWeightReserveQuantity(this.ItemId, _qtyToAdjust);

        this.TransactionWeight          += diffWeight;
        this.RemainingTransactionWeight += diffWeight;

        this.update();

        if (this.Qty == 0)
        {
            this.delete();
        }
        else if (!this.InventQtyRemain)
        {
            // Update to inventDim on workInventTrans if workLine is complete.
            InventDim toInventDim = InventDim::find(this.InventDimIdTo);

            if (!toInventDim.wmsLocationId)
            {
                toInventDim.wmsLocationId = _toLocationId;
                toInventDim = InventDim::findOrCreate(toInventDim);
                this.InventDimIdTo = toInventDim.InventDimId;
                this.doUpdate();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    [Hookable(false)]
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckOnHandDuringReservationCreation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    private static boolean mustCheckOnHandDuringReservationCreation()
    {
        var context = WHSWorkCreateReservationContext::current();
        return context && context.isEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrderCommittedReservation</Name>
				<Source><![CDATA[
    private void updateOrderCommittedReservation(InventQty  _qtyToAdd)
    {
        // to be on the safe side (if there is no reservation on the workInventTrans then no reservation should be set back also)
        if (this.WorkHasReservation)
        {
            WHSWorkLine workLine = WHSWorkLine::find(this.WorkId, this.LineNum);

            WHSOrderCommittedReservationFacade::updateOrderCommittedReservation(
                workLine.InventTransId,
                workLine.OrderCommittedInventDimId,
                _qtyToAdd);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logReservationOnSpecificDimensions</Name>
				<Source><![CDATA[
    private void logReservationOnSpecificDimensions(MethodName _callingMethod, RecId _fromSpecificInventDimRecId, RecId _fromInventDimRecId)
    {
        SysInstrumentationEventDataJsonSerializer serializer = new SysInstrumentationEventDataJsonSerializer();

        serializer.setValue(tableStr(WHSWorkInventTrans), _callingMethod);
        serializer.setValue('fromSpecificInventDim.RecId', int642Str(_fromSpecificInventDimRecId));
        serializer.setValue('fromInventDimRecId.RecId', int642Str(_fromInventDimRecId));
        serializer.setValue('CallStack', WHSInstrumentationLogger::currentStackTrace());
 
        Microsoft.Dynamics.ApplicationPlatform.XppServices.Instrumentation.XppRuntimeEventSource::EventWriteInfoLogMark(Exception::Info, serializer.toString());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransCreatedForInventTransOrigin</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean isInventTransCreatedForInventTransOrigin()
    {
        InventTransOrigin inventTransOriginTo;
        InventTrans inventTrans;

        select firstonly RecId from inventTransOriginTo
            where inventTransOriginTo.InventTransId == this.InventTransIdTo
            exists join inventTrans
                where inventTrans.InventTransOrigin == inventTransOriginTo.RecId;

        return inventTransOriginTo.RecId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>WHSandTMS</ConfigurationKey>
	<DeveloperDocumentation>@WAX4497</DeveloperDocumentation>
	<Label>@WAX425</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>WorkId</TitleField1>
	<TitleField2>LineNum</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>FoundAndEmpty</CacheLookup>
	<ClusteredIndex>Recid</ClusteredIndex>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Inventory</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<ReplacementKey>WorkIdLineNumTransIdParentDimIdIdx</ReplacementKey>
	<TableContents>DefaultData</TableContents>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransIdFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransIdTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimIdFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimIdTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransIdParent</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventQtyRemain</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkHasReservation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransIdParent</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimIdFrom</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@WAX2277</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransIdFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransIdTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimIdFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimIdTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransIdParent</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventQtyRemain</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkHasReservation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimIdFrom</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSInventDimIdFrom</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimIdTo</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSInventDimIdTo</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>InventQtyRemain</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventQtyRemain</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransIdFrom</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSInventTransIdFrom</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldGuid">
			<Name>InventoryTransactionOriginId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>WHSInventoryTransactionOriginId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldGuid">
			<Name>ItemSetId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>WHSInventoryItemSetId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransIdParent</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>OII</AssetClassification>
			<ExtendedDataType>InventTransId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransIdTo</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSInventTransIdTo</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LineNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LineNum</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Qty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProductQuantity</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>TransDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDateTime</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkHasReservation</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkHasReservation</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TransactionWeight</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSTransWeight</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>RemainingTransactionWeight</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSTransWeightRemain</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InventTransOriginIdSupply</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransOriginIdMarked</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>WorkIdLineNumTransIdParentDimIdIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransIdParent</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimIdFrom</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WorkIdInventTransIdFrom</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransIdFrom</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WorkIdInventTransIdTo</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransIdTo</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventTransIdParentWorkHasReservationIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransIdParent</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkHasReservation</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventoryTransactionOriginIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventoryTransactionOriginId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDimFrom</Name>
			<Cardinality>OneMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>DimFrom</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimIdFrom</Name>
					<SourceEDT>WHSInventDimIdFrom</SourceEDT>
					<Field>InventDimIdFrom</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDimTo</Name>
			<Cardinality>OneMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>DimTo</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimIdTo</Name>
					<SourceEDT>WHSInventDimIdTo</SourceEDT>
					<Field>InventDimIdTo</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>OneMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<SourceEDT>ItemId</SourceEDT>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ItemIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOriginFrom</Name>
			<Cardinality>ZeroOne</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>TransFrom</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransIdFrom</Name>
					<SourceEDT>WHSInventTransIdFrom</SourceEDT>
					<Field>InventTransIdFrom</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventTransIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOriginParent</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>TransParent</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransIdParent</Name>
					<SourceEDT>InventTransId</SourceEDT>
					<Field>InventTransIdParent</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventTransIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOriginTo</Name>
			<Cardinality>ZeroOne</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>TransTo</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransIdTo</Name>
					<SourceEDT>WHSInventTransIdTo</SourceEDT>
					<Field>InventTransIdTo</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventTransIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWorkLine</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LineNum</Name>
					<SourceEDT>WHSLineNum</SourceEDT>
					<Field>LineNum</Field>
					<RelatedField>LineNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkId</Name>
					<SourceEDT>WHSWorkId</SourceEDT>
					<Field>WorkId</Field>
					<RelatedField>WorkId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkTable</Name>
			<Cardinality>OneMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>WHSWorkTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkId</Name>
					<SourceEDT>WHSWorkId</SourceEDT>
					<Field>WorkId</Field>
					<RelatedField>WorkId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTransOriginIdSupply</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransOriginIdSupply</Name>
					<Field>InventTransOriginIdSupply</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>