<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailGiftCardTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class RetailGiftCardTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>balance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total amount of the gift card transactions for the current gift card.
    /// </summary>
    /// <returns>
    /// The sum of the gift card amount.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// An insufficient rights exception.
    /// </exception>
    public display RetailBalance balance()
    {
        if (!hasFieldAccess(tablenum(RetailGiftCardTransactions), fieldnum(RetailGiftCardTransactions, Amount)))
        {
            throw error("@SYS57330");
        }

        // Process any offline transactional data as it might affect the balance.
        if (this.reserved == NoYes::Yes)
        {
            this.tryReleaseCardLock();
        }

        // Compute and return the balance for the gift card.
        return RetailGiftCardTransactions::calcBalance(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>issueAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the issue amount of the gift card transactions for the current gift card.
    /// </summary>
    /// <returns>
    /// The sum of the gift card amount.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// An insufficient rights exception.
    /// </exception>
    public display RetailBalance issueAmount()
    {
        if (!hasFieldAccess(tablenum(RetailGiftCardTransactions), fieldnum(RetailGiftCardTransactions, Amount)))
        {
            throw error("@SYS57330");
        }

        // Process any offline transactional data as it might affect the balance.
        if (this.reserved == NoYes::Yes)
        {
            this.tryReleaseCardLock();
        }

        // Compute and return the issue amount for the gift card.
        return RetailGiftCardTransactions::calcIssueAmount(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the gift card transactions for the deletion of gift card table are valid.
    /// </summary>
    /// <returns>
    /// true if the gift card can be deleted; otherwise, false.
    /// </returns>
    boolean canDelete()
    {
        RetailGiftCardTransactions giftCardTransactions;
        boolean result = false;

        select count(RecId) from giftCardTransactions
            where giftCardTransactions.cardNumber == this.entryId;

        // Delete only if has one issue type with including other type transaction aswell
        if (giftCardTransactions.RecId >= 1)
            result = true;

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAmountOutstanding</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the gift card transactions for the deletion of gift card having money outstanding or not.
    /// </summary>
    /// <returns>
    /// true if the gift card can be deleted; otherwise, false.
    /// </returns>
    internal boolean isAmountOutstanding()
    {
        RetailGiftCardTransactions giftCardTransactions;
        RetailGiftCardTable giftCardTable;

        select sum(amount) from giftCardTransactions
            where giftCardTransactions.cardNumber == this.entryId;

        // Delete only if has not any outstanding balance.
        return giftCardTransactions.amount == 0 && this.reserved == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the reserve options for the gift card.
    /// </summary>
    /// <param name="_redeemed">
    /// One-time gift card was redeemed
    /// </param>
    [SysObsolete('Please use unlockCard instead.', true, 30\06\2018)]
    public void releaseCard(boolean _redeemed = false)
    {
        this.unlockCard(_redeemed, RetailGiftCardOperation::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unlocks a gift card.
    /// </summary>
    /// <param name="_expireOnUnlock">
    /// Sets the card as expired after unlocking.
    /// </param>
    /// <param name=_operationType">
    /// The gift card operation type.
    /// </param>
    public void unlockCard(boolean _expireOnUnlock = false, RetailGiftCardOperation _operationType = RetailGiftCardOperation::None)
    {
        // We validate that the gift card is unlocked for only supported operations.
        if (_operationType == RetailGiftCardOperation::None ||
            _operationType == RetailGiftCardOperation::ManualUnlock ||
            _operationType == RetailGiftCardOperation::OfflineUnlock)
        {
            // If the card has not been reserved, we have nothing to do.
            if (this.reserved == NoYes::No)
            {
                return;
            }

            ttsbegin;
            this.reserved                   = NoYes::No;
            this.reservedByTerminalId       = '';
            this.reservedByChannel          = 0;
            this.ReservedByTransactionId    = '';

            if (_expireOnUnlock)
            {
                this.Status = RetailGiftCardStatus::Expired;
            }

            if (_operationType == RetailGiftCardOperation::ManualUnlock || _operationType == RetailGiftCardOperation::OfflineUnlock)
            {
                RetailGiftCardTransactions::add(
                    _operationType,
                    this.entryId,
                    0,
                    '',
                    '',
                    '',
                    '',
                    0,
                    DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                    DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone()));
            }

            this.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>renamePrimaryKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Renames the record.
    /// </summary>
    /// <remarks>
    /// A prompt for renaming of the record.
    /// </remarks>
    public void renamePrimaryKey()
    {
        ;
        RetailConnActionManagement::errorOnRename(this);

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the reserve options for the gift card.
    /// </summary>
    /// <param name="_terminalId">
    /// The ID number of POS terminal.
    /// </param>
    /// <param name="_channelId">
    /// The channel id.
    /// </param>
    /// <param name="_transactionId">
    /// The transaction id.
    /// </param>
    /// <remarks>
    /// This method will throw in case it is unable to reserve the card.
    /// </remarks>
    public void reserveCard(RetailTerminalId _terminalId = '', RetailChannelRecId _channelId = 0, RetailTransactionId _transactionId = '')
    {
        // A gift card can be in 1 of 3 states.
        // 1 -> Unlocked.
        // 2 -> Locked by a transaction that completed in offline mode.
        // 3 -> Locked by an ongoing transaction.

        // Check to see if the gift is reserved by another transaction.
        if (this.reserved == NoYes::Yes &&
                (this.reservedByTerminalId != _terminalId || this.reservedByChannel != _channelId || this.ReservedByTransactionId != _transactionId))
        {
            // Since the gift card is reserved by another transaction. We attempt to unlock the gift card.
            this.tryReleaseCardLock();

            // If the lock has still not been released, then it is part of an ongoing transaction.
            if (this.reserved == NoYes::Yes)
            {
                throw Global::error(strfmt("@Retail:RetailGiftCardWithIdIsAlreadyReserved", this.entryId));
            }
        }

        // If the gift card is not reserved, reserve the card.
        if (this.reserved != NoYes::Yes)
        {
            ttsbegin;
            this.reserved                = NoYes::Yes;
            this.reservedByTerminalId    = _terminalId;
            this.reservedByChannel       = _channelId;
            this.ReservedByTransactionId = _transactionId;
            this.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReplicationCounter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the replication counter for the gift card.
    /// </summary>
    void setReplicationCounter()
    {
        if (!this.replicationCounter)
        {
            this.replicationCounter = (select maxof(replicationCounter) from RetailGiftCardTable).replicationCounter + 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the record can be deleted.
    /// </summary>
    /// <returns>
    /// true if the record can be deleted; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Issued gift cards with transactions cannot be deleted.
    /// </remarks>
    public boolean validateDelete()
    {
        boolean ret = super();

        if (ret)
        {
            ret = this.canDelete();
            if (!ret)
            {
                warning("@RET5063");
            }
            else
            {
                ret = this.isAmountOutstanding();
                if(!ret)
                {
                    warning("@Retail:RetailCanNotDeleteGiftWithOutstandingBalance");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the gift card is eligible for delete.
    /// </summary>
    /// <returns>
    /// true if the gift card is eligible for delete; otherwise, false.
    /// </returns>
    public boolean voidCard()
    {
        // Voiding of a card, deletes it from database so that plastic card can be reuesd.
        boolean result = false;

        if (this.canDelete())
        {
            this.delete();
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a gift card with the specified gift card number.
    /// </summary>
    /// <param name="_entryId">
    /// The ID number of the gift card to be created.
    /// </param>
    /// <param name="_currencyCode">
    /// The current currency code
    /// </param>
    /// <param name="mcrGiftcardType">
    /// The mcr gift card type
    /// </param>
    /// <param name="_channelDateTime">
    /// Channel date and time.
    /// </param>
    /// <param name="_channelTimeZone">
    /// Channel time zone.
    /// </param>
    /// <returns>
    /// A <c>RetailGiftCardTable</c> record.
    /// </returns>
    public static RetailGiftCardTable createCard(RetailGiftCardId _entryId,
                                                 CurrencyCode     _currencyCode,
                                                 MCRGiftCardType  mcrGiftcardType     = MCRGiftCardType::Email,
                                                 utcDateTime      _channelDateTime    = DateTimeUtil::utcNow(),
                                                 Timezone         _channelTimeZone    = 0)
    {
        RetailGiftCardTable tGiftCardTable;
        
        // Check if there is an existing gift card which was voided in offline mode and has not been deleted yet.
        RetailGiftCardTable offlineVoidedGiftCard = RetailGiftCardTable::find(_entryId);
        if (offlineVoidedGiftCard && offlineVoidedGiftCard.reserved == NoYes::Yes)
        {
            offlineVoidedGiftCard.tryReleaseCardLock();
        }

        if (_entryId && (!RetailGiftCardTable::find(_entryId)))
        {
            // Create the new gift card.
            tGiftCardTable.entryId                  = _entryId;
            tGiftCardTable.currencyCode             = _currencyCode;
            tGiftCardTable.MCRGiftCardType          = mcrGiftcardType;

            if (RetailParameters::find().UseGiftCardPolicies)
            {
                tGiftCardTable.initGiftCardPolicies(_entryId, _channelDateTime, _channelTimeZone);
            }

            tGiftCardTable.insert();
        }

        return tGiftCardTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified record in the <c>RetailGiftCardTable</c> table exists.
    /// </summary>
    /// <param name="_dataEntryId">
    /// The gift card number.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean exist(RetailGiftCardId _dataEntryId)
    {
        if (_dataEntryId)
        {
            return (select firstonly recId from RetailGiftCardTable
                        where RetailGiftCardTable.entryId == _dataEntryId
                       ).recId != 0;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>RetailGiftCardTable</c> table.
    /// </summary>
    /// <param name="_dataEntryId">
    /// The ID number of the gift card in the table.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>RetailGiftCardTable</c> table; otherwise, an empty record.
    /// </returns>
    public static RetailGiftCardTable find(RetailGiftCardId _dataEntryId, boolean _forUpdate = false)
    {
        RetailGiftCardTable tGiftCardTable;
        ;
        if (_dataEntryId)
        {
            tGiftCardTable.selectForUpdate(_forUpdate);

            select firstonly tGiftCardTable
                where tGiftCardTable.entryId == _dataEntryId;
        }

        return tGiftCardTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCrossCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>RetailGiftCardTable</c> table.
    /// </summary>
    /// <param name="_dataEntryId">
    /// The ID number of the gift card in the table.
    /// </param>
    /// <param name="_conCompanies">
    /// A container of campanies to search.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>RetailGiftCardTable</c> table; otherwise, an empty record.
    /// </returns>
    public static RetailGiftCardTable findCrossCompany(RetailGiftCardId _dataEntryId, container _conCompanies, boolean _forUpdate = false)
    {
        RetailGiftCardTable tGiftCardTable;
        container conCompanies = _conCompanies;
        ;
        if (_dataEntryId)
        {
            tGiftCardTable.selectForUpdate(_forUpdate);

            select firstonly crossCompany :conCompanies tGiftCardTable
                where tGiftCardTable.entryId == _dataEntryId;
        }

        return tGiftCardTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>RetailGiftCardTable</c> table.
    /// </summary>
    /// <param name="_recId">
    /// The RecID of the gift card in the table.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>RetailGiftCardTable</c> table; otherwise, an empty record.
    /// </returns>
    public static RetailGiftCardTable mcrFindRecId(RecId _recId,
                                                 boolean _forUpdate = false)
    {
        RetailGiftCardTable retailGiftCardTable;

        if (_recId)
        {
            retailGiftCardTable.selectForUpdate(_forUpdate);

            select firstonly crossCompany retailGiftCardTable
                where retailGiftCardTable.RecId == _recId;
        }

        return retailGiftCardTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks policy conditions for operations of gift card.
    /// </summary>
    /// <param name="_retailGiftCardOperation">
    /// Gift card operation.
    /// </param>
    /// <param name="_transactionAmount">
    /// Tarnsaction amount of operation; optional.
    /// </param>
    /// <param name="_showErrors">
    /// Boolean flag used to determine whether to show error messages; optional.
    /// </param>
    /// <returns>
    /// true if an opertion is allowed by policies; otherwise, false.
    /// </returns>
    public boolean checkPolicy(RetailGiftCardOperation _retailGiftCardOperation, AmountCur _transactionAmount = 0, boolean _showErrors = true)
    {
        RetailGiftCardPolicyChecker retailGiftCardPolicyChecker;

        if (prmisDefault(_transactionAmount))
        {
            retailGiftCardPolicyChecker = RetailGiftCardPolicyChecker::construct(_retailGiftCardOperation, this);
        }
        else
        {
            retailGiftCardPolicyChecker = RetailGiftCardPolicyChecker::construct(_retailGiftCardOperation, this, _transactionAmount);
        }
        retailGiftCardPolicyChecker.parmShowErrors(_showErrors);

        return retailGiftCardPolicyChecker.check();
    }

]]></Source>
			</Method>
			<Method>
				<Name>faceValueCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a staring balance of the gift card in the gift card the transaction currency.
    /// </summary>
    /// <param name="_transDate">
    /// Transaction date; optional.
    /// </param>
    /// <returns>
    /// A staring balance of the gift card in the transaction currency.
    /// </returns>
    public display AmountCur faceValueCur(TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return CurrencyExchangeHelper::curAmount2CurAmount(this.FaceValue, this.giftCardCompanyCurrencyCode(), this.currencyCode, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtendedStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows extended status of the gift card
    /// </summary>
    /// <returns>
    /// Current extended status of the gift card.
    /// </returns>
    public display RetailGiftCardStatusExtended getExtendedStatus()
    {
        RetailGiftCardStatusExtended result;
        if (!this.RecId)
        {
            result = RetailGiftCardStatusExtended::NotIssued;
        }
        else
        {
            switch (this.Status)
            {
                case RetailGiftCardStatus::Closed:
                    result = RetailGiftCardStatusExtended::Closed;
                    break;
                case RetailGiftCardStatus::Expired:
                    if (this.ExpiryDate && this.ExpiryDate < DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()))
                    {
                        result = RetailGiftCardStatusExtended::Expired;
                    }
                    else
                    {
                        result = RetailGiftCardStatusExtended::Redeemed;
                    }
                    break;
                default:
                    if (this.ActiveFrom && this.ActiveFrom > DateTimeUtil::utcNow())
                    {
                        result = RetailGiftCardStatusExtended::NotActivated;
                    }
                    else if (this.ExpiryDate && this.ExpiryDate < DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()))
                    {
                        result = RetailGiftCardStatusExtended::Expired;
                    }
                    else
                    {
                        result = RetailGiftCardStatusExtended::Active;
                    }
                    break;
            }
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>giftCardCompanyCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get an accounting currency code of company that manages gift cards.
    /// </summary>
    /// <returns>
    /// An accounting currency code of company that manages gift cards.
    /// </returns>
    /// <remarks>
    /// Gift policies amounts (FaceValue, MaxBalanceMST, MinReloadMST) are saved in this currency.
    /// </remarks>
    public display CurrencyCode giftCardCompanyCurrencyCode()
    {
        return Ledger::accountingCurrency(CompanyInfo::findDataArea(this.company()).RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initGiftCardPolicies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes gift card policies.
    /// </summary>
    /// <param name="_cardNumber">
    /// The gift card number.
    /// </param>
    /// <param name="_channelDateTime">
    /// Channel date and time.
    /// </param>
    /// <param name="_channelTimeZone">
    /// Channel time zone.
    /// </param>
    public void initGiftCardPolicies(RetailGiftCardId   _cardNumber,
                                     utcDateTime        _channelDateTime,
                                     Timezone           _channelTimeZone)
    {
        #TimeConstants

        RetailGiftCardPolicySet policySet;

        policySet = RetailGiftCardPolicySet::findOrCreateDefaultByGiftCardNumber(_cardNumber);

        // Gift card Active from date and time is stored as UTC date time
        this.ActiveFrom = DateTimeUtil::addSeconds(DateTimeUtil::removeTimeZoneOffset(_channelDateTime, _channelTimeZone), any2int64(policySet.ActivationPeriod * #secondsPerHour));

        if (policySet.FixedExpiryDate || policySet.ValidityPeriod)
        {
            this.ExpiryDate = policySet.FixedExpiryDate ?
                policySet.FixedExpiryDate :
                // Gift card Expiry date is calculated based on local channel date, not UTC date
                DateTimeUtil::date(_channelDateTime) + policySet.ValidityPeriod;
        }

        this.FaceValue          = policySet.FaceValue;
        this.Status             = RetailGiftCardStatus::Active;
        this.OneTimeRedemption  = policySet.OneTimeRedemption;
        this.NonReloadable      = policySet.NonReloadable;
        this.MinReloadMST       = policySet.MinReloadMST;
        this.MaxBalanceMST      = policySet.MaxBalanceMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxBalanceCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a maximum balance limit in the gift card transaction currency.
    /// </summary>
    /// <param name="_transDate">
    /// Transaction date; optional.
    /// </param>
    /// <returns>
    /// Maximum balance limit in transaction currency.
    /// </returns>
    public display RetailGiftCardMaxBalanceMST maxBalanceCur(TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return CurrencyExchangeHelper::curAmount2CurAmount(this.MaxBalanceMST, this.giftCardCompanyCurrencyCode(), this.currencyCode, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>minReloadCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a minimum reload amount in the gift card transaction currency.
    /// </summary>
    /// <param name="_transDate">
    /// Transaction date; optional.
    /// </param>
    /// <returns>
    /// Minimum reload amount in transaction currency.
    /// </returns>
    public display RetailGiftCardMinReloadMST minReloadCur(TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return CurrencyExchangeHelper::curAmount2CurAmount(this.MinReloadMST, this.giftCardCompanyCurrencyCode(), this.currencyCode, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>policyDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows policy of current gift card.
    /// </summary>
    /// <returns>
    /// Multiline string that descibes policy of current gift card.
    /// </returns>
    public RetailGiftCardPolicies policyDescription()
    {
        str result;
        TableId tableId = this.TableId;
        SysDictTable dictTable;
        SysDictFieldGroup dictFieldGroup;
        SysDictField sysDictField;
        SysDictMethod sysDictMethod;
        int i, j;
        SysDictEnum sysDictEnum;
        SysDictType sysDictType;
        FieldGroupName fieldGroupName = tableFieldgroupStr(RetailGiftCardTable, GiftCardPolicy);

        str getLine(FieldId _fieldId)
        {
            anytype value;
            LabelString label;

            sysDictField = new SysDictField(dictFieldGroup.tableid(), _fieldId);
            if (sysDictField)
            {
                value = this.(_fieldId);
                label = sysDictField.label();
            }
            else
            {
                sysDictMethod  = new SysDictMethod(UtilElementType::TableInstanceMethod, dictFieldGroup.tableid(), dictFieldGroup.methodName(_fieldId));
                if (sysDictMethod.returnType() == Types::Enum)
                {
                    sysDictEnum = new SysDictEnum(sysDictMethod.returnId());
                    if (sysDictEnum)
                    {
                        label = sysDictEnum.label();
                    }
                }
                else
                {
                    sysDictType = new SysDictType(sysDictMethod.returnId());
                    if (sysDictType)
                    {
                        label = sysDictType.label();
                    }
                }
                new ExecutePermission().assert();
                value = dictTable.callObject(sysDictMethod.name(), this);
                CodeAccessPermission::revertAssert();
            }

            return strFmt("%1 : %2", label , value);
        }

        dictTable = SysDictTable::newTableId(tableId);

        for (i=1; i <= dictTable.fieldGroupCnt(); i++)
        {
            if (dictTable.fieldGroup(i) == fieldGroupName)
            {
                dictFieldGroup = new SysDictFieldGroup(dictTable.id(), dictTable.fieldGroup(i));
                for (j=1; j <= dictFieldGroup.numberOfFields(); j++)
                {
                    if (result)
                    {
                        result += '\n';
                    }
                    result += getLine(dictFieldGroup.field(j));
                }
                break;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryReleaseCardLock</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tries to release the lock on the gift card by searching for offline transaction data.
    /// </summary>
    public void tryReleaseCardLock()
    {
        boolean isLockReleased = false;
        RetailGiftCardChannelTransactions giftCardChannelTxns;
        
        if (this.reserved == NoYes::Yes)
        {
            ttsbegin;

            // After issue gift card -> Expect only 1 record for unlock.
            // After void issue gift card -> Expect only 1 record for void issue.
            // After add to gift card -> Expect only 1 record for unlock.
            // After void add to gift card -> Expect 2 records.
            // 1 for 'add to' because 'void add to' is actually 'add to' with negative balance. 1 for unlock.
            // After redeem or Refund to gift card -> Expect 1 record for redeem or refund.
            // After void redeem or void refund -> Expect only 1 record for unlock.
            while select giftCardChannelTxns
                order by giftCardChannelTxns.transDate, giftCardChannelTxns.transTime
                where giftCardChannelTxns.cardNumber == this.entryId &&
                giftCardChannelTxns.transactionId == this.ReservedByTransactionId
            {
                switch (giftCardChannelTxns.operation)
                {
                    case RetailGiftCardOperation::Redeem:
                        // Move the transaction from channel side table to AX side table, if missing.
                        RetailGiftCardTransactions::findOrCreate(giftCardChannelTxns, false);

                        // Unlock the gift card.
                        this.unlockCard(this.OneTimeRedemption, RetailGiftCardOperation::OfflineUnlock);
                        isLockReleased = true;
                        break;
                    case RetailGiftCardOperation::Refund:
                        // Move the transaction from channel side table to AX side table, if missing.
                        RetailGiftCardTransactions::findOrCreate(giftCardChannelTxns, false);

                        // Unlock the gift card.
                        this.unlockCard(this.OneTimeRedemption, RetailGiftCardOperation::OfflineUnlock);
                        isLockReleased = true;
                        break;

                    case RetailGiftCardOperation::AddTo:
                        // Move the transaction from channel side table to AX side table, if missing.
                        RetailGiftCardTransactions::findOrCreate(giftCardChannelTxns, false);
                        break;

                    case RetailGiftCardOperation::CashOut:
                        // Move the transaction from channel side table to AX side table, if missing.
                        RetailGiftCardTransactions::findOrCreate(giftCardChannelTxns, false);
                        break;

                    case RetailGiftCardOperation::OfflineUnlock:
                        this.unlockCard(false, giftCardChannelTxns.operation);
                        isLockReleased = true;
                        break;

                    case RetailGiftCardOperation::VoidIssue:
                        // Set the table record as updatable before deleting.
                        this.selectForUpdate(true);

                        // Following a void issue we delete the gift card.
                        // This is because from POS you are allowed to issue and void a gift card as part of the same transaction.
                        // And another person can then come and issue the same gift card.
                        // For data integrity we then remove the transactions which dont belong to the current issuer.
                        this.delete();

                        // Setting to true as gift card is deleted when voiding.
                        isLockReleased = true;
                        break;
                }
            }

            if (isLockReleased)
            {
                // We do not require offline transactional data anymore and should clear them.
                delete_from giftCardChannelTxns where giftCardChannelTxns.cardNumber == this.entryId;
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGiftCardDataShared</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the gift card data record sharing (DRS) policy is enabled.
    /// </summary>
    /// <returns>True if DRS is enabled for gift cards. Otherwise, false.</returns>
    internal static boolean isGiftCardDataShared()
    {
        RetailGiftCardTable retailGiftCardTable;
        return SysDataSharingCommonAPI::isTablePartOfEnabledDRSPolicyForCurrentCompany(tableId2Name(retailGiftCardTable.TableId)) != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGiftCardTransactionsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the query to retrieve the transactions for the given gift card.
    /// Query is cross company enabled.
    /// </summary>
    /// <param name = "_cardId">The gift card number.</param>
    /// <returns>The query for gift card transactions.</returns>
    internal static Query getGiftCardTransactionsQuery(RetailGiftCardId _cardId)
    {
        Query query = new Query();

        if (_cardId != '')
        {
            QueryBuildDataSource qbdsRetailGiftCardTransactions = query.addDataSource(tableNum(RetailGiftCardTransactions));
            qbdsRetailGiftCardTransactions.addRange(fieldNum(RetailGiftCardTransactions, CardNumber)).value(_cardId);

            QueryBuildDataSource qbdsRetailGiftCardTable = qbdsRetailGiftCardTransactions.addDataSource(tableNum(RetailGiftCardTable));
            qbdsRetailGiftCardTable.addLink(fieldNum(RetailGiftCardTransactions, CardNumber), fieldNum(RetailGiftCardTable, EntryId));
            qbdsRetailGiftCardTable.addLink(fieldNum(RetailGiftCardTransactions, DataAreaId), fieldNum(RetailGiftCardTable, DataAreaId));

            QueryBuildDataSource qbdsRetailChannelTable = qbdsRetailGiftCardTransactions.addDataSource(tableNum(RetailChannelTable));
            qbdsRetailChannelTable.joinMode(JoinMode::OuterJoin);
            qbdsRetailChannelTable.addLink(fieldNum(RetailGiftCardTransactions, Channel), fieldNum(RetailChannelTable, RecId));

            QueryBuildDataSource qbdsOMOperatingUnit = qbdsRetailChannelTable.addDataSource(tableNum(OMOperatingUnit));
            qbdsOMOperatingUnit.joinMode(JoinMode::OuterJoin);
            qbdsOMOperatingUnit.addLink(fieldNum(RetailChannelTable, OMOperatingUnitID), fieldNum(OMOperatingUnit, RecId));

            query.allowCrossCompany(true);
        }

        return query;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Retail</ConfigurationKey>
	<DeveloperDocumentation>@RET4040257</DeveloperDocumentation>
	<FormRef>RetailGiftCardTable</FormRef>
	<Label>@RET4435</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>entryId</TitleField1>
	<TitleField2>currencyCode</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>typeEntryIdx</ClusteredIndex>
	<CreateRecIdIndex>No</CreateRecIdIndex>
	<DataSharingType>Duplicate</DataSharingType>
	<Modules>Payments</Modules>
	<PrimaryIndex>typeEntryIdx</PrimaryIndex>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>RetailGiftCardTransactions</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>RetailGiftCardTransactions</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>RetailGiftCardChannelTransactions</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>RetailGiftCardChannelTransactions</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>balance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>currencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>balance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>currencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>reservedByChannel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>reservedByTerminalId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@SYS80094</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>reservedByTerminalId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>reservedByChannel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>reserved</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>replicationCounter</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>currencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MCRGiftCardType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>entryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Amount</Name>
			<Label>@RET3221</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>balance</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Details</Name>
			<Label>@RET3813</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>balance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>currencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Grid</Name>
			<Label>@RET4772</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>balance</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>currencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@RET3040</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Locked</Name>
			<Label>@SYS8709</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>reserved</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>reservedByChannel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>reservedByTerminalId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReservedByTransactionId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>MCRRetailGiftCard</Name>
			<Label>@MCR30166</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MCRGiftCardType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>MCRRetailGiftCardVirtual</Name>
			<Label>@MCR30166</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MCRGiftCardType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Balance</Name>
			<Label>@SYP4880752</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MinReloadMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MaxBalanceMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NonReloadable</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>FaceValue</Name>
			<Label>@syp4880773</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FaceValue</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GiftCardPolicy</Name>
			<Label>@SYP4880754</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>getExtendedStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActiveFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpiryDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>minReloadCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>maxBalanceCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OneTimeRedemption</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Redemption</Name>
			<Label>@SYP4880753</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OneTimeRedemption</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ValidityPeriod</Name>
			<Label>@SYP4880751</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ActiveFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpiryDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>currencyCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>entryId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailGiftCardId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>MCRGiftCardType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>MCRGiftCardType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>replicationCounter</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailReplicationCounter</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>reserved</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS8709</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>reservedByChannel</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailChannelRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>reservedByTerminalId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailTerminalId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ActiveFrom</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailGiftCardActiveFrom</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ExpiryDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailGiftCardExpireDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>FaceValue</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailGiftCardFaceValue</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>MaxBalanceMST</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailGiftCardMaxBalanceMST</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>MinReloadMST</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailGiftCardMinReloadMST</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>NonReloadable</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailGiftCardNonReloadable</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OneTimeRedemption</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailGiftCardOneTimeRedemption</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Status</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>RetailGiftCardStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReservedByStoreId</Name>
			<AllowEdit>No</AllowEdit>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>RetailStoreId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<IsObsolete>Yes</IsObsolete>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReservedByTransactionId</Name>
			<ExtendedDataType>RetailTransactionId</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>typeEntryIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>entryId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>replicationIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>replicationCounter</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>currencyCode</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>currencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RetailChannelTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RetailChannelTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>reservedByChannel</Name>
					<Field>reservedByChannel</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RetailTerminalTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>RetailTerminalTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>reservedByTerminalId</Name>
					<SourceEDT>RetailTerminalId</SourceEDT>
					<Field>reservedByTerminalId</Field>
					<RelatedField>terminalId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>terminalIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>