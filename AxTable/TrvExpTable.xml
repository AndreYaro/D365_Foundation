<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TrvExpTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class TrvExpTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the total perdiem expenses for the expense report.
    /// </summary>
    /// <returns>
    ///     The total perdiem expenses for the expense report in company currency.
    /// </returns>
    display TrvAllowance allowance()
    {
        TrvExpTrans trvExpTrans;

        select sum(AmountMST)
            from trvExpTrans
            where trvExpTrans.TrvExpTable == this.RecId
                && trvExpTrans.ExpType == TrvExpType::Allowance
                && TrvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        return trvExpTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyLinesHaveDifferentApprovalStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there are lines with different statuses than the expense report.
    /// </summary>
    /// <returns>
    /// true if there is any line with a different status than the expense report; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The Boolean value is used to determine whether we display the approval status column in the expense
    /// line grid.
    /// </remarks>
    public display boolean anyLinesHaveDifferentApprovalStatus()
    {
        TrvExpTrans trvExpTrans;

        select firstonly RecId from trvExpTrans
            where trvExpTrans.TrvExpTable     == this.RecId
               && trvExpTrans.ApprovalStatus  != this.ApprovalStatus
               && trvExpTrans.LineType        != TrvExpLineType::ItemizedHeader
               && trvExpTrans.SplitLineType   != TrvExpSplitLineType::SplitHeader;

        return (trvExpTrans.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyPolicyErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the expense report or its lines have any expense policy errors.
    /// </summary>
    /// <returns>
    /// true if the expense report or its lines have policy errors; otherwise, false.
    /// </returns>
    public display boolean anyPolicyErrors()
    {
        return TrvPolicyEvalEngine::anyPolicyErrors(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allLinesPosted</Name>
				<Source><![CDATA[
    public boolean allLinesPosted()
    {
        TrvExpTrans trvExpTrans;
        boolean ret;

        if (this.RecId && this.hasExpenseLines())
        {
            select firstOnly RecId from trvExpTrans
                where trvexptrans.TrvExpTable == this.RecId
                && trvexptrans.ApprovalStatus != TrvAppStatus::Ledger;

            ret = trvExpTrans.RecId == 0;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyPostedLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the expense report has any posted lines.
    /// </summary>
    /// <returns>True if the expense report has any posted lines; otherwise, false.</returns>
    public display boolean anyPostedLines()
    {
        TrvExpTrans trvExpTrans;

        select firstonly RecId from trvExpTrans
            where trvExpTrans.TrvExpTable == this.RecId
            && trvExpTrans.ApprovalStatus == TrvAppStatus::Ledger;

        return (trvExpTrans.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyProjectPolicyErrorsForLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if any of the lines have project policy errors; otherwise, false.
    /// </summary>
    private boolean anyProjectPolicyErrorsForLines()
    {
        TrvExpTrans trvExpTrans;
        boolean ret = false;

        if (this.RecId)
        {
            while select trvExpTrans where trvExpTrans.TrvExpTable== this.RecId
            {
                if (trvExpTrans.anyProjectPolicyViolations())
                {
                    ret = true;
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSubmitJustificationRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the expense report has a policy violation that requires submit justification.
    /// </summary>
    /// <returns>
    /// True if the expense report requires user justification on submit for policy errors; otherwise, false.
    /// </returns>
    public boolean isSubmitJustificationRequired()
    {
        if (!this.RecId)
        {
            return false;
        }

        return TrvJustificationHelper::isJustificationRequired(this.RecId, TrvPolicyViolationJustificationTypeEnum::TrvExpHeader, TrvPolicyViolationLevel::SubmitJustification);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isApproveJustificationRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the expense report has a policy violation that requires approve justification.
    /// </summary>
    /// <returns>
    /// True if the expense report requires user justification on approval for policy errors; otherwise, false.
    /// </returns>
    public boolean isApproveJustificationRequired()
    {
        if (!this.RecId)
        {
            return false;
        }

        return TrvJustificationHelper::isJustificationRequired(this.RecId, TrvPolicyViolationJustificationTypeEnum::TrvExpHeader, TrvPolicyViolationLevel::ApproveJustification);
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyPolicyViolations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the expense report has any policy violations; they can be errors or warnings.
    /// </summary>
    /// <returns>
    /// True if the expense report has policy violations; otherwise, false.
    /// </returns>
    public display TrvAnyPolicyViolations anyPolicyViolations()
    {
        List violations = this.policyViolationLevelMsgForHeaderAndLines();

        return (violations.elements() != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>approvalStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the expense report approval status as a string
    /// </summary>
    /// <returns>The label string for the current status of the expense report.</returns>
    public str approvalStatus()
    {
        return enum2str(this.ApprovalStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>approverJustification</Name>
				<Source><![CDATA[
    /// <summary>
    /// This display method returns a concatenated string of all approver names (excluding the current user) and their justification for the policy violation.
    /// </summary>
    /// <returns>
    /// Approver names and justification provided by them.
    /// </returns>
    display TrvPreviousApproversJustifications approverJustification()
    {
        return TrvJustificationHelper::otherApproversJustifications(this.RecId, TrvPolicyViolationJustificationTypeEnum::TrvExpHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>submitterJustification</Name>
				<Source><![CDATA[
    /// <summary>
    /// The submit justification entered for the current record.
    /// </summary>
    /// <returns>The justification text entered while submitting.</returns>
    display TrvSubmitterJustification submitterJustification()
    {
        return TrvJustificationHelper::submitterJustification(this.RecId, TrvPolicyViolationJustificationTypeEnum::TrvExpHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeSubmitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the expense report can be submitted.
    /// </summary>
    /// <returns>
    /// true if the expense report can be submitted; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The expense policies and project policies for an expense line should have been evaluated before
    /// this method is called.
    /// </remarks>
    public display boolean canBeSubmitted()
    {
        TrvExpTrans expLine;
        boolean     validToSubmit = false;

        select firstonly RecId from expLine
                    where expLine.TrvExpTable == this.RecId;

        validToSubmit = expLine && this.isItemizationComplete() && this.isSplitComplete() && !this.anyPolicyErrors();

        validToSubmit = validToSubmit && this.validateProjPolicies();

        validToSubmit = validToSubmit && !this.hasTransactionWithEmptyCategoryOrZeroAmt();

        return validToSubmit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyPaid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Company paid amount
    /// </summary>
    /// <returns>
    /// The Company paid amount.
    /// </returns>
    display AmountMST companyPaid()
    {
        TrvExpTrans trvExpTrans;
        AmountMST   trvTotalCompanyPaidAmount;

        if (!this.RecId)
        {
            return 0;
        }

        // select itemized lines to sum, they have the correct expense types in case of itemization/split scenarios
        if (TrvParameters::find().PersonalPaidBy == TrvPersonalPaidBy::Employee)
        {
            select firstonly sum(AmountMST) from trvExpTrans where trvExpTrans.TrvExpTable == this.RecId
                                                                && trvExpTrans.CostOwner == TrvCostOwner::Company
                                                                && (
                                                                    trvExpTrans.ExpType != TrvExpType::Advance &&
                                                                    trvExpTrans.ExpType != TrvExpType::Personal
                                                                    )
                                                                && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                                                                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

            trvTotalCompanyPaidAmount = trvExpTrans.AmountMST;

            // add tax amount of default expense lines and itemized expense lines for which tax is not included in the expense amount
            select firstonly sum(CorrectedTaxAmountMST) from trvExpTrans where trvExpTrans.TrvExpTable == this.RecId
                                                                && trvExpTrans.CostOwner == TrvCostOwner::Company
                                                                && (
                                                                    trvExpTrans.ExpType != TrvExpType::Advance &&
                                                                    trvExpTrans.ExpType != TrvExpType::Personal
                                                                    )
                                                                && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                                                                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
                                                                && trvExpTrans.TaxIncluded == NoYes::No;

            trvTotalCompanyPaidAmount += trvExpTrans.CorrectedTaxAmountMST;
        }
        else
        {
            // select personal lines if personal is paid by company
            select firstonly sum(AmountMST) from trvExpTrans where trvExpTrans.TrvExpTable == this.RecId
                                                                && trvExpTrans.CostOwner == TrvCostOwner::Company
                                                                && (
                                                                    trvExpTrans.ExpType != TrvExpType::Advance
                                                                    )
                                                                && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                                                                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

            trvTotalCompanyPaidAmount = trvExpTrans.AmountMST;

            //slect tax amount of default expense lines and itemized expense lines for which tax is not included in the expense amount
            select firstonly sum(CorrectedTaxAmountMST) from trvExpTrans where trvExpTrans.TrvExpTable == this.RecId
                                                                && trvExpTrans.CostOwner == TrvCostOwner::Company
                                                                && (
                                                                    trvExpTrans.ExpType != TrvExpType::Advance
                                                                    )
                                                                && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                                                                && trvExpTrans.TaxIncluded == NoYes::No
                                                                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

            trvTotalCompanyPaidAmount += trvExpTrans.CorrectedTaxAmountMST;
        }

        return trvTotalCompanyPaidAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyPaidWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the company paid amount with a currency code.
    /// </summary>
    /// <returns>
    /// The company paid amount with the currency code.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvAmountCurrency companyPaidWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithCurrencyCode(this.companyPaid(), this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>costTotal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives the billed amount for the expense report.
    /// </summary>
    /// <returns>
    ///     The billed amount for the expense report.
    /// </returns>
    display TrvTotalBilledAmount costTotal()
    {
        TrvExpTrans trvExpTrans;

        AmountCur        personal, advance, expenses, total;

        // Select expense lines that aren't Personal or Advance
        // The Itemized headers would not have the correct expense type when splitting to personal; always get the default and itemized/split lines
        select firstonly sum(AmountMST) from trvExpTrans where
            trvExpTrans.TrvExpTable == this.RecId &&
            trvExpTrans.ExpType != TrvExpType::Advance &&
            trvExpTrans.ExpType != TrvExpType::Personal &&
            trvExpTrans.LineType != TrvExpLineType::ItemizedHeader &&
            trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;


        expenses = trvExpTrans.AmountMST;

        // Select all lines that ARE Advance
        select firstonly sum(AmountMST) from trvExpTrans where
            trvExpTrans.TrvExpTable == this.RecId &&
            trvExpTrans.ExpType == TrvExpType::Advance &&
            trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        advance = trvExpTrans.AmountMST;

        total = expenses - advance;

        if (TrvParameters::find().PersonalPaidBy == TrvPersonalPaidBy::Company)
        {
            // Select all lines, including split and itemized lines, that ARE Personal
            select firstonly sum(AmountMST)
                from trvExpTrans
                where trvExpTrans.TrvExpTable == this.RecId
                    && trvExpTrans.ExpType == TrvExpType::Personal
                    && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                    && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

            personal = trvExpTrans.AmountMST;

            total = total - personal;
        }

        return total;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costTotalWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays total billed amount along with the currency code.
    /// </summary>
    /// <returns>
    /// Returns the total billed amount along with the currency code.
    /// </returns>
    display TrvAmountCurrency costTotalWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithCurrencyCode(this.costTotal(), this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>customerPaid</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives the amount paid by customer for the expense report.
    /// </summary>
    /// <returns>
    ///     The amount paid by customer for the expense report.
    /// </returns>
    display AmountCur customerPaid()
    {
        TrvExpTrans trvExpTrans;

        // select itemized lines to sum, they have the correct expense types in case of itemization/split scenarios
        select firstonly sum(AmountMST)
            from trvExpTrans
            where  trvExpTrans.TrvExpTable == this.RecId
                && trvExpTrans.CostOwner == TrvCostOwner::CustomerOther
                && (trvExpTrans.ExpType != TrvExpType::Advance && trvExpTrans.ExpType != TrvExpType::Personal)
                && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        return trvExpTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        TrvExpTableTrvRequisitionTable      trvExpTableTrvRequisitionTable;
        DocuRef                             docuRef;

        ttsbegin;
        // Detach receipts attached to report before deletion.
        while select RecId, ValueRecId from docuRef where docuRef.RefTableId == tablenum(TrvExpTable) && docuRef.RefRecId == this.RecId
        {
            DocuRef lineAttachments;
            select firstonly RecId from lineAttachments where lineAttachments.ValueRecId == docuRef.ValueRecId && lineAttachments.RefTableId == tableNum(TrvExpTrans);
            if (!lineAttachments.RecId)
            {
                TrvReceiptsHelper::detachDocument(docuRef.RecId);
            }
        }

        this.changeRequisition('');

        // Unattach expenses from the expense report
        TrvExpTrans trvExpTrans;
        boolean successfullyUnattached = true;
        while select forupdate trvExpTrans 
            where TrvExpTrans.ExpNumber == this.ExpNumber
            && TrvExpTrans.TrvExpTable == this.RecId
        {
            if (!trvExpTrans.updateExpenseReport(''))
            {
                successfullyUnattached = false;
                break;
            }
        }

        // If expense line is not unattached successfully, fail expense report deletion
        if (!successfullyUnattached)
        {
            throw error(strFmt("@Expense:ExpenseLineUnattachFailure", trvExpTrans.ExpTransNumber));
        }

        select firstonly TrvRequisitionTable from trvExpTableTrvRequisitionTable
            where trvExpTableTrvRequisitionTable.TrvExpTable == this.RecId;

        super();

        if (trvExpTableTrvRequisitionTable.TrvRequisitionTable)
        {
            TrvRequisitionTable::updateReconciliationStatus(trvExpTableTrvRequisitionTable.TrvRequisitionTable);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emplBalance</Name>
				<Source><![CDATA[
    display AmountCur emplBalance()
    {
        return this.employeePaid() + this.sumAllowance() - this.sumAdvance();
    }

]]></Source>
			</Method>
			<Method>
				<Name>employeeName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the name of the worker for whom the expense report is compiled.
    /// </summary>
    /// <returns>
    /// The name of the worker.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display HcmWorkerName employeeName()
    {
        return HcmWorker::worker2Name(this.CreatingWorker);
    }

]]></Source>
			</Method>
			<Method>
				<Name>employeePaid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the amount paid by employee.
    /// </summary>
    /// <returns>
    /// The amount paid by employee.
    /// </returns>
    display AmountMST employeePaid()
    {
        TrvExpTrans trvExpTrans;

        // select itemized lines to sum, they have the correct expense types in case of itemization/split scenarios
        select firstonly sum(AmountMST) from trvExpTrans where  trvExpTrans.TrvExpTable == this.RecId
                                                             &&  trvExpTrans.CostOwner == TrvCostOwner::Employee
                                                             && (
                                                                trvExpTrans.ExpType != TrvExpType::Advance &&
                                                                trvExpTrans.ExpType != TrvExpType::Personal
                                                                )
                                                             && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                                                             && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        return trvExpTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>employeePaidWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the amount paid by employee along with the currency code.
    /// </summary>
    /// <returns>
    /// The amount paid by employee along with the currency code.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvAmountCurrency employeePaidWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithCurrencyCode(this.employeePaid(), this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorStatusIndicator</Name>
				<Source><![CDATA[
    public display container errorStatusIndicator()
    {
        ImageReference imageRef;

        // Don't need to show errors for Reports that are Approved or further in workflow
        if (this.RecId != 0 && this.ApprovalStatus != TrvAppStatus::Ledger && this.ApprovalStatus != TrvAppStatus::Approved)
        {
            if (this.hasExpenseLines())
            {
                if (this.canBeSubmitted())
                {
                    if(this.anyPolicyViolations())
                    {
                        imageRef = ImageReference::constructForSymbol(ImageReferenceSymbol::Warning);
                        return imageRef.pack();
                    }
                }
                else
                {
                    imageRef = ImageReference::constructForSymbol(ImageReferenceSymbol::Error);
                    return imageRef.pack();
                }
            }
        }
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluatePolicyForAllLines</Name>
				<Source><![CDATA[
    private void evaluatePolicyForAllLines()
    {
        TrvExpTrans trvExpTrans;

        if (this.RecId)
        {
            while select RecId from trvExpTrans where trvExpTrans.TrvExpTable == this.RecId
            {
                TrvPolicyEvalEngine::evaluateViolationsForLine(trvExpTrans.RecId, SysPolicyTypeEnum::TrvExpensePolicy);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluateProjectPoliciesForLines</Name>
				<Source><![CDATA[
    private void evaluateProjectPoliciesForLines()
    {
        TrvExpTrans trvExpTrans;

        if (this.RecId)
        {
            ttsbegin;
            while select forupdate trvExpTrans 
                where trvExpTrans.TrvExpTable == this.RecId
                && trvExpTrans.ProjId != ""

            {
                trvExpTrans.evaluateProjectPoliciesAndSave();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyPaid</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the company paid amount for the expense report.
    /// </summary>
    /// <returns>
    ///     The company paid amount.
    /// </returns>
    display TrvPaidByCompany getCompanyPaid()
    {
        return this.companyPaid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmplName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the name of the worker for whom the expense report is compiled.
    /// </summary>
    /// <returns>
    /// The name of the worker.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display EmplName getEmplName()
    {
        return HcmWorker::worker2Name(this.CreatingWorker);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmployeePaid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the amount paid by an employee for the expense report.
    /// </summary>
    /// <returns>
    /// The amount paid by the employee.
    /// </returns>
    display TrvPaidByEmployee getEmployeePaid()
    {
        return this.employeePaid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUserId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the user ID of the worker for whom the expense report is compiled.
    /// </summary>
    /// <returns>
    /// The user ID of the worker for whom the expense report is compiled.
    /// </returns>
    display SysUserId getUserId()
    {
        return DirPersonUserEx::worker2UserId(this.CreatingWorker);
    }

]]></Source>
			</Method>
			<Method>
				<Name>gotImportedCreditCardLines</Name>
				<Source><![CDATA[
    private boolean gotImportedCreditCardLines(TrvExpTable _originalTrvExpTable)
    {
        TrvExpTrans orgExpTrans;

        select firstonly RecId from orgExpTrans
                where orgExpTrans.TrvExpTable == _originalTrvExpTable.RecId
                   && orgExpTrans.PBSRecId != 0;

        if (orgExpTrans.RecId)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCreditCardLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the expense report has any credit card transactions.
    /// </summary>
    /// <returns>True if credit card transactions exist on the expense report; otherwise false</returns>
    public boolean hasCreditCardLines()
    {
        return this.gotImportedCreditCardLines(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasInterCompanyTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the expense report has intercompany transactions.
    /// </summary>
    /// <returns>
    ///     true if the expense report has intercompany transactions; otherwise, false
    /// </returns>
    public display boolean hasInterCompanyTransactions()
    {
        TrvExpTrans trvExpTrans;

        select firstonly RecId from trvExpTrans
            where trvExpTrans.TrvExpTable== this.RecId &&
                  trvExpTrans.InterCompanyLE != curext() &&
                  trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;
                

        return trvExpTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasReceiptsAttached</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether an expense report has any receipts attached to it.
    /// </summary>
    /// <returns>
    /// true if the expense report has any attached receipts; otherwise, false.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display TrvHasReceiptsAttached hasReceiptsAttached()
    {
        TrvReceiptsHelper   trvReceiptsHelper = new TrvReceiptsHelper();

        return trvReceiptsHelper.isDocumentAttachedToExpenseReport(this.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasTransactionWithEmptyCategoryOrZeroAmt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether there are any transactions with an empty category or a zero amount.
    /// </summary>
    /// <returns>
    /// true if there are any transactions with an empty category or a zero amount; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is used to determine whether the expense report can be submitted.
    /// </remarks>
    public display boolean hasTransactionWithEmptyCategoryOrZeroAmt()
    {
        TrvExpTrans trvExpTrans;

        select firstonly RecId from trvExpTrans where trvExpTrans.TrvExpTable == this.RecId &&
                      (((trvExpTrans.LineType != TrvExpLineType::ItemizedHeader || trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader)
                       && trvExpTrans.AmountCurr == 0 && TrvExpTrans.expType != TrvExpType::Transport) // allow zero amount for mileage transactions
                        || (!trvExpTrans.CostType || trvExpTrans.ExpType == TrvExpType::Empty));

        return (trvExpTrans.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        this.ApprovalStatus = TrvAppStatus::Create;

        this.LegalEntity            = CompanyInfo::current();
        this.ReferenceDataAreaId    = curext();
        this.InterCompanyLE         = curext();
        this.setDefaultDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        TrvParameters   trvParameters = TrvParameters::find();

        ttsbegin;

        // Create source document header
        SourceDocumentProcessorFacade::submitSourceDocumentImplementation(this);

        if (trvParameters.ApproverHierarchyDisplay != TrvApproverHierarchyFields::None)
        {
            this.FinalApprover = TrvInterimFinalApproverHelper::getDefaultFinalApprover(this.CreatingWorker);
        }

        super();

        ttscommit;

        if (trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
        {
            TrvPolicyEvalEngine::evaluateViolationsForHdr(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEditable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the current expense document is editable, depending on the workflow status
    /// delegate access and employment.
    /// </summary>
    /// <returns>
    /// true if the status is either the <c>TrvAppStatus::Create</c> or <c>TrvAppStatus::Returned</c> enumeration value
    /// and worker is employed in current company or has delegate access; otherwise, false.
    /// </returns>
    public display boolean isEditable()
    {
        return (this.isEditableBasedOnWorkflowStatus()
            && TrvAccessHelper::canCreateNewTransactions(this.CreatingWorker));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEditableBasedOnWorkflowStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the current expense document is editable, depending on only the workflow status.
    /// </summary>
    /// <returns>
    /// true if the status is either the <c>TrvAppStatus::Create</c> or <c>TrvAppStatus::Returned</c>
    /// enumeration value; otherwise, false.
    /// </returns>
    public boolean isEditableBasedOnWorkflowStatus()
    {
        switch (this.ApprovalStatus)
        {
            case TrvAppStatus::Approved:
            case TrvAppStatus::Cancelled:
            case TrvAppStatus::Ledger:
            case TrvAppStatus::Pending:
            case TrvAppStatus::Submitted:
            case TrvAppStatus::Ready:
            case TrvAppStatus::None:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemizationComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether all of the lines that can be itemized for an expense report are itemized.
    /// </summary>
    /// <returns>
    /// true if all lines that can be itemized have been itemized; otherwise, false.
    /// </returns>
    public boolean isItemizationComplete()
    {
        TrvExpItemizationStatus status = this.itemizationStatus();

        return status == TrvExpItemizationStatus::Completed || status == TrvExpItemizationStatus::NotApplicable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSplitComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether split is completed or not.
    /// </summary>
    /// <returns>
    /// true if all lines that can be itemized have been itemized; otherwise, false.
    /// </returns>
    public boolean isSplitComplete()
    {
        TrvExpSplitStatus status = this.splitStatus();

        return status == TrvExpSplitStatus::Completed || status == TrvExpSplitStatus::NotApplicable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjBudgetFailed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether any expense line has a project budget status of failed.
    /// </summary>
    /// <returns>
    /// true if a project budget check failed on any expense line; otherwise, false.
    /// </returns>
    display boolean isProjBudgetFailed()
    {
        ProjBudgetStatus    projBudgetStatus;
        TrvExpTrans         trvExpTrans;

        select firstonly RecId from trvExpTrans
                        where trvExpTrans.TrvExpTable == this.RecId
                     exists join RecId from projBudgetStatus
                        where projBudgetStatus.SourceDocumentLine == trvExpTrans.SourceDocumentLine
                            && projBudgetStatus.BudgetCheckResult == ProjBudgetCheckResult::Failed;

        return (trvExpTrans.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTravelRequisitionAssociated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a travel requisition is associated to the expense report.
    /// </summary>
    /// <returns>
    /// true if a travel requisition is associated; otherwise, false.
    /// </returns>
    public boolean isTravelRequisitionAssociated()
    {
        TrvExpTableTrvRequisitionTable trvExpTableTrvRequisitionTable;

        select firstonly RecId from trvExpTableTrvRequisitionTable
                    where trvExpTableTrvRequisitionTable.TrvExpTable == this.RecId;

        if (trvExpTableTrvRequisitionTable.RecId)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemizationStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the itemization status for an expense report.
    /// </summary>
    /// <returns>
    /// The itemization status for an expense report.
    /// </returns>
    display TrvExpItemizationStatus itemizationStatus()
    {
        TrvExpTrans expTrans;
        TrvExpItemizationStatus overallStatus = TrvExpItemizationStatus::NotApplicable;

        while select RecId, LineType, ExpType, AmountCurr, CreditCardTransactionCurrencyAmount, CreditCardTransactionCurrency, PBSRecId, CostType, ExpNumber, ExchangeCode from expTrans
            where expTrans.TrvExpTable == this.RecId
            && (expTrans.LineType == TrvExpLineType::ItemizedHeader || expTrans.LineType == TrvExpLineType::Default)
        {
            switch (expTrans.itemizationStatus())
            {
                case TrvExpItemizationStatus::Completed:
                case TrvExpItemizationStatus::NoItemizedLines:
                    if (overallStatus == TrvExpItemizationStatus::NotApplicable)
                    {
                        overallStatus = TrvExpItemizationStatus::Completed;
                    }
                    break;

                case TrvExpItemizationStatus::Incomplete:
                    return TrvExpItemizationStatus::Incomplete; // return early, no need to look at other lines
            }
        }

        return overallStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the split status for an expense report.
    /// </summary>
    /// <returns>
    /// The split status for an expense report.
    /// </returns>
    display TrvExpSplitStatus splitStatus()
    {
        TrvExpTrans expTrans;
        TrvExpSplitStatus overallStatus = TrvExpSplitStatus::NotApplicable;

        while select RecId, LineType, ExpType, SplitLineType, AmountCurr, CreditCardTransactionCurrencyAmount, CreditCardTransactionCurrency, PBSRecId from expTrans
            where expTrans.TrvExpTable == this.RecId
            && expTrans.SplitLineType == TrvExpSplitLineType::SplitHeader
        {
            switch (expTrans.splitStatus())
            {
                case TrvExpSplitStatus::Completed:
                    if (overallStatus == TrvExpSplitStatus::NotApplicable)
                    {
                        overallStatus = TrvExpSplitStatus::Completed;
                    }
                    break;

                case TrvExpSplitStatus::Incomplete:
                case TrvExpSplitStatus::NoSplitLines: // For some reason Split type is stuck at Split header
                    return TrvExpSplitStatus::Incomplete; // return early, no need to look at other lines
            }
        }

        return overallStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mappedTravelRequisitionNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gives the requisition number of a mapped travel requisition.
    /// </summary>
    /// <returns>
    /// The requisition number of the mapped travel requisition; otherwise, an empty String.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display TrvRequisitionNumber mappedTravelRequisitionNumber()
    {
        TrvExpTableTrvRequisitionTable  trvExpTableTrvRequisitionTable;
        TrvRequisitionTable             trvRequisitionTable;

        select firstonly RequisitionNumber from trvRequisitionTable
            exists join trvExpTableTrvRequisitionTable
                    where trvExpTableTrvRequisitionTable.TrvRequisitionTable == trvRequisitionTable.RecId
                       && trvExpTableTrvRequisitionTable.TrvExpTable        == this.RecId;

        return trvRequisitionTable.RequisitionNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(TrvExpTable, CreatingWorker):
                this.DefaultDimension = 0;
                this.setDefaultDimension();
                break;

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocHeaderTypeEnumName</Name>
				<Source><![CDATA[
    public EnumName parmSourceDocHeaderTypeEnumName()
    {
        return enumStr(SourceDocument_ExpenseReport);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocHeaderTypeEnumValue</Name>
				<Source><![CDATA[
    public SourceDocumentTypeEnumValue parmSourceDocHeaderTypeEnumValue()
    {
        return SourceDocument_ExpenseReport::ExpenseReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>personnelNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the personnel number of the worker, to whom the expense report belongs.
    /// </summary>
    /// <returns>
    /// The personnel number of the worker.
    /// </returns>
    public display HcmPersonnelNumberId personnelNumber()
    {
        return HcmWorker::find(this.CreatingWorker).PersonnelNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>policyViolationLevelMsg</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of <c>TrvPolicyViolation</c> objects for the transaction header.
    /// </summary>
    /// <returns>
    /// A list of <c>TrvPolicyViolation</c> objects for the transaction header.
    /// </returns>
    public List policyViolationLevelMsg()
    {
        return TrvPolicyEvalEngine::displayPolicyViolationLevelMsgHdr(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>policyViolationLevelMsgForHeaderAndLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of <c>TrvPolicyViolation</c> objects for the expense header + lines.
    /// </summary>
    /// <returns>
    /// A list of <c>TrvPolicyViolation</c> objects for the expense header + lines.
    /// </returns>
    public List policyViolationLevelMsgForHeaderAndLines()
    {
        return TrvPolicyEvalEngine::displayPolicyViolationLevelMsgHdr(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwInfologsForPolicyViolationLevelMsg</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Writes the policy violation messages for the header to the infolog.
    /// </summary>
    public void throwInfologsForPolicyViolationLevelMsg()
    {
        List                violations = this.policyViolationLevelMsg();
        ListEnumerator      listEnumerator;
        TrvPolicyViolation  violation;

        listEnumerator = violations.getEnumerator();

        while (listEnumerator.moveNext())
        {
            violation = listEnumerator.current();

            if (violation.parmAdjustedViolationLevel() == TrvPolicyViolationLevel::Error)
            {
                error(violation.parmViolationMessage());
            }
            else
            {
                warning(violation.parmViolationMessage());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postApprove</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the committed cost for an expense report and cleanup uncommitted split records.
    /// </summary>
    /// <param name="_trvExpTableRecId">
    /// The record ID of a record in a <c>TrvExpTable</c> table.
    /// </param>
    public void postApprove(RecId _trvExpTableRecId)
    {
        TrvExpTrans             trvExpTrans;
        SourceDocumentLineItem  sourceDocumentLineItem;
        TrvExpTransSplit		trvExpTransSplit;
        TrvExpTrans				splitHeaderExpense;

        while select trvExpTrans
            where trvExpTrans.ProjId != '' && trvExpTrans.TrvExpTable== _trvExpTableRecId
        {
            if ( !CostControlTransCommittedCost::existOpenBySourceDocumentLine(trvExpTrans.SourceDocumentLine) && AccountingDistribution::existSourceDocumentLine(trvExpTrans.SourceDocumentLine) )
            {
                sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLineImplementation(trvExpTrans);
                ProjectCommitmentFacade::updateProjectCommitments(sourceDocumentLineItem);
            }
        }

		// Clean up split records if split status is not applicable.
        if (this.splitStatus() == TrvExpSplitStatus::NotApplicable)
        {
			delete_from trvExpTransSplit
                where trvExpTransSplit.SplitLineRecId == 0
            exists join splitHeaderExpense
                where splitHeaderExpense.TrvExpTable == _trvExpTableRecId
					&& splitHeaderExpense.RecId == trvExpTransSplit.SplitHeaderRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queueAssignedDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the date that the queued expense reports were assigned to the work item queue.
    /// </summary>
    /// <returns>
    /// The assigned date of the corresponding work item to queue.
    /// </returns>
    display WorkflowWorkListQueueAssignedDate queueAssignedDate()
    {
        WorkflowTrackingStatusTable     trackingStatusTable;
        WorkflowTrackingTable           trackingTable;

        trackingStatusTable = WorkflowTrackingStatusTable::findByCorrelation(TrvExpTable::findWorkItem(this.RecId).CorrelationId);
        trackingTable = WorkflowTrackingTable::findByCorrelation(trackingStatusTable.CorrelationId, WorkflowTrackingContext::WorkItem, WorkflowTrackingType::Creation);

        return DateTimeUtil::date(trackingTable.CreatedDateTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>submissionDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the date that the expense report was submitted.
    /// </summary>
    /// <returns>The date the expense report was submitted.</returns>
    display date submissionDate()
    {
        WorkflowTrackingStatusTable statusTable;

        select firstonly CreatedDateTime from statusTable
            where statusTable.ContextTableId == tableNum(TrvExpTable)
               && statusTable.ContextRecId == this.RecId
               && (statusTable.trackingStatus == WorkflowTrackingStatus::Pending || statusTable.trackingStatus == WorkflowTrackingStatus::Completed);

        return DateTimeUtil::date(statusTable.CreatedDateTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queueName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the work item queue name that the queued expense reports are assigned to.
    /// </summary>
    /// <returns>
    /// The name of the queue that the expense reports are assigned to.
    /// </returns>
    display Name queueName()
    {
        return WorkflowWorkItemQueue::find(TrvExpTable::findWorkItem(this.RecId).Queue).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default dimensions for an expense header.
    /// </summary>
    /// <param name="_fromTravelReq">When set, use to retrieve travel requisition for defaulting.</param>
    /// <remarks>
    /// If associated with a Travel requisition, the dimension defaults from the Travel Req, otherwise
    /// the dimension defaults from the Worker. The Expense/Requisition relationship record does not get created
    /// until save. Use the _fromTravelReq parameter to default prior to saving.  Defaulting from the worker occurs
    /// only when the DefaultDimension has not been set.
    /// </remarks>
    public void setDefaultDimension(TrvRequisitionNumber _fromTravelReq = '')
    {
        TrvExpTableTrvRequisitionTable trvExpTableTrvRequisitionTable;
        TrvRequisitionTable reqTable;
        
        if (this.DefaultDimension == 0 && this.CreatingWorker)
        {
            this.DefaultDimension =  HcmEmployment::findByWorkerLegalEntity(this.CreatingWorker, this.LegalEntity).DefaultDimension;
        } 

        if (isConfigurationkeyEnabled(configurationKeyNum(ExpenseTravelRequisition)))
        {
            if (_fromTravelReq)
            {
                reqTable = TrvRequisitionTable::findByRequisitionNumber(_fromTravelReq);
            }
            else if (this.RecId)
            {
                select firstonly DefaultDimension, ReferenceDataAreaId, RecId from reqTable
                    exists join trvExpTableTrvRequisitionTable
                        where trvExpTableTrvRequisitionTable.TrvExpTable == this.RecId;
            }

            // merge travel req with worker for the current LE
            if (reqTable && reqTable.DefaultDimension)
            {
                this.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(reqTable.DefaultDimension, this.DefaultDimension);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimensionLegalEntityName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the legal entity on which the expense header's financial dimensions are valid.
    /// </summary>
    /// <returns>The legal entity on which the expense header's financial dimensions are valid.</returns>
    public SelectableDataArea defaultDimensionLegalEntityName()
    {
        return TrvExpenseDimensionHelper::getDefaultDimensionLegalEntityName(this.isIntercompany(),
                                                                            this.ReferenceDataAreaId,
                                                                            this.InterCompanyLE,
                                                                            this.isIntercompanyWithProject());
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumAdvance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives the total amount of cash advances for this expense report.
    /// </summary>
    /// <returns>
    ///     Total amount of cash advances for this expense report.
    /// </returns>
    display AmountCur sumAdvance()
    {
        TrvExpTrans trvExpTrans;

        select firstonly sum(AmountMST)
			from trvExpTrans
			where trvExpTrans.TrvExpTable == this.RecId
				&& trvExpTrans.ExpType == TrvExpType::Advance
                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        return trvExpTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumAllowance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives the total per diem expenses for this expense report.
    /// </summary>
    /// <returns>
    ///     Total amount of per diem expenses for this expense report.
    /// </returns>
    display AmountCur sumAllowance()
    {
        TrvExpTrans trvExpTrans;

        select firstonly sum(AmountMST)
			from trvExpTrans
			where trvExpTrans.TrvExpTable == this.RecId
				&& trvExpTrans.ExpType == TrvExpType::Allowance
                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        return trvExpTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumExpense</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives the total miscellaneous expenses for this expense report.
    /// </summary>
    /// <returns>
    ///     Total amount of miscellaneous expenses for this expense report.
    /// </returns>
    /// <remarks>
    ///     Miscellaneous expenses are expenses of type <c>Expense</c>.
    /// </remarks>
    display AmountCur sumExpense()
    {
        TrvExpTrans trvExpTrans;

        select firstonly sum(AmountMST)
			from trvExpTrans
			where trvExpTrans.TrvExpTable == this.RecId
				&& trvExpTrans.ExpType == TrvExpType::Expense
                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        return trvExpTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumTransport</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives the total mileage expenses for this expense report.
    /// </summary>
    /// <returns>
    ///     Total amount of the mileage expenses for this expense report.
    /// </returns>
    display AmountCur sumTransport()
    {
        TrvExpTrans trvExpTrans;

        select firstonly sum(AmountMST)
			from trvExpTrans
			where trvExpTrans.TrvExpTable == this.RecId
				&& trvExpTrans.ExpType == TrvExpType::Transport
                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        return trvExpTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>total</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives the total amount for this expense report.
    /// </summary>
    /// <returns>
    ///     Total amount for this expense report.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvTotalExpenseAmount total()
    {
        TrvExpTrans             trvExpTrans;
        TrvTotalExpenseAmount   trvTotalExpenseAmount;

        if (!this.Recid)
        {
            return 0;
        }

        // sum the headers, as we are not looking at the actual expense type of the line
        select firstonly sum(AmountMST)
			from trvExpTrans
            where trvExpTrans.TrvExpTable == this.RecId
                && trvExpTrans.LineType != TrvExpLineType::ItemizedLine
                && trvExpTrans.ExpType != TrvExpType::Advance
                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        trvTotalExpenseAmount = trvExpTrans.AmountMST;

        // add tax amount of default expense lines and itemized expense lines for which tax is not included in the expense amount
        select firstonly sum(CorrectedTaxAmountMST)
			from trvExpTrans
            where trvExpTrans.TrvExpTable == this.RecId
                && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
                && trvExpTrans.ExpType != TrvExpType::Advance
                && trvExpTrans.TaxIncluded == NoYes::No;

        trvTotalExpenseAmount += trvExpTrans.CorrectedTaxAmountMST;

        // Subtract return cash advance amount if any.
        trvTotalExpenseAmount -= this.sumAdvance();

        return trvTotalExpenseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalApprovalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the total approval amount in company currency.
    /// </summary>
    /// <returns>
    /// The total amount for approval in company currency.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvTotalExpenseAmount totalApprovalAmount()
    {
        Amount                      totalAmountToApprove = 0;
        TrvExpTrans                 trvExpTrans;
        TrvWorkflowExpProviderCache trvWorkflowExpProviderCache;

        if (TrvWorkflowExpProviderCache::existForExpense(this.RecId, curUserId()))
        {
            select sum(TransactionAmount) from trvWorkflowExpProviderCache
                where trvWorkflowExpProviderCache.TrvExpTable == this.RecId
                    && trvWorkflowExpProviderCache.WorkflowUser == curUserId()
                join RecId from trvExpTrans
                    where trvExpTrans.TrvExpTable == this.RecId
                        && trvExpTrans.RecId == trvWorkflowExpProviderCache.TrvExpTrans
                        && trvExpTrans.ExpType != TrvExpType::Advance
                        && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

            totalAmountToApprove = trvWorkflowExpProviderCache.TransactionAmount;

            // add tax amount of default expense lines and itemized expense lines for which tax is not included in the expense amount
            select sum(CorrectedTaxAmountMST) from trvExpTrans
                where trvExpTrans.TrvExpTable == this.RecId
                    && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                    && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
                    && trvExpTrans.ExpType != TrvExpType::Advance
                    && trvExpTrans.TaxIncluded == NoYes::No
                join RecId from trvWorkflowExpProviderCache
                    where trvWorkflowExpProviderCache.TrvExpTable == this.RecId
                        && trvWorkflowExpProviderCache.WorkflowUser == curUserId();

            totalAmountToApprove += trvExpTrans.CorrectedTaxAmountMST;
        }
        else
        {
            totalAmountToApprove = this.total();
        }

        return totalAmountToApprove;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalApprovalAmountWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the total approval amount in company currency and the company currency code.
    /// </summary>
    /// <returns>
    /// The total amount for approval in company currency and the company currency code.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvAmountCurrency totalApprovalAmountWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithCurrencyCode(this.totalApprovalAmount() , this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCreditCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gives the total credit card expenses for the current expense report.
    /// </summary>
    /// <returns>
    /// The total amount of credit card expenses for the current expense report.
    /// </returns>
    display TrvTotalCreditCard totalCreditCard()
    {
        TrvExpTrans trvExpTrans;
        TrvExpTrans splitLines;

        select sum(AmountMST) from trvExpTrans where
            trvExpTrans.TrvExpTable == this.RecId &&
            trvExpTrans.PBSRecId != 0 &&
            trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        select sum(AmountMST) from splitLines where
            splitLines.TrvExpTable == this.RecId &&
            splitLines.SplitLineType == TrvExpSplitLineType::SplitLine &&
            splitLines.LineType != TrvExpLineType::ItemizedLine;

        AmountMST totalCreditCardAmount = trvExpTrans.AmountMST + splitLines.AmountMST;

        // Subtract out the personal amount from credit card total when personal amount is paid by employee
        if (TrvParameters::find().PersonalPaidBy == TrvPersonalPaidBy::Employee)
        {
            totalCreditCardAmount = totalCreditCardAmount - this.totalPersonal();
        }

        return totalCreditCardAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMileageMethod</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives the total mileage from all the mileage expense lines for this expense report.
    /// </summary>
    /// <returns>
    ///     Total mileage from all the mileage expense lines for this expense report.
    /// </returns>
    display Qty totalMileageMethod()
    {
        TrvExpTrans trvExpTrans;

        select firstonly
            sum(kmOwnCar)
        from
            trvExpTrans
        where
            trvExpTrans.TrvExpTable== this.RecId
            && trvExpTrans.ExpType == TrvExpType::Transport
            && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        return trvExpTrans.kmOwnCar;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalOutOfPocket</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gives the total out of pocket expenses for the current expense report.
    /// </summary>
    /// <returns>
    /// The total amount of out of pocket expenses for the current expense report.
    /// </returns>
    /// <remarks>
    /// Out of pocket expenses include all expenses that are not credit card, personal or cash advance
    /// expenses.
    /// </remarks>
    display TrvTotalOutOfPocket totalOutOfPocket()
    {
        TrvExpTrans trvExpTrans;

        select sum(AmountMST) from trvExpTrans where
            trvExpTrans.TrvExpTable == this.RecId &&
            trvExpTrans.PBSRecId == 0 &&
            trvExpTrans.ExpType != TrvExpType::Personal &&
            trvExpTrans.ExpType != TrvExpType::Advance &&
            trvExpTrans.LineType != TrvExpLineType::ItemizedLine &&
            trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader &&
            trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitLine;

        return trvExpTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalPersonal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gives the total personal expenses for the current expense report.
    /// </summary>
    /// <returns>
    /// The total amount of personal expenses for the current expense report.
    /// </returns>
    public display TrvPersonalExpenses totalPersonal()
    {
        TrvExpTrans trvExpTrans;

        // Select all lines, including split and hotel lines, that are Personal
        select firstonly sum(AmountMST) from trvExpTrans where
            trvExpTrans.TrvExpTable == this.RecId &&
            trvExpTrans.ExpType == TrvExpType::Personal &&
            trvExpTrans.LineType != TrvExpLineType::ItemizedHeader &&
            trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        return trvExpTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalPayToEmployee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Total amount to be paid to employee. This excludes amount paid to credit card, personal amount and cash advance return.
    /// </summary>
    /// <returns>Total amount paid to employee in company currency.</returns>
    display Amount totalPayToEmployee()
    {
        TrvExpTrans trvExpTrans;
        TrvExpTrans parentExpTrans;

        select sum(AmountMST) from trvExpTrans where
            trvExpTrans.TrvExpTable == this.RecId &&
            trvExpTrans.PBSRecId == 0 &&
            trvExpTrans.ExpType != TrvExpType::Personal &&
            trvExpTrans.ExpType != TrvExpType::Advance &&
            trvExpTrans.CostOwner == TrvCostOwner::Employee &&
            trvExpTrans.LineType != TrvExpLineType::ItemizedHeader &&
            trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitLine &&
            trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
            notexists join parentExpTrans where
                parentExpTrans.RecId == trvExptrans.ParentRecId &&
                parentExpTrans.PBSRecId != 0;

        return trvExpTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the company currency code.
    /// </summary>
    /// <returns>Accounting currency of the expense report's LE.</returns>
    display CurrencyCode companyCurrency()
    {
        return Ledger::accountingCurrency(this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalPersonalWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays total personal amount along with the currency code.
    /// </summary>
    /// <returns>
    /// Returns the currency and total personal amount
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvAmountCurrency totalPersonalWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithCurrencyCode(this.totalPersonal(), this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays total amount along with the currency code.
    /// </summary>
    /// <returns>
    /// Returns the currency and total amount in company currency.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvTotalExpenseAmountWithCurrencyCode totalWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithCurrencyCode(this.total(), this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>trvReportDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the created date for the expense report in the user's timezone.
    /// </summary>
    /// <returns>
    ///     Created date of the expense report.
    /// </returns>
    public display TrvReportDateEDT trvReportDate()
    {
        utcdatetime d1 = this.CreatedDateTime;

        if (d1 == DateTimeUtil::newDateTime(dateNull(), 0))
        {
            d1 = DateTimeUtil::utcNow();
        }

        return DateTimeUtil::date(
                    DateTimeUtil::applyTimeZoneOffset(
                        d1, DateTimeUtil::getUserPreferredTimeZone()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        TrvParameters trvParameters = TrvParameters::find();

        super();
        //this.updateExchangeRates();

        if (trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
        {
            TrvPolicyEvalEngine::evaluateViolationsForHdr(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateApprove</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates an expense report before it can be approved.
    /// </summary>
    /// <returns>
    /// true if validation is successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The validations that include policy and budget errors.
    /// </remarks>
    public boolean validateApprove()
    {
        TrvPolicyEvalEngine::evaluateViolationsForHdr(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);
        TrvPolicyEvalEngine::evaluatePoliciesForAllLines(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);

        if (this.anyPolicyErrors())
        {
            error("@SYS302346");
            return false;
        }

        // Validates the exchange rate setup for the currency code used.
        if (!this.validateExchRateSetup())
        {
            return false;
        }

        if (!this.validateAntiCorruption(MessageSeverity::Error))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExchRateSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the default exchange rate setup is defined for the currency code entered for all the expense lines in an expense report.
    /// </summary>
    /// <returns>
    /// Returns true if exchange rate setup is defined; otherwise an error is thrown.
    /// </returns>
    public boolean validateExchRateSetup()
    {
        TrvExpTrans              trvExpTrans;
        RefRecId                 defaultExchangeRateType;
        Real                     exchangeRate;
        CurrencyCode             toCurrencyCode;
        boolean                  ret = true;
        ExchangeRateCalculation  exchRateCalc;

        defaultExchangeRateType = Ledger::defaultExchangeRateType(CompanyInfo::current());
        toCurrencyCode = CompanyInfoHelper::standardCurrency();

        // for any transaction not in the reporting currency, verify the exchange rate exists for currency conversion
        while select recid,ExchangeCode,TransDate from trvExpTrans
            where trvExpTrans.TrvExpTable == this.RecId
             && trvExpTrans.ExchangeCode != toCurrencyCode
        {
            if (!exchRateCalc)
            {
                exchRateCalc = ExchangeRateCalculation::newCurrencyToCurrencyWithType(defaultExchangeRateType, trvExpTrans.ExchangeCode, toCurrencyCode);
            }
            else
            {
                exchRateCalc.parmFromCurrency(trvExpTrans.ExchangeCode);
            }
            exchRateCalc.parmExchangeDate(trvExpTrans.TransDate);
            exchangeRate = exchRateCalc.getCrossRate();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the current expense transaction can be deleted.
    /// </summary>
    /// <param name="_throwError">
    ///     Boolean value that indicates whether to throw an infolog error if validate fails. Defaulted to true.
    /// </param>
    /// <returns>True if the expense can be deleted, false otherwise.</returns>
    public boolean validateDelete(boolean _throwError = true)
    {
        boolean ret;

        ret = super();

        // If framework validation succeeds, then check additional validation.
        if (ret)
        {
            if (this.ApprovalStatus != TrvAppStatus::Create)
            {
                ret = _throwError ? checkFailed("@SYS101496") : false;
            }
            else if (TrvWorkflowUtilities::recordHasActiveWorkItem(this))
            {
                ret = _throwError ? checkFailed("@Expense:WorkflowRecordDeleteError") : false;
            }
            else if (!TrvAccessHelper::canCreateNewTransactions(this.CreatingWorker))
            {
                ret = _throwError ? checkFailed("@Expense:ExpenseReportNotEditable") : false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _p1)
    {
        TrvParameters trvParameters = TrvParameters::find();
        boolean ret;

        ret = super(_p1);

        switch (_p1)
        {
            case (fieldNum(TrvExpTable, ProjId)):
                ret = ret && this.validateProject(false); // do not validate the projects on expense lines.
                break;

            case (fieldNum(TrvExpTable,Txt2)):
                ret = ret && this.validateTravelPurpose();
                break;

            case (fieldNum(TrvExpTable, InterCompanyLE)):
                if (this.InterCompanyLE != this.ReferenceDataAreaId)
                {
                    if (!trvParameters.UseInterCompanyExpense)
                    {
                        ret = ret && checkFailed("@Expense:IntercompanyDisabledError");
                    }

                    if (LedgerInterCompany::findCompanyPair(this.ReferenceDataAreaId, this.InterCompanyLE).RecId == 0)
                    {
                        ret = ret && checkFailed(strFmt("@SYS113857", this.ReferenceDataAreaId, this.InterCompanyLE));
                    }
                }

                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates an expense report before it can be posted.
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false
    /// </returns>
    /// <remarks>
    /// The validations that include budget errors and tax recovery verification.
    /// </remarks>
    public boolean validatePost()
    {
        TrvParameters   trvParameters = TrvParameters::find();
        boolean         retval = true;
        TrvExpTrans     trvExpTrans;

        // verify tax recovery
        if (TrvParametersTableHelper::isTaxRecoveryEnabled(trvParameters))
        {
            if (!this.validateTransactionsForTaxRecovery())
            {
                warning(strFmt("@SYS134509", this.ExpNumber));
                retval = false;
            }
        }

        if (!this.validateProject())
        {
            return false;
        }

        // Validates the exchange rate setup for the currency code used.
        if (!this.validateExchRateSetup())
        {
            return false;
        }

        // Create taxUncommitted, if taxUncommitted doesn't exist and is needed.
        while select * from trvExpTrans
                where trvExpTrans.TrvExpTable== this.RecId
                    && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                    && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
                    && trvExpTrans.TaxGroup != ''
                    && trvExpTrans.TaxItemGroup != ''
                    && trvExpTrans.ApprovalStatus == TrvAppStatus::Approved
        {
            trvExpTrans.createTaxUncommitted(false);
        }

        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the project that is used in the expense header and lines are valid.
    /// </summary>
    /// <param name="validateProjectOnLinesAsWell">
    /// A Boolean value that indicates whether to validate the projects of the expense lines of the expense
    /// header also.
    /// </param>
    /// <returns>
    /// false if any project that is used is not valid; otherwise, true.
    /// </returns>
    /// <remarks>
    /// This is to be called during the submission and posting.
    /// </remarks>
    private boolean validateProject(boolean validateProjectOnLinesAsWell = true)
    {
        TrvExpTrans     trvExpTrans;
        ProjTable       projTable;
        boolean         ret = true;
        TrvLegalEntity  legalEntity;

        // Validate project id used in the header
        if (this.ProjId)
        {
            changecompany (this.intercompanyLegalEntityName())
            {
                projTable = ProjTable::find(this.ProjId);

                if (!projTable.RecId)
                {
                    ret = ret && checkFailed(strFmt("@Expense:TableFieldFKViolationMessage",
                                                        this.ProjId,
                                                        fieldpname(TrvExpTable, ProjId),
                                                        tablepname(ProjTable)));
                }

                if (ret && !projTable.status().validateWriteCreateJournal())
                {
                    // validateWriteCreateJournal will give failure message
                    ret = false;
                }
                if (ret && projTable.Type == ProjType::Time)
                {
                    ret = checkFailed(strFmt("@SYS53011", ProjType::Time));
                }
            }
        }

        if (validateProjectOnLinesAsWell)
        {
            // Validate project id used in the lines
            while select ProjId, InterCompanyLE, ReferenceDataAreaId from trvExpTrans
                where trvExpTrans.TrvExpTable== this.RecId  &&
                    trvExpTrans.ProjId != ""
            {
                legalEntity = trvExpTrans.InterCompanyLE != '' ? trvExpTrans.InterCompanyLE : trvExpTrans.ReferenceDataAreaId;
                if  (legalEntity == '')
                {
                    legalEntity = curext();
                }

                changecompany(legalEntity)
                {
                    projTable = ProjTable::find(trvExpTrans.ProjId);
                    if (!projTable.status().validateWriteCreateJournal())
                    {
                        ret = false;
                    }
                    if (projTable.Type == ProjType::Time)
                    {
                        ret = checkFailed(strFmt("@SYS53011", ProjType::Time));
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransactionDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates there are no future dated expense lines on the expense report
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
	public boolean validateTransactionDates()
    {
        boolean ret = true;

        TrvExpTrans trvExpTrans;
        TrvDateStd currentDate = TrvExpenseHelper::getUserPreferredTimeZoneDate();

        select firstonly RecId, CostType, TransDate, AmountMST from trvExpTrans
            where trvExpTrans.TrvExpTable == this.RecId
            && trvExpTrans.TransDate > currentDate
            && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        if (trvExpTrans.RecId)
        {
            ret = checkFailed(strFmt("@Expense:FailedSubmitBecauseFutureDatedRecord", trvExpTrans.CostType, trvExpTrans.TransDate, trvExpTrans.AmountMST));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGiftAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates Gift amount more than transaction amount on expense report
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    public boolean validateGiftAmount()
    {
        boolean ret = true;
        TrvExpTrans trvExpTrans;
        TrvExpTransGuest trvExpTransGuest;
		        
        while select TrvExpTable, RecId, ExpType, AmountCurr from trvExpTrans 
            where trvExpTrans.TrvExpTable == this.RecId
            && trvExpTrans.ExpType == TrvExpType::Gift
        {
            select sum(AmountCurr) from trvExpTransGuest
            where trvExpTrans.RecId == trvExpTransGuest.TrvExpTrans;
            if (trvExpTransGuest.AmountCurr > trvExpTrans.AmountCurr)
            {
                ret = checkFailed("@Expense:GiftAmountMoreThanExpenseAmount");
                break;
            }
        }
       
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFromAddressToAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates from address and to address of mileage cost type on an expense report
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    public boolean validateFromAddressToAddress()
    {
        boolean ret = true;

        TrvExpTrans trvExpTrans;
       
        select firstonly RecId from trvExpTrans
            where trvExpTrans.TrvExpTable == this.RecId
                && trvExpTrans.ExpType == TrvExpType::Transport
                && (trvExpTrans.MileageFromAddress == '' || trvExpTrans.MileageToAddress == '');
  
        if (trvExpTrans.RecId)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePerDiemDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the date range on any allowance based expense lines associated with expense report
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    public boolean validatePerDiemDates()
    {
        boolean ret = true;

        TrvExpTrans trvExpTrans;
        utcdatetime currentDateTime = DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), Global::timeMax());

        select firstonly RecId, ExpType, DateFrom, DateTo, CostType, TransDate, AmountMST from trvExpTrans
			where trvExpTrans.TrvExpTable == this.RecId
			&& trvExpTrans.ExpType == TrvExpType::Allowance
            && (trvExpTrans.DateTo > currentDateTime || trvExpTrans.DateTo < TrvExpTrans.DateFrom
            || (trvExpTrans.DateTo == TrvExpTrans.DateFrom
                && TrvParameters::find().PerDiemCalculation != TrvPerDiemCalculation::CalendarDayNoTime))
            && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        if (trvExpTrans.RecId)
        {
            ret = checkFailed(strFmt("@Expense:FailedSubmitBecauseInvalidPerDiemDateRange", trvExpTrans.CostType, trvExpTrans.TransDate, trvExpTrans.AmountMST));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSubmit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates an expense report before it can be submitted.
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The validation includes additional field validation, incomplete distributions, incomplete
    /// itemization, policy errors, and budget errors.
    /// </remarks>
    public boolean validateSubmit()
    {
        // <GEERU>
        #ISOCountryRegionCodes
        // <GEERU>

        TrvParameters                   trvParameters = TrvParameters::find();
        TrvExpTrans                     trvExpTrans;
        AccountingDistribution          accountingDistribution;
        boolean                         personalPaidByEmployee = (trvParameters.PersonalPaidBy == TrvPersonalPaidBy::Employee);
        TrvExpTableTrvRequisitionTable  trvExpTableTrvRequisitionTable;

        if (this.RecId == 0)
        {
            error("@SYS341905");
            return false;
        }

        // The expense report cannot be submitted if the workflow status is such that it is not editable (status is not create or returned).
        if (!this.isEditableBasedOnWorkflowStatus())
        {
            error("@SYS4009492");
            return false;
        }

        if (!TrvAccessHelper::userHasCurrentDelegateAccessFor(this.CreatingWorker))
        {
            error("@SYS4007719");
            return false;
        }

        // Check if creating worker has employment in current legal entity or has delegate access.
        if (!TrvAccessHelper::canCreateNewTransactions(this.CreatingWorker))
        {
            return false;
        }

        // Inactive categories
        if (!this.validateCostTypeIsInactive())
        {
            checkFailed("@Expense:InactiveCategoriesExpenseSubmitFailed");
            return false;
        }

        if (!this.validateTransactionDates())
        {
            return false;
        }

        if (!this.validatePerDiemDates())
        {
            return false;
        }      

        if (trvParameters.ApproverHierarchyDisplay != TrvApproverHierarchyFields::None && !this.FinalApprover)
        {
            error("@Expense:FinalApproverRequired");
            return false;
        }

        // Create source document lines (and perform related calculations) if they don't exist yet.
        while select RecId from trvExpTrans
                where trvExpTrans.TrvExpTable == this.RecId
                   && trvExpTrans.SourceDocumentLine == 0
        {
            // Create only source document lines and skip policy evaluation here. It will be done later.
            TrvExpTrans::handleSourceDocumentAndPolicies(trvExpTrans.RecId, false);
        }

        // create distributions if they don't exist
        while select * from trvExpTrans
                where trvExpTrans.TrvExpTable == this.RecId
                   && trvExpTrans.SourceDocumentLine != 0
            notexists join accountingDistribution
                where accountingDistribution.SourceDocumentLine == trvExpTrans.SourceDocumentLine
        {
            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(trvExpTrans, false, SourceDocumentLineAccountingStatus::FullyDistributed);
        }

        // check for incomplete distributions
        while select trvExpTrans where trvExpTrans.TrvExpTable== this.RecId
                                    && trvExpTrans.LineType    != TrvExpLineType::ItemizedHeader
                                    && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
                                    && !(trvExpTrans.ExpType   == TrvExpType::Personal && personalPaidByEmployee)
        {
            // only check distributions for lines for which distributions are created
            if (!trvExpTrans.isDistributionsCompleted())
            {
                error("@SYS340881");
                return false;
            }
        }

        if (TrvRemoveExtraSDLForExpenseReportFlight::instance().isEnabled())
        {
            //Check and remove extra SDL which is not related to any expense lines
            TrvExpTable::checkAndRemoveExtraSDL(this.SourceDocumentHeader);
        }
        
        if (!this.validateAntiCorruption(MessageSeverity::Error))
        {
            return false;
        }
        
        if (!this.validateProject())
        {
            return false;
        }

        // Validates the exchange rate setup for the currency code used.
        if (!this.validateExchRateSetup())
        {
            return false;
        }

        if (!this.validateGiftAmount())
        {
            return false;
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoDK]) && !this.validateFromAddressToAddress())
        {
            error("@Expense:MileageFromAndToAddressesAreNotSpecified");
            return false;
        }
        // <GEERU>

        if (this.checkLedgerDimension())
        {
            error("@SYS138712");
            return false;
        }

        TrvPolicyEvalEngine::evaluateViolationsForHdr(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);
        TrvPolicyEvalEngine::evaluatePoliciesForAllLines(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);

        if (!this.canBeSubmitted())
        {
            error("@Expense:CannotBeSubmittedDetailedError");
            return false;
        }

        TrvBudgetCheckHelper::checkBudgetForAllLines(this);

        if (!trvParameters.IsAllowSubmitExpenseOnBudgetFail && (TrvBudgetCheckHelper::isBudgetFailed(this.RecId) || TrvBudgetCheckHelper::isProjBudgetFailed(this.RecId)) )
        {
            error(strFmt("@Expense:ExpenseOrRequisitionBudgetSubmitFailed", "@SYS330421", this.ExpNumber));
            return false;
        }

        if (trvParameters.IsTravelRequisitionMandatoryForExpense)
        {
            select firstonly TrvRequisitionTable from trvExpTableTrvRequisitionTable
                where trvExpTableTrvRequisitionTable.TrvExpTable== this.RecId;

            if (!trvExpTableTrvRequisitionTable.TrvRequisitionTable)
            {
                error("@SYS191405");
                return false;
            }
            else
            {
                if (!this.validateMandatoryTravelRequisitionLine())
                {
                    return false;
                }
            }
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) &&
            ProjFundingLimitTrackingManager::hasLimitErrorSourceDocument(this.SourceDocumentHeader))
        {
            error("@SYS4110061");
            return false;
        }

        if (!TrvExpTrans::validateExpensesForItemization(this.RecId))
        {
            error("@Expense:ItemizationRequired");
            return false;
        }

        if (!TrvReturnCashHelper::validateReturnCashAdvanceExpenses(this.RecId))
        {
            error("@Expense:ReturnCashAdvanceBalanceCheck");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAndRemoveExtraSDL</Name>
				<Source><![CDATA[
    public static void checkAndRemoveExtraSDL(RefRecId _sourceDocumentHeader)
    {
        SourceDocumentLine sourceDocumentLine;
        TrvExpTrans expLine;

        ttsbegin;
        delete_from sourceDocumentLine
            where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeader
                && sourceDocumentLine.ParentSourceDocumentLine == 0
                    notexists join expLine
                        where expLine.SourceDocumentLine == sourceDocumentLine.RecId;

        delete_from sourceDocumentLine
            where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeader
                && sourceDocumentLine.ParentSourceDocumentLine != 0
                    notexists join expLine
                        where expLine.SourceDocumentLine == sourceDocumentLine.ParentSourceDocumentLine;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates Accounting distributions ledger dimension value.
    /// </summary>
    /// <returns>
    /// Returns true if ledger dimensions are not valid; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean checkLedgerDimension()
    {
        TrvExpTrans trvExpTrans;
        AccountingDistribution accountingDistribution;
        boolean invalidLedgerDimension = false;
        str expenseLineCaption;

        // Validate the ledger dimension value of the accounting distributions
        while select AccountingLegalEntity, LedgerDimension, AccountingDate, SourceDocumentLine, Number from accountingDistribution
            order by accountingDistribution.SourceDocumentLine
            where accountingDistribution.SourceDocumentHeader == this.SourceDocumentHeader
        {
            if (trvExpTrans.SourceDocumentLine != accountingDistribution.SourceDocumentLine)
            {
                // For each distinct expense line, retrieve its caption. This block will be executed in the first iteration
                // of the while loop since trvExpTrans.SourceDocumentLine == 0 initially.
                trvExpTrans = TrvExpTrans::findBySourceDocumentLine(accountingDistribution.SourceDocumentLine);
                expenseLineCaption = trvExpTrans.generateCaption();
            }

            setPrefix("@Expense:ExpenseReportHasInvalidDistributions");
            setPrefix(strFmt("@Expense:ExpenseLineDistributionCaptionFormat", expenseLineCaption, accountingDistribution.Number));

            if (accountingDistribution.LedgerDimension == 0)
            {
                invalidLedgerDimension = true;
                error("@Expense:InvalidLedgerDimension");
                break;
            }
            else if (!TrvExpTable::validateLedgerDimension(accountingDistribution.AccountingLegalEntity, accountingDistribution.LedgerDimension, accountingDistribution.AccountingDate))
            {
                invalidLedgerDimension = true;
            }
        }

        return invalidLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAntiCorruption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the anti-corruption setting is in sync with the expense lines.
    /// </summary>
    /// <param name="_severity">
    /// The severity of message to be displayed to the user for any validation issues.
    /// </param>
    /// <returns>True if the validation was sucessful, otherwise false.</returns>
    boolean validateAntiCorruption(MessageSeverity _severity = MessageSeverity::Warning)
    {
        if (TrvParameters::find().UseAntiCorruption)
        {
            TrvExpTrans expLines;
            TrvCostType category;

            select firstonly RecId from expLines where expLines.ExpNumber == this.ExpNumber
                        join category where expLines.CostType == category.CostType && category.IsGovernment;

            if (this.AntiCorruptionSubmitterFlag && !expLines.RecId)
            {
                infolog.insertMessage(_severity, "@Expense:NoAntiCorruptionCategory");
                return false;
            }
            else if (!this.AntiCorruptionSubmitterFlag && expLines.RecId)
            {
                infolog.insertMessage(_severity, "@Expense:AntiCorruptionAttestationMissingSubmitter");
                return false;
            }
            else if (this.AntiCorruptionSubmitterFlag && ! this.AntiCorruptionApproverFlag && this.ApprovalStatus == TrvAppStatus::Pending)
            {
                infolog.insertMessage(_severity, "@Expense:AntiCorruptionAttestationMissingApprover");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransactionsForTaxRecovery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the tax information is filled for the eligible expense lines.
    /// </summary>
    /// <returns>
    /// true if all eligible lines have tax information filled; otherwise; false.
    /// </returns>
    /// <remarks>
    /// This method is used for validation before posting.
    /// </remarks>
    boolean validateTransactionsForTaxRecovery()
    {
        TrvExpTrans trvExpTrans;

        while select ExpType, TaxGroup, TaxItemGroup, LineType,SubCategoryRecId from trvExpTrans
                                           where trvExpTrans.TrvExpTable== this.RecId
                                              && trvExpTrans.ExpType != TrvExpType::Advance
                                              && trvExpTrans.ExpType != TrvExpType::Personal
                                              && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                                              && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
                                              && (trvExpTrans.ApprovalStatus == TrvAppStatus::Ready || trvExpTrans.ApprovalStatus == TrvAppStatus::Approved)
        {
            if (trvExpTrans.isTaxFieldsMandatory() && (!trvExpTrans.TaxGroup || !trvExpTrans.TaxItemGroup))
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean         ret;
        ProjTable       projTable;

        ret = super();

        if (this.ProjId)
        {
            changecompany (this.intercompanyLegalEntityName())
            {
                projTable = ProjTable::find(this.ProjId);
                if ((projTable.Status == ProjStatus::Completed) || (projTable.Header == NoYes::Yes))
                {
                    ret = ret && checkFailed("@SYS341926");
                }
            }
        }

        //Check if the creating worker is employed only if the he is the current logged in employee
        //current logged in user can create expense reports on behalf of terminated employees, if he has delegate access
        if ((this.CreatingWorker == HcmWorkerLookup::currentWorker()) && (TrvPartyEmployeeRelationship::getWorkerStatus(this.CreatingWorker) == HcmWorkerStatus::Terminated))
        {
            ret = ret && checkFailed("@SYS125812");
        }

        ret = ret && this.validateTravelPurpose();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    static boolean checkExist(TrvExpNumber expNumber)
    {
        boolean ret = true;

        if (expNumber && !TrvExpTable::exist(expNumber))
        {
            ret = checkFailed(strFmt(TrvExpTable::txtNotExist(), expNumber));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the specified <c>TrvExpTable</c> record, after confirming it can be deleted.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the <c>TrvExpTable</c> record that will be deleted.
    /// </param>
    public static void deleteRecId(RecId _recId)
    {
        TrvExpTable trvExpTable;

        ttsbegin;
        select firstonly forupdate trvExpTable where trvExpTable.RecId == _recId;
        if (trvExpTable)
        {
            if (trvExpTable.validateDelete())
            {
                trvExpTable.delete();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    public static boolean exist(TrvExpNumber expNumber)
    {
        return (select firstonly RecId from trvExpTable where trvExpTable.ExpNumber == expNumber && trvExpTable.LegalEntity == CompanyInfo::current()).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByRecId</Name>
				<Source><![CDATA[
    public static boolean existByRecId(RefRecId _expTableRecId)
    {
        return (select firstonly RecId from trvExpTable where trvExpTable.RecId == _expTableRecId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    public static TrvExpTable find(TrvExpNumber _expNumber, boolean _forUpdate = false)
    {
        TrvExpTable trvExpTable;

        if (_expNumber)
        {
            trvExpTable.selectForUpdate(_forUpdate);

            select firstonly trvExpTable where trvExpTable.ExpNumber == _expNumber && trvExpTable.LegalEntity == CompanyInfo::current();
        }

        return trvExpTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySourceDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the expense report by using the specified source document header.
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    /// The record ID of the source document header.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the retrieved buffer is selected for update.
    /// </param>
    /// <returns>
    /// The expense report record.
    /// </returns>
    public static TrvExpTable findBySourceDocumentHeader(RefRecId _sourceDocumentHeader, boolean _forUpdate=false)
    {
        TrvExpTable    trvExpTable;

        if (_sourceDocumentHeader)
        {
            trvExpTable.selectForUpdate(_forUpdate);
            select firstonly trvExpTable
                where trvExpTable.SourceDocumentHeader == _sourceDocumentHeader;
        }

        return trvExpTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the expense report by using the specified source document line.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    /// The record ID of the source document line.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the retrieved buffer is selected for update.
    /// </param>
    /// <returns>
    /// The expense report record.
    /// </returns>
    public static TrvExpTable findBySourceDocumentLine(RefRecId _sourceDocumentLine, boolean _forUpdate = false)
    {
        TrvExpTable    trvExpTable;

        if (_sourceDocumentLine)
        {
            trvExpTable.selectForUpdate(_forUpdate);
            select firstonly trvExpTable
                where trvExpTable.SourceDocumentLine == _sourceDocumentLine;
        }

        return trvExpTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the expense report by using the specified record ID.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the expense report.
    /// </param>
    /// <param name="_forUpdate">
    /// If the record should be selected for update.
    /// </param>
    /// <returns>
    /// The expense report record.
    /// </returns>
    public static TrvExpTable findRecId(RecId _recId, boolean _forUpdate = false)
    {
        TrvExpTable trvExpTable;

        trvExpTable.selectForUpdate(_forUpdate);

        select firstonly trvExpTable where trvExpTable.RecId == _recId;

        return trvExpTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWorkItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>WorkflowWorkItemTable</c> table for a corresponding <c>TrvExpTable</c> table.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of a record in a <c>TrvExpTable</c> table.
    /// </param>
    /// <returns>
    /// A <c>WorkflowWorkItemTable</c> table for the corresponding <c>TrvExpTable</c> table.
    /// </returns>
    public static WorkflowWorkItemTable findWorkItem(RecId _recId)
    {
        SysWorkflowTable                sysWorkflowTableHeader, sysWorkflowTableLine;
        WorkflowWorkItemTable           workItemTable;
        WorkflowCorrelationId           correlationId;

        select firstonly WorkflowCorrelationId from sysWorkflowTableHeader
            where sysWorkflowTableHeader.ContextTableId == tableNum(TrvExpTable)
            && sysWorkflowTableHeader.ContextRecId == _recId;

        correlationId = sysWorkflowTableHeader.WorkflowCorrelationId;

        if (!SysWorkflowTable::isRootWorkflow(correlationId) && !sysWorkflowTableHeader)
        {
            select firstonly WorkflowCorrelationId from sysWorkflowTableLine where sysWorkflowTableLine.ParentCorrelationId == correlationId;
            correlationId = sysWorkflowTableLine.WorkflowCorrelationId;
        }

        select firstonly workItemTable
            where workItemTable.CorrelationId == correlationId
            && workItemTable.Status != WorkflowWorkItemStatus::Completed;

        return workItemTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertNewRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new expense report.
    /// </summary>
    /// <param name="_worker">
    /// The record ID of the worker for whom the expense report is compiled; optional.
    /// </param>
    /// <returns>
    /// The expense report record that was created.
    /// </returns>
    public static TrvExpTable insertNewRecord(TrvHcmWorkerRecId _worker = 0)
    {
        TrvExpTable         insertTrvExpTable;
        NumberSeq           numberSeqTrvExpense;

        _worker = _worker ? _worker : HcmWorkerLookup::currentWorker();

        numberSeqTrvExpense = NumberSeq::newGetNum(TrvParameters::numRefExpNumber(),
                                                    false,
                                                    true); // do not throw
        if (numberSeqTrvExpense)
        {
            insertTrvExpTable.ExpNumber = numberSeqTrvExpense.num();
            insertTrvExpTable.CreatingWorker = _worker;
            insertTrvExpTable.initValue();
            ttsbegin;
            insertTrvExpTable.insert();
            ttscommit;
        }
        else
        {
            // number sequence not setup error
            error("@SYS78057");
        }

        return insertTrvExpTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    static TxtNotExist txtNotExist()
    {
        return "@SYS102079";
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLineStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates all the expense lines for the expense report provided to the status provided.
    /// </summary>
    /// <param name = "_expNumber">The expense report number for which to update the expense lines.</param>
    /// <param name = "_status">The new status of the expense lines.</param>
    public static void updateLineStatus(TrvExpNumber _expNumber, TrvAppStatus _status)
    {
        TrvExpTrans trvExpTrans;
        TrvExpTable trvExpTable;

        trvExpTable = TrvExpTable::find(_expNumber);

        if (trvExpTable)
        {
            update_recordset trvExpTrans setting ApprovalStatus = _status where trvExpTrans.TrvExpTable== trvExpTable.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the specified ledger dimension.
    /// </summary>
    /// <param name="_legalEntityRecId">
    /// The legal entity record ID of the company in which the validation is performed.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension to validate.
    /// </param>
    /// <param name="_date">
    /// A date to use to validate the ledger dimension.
    /// </param>
    /// <returns>
    /// true if the ledger dimension is valid; otherwise, false.
    /// </returns>
    public static boolean validateLedgerDimension(LegalEntityRecId _legalEntityRecId, LedgerDimensionAccount _ledgerDimension, TransDate _date)
    {
        DimensionValidationStatus   dimensionValidationStatus = DimensionValidationStatus::Valid;
        CompanyId                   companyId;
        LedgerDimensionAccount      ledgerDimension;

        // we return true for empty ledger dimension, since we allow submission with empty account distribution ledger dimension value
        if (_ledgerDimension != 0)
        {
            companyId = CompanyInfo::findRecId(_legalEntityRecId).DataArea;

            if (!companyId)
            {
                return false;
            }

            changecompany(companyId)
            {
                MainAccountRecId mainAccountRecId = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_ledgerDimension);

                if (!mainAccountRecId)
                {
                    ledgerDimension = _ledgerDimension;
                }
                else
                {
                    ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(LedgerDimensionFacade::serviceApplyFixedDimensions(_ledgerDimension));
                }

                dimensionValidationStatus = LedgerDimensionValidationHelper::validateByTree(ledgerDimension, _date, true, true);
            }
        }

        return dimensionValidationStatus == DimensionValidationStatus::Valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyDayOrReportProjectPolicyViolations</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns whether the expense report has any expense line with any project policy violations on day or report level.
    /// </summary>
    /// <returns>
    ///     True if any expense line has project policy violations, false otherwise.
    /// </returns>
    public boolean anyDayOrReportProjectPolicyViolations()
    {
        TrvExpTrans trvExpTrans;

        while select trvExpTrans where trvExpTrans.TrvExpTable == this.RecId
        {
            if (trvExpTrans.anyDayOrReportProjectPolicyViolations())
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjPolicies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the expense report or its lines have any project policy violations.
    /// </summary>
    /// <param name="_updateReImburseAmt">
    /// Whether the fields like ReimburseAmt and InvoiceAmt should be updated.
    /// For perf reasons, this update is not done until the submit.
    /// </param>
    /// <returns>
    /// True if the expense report is valid; otherwise, false.
    /// </returns>
    public boolean validateProjPolicies(boolean _updateReImburseAmt = true)
    {
        boolean                   ret = true;

        ProjExpPolicyStatus       sValidationStatus;
        ProjExpPolicyEngine       expPolicyEngine = new ProjExpPolicyEngine();

        this.evaluateProjectPoliciesForLines();

        if (this.anyProjectPolicyErrorsForLines())
        {
            ret = false;
        }

        changecompany (this.intercompanyLegalEntityName())
        {
            sValidationStatus = expPolicyEngine.validateProjExpPoliciesDay(this.RecId, this.CreatingWorker, this.ProjId, _updateReImburseAmt);
            if (sValidationStatus == ProjExpPolicyStatus::DayFailed)
            {
                ret = false;
            }

            sValidationStatus = expPolicyEngine.validateProjExpPoliciesReport(this.RecId, this.CreatingWorker, this.ProjId, _updateReImburseAmt);
            if (sValidationStatus == ProjExpPolicyStatus::ReportFailed)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Will default the field specified
    /// </summary>
    /// <param name = "_fieldId">The field that should be defaulted.</param>
    public void defaultField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(TrvExpTable, ExpNumber) :
                if (!this.isFieldSet(_fieldId) && !this.ExpNumber)
                {
                    this.ExpNumber = NumberSeq::newGetNum(TrvParameters::numRefExpNumber()).num();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultingDependencies</Name>
				<Source><![CDATA[
    public container getDefaultingDependencies()
    {
        container ret;

        ret =
        [
            [fieldNum(TrvExpTable, ExpNumber)]
        ];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtension</Name>
				<Source><![CDATA[
    public TableExtension getExtension()
    {
        TableExtension ret;

        ret = SysTableExtension::construct();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSubmitToWorkflowActionAvailable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the expense report can be submitted, based on business rules and document status.
    /// </summary>
    /// <returns>True if the expense report can be submitted, otherwise False.</returns>
    public boolean isSubmitToWorkflowActionAvailable()
    {
        boolean ret;

        ret = this.canBeSubmitted();
        ret = ret && (this.ApprovalStatus == TrvAppStatus::Create);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>duplicateExpenseReport</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Duplicates the current expense report
    /// </summary>
    /// <returns>
    ///     Recid of the duplicated expense report
    /// </returns>
    public RefRecId duplicateExpenseReport(TrvDateShift _trvDateShift = TrvDateShift::Today,
                                            date _transactionDate = TrvExpenseHelper::getUserPreferredTimeZoneDate(),
                                            TrvDatePeriod _trvDatePeriod = TrvDatePeriod::Days,
                                            int _numOf = 0)
    {
        // Expense report must be saved in order to duplicate
        if (!this.RecId)
        {
            error("@Expense:SaveReportBeforeDuplicating");
        }

        // Make sure all fields have been selected;
        TrvExpTable oldExpenseReport = TrvExpTable::findRecId(this.RecId);

        // Ensure number sequence is setup properly
        NumberSeq numberSeqTrvExpense = NumberSeq::newGetNum(TrvParameters::numRefExpNumber(), false, true);
        if (!numberSeqTrvExpense)
        {
            error("@Expense:NumSeqErrorForExpenseReports");
        }

        TrvExpTable newExpenseReport;
        newExpenseReport.data(oldExpenseReport);

        newExpenseReport.RecId = 0;
        newExpenseReport.ExpNumber = numberSeqTrvExpense.num();
        newExpenseReport.ApprovalStatus = TrvAppStatus::Create;
        newExpenseReport.PostedDate = DateTimeUtil::date(DateTimeUtil::minValue());
        newExpenseReport.SourceDocumentHeader = 0;
        newExpenseReport.SourceDocumentLine = 0;
        newExpenseReport.AntiCorruptionApproverFlag = NoYes::No;
        newExpenseReport.AntiCorruptionSubmitterFlag = NoYes::No;
        
        newExpenseReport.PaymentDate = DateTimeUtil::date(DateTimeUtil::minValue());
        newExpenseReport.PaymentVoucher = '';
        newExpenseReport.InvoiceId = '';

        ttsbegin;
        newExpenseReport.insert();
        ttscommit;

        date transactionDate;
        if (_trvDateShift == TrvDateShift::Today)
        {
            transactionDate = TrvExpenseHelper::getUserPreferredTimeZoneDate();
        }
        else if (_trvDateShift == TrvDateShift::SpecifyDate)
        {
            transactionDate = _transactionDate;
        }

        TrvExpTrans expenseLine;
        while select RecId, TransDate from expenseLine where expenseLine.TrvExpTable == oldExpenseReport.RecId && expenseLine.ParentRecId == 0
        {
            if (_trvDateShift == TrvDateShift::Advance)
            {
                // Calculate transaction date to use based on original line
                transactionDate = TrvExpenseHelper::advanceDate(expenseLine.TransDate, _trvDatePeriod, _numOf);
            }

            expenseLine.duplicateExpenseLine(newExpenseReport.RecId, transactionDate);
        }

        return newExpenseReport.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasExpenseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the current expense report has any expense lines.
    /// </summary>
    /// <returns>
    /// True if the report contains at least one expense line, else False.
    /// </returns>
    public boolean hasExpenseLines()
    {
        TrvExpTrans expense;

        select firstonly RecId from expense
                    where expense.TrvExpTable == this.RecId;

        return (expense.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSubmitToWorkflow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submit action will be visible for a report in draft that has one or more lines.
    /// </summary>
    /// <param name = "_workflowType">Workflow Type</param>
    /// <returns>True if the report can be submitted; false otherwise.</returns>
    public boolean canSubmitToWorkflow(str _workflowType = '')
    {
        return this
            && this.ApprovalStatus == TrvAppStatus::Create
            && this.hasExpenseLines();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfExpenseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of expense lines (itemized or not) for a given expense report.
    /// </summary>
    /// <param name = "_headerRecId">The RecId of the expense report.</param>
    /// <returns>The number of expense lines (including itemization) for the given expense report.</returns>
    public static int getNumberOfExpenseLines(RefRecId _headerRecId)
    {
        TrvExpTrans trvExpTrans;

        select count(RecId) from trvExpTrans where trvExpTrans.TrvExpTable == _headerRecid;

        return int642int(trvExpTrans.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfNonItemizationExpenseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of expense lines that are not itemization lines for a given expense report record.
    /// </summary>
    /// <param name="_headerRecId">
    /// The RecId of the expense report.
    /// </param>
    /// <returns>
    /// The number of non-itemization lines for the given expense report.
    /// </returns>
    public static int getNumberOfNonItemizationExpenseLines(RefRecId _headerRecId)
    {
        TrvExpTrans trvExpTrans;

        select count(RecId) from trvExpTrans where trvExpTrans.TrvExpTable == _headerRecid &&
            trvExpTrans.LineType != TrvExpLineType::ItemizedLine &&
            trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;


        return int642int(trvExpTrans.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfItemizedExpenseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of expense lines that are itemization lines for a given expense report record.
    /// </summary>
    /// <param name="_headerRecId">
    /// The RecId of the expense report.
    /// </param>
    /// <returns>
    /// The number of itemization lines for the given expense report.
    /// </returns>
    public static int getNumberOfItemizedExpenseLines(RefRecId _headerRecId)
    {
        TrvExpTrans trvExpTrans;

        select count(RecId) from trvExpTrans where trvExpTrans.TrvExpTable == _headerRecid &&
                trvExpTrans.LineType == TrvExpLineType::ItemizedLine;

        return int642int(trvExpTrans.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyLegalEntityName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the legal entity name selected by the user.
    /// </summary>
    /// <returns>
    /// The first of [this.InterCompanyLE, this.ReferenceDataAreaId, curext()] that is not empty.
    /// </returns>
    public SelectableDataArea intercompanyLegalEntityName()
    {
        SelectableDataArea ret;

        if (this.InterCompanyLE != '')
        {
            ret = this.InterCompanyLE;
        }
        else if (this.ReferenceDataAreaId != '')
        {
            ret = this.ReferenceDataAreaId;
        }
        else
        {
            ret = curExt();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the expense header is intercompany.
    /// </summary>
    /// <returns>
    /// true if this is an intercompany header; false otherwise.
    /// </returns>
    public boolean isIntercompany()
    {
        return (this.InterCompanyLE && this.InterCompanyLE != this.ReferenceDataAreaId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIntercompanyWithProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the expense header is intercompany and with project.
    /// </summary>
    /// <returns>
    /// true if this is an intercompany header with project; false otherwise.
    /// </returns>
    public boolean isIntercompanyWithProject()
    {
        return this.isIntercompany() && this.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeRequisition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs insert, update and delete on the linked table TrvExpTableTrvRequisitionTable
    /// </summary>
    /// <param name = "_trvRequisitionNumber">Travel requisition number.</param>
    /// <param name = "_trvRequisitionTable">Travel requisition table <c>TravelRequisitionTable</c> buffer.</param>
    public void changeRequisition(TrvRequisitionNumber _trvRequisitionNumber, TrvRequisitionTable _trvRequisitionTable = null)
    {
        TrvExpTableTrvRequisitionTable  trvExpTableTrvRequisitionTable;
        TrvRequisitionTable             trvRequisitionTable;
        
        if (!_trvRequisitionTable)
        {
            trvRequisitionTable = TrvRequisitionTable::findByRequisitionNumber(_trvRequisitionNumber);
        }
        else
        {
            trvRequisitionTable = _trvRequisitionTable;
        }
        
        ttsbegin;
        if (this.isTravelRequisitionAssociated())
        {
            select firstonly forupdate trvExpTableTrvRequisitionTable
                where trvExpTableTrvRequisitionTable.TrvExpTable == this.RecId;

            if (trvRequisitionTable)
            {
                // On updating the existing requisition mapping, update the record in link table
                this.updateRequisitionOnExpenses(trvExpTableTrvRequisitionTable.TrvRequisitionTable);
                trvExpTableTrvRequisitionTable.TrvRequisitionTable = trvRequisitionTable.RecId;
                trvExpTableTrvRequisitionTable.update();
            }
            else
            {
                // On removing the existing requisition mapping, delete the record from link table
                this.updateRequisitionOnExpenses(trvExpTableTrvRequisitionTable.TrvRequisitionTable);
                trvExpTableTrvRequisitionTable.delete();
            }
        }
        else if (trvRequisitionTable)
        {
            // On adding the requisition mapping, insert the record in link table
            trvExpTableTrvRequisitionTable.TrvExpTable = this.RecId;
            trvExpTableTrvRequisitionTable.TrvRequisitionTable = trvRequisitionTable.RecId;
            trvExpTableTrvRequisitionTable.insert();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRequisitionOnExpenses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update expense report lines on removing or updating the existing travel requisition.
    /// </summary>
    /// <param name = "_recIdRequisitionTable">Travel requisition table RecId.</param>
    private void updateRequisitionOnExpenses(RefRecId _recIdRequisitionTable)
    {
        TrvExpTrans trvExpTrans;
        //Need to open the ReconcilitionStatus when the requisition is deleted for expense report ..
        while select forupdate trvExpTrans
            where trvExpTrans.TrvExpTable == this.RecId
        {
            trvExpTrans.IsPreAuthorized = 0;
            trvExpTrans.AccountingCurrencyReconciledAmount = 0;
            trvExpTrans.MappedToRequisitionLine = 0;
            trvExpTrans.doUpdate();

            TrvRequisitionTable::updateReconciliationStatus(_recIdRequisitionTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMandatoryTravelRequisitionLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates mapping of mandatory requisition line to expense line
    /// </summary>
    /// <returns>
    /// true if mandatory requisition line is mapped to expense line, otherwise false;
    /// </returns>
    public boolean validateMandatoryTravelRequisitionLine()
    {
        TrvExpTrans trvExpTrans;

        select firstonly RecId from trvExpTrans
            where trvExpTrans.TrvExpTable == this.RecId
                && trvExpTrans.MappedToRequisitionLine != 0;

        if (trvExpTrans.RecId == 0)
        {
            return checkFailed("@SYS191406");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCostTypeIsInactive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether cost type for any expense line on expense report are "inactive"
    /// </summary>
    /// <returns>
    /// True if expense line categories are inactive; otherwise, false.
    /// </returns>
    public boolean validateCostTypeIsInactive()
    {
        TrvExpTrans trvExpTrans;
        TrvCostType trvCostType;

        select firstonly RecId from trvExpTrans
            join trvCostType
            where trvExpTrans.CostType == trvCostType.CostType
                && trvExpTrans.TrvExpTable == this.RecId
                && trvCostType.IsInactive == NoYes::Yes;

        return trvExpTrans.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTravelPurpose</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether travel purpose for expense report is filled or not based on setup.
    /// </summary>
    /// <returns>
    /// True if travel purpose is filled; otherwise, false.
    /// </returns>
    private boolean validateTravelPurpose()
    {
        boolean ret = true;
        TrvParameters trvParameters = TrvParameters::find();

        if (trvParameters.ValidateTravelPurpose == NoYes::Yes && !TrvTravelTxt::find(this.Txt2).RecId)
        {
            ret = checkFailed(strFmt("@SYS101501",this.Txt2));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetProjCommittedCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reset Project commitment on workflow status reset
    /// </summary>
    public void resetProjCommittedCost()
    {
        if( this.ApprovalStatus == TrvAppStatus::Create)
        {
            ProjectCommitmentFacade::deleteProjectCommitmentsForDocument(this.SourceDocumentHeader);
            
        }
        else
        {
            throw error("@Expense:ExpenseReportProjCommittedCost");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAddRemoveAttachments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the receipts can be attached or removed from the current expense document or not. 
    /// </summary>
    /// <returns>
    /// true if the receipts can be attached, false otherwise.
    /// </returns>
    public boolean validateAddRemoveAttachments()
    {
        // Check if creating worker has employment in current legal entity or has delegate access.
        if (!TrvAccessHelper::canCreateNewTransactions(this.CreatingWorker))
        {
            return false;
        }

        // Check if the expense report has already been posted.
        if (this.ApprovalStatus == TrvAppStatus::Ledger)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMileageLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if there is any mileage line for the expense report.
    /// </summary>
    /// <returns>
    /// True, if mileage line is present; otherwise false.
    /// </returns>
    public boolean hasMileageLine()
    {
        TrvExpTrans trvExpTrans;

        select firstonly RecId from trvExpTrans
        where trvExpTrans.TrvExpTable== this.RecId
            && trvExpTrans.ExpType == TrvExpType::Transport
            && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        return trvExpTrans.RecId != 0? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCashAdvanceReturnLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if there is a cash advance return line for this expense report
    /// </summary>
    /// <returns>True, if there is a cash advance return line; Otherwise, false.</returns>
    public boolean hasCashAdvanceReturnLine()
    {
        TrvExpTrans trvExpTrans;

        select firstonly RecId from trvExpTrans
            where trvExpTrans.TrvExpTable == this.RecId
            &&  trvExpTrans.ExpType == TrvExpType::Advance;

        return trvExpTrans.RecId != 0? true: false;
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsAnyExpenseLineForGivenOwner</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if there is any expense line with given cost owner - Company, Customer or Employee.
    /// </summary>
    /// <param 
    /// name = "_costOwner">Owner of the expense-Company, Customer or Employee.
    /// </param>
    /// <returns>True, if any expense line exists for given expense owner; Otherwise, false.</returns>
    public boolean existsAnyExpenseLineForGivenOwner(TrvCostOwnerEDT _costOwner)
    {
        return (select firstonly RecId from TrvExpTrans 
                                        where TrvExpTrans.CostOwner == _costOwner && 
                                              TrvExpTrans.TrvExpTable == this.RecId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDistributionAllocation</Name>
				<Source><![CDATA[
    public void updateDistributionAllocation()
    {
        TrvExpTrans trvExpTrans;

        while select trvExpTrans where trvExpTrans.TrvExpTable == this.RecId
                                 && trvExpTrans.ApprovalStatus != TrvAppStatus::Ledger
        {
            trvExpTrans.updateAllocationForExpTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccountingEventForPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the accounting event is a valid accounting event for the source document.
    /// </summary>
    /// <param name = "_accountingEventRecId">Accounting event record identifier.</param>
    /// <returns>
    /// True, if IsAccountingRequired is True and DocumentDataAreaID is valid; otherwise,false.
    /// </returns>
    public boolean validateAccountingEventForPosting(AccountingEventRecId _accountingEventRecId = 0)
    {
        boolean ret = _accountingEventRecId != 0;

        if (ret)
        {
            AccountingEvent accountingEvent;

            select IsAccountingRequired, State, SourceDocumentHeader from accountingEvent
                where accountingEvent.RecId == _accountingEventRecId;

            ret = accountingEvent.IsAccountingRequired &&
                  (accountingEvent.State != AccountingEventState::Complete) &&
                  (accountingEvent.State != AccountingEventState::Error) &&
                  (accountingEvent.SourceDocumentHeader == this.SourceDocumentHeader);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveAccountingEventRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// AccountingEvent record identifier based on the SourceDocumentHeader.
    /// </summary>
    /// <param name = "_voucher">Voucher related to the accounting event.</param>
    /// <returns>
    /// Record identifier for the AccountingEvent record
    /// </returns>
    public AccountingEventRecId getActiveAccountingEventRecId(Voucher _voucher)
    {
        AccountingEventRecId accountingEventRecId = (select AccountingEvent 
                                                                from TrvAccountingEventVoucher
                                                                where TrvAccountingEventVoucher.Voucher == _voucher &&
                                                                      TrvAccountingEventVoucher.SourceDocumentHeader == this.SourceDocumentHeader).AccountingEvent;


        if (!accountingEventRecId)
        {
            TrvInstrumentationHelper::logExpenseOperationsInformation(
                                                                      strFmt("@Expense:AccountingEventMissing", this.SourceDocumentHeader, tableStr(TrvAccountingEventVoucher)),
                                                                      tableMethodStr(TrvExpTable, getActiveAccountingEventRecId)
                                                                     );
            AccountingEvent accountingEvent;
            select firstonly RecId from accountingEvent
                    where accountingEvent.SourceDocumentHeader == this.SourceDocumentHeader &&
                          accountingEvent.IsAccountingRequired &&
                          accountingEvent.State != AccountingEventState::Complete &&
                          accountingEvent.State != AccountingEventState::Error;
            
            accountingEventRecId = accountingEvent.RecId;

            if(!accountingEvent.RecId)
            {
                TrvInstrumentationHelper::logExpenseOperationsInformation(
                                                                          strFmt("@Expense:AccountingEventMissing", this.SourceDocumentHeader, tableStr(AccountingEvent)),
                                                                          tableMethodStr(TrvExpTable, getActiveAccountingEventRecId)
                                                                         );

                accountingEventRecId = AccountingEvent::getActiveEvent(this.SourceDocumentHeader).RecId;
                
                if (!accountingEventRecId)
                {
                    TrvInstrumentationHelper::logExpenseOperationsInformation
                        (
                            strFmt("@Expense:AccountingEventMethodNull", tableStaticMethodStr(AccountingEvent, getActiveEvent), this.ExpNumber),
                            tableMethodStr(TrvExpTable, getActiveAccountingEventRecId)
                        );
                    accountingEventRecId = AccountingEvent::getCurrentEvent(this.SourceDocumentHeader).RecId;
                }
            }
        }

        return accountingEventRecId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Trv</ConfigurationKey>
	<DeveloperDocumentation>@SYS124837</DeveloperDocumentation>
	<Label>@Expense:ExpenseReports</Label>
	<SingularLabel>@SYS101289</SingularLabel>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>CreatingWorker</TitleField1>
	<TitleField2>ExpNumber</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>ExpNoIdx</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<CreatedTransactionId>Yes</CreatedTransactionId>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<ModifiedTransactionId>Yes</ModifiedTransactionId>
	<Modules>Expense</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<ReplacementKey>ExpNoIdx</ReplacementKey>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>SourceDocumentHeader</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>SourceDocumentHeader</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>TrvExpTableTrvRequisitionTable</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>TrvExpTableTrvRequisitionTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>TrvExpTrans</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>TrvExpTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>TrvPolicyViolationJustification</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>TrvPolicyViolationJustification</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>TrvPolicyViolationsCache</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>TrvPolicyViolationsCache</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreatingWorker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Destination</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreatingWorker</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LegalEntity</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Account</Name>
			<Label>@SYS24500</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendAccount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@SYS14437</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Destination</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BarcodeCoverPage</Name>
			<Label>@SYS133317</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>getEmplName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>personnelNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>getUserId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>trvReportDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Destination</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>costTotal</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>getCompanyPaid</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>getEmployeePaid</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>totalPersonal</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>total</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CaseMoreInformation</Name>
			<Label>@SYS314356</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>employeeName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>trvReportDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Destination</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Description</Name>
			<Label>@SYS7576</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Txt1</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>DimensionName</Name>
			<Label>@SYS56299</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>EPNew</Name>
			<Label>@SYS109449</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Destination</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>expense</Name>
			<Label>@SYS101318</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreatingWorker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>FinalApprover</Name>
			<Label>@Expense:FinalApprover</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>General</Name>
			<Label>@SYS2952</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreatingWorker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt1</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Payment</Name>
			<Label>@SYS828</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InvoiceId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentVoucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PostedDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PreApprovalNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReferenceDataArea</Name>
			<Label>@SYS135125</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReferenceDataAreaId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>RelatedInfo</Name>
			<Label>@SYS311280</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Destination</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendAccount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SourceDocumentHeader</Name>
			<Label>@SYS314386</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SourceDocumentHeader</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SourceDocumentLine</Name>
			<Label>@SYS319494</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SourceDocumentLine</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Status</Name>
			<Label>@SYS101491</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PostedDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Totals</Name>
			<Label>@SYS314504</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>totalCreditCard</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>totalOutOfPocket</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TravelPeriod</Name>
			<Label>@SYS101488</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>trvReportDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WebCategoryBrowsing</Name>
			<Label>@SYS74258</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CreatingWorker</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WorkerInfoPart</Name>
			<Label>@SYS112492</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Destination</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WorkerListPage</Name>
			<Label>@SYS317017</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>trvReportDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Destination</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>costTotal</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Workflow</Name>
			<Label>@SYS103643</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Destination</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>totalWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>anyPolicyViolations</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WorkflowOverview</Name>
			<Label>@SYS103643</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Destination</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WorkflowSummary</Name>
			<Label>@SYS319419</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>totalApprovalAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>totalWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ApproverFields</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AntiCorruptionApproverFlag</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AntiCorruptionApproverFlag</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@Expense:AntiCorruption</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AntiCorruptionSubmitterFlag</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@Expense:AntiCorruption</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ApprovalStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>TrvAppStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CreatingWorker</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>TrvHcmWorkerRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustAccount</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>CustAccount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDefaultDimensionValueSet</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Destination</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvDestination</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ExpNumber</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvExpNumber</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>FinalApprover</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>HcmWorkerRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LegalEntity</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LegalEntity</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InterCompanyLE</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvLegalEntity</ExtendedDataType>
			<Label>@Expense:IntercompanyLEHeaderLabel</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InvoiceId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvExpInvoiceId</ExtendedDataType>
			<HelpText>@Expense:InvoiceId</HelpText>
			<Label>@SYS14204</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>PaymentDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvDateStd</ExtendedDataType>
			<HelpText>@Expense:PaymentDate</HelpText>
			<Label>@SYS114292</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymentVoucher</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymId</ExtendedDataType>
			<HelpText>@Expense:PaymentVoucher</HelpText>
			<Label>@SYS53939</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PreApprovalNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvPreApprovalNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>PostedDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvDateStd</ExtendedDataType>
			<Label>@SYS101146</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReferenceDataAreaId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DataAreaId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceDocumentHeader</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS314386</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceDocumentLine</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS319494</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Txt1</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemFreeTxt</ExtendedDataType>
			<Label>@SYS101290</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Txt2</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvTravelTxtEDT</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VendAccount</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>VendAccount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TrvExpGeneratedBy</Name>
			<EnumType>TrvExpGeneratedBy</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>ExpNoIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ExpNumber</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LegalEntity</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>EmpExpIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>LegalEntity</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CreatingWorker</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ExpNumber</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>FK_DimensionAttributeValueSet_TrvExpTabl</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>DefaultDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TrvCreatingWorkerIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CreatingWorker</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SourceDocumentHeaderIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceDocumentHeader</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CreatedTransactionIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CreatedTransactionId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TrvAgentWorkerIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CreatingWorker</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TrvExpGeneratedBy</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LegalEntity</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SourceDocumentHeaderImplementation</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>SourceDocumentHeader</MapField>
					<MapFieldTo>SourceDocumentHeader</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CompanyInfo</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CompanyInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>DataArea</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Key</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustAccount</Name>
					<SourceEDT>CustAccount</SourceEDT>
					<Field>CustAccount</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Dimensions</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DimensionedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ExpensePurpose</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124838</EntityRelationshipRole>
			<RelatedTable>TrvTravelTxt</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>IsThePurposeFor</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>PurposeSpecifiedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Txt2</Name>
					<Field>Txt2</Field>
					<RelatedField>Txt</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TrvTxtIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LegalEntity</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CompanyInfo</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>LegallyAccounts</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LegallyAccountedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LegalEntity</Name>
					<Field>LegalEntity</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SourceDocumentHeader</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>SourceDocumentHeader</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>SourceDocumentHeader</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TrvExpTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceDocumentHeader</Name>
					<Field>SourceDocumentHeader</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SourceDocumentLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SourceDocumentLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>SourceDocumentLine</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TrvExpTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceDocumentLine</Name>
					<Field>SourceDocumentLine</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TrvDestinations</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>TrvDestinations</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Destination</Name>
					<SourceEDT>TrvDestination</SourceEDT>
					<Field>Destination</Field>
					<RelatedField>Destination</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DestinationIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TrvHcmWorker</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>Creates</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CreatedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CreatingWorker</Name>
					<Field>CreatingWorker</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VendTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendAccount</Name>
					<SourceEDT>VendAccount</SourceEDT>
					<Field>VendAccount</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InterCompanyLE</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CompanyInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InterCompanyLE</Name>
					<Field>InterCompanyLE</Field>
					<RelatedField>DataArea</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Key</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>FinalApprover</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FinalApprover</Name>
					<Field>FinalApprover</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TrvExpTable_self</Name>
			<RelatedTable>TrvExpTable</RelatedTable>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ExpNumber</Name>
					<Field>ExpNumber</Field>
					<RelatedField>ExpNumber</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>