<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjCategory</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ProjCategory extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accruedCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an editable field that contains the ledger account number for the accrued costs account.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the ledger account for accrued costs to the value of
    ///    the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    ///    The ledger account for accrued costs.
    /// </param>
    /// <returns>
    ///    A <c>LedgerAccount</c> value that represents the ledger account number for the accrued costs
    ///    account. 
    /// </returns>
    /// <remarks>
    ///    The <paramref name="_ledgerAccount" /> value is used by the private <c>setLedgerAccount</c> method
    ///    to retrieve the posting account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountEst accruedCost(boolean _set,ProjLedgerDimensionDefaultAccountEst  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::AccruedCost);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedTurnoverProd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an editable field that contains the ledger account number for accrued revenue minus
    /// production posting.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that indicates whether to set the ledger account for accrued revenue minus
    /// production to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// The ledger account number for accrued revenue minus production.
    /// </param>
    /// <returns>
    /// The ledger account number for accrued revenue minus production.
    /// </returns>
    /// <remarks>
    /// The <paramref name="_ledgerAccount" /> parameter value is used by the private
    /// <c>setLedgerAccount</c> method to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountFP accruedTurnoverProd(boolean _set,ProjLedgerDimensionDefaultAccountFP  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::AccruedTurnoverProd);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedTurnoverProfit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns an editable field that contains the ledger account number for accrued revenue minus profit
    ///    posting.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the ledger account for accrued revenue minus profit
    ///    to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    ///    The ledger account number for accrued revenue minus profit.
    /// </param>
    /// <returns>
    ///    A <c>LedgerAccount</c> data type that represents the ledger account number for accrued revenue
    ///    minus profit.
    /// </returns>
    edit ProjLedgerDimensionDefaultAccountFP accruedTurnoverProfit(boolean _set,ProjLedgerDimensionDefaultAccountFP  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::AccruedTurnoverProfit);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedTurnoverSalesvalue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns an editable field that contains the ledger account number for accrued revenue minus sales
    ///    posting.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the ledger account for accrued revenue minus sales to
    ///    the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    ///    The ledger account number for accrued revenue minus sales.
    /// </param>
    /// <returns>
    ///    A <c>LedgerAccount</c> data type that represents the ledger account number for accrued revenue
    ///    minus sales.
    /// </returns>
    /// <remarks>
    ///    The <paramref name="_ledgerAccount" /> value is used by the private <c>setLedgerAccount</c> method
    ///    to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountWIP accruedTurnoverSalesvalue(boolean _set, LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::SalesValue);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjCategoryEmplOption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the project category employee option field matches the value required by the category type.
    /// </summary>
    /// <returns>
    ///    true if the project category employee option field matches the type required by the category type; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The mandatory project category employee option is required for hour category types. The never project category employee option is required for item category types.
    /// </remarks>
    private boolean checkProjCategoryEmplOption()
    {
        if (this.CategoryType == ProjCategoryType::Hour && this.ProjCategoryEmplOption != ProjCategoryEmplOption::Mandatory)
        {
            // The Hour category type cannot be changed to anything other than Mandatory in the Employee field.
            return checkFailed("@SYS75743");
        }

        if (this.CategoryType == ProjCategoryType::Item && this.ProjCategoryEmplOption != ProjCategoryEmplOption::Never)
        {
            // The Item category type cannot be changed to anything other than Never in the Employee field.
            return checkFailed("@SYS75744");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValid</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the category is in the <c>ProjCategory</c> table.
    /// </summary>
    /// <returns>
    ///    true if the category is in the table; otherwise, false.
    /// </returns>
    public boolean checkValid()
    {
        boolean         ok = true;

        if (! this.CategoryId)
        {
            ok = checkFailed("@SYS12362");
        }

        if (! this)
        {
            ok = checkFailed(strFmt(ProjCategory::txtNotExist(), this.CategoryId));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns an editable field that contains the ledger account number for costs posting.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the ledger account for costs to the value of the
    ///    <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    ///    The ledger account number for costs.
    /// </param>
    /// <returns>
    ///    A <c>LedgerAccount</c> data type that represents the ledger account number for the costs.
    /// </returns>
    /// <remarks>
    ///    The <paramref name="_ledgerAccount" /> value is used by the private <c>setLedgerAccount</c> method
    ///    to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountCost costAccount(boolean _set, LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::CostAccount);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAccount1</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger account number for costs posting.
    /// </summary>
    /// <returns>
    ///    The ledger account number for posting costs.
    /// </returns>
    public LedgerDimensionDefaultAccount costAccount1()
    {
        return ProjPosting::find(ProjAccountType::CostAccount,
                            TableGroupAll::All,
                            '',
                            TableGroupAll::Table,
                            this.CategoryId).LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete(boolean _integrate = true)
    {
        ttsbegin;

        super();

        if (_integrate)
        {
            CategoryHelper::deleteBaseCategory(this.CategoryId, CategoryModule::Project);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();

        this.Active = NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a new activity into the table.
    /// </summary>
    /// <param name="_integrate">
    ///    A Boolean value that indicates whether a new activity is to be inserted into the table.
    /// </param>
    /// <remarks>
    ///    This will call the <c>updateControlCategory</c> method to update the <c>ProjControlCategory</c>
    ///    table.
    /// </remarks>
    public void insert(boolean _integrate = true)
    {
        ttsbegin;     

        super();

        this.updateControlCategory(this);

        if (_integrate)
        {
            CategoryHelper::createBaseCategory(this.CategoryId, this.Name, CategoryModule::Project);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicedTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an editable field that contains the ledger account number for invoiced revenue posting.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that indicates whether to set the ledger account for invoiced revenue to the value
    /// of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// The ledger account number for invoiced revenue.
    /// </param>
    /// <returns>
    /// A <c>LedgerAccount</c> data type that represents the ledger account number for the invoiced revenue.
    /// </returns>
    /// <remarks>
    /// The <paramref name="_ledgerAccount" /> value is used by the private <c>setLedgerAccount</c> method
    /// to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountTM invoicedTurnover(boolean _set,LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::RevenueAccount);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Maintains relationships between the <c>ProjCategory</c>, <c>CategoryGroupId</c>,
    ///    <c>SetupEstimate</c>, <c>SetupSubscription</c> and <c>TaxItemGroupId</c> fields.
    /// </summary>
    /// <param name="_fieldName">
    ///    The name of field modified by a form.
    /// </param>
    /// <param name="_arrayIndex">
    ///    The array index of the field; optional.
    /// </param>
    /// <remarks>
    ///    This method is automatically called by the forms when any field is modified.
    /// </remarks>
    public void modifiedFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        super(_fieldName, _arrayIndex);

        switch (_fieldName)
        {
            case fieldStr(ProjCategory, CategoryGroupId) :
                this.CategoryType           = ProjCategoryGroup::find(this.CategoryGroupId).CategoryType;
                this.ProjCategoryEmplOption = ProjCategory::categoryType2CategoryEmplOption(this.CategoryType);
                switch (this.CategoryType)
                {
                    case ProjCategoryType::Revenue:
                        break;

                    case ProjCategoryType::Hour:
                        this.SetupEstimate      = NoYes::No;
                        this.SetupSubscription  = NoYes::No;
                        break;

                    case ProjCategoryType::Cost:
                        this.SetupSubscription  = NoYes::No;
                        break;

                    case ProjCategoryType::Item:
                        this.SetupEstimate      = NoYes::No;
                        this.SetupSubscription  = NoYes::No;
                        break;
                }
                break;

            case fieldStr(ProjCategory, SetupEstimate) :
            if (this.SetupEstimate)
                {
                    this.ProjCategoryEmplOption = ProjCategoryEmplOption::Never;
                    this.SetupSubscription      = NoYes::No;
                    this.Active                 = NoYes::No;
                    this.TaxItemGroupId         = "";
                    this.projLinePropertyIdEdit(true,this,"");
                }
                break;

            case fieldStr(ProjCategory, SetupSubscription) :
            if (this.SetupSubscription)
                {
                    this.ProjCategoryEmplOption = ProjCategoryEmplOption::Never;
                    this.SetupEstimate          = NoYes::No;
                    this.Active                 = NoYes::No;
                    this.TaxItemGroupId         = "";
                    this.projLinePropertyIdEdit(true,this,"");
                }
                break;

            case fieldStr(ProjCategory, Active) :
            if (this.Active)
                {
                    this.SetupEstimate          = NoYes::No;
                    this.SetupSubscription      = NoYes::No;
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfFeeCategoryMarked</Name>
				<Source><![CDATA[
    public boolean numOfFeeCategoryMarked()
    {
        return (select RecId from projCategory
                where projCategory.CategoryId == this.CategoryId
                   && projCategory.psaCustPaymentRetention == NoYes::Yes).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns an editable field that contains the ledger account number for offset account posting.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the ledger offset account to the value of the
    ///    <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    ///    The ledger account number of the offset account.
    /// </param>
    /// <returns>
    ///    The ledger account number of the offset account.
    /// </returns>
    /// <remarks>
    ///    The <paramref name="_ledgerAccount" /> value is used by the private <c>setLedgerAccount</c> method
    ///    to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit LedgerDimensionDefaultAccount offsetAccount(boolean        _set,
                                 LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::OffsetAccount);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an editable field that contains the ledger account number for offset account minus item
    ///    posting.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the ledger account for offset minus item to the value
    ///    of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    ///    The ledger account number for offset account minus item.
    /// </param>
    /// <returns>
    ///    The ledger account number for offset account minus item.
    /// </returns>
    /// <remarks>
    ///    The <paramref name="_ledgerAccount" /> value is used by the private <c>setLedgerAccount</c> method
    ///    to retrieve the account from the ProjPosting table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountWIP offsetAccountItem(boolean        _set,
                                       LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::OffsetAccountItem);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>payrollAllocation</Name>
				<Source><![CDATA[
    edit ProjLedgerDimensionDefaultAccountHour payrollAllocation(boolean        _set,
                                     LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::PayrollAllocation);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLinePropertyId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the project line property ID setting.
    /// </summary>
    /// <returns>
    ///    The value of the line property ID from the <c>ProjLinePropertySetup</c> table.
    /// </returns>
    display ProjLinePropertyId projLinePropertyId()
    {
        DictTable dictTable = new DictTable(tableNum(ProjLinePropertySetup));

        if (dictTable.rights() >= AccessType::View)
        {
            return (select projLinePropertySetup where projLinePropertySetup.ProjCode         == TableGroupAll::All   &&
                                               projLinePropertySetup.ProjRelation     == ''                   &&
                                               projLinePropertySetup.CategoryCode     == TableGroupAll::Table &&
                                               projLinePropertySetup.CategoryRelation == this.CategoryId).LinePropertyId;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLinePropertyIdEdit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the editable value of project line property ID.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to create the project line property ID when it does not
    ///    exist.
    /// </param>
    /// <param name="_projCategory">
    ///    The category ID of the line property that will be retrieved or updated.
    /// </param>
    /// <param name="_projLinePropertyId">
    ///    The line property ID value that is used to create or update the current record.
    /// </param>
    /// <returns>
    ///    A <c>ProjLinePropertyId</c> data type that represents the project property line ID from the
    ///    <c>ProjLinePropertySetup</c> table.
    /// </returns>
    /// <remarks>
    ///    If the <paramref name="_set" /> parameter is true the line property ID is created when it does not
    ///    exist.
    /// </remarks>
    public edit ProjLinePropertyId projLinePropertyIdEdit(boolean                _set,
                                                      ProjCategory           _projCategory,
                                                      ProjLinePropertyId     _projLinePropertyId)
    {
        ProjLinePropertyId projLinePropertyId = '';
        DictTable dictTable = new DictTable(tableNum(ProjLinePropertySetup));

        if (_set)
        {
            if (_projLinePropertyId && !ProjLineProperty::checkExist(_projLinePropertyId))
            {
                if (dictTable.rights() >= AccessType::View)
                {
                    projLinePropertyId = (select projLinePropertySetup where projLinePropertySetup.ProjCode          == TableGroupAll::All   &&
                                                                 projLinePropertySetup.ProjRelation      == ''                   &&
                                                                 projLinePropertySetup.CategoryCode      == TableGroupAll::Table &&
                                                                 projLinePropertySetup.CategoryRelation  == _projCategory.CategoryId).LinePropertyId;
                }
            }
            else
            {
                if (dictTable.rights() >= AccessType::Edit)
                {
                    ProjLinePropertySetup::updateLinePropertyCategory( _projCategory.CategoryId, _projLinePropertyId, TableGroupAll::Table, _set);
                    projLinePropertyId = _projLinePropertyId;
                }
            }
        }
        else
        {
            if (dictTable.rights() >= AccessType::View)
            {
                projLinePropertyId = (select projLinePropertySetup where projLinePropertySetup.ProjCode          == TableGroupAll::All   &&
                                                                 projLinePropertySetup.ProjRelation      == ''                   &&
                                                                 projLinePropertySetup.CategoryCode      == TableGroupAll::Table &&
                                                                 projLinePropertySetup.CategoryRelation  == _projCategory.CategoryId).LinePropertyId;
            }
        }

        return projLinePropertyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger account number for the posting account type.
    /// </summary>
    /// <param name="set">
    ///    A Boolean value that indicates whether to set the ledger account to the value of the <paramref
    ///    name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="ledgerAccount">
    ///    The ledger account number for the posting account type.
    /// </param>
    /// <param name="accountType">
    ///    The project account type for posting.
    /// </param>
    /// <returns>
    ///    The ledger account number that is used for posting.
    /// </returns>
    private LedgerDimensionDefaultAccount setLedgerAccount(boolean set, LedgerDimensionDefaultAccount ledgerAccount, ProjAccountType accountType)
    {
        if (set)
        {
            ProjPosting::createTrans(ledgerAccount,
                                 accountType,
                                 TableGroupAll::All,
                                 '',
                                 TableGroupAll::Table,
                                 this.CategoryId);
        }

        return ProjPosting::find(accountType,
                             TableGroupAll::All,
                             '',
                             TableGroupAll::Table,
                             this.CategoryId).LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>smaAccruedRevenueSubscription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an editable field that contains the ledger account number to use tp post accrued revenue
    /// minus subscription.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that indicates whether to set the ledger account for accrued revenue minus
    /// subscription to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// The ledger account number for accrued revenue minus subscription.
    /// </param>
    /// <returns>
    /// The ledger account number for accrued revenue minus subscription.
    /// </returns>
    /// <remarks>
    /// The <paramref name="_ledgerAccount" /> parameter value is used by the private
    /// <c>setLedgerAccount</c> method to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit SMAAccruedRevenueSubscriptionLedDimDefAc smaAccruedRevenueSubscription( boolean       _set,
                                                  LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::AccruedRevenueSubscription);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>smawipSubscription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an editable field that contains the ledger account number to use to post work in progress
    /// minus subscription.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that indicates whether to set the ledger account for work in progress minus
    /// subscription to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// The ledger account number for work in progress minus subscription.
    /// </param>
    /// <returns>
    /// The ledger account number for work in progress minus subscription.
    /// </returns>
    /// <remarks>
    /// The <paramref name="_ledgerAccount" /> parameter value is used by the private
    /// <c>setLedgerAccount</c> method to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit SMAWIPSubscriptionLedDimDefAc smawipSubscription(  boolean       _set,
                                        LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::WIPSubscription);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>statusAccountItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger account number for the status account item posting type.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the ledger account to the value of the <paramref
    ///    name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    ///    The ledger account number for <c>ProjAccountType::StatusAccountItem</c>.
    /// </param>
    /// <returns>
    ///    The ledger account number for the posting type of <c>ProjAccountType::StatusAccountItem</c>.
    /// </returns>
    edit ProjLedgerDimensionDefaultAccountWIP statusAccountItem(boolean        _set,
                                       LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::StatusAccountItem);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update(boolean _integrate = true)
    {
        str s;

        ttsbegin;

        if (_integrate)
        {
            s = this.orig().Name;
            // update the category name in the related tables
            if (this.orig().Name != this.Name)
            {
                CategoryHelper::updateCategoryName(this.CategoryId, this.Name, CategoryModule::Project);
            }

            // update the taxitemgroup in the related tables
            if (this.orig().TaxItemGroupId != this.TaxItemGroupId)
            {
                CategoryHelper::updateTaxItemGroupId(this.CategoryId, this.TaxItemGroupId, CategoryModule::Project);
            }
        }

        super();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateControlCategory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates records in the <c>ProjControlCategory</c> table for the category provided.
    /// </summary>
    /// <param name="_projCategory">
    ///    A <c>ProjCategory</c> table buffer.
    /// </param>
    private void updateControlCategory(ProjCategory _projCategory)
    {
        ProjControlCategory projControlCategory = null;
        ProjControl         projControl;

        switch (_projCategory.CategoryType)
        {
            case ProjCategoryType::Hour    :
            case ProjCategoryType::Item    :
                break;

            case ProjCategoryType::Cost    :
            if (_projCategory.SetupEstimate)
                {
                    // Setup Estimate costs are not added to template
                    return;
                }
                else
                {
                    break;
                }

            default:
                return;
        }

        while select ControlId, CostGroupHourId, CostGroupCostId, CostGroupItemId from projControl
        {
            projControlCategory.clear();
            projControlCategory.ControlId = projControl.ControlId;

            projControlCategory = this.initControlCategory(_projCategory, projControlCategory, projControl);

            projControlCategory.CategoryId = _projCategory.CategoryId;

            if (!ProjControlCategory::find(projControlCategory.ControlId,projControlCategory.CostGroupId ,projControlCategory.CategoryId))
            {
                projControlCategory.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initControlCategory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes records in the <c>ProjControlCategory</c> table for the category provided.
    /// </summary>
    /// <param name = "_projCategory">
    ///     A <c>ProjCategory</c> table buffer.
    /// </param>
    /// <param name = "_projControlCategory">
    ///      A <c>ProjControlCategory</c> table buffer.
    /// </param>
    /// <param name = "_projControl">
    ///      A <c>ProjControl</c> table buffer.
    /// </param>
    /// <returns>
    ///     A <c>ProjControlCategory</c> table buffer.
    /// </returns>
    protected ProjControlCategory initControlCategory(ProjCategory _projCategory, ProjControlCategory _projControlCategory, ProjControl _projControl)
    {
        switch (_projCategory.CategoryType)
        {
            case ProjCategoryType::Hour :
                _projControlCategory.CostType    = ProjCostType::Hour;
                _projControlCategory.CostGroupId = _projControl.CostGroupHourId;
                break;

            case ProjCategoryType::Cost    :
                _projControlCategory.CostType    = ProjCostType::Cost;
                _projControlCategory.CostGroupId = _projControl.CostGroupCostId;
                break;

            case ProjCategoryType::Item    :
                _projControlCategory.CostType    = ProjCostType::Item;
                _projControlCategory.CostGroupId = _projControl.CostGroupItemId;
                break;
        }

        return _projControlCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean ret;
        PSAIndirectComponent    tpsaIndirectComponent;

        ret = super();

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            //to check the if there any related records in the PSAIndirect table
            select firstonly ComponentCategory, RecId from tpsaIndirectComponent
            where tpsaIndirectComponent.ComponentCategory == this.CategoryId;

            if (tpsaIndirectComponent.RecId && this.psaIndirectComponent == NoYes::Yes)
            {
                ret = checkFailed(strFmt("@SYS75284", tablePName(PSAIndirectComponent)));
            }

            if (ret && ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                ProjAdvancedJournalLine advJourLine;
                select firstonly crosscompany RecId from advJourLine
                    where advJourLine.ProjCategoryId == this.CategoryId
                        && advJourLine.ProjDataAreaId == curExt();

                if (advJourLine)
                {
                    ret = checkFailed(strFmt("@SYS75284", tablePName(ProjAdvancedJournalLine)));
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the specified field.
    /// </summary>
    /// <param name="_fieldName">
    ///    The name of the field to validate.
    /// </param>
    /// <param name="_arrayIndex">
    ///    The array index of the field to validate; optional.
    /// </param>
    /// <returns>
    ///    true if the value in the specified field is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <c>ProjCategory</c>, <c>ProjCategoryEmplOption</c>, <c>SetupSubscription</c>, and
    ///    <c>SetupEstimate</c> fields have interdependencies among them. This method is automatically called
    ///    by forms when any field is modified.
    /// </remarks>
    public boolean validateFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        boolean ret;

        ret = super(_fieldName, _arrayIndex);

        switch (_fieldName)
        {
            case (fieldStr(ProjCategory, ProjCategoryEmplOption)) :
                ret  = this.checkProjCategoryEmplOption() && ret;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateIfInactiveAllowed</Name>
				<Source><![CDATA[
    public boolean validateIfInactiveAllowed(boolean _suppressInfolog = false)
    {
        boolean retOk = true;

        // check for "this", since null records have Active=No also
        if (this && !this.Active && !ProjParameters::find().ShowInactiveCategories)
        {
            retOk = _suppressInfolog ? false : checkFailed(strFmt("@SYS100383", this.CategoryId));
        }

        return retOk;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            if (ProjCategoryGroup::find(this.CategoryGroupId).CategoryType != this.CategoryType)
            {
                // Category group and transaction type are inconsistent.
                ret = checkFailed("@SYS54088");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an editable field that contains the ledger account number for posting work in progress
    ///    minus accrued loss.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the ledger account for work in progress minus accrued
    ///    loss to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    ///    The ledger account number for work in progress minus accrued loss.
    /// </param>
    /// <returns>
    ///    The ledger account number for work in progress minus accrued loss.
    /// </returns>
    /// <remarks>
    ///    The <paramref name="_ledgerAccount" /> value is used by the private <c>setLedgerAccount</c> method
    ///    to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountEst wipCostAccrued(boolean _set,LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::WIPCostAccruals);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an editable field that contains the ledger account number to use to post work in progress
    /// minus cost value.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that indicates whether to set the ledger account for work in progress minus cost
    /// value to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// The ledger account number for work in progress minus cost value.
    /// </param>
    /// <returns>
    /// The ledger account number for work in progress minus cost value.
    /// </returns>
    /// <remarks>
    /// The <paramref name="_ledgerAccount" /> parameter value is used by the private
    /// <c>setLedgerAccount</c> method to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountWIP wipCostValue(boolean     _set,
                                LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::StatusAccount);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipProduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an editable field that contains the ledger account number to use to post work in progress,
    /// minus production.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for work in progress minus
    /// production to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// The ledger account number for work in progress minus production.
    /// </param>
    /// <returns>
    /// The ledger account number for work in progress minus production.
    /// </returns>
    /// <remarks>
    /// The <paramref name="_ledgerAccount" /> value is used by the private <c>setLedgerAccount</c> method
    /// to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountFP wipProduction(boolean _set,LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::WIPProduction);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipProfit</Name>
				<Source><![CDATA[
    edit ProjLedgerDimensionDefaultAccountFP wipProfit(boolean _set,LedgerDimensionDefaultAccount  _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::WIPProfit);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipSalesvalue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an editable field that contains the ledger account number for posting work in progress
    /// accrued, minus the sales value.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that specifies whether to set the ledger account for work in progress minus sales
    /// to the value of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// The ledger account number for work in progress minus sales value.
    /// </param>
    /// <returns>
    /// The ledger account number for work in progress minus sales value.
    /// </returns>
    /// <remarks>
    /// The <paramref name="_ledgerAccount" /> parameter value is used by the private
    /// <c>setLedgerAccount</c> method to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountWIP wipSalesvalue(boolean       _set,
                                 LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger (_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set,_ledgerAccount,ProjAccountType::SalesOffsetAccount);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canceledInvoicedRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an editable field that contains the ledger account number for canceled invoiced revenue posting.
    /// </summary>
    /// <param name="_set">
    /// A Boolean value that indicates whether to set the ledger account for canceled invoiced revenue to the value
    /// of the <paramref name="_ledgerAccount" /> parameter.
    /// </param>
    /// <param name="_ledgerAccount">
    /// The ledger account number for canceled invoiced revenue.
    /// </param>
    /// <returns>
    /// A <c>LedgerAccount</c> data type that represents the ledger account number for the canceled invoiced revenue.
    /// </returns>
    /// <remarks>
    /// The <paramref name="_ledgerAccount" /> value is used by the private <c>setLedgerAccount</c> method
    /// to retrieve the account from the <c>ProjPosting</c> table.
    /// </remarks>
    edit ProjLedgerDimensionDefaultAccountTM canceledInvoicedRevenue(boolean _set,LedgerDimensionDefaultAccount _ledgerAccount)
    {
        if (ProjPosting::isAccessibleToSetLedger(_set, _ledgerAccount))
        {
            return this.setLedgerAccount(_set, _ledgerAccount, ProjAccountType::InvoiceCancelRevenueAccount);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryType2CategoryEmplOption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a category employee option enumeration based on a category type enumeration value.
    /// </summary>
    /// <param name="_projCategoryType">
    ///    A <c>ProjCategoryType</c> enumeration value.
    /// </param>
    /// <returns>
    ///    A <c>ProjCategoryEmplOption</c> enumeration value that is based on the category type.
    /// </returns>
    /// <remarks>
    ///    If no valid mapping between the category type and the project category employee option exists, an
    ///    error is thrown.
    /// </remarks>
    public static ProjCategoryEmplOption categoryType2CategoryEmplOption(ProjCategoryType _projCategoryType)
    {
        ProjCategoryEmplOption  projCategoryEmplOption;

        switch (_projCategoryType)
        {
            case ProjCategoryType::None:
                projCategoryEmplOption  = ProjCategoryEmplOption::Never;
                break;

            case ProjCategoryType::Hour:
                projCategoryEmplOption  = ProjCategoryEmplOption::Mandatory;
                break;

            case ProjCategoryType::Cost:
                projCategoryEmplOption  = ProjCategoryEmplOption::Optional;
                break;

            case ProjCategoryType::Item:
                projCategoryEmplOption  = ProjCategoryEmplOption::Never;
                break;

            case ProjCategoryType::Revenue, ProjCategoryType::OnAccount:
                projCategoryEmplOption  = ProjCategoryEmplOption::Optional;
                break;

            default:
                EventHandlerResult result = EventHandlerResult::newSingleResponse();
                ProjCategory::categoryType2CategoryEmplOptionDelegate(_projCategoryType, result);
                if (result.hasResult())
                {
                    projCategoryEmplOption = result.result();
                }
                else
                {
                    throw error(strFmt("@SYS5932", _projCategoryType));
                }
        }

        return projCategoryEmplOption;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryType2CategoryEmplOptionDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for getting the <c>ProjCategoryEmplOption</c> enumeration value given a <c>ProjCategoryType</c> enumeration value.
    /// </summary>
    /// <param name = "_projCategoryType">
    /// The <c>ProjCategoryType</c> enumeration value.
    /// </param>
    /// <param name = "_eventResult">
    /// An <c>EventHandlerResult</c> instance, where subscribers can provide default <c>ProjCategoryEmplOption</c> enumeration value.
    /// </param>
    static delegate void categoryType2CategoryEmplOptionDelegate(ProjCategoryType _projCategoryType, EventHandlerResult _eventResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryType2TransType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a transaction type enumeration based on the category type.
    /// </summary>
    /// <param name="_projCategoryType">
    ///    A <c>ProjCategoryType</c> enumeration value.
    /// </param>
    /// <returns>
    ///    A <c>ProjTransType</c> enumeration value that corresponds to the category type.
    /// </returns>
    /// <remarks>
    ///    If no valid mapping between the category type and the project transaction type option exists, an
    ///    error is thrown.
    /// </remarks>
    public static ProjTransType categoryType2TransType(ProjCategoryType _projCategoryType)
    {
        ProjTransType retval;

        switch (_projCategoryType)
        {
            case ProjCategoryType::None:
                retval = ProjTransType::None;
                break;

            case ProjCategoryType::Hour:
                retval = ProjTransType::Hour;
                break;

            case ProjCategoryType::Cost:
                retval = ProjTransType::Cost;
                break;

            case ProjCategoryType::Item:
                retval = ProjTransType::Item;
                break;

            case ProjCategoryType::Revenue:
                retval = ProjTransType::Revenue;
                break;

            case ProjCategoryType::OnAccount:
                retval = ProjTransType::OnAccount;
                break;
            
            default:
                EventHandlerResult result = EventHandlerResult::newSingleResponse();
                ProjCategory::categoryType2TransTypeDelegate(_projCategoryType, result);
                if (result.hasResult())
                {
                    retval = result.result();
                }
                else
                {
                    throw error(strFmt("@SYS5932", _projCategoryType));
                }
        }

        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryType2TransTypeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for getting the <c>ProjTransType</c> enumeration value given a <c>ProjCategoryType</c> enumeration value.
    /// </summary>
    /// <param name = "_projCategoryType">
    /// The <c>ProjCategoryType</c> enumeration value.
    /// </param>
    /// <param name = "_eventResult">
    /// An <c>EventHandlerResult</c> instance, where subscribers can provide default <c>ProjTransType</c> enumeration value.
    /// </param>
    static delegate void categoryType2TransTypeDelegate(ProjCategoryType _projCategoryType, EventHandlerResult _eventResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    public static boolean checkExist(ProjCategoryId category)
    {
        if (category && !ProjCategory::exist(category))
        {
            return checkFailed(strFmt(ProjCategory::txtNotExist(), category));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjConnection</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether project and category validation is set up for project.
    /// </summary>
    /// <param name="_projId">
    ///    The project identifier.
    /// </param>
    /// <returns>
    ///    true if project and category validation is set up for the project; otherwise, false.
    /// </returns>
    public static boolean createProjConnection(ProjId _projId)
    {
        if (!_projId)
        {
            return false;
        }

        return ProjCategory::createProjConnectionProjTable(ProjTable::find(_projId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjConnectionProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether project and category validation is set up for project.
    /// </summary>
    /// <param name="_projTable">
    ///    The project to use.
    /// </param>
    /// <returns>
    ///    true if project and category validation is set up for the project; otherwise, false.
    /// </returns>
    public static boolean createProjConnectionProjTable(ProjTable _projTable)
    {
        if (!_projTable)
        {
            return false;
        }
        if (ProjParameters::find().ValidationProjCategory == ProjValParameter::None)
        {
            return false;
        }

        if (_projTable.ValidateProjCategory == NoYes::No)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createResourceConnection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a resource and category validation is set up for projects.
    /// </summary>
    /// <param name="_resourceRecId">
    /// The resource <c>RecId</c> value.
    /// </param>
    /// <param name="_isIntercompany">
    /// True if transaction is an intercompany transaction.
    /// </param>
    /// <returns>
    /// true if the resource and category validation is enabled for this resource; otherwise, false.
    /// </returns>
    public static boolean createResourceConnection(ResourceRecId _resourceRecId, boolean _isIntercompany = false)
    {
        if (!_resourceRecId)
        {
            return false;
        }

        if (ProjParameters::find().ValidationEmplCategory == ProjValParameter::None)
        {
            return false;
        }

        // If validation is from an intercompany trx, ignore the resource setup
        if (_isIntercompany)
        {
            return true;
        }

        if (ResourceFacade::validateResourceCategory(_resourceRecId) == NoYes::No)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a record is located in the table for the values passed as parameters.
    /// </summary>
    /// <param name="category">
    ///    The category identifier.
    /// </param>
    /// <returns>
    ///    true if the category record exists; otherwise, false.
    /// </returns>
    public static boolean exist(ProjCategoryId category)
    {
        return category && (select RecId from projCategory where projCategory.CategoryId == category).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsActiveRevenueCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the passed category id is an active for posting in journals category of type Revenue
    /// </summary>
    /// <param name="_projCategoryId">
    /// Category Id
    /// </param>
    /// <returns>
    /// True if category id is found as an active for posting in journals and of type revenue; else false
    /// </returns>
    /// <remarks>
    /// Used in lookup to display only active categories of type revenue
    /// </remarks>
    public static boolean existsActiveRevenueCategory(ProjCategoryId _projCategoryId)
    {
        ProjCategory     projCategory;

        select firstonly RecId from projCategory
            where projCategory.CategoryType == ProjCategoryType::Revenue &&
            projCategory.Active             == NoYes::Yes &&
            projCategory.CategoryId         == _projCategoryId;

        if (!projCategory)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the record that corresponds to the values passed as parameters.
    /// </summary>
    /// <param name="_category">
    ///    The category identifier.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that specifies whether the record should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    A <c>ProjCategory</c> table record.
    /// </returns>
    /// <remarks>
    ///    Returns null if the record does not exist.
    /// </remarks>
    public static ProjCategory find(ProjCategoryId _category, boolean _forUpdate = false)
    {
        ProjCategory projCategory = null;

        projCategory.selectForUpdate(_forUpdate);

        if (_category)
        {
            select firstonly projCategory where projCategory.CategoryId  == _category;
        }

        return projCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecId</Name>
				<Source><![CDATA[
    public static ProjCategory findRecId(
    RecId   _recId,
    boolean _forUpdate = false)
    {
        ProjCategory projCategory;

        if (_recId)
        {
            projCategory.selectForUpdate(_forUpdate);

            select firstonly projCategory
            where projCategory.RecId == _recId;
        }

        return projCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultProjectGlobalCategory</Name>
				<Source><![CDATA[
    public static ProjCategoryId getDefaultProjectGlobalCategory(RefRecId _ecoResCategory)
    {
        EcoResCategory  ecoResCategory;
        CategoryTable   categoryTable;
        ProjCategory    projCategory;

        if (_ecoResCategory)
        {
            ecoResCategory = EcoResCategory::find(_ecoResCategory);
            while (ecoResCategory)
            {
                if (ecoResCategory.DefaultProjectGlobalCategory)
                {
                    select CategoryId from categoryTable
                    where categoryTable.SharedCategory == ecoResCategory.DefaultProjectGlobalCategory &&
                        categoryTable.UseInProject == NoYes::Yes
                    exists join projCategory
                        where projCategory.CategoryId   == categoryTable.CategoryId &&
                              projCategory.CategoryType != ProjCategoryType::Revenue;

                    if (categoryTable.CategoryId)
                    {
                        break;
                    }
                }

                if (ecoResCategory.ParentCategory)
                {
                    ecoResCategory = EcoResCategory::find(ecoResCategory.ParentCategory);
                }
                else
                {
                    ecoResCategory = null;
                }
            }
        }

        return categoryTable.CategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMarkedCategory</Name>
				<Source><![CDATA[
    public static ProjCategory isMarkedCategory()
    {
        ProjCategory projCategory;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            select firstonly projCategory
            where projCategory.psaCustPaymentRetention == NoYes::Yes;
        }

        return projCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjCategoryByCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to look up categories by category.
    /// </summary>
    /// <param name = "_ctrl">A <c>FormStringControl</c> data type that is used to display the categories.</param>
    public static void lookupProjCategoryByCategory(FormStringControl _ctrl)
    {
        SysTableLookup  sysTableLookup = SysTableLookup::newParameters(tableNum(ProjCategory), _ctrl);

        sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryId));
        sysTableLookup.addLookupfield(fieldNum(ProjCategory, Name));
        sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryType));
        sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryGroupId));

        Query query = new Query();
        QueryBuildDataSource queryBuildDataSource = query.addDataSource(tableNum(ProjCategory));

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            QueryBuildRange queryBuildRangeIndirect     = queryBuildDataSource.addRange(fieldNum(ProjCategory, psaIndirectComponent));
            QueryBuildRange queryBuildRangeRetention    = queryBuildDataSource.addRange(fieldNum(ProjCategory, psaCustPaymentRetention));

            queryBuildRangeIndirect.value(queryValue(NoYes::No));
            queryBuildRangeRetention.value(queryValue(NoYes::No));
        }

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjCategoryByCategoryGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Used to look up categories by category group.
    /// </summary>
    /// <param name="ctrl">
    ///    A <c>FormStringControl</c> data type that is used to display the categories.
    /// </param>
    /// <param name="categoryGroupId">
    ///    The category group ID to be displayed in the lookup. The default value is an empty string; optional.
    /// </param>
    public static void lookupProjCategoryByCategoryGroup(
    FormStringControl   ctrl,
    ProjCategoryGroupId categoryGroupId = '')
    {
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(ProjCategory),ctrl);
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;

        sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryId));
        sysTableLookup.addLookupfield(fieldNum(ProjCategory, Name));

        query = new Query();
        queryBuildDataSource = query.addDataSource(tableNum(ProjCategory));
        if (categoryGroupId != '')
        {
            queryBuildDataSource.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(queryValue(categoryGroupId));
        }
        else
        {
            queryBuildDataSource.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(SysQuery::valueEmptyString());
        }
        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjCategoryProductionProfit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the revenue categories for a specified project group.
    /// </summary>
    /// <param name="ctrl">
    /// A <c>FormStringControl</c> data type that is used to display the categories.
    /// </param>
    /// <param name="projGroup">
    /// The project group ID.
    /// </param>
    public static void lookupProjCategoryProductionProfit(
    FormStringControl   ctrl,
    ProjGroup           projGroup
)
    {
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(ProjCategory),ctrl);
        Query                   query;
        QueryBuildDataSource    qbdsProjCategory;
        QueryBuildDataSource    qbdsProjGroup;
        QueryBuildRange         queryBuildRangeRetention;

        sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryId));
        sysTableLookup.addLookupfield(fieldNum(ProjCategory, Name));

        query = new Query();
        qbdsProjCategory = query.addDataSource(tableNum(ProjCategory));
        qbdsProjCategory.addRange(fieldNum(ProjCategory, CategoryType)).value(queryValue(ProjCategoryType::Revenue));
        qbdsProjCategory.addRange(fieldNum(ProjCategory, SetupEstimate)).value(queryValue(NoYes::Yes));
        queryBuildRangeRetention  = qbdsProjCategory.addRange(fieldNum(ProjCategory, psaCustPaymentRetention));
        queryBuildRangeRetention.value(queryValue(NoYes::No));

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            qbdsProjGroup   = qbdsProjCategory.addDataSource(tableNum(ProjGroup));
            qbdsProjGroup.addRange(fieldNum(ProjGroup, ProjGroupId)).value(projGroup.ProjGroupId);

            qbdsProjGroup.addRange(fieldNum(ProjGroup, ProductionCategoryId)).value(
                strFmt('(%1.%3 == %2.%4) || (%1.%3 == %2.%5)',
                qbdsProjCategory.name(),
                qbdsProjGroup.name(),
                fieldStr(ProjCategory,CategoryId),
                fieldStr(ProjGroup,ProductionCategoryId),
                fieldStr(ProjGroup, ProfitCategoryId)));
        }

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjCategorySalesValue</Name>
				<Source><![CDATA[
    public static void lookupProjCategorySalesValue(
    FormStringControl   ctrl,
    ProjGroup           projGroup
)
    {
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(ProjCategory),ctrl);
        Query                   query;
        QueryBuildDataSource    qbdsProjCategory;
        QueryBuildDataSource    qbdsProjGroup;
        QueryBuildRange         queryBuildRangeRetention;

        sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryId));
        sysTableLookup.addLookupfield(fieldNum(ProjCategory, Name));

        query = new Query();
        qbdsProjCategory = query.addDataSource(tableNum(ProjCategory));
        qbdsProjCategory.addRange(fieldNum(ProjCategory, CategoryType)).value(queryValue(ProjCategoryType::Revenue));
        qbdsProjCategory.addRange(fieldNum(ProjCategory, SetupEstimate)).value(queryValue(NoYes::Yes));
        queryBuildRangeRetention  = qbdsProjCategory.addRange(fieldNum(ProjCategory, psaCustPaymentRetention));
        queryBuildRangeRetention.value(queryValue(NoYes::No));
        
        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            qbdsProjGroup   = qbdsProjCategory.addDataSource(tableNum(ProjGroup));
            qbdsProjGroup.addRange(fieldNum(ProjGroup, ProjGroupId)).value(projGroup.ProjGroupId);

            qbdsProjGroup.addRange(fieldNum(ProjGroup, SalesvalueCategoryId)).value(
                strFmt('(%1.%3 == %2.%4)',
                qbdsProjCategory.name(),
                qbdsProjGroup.name(),
                fieldStr(ProjCategory,CategoryId),
                fieldStr(ProjGroup,SalesvalueCategoryId)));
        }

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjCategoryType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for project categories based on the parameters that are provided.
    /// </summary>
    /// <param name="ctrl">
    /// A <c>FormStringControl</c> data type that is used to display the categories.
    /// </param>
    /// <param name="categoryType">
    /// A <c>ProjCategoryType</c> value to be displayed in the lookup; optional.
    /// </param>
    /// <param name="subscription">
    /// A <c>YesNo</c> value that is used to display subscriptions in the lookup; optional.
    /// </param>
    /// <param name="estimate">
    /// A <c>YesNo</c> value that is used to display estimates in the lookup; optional.
    /// </param>
    /// <param name="active">
    /// A <c>YesNo</c> value that is used to display active in the lookup; optional.
    /// </param>
    /// <param name="indirectComponent">
    /// A <c>YesNo</c> value that is used to display indirect components in the lookjp; optional.
    /// </param>
    /// <param name="showCategoryType">
    /// A <c>YesNo</c> value that is used to indicate if the lookup should display the category type field; optional.
    /// </param>
    public static void lookupProjCategoryType(
        FormStringControl   ctrl,
        ProjCategoryType    categoryType        = ProjCategoryType::Item,
        NoYes               subscription        = NoYes::No,
        NoYes               estimate            = NoYes::No,
        NoYes               active              = NoYes::No,
        NoYes               indirectComponent   = NoYes::No,
        NoYes               showCategoryType    = NoYes::Yes)
    {
        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(ProjCategory),ctrl);

        sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryId));
        sysTableLookup.addLookupfield(fieldNum(ProjCategory, Name));
        if (showCategoryType)
        {
            sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryType));
        }

        Query query = ProjCategory::getProjCategoryTypeQuery(categoryType, subscription, estimate, active, indirectComponent);
        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjCategoryTypeQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a query for project categories based on the parameters that are provided.
    /// </summary>
    /// <param name="categoryType">
    /// A <c>ProjCategoryType</c> value to be displayed in the lookup
    /// </param>
    /// <param name="subscription">
    /// A <c>YesNo</c> value that is used to include subscriptions categories.
    /// </param>
    /// <param name="estimate">
    /// A <c>YesNo</c> value that is used to include estimates categories.
    /// </param>
    /// <param name="active">
    /// A <c>YesNo</c> value that is used to include only active categories.
    /// </param>
    /// <param name="indirectComponent">
    /// A <c>YesNo</c> value that is used to include indirect component.
    /// </param>
    /// <returns>
    /// A <c>Query</c> instance.
    /// </returns>
    [HookableAttribute(true)]
    protected static Query getProjCategoryTypeQuery(
        ProjCategoryType    categoryType,
        NoYes               subscription,
        NoYes               estimate,
        NoYes               active,
        NoYes               indirectComponent)
    {
        Query query = new Query();
        QueryBuildDataSource queryBuildDataSource = query.addDataSource(tableNum(ProjCategory));
        queryBuildDataSource.addRange(fieldNum(ProjCategory, CategoryType)).value(queryValue(categoryType));

        if (subscription == NoYes::Yes)
        {
            queryBuildDataSource.addRange(fieldNum(ProjCategory, SetupSubscription)).value(queryValue(NoYes::Yes));
        }

        if (estimate == NoYes::Yes)
        {
            queryBuildDataSource.addRange(fieldNum(ProjCategory, SetupEstimate)).value(queryValue(NoYes::Yes));
        }
        else
        {
            queryBuildDataSource.addRange(fieldNum(ProjCategory, SetupEstimate)).value(queryValue(NoYes::No));
        }

        // Show all not just the active when NoYes::No
        if (active == NoYes::Yes)
        {
            queryBuildDataSource.addRange(fieldNum(ProjCategory, Active)).value(queryValue(NoYes::Yes));
        }

        if (indirectComponent == NoYes::No)
        {
            queryBuildDataSource.addRange(fieldNum(ProjCategory, PSAIndirectComponent)).value(queryValue(NoYes::No));
        }

        if (categoryType == ProjCategoryType::Revenue)
        {
            // Do not show the customer retention category as it is a special category
            queryBuildDataSource.addRange(fieldNum(ProjCategory, PSACustPaymentRetention)).value(queryValue(NoYes::No));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjHour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for project categories based on the parameters that are provided.
    /// </summary>
    /// <param name="ctrl">
    /// A <c>FormStringControl</c> data type that is used to display the categories.
    /// </param>
    /// <param name="categoryType">
    /// A <c>ProjCategoryType</c> value to be displayed in the lookup; optional.
    /// </param>
    /// <param name="subscription">
    /// A <c>YesNo</c> value that is used to display subscriptions in the lookup; optional.
    /// </param>
    /// <param name="estimate">
    /// A <c>YesNo</c> value that is used to display estimates in the lookup; optional.
    /// </param>
    /// <param name="active">
    /// A <c>YesNo</c> value that is used to display active in the lookup; optional.
    /// </param>
    /// <param name="indirectComponent">
    /// A <c>YesNo</c> value that is used to display indirect components in the lookjp; optional.
    /// </param>
    /// <param name="showCategoryType">
    /// A <c>YesNo</c> value that is used to indicate if the lookup should display the category type field; optional.
    /// </param>
    //public static void lookupProjHour(
    public client static ProjCategory lookupProjHour(
                    FormReferenceControl    ctrl,
                    ProjCategoryType        categoryType        = ProjCategoryType::Hour,
                    NoYes                   subscription        = NoYes::No,
                    NoYes                   estimate            = NoYes::No,
                    NoYes                   active              = NoYes::No,
                    NoYes                   indirectComponent   = NoYes::No,
                    NoYes                   showCategoryType    = NoYes::Yes)
    {
        ProjCategory selectedRecord;
        SysReferenceTableLookup sysTableLookup = SysReferenceTableLookup::newParameters(tableNum(ProjCategory), ctrl, true);

        sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryId));
        sysTableLookup.addLookupfield(fieldNum(ProjCategory, Name));
        if (showCategoryType)
        {
            sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryType));
            sysTableLookup.addLookupField(fieldNum(ProjCategory, CategoryGroupId));
        }

        Query query = ProjCategory::getProjCategoryTypeQuery(categoryType, subscription, estimate, active, indirectComponent);
        sysTableLookup.parmQuery(query);
        selectedRecord = sysTableLookup.performFormLookup();

        return selectedRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProjFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for project categories based on the parameters that are provided.
    /// </summary>
    /// <param name="ctrl">
    /// <c>FormStringControl</c> data type that is used to display the categories.
    /// </param>
    /// <param name="categoryType">
    /// <c>ProjCategoryType</c> value to be displayed in the lookup; optional.
    /// </param>
    public static void lookupProjFee(FormStringControl   ctrl,
                    ProjCategoryType    categoryType = ProjCategoryType::Revenue)
    {
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(ProjCategory),ctrl);
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;

        sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryId));
        sysTableLookup.addLookupfield(fieldNum(ProjCategory, Name));
        sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryType));

        query = new Query();
        queryBuildDataSource = query.addDataSource(tableNum(ProjCategory));
        queryBuildDataSource.addRange(fieldNum(ProjCategory, CategoryType)).value(queryValue(categoryType));
        queryBuildDataSource.addRange(fieldNum(ProjCategory, SetupEstimate)).value(queryValue(NoYes::No));
        queryBuildDataSource.addRange(fieldNum(ProjCategory, PSACustPaymentRetention)).value(queryValue(NoYes::No));

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupPSAProjCategoryEmpl</Name>
				<Source><![CDATA[
    static void lookupPSAProjCategoryEmpl(FormStringControl ctrl, boolean _includeIndirectComp = true)
    {
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(ProjCategory),ctrl);
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            sysTableLookup.addLookupfield(fieldNum(ProjCategory, CategoryId));
            sysTableLookup.addLookupfield(fieldNum(ProjCategory, Name));

            query = new Query();
            queryBuildDataSource = query.addDataSource(tableNum(ProjCategory));
            queryBuildDataSource.addRange(fieldNum(ProjCategory, CategoryType)).value(queryValue(ProjCategoryType::Hour));

            if (!_includeIndirectComp)
            {
                queryBuildDataSource.addRange(fieldNum(ProjCategory, psaIndirectComponent)).value(queryValue(NoYes::No));
            }

            sysTableLookup.parmQuery(query);
            sysTableLookup.performFormLookup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>name</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the category name for the category ID value provided.
    /// </summary>
    /// <param name="category">
    ///    The category ID value.
    /// </param>
    /// <returns>
    ///    The <c>Name</c> field from the <c>ProjCategory</c> table for the category ID provided.
    /// </returns>
    /// <remarks>
    ///    No validation of the category ID value is provided by this method.
    /// </remarks>
    public static Name name(ProjCategoryId category)
    {
        return ProjCategory::find(category).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType2CategoryType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a category transaction enumeration data type that is based on the project transaction
    /// type.
    /// </summary>
    /// <param name="_projTransType">
    /// A <c>_projTransType</c> enumeration value.
    /// </param>
    /// <returns>
    /// A <c>ProjCategoryType</c> enumeration data type that corresponds to the category type.
    /// </returns>
    public static ProjCategoryType transType2CategoryType(ProjTransType _projTransType)
    {
        ProjCategoryType retval;

        switch (_projTransType)
        {
            case ProjTransType::None:
                retval = ProjCategoryType::None;
                break;

            case ProjTransType::Hour:
                retval = ProjCategoryType::Hour;
                break;

            case ProjTransType::Cost:
                retval = ProjCategoryType::Cost;
                break;

            case ProjTransType::Item:
                retval = ProjCategoryType::Item;
                break;

            case ProjTransType::Revenue:
                retval = ProjCategoryType::Revenue;
                break;

            default:
                EventHandlerResult result = EventHandlerResult::newSingleResponse();
                ProjCategory::transType2CategoryTypeDelegate(_projTransType, result);
                if (result.hasResult())
                {
                    retval = result.result();
                }
                else
                {
                    throw error(strFmt("@SYS5932", _projTransType));
                }
        }

        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType2CategoryTypeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for getting the <c>ProjCategoryType</c> enumeration value given a <c>ProjTransType</c> enumeration value.
    /// </summary>
    /// <param name = "_projTransType">
    /// The <c>ProjTransType</c> enumeration value.
    /// </param>
    /// <param name = "_eventResult">
    /// An <c>EventHandlerResult</c> instance, where subscribers can provide default <c>ProjCategoryType</c> enumeration value.
    /// </param>
    static delegate void transType2CategoryTypeDelegate(ProjTransType _projTransType, EventHandlerResult _eventResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a formatted message stating that the category ID does not exist.
    /// </summary>
    /// <returns>
    ///    A formatted string base on the label "SYS1434".
    /// </returns>
    public static str 80 txtNotExist()
    {
        // Category '%1' does not exist.
        return "@SYS1434";
    }

]]></Source>
			</Method>
			<Method>
				<Name>validCategory</Name>
				<Source><![CDATA[
    public static boolean validCategory(ProjCategoryId _categoryId)
    {
        boolean ret;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            ret = ProjCategory::find(_categoryId).psaIndirectComponent ? false:true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjCategoryTypeItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check the Project category of type item.
    /// </summary>
    /// <param name="_projCategoryId">
    /// The project category id value.
    /// </param>
    /// <returns>
    /// True if category type is item ; otherwise false;
    /// </returns>
    public static boolean isProjCategoryTypeItem(ProjCategoryId	_projCategoryId)
    {
        boolean isItemTypeCategory = true;

        ProjCategoryType projCategoryType = ProjCategory::find(_projCategoryId).CategoryType;
        if (projCategoryType != ProjCategoryType::Item)
        {
            isItemTypeCategory = false;
        }
		
        return isItemTypeCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjCategoryTypeHour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check the Project category of type hour.
    /// </summary>
    /// <param name="_projCategoryId">
    /// The project category id value.
    /// </param>
    /// <returns>
    /// True if category type is hour; otherwise false;
    /// </returns>
    public static boolean isProjCategoryTypeHour(ProjCategoryId	_projCategoryId)
    {
        boolean isHourTypeCategory = true;

        ProjCategoryType projCategoryType = ProjCategory::find(_projCategoryId).CategoryType;
        if (projCategoryType != ProjCategoryType::Hour)
        {
            isHourTypeCategory = false;
        }
  
        return isHourTypeCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectTransType</Name>
				<Source><![CDATA[
    public ProjTransType getProjectTransType()
    {
        ProjTransType transactionType;

        switch (this.CategoryType)
        {
            case ProjCategoryType::Cost:
                transactionType = ProjTransType::Cost;
                break;
            case ProjCategoryType::Item:
                transactionType = ProjTransType::Item;
                break;
            case ProjCategoryType::Revenue:
                transactionType = ProjTransType::Revenue;
                break;
            case ProjCategoryType::Hour:
                transactionType = ProjTransType::Hour;
                break;
            default: 
                transactionType = ProjTransType::None;
        }

        return transactionType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostWIPForProjGroup</Name>
				<Source><![CDATA[
    public boolean canPostWIPForProjGroup(ProjGroup _projGroup)
    {
        boolean canPostWip;

        switch (this.CategoryType)
        {
            case ProjCategoryType::Cost:
                canPostWip = _projGroup.CostTransTurnover;
                break;
            case ProjCategoryType::Item:
                canPostWip = _projGroup.ItemTransTurnover;
                break;
            case ProjCategoryType::Revenue:
                canPostWip = _projGroup.RevenueTransTurnover;
                break;
            case ProjCategoryType::Hour:
                canPostWip = _projGroup.EmplTransTurnover;
                break;
            default: canPostWip = false;
        }

        return canPostWip;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Project</ConfigurationKey>
	<DeveloperDocumentation>@SYS124888</DeveloperDocumentation>
	<FormRef>ProjCategory</FormRef>
	<Label>@SYS6114</Label>
	<TableGroup>Group</TableGroup>
	<TitleField1>CategoryId</TitleField1>
	<TitleField2>CategoryType</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>EntireTable</CacheLookup>
	<ClusteredIndex>CategoryIdx</ClusteredIndex>
	<DataSharingType>Duplicate</DataSharingType>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>ProjectManagementAndAccounting</Modules>
	<PrimaryIndex>CategoryIdx</PrimaryIndex>
	<ReplacementKey>CategoryIdx</ReplacementKey>
	<TableContents>DefaultData</TableContents>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>ProjRevenueTrans</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>CategoryId</Relation>
			<Table>ProjRevenueTrans</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjItemTrans</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>CategoryId</Relation>
			<Table>ProjItemTrans</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjEmplTrans</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>CategoryId</Relation>
			<Table>ProjEmplTrans</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjCostTrans</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>CategoryId</Relation>
			<Table>ProjCostTrans</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>ProjOnAccTrans</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation>CategoryId</Relation>
			<Table>ProjOnAccTrans</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CategoryId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Administration</Name>
			<Label>@SYS9853</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CategoryType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjCategoryEmplOption</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CategoryId</Name>
			<Label>@SYS113377</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CategoryId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CustPaymRetention</Name>
			<Label>@PSA11244</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PSACustPaymentRetention</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Description</Name>
			<Label>@SYS6303</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>FiscalInformation</Name>
			<Label>@GLS56</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxServiceCodeId_BR</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Integration</Name>
			<Label>@SYS119497</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SetupCategory</Name>
			<Label>@SYS88804</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Active</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SetupEstimate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SetupSubscription</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PSAIndirectComponent</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TsAbsence</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WebCategoryBrowsing</Name>
			<Label>@SYS74258</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CategoryType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WithholdingTax</Name>
			<Label>@SYS7372</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxWithholdItemGroupHeading_TH</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GST_IN</Name>
			<Label>@Tax:GST</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Exempt_IN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ServiceAccountingCodeTable_IN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TaxRateTypeGroup</Name>
			<Label>@TaxInfoManagement:TaxRateType</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxRateType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Active</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryActive</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CategoryGroupId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryGroupId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CategoryId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CategoryType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjCategoryType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjCategoryEmplOption</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjCategoryEmplOption</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSACustPaymentRetention</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@PSA11244</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PSAIndirectComponent</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@PSA2379</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SetupEstimate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategorySetupEstimate</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SetupSubscription</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategorySetupSubscription</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxItemGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxItemGroup</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxServiceCodeId_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxServiceCodeId_BR</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxWithholdItemGroupHeading_TH</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>TaxWithholdItemGroupId_TH</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TsAbsence</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS3414</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Exempt_IN</Name>
			<ConfigurationKey>CRSEIndia</ConfigurationKey>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<HelpText>@TaxGST:HelpTextOfExempt</HelpText>
			<Label>@GLS93026</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ServiceAccountingCodeTable_IN</Name>
			<ConfigurationKey>CRSEIndia</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<HelpText>@TaxGST:EnterAServiceAccountingCode</HelpText>
			<Label>@TaxGST:ServiceAccountingCode</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxRateType</Name>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@TaxInfoManagement:TaxRateType</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>CategoryIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>CategoryId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TypeIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CategoryType</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>CategoryTable</Name>
			<Cardinality>ZeroOne</Cardinality>
			<EntityRelationshipRole>@SYS124889</EntityRelationshipRole>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>CategoryTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CategoryId</Name>
					<Field>CategoryId</Field>
					<RelatedField>CategoryId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjCategoryGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124890</EntityRelationshipRole>
			<RelatedTable>ProjCategoryGroup</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CategoryGroupId</Name>
					<SourceEDT>ProjCategoryGroupId</SourceEDT>
					<Field>CategoryGroupId</Field>
					<RelatedField>CategoryGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxItemGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxItemGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxItemGroupHeading</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjCategory</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxItemGroupId</Name>
					<SourceEDT>TaxItemGroup</SourceEDT>
					<Field>TaxItemGroupId</Field>
					<RelatedField>TaxItemGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxItemGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxWithholdItemGroupHeading_TH</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxWithholdItemGroupHeading_TH</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxWithholdItemGroupHeading_TH</Name>
					<Field>TaxWithholdItemGroupHeading_TH</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ServiceAccountingCodeTable_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ServiceAccountingCodeTable_IN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ServiceAccountingCodeTable_IN</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ServiceAccountingCodeTable_IN_ProjCategory</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ServiceAccountingCodeTable_IN</Name>
					<Field>ServiceAccountingCodeTable_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TaxRateType</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxRateType</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxRateType</Name>
					<Field>TaxRateType</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>