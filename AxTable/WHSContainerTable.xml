<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSContainerTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class WHSContainerTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateVolume</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates total volume of the container.
    /// </summary>
    /// <returns>
    /// Calculated volume.
    /// </returns>
    public Weight calculateVolume()
    {
        Volume                  volume;
        InventParameters        inventParameters = InventParameters::find();
        WHSContainerLine        containerLine;

        while select containerLine
            where containerLine.ContainerId  == this.ContainerId  &&
                  containerLine.ShipmentId   == this.ShipmentId
        {
            volume += EcoResPhysicalProductDimensions::calculatePackingVolume(containerLine.itemKey().productKey(), containerLine.Qty, containerLine.UnitId, inventParameters.VolumeUnitSymbol);
        }

        WHSContainerTable       containerTable;

        while select containerTable
            where containerTable.ParentContainerId   == this.ContainerId &&
                  containerTable.ShipmentId          == this.ShipmentId
        {
            if (WHSContainerType::exist(containerTable.ContainerTypeCode))
            {
                volume += WHSContainerType::find(containerTable.ContainerTypeCode).MaxVolume;
            }
            else
            {
                // If the container type doesn't exist then we assume that this is a full case or other UOM of an item and we need to grab dims from the item.
                volume += containerTable.calculateVolume();
            }
        }

        return volume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates total weight of the container.
    /// </summary>
    /// <returns>
    /// Calculated weight.
    /// </returns>
    public Weight calculateWeight()
    {
        Weight              weight;
        InventParameters    inventParameters = InventParameters::find();

        WHSContainerLine    containerLine;

        while select containerLine
            where containerLine.ContainerId == this.ContainerId
            &&    containerLine.ShipmentId  == this.ShipmentId
        {
            weight += EcoResPhysicalProductDimensions::calculatePackingWeight(containerLine.itemKey().productKey(), containerLine.Qty, containerLine.UnitId, inventParameters.MassUnitSymbol);
        }

        WHSContainerTable   innerContainer;

        // Assume weight of internal containers is correct.
        select sum(Weight) from innerContainer
            where innerContainer.ParentContainerId == this.ContainerId
                && innerContainer.ShipmentId       == this.ShipmentId;

        weight += innerContainer.Weight;

        // Include Tare weight
        weight += WHSContainerType::find(WHSContainerTable::find(this.ShipmentId, this.ContainerId).ContainerTypeCode).TareWeight;

        return weight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateWeightInUOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates total weight of the container in a given unit of measure.
    /// </summary>
    /// <param name = "_uomSymbol">A unit of measure to calculate weight in.</param>
    /// <returns>Calculated weight in a given unit of measure.</returns>
    public Weight calculateWeightInUOM(UnitOfMeasureSymbol _uomSymbol)
    {
        Weight calculatedContainerWeight;

        UnitOfMeasureSymbol systemUOMWeightSymbol = UnitOfMeasure::find(UnitOfMeasureSystemUnit::findByUnitOfMeasureClass(UnitOfMeasureClass::Mass).UnitOfMeasure).Symbol;
        Weight calculatedContainerStandardWeight = this.calculateWeight();

        if (systemUOMWeightSymbol
            && _uomSymbol
            && _uomSymbol != systemUOMWeightSymbol)
        {
            calculatedContainerWeight = UnitOfMeasureConverter::convert(
                                                                    calculatedContainerStandardWeight,
                                                                    UnitOfMeasure::findBySymbol(systemUOMWeightSymbol).RecId,
                                                                    UnitOfMeasure::findBySymbol(_uomSymbol).RecId,
                                                                    NoYes::No,
                                                                    0,
                                                                    NoYes::No);
        }
        else
        {
            calculatedContainerWeight = calculatedContainerStandardWeight;
        }

        return calculatedContainerWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setContainerNumOnContainerWithHighestContainerNum</Name>
				<Source><![CDATA[
    private void setContainerNumOnContainerWithHighestContainerNum(
        WHSShipmentId	_shipmentId,
        WHSContainerNum _containerNum)
    {
        WHSContainerTable containerTable;

        // Fill in containerNum gap if containerNum being removed is not the highest
        select firstonly forupdate containerTable
            order by containerTable.ContainerNum desc
            where  containerTable.ShipmentId        == _shipmentId
                && containerTable.ContainerNum       > _containerNum
                && containerTable.ContainerLevel    == 0;

        if (containerTable.RecId)
        {
            containerTable.ContainerNum = _containerNum;

            if (!containerTable.validateWrite())
            {
                throw error(strFmt("@WAX:WHSCannotUpdateRecordInTable", tablePName(WHSContainerTable)));
            }
            else
            {
                containerTable.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        WHSContainerTable        containersWithSameContainerGroup;
        WHSShipmentStatusUpdater shipmentStatusUpdater = WHSShipmentStatusUpdater::newFromShipmentId(this.ShipmentId);
        shipmentStatusUpdater.updateWhenContainerDeleted(this.ContainerId);

        WHSLoadId loadId = WHSShipmentTable::find(this.ShipmentId).LoadId;

        WHSLoadStatusUpdater loadStatusUpdater = WHSLoadStatusUpdater::newFromLoadId(loadId);
        loadStatusUpdater.updateWhenContainerDeleted(this.ContainerId);

        ttsbegin;

        if (this.ContainerLevel == 0)
        {
            this.setContainerNumOnContainerWithHighestContainerNum(this.ShipmentId, this.ContainerNum);
        }

        // Must delete the current container before trying to delete the parent container.
        super();

        // Delete the parent container table if it has no more containers within it
        if (this.ParentContainerId)
        {
            WHSContainerTable containerTable;
            
            select count(RecId) from containerTable
                where containerTable.ParentContainerId == this.ParentContainerId;

            if (!containerTable.RecId)
            {
                containerTable = WHSContainerTable::find(this.ShipmentId, this.ParentContainerId, true);
                if (!containerTable.validateDelete())
                {
                    throw error(strFmt("@WAX:WHSCannotDeleteRecordInTable", tablePName(WHSContainerTable)));
                }
                else
                {
                    containerTable.delete();
                }
            }
            else
            {
                // Update the weight of the parent container
                containerTable = WHSContainerTable::find(this.ShipmentId, this.ParentContainerId, true);
                containerTable.Weight -= this.Weight;
                containerTable.update();
            }
        }

        if (this.ContainerGroupingLicensePlateId)
        {
            WHSLicensePlate::removeFromParentLP(this.ContainerId);

            // Unmanifest the container group if needed
            if (WHSCloseContainerProfile::find(this.CloseContainerProfileId).ManifestRequirementsForContainerGroup == WHSManifestRequirementContainerGroup::Manual &&
                WHSContainerGroupManifest::find(this.ContainerGroupingLicensePlateId).ContainerGroupTrackingNumber)
            {
                select firstonly RecId from containersWithSameContainerGroup
                    where containersWithSameContainerGroup.ContainerId                     != this.ContainerId
                    &&    containersWithSameContainerGroup.ContainerGroupingLicensePlateId == this.ContainerGroupingLicensePlateId;

                // If no other containers are part of the group, make sure that the container group is unmanifested
                if (containersWithSameContainerGroup.RecId == 0)
                {
                    WHSContainerTable::unManifestContainerGroup(this.ContainerGroupingLicensePlateId);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Display method of the Load id field.
    /// </summary>
    /// <returns>
    /// Load id of the container.
    /// </returns>
    public display WHSLoadId displayLoadId()
    {
        return WHSShipmentTable::find(this.ShipmentId).LoadId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalFreight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Display method for total freight rate.
    /// </summary>
    /// <returns>
    /// Total freight rate.
    /// </returns>
    public display TMSRate displayTotalFreight()
    {
        return (select RateCur from tmsRouteRateDetail where tmsRouteRateDetail.Id == this.ContainerId).RateCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstContainerLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets first container line in the container.
    /// </summary>
    /// <returns>
    /// The first <c>WHSContainerLine</c> record in the container.
    /// </returns>
    public WHSContainerLine getFirstContainerLine()
    {
        WHSContainerLine containerLine;

        select firstonly containerLine
            where containerLine.ContainerId  == this.ContainerId &&
                  containerLine.ShipmentId   == this.ShipmentId;

        return containerLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUnstagedWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether there is an unstaged work for the container.
    /// </summary>
    /// <returns>
    /// True if there is an unstaged work.
    /// </returns>
    public boolean hasUnstagedWork()
    {
        WHSWorkLine workLine;
        WHSWorkLine firstOpenWorkLine;
        boolean     ret;

        select firstonly RecId from workLine
            order by firstOpenWorkLine.LineNum asc
            where workLine.ContainerId == this.ContainerId
        join firstOpenWorkLine
            where firstOpenWorkLine.WorkId      == workLine.WorkId
                && firstOpenWorkLine.WorkStatus == WHSWorkStatus::Open
                && firstOpenWorkLine.WorkType    == WHSWorkType::Pick;

        if (firstOpenWorkLine.RecId && !WHSWorkLine::isPutBefore(firstOpenWorkLine.WorkId, firstOpenWorkLine.LineNum))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromContainerType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the record from a container type.
    /// </summary>
    /// <param name="_updateWeight">
    /// True if the weight of the container will be updated.
    /// </param>
    public void initFromContainerType(boolean _updateWeight = true)
    {
        WHSContainerType    containerType;

        containerType = WHSContainerType::find(this.ContainerTypeCode);

        if (containerType.RecId)
        {
            this.ContainerAttributeCode = containerType.ContainerAttributeCode;
            this.Length = containerType.Length;
            this.Height = containerType.Height;
            this.Width = containerType.Width;
            this.Weight = _updateWeight ? containerType.TareWeight : this.Weight;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertMandatoryFieldsNotBlank</Name>
				<Source><![CDATA[
    private void assertMandatoryFieldsNotBlank()
    {
        WHSMandatoryFieldValidator::assertNotBlank(this, fieldNum(WHSContainerTable, ShipmentId));
        WHSMandatoryFieldValidator::assertNotBlank(this, fieldNum(WHSContainerTable, ContainerId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        ttsbegin;
        WHSShipmentStatusUpdater shipmentStatusUpdater = WHSShipmentStatusUpdater::newFromShipmentId(this.ShipmentId);
        shipmentStatusUpdater.updateWhenContainerCreated();

        WHSLoadId loadId = WHSShipmentTable::find(this.ShipmentId).LoadId;

        WHSLoadStatusUpdater loadStatusUpdater = WHSLoadStatusUpdater::newFromLoadId(loadId);
        loadStatusUpdater.updateWhenContainerCreated();

        this.initFromContainerType();

        if (this.ContainerGroupingLicensePlateId)
        {
            WHSLicensePlate::createLicensePlate(this.ContainerGroupingLicensePlateId);
        }

        this.InventoryTransactionMechanism = WHSInventoryTransactionConfigurationProvider::chooseAppropriateTransactionMechanismForContainer();
        super();
        this.assertMandatoryFieldsNotBlank();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the container contains another container.
    /// </summary>
    /// <returns>
    /// True if the container is a parent container.
    /// </returns>
    public boolean isParent()
    {
        WHSContainerTable childCon;

        if (this.ContainerId)
        {
            select firstonly RecId from childCon
                where childCon.ParentContainerId == this.ContainerId;
        }

        return childCon.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>manifestContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes an overall run when the container structure has changed.
    /// </summary>
    /// <param name="_weightChanged">
    /// Determines whether the weight of the container has changed.
    /// </param>
    /// <param name="_newWeight">
    /// New weight of the container.
    /// </param>
    /// <returns>
    /// True if the manifest has succeeded.
    /// </returns>
    public boolean manifestContainer(
        boolean	_weightChanged,
        Weight	_newWeight		= this.Weight)
    {
        boolean ret;

        var whsManifestContainer = WHSManifestContainer::newStandard(_newWeight, this);
        ret = whsManifestContainer.run(_weightChanged);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>manifestContainerGroupManual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Manifests a container group
    /// </summary>
    /// <param name="_containerGroupingLicensePlateId">
    /// License plate of the container group
    /// </param>
    /// <param name="_containerGroupTrackingNumber">
    /// Tracking number of the container group
    /// </param>
    /// <param name="_weightUOM">
    /// Unit of measure for the container group.
    /// </param>
    /// <param name="_newWeight">
    /// New weight of the container group.
    /// </param>
    /// <returns>
    /// True if the group manifest has succeeded; otherwise false
    /// </returns>
    public static boolean manifestContainerGroupManual(WHSContainerGroupingLicensePlateId   _containerGroupingLicensePlateId,
                                                       ShipCarrierTrackingNum               _containerGroupTrackingNumber,
                                                       WHSWeightUOM                         _weightUOM,
                                                       Weight                               _newWeight)
    {
        boolean                     ret = true;
        WHSContainerGroupManifest   containerGroupManifest;

        if (_newWeight <= 0)
        {
            ret = checkFailed("@WAX:WeightMustBePositive");
        }

        if (!_containerGroupTrackingNumber)
        {
            ret = checkFailed("@WAX:ContainerTrackingNumberMustBeSpecified");
        }

        if (ret)
        {
            ttsbegin;

            containerGroupManifest.ContainerGroupingLicensePlateId  = _containerGroupingLicensePlateId;
            containerGroupManifest.ContainerGroupTrackingNumber     = _containerGroupTrackingNumber;
            containerGroupManifest.Weight                           = _newWeight;
            containerGroupManifest.WeightUOM                        = _weightUOM;
            containerGroupManifest.insert();

            ttscommit;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickContainerToOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks the contents of the container to the related order.
    /// </summary>
    /// <remarks>
    /// Container should be in a closed status.
    /// </remarks>
    public void pickContainerToOrder()
    {
        WHSContainerSourceOrderTransactionUpdater containerSourceOrderTransactionUpdater = WHSContainerSourceOrderTransactionUpdater::newFromContainerTable(this);
        containerSourceOrderTransactionUpdater.pickContainerToOrder();       
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastContainerTransactionInventDimIdOnFinalShippingLocation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal InventDimId getLastContainerTransactionInventDimIdOnFinalShippingLocation(
        WHSContainerLine    _containerLine,
        WHSShipFinalLocType _finalShippingLocation)
    {
        WHSContainerTrans   containerTrans;
        InventDim           inventDim;
        WMSLocation         location;
        WHSLocationProfile  whsLocationProfile;

        select firstonly InventDimIdTo from containerTrans
            order by TransDateTime desc
            where containerTrans.ContainerLine          == _containerLine.RecId
            exists join inventDim
                where inventDim.inventDimId             == containerTrans.InventDimIdTo
            exists join location
                where location.wMSLocationId            == inventDim.wMSLocationId
                    && location.inventLocationId        == inventDim.InventLocationId
            exists join whsLocationProfile
                where whsLocationProfile.LocProfileId   == location.LocProfileId
                    && whsLocationProfile.LocType       == _finalShippingLocation;

        return containerTrans.InventDimIdTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recursiveCloseContainer</Name>
				<Source><![CDATA[
    private void recursiveCloseContainer(boolean _usePessimisticLock)
    {
        ttsbegin;

        this.ContainerStatus = WHSContainerStatus::Closed;
        this.CloseContainerUTCDateTime = DateTimeUtil::getSystemDateTime();
        this.update();

        if (this.ContainerLevel > 0)
        {
            WHSContainerTable subContainer;

            select firstonly ParentContainerId, RecId from subContainer
                where subContainer.ParentContainerId == this.ParentContainerId
                    && subContainer.ContainerStatus != WHSContainerStatus::Closed;

            if (!subContainer.RecId)
            {
                WHSContainerTable parentContainer = _usePessimisticLock ? WHSContainerTable::findByContainerIdWithPessimisticLock(this.ParentContainerId) :
                    WHSContainerTable::findByContainerId(this.ParentContainerId, true);

                if (parentContainer)
                {
                    parentContainer.recursiveCloseContainer(_usePessimisticLock);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTrackingNumbersFromContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes tracking numbers from the container.
    /// </summary>
    public void removeTrackingNumbersFromContainer()
    {
        ShipCarrierTrackingNum localShipCarrierTrackingNum = this.ShipCarrierTrackingNum;

        if (localShipCarrierTrackingNum)
        {
            ttsbegin;

            this.selectForUpdate(true);
            this.ShipCarrierTrackingNum = '';
            this.update();

            if (WHSUseReturnDetailConfigurationProviderFlight::instance().isEnabled())
            {
                if (WHSReturnDetailConfigurationProvider::isContainerReturnDetailsCreationEnabled(this))
                {
                    this.removeReturnDetailReturnShipCarrierTrackingNum(this.ContainerId);
                }
            }
            else
            {
                if (WHSParameters::isReturnDetailsCreationEnabled())
                {
                    this.removeReturnDetailReturnShipCarrierTrackingNum(this.ContainerId);
                }
            }
            ttscommit;

            info(strFmt("@WAX:ContainerWithTrackingNumberHasBeenUnmanifested", this.ContainerId, localShipCarrierTrackingNum));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTrackingNumbersFromAllContainersRelatedToMasterTrackingNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes tracking numbers from all containers with the same master tracking number.
    /// </summary>
    public void removeTrackingNumbersFromAllContainersRelatedToMasterTrackingNum()
    {
        boolean isReturnDetailsCreationEnabled;
        
        if (WHSUseReturnDetailConfigurationProviderFlight::instance().isEnabled())
        {
            isReturnDetailsCreationEnabled = WHSReturnDetailConfigurationProvider::isContainerReturnDetailsCreationEnabled(this);
        }
        else
        {
            isReturnDetailsCreationEnabled = WHSParameters::isReturnDetailsCreationEnabled();
        }

        WHSContainerTable containerTable;

        ttsbegin;

        while select forupdate containerTable
            where containerTable.MasterTrackingNum == this.MasterTrackingNum
        {
            containerTable.ShipCarrierTrackingNum = '';
            containerTable.MasterTrackingNum = '';
            containerTable.update();

            if (isReturnDetailsCreationEnabled)
            {
                this.removeReturnDetailReturnShipCarrierTrackingNum(containerTable.ContainerId);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeReturnDetailReturnShipCarrierTrackingNum</Name>
				<Source><![CDATA[
    private void removeReturnDetailReturnShipCarrierTrackingNum(WHSContainerId _containerId)
    {
        WHSReturnDetail returnDetail = WHSReturnDetail::findForContainerId(_containerId, true);

        if (returnDetail.RecId
            && returnDetail.ReturnShipCarrierTrackingNum != '')
        {
            returnDetail.ReturnShipCarrierTrackingNum = '';
            returnDetail.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setContainerTableNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns a container number to the container.
    /// </summary>
    public void setContainerTableNum()
    {
        WHSContainerTable   containerTableNum;

        select firstonly ContainerNum from containerTableNum
            order by containerTableNum.ContainerNum desc
            where containerTableNum.ShipmentId       == this.ShipmentId &&
                  containerTableNum.ContainerLevel   == 0;

        this.ContainerNum = containerTableNum.ContainerNum + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParentContainerCodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates NMFC and STCC codes of parent containers.
    /// </summary>
    /// <param name="_origContainerTable">
    /// Original <c>WHSContainerTable</c> record.
    /// </param>
    public void setParentContainerCodes(WHSContainerTable _origContainerTable)
    {
        WHSContainerTable   parentContainer;
        WHSContainerTable   childContainer;

        ttsbegin;
        // Update new parent's nmfc and stcc codes
        parentContainer = WHSContainerTable::find(this.ShipmentId, this.ParentContainerId, true);
        if (parentContainer.RecId)
        {
            parentContainer.nmfcCode = parentContainer.nmfcCode ? parentContainer.nmfcCode : this.nmfcCode;
            parentContainer.stccCode = parentContainer.stccCode ? parentContainer.stccCode : this.stccCode;
            parentContainer.update();
        }

        parentContainer = WHSContainerTable::find(this.ShipmentId, _origContainerTable.ParentContainerId, true);

        // Update old parent's nmfc and stcc codes
        if (parentContainer.RecId)
        {
            select firstonly childContainer
                where childContainer.ParentContainerId   == _origContainerTable.ParentContainerId &&
                      childContainer.ShipmentId          == this.ShipmentId                       &&
                      childContainer.nmfcCode;

            parentContainer.nmfcCode = childContainer.nmfcCode;

            select firstonly childContainer
                where childContainer.ParentContainerId   == _origContainerTable.ParentContainerId &&
                      childContainer.ShipmentId          == this.ShipmentId                       &&
                      childContainer.stccCode;

            childContainer.stccCode  = childContainer.stccCode;
            parentContainer.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAndUnmanifestSingleContainerTransportationManagement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmanifests the container and throws warnings with the exact error messages in case the process failed.
    /// </summary>
    /// <returns>True if it was possible to unmanifest the container;otherwise, false.</returns>
    public boolean checkAndUnmanifestSingleContainerTransportationManagement()
    {
        container errorContainer = this.unmanifestSingleContainerTransportationManagement();

        return this.throwUnmanifestContainerWarnings(errorContainer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAndUnmanifestShipmentRelatedToContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmanifests the shipment related to the container and throws warnings with
    /// the exact error messages in case the process failed.
    /// </summary>
    /// <returns>True if it was possible to unmanifest the container;otherwise, false.</returns>
    public boolean checkAndUnmanifestShipmentRelatedToContainer()
    {
        container errorContainer = this.unmanifestShipmentRelatedToContainerTransportationManagement();

        return this.throwUnmanifestContainerWarnings(errorContainer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwUnmanifestContainerWarnings</Name>
				<Source><![CDATA[
    private boolean throwUnmanifestContainerWarnings(container _errorContainer)
    {
        if (conLen(_errorContainer) > 0)
        {
            for (int i = 1; i <= conLen(_errorContainer); ++i)
            {
                warning(strFmt('%1',conPeek(_errorContainer, i)));
            }

            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmanifestSingleContainerTransportationManagement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmanifests the current container using transportation management engines
    /// </summary>
    /// <returns>A container with all the generated warnings, if any, in case the process failed</returns>
    public container unmanifestSingleContainerTransportationManagement()
    {
        if (WHSShipmentTable::find(this.ShipmentId).ShipmentStatus == WHSShipmentStatus::Shipped)
        {
            throw error ("@WAX2584");
        }

        TMSContainerProcess containerProcess = new TMSContainerProcess();
        containerProcess.parmContainerId(this.ContainerId);
        containerProcess.voidContainer();

        return containerProcess.parmErrors();
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmanifestShipmentRelatedToContainerTransportationManagement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmanifests the shipment related to the current container using transportation management
    /// </summary>
    /// <returns>A container with all the generated warnings, if any, in case the process failed</returns>
    public container unmanifestShipmentRelatedToContainerTransportationManagement()
    {
        if (WHSShipmentTable::find(this.ShipmentId).ShipmentStatus == WHSShipmentStatus::Shipped)
        {
            throw error ("@WAX2584");
        }

        TMSShipmentProcess shipmentProcess = new TMSShipmentProcess();
        shipmentProcess.parmMasterTrackingNum(this.MasterTrackingNum);
        shipmentProcess.parmshipmentId(this.ShipmentId);
        shipmentProcess.voidAllContainer();

        return shipmentProcess.parmErrors();
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        WHSContainerLine    containerLine;
        boolean             updateLines;
        WHSContainerTable   origContainer = this.orig();

        this.assertMandatoryFieldsNotBlank();

        if (this.ShipmentId != origContainer.ShipmentId)
        {
            updateLines = true;
        }

        // Check to make sure that container structure doesn't change if the container is part of unstaged work.
        // Also prevent a container of being a parent of itself.
        if (this.ParentContainerId != origContainer.ParentContainerId)
        {
            if (!this.validateSelfParent())
            {
                throw error("@WAX3814");
            }
            if (this.hasUnstagedWork())
            {
                throw error("@WAX3811");
            }

            // Set NMFC and STCC codes
            this.setParentContainerCodes(origContainer);
        }

        // Update weight of parent containers
        this.updateParentContainerWeight(origContainer);

        // Update container num
        if (this.ContainerLevel == 0 && origContainer.ContainerLevel != 0)
        {
            this.setContainerTableNum();
        }
        else if (this.ContainerLevel != 0 && origContainer.ContainerLevel == 0)
        {
            this.ContainerNum = 0;
            this.setContainerNumOnContainerWithHighestContainerNum(origContainer.ShipmentId, origContainer.ContainerNum);
        }

        // Update container fields to match container type.
        if (this.ContainerTypeCode != origContainer.ContainerTypeCode)
        {
            // Assume that container type exists
            this.initFromContainerType(false);
            // Update container weight to include new tare weight.
            this.Weight = this.Weight + (WHSContainerType::find(this.ContainerTypeCode).TareWeight -
                                         WHSContainerType::find(origContainer.ContainerTypeCode).TareWeight);
        }

        if (this.ContainerGroupingLicensePlateId != this.orig().ContainerGroupingLicensePlateId)
        {
            if (this.ContainerGroupingLicensePlateId)
            {
                WHSLicensePlate::createLicensePlate(this.ContainerGroupingLicensePlateId);
                WHSLicensePlate::nestLicensePlate(this.ContainerGroupingLicensePlateId, this.ContainerId);
            }
            else
            {
                WHSLicensePlate::removeFromParentLP(this.ContainerId);
            }
        }

        super();

        ttsbegin;

        if (updateLines)
        {
            while select forupdate containerLine
                where containerLine.ContainerId == this.ContainerId
            {
                containerLine.ShipmentId = this.ShipmentId;
                containerLine.update();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParentContainerWeight</Name>
				<Source><![CDATA[
    private void updateParentContainerWeight(WHSContainerTable _origContainer)
    {
        WHSContainerTable parentContainer;
        Weight            diffWeight;

        ttsbegin;

        diffWeight = this.Weight - _origContainer.Weight;

        if (this.ParentContainerId && diffWeight)
        {
            parentContainer = WHSContainerTable::find(this.ShipmentId, this.ParentContainerId, true);
            parentContainer.Weight += diffWeight;
            
            if (!parentContainer.validateWrite())
            {
                throw error(strFmt("@WAX:WHSCannotUpdateRecordInTable", tablePName(WHSContainerTable)));
            }
            else
            {
                parentContainer.update();
            }
        }

        if (this.ParentContainerId != _origContainer.ParentContainerId)
        {
            if (_origContainer.ParentContainerId)
            {
                parentContainer = WHSContainerTable::find(_origContainer.ShipmentId, _origContainer.ParentContainerId, true);
                parentContainer.Weight -= this.Weight;
                
                if (!parentContainer.validateWrite())
                {
                    throw error(strFmt("@WAX:WHSCannotUpdateRecordInTable", tablePName(WHSContainerTable)));
                }
                else
                {
                    parentContainer.update();
                }
            }
            if (this.ParentContainerId)
            {
                parentContainer = WHSContainerTable::find(this.ShipmentId, this.ParentContainerId, true);
                parentContainer.Weight += this.Weight;
                
                if (!parentContainer.validateWrite())
                {
                    throw error(strFmt("@WAX:WHSCannotUpdateRecordInTable", tablePName(WHSContainerTable)));
                }
                else
                {
                    parentContainer.update();
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerForPacking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates, if the container can be used for a manual packing process.
    /// </summary>
    /// <param name = "_shipmentId">Shipment ID.</param>
    /// <param name = "_packStationLocation">Pack station location.</param>
    /// <returns>
    /// true, if a container can be used for a manual packing process; otherwise false.
    /// </returns>
    public boolean validateContainerForPacking(WHSShipmentId _shipmentId, WMSLocation _packStationLocation)
    {
        boolean ret = true;

        if (!this
            || this.ShipmentId		!= _shipmentId
            || this.ContainerStatus	== WHSContainerStatus::Closed)
        {
            ret = checkFailed("@WAX5651");
        }

        if (ret && this.ContainerBuildId)
        {
            ret = checkFailed("@WAX5805");
        }

        if (ret)
        {
            InventDim containerInventDim = InventDim::find(this.InventDimId);

            if (!containerInventDim
                || !_packStationLocation
                || containerInventDim.InventLocationId	!= _packStationLocation.inventLocationId
                || containerInventDim.wMSLocationId		!= _packStationLocation.wMSLocationId)
            {
                ret = checkFailed(strFmt("@WAX:ContainerIsNotOnPackingStation", this.ContainerId));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;

        ret = super();

        if (this.ContainerGroupingLicensePlateId
            && this.CloseContainerProfileId)
        {
            WHSCloseContainerProfile closeContainerProfile = WHSCloseContainerProfile::find(this.CloseContainerProfileId);

            if (closeContainerProfile.AutoReleaseContainerAtContainerClose == WHSAutoReleaseContainerAtContainerClose::Always)
            {
                ret = checkFailed("@WAX:MessageContainerGroupLicensePlateIdCannotBeUsedWithAutomaticRelease");
            }

            if (closeContainerProfile.shouldContainerBeAvailableAtFinalShippingLocation())
            {
                ret = checkFailed("@WAX:MessageContainerGroupLicensePlateIdCannotBeUsedWithMakeAvailableAtFinalShipLoc");
            }
        }

        ret = ret && this.validateContainerGroupingLicensePlateId();

        if (this.ContainerGroupingLicensePlateId != this.orig().ContainerGroupingLicensePlateId)
        {
            WHSContainerGroupManifest groupManifestFrom;
            WHSContainerGroupManifest groupManifestTo;

            if (this.ContainerGroupingLicensePlateId)
            {
                groupManifestTo = WHSContainerGroupManifest::find(this.ContainerGroupingLicensePlateId);
            }

            if (this.orig().ContainerGroupingLicensePlateId)
            {
                groupManifestFrom = WHSContainerGroupManifest::find(this.orig().ContainerGroupingLicensePlateId);
            }

            if (groupManifestFrom || groupManifestTo)
            {
                ret = checkFailed("@WAX:ErrorCannotChangeContainerGroupWhenItIsManifested");
            }
        }

        if (ret && WHSContainerTable::existsContainerGroupingLicensePlateId(this.ContainerId))
        {
            ret = checkFailed(strFmt("@WAX:ErrorContainerLicensePlateAndGroupingLicensePlateAreSame", this.ContainerId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean ret;

        ret = super();

        if (this.isParent())
        {
            ret = checkFailed("@WAX3810");
        }

        if (!this.skipClosedStatusValidationOnDelete()
	      && this.ContainerStatus == WHSContainerStatus::Closed)
        {
            ret = checkFailed("@WAX2373");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipClosedStatusValidationOnDelete</Name>
				<Source><![CDATA[
	private boolean skipClosedStatusValidationOnDelete()
    {
        WHSUnshipLoadLineSkipClosedStatusValidationOnContainerDeleteContext context = WHSUnshipLoadLineSkipClosedStatusValidationOnContainerDeleteContext::current();
        WHSAdjustContainerLineQtySkipParentValidationContext contextContainerLineQtyAdjustment = WHSAdjustContainerLineQtySkipParentValidationContext::current();

        return (context
                    && context.skipClosedStatusValidation)
            || (contextContainerLineQtyAdjustment
                    && contextContainerLineQtyAdjustment.skipClosedStatusValidation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSelfParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that a child container is not declared as parent container before.
    /// </summary>
    /// <param name="_parentContainerId">
    /// Container id of the parent container.
    /// </param>
    /// <returns>
    /// True if the descendants of the container doesn't contain a parent container.
    /// </returns>
    public boolean validateSelfParent(WHSParentContainerId _parentContainerId = this.ParentContainerId)
    {
        WHSContainerTable   childContainer;
        boolean             ret = true;

        while select childContainer
            where childContainer.ParentContainerId == this.ContainerId
        {
            if (childContainer.ContainerId == _parentContainerId)
            {
                ret = false;
                break;
            }

            ret = childContainer.validateSelfParent(_parentContainerId);
            if (!ret)
            {
                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>beginLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a voucher to ledger for a container.
    /// </summary>
    /// <param name="_containerId">
    /// The id of the container.
    /// </param>
    /// <returns>
    /// The ledger voucher.
    /// </returns>
    public static LedgerVoucher beginLedger(WHSContainerId  _containerId)
    {
        LedgerVoucherObject ledgerVoucherObject;
        TransactionTxt      transactionTxt = TransactionTxt::construct();
        NumberSeq           numberSeq;
        WHSInventVoucherId  voucherId;
        LedgerVoucher       ledgerVoucher;

        numberSeq           = NumberSeq::newGetNum(WHSParameters::numRefWHSInventVoucherId());
        voucherId           = numberSeq.num();

        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,SysModule::Invent,numberSeq.parmNumberSequenceCode());

        transactionTxt.setType(LedgerTransTxt::InventTransferOrder);
        transactionTxt.setDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        transactionTxt.setVoucher(voucherId);
        transactionTxt.setKey1(_containerId);

        ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucherId,
                                                              DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                                              SysModule::Invent,
                                                              LedgerTransType::Invent);

        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
        ledgerVoucher.addVoucher(ledgerVoucherObject);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRelatedToWorkContainersCreatedByContainerization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all the containers related to a work, which were created by the containerization process.
    /// </summary>
    /// <param name = "_workId">Work ID used to determine which containers to delete.</param>
    public static void deleteRelatedToWorkContainersCreatedByContainerization(WHSWorkId _workId)
    {
        WHSWorkLine         workLine;
        WHSContainerTable   containerTable;

        ttsbegin;

        LineNum firstPutLineNum = WHSWorkTable::getFirstPutWorkLine(_workId).LineNum;

        while select workLine
            where workLine.WorkId == _workId
                && workLine.LineNum < firstPutLineNum
                && workLine.ContainerId   != ''
                && workLine.WorkStatus != WHSWorkStatus::Cancelled
                && workLine.WorkType == WHSWorkType::Pick
            exists join containerTable
                where containerTable.ContainerBuildId != ''
                    && containerTable.ShipmentId  == workLine.ShipmentId
                    && containerTable.ContainerId == workLine.ContainerId
        {
            WHSContainerLine::adjustQuantityBasedOnWorkLine(workLine, -workLine.InventQtyWork);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupOutboundSortWorkContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleanup containers associated with outbound work.
    /// </summary>
    /// <param name="_shipmentId">
    /// The shipment ID for the container.
    /// </param>
    /// <param name="_containerId">
    /// The container ID for the container.
    /// </param>
    [Hookable(false)]
    internal static void cleanupOutboundSortWorkContainer(
        WHSShipmentId    _shipmentId,
        WHSContainerId   _containerId)
    {
        ttsbegin;

        WHSContainerTable::reOpenContainer(_shipmentId, _containerId);

        WHSContainerTable containerTable = WHSContainerTable::find(_shipmentId, _containerId, true);

        if (containerTable.RecId)
        {
            containerTable.delete();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupShipmentContainers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clean up empty containers on shipment.
    /// </summary>
    /// <param name = "_shipmentId">The Shipment ID.</param>
    [Hookable(false)]
    internal static void cleanupShipmentContainers(WHSShipmentId _shipmentId)
    {
        WHSContainerTable   containerTable, childCon;
        WHSContainerLine    containerLine;

        ttsbegin;

        delete_from containerTable
            where containerTable.ShipmentId        == _shipmentId
                && containerTable.ContainerStatus   == WHSContainerStatus::Open
            notexists join containerLine
                where containerLine.ContainerId == containerTable.ContainerId
            notexists join childCon
                where childCon.ParentContainerId == containerTable.ContainerId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the close container process.
    /// </summary>
    /// <param name="_shipmentId">
    /// The shipment of the container being closed.
    /// </param>
    /// <param name="_containerId">
    /// The container Id of the container being closed.
    /// </param>
    /// <param name="_weight">
    /// The captured gross weight of the container being closed.
    /// </param>
    /// <param name="_weightUOM">
    /// The unit of measure the weight is stored in.
    /// </param>
    /// <param name="_putLocation">
    /// The location the container is being moved to.
    /// </param>
    /// <param name="_releaseContainer">
    /// Should the container be released on closing?
    /// </param>
    /// <param name="_containerTrackingId">
    /// Container tracking if manifesting is part of the container closing process; optional.
    /// </param>
    /// <param name="_containerGroupingLicensePlateId">
    /// Container grouping license plate id; optional.
    /// </param>
    public static void closeContainer(
        WHSShipmentId                       _shipmentId,
        WHSContainerId                      _containerId,
        Weight                              _weight,
        WHSWeightUOM                        _weightUOM,
        WMSLocationId                       _putLocation,
        boolean                             _releaseContainer,
        ShipCarrierTrackingNum              _containerTrackingId                = '',
        WHSContainerGroupingLicensePlateId  _containerGroupingLicensePlateId    = '')
    {
        WHSCloseContainerParameters closeContainerParams = WHSCloseContainerParameters::createFromParameters(
            _shipmentId,
            _containerId,
            _weight,
            _weightUOM,
            _putLocation,
            _releaseContainer,
            _containerTrackingId,
            _containerGroupingLicensePlateId,
            false);

        WHSContainerTable::closeContainerUsingParam(closeContainerParams);
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerUsingParam</Name>
				<Source><![CDATA[
    public static void closeContainerUsingParam(WHSCloseContainerParameters _closeContainerParams)
    {
        WHSContainerTable           containerTable;
        WHSCloseContainerProfile    closeContainerProfile;
        WHSShipmentTable            shipmentTable;
        boolean                     weightChange;
        boolean                     releaseContainer = false;

        WHSInstrumentationLogger instrumentationLogger = WHSInstrumentationLogger::CreateLogger(tableStr(WHSContainerTable));

        using (var activityContext = instrumentationLogger.containerTableActivities().closeContainer())
        {
            try
            {
                ttsbegin;
                
                containerTable = WHSContainerTable::findByContainerIdWithPessimisticLock(_closeContainerParams.parmContainerId());
                InventDimId preCloseContainerInventDimId = containerTable.InventDimId;

                instrumentationLogger.logRecordInformation(containerTable);

                shipmentTable = WHSShipmentTable::find(_closeContainerParams.parmShipmentId(), true);

                // Validate that all requirements for closing the container are met
                WHSContainerTable::closeContainerErrorCheck(containerTable, shipmentTable, _closeContainerParams.parmWeight(), _closeContainerParams.parmContainerTrackingId());

                closeContainerProfile = WHSCloseContainerProfile::find(containerTable.CloseContainerProfileId);

                // Container should be released if it is defined in the container policy. If container policy is set to optional release, we will release if manually specified by user
                releaseContainer = (closeContainerProfile.AutoReleaseContainerAtContainerClose == WHSAutoReleaseContainerAtContainerClose::Always) || _closeContainerParams.parmReleaseContainer();

                if (!WHSContainerTable::validateReleaseContainerContainerGroupingLicensePlateId(releaseContainer, _closeContainerParams.parmContainerGroupingLicensePlateId()))
                {
                    throw error ("@WAX:ErrorContainerGroupingCannotBeUsedWhenReleasingContainer");
                }

                if (roundUp(containerTable.Weight, 1) != roundUp(_closeContainerParams.parmWeight(), 1))
                {
                    weightChange = true;
                }
                                
                // Update container
                containerTable.Weight      = _closeContainerParams.parmWeight();
                containerTable.WeightUOM    = _closeContainerParams.parmWeightUOM();
                
                containerTable.initializeDuringClose(closeContainerProfile, _closeContainerParams.parmContainerTrackingId());

                if (!containerTable.validateWrite())
                {
                    throw error("@WAX:ErrorContainerValidation");
                }

                containerTable.write();

                // Return details need to be created before calling manifestContainer as manifesting can depend on the return details.
                if (WHSReturnDetailOrderTypeCalculator::calculateReturnDetailOrderType(shipmentTable.WorkTransType) != WHSReturnDetailOrderType::Unsupported)
                {
                    WHSContainerCloseReturnDetailCreator returnDetailCreator = WHSContainerCloseReturnDetailCreator::newFromContainer(containerTable);
                    returnDetailCreator.createReturnDetails();
                }

                // Containers created by containerization do not perform manifesting
                if (!containerTable.ContainerBuildId
                &&  closeContainerProfile.ManifestAtContainerClose
                &&  closeContainerProfile.ManifestRequirementsForContainer == WHSManifestRequirement::TransportationManagement)
                {
                    //Split transactions if we need manifesting.
                    ttscommit;
                    containerTable.manifestContainer(weightChange);
                    ttsbegin;
                }

                // Buffer may no longer be up to date.
                containerTable = WHSContainerTable::find(_closeContainerParams.parmShipmentId(), _closeContainerParams.parmContainerId(), true);

                // Containers created by containerization do not perform any additional actions.
                if (!containerTable.ContainerBuildId)
                {
                    boolean printContainerContentsAfterClosing = WHSCloseContainerPrintContainerContentsFlight::instance().isEnabled();

                    // Print Container content report
                    if (!printContainerContentsAfterClosing && closeContainerProfile.canPrintContainerContents())
                    {
                        WHSContainerTable::printContainerContents(containerTable, NoYes::No);
                    }

                    WHSLicensePlateId licensePlateIdForTheContainer = containerTable.ContainerId;

                    if (closeContainerProfile.shouldContainerBeAvailableAtFinalShippingLocation())
                    {
                        WMSLocation putLocation = WMSLocation::find(_closeContainerParams.parmPutLocation(), containerTable.containerWarehouseId(closeContainerProfile));

                        containerTable.closeContainerWithoutWorkCreation(releaseContainer, putLocation, licensePlateIdForTheContainer);

                        if (releaseContainer)
                        {
                            containerTable.updateShipmentAndLoadStatus(shipmentTable, _closeContainerParams.parmContainerId());
                        }
                    }
                    else if (closeContainerProfile.shouldWorkBeCreatedToMoveFromPickingLocation())
                    {
                        containerTable.validateAndUpdateContainerTableWithContainerGroupingLicensePlateId(licensePlateIdForTheContainer, _closeContainerParams.parmContainerGroupingLicensePlateId());

                        containerTable.closeContainerWithWorkCreation(releaseContainer, licensePlateIdForTheContainer);
                    }
                    else if (closeContainerProfile.ContainerClosingWorkCreationProcess == WHSWarehouseContainerClosingWorkCreationProcess::AssignContainerToSortPosition)
                    {
                        WMSLocation putLocation = WMSLocation::find(_closeContainerParams.parmPutLocation(), containerTable.containerWarehouseId(closeContainerProfile));

                        containerTable.closeContainerWithNewInventDim(putLocation, licensePlateIdForTheContainer);
                        containerTable.closeContainerCreateTransactions(putLocation, licensePlateIdForTheContainer);

                        WHSContainerTable::closeContainerBeforeSort(containerTable.ContainerId);
                        WHSOutboundSortRFInstruction::createNewInstructionsFromContainer(containerTable.ContainerId, containerTable.ShipmentId);
                    }

                    // Print Container content report
                    if (printContainerContentsAfterClosing && closeContainerProfile.canPrintContainerContents())
                    {
                        WHSContainerTable::printContainerContents(containerTable, NoYes::No);
                    }

                    // Print container labels
                    if (closeContainerProfile.canPrintContainerLabelsOnClose())
                    {
                        WHSContainerLabelRoutingProcessor::printLabelForClosedContainer(containerTable, preCloseContainerInventDimId);
                    }
                }

                containerTable.printContainerShippingLabel(closeContainerProfile);
                containerTable.printContainerReturnShippingLabel(closeContainerProfile);
                containerTable.closePackingWork();
                containerTable.postClosed();

                ttscommit;
            }
            catch
            {
                error(strFmt("@WAX2981", _closeContainerParams.parmContainerId()));
            }

            // If all qty has been packed for the shipment and all containers are closed, print packing slip for the shipment
            if (!_closeContainerParams.parmShouldSkipPackSlipPosting() && WHSContainerTable::mustPrintPackingSlip(releaseContainer, closeContainerProfile, _closeContainerParams.parmShipmentId(), _closeContainerParams.parmContainerId()))
            {
                if (closeContainerProfile.PrintPackingSlipAsynchronously)
                {
                    var contract = new WHSRunPackingSlipForContainerMessageContract();
                    contract.parmContainerId(containerTable.ContainerId);
                    contract.parmPackingSlipPostingParametersId(closeContainerProfile.PackingSlipPostingParameters);
                    str serializedContract = FormJsonSerializer::serializeClass(contract);

                    ttsbegin;
                    SysMessageSend::sendMessageCompany(
                        SysMessageQueue::Warehouse,
                        SysMessageType::RunPackingSlipForContainer,
                        serializedContract,
                        curExt());
                    ttscommit;
                }
                else
                {
                    WHSShipConfirm shipConfirm = new WHSShipConfirm();
                    shipConfirm.runPackingSlipForContainer(containerTable);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>containerWarehouseId</Name>
				<Source><![CDATA[
    internal InventLocationId containerWarehouseId(WHSCloseContainerProfile _closeContainerProfile)
    {
        switch (_closeContainerProfile.WarehouseGroupAll)
        {
            case WhsWarehouseGroupAll::Warehouse:
                return _closeContainerProfile.InventLocationId;

            case WhsWarehouseGroupAll::Group:
            case WhsWarehouseGroupAll::All:
                InventDim containerInventDim = InventDim::find(this.InventDimId);
                return containerInventDim.InventLocationId;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultFinalShipmentLocationId</Name>
				<Source><![CDATA[
    internal WMSLocationId defaultFinalShipmentLocationId(WHSCloseContainerProfile _closeContainerProfile)
    {
        switch (_closeContainerProfile.WarehouseGroupAll)
        {
            case WhsWarehouseGroupAll::Warehouse:
                return _closeContainerProfile.DefaultFinalShipLoc;

            case WhsWarehouseGroupAll::Group:
            case WhsWarehouseGroupAll::All:
                InventDim containerInventDim = InventDim::find(this.InventDimId);
                InventLocation warehouse = InventLocation::find(containerInventDim.InventLocationId);

                if (warehouse.DefaultFinalShipmentLocation)
                {
                    return warehouse.DefaultFinalShipmentLocation;
                }

                WHSParameters whsParameters = WHSParameters::find();

                return WMSLocation::findFirstByWarehouseAndLocationProfileType(warehouse.InventLocationId, whsParameters.ShipFinalLocType).wMSLocationId;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultSortingLocationId</Name>
				<Source><![CDATA[
    internal WMSLocationId defaultSortingLocationId(WHSCloseContainerProfile _closeContainerProfile)
    {
        switch (_closeContainerProfile.WarehouseGroupAll)
        {
            case WhsWarehouseGroupAll::Warehouse:
                return _closeContainerProfile.DefaultSortLocation;

            case WhsWarehouseGroupAll::Group:
            case WhsWarehouseGroupAll::All:
                InventDim containerInventDim = InventDim::find(this.InventDimId);
                InventLocation warehouse = InventLocation::find(containerInventDim.InventLocationId);

                if (warehouse.DefaultSortingLocation)
                {
                    return warehouse.DefaultSortingLocation;
                }

                WHSParameters whsParameters = WHSParameters::find();

                return WMSLocation::findFirstByWarehouseAndLocationProfileType(warehouse.InventLocationId, whsParameters.SortingLocationType).wMSLocationId;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>postClosed</Name>
				<Source><![CDATA[
    private void postClosed()
    {
        WHSInventoryTransactionArchiveQueueEntry::addContainerToQueue(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeDuringClose</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes fields as part of container closing.
    /// </summary>
    /// <param name = "_whsCloseContainerProfile">
    /// Closing profile of the container.
    /// </param>
    /// <param name="_containerTrackingId">
    /// Container tracking if manifesting is part of the container closing process.
    /// </param>
    protected void initializeDuringClose(
        WHSCloseContainerProfile _whsCloseContainerProfile, 
        ShipCarrierTrackingNum _containerTrackingId)
    {
        // Manual manifesting of container
        if (_whsCloseContainerProfile.ManifestAtContainerClose
            && _whsCloseContainerProfile.ManifestRequirementsForContainer == WHSManifestRequirement::Manual
            && _containerTrackingId)
        {
            this.ShipCarrierTrackingNum = _containerTrackingId;
        }
     
        // If the container is created by containerization then we just close the container and do nothing else.
        if (this.ContainerBuildId)
        {
            this.ContainerStatus = WHSContainerStatus::Closed;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printContainerShippingLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints the container label.
    /// </summary>
    /// <param name = "_closeContainerProfile">Closing profile of the contaier</param>
    [Hookable(false)]
    final internal void printContainerShippingLabel(WHSCloseContainerProfile _closeContainerProfile)
    {
        if (_closeContainerProfile.PrintContainerShippingLabelRule != WHSPrintContainerShippingLabelRule::Never
            && _closeContainerProfile.ManifestRequirementsForContainer == WHSManifestRequirement::TransportationManagement
            && this.hasContainerShippingLabel())
        {
            TMSContainerPrintLabel::printContainerShippingLabel(this, _closeContainerProfile);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printContainerShippingLabelForManifestShipment</Name>
				<Source><![CDATA[
    internal void printContainerShippingLabelForManifestShipment(WHSCloseContainerProfile _closeContainerProfile)
    {
        if (_closeContainerProfile.PrintContainerShippingLabelRule != WHSPrintContainerShippingLabelRule::Never
            && _closeContainerProfile.ManifestRequirementsForShipment == WHSManifestRequirement::TransportationManagement
            && this.hasContainerShippingLabel())
        {
            TMSContainerPrintLabel::printContainerShippingLabel(this, _closeContainerProfile);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasContainerShippingLabel</Name>
				<Source><![CDATA[
    private boolean hasContainerShippingLabel()
    {
        return this.ShipCarrierTrackingNum
            && this.findRouteSegmentContainer().ContainerShippingLabel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printContainerReturnShippingLabel</Name>
				<Source><![CDATA[
    private void printContainerReturnShippingLabel(WHSCloseContainerProfile _closeContainerProfile)
    {
        if (this.ShipCarrierTrackingNum
            && _closeContainerProfile.PrintContainerShippingLabelRule  != WHSPrintContainerShippingLabelRule::Never
            && _closeContainerProfile.ManifestRequirementsForContainer == WHSManifestRequirement::TransportationManagement
            && this.findRouteSegmentContainer().ContainerReturnShippingLabel)
        {
            TMSContainerPrintReturnShippingLabel::printContainerReturnShippingLabel(this, _closeContainerProfile);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPrintPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether packing slip for the shipment must be printed.
    /// </summary>
    /// <param name = "_releaseContainer">A <c>boolean</c> value to indicate whether container is released.</param>
    /// <param name = "_closeContainerProfile">A buffer to hold the close container profiles.</param>
    /// <param name = "_shipmentId">The shipment of the container being closed.</param>
    /// <param name = "_containerId">The container Id of the container being closed.</param>
    /// <returns>true, if packing slip for the shipment must be printed; otherwise, false.</returns>
    protected static boolean mustPrintPackingSlip(boolean _releaseContainer, WHSCloseContainerProfile _closeContainerProfile, WHSShipmentId _shipmentId, WHSContainerId _containerId )
    {
        return _releaseContainer && _closeContainerProfile.PrintPackingSlip && !WHSShipmentTable::hasOpenContainer(_shipmentId, _containerId) && WHSShipmentTable::isAllQtyPicked(_shipmentId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReleaseContainerContainerGroupingLicensePlateId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the container releasing and grouping combination.
    /// </summary>
    /// <param name = "_releaseContainer">Should the container be released immediately?</param>
    /// <param name = "_containerGroupingLicensePlateId">Container grouping license plate id.</param>
    /// <returns>
    /// True if only one of the parameters is set; otherwise false.
    /// </returns>
    public static boolean validateReleaseContainerContainerGroupingLicensePlateId(boolean _releaseContainer, WHSContainerGroupingLicensePlateId _containerGroupingLicensePlateId)
    {
        boolean ret = true;

        if (_releaseContainer && _containerGroupingLicensePlateId)
        {
            ret = checkFailed("@WAX:ErrorContainerGroupingCannotBeUsedWhenReleasingContainer");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAndUpdateContainerTableWithContainerGroupingLicensePlateId</Name>
				<Source><![CDATA[
    private void validateAndUpdateContainerTableWithContainerGroupingLicensePlateId(WHSLicensePlateId _licensePlateIdForTheContainer, WHSContainerGroupingLicensePlateId _containerGroupingLicensePlateId)
    {
        this.ContainerGroupingLicensePlateId = _containerGroupingLicensePlateId;

        if (!this.validateWrite())
        {
            throw error("@WAX:ErrorContainerValidation");
        }

        WHSLicensePlate::createLicensePlate(_licensePlateIdForTheContainer);

        if (_containerGroupingLicensePlateId)
        {
            WHSLicensePlate::createLicensePlate(_containerGroupingLicensePlateId);
            WHSLicensePlate::nestLicensePlate(_containerGroupingLicensePlateId, _licensePlateIdForTheContainer);
        }

        this.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCWItemInContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether or not any container lines for the selected container are associated to a catch weight item.
    /// </summary>
    /// <returns>
    /// True if the container has a catch weight item in it, otherwise false.
    /// </returns>
    [Hookable(false)]
    internal boolean isCWItemInContainer()
    {
        WHSContainerLine    containerLine;
        PdsCatchWeightItem  catchWeightItem;

        select firstonly RecId from containerLine
            where containerLine.ContainerId == this.ContainerId
            exists join catchWeightItem
                where catchWeightItem.ItemId == containerLine.ItemId;

        return containerLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerGroupingLicensePlateId</Name>
				<Source><![CDATA[
    private boolean validateContainerGroupingLicensePlateId()
    {
        boolean ret = true;

        if (this.ContainerGroupingLicensePlateId
            && this.ContainerGroupingLicensePlateId != this.orig().ContainerGroupingLicensePlateId)
        {
            if (WHSContainerTable::findByContainerId(this.ContainerGroupingLicensePlateId))
            {
                ret = checkFailed(strFmt("@WAX:ErrorContainerLicensePlateAndGroupingLicensePlateAreSame", this.ContainerGroupingLicensePlateId));
            }

            if (this.ContainerGroupingLicensePlateId == this.ContainerId)
            {
                ret = checkFailed(strFmt("@WAX:ErrorContainerLicensePlateAndGroupingLicensePlateAreSame", this.ContainerGroupingLicensePlateId));
            }

            if (ret && this.ContainerBuildId)
            {
                ret = checkFailed(strFmt("@WAX:ErrorContainerCreatedThroughContainerizationCantBeAddedToContainerGroup", this.ContainerId));
            }

            if (ret && this.ContainerReleased)
            {
                ret = checkFailed(strFmt("@WAX:ErrorReleasedContainerCantBeAddedToContainerGroup", this.ContainerId));
            }

            if (ret && this.isCWItemInContainer())
            {
                ret = checkFailed("@WAX:Error_ContainerGroupingNotSupportedForCWItems");
            }

            if (ret)
            {
                /*
                    When adding a container to a container group, we need to check if that group is on the same packing station.
                    To do that, we just need to get one non-released container from that container group.
                    Then we can check if that container is on the same packing station.
                    We don't need to check if the container from the group is released, because it is done in the check after this one.
                */

                WHSContainerTable containerTable;

                select firstonly containerTable
                    where containerTable.ContainerGroupingLicensePlateId	== this.ContainerGroupingLicensePlateId
                        && containerTable.ContainerReleased					== NoYes::No;

                if (containerTable && !this.isContainerOnTheSamePackingStation(containerTable))
                {
                    ret = checkFailed(strFmt("@WAX:CantAddContainerToGroupNotOnPackingStation", this.ContainerId, this.ContainerGroupingLicensePlateId));
                }
            }

            if (ret)
            {
                WHSContainerTable containerTable;

                while select containerTable
                    where containerTable.ContainerGroupingLicensePlateId    == this.ContainerGroupingLicensePlateId
                        && containerTable.ContainerId                       != this.ContainerId
                {
                    if (this.validateGroupedContainerShipmentMixing(containerTable))
                    {
                        ret = checkFailed(strFmt("@WAX:ErrorCannotAddContainerToGroupWithDifferentShipment", this.ContainerId, this.ContainerGroupingLicensePlateId));
                    }
                    else if (this.validateGroupedContainerProfileMixing(containerTable))
                    {
                        ret = checkFailed(strFmt("@WAX:ErrorContainerGroupContainerPackingPolicy", this.ContainerId, this.ContainerGroupingLicensePlateId));
                    }
                    else if (this.validateGroupedContainerReleasedState(containerTable))
                    {
                        ret = checkFailed(strFmt("@WAX:ErrorCannotAddContainerToReleasedContainerGroup", this.ContainerId, this.ContainerGroupingLicensePlateId));
                    }
                }
            }

            if (ret)
            {
                WHSLicensePlate licensePlate;

                select firstonly LicensePlateParent from licensePlate
                    where licensePlate.LicensePlateId == this.ContainerGroupingLicensePlateId;

                if (licensePlate.LicensePlateParent)
                {
                    ret = checkFailed(strFmt("@WAX:ErrorCannotAddContainerToLicensePlateWithParent", this.ContainerId, this.ContainerGroupingLicensePlateId));
                }
            }

            if (ret)
            {
                InventHandlingQty inventHandlingQuantity = WHSLicensePlate::getTotalHandlingQtyOnLicensePlateWithDelta(this.ContainerGroupingLicensePlateId);

                if (inventHandlingQuantity)
                {
                    ret = checkFailed(strFmt("@WAX:ErrorCannotAddContainerToNonEmptyLicensePlate", this.ContainerId, this.ContainerGroupingLicensePlateId));
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGroupedContainerShipmentMixing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if shipment for container grouping with license plate is valid.
    /// </summary>
    /// <param name = "_containerTable">The container record.</param>
    /// <returns>true if validation is successful; otherwise, false.</returns>
    protected boolean validateGroupedContainerShipmentMixing(WHSContainerTable _containerTable)
    {
        return _containerTable.ShipmentId != this.ShipmentId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGroupedContainerProfileMixing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if close container profile for container grouping with license plate is valid.
    /// </summary>
    /// <param name = "_containerTable">The container record.</param>
    /// <returns>true if validation is successful; otherwise, false.</returns>
    protected boolean validateGroupedContainerProfileMixing(WHSContainerTable _containerTable)
    {
        return _containerTable.CloseContainerProfileId != this.CloseContainerProfileId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGroupedContainerReleasedState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if container is already released for container grouping with license plate.
    /// </summary>
    /// <param name = "_containerTable">The container record.</param>
    /// <returns>true if validation is successful; otherwise, false.</returns>
    protected boolean validateGroupedContainerReleasedState(WHSContainerTable _containerTable)
    {
        return _containerTable.ContainerReleased == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateShipmentAndLoadStatus</Name>
				<Source><![CDATA[
    private void updateShipmentAndLoadStatus(WHSShipmentTable _shipmentTable, WHSContainerId _containerId)
    {
        WHSShipmentStatusUpdater shipmentStatusUpdater = WHSShipmentStatusUpdater::newFromShipmentId(_shipmentTable.ShipmentId);
        shipmentStatusUpdater.updateWhenContainerClosed(_containerId);

        WHSLoadStatusUpdater loadStatusUpdater = WHSLoadStatusUpdater::newFromLoadId(_shipmentTable.LoadId);
        loadStatusUpdater.updateWhenContainerClosed(_containerId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerWithNewInventDim</Name>
				<Source><![CDATA[
    private void closeContainerWithNewInventDim(WMSLocation _location, WHSLicensePlateId _licensePlateId)
    {
        InventDim locAndLpDim;
        locAndLpDim.wmsLocationId       = _location.wMSLocationId;
        locAndLpDim.InventLocationId    = _location.inventLocationId;
        locAndLpDim.InventSiteId        = _location.inventSiteId();
        locAndLpDim.LicensePlateId      = _licensePlateId;
        locAndLpDim                     = InventDim::findOrCreate(locAndLpDim);

        this.CloseContainerUTCDateTime  = DateTimeUtil::getSystemDateTime();
        this.InventDimId                = locAndLpDim.inventDimId;
        this.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerWithoutWorkCreation</Name>
				<Source><![CDATA[
    private void closeContainerWithoutWorkCreation(boolean _releaseContainer, WMSLocation _putLocation, WHSLicensePlateId _licensePlateId)
    {
        ttsbegin;

        if (_releaseContainer)
        {
            this.updateContainerToFinalShippingLocation(_putLocation, _licensePlateId);
            this.ContainerReleased = NoYes::Yes;
        }
        else
        {
            // Update dimensions of the container to reflect the new LP
            WMSLocation containerWarehouseLocation = this.getContainerWarehouseLocation();

            this.closeContainerWithNewInventDim(containerWarehouseLocation, _licensePlateId);

            this.closeContainerCreateTransactions(containerWarehouseLocation, _licensePlateId);
        }

        this.checkContainerWholeLicensePlateMovedWithoutWork();

        this.ContainerStatus = WHSContainerStatus::Closed;
        this.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerWithWorkCreation</Name>
				<Source><![CDATA[
    private void closeContainerWithWorkCreation(boolean _releaseContainer, WHSLicensePlateId _licensePlateId)
    {
        ttsbegin;

        WMSLocation containerWarehouseLocation = this.getContainerWarehouseLocation();

        this.closeContainerCreateTransactions(containerWarehouseLocation, this.ContainerId, _licensePlateId);

        this.closeContainerWithNewInventDim(containerWarehouseLocation, _licensePlateId);

        if (_releaseContainer)
        {
            this.createWorkForTheContainer(containerWarehouseLocation);
        }

        this.ContainerStatus = WHSContainerStatus::Closed;
        this.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerHasLines</Name>
				<Source><![CDATA[
    private void validateContainerHasLines()
    {
        if (!this.existContainerLineForContainerId())
        {
            throw error("@WAX:CloseContainerDoesNotHaveLinesError");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existContainerLineForContainerId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if container lines exists for container.
    /// </summary>
    /// <returns>true if container lines exists; otherwise, false.</returns>
    protected boolean existContainerLineForContainerId()
    {
        WHSContainerLine containerLine;

        select firstonly RecId from containerLine
            where containerLine.ContainerId == this.ContainerId;

        return containerLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateHasBlockedWorkByDeferredPutOperation</Name>
				<Source><![CDATA[
    private void validateHasBlockedWorkByDeferredPutOperation()
    {
        WHSWorkLine workLine;
        WHSWorkBlockingReasonAssociation workBlockingReasonAssociation;
        
        select firstonly RecId from workLine
            where workLine.ContainerId == this.ContainerId
            exists join workBlockingReasonAssociation
                where workBlockingReasonAssociation.WorkId == workLine.WorkId
                    && workBlockingReasonAssociation.ReasonType == WHSWorkBlockingReasonType::DeferredPutOperation;

        if (workLine.RecId)
        {
            throw error(strFmt("@WAX:WHSContainerCanNotCloseDeferredPutExistError", this.ContainerId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContainerWarehouseLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets current container warehouse location.
    /// </summary>
    /// <returns>
    /// Found <c>WMSLocation</c> record.
    /// </returns>
    public WMSLocation getContainerWarehouseLocation()
    {
        InventDim containerLocationInventDim = this.getFirstContainerLineInventDim();

        return containerLocationInventDim.wmsLocation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContainerWarehouseLocationId</Name>
				<Source><![CDATA[
    internal WMSLocationId getContainerWarehouseLocationId()
    {
        InventDim containerLocationInventDim = this.getFirstContainerLineInventDim();

        return containerLocationInventDim.wMSLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkForTheContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates work for the current container on the specified warehouse location.
    /// </summary>
    /// <param name="_startLocation">
    /// Warehouse location.
    /// </param>
    public void createWorkForTheContainer(WMSLocation _startLocation)
    {
        if (this.isCWItemInContainer())
        {
            throw error("@WAX:Error_ReleasingForPackedContainerPickingWorkNotSupportedForCWItems");
        }

        WHSWorkCreatePackedContainerBase workCreate = WHSWorkCreatePackedContainerBase::construct(this);

        workCreate.parmStartLocationId(_startLocation.wMSLocationId);

        WHSCloseContainerProfile closeContainerProfile = WHSCloseContainerProfile::find(this.CloseContainerProfileId);

        workCreate.parmWorkTemplateCode(closeContainerProfile.WorkTemplateCode);

        if (workCreate.createWork())
        {
            if (this.ContainerGroupingLicensePlateId)
            {
                info(strFmt("@WAX:WorkCreatedForGroupedContainers", this.ContainerGroupingLicensePlateId));

                ttsbegin;

                WHSContainerTable containerTable;

                update_recordset containerTable
                    setting ContainerReleased = NoYes::Yes
                    where containerTable.ContainerGroupingLicensePlateId == this.ContainerGroupingLicensePlateId;

                ttscommit;
            }
            else
            {
                info(strFmt("@WAX:WorkCreatedForContainer", this.ContainerId));

                ttsbegin;

                this.ContainerReleased = NoYes::Yes;
                this.update();

                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerCreateTransRecs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>WHSContainerTrans</c> records for the container being closed.
    /// </summary>
    /// <param name="_putLocation">
    /// The location the container is being moved to.
    /// </param>
    /// <param name="_containerId">
    /// The container Id of the container being closed.
    /// </param>
    /// <param name="_licensePlateIdTo">
    /// License plate id to be set on the dimension.
    /// </param>
    private static void closeContainerCreateTransRecs(
        WMSLocation         _putLocation,
        WHSContainerId      _containerId,
        WHSLicensePlateId   _licensePlateIdTo)
    {
        WHSContainerLine containerLine;

        while select forupdate containerLine
            where containerLine.ContainerId == _containerId
        {
            containerLine.insertContainerTrans(_putLocation, _containerId, _licensePlateIdTo);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerCreateWarehouseInventoryTransactions</Name>
				<Source><![CDATA[
    private void closeContainerCreateWarehouseInventoryTransactions(
            WMSLocation         _putLocation,
            WHSContainerId      _containerId,
            WHSLicensePlateId   _licensePlateIdTo)
    {
        WHSContainerLine containerLine;

        WHSInventoryTransactionContainerCloseController controller      = WHSInventoryTransactionContainerCloseController::construct();
        WHSInventoryItemSetsMap                         itemSetsMap     = WHSInventoryItemSetsMap::construct();

        while select forupdate containerLine
                where containerLine.ContainerId == _containerId
        {
            WHSContainerTrans containerTrans = containerLine.insertContainerTrans(_putLocation, _containerId, _licensePlateIdTo);

            controller.addToItemSet(containerLine, containerTrans, itemSetsMap);
        }

        controller.createInventoryTransactions(this, itemSetsMap, _putLocation, _licensePlateIdTo);
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerErrorCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that all requirements for closing the container are met.
    /// </summary>
    /// <param name = "_containerTable">The container record.</param>
    /// <param name = "_shipmentTable">The shipment record.</param>
    /// <param name = "_weight">The captured gross weight of the container being closed.</param>
    /// <param name = "_containerTrackingNumber">The container tracking if manifesting is part of the container closing process.</param>
    protected static void closeContainerErrorCheck(
        WHSContainerTable       _containerTable,
        WHSShipmentTable        _shipmentTable,
        Weight                  _weight,
        ShipCarrierTrackingNum  _containerTrackingNumber)
    {
        WHSCloseContainerProfile closeContainerProfile = WHSCloseContainerProfile::find(_containerTable.CloseContainerProfileId);

        WHSContainerTable::closeContainerErrorCheckContainer(_containerTable, _shipmentTable, closeContainerProfile);

        WHSContainerTable::closeContainerErrorCheckWeight(_containerTable, _weight);

        WHSContainerTable::closeContainerErrorCheckTrackingNumber(closeContainerProfile, _containerTrackingNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerErrorCheckContainer</Name>
				<Source><![CDATA[
    internal static void closeContainerErrorCheckContainer(WHSContainerTable _containerTable, WHSShipmentTable _shipmentTable, WHSCloseContainerProfile _closeContainerProfile)
    {
        WHSShipmentTable shipmentTable = _shipmentTable;

        if (!_containerTable.ContainerId)
        {
            throw error(Error::missingMethodParameter(tableStr(WHSContainerTable), funcName(), fieldStr(WHSContainerTable, ContainerId)));
        }

        // Check to see if container is already closed.
        if (_containerTable.ContainerStatus == WHSContainerStatus::Closed)
        {
            throw error("@WAX2380");
        }

        if (shipmentTable.whsLoadTable().LoadingStrategy == WHSLoadingStrategy::PartialLoadShippingAllowed)
        {
            throw error(strFmt("@WAX:Error_LoadingStrategyDoesNotSupportContainerPacking", shipmentTable.ShipmentId, shipmentTable.LoadId));
        }

        // Check if related work is not blocked by deferred put operation
        _containerTable.validateHasBlockedWorkByDeferredPutOperation();

        // Check if the container have lines
        _containerTable.validateContainerHasLines();

        // Check to see if shipment and close container profile match warehouses
        if (_closeContainerProfile.shouldContainerBeAvailableAtFinalShippingLocation())
        {
            switch (_closeContainerProfile.WarehouseGroupAll)
            {
                case WhsWarehouseGroupAll::Warehouse:
                    if (shipmentTable.InventLocationId != _closeContainerProfile.InventLocationId)
                    {
                        throw error("@WAX2662");
                    }
                    break;
                case WhsWarehouseGroupAll::Group:
                    if (!WhsWarehouseGroup::containsWarehouse(_closeContainerProfile.WarehouseGroupId, shipmentTable.InventLocationId))
                    {
                        throw error(strFmt("@WAX:ContainerCloseWarehouseAndContainerProfileWarehouseGroupMismatchError", _containerTable.ContainerId, shipmentTable.InventLocationId, _closeContainerProfile.WarehouseGroupId, _closeContainerProfile.CloseContainerProfileId));
                    }
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerErrorCheckWeight</Name>
				<Source><![CDATA[
    internal static void closeContainerErrorCheckWeight(WHSContainerTable _containerTable, Weight _weight)
    {
        // Check that weight was specified and positive.
        if (_weight <= 0)
        {
            throw error("@WAX3345");
        }

        _containerTable.validateContainerMaximumNetWeight(_weight);
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerErrorCheckTrackingNumber</Name>
				<Source><![CDATA[
    public static void closeContainerErrorCheckTrackingNumber(WHSCloseContainerProfile _closeContainerProfile, ShipCarrierTrackingNum _containerTrackingNumber = '')
    {
        if (_closeContainerProfile.ManifestRequirementsForContainer == WHSManifestRequirement::None && _containerTrackingNumber)
        {
            throw error("@WAX:TheContainerPolicyForTheContainerDoNotAllowManifesting");
        }

        // Check that a container tracking id have been specified for containers that require manual manifesting
        if (_closeContainerProfile.ManifestAtContainerClose &&
            _closeContainerProfile.ManifestRequirementsForContainer == WHSManifestRequirement::Manual &&
            !_containerTrackingNumber)
        {
            throw error("@WAX:ContainerPolicyRequiresTrackingNumber");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes and manifests a shipment.
    /// </summary>
    /// <param name="_shipmentId">
    /// Shipment ID.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when there are errors in manifest.
    /// </exception>
    public static void closeShipment(WHSShipmentId _shipmentId)
    {
        TMSShipmentProcess  shipmentProcess;
        container           errorContainer;
        int                 i;

        // Call manifest shipment
        shipmentProcess = new TMSShipmentProcess();
        shipmentProcess.parmshipmentId(_shipmentId);
        shipmentProcess.execute();

        errorContainer = shipmentProcess.parmErrors();

        if (conLen(errorContainer) > 0)
        {
            for (i = 1; i <= conLen(errorContainer); i ++)
            {
                warning(strFmt('%1',conPeek(errorContainer, i)));
            }

            throw error("@WAX:TheShipmentCouldNotBeManifested");
        }

        WHSShipmentTable::find(_shipmentId).printContainerShippingLabels();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>WHSContainerTable</c> record with given parameters.
    /// </summary>
    /// <param name="_shipmentId">
    /// Shipment id of the record.
    /// </param>
    /// <param name="_containerId">
    /// Container id of the record.
    /// </param>
    /// <param name="_containerTypeCode">
    /// Container type code of the record.
    /// </param>
    /// <param name="_closeContainerProfileId">
    /// Container packing policy id; optional.
    /// </param>
    /// <param name="_containerGroupingLicensePlateId">
    /// Container grouping license plate id; optional.
    /// </param>
    /// <param name="_containerLocation">
    /// Container location; optional.
    /// </param>
    public static void createContainer(
        WHSShipmentId                       _shipmentId,
        WHSContainerId                      _containerId,
        WHSContainerTypeCode                _containerTypeCode,
        WHSCloseContainerProfileId          _closeContainerProfileId            = '',
        WHSContainerGroupingLicensePlateId  _containerGroupingLicensePlateId    = '',
        WMSLocation							_containerLocation					= null)
    {
        ttsbegin;

        InventDim containerInventDim;

        if (_containerLocation)
        {
            containerInventDim.InventLocationId = _containerLocation.inventLocationId;
            containerInventDim.wMSLocationId	= _containerLocation.wMSLocationId;

            containerInventDim = InventDim::findOrCreate(containerInventDim);
        }

        WHSContainerTable containerTableNum;

        select firstonly ContainerNum from containerTableNum
            order by containerTableNum.ContainerNum desc
            where containerTableNum.ShipmentId == _shipmentId;

        WHSContainerTable containerTable;

        containerTable.ContainerNum                     = containerTableNum.ContainerNum + 1;
        containerTable.ShipmentId                       = _shipmentId;
        containerTable.ContainerId                      = _containerId;
        containerTable.ContainerTypeCode                = _containerTypeCode;
        containerTable.CloseContainerProfileId          = _closeContainerProfileId;
        containerTable.ContainerGroupingLicensePlateId  = _containerGroupingLicensePlateId;
        containerTable.InventDimId						= containerInventDim.InventDimId;

        if (!containerTable.validateWrite())
        {
            throw error(strFmt("@WAX:WHSCannotInsertRecordInTable", tablePName(WHSContainerTable)));
        }
        else
        {
            containerTable.insert();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createContainerWithParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>WHSContainerTable</c> record with given parameters.
    /// Call <c>onContainerCreated</c> delegate.
    /// </summary>
    /// <param name = "_createContainerParameters">
    /// Class containing parameters for container creation.
    /// </param>
    [Hookable(false)]
    public static void createContainerWithParameters(WHSCreateContainerParameters _createContainerParameters)
    {
        WHSContainerTable::validateContainerCreation(_createContainerParameters);

        ttsbegin;
        WHSContainerTable::createContainer(
            _createContainerParameters.parmShipmentId(),
            _createContainerParameters.parmContainerId(),
            _createContainerParameters.parmContainerTypeCode(),
            _createContainerParameters.parmCloseContainerProfileId(),
            _createContainerParameters.parmContainerGroupingLicensePlateId(),
            _createContainerParameters.parmContainerLocation());
         ttscommit;
    
        WHSContainerTable::onContainerCreated(_createContainerParameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerCreation</Name>
				<Source><![CDATA[
    private static void validateContainerCreation(WHSCreateContainerParameters _createContainerParameters)
    {
        WHSWorker worker = WHSWorker::find(_createContainerParameters.parmWhsWorkerRecId());
        WHSPackProfile packProfile = WHSPackProfile::find(worker.PackProfileId);

        if (packProfile.PreventContainerCreateWithoutItemToPack
            && !WHSContainerTable::shipmentHasClosedWorkOnPackStation(
                _createContainerParameters.parmShipmentId(),
                _createContainerParameters.parmContainerLocation()))
        {

            throw error(strFmt("@WAX:ErrorCannotCreateContainerOnLocation",
                _createContainerParameters.parmShipmentId(),
                _createContainerParameters.parmContainerLocation().wMSLocationId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shipmentHasClosedWorkOnPackStation</Name>
				<Source><![CDATA[
    private static boolean shipmentHasClosedWorkOnPackStation(WHSShipmentId _shipmentId, WMSLocation _location)
    {
        boolean ret = false;

        WHSWorkTable workTable;
        WHSWorkLine workLine;
        while select workLine
                where workLine.ShipmentId == _shipmentId
                    && workLine.WorkType == WHSWorkType::Put
                    && workLine.WMSLocationId == _location.wMSLocationId
                exists join workTable
                    where workLine.WorkId == workTable.WorkId
                    && workTable.WorkStatus == WHSWorkStatus::Closed
                    && workTable.InventLocationId == _location.inventLocationId
        {
            if (workLine.isLastWorkLine())
            {
                ret = true;
                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineContainerClose</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the container related to a work.
    /// </summary>
    /// <param name="_workId">
    /// Id of the work.
    /// </param>
    /// <param name="_closeContainerProfileId">
    /// Container closing profile ID; optional.
    /// </param>
    public static void determineContainerClose(WHSWorkId _workId, WHSCloseContainerProfileId _closeContainerProfileId = '')
    {
        WHSContainerTable::determineContainerCloseConsiderLockType(_workId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineContainerCloseConsiderLockType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the container related to a work with or without using of pessimistic lock.
    /// </summary>
    /// <param name="_workId">
    /// Id of the work.
    /// </param>
    /// <param name="_usePessimisticLock">
    /// Determine if need or not using of pessimistic lock
    /// </param>
    public static void determineContainerCloseConsiderLockType(WHSWorkId _workId, boolean _usePessimisticLock = false)
    {
        ttsbegin;

        WHSWorkLine workLine;

        while select ContainerId from workLine
            group by workLine.ContainerId
            where workLine.WorkId == _workId &&
                workLine.ContainerId != ''
        {
            workLine.checkInvalidFieldAccess(false);

            WHSContainerTable::recursiveCloseContainerForWorkLine(workLine, _usePessimisticLock);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recursiveCloseContainerForWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the container related to workline with or without using of pessimistic lock.
    /// </summary>
    /// <param name = "_workLine">Id of the work line.</param>
    /// <param name = "_usePessimisticLock">Determine if need or not using of pessimistic lock.</param>
    [Hookable(false)]
    internal static void recursiveCloseContainerForWorkLine(WHSWorkLine _workLine, boolean _usePessimisticLock = false)
    {
        WHSContainerTable containerTable = _usePessimisticLock ? WHSContainerTable::findByContainerIdWithPessimisticLock(_workLine.ContainerId) :
                WHSContainerTable::findByContainerId(_workLine.ContainerId, true);
            
        if (containerTable.RecId)
        {
            WHSWorkLine workLineWithSameContainerId;
            select firstonly TableId from workLineWithSameContainerId
                where workLineWithSameContainerId.ContainerId   ==  _workLine.ContainerId
                    && workLineWithSameContainerId.RecId        !=  _workLine.RecId
                    && (workLineWithSameContainerId.WorkStatus  == WHSWorkStatus::InProcess
                    ||  workLineWithSameContainerId.WorkStatus  == WHSWorkStatus::Open);

            if (!workLineWithSameContainerId)
            {
                containerTable.recursiveCloseContainer(_usePessimisticLock);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a specific <c>WHSContainerTable</c> record exists with given parameters.
    /// </summary>
    /// <param name="_shipmentId">
    /// Shipment id of the record.
    /// </param>
    /// <param name="_containerId">
    /// Container id of the record.
    /// </param>
    /// <returns>
    /// True if the record exists.
    /// </returns>
    public static boolean exist(WHSShipmentId   _shipmentId, WHSContainerId  _containerId)
    {
        return (_shipmentId && _containerId) &&
               (select firstonly whsContainerTable
                    where whsContainerTable.ShipmentId   == _shipmentId  &&
                          whsContainerTable.ContainerId  == _containerId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForContainerId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a specific <c>WHSContainerTable</c> record exists with given parameters.
    /// </summary>
    /// <param name="_containerId">
    /// Container id of the record.
    /// </param>
    /// <returns>
    /// true if the record exists; otherwise, false.
    /// </returns>
    public static boolean existForContainerId(WHSContainerId  _containerId)
    {
        return (_containerId) &&
               (select firstonly whsContainerTable
                    where whsContainerTable.ContainerId  == _containerId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific <c>WHSContainerTable</c> record with given parameters.
    /// </summary>
    /// <param name="_shipmentId">
    /// Shipment id of the record.
    /// </param>
    /// <param name="_containerId">
    /// Container id of the record.
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is selected for.
    /// </returns>
    public static WHSContainerTable find(
                                WHSShipmentId      _shipmentId,
                                WHSContainerId     _containerId,
                                boolean            _forupdate = false)
    {
        WHSContainerTable   containerTable;

        if (_shipmentId && _containerId)
        {
            containerTable.selectForUpdate(_forupdate);

            select firstonly containerTable
                where containerTable.ShipmentId  == _shipmentId  &&
                      containerTable.ContainerId == _containerId;
        }

        return containerTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByContainerId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>WHSContainerTable</c> record by container id.
    /// </summary>
    /// <param name="_containerId">
    /// Container id of the record.
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    public static WHSContainerTable findByContainerId(WHSContainerId _containerId, boolean _forupdate = false)
    {
        WHSContainerTable   containerTable;

        if (_containerId)
        {
            containerTable.selectForUpdate(_forupdate);

            select firstonly containerTable
                where containerTable.ContainerId == _containerId;
        }

        return containerTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByContainerIdWithPessimisticLock</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>WHSContainerTable</c> record by container id using pessimistic lock.
    /// </summary>
    /// <param name="_containerId">
    /// Container id of the record.
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    public static WHSContainerTable findByContainerIdWithPessimisticLock(WHSContainerId _containerId)
    {
        WHSContainerTable containerTable;

        if (_containerId)
        {
            containerTable.disableCache(true);

            select pessimisticlock firstonly containerTable
                where containerTable.ContainerId == _containerId;
        }

        return containerTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>WHSContainerTable</c> record by id.
    /// </summary>
    /// <param name="_recId">
    /// Id of the record.
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    public static WHSContainerTable findByRecId(RefRecId _recId, boolean _forupdate = false)
    {
        WHSContainerTable   containerTable;

        if (_recId)
        {
            containerTable.selectForUpdate(_forupdate);

            select firstonly containerTable
                where containerTable.RecId == _recId;
        }

        return containerTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether container contains any lines or any containers.
    /// </summary>
    /// <param name="_containerId">
    /// Container ID.
    /// </param>
    /// <returns>
    /// true if container contains any line or any container; otherwise false.
    /// </returns>
    public static boolean isEmpty(WHSContainerId _containerId)
    {
        WHSContainerLine    containerLine;

        select firstonly RecId from containerLine
            where containerLine.ContainerId == _containerId;

        return containerLine.RecId || WHSContainerTable::findByContainerId(_containerId).isParent() ? false : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupContainers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Lookup method for showing manually created containers which are available in the specified warehouse.
    /// </summary>
    /// <param name="_ctrl">
    /// The container Id form control.
    /// </param>
    /// <param name="_inventLocationId">
    /// The specified <c>InventLocationId</c> value..
    /// </param>
    public static void lookupContainers(FormStringControl _ctrl, InventLocationId _inventLocationId)
    {
        SysTableLookup          sysTableLookup;
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;
        QueryBuildDataSource    qbdsShipment;

        sysTableLookup          = SysTableLookup::newParameters(tableNum(WHSContainerTable), _ctrl);
        query                   = new Query();
        queryBuildDataSource    = query.addDataSource(tableNum(WHSContainerTable));
        qbdsShipment            = queryBuildDataSource.addDataSource(tableNum(WHSShipmentTable));

        qbdsShipment.relations(true);

        sysTableLookup.addLookupfield(fieldNum(WHSContainerTable, ContainerId));
        sysTableLookup.addLookupfield(fieldNum(WHSContainerTable, ContainerTypeCode));
        sysTableLookup.addLookupfield(fieldNum(WHSContainerTable, ShipmentId));
        queryBuildDataSource.addSortField(fieldNum(WHSContainerTable, ShipmentId), SortOrder::Ascending);
        queryBuildDataSource.addRange(fieldNum(WHSContainerTable, ContainerStatus)).value(SysQuery::valueNot(WHSContainerStatus::Closed));
        queryBuildDataSource.addRange(fieldNum(WHSContainerTable, ContainerBuildId)).value(SysQuery::valueEmptyString());
        qbdsShipment.addRange(fieldNum(WHSShipmentTable, InventLocationId)).value(_inventLocationId);

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupContainersByShipmentAndLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Lookup method for showing manually created containers related to a shipmentId
    /// </summary>
    /// <param name="_ctrl">
    /// The container Id form control.
    /// </param>
    /// <param name="_shipmentId">
    /// The shipment Id that containers are being filtered on.
    /// </param>
    /// <param name="_containerLocation">
    /// The location that containers are being filtered on.
    /// </param>
    public static void lookupContainersByShipmentAndLocation(
        FormStringControl   _ctrl,
        WHSShipmentId       _shipmentId,
        WMSLocation			_containerLocation)
    {
        Query query = new Query();

        QueryBuildDataSource qbdsContainerTable = query.addDataSource(tableNum(WHSContainerTable));

        qbdsContainerTable.addRange(fieldNum(WHSContainerTable, ShipmentId)).value(queryValue(_shipmentId));
        qbdsContainerTable.addRange(fieldNum(WHSContainerTable, ContainerStatus)).value(SysQuery::valueNot(WHSContainerStatus::Closed));
        qbdsContainerTable.addRange(fieldNum(WHSContainerTable, ContainerBuildId)).value(SysQuery::valueEmptyString());
        qbdsContainerTable.addRange(fieldNum(WHSContainerTable, ErrorContainer)).value(queryValue(NoYes::No));

        QueryBuildDataSource qbdsInventDim = qbdsContainerTable.addDataSource(tableNum(InventDim));

        qbdsInventDim.relations(true);
        qbdsInventDim.joinMode(JoinMode::ExistsJoin);
        qbdsInventDim.addRange(fieldNum(InventDim, InventLocationId)).value(_containerLocation.inventLocationId);
        qbdsInventDim.addRange(fieldNum(InventDim, wMSLocationId)).value(_containerLocation.wMSLocationId);

        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(WHSContainerTable), _ctrl);

        sysTableLookup.addLookupfield(fieldNum(WHSContainerTable, ContainerId));
        sysTableLookup.addLookupfield(fieldNum(WHSContainerTable, ContainerTypeCode));
        sysTableLookup.addLookupfield(fieldNum(WHSContainerTable, Weight));
        sysTableLookup.addLookupfield(fieldNum(WHSContainerTable, CloseContainerProfileId));

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>packItemHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs an item into the container.
    /// </summary>
    /// <param name="_itemId">
    /// The item Id of the item being packed.
    /// </param>
    /// <param name="_handlingQty">
    /// The Qty of the item being packed.
    /// </param>
    /// <param name="_unitId">
    /// The unit of measure the qty being packed is stored in.
    /// </param>
    /// <param name="_containerId">
    /// The container Id of the container the item is being packed into.
    /// </param>
    /// <param name="_tmpPackingLine">
    /// A <c>WHSTmpPackingLine</c> table buffer which holds the available inventory to pack.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria which must be met by the inventory being packed.
    /// </param>
    /// <param name="_capturedWeight">
    ///	The capture weight of the item being packed.
    /// </param>
    /// <param name="_tagNumber">
    /// The tag number for tracked catch weight item.
    /// </param>
    [Hookable(false)]
    public static void packItemHandlingQty(
        ItemId                  _itemId,
        Qty                     _handlingQty,
        UnitOfMeasureSymbol     _unitId,
        WHSContainerId          _containerId,
        WHSTmpPackingLine       _tmpPackingLine,
        InventDim               _inventDimCriteria,
        WHSTransWeight		    _capturedWeight,
        WHSCatchWeightTagNumber _tagNumber)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightHandlingWeightLogic(funcName(), _itemId, _capturedWeight))
        {
            WHSContainerTable::packItemQuantities(_itemId, _handlingQty, _unitId, _containerId, _tmpPackingLine, _inventDimCriteria, true, _capturedWeight, _tagNumber);
        }
        else
        {
            WHSContainerTable::packItem(_itemId, _handlingQty, _unitId, _containerId, _tmpPackingLine, _inventDimCriteria);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>packItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs an item into the container.
    /// </summary>
    /// <param name="_itemId">
    /// The item Id of the item being packed.
    /// </param>
    /// <param name="_qty">
    /// The Qty of the item being packed.
    /// </param>
    /// <param name="_unitId">
    /// The unit of measure the qty being packed is stored in.
    /// </param>
    /// <param name="_containerId">
    /// The container Id of the container the item is being packed into.
    /// </param>
    /// <param name="_tmpPackingLine">
    /// A <c>WHSTmpPackingLine</c> table buffer which holds the available inventory to pack.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria which must be met by the inventory being packed.
    /// </param>
    /// <exception cref="Exception::Error">
    /// The item does not exist in the <c>WHSTmpPackingLine</c> table buffer.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The container does not exists for this shipment.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The container is in a closed status.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// You can only pack one inventory at a time if serial is being captured at packing.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The serial Id was not entered during capture.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// There is not enough available inventory to be packed.
    /// </exception>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the packItemHandlingQty method. Extenders should move their logic to wrap the packItemQuantities method.', false, 30\9\2019)]
    public static void packItem(
        ItemId              _itemId,
        Qty                 _qty,
        UnitOfMeasureSymbol _unitId,
        WHSContainerId      _containerId,
        WHSTmpPackingLine   _tmpPackingLine,
        InventDim           _inventDimCriteria)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _itemId);

        WHSContainerTable::packItemQuantities(_itemId, _qty, _unitId, _containerId, _tmpPackingLine, _inventDimCriteria, false, 0, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>packItemQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs an item into the container.
    /// </summary>
    /// <param name="_itemId">
    /// The item Id of the item being packed.
    /// </param>
    /// <param name="_handlingQty">
    /// The handling quantity of the item being packed.
    /// </param>
    /// <param name="_unitId">
    /// The unit of measure the qty being packed is stored in.
    /// </param>
    /// <param name="_containerId">
    /// The container Id of the container the item is being packed into.
    /// </param>
    /// <param name="_tmpPackingLine">
    /// A <c>WHSTmpPackingLine</c> table buffer which holds the available inventory to pack.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria which must be met by the inventory being packed.
    /// </param>
    /// <param name="_isCWItem">
    /// Boolean describing whether the packed item is a catch weight item.
    /// </param>
    /// <param name="_capturedWeight">
    ///	The capture weight of the item being packed.
    /// </param>
    /// <param name="_tagNumber">
    /// The tag number for tracked catch weight item.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the packItemHandlingQty method.
    /// </remarks>
    [Wrappable(true)]
    protected static void packItemQuantities(
        ItemId                  _itemId,
        InventHandlingQty       _handlingQty,
        UnitOfMeasureSymbol     _unitId,
        WHSContainerId          _containerId,
        WHSTmpPackingLine       _tmpPackingLine,
        InventDim               _inventDimCriteria,
        boolean				    _isCWItem,
        WHSTransWeight		    _capturedWeight,
        WHSCatchWeightTagNumber _tagNumber)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _itemId, _handlingQty, _capturedWeight);

        WHSSerialId             serialId;
        Qty                     qtySupplied;
        Qty                     qtyLeft;
        Qty                     qtyCreate;
        WHSTmpPackingLine       tmpPackingLine;
        WHSContainerTable       containerTable;
        boolean                 outdated;
        WHSCreateSerialNumber   whsCreateSerialNumber;
        InventDim               finalInventDim;
        InventDim               inventDim;
        InventDimParm           inventDimParm;
        Qty                     newQtyRemaining;
        InventTransId           transId;
        Set                     transSet = new Set(Types::String);
        container               serialCon;
        WHSTransWeight			weightRemainingToPack = _capturedWeight;
        WHSTransWeight			weightToPack;
        PdsCatchWeightItem      catchWeightItem;
        

        if (_isCWItem)
        {
            catchWeightItem = PdsCatchWeightItem::find(_itemId);
        }

        try
        {

            using (var activityContext = containerTable.instrumentationLogger().warehouseItemPackingInContainer().packItemQuantities())
            {
                tmpPackingLine.setTmpData(_tmpPackingLine);

                // Check to make sure the item is in the tmpPackingLines table
                select firstonly RecId from tmpPackingLine
                where tmpPackingLine.ItemId == _itemId;

                if (tmpPackingLine.RecId == 0)
                {
                    throw error(strFmt("@WAX2331", _itemId));
                }

                containerTable = WHSContainerTable::find(_tmpPackingLine.ShipmentId, _containerId);
                if (!containerTable)
                {
                    throw error ("@WAX2751");
                }

                // Check if the container is closed
                if (containerTable.ContainerStatus == WHSContainerStatus::Closed)
                {
                    throw error("@WAX2376");
                }

                WHSWorkTransType transType = WHSShipmentTable::find(containerTable.ShipmentId).WorkTransType;
                WHSRFWhenToCapture capture = WHSInventTable::captureSerial(_itemId);
                InventTable inventTable = InventTable::find(_itemId);

                // Check if the item requires serial to be captured at packing
                if (capture == WHSRFWhenToCapture::Packing
                    && WHSContainerTable::isForOutboundShipmentAndSerialNumberAssignmentEnabled(transType)
                    && inventTable.isItemSerialNumberActivated())
                {
                    if (_handlingQty != 1 || _unitId != WHSCatchWeightHelper::inventHandlingUnitId(_itemId))
                    {
                        throw error("@WAX2333");
                    }

                    WHSCaptureSerialNumberAtContainerPackingContext capturedSerialContext = WHSCaptureSerialNumberAtContainerPackingContext::current();

                    if (capturedSerialContext)
                    {
                        WHSCreateSerialNumber::createNewSerialId(_itemId, capturedSerialContext.capturedSerialId);
                        serialId = capturedSerialContext.capturedSerialId;
                    }
                    else
                    {
                        whsCreateSerialNumber = WHSCreateSerialNumber::newStandard(_itemId);
                        serialId = whsCreateSerialNumber.run();
                    }

                    if (!serialId)
                    {
                        throw error("@WAX3128");
                    }
                }

                ttsbegin;

                tmpPackingLine.ttsbegin();

                //Set Quantities
                qtySupplied = _handlingQty;

                inventDimParm.initFromInventDim(_inventDimCriteria);
                boolean salesActive = inventTable.isSalesProcessSerialActive();
                // Loop over packing lines with some remaining qty for the selected item.
                while select forupdate tmpPackingLine
                where tmpPackingLine.ItemId         == _itemId
                    &&    tmpPackingLine.QtyRemaining   >  0
                    &&    tmpPackingLine.uom            == _unitId
                #InventDimExistsJoin(tmpPackingLine.inventDimId, inventDim, _inventDimCriteria, inventDimParm)
                {
                    // Make sure the QtyRemaining is not out of date because other users are packing it.
                    newQtyRemaining = tmpPackingLine.calcQtyRemaining();
                    if (newQtyRemaining != tmpPackingLine.QtyRemaining)
                    {
                        // Update the tmpWorkLine to current values
                        tmpPackingLine.QtyPacked     = tmpPackingLine.Qty - newQtyRemaining;
                        tmpPackingLine.QtyRemaining  = newQtyRemaining;
                        tmpPackingLine.update();

                        outdated = true;
                    }

                    qtyLeft = tmpPackingLine.QtyRemaining;

                    qtyCreate = min(qtyLeft, qtySupplied);

                    if (qtyCreate == 0)
                    {
                        continue;
                    }

                    if (catchWeightItem)
                    {
                        if (weightRemainingToPack)
                        {
                            Qty tmpQty = WHSCatchWeightHelper::convertInventQuantity(_itemId, _unitId, qtySupplied, tmpPackingLine.inventDimId);

                            WHSTransWeight unitWeight = weightRemainingToPack / tmpQty;

                            if (catchWeightItem.PdsCWMax < unitWeight
                            || catchWeightItem.PdsCWMin > unitWeight)
                            {
                                throw error (strFmt(
                                "@PDS85",
                                tmpQty * catchWeightItem.PdsCWMin,
                                tmpQty * catchWeightItem.PdsCWMax,
                                _itemId));
                            }
                        }
                        else
                        {
                            // Get the weight to pack based on the portion of the line being packed
                            weightToPack = WHSCatchWeightHelper::calculateAverageWeight(
                                                                qtyCreate,
                                                                tmpPackingLine.QtyRemaining,
                                                                tmpPackingLine.WeightToPack,
                                                                InventTable::inventDecimals(_itemId));
                        }
                    }

                    if (_capturedWeight)
                    {
                        UnitOfMeasureDecimalPrecision decimalPrecision = InventTable::inventDecimals(_itemId);
                        // Determine the weight passed in to pack based on the amount of this line being packed
                        weightToPack = WHSCatchWeightHelper::calculateAverageWeight(
                                                            qtyCreate,
                                                            qtySupplied,
                                                            weightRemainingToPack,
                                                            decimalPrecision);
                        weightRemainingToPack -= weightToPack;
                    }

                
                    finalInventDim = InventDim::find(tmpPackingLine.InventDimId);

                    // If we captured a serial, add it to the inventDim that will be used to create containerLine
                    if (serialId)
                    {
                        finalInventDim.InventSerialId = serialId;
                        finalInventDim = InventDim::findOrCreate(finalInventDim);
                    }

                    WHSContainerLine containerLine = WHSContainerLine::writeContainerLine(
                                                                        tmpPackingLine.ShipmentId,
                                                                        _containerId,
                                                                        _itemId,
                                                                        qtyCreate,
                                                                        tmpPackingLine.uom,
                                                                        weightToPack,
                                                                        tmpPackingLine.LoadLine,
                                                                        finalInventDim.InventDimId);
                
                    if (capture == WHSRFWhenToCapture::Packing
                        && WHSContainerTable::isForOutboundShipmentAndActiveInSalesSerialProcess(transType)
                        && salesActive)
                    {
                        transId = WHSLoadLine::findbyRecId(tmpPackingLine.LoadLine).InventTransId;

                        if (!transSet.in(transId))
                        {
                            transSet.add(transId);
                            serialCon += [[finalInventDim.inventDimId, tmpPackingLine.LoadLine, tmpPackingLine.UOM]];
                        }
                    }

                    qtySupplied -= qtyCreate;
                    qtyLeft -= qtyCreate;

                    if (_tagNumber)
                    {
                        WHSContainerTable::registerTagEvent(_tagNumber, containerLine.RecId, finalInventDim);
                    }

                    tmpPackingLine.QtyRemaining -= qtyCreate;
                    tmpPackingLine.QtyPacked += qtyCreate;
                    if (catchWeightItem)
                    {
                        tmpPackingLine.WeightToPack -= weightToPack;
                    }
                    tmpPackingLine.update();

                    qtyCreate = 0;
                    weightToPack = 0;

                    if (qtySupplied <= 0)
                    {
                        break;
                    }
                }

                if (qtySupplied > 0)
                {
                    if (outdated)
                    {
                        warning("@WAX3058");
                    }

                    throw error("@WAX1445");
                }

                tmpPackingLine.ttscommit();

                ttscommit;
            }

            if (serialCon != conNull())
            {
                for (int i = 1; i <= conLen(serialCon); i++)
                {
                    InventDimId         packingLineInventDimId;
                    WHSLoadLineRefRecId packingLineLoadLine;
                    UnitOfMeasureSymbol packingLineUoM;
                    [packingLineInventDimId, packingLineLoadLine, packingLineUoM] = conPeek(serialCon, i);

                    WHSCaptureSerialNumberAtContainerPackingContext capturedSerialContext = WHSCaptureSerialNumberAtContainerPackingContext::current();

                    if (capturedSerialContext)
                    {
                        InventTrackingRegisterTrans inventTrackingRegisterTrans;
                        inventTrackingRegisterTrans.initFromSerialId(capturedSerialContext.capturedSerialId);
                        InventTransId packingLineInventTransOrigin = WHSLoadLine::findbyRecId(packingLineLoadLine).InventTransId;
                        inventTrackingRegisterTrans.InventTransOrigin = InventTransOrigin::findByInventTransId(packingLineInventTransOrigin).RecId;
                        inventTrackingRegisterTrans.Qty -= capturedSerialContext.capturedInventQty;
                        inventTrackingRegisterTrans.write();
                    }
                    else
                    {
                        var menu = new MenuFunction(menuitemDisplayStr(InventTrackingRegisterTrans), MenuItemType::Display);
                        var args = new Args();
                        args.record(WHSContainerLine::find(
                            _tmpPackingLine.ShipmentId,
                            _containerId,
                            packingLineInventDimId,
                            packingLineLoadLine,
                            packingLineUoM));
                        menu.run(args);
                    }
                }
            }
        }
        catch
        {
            //Must back out changes to tmp table
            tmpPackingLine.ttsabort();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForOutboundShipmentAndActiveInSalesSerialProcess</Name>
				<Source><![CDATA[
    private static boolean isForOutboundShipmentAndActiveInSalesSerialProcess(WHSWorkTransType _transType)
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromTypeOrDefault(_transType);
        
        return workTransactionType.isActiveInSalesSerialProcess()
            && workTransactionType.isForOutboundShipment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForOutboundShipmentAndSerialNumberAssignmentEnabled</Name>
				<Source><![CDATA[
    private static boolean isForOutboundShipmentAndSerialNumberAssignmentEnabled(WHSWorkTransType _transType)
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromTypeOrDefault(_transType);

        return workTransactionType.isSerialNumberAssignmentEnabled()
            && workTransactionType.isForOutboundShipment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCaptureWeightAtPacking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if capture the container weight is needed
    /// </summary>
    /// <param name = "_shipmentId">
    /// The shipment Id the container is for.
    /// </param>
    /// <param name = "_itemId">
    /// The item Id of the item being packed.
    /// </param>
    /// <returns>
    /// True if it must capture the container weight at packing; otherwise false
    /// </returns>
    [Hookable(false)]
    internal static boolean mustCaptureWeightAtPacking(WHSShipmentId _shipmentId, ItemId _itemId)
    {
        var shipmentTable = WHSShipmentTable::find(_shipmentId);

        return ((shipmentTable.WorkTransType == WHSWorkTransType::Sales
                    && WHSInventTable::salesOrderWeightCapturingProcess(_itemId) == WHSSalesOrderWeightCapturingProcess::Packing)
                || (shipmentTable.WorkTransType == WHSWorkTransType::TransferIssue
                    && WHSInventTable::transferIssueWeightCapturingProcess(_itemId) == WHSTransferIssueWeightCapturingProcess::Packing));
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerTagEvent</Name>
				<Source><![CDATA[
    private static void registerTagEvent(WHSCatchWeightTagNumber _tagNumber, WHSContainerLineRecId _containerLineRecId, InventDim _inventDim)
    {
        WHSCatchWeightTagEventRegistration eventRegistration = WHSCatchWeightTagEventRegistration::instantiateFromTagRegistration(WHSCatchWeightTagRegistrationEvent::PackingCompleted);
        eventRegistration.parmContainerLineRecId(_containerLineRecId);
        eventRegistration.parmStorageInventDim(_inventDim);
        eventRegistration.registerEvent(WHSCatchWeightTag::find(_tagNumber));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCWTagMismatchLoadLine</Name>
				<Source><![CDATA[
    private static boolean isCWTagMismatchLoadLine(WHSCatchWeightTagNumber _tagNumber, WHSLoadLineRefRecId _loadLineRecId)
    {
        boolean ret;

        WHSCatchWeightTag tag = WHSCatchWeightTag::find(_tagNumber);
        WHSCatchWeightTagLastRegistration lastRegistration = WHSCatchWeightTagLastRegistration::find(tag.TagNumber);

        if (!lastRegistration || !lastRegistration.WorkLine)
        {
            ret = true;
        }
        
        if (!ret)
        {
            WHSWorkLine workLine = WHSWorkLine::findByRecId(lastRegistration.WorkLine);
            ret = workLine.LoadLineRefRecId != _loadLineRecId;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMenuFunctionForPrintingContainerContents</Name>
				<Source><![CDATA[
    protected static MenuFunction createMenuFunctionForPrintingContainerContents(Args _args, WHSContainerTable _whsContainerTable, NoYesId _showDialog = NoYes::Yes)
    {
        _args.name(ssrsReportStr(WHSContainerContents, Report));
        _args.record(_whsContainerTable);

        MenuFunction menuFunction = new MenuFunction(menuitemOutputStr(WHSContainerContents), MenuItemType::Output);
        menuFunction.enumParameter(_showDialog);

        return menuFunction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printContainerContents</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints container contents.
    /// </summary>
    /// <param name="_whsContainerTable">
    /// Container table record.
    /// </param>
    /// <param name="_showDialog">
    /// Determines whether the output will be shown on dialog; optional.
    /// </param>
    public static void printContainerContents(WHSContainerTable _whsContainerTable, NoYesId _showDialog = NoYes::Yes)
    {
        Args args = new Args();

        MenuFunction menuFunction = WHSContainerTable::createMenuFunctionForPrintingContainerContents(args, _whsContainerTable, _showDialog);

        if (menuFunction)
        {
            menuFunction.run(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reOpenContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reopens a closed container.
    /// </summary>
    /// <param name="_shipmentId">
    /// The shipment Id the container is for.
    /// </param>
    /// <param name="_containerId">
    /// The container Id of the container being reopened.
    /// </param>
    /// <param name="_unmanifestShipment">
    /// A Boolean that determines if the the container should be unmanifested.
    /// </param>
    public static void reOpenContainer(
        WHSShipmentId   _shipmentId,
        WHSContainerId  _containerId,
        boolean         _unmanifestShipment = false)
    {
        WHSContainerTable   containerTable = WHSContainerTable::find(_shipmentId, _containerId);

        if (!containerTable)
        {
            throw error(error::missingRecord(tableStr(WHSContainerTable)));
        }

        WHSReopenContainer reopenContainer = WHSReopenContainer::newFromContainerTable(containerTable);

        if (_unmanifestShipment)
        {
            reopenContainer.reopenContainerAndUnmanifestShipmentRelatedToContainer();
        }
        else
        {
            reopenContainer.reopenContainerAndUnmanifestContainer();
        }

        if (WHSContainerGroupManifest::find(containerTable.ContainerGroupingLicensePlateId).ContainerGroupTrackingNumber != '')
        {
            WHSContainerTable::unManifestContainerGroup(containerTable.ContainerGroupingLicensePlateId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstContainerLineInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the first container line related <c>InventDim</c> record for the container table.
    /// </summary>
    /// <returns>Related <c>InventDim</c> record.</returns>
    public InventDim getFirstContainerLineInventDim()
    {
        WHSContainerLine containerLine;

        select firstonly InventDimId from containerLine
            where containerLine.ContainerId == this.ContainerId;

        return containerLine.inventDim();
    }

]]></Source>
			</Method>
			<Method>
				<Name>onhandLPLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the location of the license plate of the container
    /// </summary>
    /// <returns>
    /// The location id of the location where the license plate is on hand
    /// </returns>
    display public WMSLocationId onhandLPLocation()
    {
        return InventDim::find(this.InventDimId).wMSLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isContainerManifested</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the container is manifested
    /// </summary>
    /// <returns>
    /// True if the container is manifested; otherwise false
    /// </returns>
    public boolean isContainerManifested()
    {
        return (this.ShipCarrierTrackingNum != '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>isShipmentManifested</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the shipment for the container is manifested
    /// </summary>
    /// <returns>
    /// True if the shipment for the container is manifested; otherwise false
    /// </returns>
    public boolean isShipmentManifested()
    {
        return (this.MasterTrackingNum != '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>isContainerManifestRequirementsMet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether all manifest requirements for a container is met
    /// </summary>
    /// <returns>
    /// True if all manifest requirements for the container has been met; otherwise false
    /// </returns>
    public boolean isContainerManifestRequirementsMet()
    {
        WHSCloseContainerProfile    containerProfile = WHSCloseContainerProfile::find(this.CloseContainerProfileId);

        return containerProfile.ManifestRequirementsForContainer == WHSManifestRequirement::None || this.isContainerManifested();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isContainerGroupManifestRequirementsMet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether all manifest requirements for a container group are met
    /// </summary>
    /// <returns>
    /// True if all manifest requirements for the container group have been met; otherwise false
    /// </returns>
    public boolean isContainerGroupManifestRequirementsMet()
    {
        WHSCloseContainerProfile    containerProfile = WHSCloseContainerProfile::find(this.CloseContainerProfileId);

        return this.ContainerGroupingLicensePlateId == ''
            || containerProfile.ManifestRequirementsForContainerGroup == WHSManifestRequirementContainerGroup::None
            || WHSContainerGroupManifest::find(this.ContainerGroupingLicensePlateId).ContainerGroupTrackingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isShipmentManifestRequirementsMet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether all manifest requirements for a shipment are met
    /// </summary>
    /// <returns>
    /// True if all manifest requirements for the shipment have been met; otherwise false
    /// </returns>
    public boolean isShipmentManifestRequirementsMet()
    {
        WHSCloseContainerProfile    containerProfile = WHSCloseContainerProfile::find(this.CloseContainerProfileId);

        return containerProfile.ManifestRequirementsForShipment == WHSManifestRequirement::None || this.isShipmentManifested();
    }

]]></Source>
			</Method>
			<Method>
				<Name>manifestContainerManual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes an overall run when the container structure has changed.
    /// </summary>
    /// <param name="_weightChanged">
    /// Determines whether the weight of the container has changed.
    /// </param>
    /// <param name="_containerTrackingNumber">
    /// The parameter of type <c>ShipCarrierTrackingNum</c>.
    /// </param>
    /// <param name="_weightUOM">
    /// Unit of measure for the container group.
    /// </param>
    /// <param name="_newWeight">
    /// New weight of the container.
    /// </param>
    /// <returns>
    /// True if the manifest has succeeded.
    /// </returns>
    public boolean manifestContainerManual(boolean                      _weightChanged,
                                           ShipCarrierTrackingNum       _containerTrackingNumber,
                                           WHSWeightUOM                 _weightUOM,
                                           Weight                       _newWeight = this.Weight)
    {
        WHSManifestContainer whsManifestContainer;
        boolean              ret = true;

        if (_newWeight <= 0)
        {
            ret = ret && checkFailed("@WAX:WeightMustBePositive");
        }

        if (!_containerTrackingNumber)
        {
            ret = ret && checkFailed("@WAX:ContainerTrackingNumberMustBeSpecified");
        }

        ttsbegin;

        this.Weight                 = _newWeight;
        this.WeightUOM              = _weightUOM;
        this.ShipCarrierTrackingNum = _containerTrackingNumber;

        this.validateContainerMaximumNetWeight();

        this.update();

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unManifestContainerManual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmanifests the container manually (bypassing transportation management)
    /// </summary>
    public void unManifestContainerManual()
    {
        if (this.ShipCarrierTrackingNum)
        {
            this.removeTrackingNumbersFromContainer();

            if (this.MasterTrackingNum)
            {
                info(strFmt("@WAX:TheContainerIsStillManifestedAsPartOfShipment", this.ShipmentId, this.MasterTrackingNum));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmanifestContainerWithTransportationManagement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Manifests the container using transportation management
    /// </summary>
    public void unmanifestContainerWithTransportationManagement()
    {
        DialogButton unmanifestShipment;

        if (this.MasterTrackingNum)
        {
            unmanifestShipment = Box::yesNoCancel("@WAX3325", DialogButton::No, "@WAX3326");
        }
        else
        {
            unmanifestShipment = DialogButton::No;
        }

        if (unmanifestShipment != DialogButton::Cancel)
        {
            if (unmanifestShipment == DialogButton::Yes)
            {
                if (!this.checkAndUnmanifestShipmentRelatedToContainer())
                {
                    throw error("@WAX3327");
                }

                this.removeTrackingNumbersFromAllContainersRelatedToMasterTrackingNum();
            }
            else
            {
                if (!this.checkAndUnmanifestSingleContainerTransportationManagement())
                {
                    throw error("@WAX3327");
                }

                this.removeTrackingNumbersFromContainer();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLicensePlateIdAssociatedToContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether a license plate is associated with non-shipped container
    /// </summary>
    /// <param name="_licensePlateId">
    /// The license plate id
    /// </param>
    /// <returns>
    /// True if a license plate is associated with non-shipped container; otherwise false
    /// </returns>
    public static boolean isLicensePlateIdAssociatedToContainer(WHSLicensePlateId _licensePlateId)
    {
        if (_licensePlateId && WHSLicensePlate::exist(_licensePlateId))
        {
            WHSContainerTable containerTable = WHSContainerTable::findByContainerId(_licensePlateId);

            if (containerTable.RecId != 0)
            {
                WHSShipmentTable shipmentTable = WHSShipmentTable::find(containerTable.ShipmentId);

                return shipmentTable.ShipmentStatus != WHSShipmentStatus::Shipped
                    || shipmentTable.WorkTransType  == WHSWorkTransType::TransferIssue;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfContainerCanBeReleased</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the container can be released.
    /// </summary>
    /// <returns>
    /// True if the container can be released; otherwise false.
    /// </returns>
    public boolean checkIfContainerCanBeReleased()
    {
        boolean ret = true;

        if (this.ContainerStatus != WHSContainerStatus::Closed)
        {
            ret = checkFailed(strFmt("@WAX:TheContainerIsNotClosed", this.ContainerId));
        }

        if (this.ContainerReleased)
        {
            ret = checkFailed(strFmt("@WAX:TheContainerIsAlreadyReleased", this.ContainerId));
        }

        InventDim containerInventDim = InventDim::find(this.InventDimId);

        if (!WMSLocation::find(containerInventDim.wMSLocationId, containerInventDim.InventLocationId).isPackingLocation())
        {
            ret = checkFailed(strFmt("@WAX:ContainerIsNotOnPackingStation", this.ContainerId));
        }

        if (!this.areAllManifestRequirementsMet())
        {
            ret = checkFailed(strFmt("@WAX:ManifestRequirementsForTheContainerAreNotMet", this.ContainerId));
        }

        ret = ret && this.validateAllGroupedContainersClosedBeforeRelease();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAllGroupedContainersClosedBeforeRelease</Name>
				<Source><![CDATA[
    private boolean validateAllGroupedContainersClosedBeforeRelease()
    {
        boolean ret = true;

        if (WHSContainerTable::isThereAnOpenContainerRelatedToContainerGroup(this.ContainerGroupingLicensePlateId))
        {
            ret = checkFailed(strFmt("@WAX:ErrorCannotReleaseGroupedContainersWhenThereNotAllAreClosed", this.ContainerGroupingLicensePlateId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isThereAnOpenContainerRelatedToContainerGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if there is an open container related to the passed container group license plate id.
    /// </summary>
    /// <param name = "_containerGroupLicensePlateId">Container group license plate id.</param>
    /// <returns>true if there is an open container related to the container group; otherwise false.</returns>
    public static boolean isThereAnOpenContainerRelatedToContainerGroup(WHSLicensePlateId _containerGroupLicensePlateId)
    {
        boolean ret;

        if (_containerGroupLicensePlateId)
        {
            WHSContainerTable containerTable;

            select firstonly RecId from containerTable
                where containerTable.ContainerGroupingLicensePlateId	== _containerGroupLicensePlateId
                    && containerTable.ContainerStatus                   != WHSContainerStatus::Closed;

            if (containerTable.RecId)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeOpenContainersFromContainerGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes open containers related to the passed container group license plate id.
    /// </summary>
    /// <param name = "_containerGroupLicensePlateId">Container group license plate id.</param>
    public static void removeOpenContainersFromContainerGroup(WHSLicensePlateId _containerGroupLicensePlateId)
    {
        if (_containerGroupLicensePlateId)
        {
            WHSContainerTable containerTable;

            ttsbegin;

            while select ContainerId from containerTable
                where containerTable.ContainerGroupingLicensePlateId	== _containerGroupLicensePlateId
                    && containerTable.ContainerStatus                   == WHSContainerStatus::Open
            {
                WHSLicensePlate::removeFromParentLP(containerTable.ContainerId);
            }

            update_recordset containerTable
                setting ContainerGroupingLicensePlateId = ''
                where containerTable.ContainerGroupingLicensePlateId	== _containerGroupLicensePlateId
                    && containerTable.ContainerStatus                   == WHSContainerStatus::Open;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLicensePlateIdUsedForContainerGrouping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the license plate ID is used for container grouping.
    /// </summary>
    /// <param name="_licensePlateId">
    /// The license plate ID.
    /// </param>
    /// <returns>
    /// true if the license plate ID is used for container grouping; otherwise false
    /// </returns>
    public static boolean isLicensePlateIdUsedForContainerGrouping(WHSLicensePlateId _licensePlateId)
    {
        WHSContainerTable containerTable;

        if (_licensePlateId)
        {
            select firstonly ContainerGroupingLicensePlateId
                from containerTable
                index hint ContainerGroupingLicensePlateIdIdx
                where containerTable.ContainerGroupingLicensePlateId == _licensePlateId;
        }

        return containerTable.ContainerGroupingLicensePlateId != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLicensePlateIdUsedForContainerGroupingWithNonCompletedWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the license plate ID is used for container grouping which has a non-completed work.
    /// </summary>
    /// <param name="_licensePlateId">
    /// The license plate ID.
    /// </param>
    /// <returns>
    /// true if the license plate ID is used for container grouping and has a non-completed work; otherwise false
    /// </returns>
    public static boolean isLicensePlateIdUsedForContainerGroupingWithNonCompletedWork(WHSLicensePlateId _licensePlateId)
    {
        return WHSContainerTable::isLicensePlateIdUsedForContainerGrouping(_licensePlateId)
            && WHSWorkTable::findByLicensePlate(_licensePlateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseContainerWithWorkCreation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Release the container and create work
    /// </summary>
    public void releaseContainerWithWorkCreation()
    {
        if (this.checkIfContainerCanBeReleased())
        {
            var containerProfile = WHSCloseContainerProfile::find(this.CloseContainerProfileId);

            ttsbegin;

            if (containerProfile.shouldWorkBeCreatedToMoveFromPickingLocation())
            {
                var containerWarehouseLocation = this.getContainerWarehouseLocation();
                this.createWorkForTheContainer(containerWarehouseLocation);
            }

            ttscommit;
        }
        else
        {
            throw error("@WAX:NoWorkCouldBeCreated");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPickContainerToOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the contents of the container must be picked to order.
    /// </summary>
    /// <returns>true if the contents of the container must be picked to order; otherwise, false.</returns>
    protected boolean mustPickContainerToOrder()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerCreateTransactions</Name>
				<Source><![CDATA[
    private void closeContainerCreateTransactions(WMSLocation _putLocation, WHSContainerId _containerId, WHSLicensePlateId _licensePlateId = _containerId)
    {
        if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStackForContainer(this.ContainerId))
        {
            this.closeContainerCreateWarehouseInventoryTransactions(_putLocation, _containerId, _licensePlateId);
        }
        else
        {
            WHSContainerTable::closeContainerCreateTransRecs(_putLocation, _containerId, _licensePlateId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateContainerToFinalShippingLocation</Name>
				<Source><![CDATA[
    private void updateContainerToFinalShippingLocation(WMSLocation _putLocation, WHSLicensePlateId _licensePlateId)
    {
        this.closeContainerWithNewInventDim(_putLocation, _licensePlateId);

        this.closeContainerCreateTransactions(_putLocation, _licensePlateId);

        if (this.mustPickContainerToOrder())
        {
            this.pickContainerToOrder();
        }

        this.updateShipmentAndLoadStatus(WHSShipmentTable::find(this.ShipmentId, true), this.ContainerId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseContainerWithoutWorkCreation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Release the container and directly move to final shipping location
    /// </summary>
    /// <param name="_putLocation">
    /// Put location record.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id.
    /// </param>
    public void releaseContainerWithoutWorkCreation(WMSLocation _putLocation, WHSLicensePlateId _licensePlateId)
    {
        if (this.checkIfContainerCanBeReleased())
        {
            ttsbegin;

            this.ContainerReleased = NoYes::Yes;
            this.updateContainerToFinalShippingLocation(_putLocation, _licensePlateId);
            this.checkContainerWholeLicensePlateMovedWithoutWork();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setContainerReleasedToNoForContainerId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets container released field to No for the <c>WHSContainerTable</c> record with the specified container id.
    /// </summary>
    /// <param name = "_containerId">Container id.</param>
    public static void setContainerReleasedToNoForContainerId(WHSContainerId _containerId)
    {
        ttsbegin;

        WHSContainerTable containerTable = WHSContainerTable::findByContainerId(_containerId, true);
        containerTable.ContainerReleased = NoYes::No;
        containerTable.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setContainerReleasedToNoForContainerGroupLicensePlateId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets container released field to No for the <c>WHSContainerTable</c> records with the specified container group license plate id.
    /// </summary>
    /// <param name = "_containerGroupingLicensePlateId">Container group license plate id.</param>
    public static void setContainerReleasedToNoForContainerGroupLicensePlateId(WHSContainerGroupingLicensePlateId _containerGroupingLicensePlateId)
    {
        ttsbegin;

        WHSContainerTable containerTable;

        update_recordset containerTable
            setting ContainerReleased = NoYes::No
            where containerTable.ContainerGroupingLicensePlateId == _containerGroupingLicensePlateId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setContainerReleasedToNo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets container released field to No for the <c>WHSContainerTable</c> record or records depending if the specified license plate id
    /// is related to a container or a container group.
    /// </summary>
    /// <param name = "_licensePlateId">Container id.</param>
    public static void setContainerReleasedToNo(WHSLicensePlateId _licensePlateId)
    {
        if (WHSContainerTable::isLicensePlateIdAssociatedToContainer(_licensePlateId))
        {
            WHSContainerTable::setContainerReleasedToNoForContainerId(_licensePlateId);
        }
        else if (WHSContainerTable::isLicensePlateIdUsedForContainerGrouping(_licensePlateId))
        {
            WHSContainerTable::setContainerReleasedToNoForContainerGroupLicensePlateId(_licensePlateId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isContainerOnPackingLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the container is on a packing location.
    /// </summary>
    /// <returns>True if the container is on the a packing location; otherwise false.</returns>
    public boolean isContainerOnPackingLocation()
    {
        InventDim   containerInventDim  = InventDim::find(this.InventDimId);
        WMSLocation	containerLocation   = containerInventDim.wmsLocation();

        return containerLocation.isPackingLocation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateContainerPackingPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a container with a new container packing policy.
    /// </summary>
    /// <param name = "_containerPackingPolicy">New container packing policy for the container</param>
    public void updateContainerPackingPolicy(WHSCloseContainerProfileId _containerPackingPolicy)
    {
        if (this.ContainerStatus != WHSContainerStatus::Open)
        {
            throw error("@WAX:ContainerPackingPolicyCanOnlyBeChangedForOpenedContainers");
        }

        ttsbegin;

        this.CloseContainerProfileId = _containerPackingPolicy;

        if (!this.validateWrite())
        {
            throw error(strFmt("@WAX:WHSCannotUpdateRecordInTable", tablePName(WHSContainerTable)));
        }
        else
        {
            this.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areGroupedContainersOnPackStation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the containers grouped on the specified license plate are on the specific pack station.
    /// </summary>
    /// <param name = "_containerGroupingLicensePlateId">Container group license plate ID.</param>
    /// <param name = "_packingStationLocation">Location for the packing station.</param>
    /// <returns>true if the grouped containers are on the specified pack station; otherwise false.</returns>
    public static boolean areGroupedContainersOnPackStation(WHSContainerGroupingLicensePlateId _containerGroupingLicensePlateId, WMSLocation _packingStationLocation)
    {
        if (WHSContainerTable::isLicensePlateIdUsedForContainerGrouping(_containerGroupingLicensePlateId))
        {
            WHSContainerTable containerTable;

            select firstonly ContainerId from containerTable
                where containerTable.ContainerGroupingLicensePlateId == _containerGroupingLicensePlateId;

            WMSLocation groupedContainerLocation = WHSLicensePlate::getWMSLocationWithOnHand(containerTable.ContainerId);

            if (groupedContainerLocation.wMSLocationId != _packingStationLocation.wMSLocationId
                || groupedContainerLocation.inventLocationId != _packingStationLocation.inventLocationId)
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateContainerLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates container inventDim with the new location.
    /// </summary>
    /// <param name = "_containerId">Container ID.</param>
    /// <param name = "_locationId">Warehouse location ID.</param>
    public static void updateContainerLocation(WHSContainerId _containerId, WMSLocationId _locationId)
    {
        WHSContainerTable containerTable = WHSContainerTable::findByContainerId(_containerId, true);

        if (containerTable)
        {
            InventDim containerInventDim = InventDim::find(containerTable.InventDimId);

            if (containerInventDim.wMSLocationId != _locationId)
            {
                containerInventDim.wMSLocationId = _locationId;
                containerInventDim = InventDim::findOrCreate(containerInventDim);

                containerTable.InventDimId = containerInventDim.InventDimId;
                containerTable.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateContainerGroupLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates inventDim for all containers in a container group with the new location.
    /// </summary>
    /// <param name = "_containerGroupLicensePlateId">Container ID.</param>
    /// <param name = "_locationId">Warehouse location ID.</param>
    public static void updateContainerGroupLocation(WHSContainerGroupingLicensePlateId _containerGroupLicensePlateId, WMSLocationId _locationId)
    {
        WHSContainerTable containerTable;

        while select ContainerId from containerTable
            where containerTable.ContainerGroupingLicensePlateId == _containerGroupLicensePlateId
        {
            WHSContainerTable::updateContainerLocation(containerTable.ContainerId, _locationId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateContainerOrContainerGroupLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates either the container inventDim or the inventDim for all container in a container group, based on the specified license plate.
    /// </summary>
    /// <param name = "_licensePlateId">Container or container grouping license plate ID.</param>
    /// <param name = "_locationId">Warehouse location ID.</param>
    public static void updateContainerOrContainerGroupLocation(WHSLicensePlateId _licensePlateId, WMSLocationId _locationId)
    {
        if (WHSContainerTable::isLicensePlateIdAssociatedToContainer(_licensePlateId))
        {
            WHSContainerTable::updateContainerLocation(_licensePlateId, _locationId);
        }
        else if (WHSContainerTable::isLicensePlateIdUsedForContainerGrouping(_licensePlateId))
        {
            WHSContainerTable::updateContainerGroupLocation(_licensePlateId, _locationId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkContainerMaximumNetWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the container net weight is under the weight limit specified by its container type.
    /// </summary>
    /// <param name = "_weight">Weight to be validated; optional. Default value is the container weight.</param>
    /// <returns>true if the container net weight is under the container type limit; otherwise false.</returns>
    public boolean checkContainerMaximumNetWeight(Weight _weight = this.Weight)
    {
        boolean ret = true;

        WHSContainerType containerType = WHSContainerType::find(this.ContainerTypeCode);

        if (_weight - containerType.TareWeight > containerType.MaxWeight)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerMaximumNetWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates container maximum net weight.
    /// </summary>
    /// <param name = "_weight">Weight to be validated; optional.</param>
    public void validateContainerMaximumNetWeight(Weight _weight = this.Weight)
    {
        if (!this.checkContainerMaximumNetWeight(_weight))
        {
            throw error("@WAX5647");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unManifestContainerGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmanifests a container group
    /// </summary>
    /// <param name = "_containerGroupingLicensePlateId">Container group license plate ID.</param>
    public static void unManifestContainerGroup(WHSContainerGroupingLicensePlateId _containerGroupingLicensePlateId)
    {
        WHSContainerGroupManifest containerGroupManifest;

        ttsbegin;

        delete_from containerGroupManifest
            where containerGroupManifest.ContainerGroupingLicensePlateId == _containerGroupingLicensePlateId;

        ttscommit;

        info(strFmt("@WAX:ContainerGroupIsUnmanifested", _containerGroupingLicensePlateId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isContainerManifestRequirementMetForGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether all manifest requirements for a container is met for the container group
    /// </summary>
    /// <param name="_containerGroupingLicensePlateId">
    /// The parameter of type <c>WHSContainerGroupingLicensePlateId</c>.
    /// </param>
    /// <returns>
    /// True if all manifest requirements for the containers in the group has been met; otherwise false
    /// </returns>
    public static boolean isContainerManifestRequirementMetForGroup(WHSContainerGroupingLicensePlateId _containerGroupingLicensePlateId)
    {
        WHSContainerTable           containerTable;
        boolean                     manifestRequirementsMet = true;

        while select containerTable
            where containerTable.ContainerGroupingLicensePlateId == _containerGroupingLicensePlateId
        {
            manifestRequirementsMet = containerTable.ContainerStatus == WHSContainerStatus::Closed && containerTable.isContainerManifestRequirementsMet();
            if (!manifestRequirementsMet)
            {
                return false;
            }
        }

        return manifestRequirementsMet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalContainersInContainerGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the number of containers in the container group
    /// </summary>
    /// <param name="_containerGroupingLicensePlateId">
    /// The parameter of type <c>WHSContainerGroupingLicensePlateId</c>.
    /// </param>
    /// <returns>
    /// Number of containers in the container group
    /// </returns>
    public static int totalContainersInContainerGroup(WHSContainerGroupingLicensePlateId _containerGroupingLicensePlateId)
    {
        WHSContainerTable           containerTable;

        select count(RecId) from containerTable
            where containerTable.ContainerGroupingLicensePlateId == _containerGroupingLicensePlateId;

        return int642int(containerTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>areAllManifestRequirementsMet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if all manifest requirements are met for the container, the container group and the shipment
    /// </summary>
    /// <returns>
    /// true if all requirements are met; otherwise false;
    /// </returns>
    public boolean areAllManifestRequirementsMet()
    {
        return this.isContainerManifestRequirementsMet() && this.isContainerGroupManifestRequirementsMet() && this.isShipmentManifestRequirementsMet();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayContainerGroupTrackingNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the container group manifest tracking number for the container, if any
    /// </summary>
    /// <returns>
    /// The container group manifest tracking number
    /// </returns>
    public display WHSContainerGroupTrackingNumber displayContainerGroupTrackingNumber()
    {
        return this.ContainerGroupingLicensePlateId ? WHSContainerGroupManifest::find(this.ContainerGroupingLicensePlateId).ContainerGroupTrackingNumber : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkContainerPackingPolicyCompliesWithPoliciesInShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks is a container packing policies is compatible with existing packing policies in a shipment
    /// </summary>
    /// <param name = "_packingPolicy">Container packing policy</param>
    /// <param name = "_shipmentId">Shipment id</param>
    /// <returns>
    /// True is the container packing policy is compatible; false otherwise
    /// </returns>
    public static boolean checkContainerPackingPolicyCompliesWithPoliciesInShipment(WHSCloseContainerProfileId _packingPolicy,
                                                                                    WHSShipmentId              _shipmentId)
    {
        WHSCloseContainerProfile packingPolicyForNewContainer                         = WHSCloseContainerProfile::find(_packingPolicy);
        WHSCloseContainerProfile packingPolicyForShipment                             = WHSCloseContainerProfile::find(WHSShipmentTable::findFirstContainerOnShipment(_shipmentId).CloseContainerProfileId);
        boolean                  containerPackingPolicyCompliesWithPoliciesInShipment = true;

        if (packingPolicyForShipment
         && packingPolicyForNewContainer.ManifestRequirementsForShipment != packingPolicyForShipment.ManifestRequirementsForShipment)
        {
            containerPackingPolicyCompliesWithPoliciesInShipment = checkFailed(strFmt("@WAX:TheManifestRequirementsForContainerPackingPolicyAreNotCompatibleWithExistingPackingPoliciesInShipment", _packingPolicy, _shipmentId ));
        }

        return containerPackingPolicyCompliesWithPoliciesInShipment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOnlyContainerOnShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is a container currently the only container on a shipment
    /// </summary>
    /// <returns>
    /// True is the container is the only one on the shipment; false otherwise
    /// </returns>
    public boolean isOnlyContainerOnShipment()
    {
        WHSContainerTable containerTable;

        select firstonly RecId from containerTable
            where containerTable.ShipmentId == this.ShipmentId
            &&    containerTable.RecId      != this.RecId;

        return (containerTable.RecId == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstContainerInGroupOnShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds first container in a container group on a shipment
    /// </summary>
    /// <param name="_shipmentId">
    /// Shipment id of the shipment
    /// </param>
    /// <param name="_containerGroupId">
    /// Id of the container group
    /// </param>
    /// <returns>First container in a container group on a shipment</returns>
    public static WHSContainerTable findFirstContainerInGroupOnShipment(WHSShipmentId                        _shipmentId,
                                                                        WHSContainerGroupingLicensePlateId   _containerGroupId)
    {
        WHSContainerTable containerTable;

        select firstonly containerTable
            where containerTable.ShipmentId                      == _shipmentId
            &&    containerTable.ContainerGroupingLicensePlateId == _containerGroupId;

        return containerTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOriginalPackingStation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the passed <c>WMSLocation</c> record is the packing station on which the container was created.
    /// </summary>
    /// <param name = "_packingStationLocation">The packing station location record.</param>
    /// <returns>true if the passed parameter is the packing station location on which the container was created; otherwise false.</returns>
    public boolean isOriginalPackingStation(WMSLocation _packingStationLocation)
    {
        if (_packingStationLocation)
        {
            InventDim			firstContainerInventDimFrom;
            WHSContainerTrans	firstContainerTrans;

            select firstonly InventLocationId, wMSLocationId from firstContainerInventDimFrom
                order by firstContainerTrans.TransDateTime, firstContainerTrans.ContainerTransId asc
                exists join firstContainerTrans
                    where firstContainerTrans.InventDimIdFrom	== firstContainerInventDimFrom.inventDimId
                        && firstContainerTrans.ContainerId		== this.ContainerId;

            return firstContainerInventDimFrom.InventLocationId		== _packingStationLocation.inventLocationId
                    && firstContainerInventDimFrom.wMSLocationId	== _packingStationLocation.wMSLocationId;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isContainerOnTheSamePackingStation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the passed <c>WHSContainerTable</c> record is on the same packing station.
    /// </summary>
    /// <param name = "_containerTable">The container record.</param>
    /// <returns>true if the passed container is on the same packing station; otherwise false.</returns>
    public boolean isContainerOnTheSamePackingStation(WHSContainerTable _containerTable)
    {
        if (_containerTable)
        {
            InventDim   container1InventDim  = InventDim::find(this.InventDimId);
            WMSLocation	container1Location   = container1InventDim.wmsLocation();
            InventDim   container2InventDim  = InventDim::find(_containerTable.InventDimId);

            return container1InventDim.inventLocationId	== container2InventDim.inventLocationId
                && container1InventDim.wMSLocationId	== container2InventDim.wMSLocationId
                && container1Location.isPackingLocation();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canContainerWholeLicensePlateMoveWithoutWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the container represents the license plate being moved directly to baydoor without work when closing/opening the container.
    /// </summary>
    /// <returns>true, if the container Id and corresponding license plate match, and container is moved directly to baydoor; otherwise, false.</returns>
    public boolean canContainerWholeLicensePlateMoveWithoutWork()
    {
        InventDim containerInventDim = InventDim::find(this.InventDimId);
        if (this.ContainerId == containerInventDim.LicensePlateId)
        {
            WHSCloseContainerProfile closeContainerProfile = WHSCloseContainerProfile::find(this.CloseContainerProfileId);

            return (closeContainerProfile && closeContainerProfile.shouldContainerBeAvailableAtFinalShippingLocation());
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkContainerWholeLicensePlateMovedWithoutWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks that the container that represents a license plate is moved as a whole.
    /// Ensures that as a result of the move we do not end up with a license plate being in two places at once.
    /// </summary>
    /// <exception>
    /// Update of the container will be aborted if the license plate ends up in multiple locations as a result.
    /// </exception>
    public void checkContainerWholeLicensePlateMovedWithoutWork()
    {
        if (this.canContainerWholeLicensePlateMoveWithoutWork())
        {
            InventDim containerInventDim = InventDim::find(this.InventDimId);
            if (!WHSInvent::canPutLicensePlateOnLocation(containerInventDim.LicensePlateId, containerInventDim.wMSLocationId, containerInventDim.InventLocationId, false))
            {
                warning("@WAX605");
                throw error("@SYS18447");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseTMSActions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if TMS actions can be used.
    /// </summary>
    /// <returns>
    /// true if TMS actions can be used; otherwise, false.
    /// </returns>
    public boolean canUseTMSActions()
    {
        if (TMSGlobal::skipTMS())
        {
            return false;
        }

        boolean ret = true;

        if (this.ShipmentId)
        {
            ret = WHSShipmentTable::find(this.ShipmentId).canUseTMSActions();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerBeforeSort</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes container before outbound sorting.
    /// </summary>
    /// <param name="_containerId">
    /// The container being updated.
    /// </param>
    [Hookable(false)]
    internal static void closeContainerBeforeSort(WHSContainerId _containerId)
    {
        WHSContainerTable containerTable;

        ttsbegin;

        select firstonly forupdate containerTable
            where containerTable.ContainerId == _containerId;

        containerTable.ContainerStatus    = WHSContainerStatus::Closed;
        containerTable.ContainerReleased  = NoYes::Yes;
        containerTable.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeContainerAfterWaveDemandSort</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the container created from closed wave demand sort position.
    /// </summary>
    /// <param name="_containerId">
    /// The container that is being closed.
    /// </param>
    /// <param name="_closeContainerProfileId">
    /// The close container profile used to close the container.
    /// </param>
    /// <param name="_sortLocationId">
    /// The sort location used for the container.
    /// </param>
    [Hookable(false)]
    internal static void closeContainerAfterWaveDemandSort(
        WHSContainerId                _containerId,
        WHSCloseContainerProfileId    _closeContainerProfileId,
        WMSLocationId                 _sortLocationId)
    {
        if (!_containerId || !_sortLocationId)
        {
            return;
        }

        ttsBegin;

        WHSContainerTable   containerTable = WHSContainerTable::findByContainerId(_containerId, true);
        WHSShipmentTable    shipmentTable  = WHSShipmentTable::find(containerTable.ShipmentId, true);

        // Get the location and license plate dimensions to put on the container header.
        InventDim   containerInventDim;
        containerInventDim.InventLocationId = shipmentTable.InventLocationId;
        containerInventDim.wmsLocationId  = _sortLocationId;
        containerInventDim.LicensePlateId = containerTable.ContainerId;
        containerInventDim = InventDim::findOrCreate(containerInventDim);

        // Close Container Status and update inventdim
        containerTable.ContainerStatus              = WHSContainerStatus::Closed;
        containerTable.CloseContainerUTCDateTime    = DateTimeUtil::getSystemDateTime();
        containerTable.InventDimId                  = containerInventDim.InventDimId;
        containerTable.Weight                       = containerTable.calculateWeight();
        containerTable.WeightUOM                    = WHSCloseContainerProfile::find(_closeContainerProfileId).WeightUOM;
        containerTable.write();

        // If all qty has been packed for the shipment and all containers are closed update shipment and load statuses.
        if (!WHSShipmentTable::hasOpenContainer(shipmentTable.ShipmentId, _containerId) && WHSShipmentTable::isAllQtyPicked(shipmentTable.ShipmentId))
        {
            // Update shipment status to Loaded
            WHSShipmentTable::updateShipmentStatus(shipmentTable.ShipmentId, WHSShipmentStatus::Loaded);

            // Update the load status to loaded.
            if (!WHSLoadTable::hasOpenContainer(shipmentTable.LoadId, _containerId) && WHSLoadTable::isAllQtyPicked(shipmentTable.LoadId))
            {
                WHSLoadTable::updateLoadStatus(shipmentTable.LoadId, WHSLoadStatus::Loaded);
            }
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLicensePlateByContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>WHSContainerTable</c> record by id.
    /// </summary>
    /// <param name="_containerId">
    /// Container id to find the associate license plate id.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    [Hookable(false)]
    internal static WHSLicensePlateId findLicensePlateByContainer(WHSContainerId _containerId)
    {
        WHSContainerTable containerTable = WHSContainerTable::findByContainerId(_containerId);

        WHSLicensePlateId licensePlateId = InventDim::find(containerTable.InventDimId).LicensePlateId;

        if (!licensePlateId)
        {
            // If the container dim isn't set, look for work tied to the container from containerization.
            WHSWorkLine conWorkLine;
            WHSWorkTable conWorkTable;

            select firstonly TargetLicensePlateId from conWorkTable
                where conWorkTable.WorkStatus == WHSWorkStatus::InProcess
                exists join conWorkLine
                    where conWorkLine.WorkId == conWorkTable.WorkId
                        && conWorkLine.ContainerId == containerTable.ContainerId;

            licensePlateId = conWorkTable.TargetLicensePlateId;
        }
        return licensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateContainerId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates new Container Id
    /// </summary>
    /// <returns>Container id</returns>
    public static WHSContainerId generateContainerId()
    {
        WHSContainerId containerId;

        do
        {
            containerId = WHSNumberSeqExt::newGetNum(WHSParameters::numRefWHSContainerId()).num(WHSNumberSeqExtParameters::emptyParameters());
        }
        while (WHSContainerTable::existsContainerGroupingLicensePlateId(containerId));

        return containerId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsContainerGroupingLicensePlateId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a specific <c>WHSContainerTable</c> record exists with given parameters.
    /// </summary>
    /// <param name="_containerGroupingLicensePlateId">
    /// Container grouping license plate id of the record.
    /// </param>
    /// <returns>
    /// true if the record exists; otherwise, false.
    /// </returns>
    public static boolean existsContainerGroupingLicensePlateId(WHSContainerGroupingLicensePlateId _containerGroupingLicensePlateId)
    {
        return (_containerGroupingLicensePlateId) &&
               (select firstonly RecId from whsContainerTable
                    where whsContainerTable.ContainerGroupingLicensePlateId  == _containerGroupingLicensePlateId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemAlreadyIncluded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an item in a given unit is already included on the current container.
    /// </summary>
    /// <param name = "_itemKey">
    /// An <c>InventItemKey</c> object identifying the item.
    /// </param>
    /// <param name = "_uom">
    /// A unit associated with the product.
    /// </param>
    /// <returns>
    /// True if the item in the given unit is already included; otherwise, false.
    /// </returns>
    [Hookable(false)]
    final public boolean isItemAlreadyIncluded(
        InventItemKey           _itemKey,
        UnitOfMeasureSymbol     _uom)
    {
        WHSContainerLine    containerLine;
    
        if (this.ShipmentId && this.ContainerId && _itemKey.isSpecified() && _uom)
        {
            select firstonly containerLine
                where containerLine.ShipmentId   == this.ShipmentId  &&
                      containerLine.ContainerId  == this.ContainerId &&
                      containerLine.ItemId          == _itemKey.parmItemId() &&
                      containerLIne.UnitId          == _uom;
        }
    
        return containerLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRouteSegmentContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds one <c>TMSRouteSegmentContainer</c> record based on the container ID and shipment tracking number.
    /// </summary>
    /// <returns>A <c>TMSRouteSegmentContainer</c> record.</returns>
    [Hookable(false)]
    final internal TMSRouteSegmentContainer findRouteSegmentContainer()
    {
        TMSRouteSegmentContainer routeSegmentContainer;

        if (this.ContainerId && this.ShipCarrierTrackingNum)
        {
            select firstonly routeSegmentContainer
                where routeSegmentContainer.Id == this.containerId
                    && routeSegmentContainer.ShipCarrierTrackingNum == this.ShipCarrierTrackingNum;
        }

        return routeSegmentContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkContainerShippingLabelReceived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if the container shipping label printing rule has been setup to Always and whether the label has been received from the engine.
    /// </summary>
    /// <param name = "_throwErrors">Diplay error or warning.</param>
    /// <returns>
    /// Returns <c>boolean</c> object.
    /// </returns>
    [Hookable(false)]
    final internal boolean checkContainerShippingLabelReceived()
    {
        boolean ret = true;

        if (this.ShipCarrierTrackingNum
            && WHSCloseContainerProfile::find(this.CloseContainerProfileId).PrintContainerShippingLabelRule == WHSPrintContainerShippingLabelRule::Always
            && this.findRouteSegmentContainer().ContainerShippingLabel == '')
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    [Hookable(false)]
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSInstrumentationLogger instrumentationLogger()
    {
        WHSInstrumentationLogger    logger;
        if (!logger)
        {
            logger = WHSInstrumentationLogger::createLogger(tableStr(WHSContainerTable));
        }

        return logger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closePackingWork</Name>
				<Source><![CDATA[
    private void closePackingWork()
    {
        Map closedQties = this.determinePackingWorkLinesToClose(); // Maps WorkId -> (Map of LineNum -> Qty to split)        
        boolean shouldConsiderQtyRemain = WHSPackingWorkRemainingQtyUpdateOnPackingFlight::instance().isEnabled();

        MapIterator workIterator = new MapIterator(closedQties);
        while (workIterator.more())
        {
            WHSWorkTable packingWork = WHSWorkTable::find(workIterator.key(), true);

            WHSTargetLicensePlateId initialTargetLicensePlate = packingWork.TargetLicensePlateId;

            packingWork.TargetLicensePlateId = this.ContainerId;
            packingWork.update();


            WhsSplitWork splitWork = WhsSplitWork::newFromMultipleWorkLines(packingWork.WorkId,
                                                                                workIterator.value(),
                                                                                false,
                                                                                packingWork.WorkCreatedBy);

            splitWork.parmIsSplitOnClosingPackingWork(shouldConsiderQtyRemain);
            
            WHSWorkTable workToClose;

            using (var context = WHSPackingWorkAllowInProcessContext::construct())
            {
                workToClose = WHSWorkTable::find(splitWork.splitMultipleWorkLines(), true);
            }

            //this is needed because Target LP is getting erased on initial work during work split, but this feild is needed for further splits
            packingWork = WHSWorkTable::find(packingWork.WorkId, true);
            packingWork.TargetLicensePlateId = initialTargetLicensePlate; 
            packingWork.update();

            workToClose.WorkStatus = WHSWorkStatus::Closed;
            workToClose.update();

            WHSWorkLine packingWorkLine;
            while select forupdate packingWorkLine
                where packingWorkLine.WorkId == workToClose.WorkId
            {
                packingWorkLine.WorkStatus = WHSWorkStatus::Closed;
                packingWorkLine.InventQtyRemain = 0;
                packingWorkLine.QtyRemain = 0;

                packingWorkLine.update();
            }

            workIterator.next();  
  
            WHSPackingWorkHelper::updatePutLineQty(packingWork.WorkId);
        }

        this.combineLikeWork(this.ContainerId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePackingWorkLinesToClose</Name>
				<Source><![CDATA[
    private Map determinePackingWorkLinesToClose()
    {
        Map closedQties = new Map(Types::String, Types::Class);
        boolean shouldConsiderQtyRemain = WHSPackingWorkRemainingQtyUpdateOnPackingFlight::instance().isEnabled();

        //group what needs to be moved to closed work
        WHSContainerLine containerLine;
        while select * from containerLine
            where containerLine.ContainerId == this.ContainerId
        {            
            
            WHSWorkTable openPackingWork;
            WHSWorkLine packingWorkLine;

            InventQty runningQty = containerLine.Qty;

            while select WorkId, LineNum, InventQtyWork from packingWorkLine
                where packingWorkLine.LoadLineRefRecId == containerLine.LoadLine
                    && packingWorkLine.inventDimId == containerLine.InventDimId
                    && (!shouldConsiderQtyRemain || packingWorkLine.InventQtyRemain < packingWorkLine.InventQtyWork)
                exists join openPackingWork
                    where openPackingWork.WorkTransType == WHSWorkTransType::Packing
                        && openPackingWork.WorkStatus == WHSWorkStatus::Open
                        && packingWorkLine.WorkId == openPackingWork.WorkId
            {
                if (runningQty <= 0)
                {
                    break;
                }

                if (!closedQties.exists(packingWorkLine.WorkId))
                {
                    closedQties.insert(packingWorkLine.WorkId, new Map(Types::Real, Types::Real));
                }

                Map closedQtiesOnLines = closedQties.lookup(packingWorkLine.WorkId);
                    
                InventQty packingWorkLineAlreadyAllocatedQty = (closedQtiesOnLines.exists(packingWorkLine.LineNum) ? closedQtiesOnLines.lookup(packingWorkLine.LineNum) : 0);
                InventQty packingWorkLineAvailableForAllocationQty = shouldConsiderQtyRemain ? packingWorkLine.InventQtyWork - packingWorkLine.InventQtyRemain : packingWorkLine.InventQtyWork;
                InventQty packingWorkLineNewlyAllocatedQty = min(containerLine.Qty, packingWorkLineAvailableForAllocationQty - packingWorkLineAlreadyAllocatedQty);
                runningQty -= packingWorkLineNewlyAllocatedQty;

                closedQtiesOnLines.insert(packingWorkLine.LineNum, packingWorkLineAlreadyAllocatedQty + packingWorkLineNewlyAllocatedQty);
            }
          
        }

        return closedQties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>combineLikeWork</Name>
				<Source><![CDATA[
    private void combineLikeWork(WHSTargetLicensePlateId _targetLicensePlateId)
    {
        Map locationListWorkId = new Map(Types::Container, Types::Class);
        WHSWorkTable workTable;
        container prevPutLocations;
        List workIds = new List(Types::String);
        const LineNum FirstLineNum = 1;
        WHSWorkLine workLine;

        while select WorkId from workTable
            where workTable.TargetLicensePlateId == _targetLicensePlateId
                && workTable.WorkStatus == WHSWorkStatus::Closed
                && workTable.WorkTransType == WHSWorkTransType::Packing
        {
            workIds.addEnd(workTable.WorkId);
        }

        int numberOfWorkIds = workIds.elements();

        if (numberOfWorkIds > 1)
        {
            ListEnumerator workIdListEnumerator = workIds.getEnumerator();

            workIdListEnumerator.moveNext();

            WHSWorkId firstWorkId = workIdListEnumerator.current();           

            while (workIdListEnumerator.moveNext())
            {
                while select WorkId, LineNum from workLine
                    where workLine.WorkId == workIdListEnumerator.current()
                    && workLine.WorkType == WHSWorkType::Pick
                {
                    WHSPackingWorkHelper::addWorkLineToWork(firstWorkId, workLine.WorkId, workLine.LineNum);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUnmanifestShipment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean shouldUnmanifestShipment()
    {
        return this.MasterTrackingNum != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfOpenContainersForShipment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static int numberOfOpenContainersForShipment(WHSShipmentId _shipmentId)
    {
        WHSContainerTable containerTable;

        select count(RecId) from containerTable
            where containerTable.ShipmentId == _shipmentId
            && containerTable.ContainerStatus == WHSContainerStatus::Open;

        return containerTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onContainerCreated</Name>
				<Source><![CDATA[
    static delegate void onContainerCreated(WHSCreateContainerParameters _createContainerParameters)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>containerClosingWorkCreationProcessPutLocationId</Name>
				<Source><![CDATA[
    internal WMSLocationId containerClosingWorkCreationProcessPutLocationId()
    {
        WMSLocationId putLocationId;

        WHSCloseContainerProfile closeContainerProfile = WHSCloseContainerProfile::find(this.CloseContainerProfileId);

        if (closeContainerProfile.ContainerClosingWorkCreationProcess == WHSWarehouseContainerClosingWorkCreationProcess::AssignContainerToSortPosition)
        {
            putLocationId = this.defaultSortingLocationId(closeContainerProfile);
        }
        else
        {
            putLocationId = this.defaultFinalShipmentLocationId(closeContainerProfile);
        }

        return putLocationId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>WHSandTMS</ConfigurationKey>
	<DeveloperDocumentation>@WAX4339</DeveloperDocumentation>
	<FormRef>WHSContainerTable</FormRef>
	<Label>@WAX1424</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>ContainerId</TitleField1>
	<TitleField2>ShipmentId</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>FoundAndEmpty</CacheLookup>
	<ClusteredIndex>ShipmentIdContainerIdIdx</ClusteredIndex>
	<CreatedDateTime>Yes</CreatedDateTime>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Inventory</Modules>
	<PrimaryIndex>ContainerIdIdx</PrimaryIndex>
	<ReplacementKey>ContainerIdIdx</ReplacementKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ShipmentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerTypeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Weight</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WeightUOM</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShipCarrierTrackingNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MasterTrackingNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerBuildId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveExecutionID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerLevel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentContainerId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Length</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Width</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Height</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerAttributeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NMFCCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>STCCCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CloseContainerUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ErrorContainer</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ContainerId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@WAX2277</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ShipmentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerTypeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Weight</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WeightUOM</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShipCarrierTrackingNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MasterTrackingNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>STCCCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NMFCCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerAttributeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Length</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Width</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Height</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerLevel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentContainerId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveExecutionID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerBuildId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CloseContainerUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ErrorContainer</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CloseContainerProfileId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerGroupingLicensePlateId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerizationTable</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>CloseContainerUTCDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSCloseContainerUTCDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContainerAttributeCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerAttributeCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContainerBuildId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerBuildId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContainerGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContainerId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>ContainerLevel</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerLevel</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>ContainerNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ContainerStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>WHSContainerStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContainerTypeCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerTypeCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ErrorContainer</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSErrorContainer</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Height</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSHeight</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Length</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLength</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MasterTrackingNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSMasterTrackingNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>NMFCCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSNMFCCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ParentContainerId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSParentContainerId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ShipCarrierTrackingNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ShipCarrierTrackingNum</ExtendedDataType>
			<Label>@WAX:ContainerManifestId</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ShipmentId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSShipmentId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>STCCCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSSTCCCode</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WaveExecutionID</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveExecutionID</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Weight</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Weight</ExtendedDataType>
			<Label>@WAX:ContainerGrossWeight</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WeightUOM</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWeightUOM</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Width</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWidth</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CloseContainerProfileId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSCloseContainerProfileId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ContainerReleased</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerReleased</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContainerGroupingLicensePlateId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerGroupingLicensePlateId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ContainerizationTable</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>WHSContainerizationTableRecId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InventoryTransactionMechanism</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSInventoryTransactionMechanism</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>WHSInventoryTransactionMechanismEnum</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>ShipmentIdContainerIdIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ShipmentId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ContainerId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ContainerIdIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ContainerId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ContainerGroupingLicensePlateIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ContainerGroupingLicensePlateId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ParentContainerIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ParentContainerId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ContainerBuildIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ContainerBuildId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>ContainerAttributeCode1</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSContainerAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute1</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContainerAttributeCode</Name>
					<Field>ContainerAttributeCode[1]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ContainerAttributeCode2</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSContainerAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code2</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute2</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContainerAttributeCode</Name>
					<Field>ContainerAttributeCode[2]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ContainerAttributeCode3</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSContainerAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code3</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute3</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContainerAttributeCode</Name>
					<Field>ContainerAttributeCode[3]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ContainerAttributeCode4</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSContainerAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code4</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute4</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContainerAttributeCode</Name>
					<Field>ContainerAttributeCode[4]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimId</Name>
					<SourceEDT>InventDimId</SourceEDT>
					<Field>InventDimId</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>UnitOfMeasure</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UnitOfMeasure</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WeightUOM</Name>
					<SourceEDT>WHSWeightUOM</SourceEDT>
					<Field>WeightUOM</Field>
					<RelatedField>Symbol</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSContainerTable</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>WHSContainerTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Composition</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContainerId</Name>
					<Field>ContainerId</Field>
					<RelatedField>ContainerId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSContainerType</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSContainerType</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContainerTypeCode</Name>
					<SourceEDT>WHSContainerTypeCode</SourceEDT>
					<Field>ContainerTypeCode</Field>
					<RelatedField>ContainerTypeCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSNMFC</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSNMFC</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>NMFCCode</Name>
					<SourceEDT>WHSNMFCCode</SourceEDT>
					<Field>NMFCCode</Field>
					<RelatedField>NMFCCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSShipmentTable</Name>
			<Cardinality>OneMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>WHSShipmentTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ShipmentId</Name>
					<SourceEDT>WHSShipmentId</SourceEDT>
					<Field>ShipmentId</Field>
					<RelatedField>ShipmentId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WHSLicensePlate</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSLicensePlate</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContainerGroupingLicensePlateId</Name>
					<Field>ContainerGroupingLicensePlateId</Field>
					<RelatedField>LicensePlateId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WHSCloseContainerProfile</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>WHSCloseContainerProfile</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CloseContainerProfileId</Name>
					<Field>CloseContainerProfileId</Field>
					<RelatedField>CloseContainerProfileId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WHSContainerizationTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSContainerizationTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContainerizationTable</Name>
					<Field>ContainerizationTable</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>