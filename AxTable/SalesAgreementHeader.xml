<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesAgreementHeader</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

public class SalesAgreementHeader extends AgreementHeader
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>agreementValidityPeriodText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a string.
    /// </summary>
    /// <returns>
    /// A string.
    /// </returns>
    /// <remarks>
    /// This string is used to explain the validity period when an intercompany is enabled.
    /// </remarks>
    display AgreementValidityPeriod agreementValidityPeriodText()
    {
        if (CustTable::findByCompany(
                                    this.sellingCompanyInfo().DataArea,
                                    this.CustAccount).interCompanyTradingPartner().RecId)
        {
            return "@SYS334942";
        }

        return "@SYS334943";
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeIntercompanyAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether the sales agreement can be an intercompany agreement.
    /// </summary>
    /// <returns>
    /// true if the sales agreement can be an intercompany agreement; otherwise, false.
    /// </returns>
    public boolean canBeIntercompanyAgreement()
    {
        return this.custTable().interCompanyTradingPartner().RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAgreementUsingActiveIntercompanyPartner</Name>
				<Source><![CDATA[
    public boolean isAgreementUsingActiveIntercompanyPartner()
    {
        return this.canBeIntercompanyAgreement() 
            && (!AgreementHeaderInterCompanyValidationFlight::instance().isEnabled() 
            || this.custTable().interCompanyTradingPartner().interCompanyTradingRelation().Active == NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateIntercompanyAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the sales agreement can be used for creating intercompany agreements.
    /// </summary>
    /// <returns>
    /// true if the sales agreement can be used for creating intercompany agreements; otherwise, false.
    /// </returns>
    public boolean canCreateIntercompanyAgreement()
    {
        boolean                     ret = true;
        InterCompanyTradingPartner  interCompanyTradingPartner;

        interCompanyTradingPartner = this.custTable().interCompanyTradingPartner();

        if (!interCompanyTradingPartner.RecId)
        {
            ret = false;
        }

        if (ret && InterCompanyEndpointActionPolicy::findPartner(interCompanyTradingPartner.RecId).UnitPriceEqualsCostPrice)
        {
            ret = false;
        }

        if (ret && this.intercompanyLinkExist())
        {
            ret = false;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateIntracompanyAgreement_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the sales agreement can be used for creating intracompany agreements.
    /// </summary>
    /// <returns>
    /// true if the sales agreement can be used for creating intracompany agreements; otherwise, false;
    /// </returns>
    public boolean canCreateIntracompanyAgreement_RU()
    {
        boolean ret = true;

        if (!VendTable::findByPartyRecId(this.custTable().Party))
        {
            ret = false;
        }

        if (ret && (this.intracompanyLinkExist_RU() || this.intercompanyLinkExist()))
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReleaseAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the sales agreement can be released.
    /// </summary>
    /// <param name="_agreementDate">
    /// Valid agreement date.
    /// </param>
    /// <returns>
    /// true if the sales agreement can be released; otherwise, false.
    /// </returns>
    public boolean canReleaseAgreement(
        TransDate _agreementDate = dateNull()
    )
    {
        boolean ret;

        // <GEERU>
        ret = super(_agreementDate);
        // </GEERU>

        if (ret && this.isAgreementUsingActiveIntercompanyPartner() && !this.intercompanyLinkExist())
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventOwner_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether it is possible to change agreement document title in case of related inventory owner.
    /// </summary>
    /// <returns>
    ///     true if there is no inventory owner or user accepts document title changing; otherwise, false.
    /// </returns>
    public boolean checkInventOwner_RU()
    {
        SalesAgreementHeader this_orig;
        InventOwner_RU inventOwner;
        boolean ret = true;

        if (appl.ttsLevel() == 0)
        {
            this_orig = this.orig();

            if (this.DocumentTitle != this_orig.DocumentTitle &&
                FormDataUtil::isFormDataSource(this) &&
                PurchParameters::find().InventOwnerIdInitMode_RU == InventOwnerIdInitMode_RU::AccountNumAgreement)
            {
                inventOwner = InventOwner_RU::findAccountNum(InventOwnerAccountType_RU::Cust,
                                                             this.CustAccount,
                                                             SAlesAgreementHeaderExt_RU::findBySalesAgreementHeader(this.RecId).RecId);
                if (inventOwner)
                {
                    ret = Box::okCancel(strfmt("@GLS115640", inventOwner.InventOwnerId, fieldid2pname(tablenum(InventDim), fieldnum(InventDim, InventOwnerId_RU))),
                                        DialogButton::Ok) == DialogButton::Ok;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAgreementReleaseHeaderMatch</Name>
				<Source><![CDATA[
    public AgreementReleaseHeaderMatch createAgreementReleaseHeaderMatch(Common _releaseOrderHeader)
    {
        SalesTable                  salesHeader;
        AgreementReleaseHeaderMatch ret;
        if (!(_releaseOrderHeader is SalesTable))
        {
            // Wrong argument type
            throw error("@SYS111577");
        }
        salesHeader = _releaseOrderHeader as SalesTable;

        // Init values and insert
        ret.initFromAgreementHeader(this);
        ret.initFromSalesTable(salesHeader);
        ret.insert();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Get the name of the customer account for the current <c>SalesAgreementHeader</c> record.
    /// </summary>
    /// <returns>
    ///    The name of the customer.
    /// </returns>
    public display CustName custName()
    {
        CustTable       custTable;
        DirPartyTable   partyTable;

        if (this.CustAccount)
        {
            select firstonly Party from custTable
                    where custTable.AccountNum == this.CustAccount
                join Name from partyTable
                    where partyTable.RecId == custTable.Party;
        }
        return partyTable.Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>CustTable</c> record for the current record.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// The <c>CustTable</c> record.
    /// </returns>
    CustTable custTable(boolean _forUpdate = false)
    {
        return CustTable::findByCompany(this.CustomerDataAreaId, this.CustAccount, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLegalEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the selling legal entity <c>CompanyInfo</c> instance.
    /// </summary>
    /// <returns>
    /// A <c>CompanyInfo</c> instance related to the selling legal entity.
    /// </returns>
    public CompanyInfo getLegalEntity()
    {
        return this.sellingCompanyInfo();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults the <c>SalesAgreementHeader</c> and <c>AgreementHeader</c> records from the
    /// <c>CustTable</c> table.
    /// </summary>
    /// <param name="_custTable">
    /// The customer record from which to initialize; optional.
    /// </param>
    /// <remarks>
    /// For more information, see the <see cref="T:CustTable" /> and <see cref="T:AgreementHeader" /> table.
    /// </remarks>
    public void  initFromCustTable(CustTable _custTable = this.custTable())
    {
        this.CustAccount        = _custTable.AccountNum;
        this.CustomerDataAreaId = appl.company().dataArea(tableNum(CustTable));
        this.Language           = _custTable.languageId();

        this.initFromCustVendTable(_custTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defaults the <c>SalesAgreementHeader</c> record.
    /// </summary>
    /// <remarks>
    ///    For more information, see the <see cref="SalesAgreementHeader Table" />.
    /// </remarks>
    public void initValue()
    {
        super();

        this.SellingLegalEntity = CompanyInfo::current();
        this.CustomerDataAreaId = appl.company().dataArea(tableNum(CustTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanySync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes changed data to the intercompany sales agreement header record that relates to the
    /// purchase agreement header record.
    /// </summary>
    /// <param name="_forceIntercompanySync">
    /// A Boolean value that indicates whether to force the intercompany synchronization; optional.
    /// </param>
    public void intercompanySync(boolean _forceIntercompanySync = false)
    {
        InterCompanyTradingValueMap         fromInterCompanyTradingValueMap;
        InterCompanyTradingValueMap         toInterCompanyTradingValueMap;
        InterCompanyTradingPartner          interCompanyTradingPartner;
        PurchAgreementHeader                purchAgreementHeader;
        CustTable                           custTable;
        VendTable                           vendTable;
        InterCompanyCompanyId               custTableInterCompanyTradingPartnerCompanyId;

        TradeInterCompanyConv               convAgreementClassification;
        AgreementClassification             agreementClassification, purchAgreementClassification;
        boolean                             create;
        Name                                purchClassificationName;
        // <GEERU>
        #ISOCountryRegionCodes
        boolean                             toCountryRegion_RU, fromCountryRegion_RU;
        AgreementClassificationExt_RU       agreementClassificationExt;
        SalesAgreementHeaderExt_RU          salesAgreementHeaderExt;
        PurchAgreementHeaderExt_RU          purchAgreementHeaderExt;
        // </GEERU>

        if (!_forceIntercompanySync)
        {
            if (this.InterCompanySkipUpdate == InterCompanySkipUpdate::InterCompany
             || this.InterCompanySkipUpdate == InterCompanySkipUpdate::Both
             || !this.intercompanyUpdateNow())
            {
                return;
            }
        }

        custTable = this.custTable();
        custTableInterCompanyTradingPartnerCompanyId = custTable.interCompanyTradingPartnerCompanyID();
        if (!TradeInterCompany::checkDataAreaAccess(custTableInterCompanyTradingPartnerCompanyId))
        {
            return;
        }

        fromInterCompanyTradingValueMap = custTable.interCompanyTradingPartner().interCompanyTradingValueMap();

        if (this.AgreementClassification)
        {
            select firstonly Name from agreementClassification
                where agreementClassification.RecId == this.AgreementClassification;

            convAgreementClassification = TradeInterCompanyConv::construct();
            convAgreementClassification.axSalesAgreementClassification(fromInterCompanyTradingValueMap, agreementClassification.Name);
        }

        create = !this.intercompanyLinkExist();

        changecompany(custTableInterCompanyTradingPartnerCompanyId)
        {
            // <GEERU>
            toCountryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
            // </GEERU>

            setPrefix(strFmt("@SYS93821",TradeInterCompany::curCompanyName()));

            vendTable = VendTable::find(custTable.interCompanyTradingPartnerAccount());
            interCompanyTradingPartner    = vendTable.interCompanyTradingPartner();
            toInterCompanyTradingValueMap = interCompanyTradingPartner.interCompanyTradingValueMap();

            if (create)
            {
                purchAgreementHeader.DocumentTitle            = this.DocumentTitle;
                purchAgreementHeader.DefaultAgreementLineType = CommitmentType::ProductQuantity;
                // <GEERU>
                if (!toCountryRegion_RU)
                {
                // </GEERU>
                    purchAgreementHeader.PurchNumberSequence  = NumberSeq::newGetNum(PurchParameters::numRefPurchAgreementId()).num();
                // <GEERU>
                }
                // </GEERU>
                purchAgreementHeader.VendAccount              = custTable.interCompanyTradingPartnerAccount();
                purchAgreementHeader.VendorDataAreaId         = getCompany(tableNum(vendTable), custTableInterCompanyTradingPartnerCompanyID);
                purchAgreementHeader.BuyingLegalEntity        = CompanyInfo::current();
            }
            else
            {
                purchAgreementHeader = this.purchAgreementHeader(true);
            }

            this.syncField(purchAgreementHeader,create,fieldNum(SalesAgreementHeader,AgreementState));
            this.syncField(purchAgreementHeader,create,fieldNum(SalesAgreementHeader,DocumentExternalReference));
            this.syncField(purchAgreementHeader,create,fieldNum(SalesAgreementHeader,Currency));
            this.syncField(purchAgreementHeader,create,fieldNum(SalesAgreementHeader,DefaultAgreementLineEffectiveDate));
            this.syncField(purchAgreementHeader,create,fieldNum(SalesAgreementHeader,DefaultAgreementLineExpirationDate));
            this.syncField(purchAgreementHeader,create,fieldNum(SalesAgreementHeader,Language));

            if (create || this.fieldChanged(fieldNum(SalesAgreementHeader,AgreementClassification)))
            {
                if (this.AgreementClassification)
                {
                    purchClassificationName = convAgreementClassification.axPurchAgreementClassification(toInterCompanyTradingValueMap);
                    if (!purchClassificationName)
                    {
                        this.intercompanyErrorAgreementClassification(
                            this.sellingCompanyInfo().DataArea,
                            fromInterCompanyTradingValueMap.AgreementClassificationExtCodeId,
                            toInterCompanyTradingValueMap.AgreementClassificationExtCodeId);
                    }
                    purchAgreementClassification = AgreementClassification::findPurchClassification(purchClassificationName);
                    purchAgreementHeader.AgreementClassification = purchAgreementClassification.RecId;
                }
            }
            // <GEERU>
            if (toCountryRegion_RU)
            {
                if (create)
                {
                    if (purchAgreementClassification)
                    {
                        agreementClassificationExt = AgreementClassificationExt_RU::findByAgreementClassification(purchAgreementClassification.RecId);
                    }

                    if (agreementClassificationExt.NumberSequenceTable)
                    {
                        purchAgreementHeader.PurchNumberSequence = NumberSeq::newGetNumFromId(agreementClassificationExt.NumberSequenceTable).num();
                    }
                    else
                    {
                        purchAgreementHeader.PurchNumberSequence = NumberSeq::newGetNum(PurchParameters::numRefPurchAgreementId()).num();
                    }
                }
                this.syncField(purchAgreementHeader, create, fieldNum(SalesAgreementHeader, DocumentTitle));
                this.syncField(purchAgreementHeader, create, fieldNum(SalesAgreementHeader, DefaultDimension));
            }
            // </GEERU>

            purchAgreementHeader.InterCompanySkipUpdate = InterCompanySkipUpdate::InterCompany;

            if (create)
            {
                purchAgreementHeader.insert();
                AgreementReference::createRelationShip(this.RecId, purchAgreementHeader.RecId);
                TradeInterCompany::synchronizeDocuRef(this);
            }
            else
            {
                purchAgreementHeader.update();
            }
        }

        // <GEERU>
        if (toCountryRegion_RU)
        {
            fromCountryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

            if (fromCountryRegion_RU)
            {
                salesAgreementHeaderExt = SalesAgreementHeaderExt_RU::findBySalesAgreementHeader(this.RecId);
                if (salesAgreementHeaderExt)
                {
                    salesAgreementHeaderExt.intercompanySync(_forceIntercompanySync);
                }
            }
            else
            {
                if (create)
                {
                    changecompany(custTableInterCompanyTradingPartnerCompanyId)
                    {
                        purchAgreementHeaderExt.initValue();
                        purchAgreementHeaderExt.initFromAgreementHeader(purchAgreementHeader);
                        purchAgreementHeaderExt.InterCompanySkipUpdate = InterCompanySkipUpdate::InterCompany;
                        purchAgreementHeaderExt.insert();
                    }
                }
            }
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>intracompanySync_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Synchronizes changed data to the intracompany purchase agreement header record that relates to the
    ///     sales agreement header record.
    /// </summary>
    /// <param name="_forceIntracompanySync">
    ///     A Boolean value that indicates whether to force the intracompany synchronization; optional.
    /// </param>
    public void intracompanySync_RU(boolean _forceIntracompanySync = false)
    {
        PurchAgreementHeader    purchAgreementHeader;
        CustTable               custTable;
        VendTable               vendTable;
        AgreementClassification agreementClassification, purchAgreementClassification;
        AgreementClassificationExt_RU agreementClassificationExt;
        boolean                 create;

        if (!_forceIntracompanySync)
        {
            if (this.InterCompanySkipUpdate == InterCompanySkipUpdate::Internal
             || !this.intercompanyUpdateNow())
            {
                return;
            }
        }

        custTable = this.custTable();
        vendTable = VendTable::findByPartyRecId(custTable.Party);
        create    = !this.intracompanyLinkExist_RU();

        if (create)
        {
            agreementClassification    = AgreementClassification::find(this.AgreementClassification);
            agreementClassificationExt = AgreementClassificationExt_RU::findByAgreementClassification(this.AgreementClassification);

            if (agreementClassificationExt)
            {
                purchAgreementClassification = AgreementClassification::find(agreementClassificationExt.RelatedAgreementClassification);
            }

            if (purchAgreementClassification)
            {
                agreementClassificationExt = AgreementClassificationExt_RU::findByAgreementClassification(purchAgreementClassification.recId);

                if (agreementClassificationExt.NumberSequenceTable)
                {
                    purchAgreementHeader.PurchNumberSequence = NumberSeq::newGetNumFromId(agreementClassificationExt.NumberSequenceTable).num();
                }
                else
                {
                    purchAgreementHeader.PurchNumberSequence = NumberSeq::newGetNum(PurchParameters::numRefPurchAgreementId()).num();
                }
            }
            else
            {
                throw error(strFmt("@GLS115642", agreementClassification.name));
            }

            purchAgreementHeader.AgreementClassification  = agreementClassification.RecId;
            purchAgreementHeader.DocumentTitle            = this.DocumentTitle;
            purchAgreementHeader.DefaultAgreementLineType = CommitmentType::ProductQuantity;
            purchAgreementHeader.VendAccount              = vendTable.AccountNum;
            purchAgreementHeader.VendorDataAreaId         = vendTable.dataAreaId;
            purchAgreementHeader.BuyingLegalEntity        = CompanyInfo::current();
        }
        else
        {
            purchAgreementHeader = this.purchAgreementHeader_RU(true);
        }

        this.syncField(purchAgreementHeader, create, fieldNum(SalesAgreementHeader, DocumentTitle));
        this.syncField(purchAgreementHeader, create, fieldNum(SalesAgreementHeader, AgreementState));
        this.syncField(purchAgreementHeader, create, fieldNum(SalesAgreementHeader, DocumentExternalReference));
        this.syncField(purchAgreementHeader, create, fieldNum(SalesAgreementHeader, Currency));
        this.syncField(purchAgreementHeader, create, fieldNum(SalesAgreementHeader, DefaultAgreementLineEffectiveDate));
        this.syncField(purchAgreementHeader, create, fieldNum(SalesAgreementHeader, DefaultAgreementLineExpirationDate));
        this.syncField(purchAgreementHeader, create, fieldNum(SalesAgreementHeader, Language));
        this.syncField(purchAgreementHeader, create, fieldNum(SalesAgreementHeader, DefaultDimension));

        purchAgreementHeader.InterCompanySkipUpdate = InterCompanySkipUpdate::Internal;

        if (create)
        {
            purchAgreementHeader.insert();
            AgreementReference::createRelationShip(this.RecId, purchAgreementHeader.RecId, true);
        }
        else
        {
            purchAgreementHeader.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the invoice journal records exist for the agreement.
    /// </summary>
    /// <returns>
    /// true if the invoice journal records exist; otherwise, false.
    /// </returns>
    public boolean invoiceExists()
    {
        AgreementReleaseHeaderMatch agreementReleaseHeaderMatch;
        CustInvoiceJour             custInvoiceJour;
        boolean                     ret = false;

        if (this.RecId)
        {
            select firstonly RecId from agreementReleaseHeaderMatch
                where agreementReleaseHeaderMatch.MatchingReleaseOrderAgreement == this.RecId
                exists join custInvoiceJour
                    where custInvoiceJour.SalesId == agreementReleaseHeaderMatch.SalesTableSalesId;

            ret = agreementReleaseHeaderMatch.RecId ? true : false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldValue</Name>
				<Source><![CDATA[
    public void modifiedFieldValue(fieldName _fieldName, int _arrayIndex = 1)
    {
        super(_fieldName, _arrayIndex);

        switch (_fieldName)
        {
            case fieldStr(SalesAgreementHeader, CustAccount):
                if (this.isAgreementUsingActiveIntercompanyPartner())
                {
                    this.DefaultAgreementLineType = CommitmentType::ProductQuantity;
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the type of the agreement is purchase or sales.
    /// </summary>
    /// <returns>
    ///    The type of agreement.
    /// </returns>
    /// <remarks>
    ///    For the <c>SalesAgreementHeader</c> subtype, the method always returns sales.
    /// </remarks>
    ModuleSalesPurch moduleType()
    {
        return ModuleSalesPurch::Sales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>originatorName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the originators name for the current agreement Header.
    /// </summary>
    /// <returns>
    ///    The name of the originator.
    /// </returns>
    display DirPartyName originatorName()
    {
        // Just calling super() since BP Check cannot find display method on super type
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchAgreementHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and returns the intercompany purchase agreement that relates to this sales agreement.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the <c>PurchAgreementHeader</c> record for update;
    /// optional.
    /// </param>
    /// <returns>
    /// The intercompany purchase agreement that relates to this sales agreement.
    /// </returns>
    public PurchAgreementHeader purchAgreementHeader(boolean _forUpdate = false)
    {
        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        AgreementReference      agreementReference;

        select firstonly DerivedAgreement from agreementReference
            where agreementReference.SourceAgreement == this.RecId
                // <GEERU>
                && (!countryRegion_RU || !agreementReference.IsIntraCompany_RU)
                // </GEERU>
            ;

        if (agreementReference.DerivedAgreement)
        {
            return PurchAgreementHeader::find(agreementReference.DerivedAgreement,_forUpdate);
        }

        select firstonly SourceAgreement from agreementReference
            where agreementReference.DerivedAgreement == this.RecId
                // <GEERU>
                && (!countryRegion_RU || !agreementReference.IsIntraCompany_RU)
                // </GEERU>
            ;

        return PurchAgreementHeader::find(agreementReference.SourceAgreement,_forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchAgreementHeader_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the intracompany purchase agreement header record that is related to the sales agreement header record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the <c>PurchAgreementHeader</c> record for update; optional.
    /// </param>
    /// <returns>
    ///    A table buffer that contains the intracompany purchase agreement header.
    /// </returns>
    public PurchAgreementHeader purchAgreementHeader_RU(boolean _forUpdate = false)
    {
        AgreementReference agreementReference;

        select firstonly DerivedAgreement from agreementReference
            where agreementReference.SourceAgreement   == this.RecId
               && agreementReference.IsIntraCompany_RU == true;

        if (agreementReference.DerivedAgreement)
        {
            return PurchAgreementHeader::find(agreementReference.DerivedAgreement,_forUpdate);
        }

        select firstonly SourceAgreement from agreementReference
            where agreementReference.DerivedAgreement  == this.RecId
               && agreementReference.IsIntraCompany_RU == true;

        return PurchAgreementHeader::find(agreementReference.SourceAgreement,_forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAgreementReleaseHeaderMatch</Name>
				<Source><![CDATA[
    public void removeAgreementReleaseHeaderMatch(Common _releaseOrderHeader)
    {
        SalesTable                  salesHeader;
        AgreementReleaseHeaderMatch agreementReleaseHeaderMatch;

        if (!(_releaseOrderHeader is SalesTable))
        {
            // Wrong argument type
            throw error("@SYS111577");
        }
        salesHeader = _releaseOrderHeader as SalesTable;

        delete_from agreementReleaseHeaderMatch
        where agreementReleaseHeaderMatch.SalesTableSalesId == salesHeader.SalesId
            && agreementReleaseHeaderMatch.SalesTableDataAreaId == salesHeader.dataAreaId
            && agreementReleaseHeaderMatch.ReferenceRelationType == salesHeader.TableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesAgreementHeaderDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Get the <c>SalesAgreementHeader</c> default record attached to the current
    ///    <c>SalesAgreementHeader</c> record.
    /// </summary>
    /// <param name="_forupdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A default <c>SalesAgreementHeader</c> record.
    /// </returns>
    public SalesAgreementHeaderDefault salesAgreementHeaderDefault(boolean  _forupdate = false)
    {
        SalesAgreementHeaderDefault salesAgreementHeaderDefault;

        if (this.RecId)
        {
            salesAgreementHeaderDefault.selectForUpdate(_forupdate);

            select firstonly salesAgreementHeaderDefault
                where salesAgreementHeaderDefault.SalesAgreementHeader == this.RecId;
        }

        return salesAgreementHeaderDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sellingCompanyInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>CompanyInfo</c> record referenced by the selling legal entity.
    /// </summary>
    /// <returns>
    /// The <c>CompanyInfo</c> record.
    /// </returns>
    public CompanyInfo sellingCompanyInfo()
    {
        return CompanyInfo::findRecId(this.SellingLegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCheckFailedTextAgreementState</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the check failed text for the agreement state field for sales agreements.
    /// </summary>
    public void setCheckFailedTextAgreementState()
    {
        checkFailed("@SYS334936");
    }

]]></Source>
			</Method>
			<Method>
				<Name>showDocHandIcon</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the document handling icon for the current <c>SalesAgreementHeader</c> record.
    /// </summary>
    /// <returns>
    ///    The icon number to show document handling icon for the <c>SalesAgreementHeader</c> record.
    /// </returns>
    display smmDocIconNum showDocHandIcon()
    {
        #Macrolib.Resource
        boolean     exist;

        if (this.RecId)
        {
            exist = DocuRef::exist(this.CustomerDataAreaId, this.TableId, this.RecId);
        }

        return exist? #RES_NODE_DOC : #RES_AM_NEW;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        // <GEERU>
        #ISOCountryRegionCodes
        AmountMST openBalance;
        AgreementHeader origAgreementHeader;
        SalesAgreementHeaderExt_RU salesAgreementHeaderExt, origSalesAgreementHeaderExt;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            origAgreementHeader = this;
            origAgreementHeader = origAgreementHeader.orig();

            if (this.AgreementState == AgreementState::OnHold
            && this.AgreementState != origAgreementHeader.AgreementState)
            {
                ttsBegin;
                salesAgreementHeaderExt = SalesAgreementHeaderExt_RU::findBySalesAgreementHeader(this.RecId, true);
                if (salesAgreementHeaderExt.RecId)
                {
                    origSalesAgreementHeaderExt.data(salesAgreementHeaderExt);
                    openBalance                       = CustTable::find(this.custAccount).openBalanceMSTPerAgreement_RU(salesAgreementHeaderExt.AgreementId);
                    salesAgreementHeaderExt.CreditMax = openBalance > 0 ? openBalance : 0;
                    salesAgreementHeaderExt.Update();
                }
                ttsCommit;
                if (origSalesAgreementHeaderExt.CreditMax != salesAgreementHeaderExt.CreditMax)
                {
                    info(strfmt("@GLS112519", origSalesAgreementHeaderExt.CreditMax, salesAgreementHeaderExt.CreditMax));
                }
            }

            if (this.InterCompanySkipUpdate != InterCompanySkipUpdate::Internal
            &&  this.intracompanyLinkExist_RU())
            {
                ttsbegin;
                this.intracompanySync_RU();
                ttscommit;
            }
        }
        // </GEERU>
        if (this.InterCompanySkipUpdate != InterCompanySkipUpdate::InterCompany
        &&  this.InterCompanySkipUpdate != InterCompanySkipUpdate::Both
        &&  this.intercompanyLinkExist())
        {
            ttsbegin;
            this.intercompanySync();
            ttscommit;
        }

        if(CFMParameters::isPaymentRequestsEnabled() && !CFMAgreementPaymentOrder::isMethodOfPaymentRu(this.salesAgreementHeaderDefault(), this.salesAgreementHeaderDefault().CustomerMethodOfPayment))
        {
            CFMAgreementPaymentOrder agreementPaymentOrder = CFMAgreementPaymentOrder::findByAgreement(this.RecId, SalesPurch::Sales, true);

            if (agreementPaymentOrder)
            {
                agreementPaymentOrder.delete();
            }
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDeleteErrorMessage</Name>
				<Source><![CDATA[
    public str validateDeleteErrorMessage()
    {
        return "@SYS301386";
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        ret = super();

        if (this.isAgreementUsingActiveIntercompanyPartner() && this.custTable().interCompanyTradingPartner().interCompanyEndpointActionPolicy().UnitPriceEqualsCostPrice)
        {
            ret = checkFailed("@SYS334946");
        }
        // <GEERU>
        if (ret && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ret = this.checkInventOwner_RU();
        }
        // </GEERU>
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a customer has a valid sales agreement.
    /// </summary>
    /// <param name="_custAccount">
    /// The customer account number.
    /// </param>
    /// <returns>
    /// true if customer has at least one valid agreement; otherwise, false.
    /// </returns>
    public static boolean existForCustomer(CustAccount _custAccount)
    {
        QueryRun                queryRun;

        queryRun = new QueryRun(AgreementHeader::partyAgreementsQuery(tableNum(SalesAgreementHeader), fieldNum(SalesAgreementHeader, CustAccount),
            _custAccount, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), true));
        return queryRun.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>SalesAgreementHeader</c> table.
    /// </summary>
    /// <param name="_agreementHeaderRecId">
    ///    The record ID of the <c>SalesAgreementHeader</c> record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>SalesAgreementHeader</c> table; otherwise, an empty record.
    /// </returns>
    public static SalesAgreementHeader find(AgreementHeaderRecId _agreementHeaderRecId,
                                            boolean              _forUpdate = false)
    {
        SalesAgreementHeader salesAgreementHeader;

        if (_agreementHeaderRecId)
        {
            if (_forUpdate)
            {
                salesAgreementHeader.selectForUpdate(_forUpdate);
            }

            select salesAgreementHeader
                where salesAgreementHeader.RecId == _agreementHeaderRecId;
        }

        return salesAgreementHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAgreementId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>SalesAgreementHeader</c> table.
    /// </summary>
    /// <param name="_agreementId">
    ///    The agreement ID of the <c>SalesAgreementHeader</c> record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>SalesAgreementHeader</c> table; otherwise, an empty record.
    /// </returns>
    static SalesAgreementHeader findAgreementId(SalesAgreementId  _agreementId,
                                                boolean           _forUpdate = false)
    {
        SalesAgreementHeader  salesAgreementHeader;
        CompanyInfo           companyInfo;

        if (_agreementId)
        {
            if (_forUpdate)
            {
                salesAgreementHeader.selectForUpdate(_forUpdate);
            }

            select firstonly salesAgreementHeader
                exists join companyInfo
                    where salesAgreementHeader.SalesNumberSequence  == _agreementId
                       && salesAgreementHeader.SellingLegalEntity   == companyInfo.RecId
                       && companyInfo.DataArea                      == curext();
        }

        return salesAgreementHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesAgreementLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the sales agreements lookup.
    /// </summary>
    /// <param name="_callingControl">
    /// The control for which lookup will be created.
    /// </param>
    /// <param name="_salesTable">
    /// The <c>SalesTable</c> record containing customer account and requested shipping date data, which is used to filter agreement lookup data.
    /// </param>
    /// <param name="_filterStr">
    ///    The filter string entered by the user.
    /// </param>
    /// <param name="_allStatus">
    ///    The flag to show agreements of all statuses.
    /// </param>
    public static void salesAgreementLookup(FormControl _callingControl,
        SalesTable _salesTable
        ,str _filterStr = '',
        boolean _allStatus = false
        )
    {
        // <GEERU>
        #ISOCountryRegionCodes
        Query query;
        QueryBuildDataSource qbds;
        // </GEERU>
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(SalesAgreementHeader), _callingControl);

        CustAccount currentAccount = SalesAgreementHeader::getCustAccountForSalesAgreementLookup(_salesTable.CustAccount);

        sysTableLookup.addLookupfield(fieldNum(SalesAgreementHeader, SalesNumberSequence));
        sysTableLookup.addLookupfield(fieldNum(SalesAgreementHeader, CustAccount));
        sysTableLookup.addLookupfield(fieldNum(SalesAgreementHeader, DocumentTitle));
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            sysTableLookup.addLookupMethod(tableMethodStr(AgreementHeader, AgreementDate_RU));
            sysTableLookup.addLookupfield(fieldNum(SalesAgreementHeader, Currency));
            sysTableLookup.addLookupfield(fieldNum(SalesAgreementHeader, AgreementClassification));

            query = AgreementHeader::partyAgreementsQuery(tableNum(SalesAgreementHeader),
                fieldNum(SalesAgreementHeader, CustAccount),
                currentAccount ? currentAccount : SysQuery::valueEmptyString(),
                _salesTable.ShippingDateRequested);

            SalesAgreementHeader::addRangesForSalesAgreementLookup(query, _salesTable);

            if (_filterStr)
            {
                qbds = query.dataSourceTable(tableNum(SalesAgreementHeader));
                findOrCreateRange_W(qbds, fieldNum(SalesAgreementHeader, SalesNumberSequence), _filterStr);
            }

            if (_allStatus)
            {
                qbds = query.dataSourceTable(tableNum(SalesAgreementHeader));
                findOrCreateRange_W(qbds, fieldNum(SalesAgreementHeader, AgreementState), SysQuery::valueUnlimited());
            }

            qbds = query.dataSourceTable(tableNum(SalesAgreementHeader));
            qbds = qbds.addDataSource(tableNum(SalesAgreementHeaderExt_RU));
            qbds.relations(true);
            qbds.joinMode(JoinMode::ExistsJoin);

            sysTableLookup.parmQuery(query);
        }
        else
        {
        // </GEERU>

            sysTableLookup.parmQuery(AgreementHeader::partyAgreementsQuery(tableNum(SalesAgreementHeader), fieldNum(SalesAgreementHeader, CustAccount),
                currentAccount, _salesTable.ShippingDateRequested));
        // <GEERU>
        }
        // </GEERU>
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRangesForSalesAgreementLookup</Name>
				<Source><![CDATA[
    protected static void addRangesForSalesAgreementLookup(Query _query, SalesTable _salesTable)
    {
        if (_salesTable.InvoiceAccount)
        {
            QueryBuildDataSource qbds = _query.dataSourceTable(tableNum(SalesAgreementHeader));
            qbds = qbds.addDataSource(tableNum(SalesAgreementHeaderDefault));
            qbds.relations(true);

            qbds.addRange(fieldNum(SalesAgreementHeaderDefault, CustomerInvoiceAccount)).value(_salesTable.InvoiceAccount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findIntercompanyAgreementActionPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and returns an <c>IntercompanyAgreementActionPolicy</c> record.
    /// </summary>
    /// <returns>
    /// An <c>IntercompanyAgreementActionPolicy</c> record.
    /// </returns>
    public IntercompanyAgreementActionPolicy findIntercompanyAgreementActionPolicy()
    {
        InterCompanyTradingPartnerRecID interCompanyTradingPartnerRecID = this.custTable().interCompanyTradingPartner().RecId;

        return IntercompanyAgreementActionPolicy::findFromIntercompanyTradingPartner(interCompanyTradingPartnerRecID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContactPerson</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the specified contact person can be referenced in the agreement.
    /// </summary>
    /// <param name="_contactPersonId">The ID of the contact person.</param>
    /// <returns>true, if the specified contact person can be referenced in the agreement; otherwise, false.</returns>
    public boolean validateContactPerson(ContactPersonId _contactPersonId)
    {
        if (CustTable::find(this.CustAccount).Party != ContactPerson::find(_contactPersonId).ContactForParty)
        {
            return checkFailed("@SCM:ContactPersonIsNotAssociatedWithCustomer");
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        if (TaxIntegrationUtils::isTransitDocumentEnabled())
        {
            this.TransitDocumentTransactionMap_IN::deleteTransitDocumentsForHeader();
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return super() || SalesEnforceConcurrentDeletesFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustAccountForSalesAgreementLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the organization account to which the given customer account belongs.
    /// This should be public for extensibility.
    /// Customer account contains person customer and organization customer. A person customer can belong to another organization customer.
    /// 1. If this is a non-Retail order, return current customer account.
    /// 2. If this is a Retail order, check whether organization hierarchy is supported for retail sales agreement.
    ///     2.1 If organization hierarchy is not supported, return current customer account.
    ///     2.2 If organization hierarchy is supported,
    ///         2.2.1 If this customer account doesn't belong to any other organization in customer hierarchy, return current customer account.
    ///         2.2.2 If this customer account belongs to another organization in customer hierarchy, return customer account of the corresponding organization customer.
    ///               If the organization customer doesn't exist, return current customer account.
    /// </summary>
    /// <param name = "_accountNum">The person customer account number</param>
    /// <returns>The organization account the person customer account belongs to if exists, otherwise the input customer account.</returns>
    internal static CustAccount getCustAccountForSalesAgreementLookup(CustAccount _accountNum)
    {
        CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

        MCRChannelUser mcrChannelUser = MCRChannelUser::find();
        boolean isRetailOrder = mcrChannelUser.RecId != 0;
        RetailParameters retailParameters = RetailParameters::find();
        boolean supportOrganizationHierarchy = retailParameters.IsOrganizationHierarchyEnabledOnSalesAgreement;

        CustAccount currentAccount;
        CustTable custTable = CustTable::find(_accountNum);

        if (!isRetailOrder || !supportOrganizationHierarchy)
        {
            currentAccount = _accountNum;
            eventSource.EventWritePricingSalesAgreementLookupUseCurrentCustomer(custTable.RecId, isRetailOrder, supportOrganizationHierarchy);
        }
        else
        {
            CustTable orgCustTable;
            CustHierarchyNode custHierarchyNode;
            CustHierarchy custHierarchy;

            select firstonly AccountNum from orgCustTable
                join custHierarchy
                join custHierarchyNode
                where orgCustTable.DataAreaId == custTable.DataAreaId
                    && orgCustTable.Party == custHierarchy.OrganizationParty
                    && custHierarchy.CustHierarchyId == custHierarchyNode.CustHierarchyId
                    && custHierarchyNode.Party == custTable.Party;

            if (orgCustTable.AccountNum)
            {
                currentAccount = orgCustTable.AccountNum;
                eventSource.EventWritePricingSalesAgreementLookupUseOrganizationCustomer(custTable.RecId, orgCustTable.RecId);
            }
            else
            {
                currentAccount = _accountNum;
                eventSource.EventWritePricingSalesAgreementLookupUseCurrentCustomerAsNoOrganizationFound(custTable.RecId);
            }
        }

        return currentAccount;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>TradeBlanketOrder</ConfigurationKey>
	<DeveloperDocumentation>@SYS325539</DeveloperDocumentation>
	<FormRef>SalesAgreement</FormRef>
	<Label>@SYS190135</Label>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>SalesNumberSequence</TitleField1>
	<TitleField2>CustAccount</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<Extends>AgreementHeader</Extends>
	<Modules>SalesAndMarketing</Modules>
	<ReplacementKey>SalesNumberSequenceSellingPartyIdx</ReplacementKey>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<SupportInheritance>Yes</SupportInheritance>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>SalesAgreementHeaderDefault</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>SalesAgreementHeaderDefault</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SalesNumberSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SalesNumberSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SellingLegalEntity</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Customer</Name>
			<Label>@SYS24704</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Details</Name>
			<Label>@SYS80118</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SalesNumberSequence</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SellingLegalEntity</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>OrderId</Name>
			<Label>@SYS93383</Label>
			<Fields />
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustAccount</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>CustAccount</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustomerDataAreaId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>DataAreaId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SalesNumberSequence</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SalesAgreementId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SellingLegalEntity</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS129100</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>CompanyInfoIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>SellingLegalEntity</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CustTableIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CustAccount</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CustomerDataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SalesNumberSequenceSellingPartyIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<ConfigurationKey>TradeBlanketOrder</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>SalesNumberSequence</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>SellingLegalEntity</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalTable</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>Posted</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>TableId</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AgreementHeaderSales</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>AgreementHeader</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Specialization</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>CustTable_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CustTable_1_SalesAgreementHeader</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustomerDataAreaId</Name>
					<Field>CustomerDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustAccount</Name>
					<SourceEDT>CustAccount</SourceEDT>
					<Field>CustAccount</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SellingLegalEntity</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CompanyInfo</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>CompanyInfo_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CompanyInfo_SalesAgreementHeader</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SellingLegalEntity</Name>
					<Field>SellingLegalEntity</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>