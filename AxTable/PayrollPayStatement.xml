<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PayrollPayStatement</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class PayrollPayStatement extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowAdjustDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the accounting date can be changed for the given pay statement.
    /// </summary>
    /// <returns>
    ///     true if the accounting date can be changed; otherwise, false.
    /// </returns>
    public boolean allowAdjustDate()
    {
        boolean allowAdjustDate = true;

        if ((this.PostedStatus != PayrollPayStatementPostedStatus::None)
            || (this.SourceDocumentHeader == 0))
        {
            // The pay statement has either already been posted or is in the process of being posted
            allowAdjustDate = false;
        }

        return allowAdjustDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDeleteOrEdit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the record can be deleted or edited.
    /// </summary>
    /// <returns>
    ///     true if the record can be deleted or edited; otherwise, false.
    /// </returns>
    public boolean allowDeleteOrEdit()
    {
        boolean allowDeleteOrEdit;

        if (this.PostedStatus != PayrollPayStatementPostedStatus::None)
        {
            // Don't allow edits for pay statements that are either posted or in the process of being posted
            allowDeleteOrEdit = false;
        }
        else
        {
            allowDeleteOrEdit = (this.PaymentStatus == PayrollPaymentStatus::Calculated
                                || this.PaymentStatus == PayrollPaymentStatus::RequiresRecalculation) && !this.IsReversed;
        }

        return allowDeleteOrEdit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowPosting</Name>
				<Source><![CDATA[
/// <summary>
    ///     Checks if the record can be posted.
    /// </summary>
    /// <returns>
    ///     true if the record can be posted; otherwise, false.
    /// </returns>
    public boolean allowPosting()
    {
        boolean allowPosting = true;

        if (this.PaymentStatus == PayrollPaymentStatus::RequiresRecalculation)
        {
            // Pay statement requires a recalc first
            allowPosting = false;
        }
        else if (this.PostedStatus != PayrollPayStatementPostedStatus::None)
        {
            // The pay statement has either already been posted or is in the process of being posted
            allowPosting = false;
        }
        else if (this.SourceDocumentHeader == 0)
        {
            // The pay statement was created with accounting disabled
            allowPosting = false;
        }
        else if (this.NetAccountingCurrencyAmount < 0 && !this.IsReversed)
        {
            // The pay statement has a negative amount and would be stuck in a posted only state
            allowPosting = false;
        }

        return allowPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowReversal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the record can be reversed or not.
    /// </summary>
    /// <returns>
    ///     true if the record can be reversed; otherwise, false.
    /// </returns>
    public boolean allowReversal()
    {
        return !this.IsReversed
                && (this.PaymentStatus == PayrollPaymentStatus::SentToPaymentJournal
                    || this.PaymentStatus == PayrollPaymentStatus::PaymentIssued
                    || this.PostedStatus == PayrollPayStatementPostedStatus::Posted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSubmitForPayment</Name>
				<Source><![CDATA[
/// <summary>
    ///     Checks if the record can be submitted for payment or not.
    /// </summary>
    /// <returns>
    ///     true if the record status is calculated and it is not a manual payment; otherwise, false.
    /// </returns>
    public boolean allowSubmitForPayment()
    {
        boolean allowSubmitForPayment;

        allowSubmitForPayment = this.PaymentStatus == PayrollPaymentStatus::Calculated
                                && (this.CreationType == PayrollPayStatementCreationType::UserEntry || this.PaymentType != PayrollPaymentType::Manual)
                                && (this.NetAccountingCurrencyAmount >= 0 || this.IsReversed);

        return allowSubmitForPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSubmitForReissue</Name>
				<Source><![CDATA[
/// <summary>
    ///     Checks if the record can be submitted for reissue for payment or not.
    /// </summary>
    /// <returns>
    ///     true if the record can be submitted for reissue for payment; otherwise, false.
    /// </returns>
    public boolean allowSubmitForReissue()
    {
        return this.PaymentStatus == PayrollPaymentStatus::PaymentIssued
                && this.IsReversed == false
                && this.NetAccountingCurrencyAmount != 0
                && (this.CreationType == PayrollPayStatementCreationType::UserEntry
                    || this.PaymentType != PayrollPaymentType::Manual);
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Manages the deletion of a <c>PayrollPayStatement</c> record buffer.
    /// </summary>
    public void delete()
    {
        PayrollPayStatementLine payStatementLine;

        ttsbegin;

        //
        // When deleted, the benefit lines need to know the pay period off of the pay statement in order to properly
        // adjust their benefit limit amount remaining, so the pay statement must still exist to retrieve during
        // the benefit delete() logic; because of this a cascade delete cannot be used.  This delete_from simulates a
        // cascade delete of the pay statement lines, but it does so prior to the pay statement getting deleted.
        //
        delete_from payStatementLine where payStatementLine.PayStatement == this.RecId;

        super();

        // Use the number sequence framework to attempt to release the document number for reuse by another pay statement.
        NumberSeq::releaseNumber(PayrollParameters::numRefPayStatementId().NumberSequenceId, this.DocumentNumber);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPayStatementStatusImage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates the pay statement status of the current record in the <c>PayrollPayStatement</c> table.
    /// </summary>
    /// <returns>
    /// A container with payroll pay statement status icon image
    /// </returns>
    public display container displayPayStatementStatusImage()
    {
        #resAppl
        ImageReference imgRef;
        str imageName;
        container imgContainer;

        switch (this.PaymentStatus)
        {
            case PayrollPaymentStatus::RequiresRecalculation:
                imageName = identifierstr(Warning);
                break;
            case PayrollPaymentStatus::SentToPaymentJournal:
                imageName = identifierstr(Generate);
                break;
            case PayrollPaymentStatus::PaymentIssued:
                imageName = identifierstr(FieldCorrect);
                break;
            case PayrollPaymentStatus::Calculated:
                imageName = identifierstr(CalculationUnitBase);
                break;
        }

        if (imageName)
        {
            imgRef = ImageReference::constructForSymbol(imageName);
            imgContainer = imgRef.pack();
        }

        return imgContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPayStatementStatusText</Name>
				<Source><![CDATA[
    public display str displayPayStatementStatusText()
    {
        DictEnum dictEnum = new DictEnum(enumnum(PayrollPaymentStatus));

        return dictEnum.value2Label(this.PaymentStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuAllowEdit_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether allowed attachments or not.
    /// </summary>
    /// <returns>
    /// true if attachments are alloded; otherwise false.
    /// </returns>
    public boolean docuAllowEdit_W()
    {
        // Attachments are always allowed for pay statements, regardless of the pay statements state
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBenefitDeductionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of benefit deductions.
    /// </summary>
    /// <returns>
    /// The calculated sum of benefit deductions.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display PayrollBenefitDeductionsAmount getBenefitDeductionAmount()
    {
        #PayrollConstants
        PayrollPayStatementBenefitLine payrollPayStatementBenefitLine;

        select sum(AccountingCurrencyAmount) from payrollPayStatementBenefitLine
            where payrollPayStatementBenefitLine.PayStatement == this.RecId
            &&    payrollPayStatementBenefitLine.IsEmployer == NoYes::No
            &&    payrollPayStatementBenefitLine.IsMarkedForRemoval == NoYes::No;

        return CurrencyExchange::round(payrollPayStatementBenefitLine.AccountingCurrencyAmount, PayrollSetup::currencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContributionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of benefit and tax contributions.
    /// </summary>
    /// <returns>
    /// The calculated sum of benefit and tax contributions.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display PayrollStatementAccountingCurrencyAmount getContributionAmount()
    {
        PayrollPayStatementLine payStatementLine;

        // This will sum taxes and benefits only because earnings always have isEmployer == false.
        select sum(AccountingCurrencyAmount) from payStatementLine
            where payStatementLine.PayStatement == this.RecId
            &&    payStatementLine.IsEmployer == NoYes::Yes
            &&    payStatementLine.IsMarkedForRemoval == NoYes::No;

        return payStatementLine.AccountingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeductionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of benefit and tax deductions.
    /// </summary>
    /// <returns>
    /// The calculated sum of benefit and tax deductions.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display PayrollStatementAccountingCurrencyAmount getDeductionAmount()
    {
        return this.getBenefitDeductionAmount() + this.getTaxDeductionAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDeductionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of tax deductions.
    /// </summary>
    /// <returns>
    /// The calculated sum of tax deductions.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display PayrollTaxDeductionsAmount getTaxDeductionAmount()
    {
        #PayrollConstants
        PayrollPayStatementTaxLine     payrollPayStatementTaxLine;

        select sum(AccountingCurrencyAmount) from payrollPayStatementTaxLine
            where payrollPayStatementTaxLine.PayStatement == this.RecId
            &&    payrollPayStatementTaxLine.IsEmployer == NoYes::No
            &&    payrollPayStatementTaxLine.IsMarkedForRemoval == NoYes::No;

        return CurrencyExchange::round(payrollPayStatementTaxLine.AccountingCurrencyAmount, PayrollSetup::currencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Manages the insertion of a new <c>PayrollPayStatement</c> buffer.
    /// </summary>
    /// <param name="_createSourceDocument">
    ///     This parameter is deprecated and not used any more. Instead, set the <c>DisableAccounting</c> field
    ///     to control whether a source document should be created with the pay statement
    /// </param>
    public void insert(boolean _createSourceDocument=true)
    {
        if (this.DisableAccounting == NoYes::No)
        {
            SourceDocumentProcessorFacade::submitSourceDocumentImplementation(this);
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpRefPayrollDisbursementJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays a jump reference table for the payroll disbursement journal.
    /// </summary>
    /// <param name="_caller">
    ///     The form or object calling this method.
    /// </param>
    public void jumpRefPayrollDisbursementJournal(Object _caller)
    {
        Args                args;
        MenuFunction        menuFunction;

        if (!this.RecId)
        {
            return;
        }

        args = new Args();

        args.caller(_caller);
        args.record(this);
        args.parmEnum(enum2int(LedgerJournalType::PayrollDisbursement));

        menuFunction = new MenuFunction(menuitemDisplayStr(LedgerJournalTablePayrollDisbursement), MenuItemType::Display);
        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocHeaderTypeEnumName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source document header type enum name.
    /// </summary>
    /// <returns>
    /// The value of the source document header type enum name.
    /// </returns>
    public EnumName parmSourceDocHeaderTypeEnumName()
    {
        return enumStr(SourceDocument_PayrollPayStatement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocHeaderTypeEnumValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source document header type enum value for a record.
    /// </summary>
    /// <returns>
    /// The value of the source document header type enum.
    /// </returns>
    public SourceDocumentTypeEnumValue parmSourceDocHeaderTypeEnumValue()
    {
        return SourceDocument_PayrollPayStatement::PayStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
public boolean validateDelete()
    {
        boolean ret = this.allowDeleteOrEdit();

        if (ret)
        {
            // allowDeleteOrEdit returned true so we also need to check the delete actions.
            ret = ret && super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a record ID exists in <c>PayrollPayStatement</c> table and shows an infolog message if record does not exist.
    /// </summary>
    /// <param name="_recId">
    /// The value of the record ID to check.
    /// </param>
    /// <returns>
    /// true if the record ID exists; otherwise, false.
    /// </returns>
    public static boolean checkExist(PayrollPayStatementRecId _recId)
    {
        boolean ret = true;

        if (!PayrollPayStatement::exist(_recId))
        {
            ret = checkFailed(strFmt(PayrollPayStatement::txtNotExist(), tableStr(PayrollPayStatement)));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countPayStatementsByBatchNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Counts the number of record in the <c>PayrollPayStatement</c> table based on the supplied value of the <c>BatchNumber</c> field.
    /// </summary>
    /// <param name="_batchNumber">
    /// The value of the <c>BatchNumber</c> field to find.
    /// </param>
    /// <returns>
    /// THe total numbers of records that have the same  <c>BatchNumber</c> in the <c>PayrollPayStatement</c> table.
    /// </returns>
    public static int countPayStatementsByBatchNumber(
        PayrollPayStatementBatchNumber _batchNumber)
    {
        PayrollPayStatement payrollPayStatement;

        select count(RecId) from payrollPayStatement
            where payrollPayStatement.BatchNumber == _batchNumber;

        return int642int(payrollPayStatement.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>PayrollPayStatement</c> record for the given inputs.
    /// </summary>
    /// <param name="_worker">
    /// Specifies the <c>HcmWorker</c> that is getting paid by the pay statement.
    /// </param>
    /// <param name="_period">
    /// Specifies the pay period of the pay run that the pay statement is to be
    /// a part of.
    /// </param>
    /// <param name="_paymentDate">
    /// Specifies the actual date of the pay statment.
    /// </param>
    /// <param name="_paymentType">
    /// Specifies the kind of pay run that is generating the pay statement.
    /// </param>
    /// <param name="_batchNumber">
    /// Specifies the batch number generated for a given pay statement generation process.
    /// </param>
    /// <param name="_doAccounting">
    /// A Boolean value that specifies whether to create the source document and related accounting distribution; optional.
    /// </param>
    /// <returns>
    /// A persisted <c>PayrollPayStatement</c> record.
    /// </returns>
    public static PayrollPayStatement create(
        HcmWorkerRecId  _worker ,
        PayrollPayPeriodRecId   _period,
        TransDate   _paymentDate,
        PayrollPaymentType  _paymentType,
        PayrollPayStatementBatchNumber  _batchNumber,
        boolean _doAccounting = true,
        PayrollPaymentMethodTypeOverrideOption  _paymentMethod = PayrollPaymentMethodTypeOverrideOption::WorkerDefault
    )
    {
        PayrollPayStatement             payStatement;
        RecId                           currentLE;
        NumberSeq                       numberSeq;

        // Get the current LE
        currentLE = CompanyInfo::current();

        ttsbegin;

        // Assign the document number via the number sequence
        numberSeq = NumberSeq::newGetNum(PayrollParameters::numRefPayStatementId());
        payStatement.DocumentNumber = numberSeq.num();

        // Determine if the payment method should be electronic or check for this worker
        if (_paymentMethod == PayrollPaymentMethodTypeOverrideOption::WorkerDefault
            && PayrollPayStatement::isAccountExistsForElectronicPayment(_worker))
        {
            payStatement.PaymentMethodType = PayrollPaymentMethodType::ElectronicPayment;
        }
        else
        {
            payStatement.PaymentMethodType = PayrollPaymentMethodType::Check;
        }

        // Set rest of the fields based on the passed-in parameters
        payStatement.Worker = _worker;
        payStatement.PayPeriod = _period;
        payStatement.PaymentDate = _paymentDate;
        payStatement.PaymentType = _paymentType;
        payStatement.BatchNumber = _batchNumber;

        if (_doAccounting)
        {
            payStatement.DisableAccounting = NoYes::No;
        }
        else
        {
            payStatement.DisableAccounting = NoYes::Yes;
        }

        payStatement.insert();
        ttscommit;
        return payStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a record ID exists in <c>PayrollPayStatement</c> table.
    /// </summary>
    /// <param name="_recId">
    /// The value of the record ID to check.
    /// </param>
    /// <returns>
    /// true if the record ID exists; otherwise, false.
    /// </returns>
    public static boolean exist(PayrollPayStatementRecId _recId)
    {
        return _recId && (select firstonly RecId from payrollPayStatement
                    where payrollPayStatement.RecId == _recId).RecId!= 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByPayCycleLegalEntityPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a record ID exists in <c>PayrollPayStatement</c> table.
    /// </summary>
    /// <param name="_payCycleRecId">
    /// The <c>PayrollPayCycle</c> record ID.
    /// </param>
    /// <param name="_legalEntityRecId">
    /// The legal entity record ID.
    /// </param>
    /// <param name="_positionRecId">
    /// The <c>HcmPosition</c> record ID.
    /// </param>
    /// <param name="_validFrom">
    /// The date value of the <c>ValidFrom</c> field of the <c>PayrollPositionDetails</c> table.
    /// </param>
    /// <param name="_validTo">
    /// The date value of the <c>ValidTo</c> field of the <c>PayrollPositionDetails</c> table.
    /// </param>
    /// <returns>
    /// true if the record ID exists; otherwise, false.
    /// </returns>
    public static boolean existByPayCycleLegalEntityPosition(PayrollPayCycleRecId   _payCycleRecId,
                                                                LegalEntityRecId    _legalEntityRecId,
                                                                HcmPositionRecId    _positionRecId,
                                                                ValidFromDate       _validFrom,
                                                                ValidToDate         _validTo)
    {
        PayrollPayStatement         payStatement;
        PayrollPayStatementLine     payStatementLine;
        PayrollPayCycle             payCycle;
        PayrollPayPeriod            payPeriod;
        DataAreaId                  companyDataAreaId;

        if (_payCycleRecId && _legalEntityRecId)
        {
            companyDataAreaId = CompanyInfo::getDataArea(_legalEntityRecId);

            changecompany(companyDataAreaId)
            {
                select firstonly RecId from payStatement
                    join RecId, Position from payStatementLine
                        where payStatement.RecId == payStatementLine.PayStatement
                            && payStatement.DataAreaId == companyDataAreaId
                            && (payStatement.PaymentStatus != PayrollPaymentStatus::PaymentIssued
                                || payStatement.PostedStatus == PayrollPayStatementPostedStatus::None)
                            && payStatementLine.Position == _positionRecId
                    join RecId from payPeriod
                        where payPeriod.RecId == payStatement.PayPeriod
                            && payPeriod.PeriodStartDate >= _validFrom
                            && payPeriod.PeriodEndDate <= _validTo
                    join RecId from payCycle
                        where payCycle.RecId == _payCycleRecId;
            }
        }

        return payStatement.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a record in the <c>PayrollPayStatement</c> table based on a record ID value.
    /// </summary>
    /// <param name="_recId">
    /// The value of the record ID to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that specifies whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// An enumeration value that indicates whether concurrency setting to be used on the table; optional.
    /// </param>
    /// <returns>
    /// A record from the <c>PayrollPayStatement</c> table.
    /// </returns>
    public static PayrollPayStatement find(
        PayrollPayStatementRecId         _recId,
        boolean             _forUpdate = false,
        ConcurrencyModel    _concurrencyModel = ConcurrencyModel::Auto)
    {
        PayrollPayStatement payrollPayStatement;

        payrollPayStatement.selectForUpdate(_forUpdate );
        if (_forUpdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            payrollPayStatement.concurrencyModel(_concurrencyModel);
        }

        select firstonly payrollPayStatement
             where payrollPayStatement.RecId == _recId;

        return payrollPayStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByDocumentNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a record in the <c>PayrollPayStatement</c> table based on supplied value of the <c>DocumentNumber</c> field.
    /// </summary>
    /// <param name="_documentNumber">
    /// The value of the <c>DocumentNumber</c> field to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that specifies whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// An enumeration value that indicates whether concurrency setting to be used on the table; optional.
    /// </param>
    /// <returns>
    /// A record from the <c>PayrollPayStatement</c> table.
    /// </returns>
    public static PayrollPayStatement findByDocumentNumber(
        PayrollPayStatementId _documentNumber,
        boolean               _forUpdate = false,
        ConcurrencyModel      _concurrencyModel = ConcurrencyModel::Auto)
    {
        PayrollPayStatement payrollPayStatement;

        payrollPayStatement.selectForUpdate(_forUpdate );
        if (_forUpdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            payrollPayStatement.concurrencyModel(_concurrencyModel);
        }

        select firstonly payrollPayStatement
            where payrollPayStatement.DocumentNumber == _documentNumber;

        return payrollPayStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySourceDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a record in the <c>PayrollPayStatement</c> table based on supplied value of the <c>SourceDocumentHeader</c> field.
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    /// The value of the <c>SourceDocumentHeader</c> field to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that specifies whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// An enumeration value that indicates whether concurrency setting to be used on the table; optional.
    /// </param>
    /// <returns>
    /// A record from the <c>PayrollPayStatement</c> table.
    /// </returns>
    public static PayrollPayStatement findBySourceDocumentHeader(
        SourceDocumentHeaderRecId _sourceDocumentHeader,
        boolean             _forUpdate = false,
        ConcurrencyModel    _concurrencyModel = ConcurrencyModel::Auto)
    {
        PayrollPayStatement payrollPayStatement;

        payrollPayStatement.selectForUpdate(_forUpdate );
        if (_forUpdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            payrollPayStatement.concurrencyModel(_concurrencyModel);
        }

        select firstonly payrollPayStatement
            where payrollPayStatement.SourceDocumentHeader == _sourceDocumentHeader;

        return payrollPayStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAccountExistsForElectronicPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified record in the <c>PayrollBankAccountDisbursement</c> table exists against the worker.
    /// </summary>
    /// <param name="_workerRecId">
    /// The <c>Worker</c> of the record to find.
    /// </param>
    /// <param name="_companyInfoRecId">
    /// The <c>LegalEntity</c> of the record to find; optional.
    /// </param>
    /// <param name="_showError">
    /// A Boolean value that indicates whether show info error message or not; optional.
    /// </param>
    /// <returns>
    /// true if the record in the <c>PayrollBankAccountDisbursement</c> table for electronic payment exists.
    /// </returns>
    public static boolean isAccountExistsForElectronicPayment(
        HcmWorkerRecId              _workerRecId,
        CompanyInfoRecId            _companyInfoRecId = CompanyInfo::current(),
        boolean                     _showError = false)
    {
        PayrollBankAccountDisbursement  bankAccountDisbursement;
        HcmWorkerBankAccount            workerBankAccount;
        boolean                         isDisbursementAccountExists = true;

        select firstonly WorkerBankAccount from bankAccountDisbursement
            where bankAccountDisbursement.IsRemainder == NoYes::Yes
            &&    bankAccountDisbursement.IsInPreNoteStatus == NoYes::No
            &&    bankAccountDisbursement.LegalEntity == _companyInfoRecId
        join RecId from workerBankAccount
            where bankAccountDisbursement.WorkerBankAccount == workerBankAccount.RecId
            && workerBankAccount.Worker == _workerRecId;

        if (workerBankAccount.RecId == 0)
        {
            if (_showError)
            {
                isDisbursementAccountExists = checkFailed(strFmt("@Payroll:ThePayStatementCouldNotBePaidElectronicallyForWorker1ACheckW", HcmWorker::find(_workerRecId).name()));
            }
            else
            {
                isDisbursementAccountExists = false;
            }
        }

        return isDisbursementAccountExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetControlEnabledForPayStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if Budget control has been enabled for pay statements.
    /// </summary>
    /// <returns>
    /// true if Budget control has been enabled for pay statements; otherwise, false.
    /// </returns>
    public static boolean isBudgetControlEnabledForPayStatement()
    {
        LedgerRecId ledgerRecId = Ledger::current();

        if (Ledger::isLedgerBudgetControlEnabled(ledgerRecId)
            && BudgetControlConfiguration::isSourceIntegratorEnabled(ledgerRecId, BudgetControlSourceIntegrator::Payroll))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the View Details option to RecId field of <c>PayrollPayStatement</c> table.
    /// </summary>
    /// <param name="_payStatementRecId">
    ///     The <c>PayrollPayStatementRecId</c> being looked up.
    /// </param>
    /// <param name="_caller">
    ///     The calling form.
    /// </param>
    /// <remarks>
    /// The method takes the RecId of <c>PayrollPayStatement</c> table value as an input param and opens the <c>PayrollPayStatement</c> form.
    /// </remarks>
    public static void jumpRef(PayrollPayStatementRecId _payStatementRecId, Object _caller)
    {
        PayrollPayStatement      payrollPayStatement;
        Args                     args;
        MenuFunction             menuFunction;
        FormRun                  formRun;

        payrollPayStatement = PayrollPayStatement::find(_payStatementRecId);

        if (!payrollPayStatement)
        {
            return;
        }

        args = new Args();
        args.caller(_caller);
        args.lookupRecord(payrollPayStatement);
        args.openMode(OpenMode::Auto);
        menuFunction = new MenuFunction(menuitemDisplayStr(PayrollPayStatement), MenuItemType::Display);
        formRun = menuFunction.create(args);
        formRun.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    public static TxtNotExist txtNotExist()
    {
        return "@SYS321009";
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();

        this.DisableAccounting = NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the default currency code of the current legal entity.
    /// </summary>
    /// <returns>The Currency code of the current legal entity.</returns>
    public display CurrencyCode getCompanyAccountingCurrency()
    {
        return Ledger::accountingCurrency();
    }

]]></Source>
			</Method>
			<Method>
				<Name>workerHasIssuedPayStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given worker has any pay statements with PaymentIssued status.
    /// </summary>
    /// <param name = "_worker">The recId of the worker to check.</param>
    /// <returns>Returns true if the worker has payment issued pay statement; otherwise, false.</returns>
    public static boolean workerHasIssuedPayStatement(HcmWorkerRecId _worker)
    {
        PayrollPayStatement payStatement;
        select firstonly RecId from payStatement
            where payStatement.PaymentStatus == PayrollPaymentStatus::PaymentIssued
                && payStatement.Worker == _worker;

        return payStatement.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Display the pay period as formatted.
    /// </summary>
    public display str getPayPeriod()
    {
        PayrollPayPeriod payPeriod = PayrollPayPeriod::find(this.PayPeriod);

        return strFmt("%1 - %2", payPeriod.PeriodStartDate, payPeriod.PeriodEndDate);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>PayrollAdministration</ConfigurationKey>
	<DeveloperDocumentation>@Payroll:ThePayrollpaystatementheaderTableHoldsThePayStatementHeaders</DeveloperDocumentation>
	<FormRef>PayrollPayStatement</FormRef>
	<Label>@Payroll:PayStatements</Label>
	<SingularLabel>@Payroll:PayStatement1</SingularLabel>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>Worker</TitleField1>
	<TitleField2>PayPeriod</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Payroll</Modules>
	<ReplacementKey>DocumentNumberIdx</ReplacementKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Worker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayPeriod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentMethodType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsReversed</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GrossAccountingCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NetAccountingCurrencyAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DocumentNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BatchNumber</Name>
			<Label>@SYS53635</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BatchNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@Payroll:Overview1</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DocumentNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Worker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayPeriod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentMethodType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsReversed</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PaymentJournal</Name>
			<Label>@Payroll:PaymentJournal</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymentJournalBatchNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VendTrans</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Posting</Name>
			<Label>@SYS334246</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PostedStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Totals</Name>
			<Label>@SYS114611</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>GrossAccountingCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NetAccountingCurrencyAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BatchNumber</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PayrollPayStatementBatchNumber</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DocumentNumber</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PayrollPayStatementId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>GrossAccountingCurrencyAmount</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PayrollStatementAccountingCurrencyAmount</ExtendedDataType>
			<Label>@Payroll:GrossPay</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsReversed</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@Payroll:PayStatementReversed</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>NetAccountingCurrencyAmount</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PayrollStatementAccountingCurrencyAmount</ExtendedDataType>
			<Label>@Payroll:NetPay1</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>PaymentDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PayrollPaymDate</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymentJournalBatchNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@Payroll:PaymentJournal</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PaymentMethodType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PayrollPaymentMethodType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PaymentStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PayrollPaymentStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PaymentType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PayrollPaymentType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PayPeriod</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PayrollPayPeriodRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PostedStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PayrollPayStatementPostedStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ReversedPayStatement</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PayrollPayStatementRecId</ExtendedDataType>
			<Label>@Payroll:ReversedPayStatement</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceDocumentHeader</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SourceDocumentHeaderRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>VendTrans</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VendTransRefRecId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@Payroll:PaymentInvoice</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Worker</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>HcmWorkerRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CreationType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>PayrollPayStatementCreationType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DisableAccounting</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS4000407</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>DocumentNumberIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>DocumentNumber</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SourceDocumentHeaderIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceDocumentHeader</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>dataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WorkerPaymentDateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Worker</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>dataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PaymentDate</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SourceDocumentHeaderImplementation</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>SourceDocumentHeader</MapField>
					<MapFieldTo>SourceDocumentHeader</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalTable</Name>
			<Cardinality>ZeroOne</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>LedgerJournalTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymentJournalBatchNum</Name>
					<Field>PaymentJournalBatchNum</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>JournalType_Extern</Name>
					<RelatedField>JournalType</RelatedField>
					<ValueStr>LedgerJournalType::PayrollDisbursement</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TypeNumIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PayPeriod_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PayrollPayPeriod</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PayPeriod</Name>
					<Field>PayPeriod</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ReversedPayStatement_FK</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>PayrollPayStatement</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReversedPayStatement</Name>
					<Field>ReversedPayStatement</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SourceDocumentHeader_FK</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>SourceDocumentHeader</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceDocumentHeader</Name>
					<Field>SourceDocumentHeader</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VendInvoicePosted</Name>
			<Cardinality>ZeroOne</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>VendTrans</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendTrans</Name>
					<Field>VendTrans</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Worker_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Worker</Name>
					<Field>Worker</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>