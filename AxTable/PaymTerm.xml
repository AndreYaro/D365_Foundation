<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PaymTerm</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class PaymTerm extends common
{
    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcBaseDateOfDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to calculate base date for counting due date when user selects cutoff date as
    /// the payment method in the term of payment form and set up cutoff day.
    /// </summary>
    /// <param name="_dueDate">
    /// A base due date contains information document date or invoice date.
    /// </param>
    /// <returns>
    /// A due date is based on cutoff day.
    /// </returns>
    public DueDate calcBaseDateOfDueDate(DueDate _dueDate)
    {
        DueDate     dueDate = _dueDate;
        int         additionalMonths;

        if (this.validateCutoffDay(true))
        {
            if (this.CutOffDay >= dayOfMth(dateEndMth(_dueDate)))
            {
                dueDate = dateEndMth(_dueDate);
            }
            else
            {
                dueDate = mkDate(this.CutOffDay, mthOfYr(_dueDate), year(_dueDate));
                if (this.CutOffDay < dayOfMth(_dueDate))
                {
                    // always do one month
                    dueDate = nextMth(dueDate);
                    // now add any additioonal months
                    for (additionalMonths = 1; additionalMonths < this.AdditionalMonths; additionalMonths +=1)
                    {
                        dueDate = nextMth(dueDate);
                    }
                }
            }
        }

        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashAccountName</Name>
				<Source><![CDATA[
    public display MainAccountNum cashAccountName()
    {
        return LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(this.CashLedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCash</Name>
				<Source><![CDATA[
    public void checkCash()
    {
        if (this.PaymMethod != NetCurrent::COD)
        {
            this.Cash = NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostOffsettingAR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>PaymTerm.PostOffsettingAR</c> field to <c>No</c> if the payment method is not COD.
    /// </summary>
    public void checkPostOffsettingAR()
    {
        //Post Offsetting AR should always be no if payment method is not COD
        if (this.PaymMethod != NetCurrent::COD)
        {
            this.PostOffsettingAR = NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        super();

        LedgerCache::clearScope(LedgerCacheScope::TermMainAccountDimensionListProvider);
    }

]]></Source>
			</Method>
			<Method>
				<Name>due</Name>
				<Source><![CDATA[
    public TransDate due(
        TransDate _transDate,
        PaymDayId _paymDayId = '',
        boolean _calledFromAOS = false,
        PaymDueDateLimit_ES _dueDateLimit_ES = null,
        TableId _docTableId = 0)
    {
        TransDate dueDate;
        PaymDayId paymDayId;

        boolean skipMonthForwarded = this.shouldSkipMonthForwarded(_transDate);

        dueDate = this.calculateDueDateFromPaymMethod(_transDate, _calledFromAOS);

        dueDate = this.adjustDueDateFromNumOfMonths(dueDate);

        dueDate = this.adjustDueDateFromNumOfDays(dueDate);

        paymDayId = this.determinePaymDayId(_paymDayId);

        dueDate = this.adjustDueDateFromDueDateLimitES(_transDate, dueDate, paymDayId, _dueDateLimit_ES, _docTableId, skipMonthForwarded);

        dueDate = this.adjustDueDateBeforeRoundOffDueDate(_transDate, dueDate, paymDayId);

        dueDate = PaymDay::roundOffDate(dueDate, paymDayId, skipMonthForwarded, this.CutOffDay);

        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDueDateFromPaymMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate due date from the payment method.
    /// </summary>
    /// <param name = "_transDate">The transaction date.</param>
    /// <param name = "_calledFromAOS">Called from AOS.</param>
    /// <returns>The due date.</returns>
    protected DueDate calculateDueDateFromPaymMethod(TransDate _transDate, boolean _calledFromAOS = false)
    {
        DueDate dueDate;

        PreferredLocale locale = new xSession().preferredLocale();

        switch (this.PaymMethod)
        {
            case NetCurrent::Net:
                dueDate = _transDate;
                break;

            case NetCurrent::CurrentMth:
                dueDate = endMth(_transDate);
                break;

            case NetCurrent::CurrentQuart:
                dueDate = dateEndQtr(_transDate);
                break;

            case NetCurrent::CurrentYear:
                dueDate = nextYr(_transDate - dayOfYr(_transDate));
                break;

            case NetCurrent::CurrentWeek:
                if (_calledFromAOS)
                {
                    dueDate = ProjParameters::dateEndOfWeekOnAOS(_transDate);
                }
                else
                {
                    dueDate = DateTimeUtil::getEndOfWeekDate(locale, _transDate);
                }
                break;

            case NetCurrent::CutOffDate:
                dueDate = this.calcBaseDateOfDueDate(_transDate);
                break;

            default:
                dueDate =_transDate;
                break;
        }

        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDueDateFromNumOfMonths</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the due date from the number of months.
    /// </summary>
    /// <param name = "_dueDate">The due date.</param>
    /// <returns>The due date.</returns>
    protected DueDate adjustDueDateFromNumOfMonths(DueDate _dueDate)
    {
        DueDate dueDate = _dueDate;

        if (this.NumOfMonths)
        {
            dueDate = dateMthFwd(dueDate, this.NumOfMonths);

            if(this.PaymMethod == NetCurrent::CurrentMth
               ||this.PaymMethod == NetCurrent::CurrentQuart
               ||this.PaymMethod == NetCurrent::CurrentYear)
            {
                dueDate = endMth(dueDate);
            }
        }

        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDueDateFromNumOfDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the due date from the number of days.
    /// </summary>
    /// <param name = "_dueDate">The due date.</param>
    /// <returns>The due date.</returns>
    protected DueDate adjustDueDateFromNumOfDays(DueDate _dueDate)
    {
        DueDate dueDate = _dueDate;

        dueDate = dueDate + this.NumOfDays;

        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePaymDayId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the payment day Id.
    /// </summary>
    /// <param name = "_paymDayId">The default payment day Id.</param>
    /// <returns>The payment day Id.</returns>
    protected PaymDayId determinePaymDayId(PaymDayId _paymDayId)
    {
        PaymDayId paymDayId = _paymDayId;

        if (!paymDayId)
        {
            paymDayId = this.PaymDayId;
        }

        return paymDayId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDueDateFromDueDateLimitES</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust the due date from the due date limits.
    /// </summary>
    /// <param name = "_transDate">The transaction date.</param>
    /// <param name = "_dueDate">The due date.</param>
    /// <param name = "_paymDayId">The payment day Id.</param>
    /// <param name = "_dueDateLimit_ES">The due date limit.</param>
    /// <param name = "_docTableId">The document table Id.</param>
    /// <param name = "_skipMonthForwarding">The parameter determining whether month forwarding functionality should be bypassed.</param>
    /// <returns>The due date.</returns>
    protected DueDate adjustDueDateFromDueDateLimitES(
        TransDate _transDate, 
        DueDate _dueDate, 
        PaymDayId _paymDayId, 
        PaymDueDateLimit_ES _dueDateLimit_ES = null, 
        TableId _docTableId = 0,
        boolean _skipMonthForwarding = false)
    {
        DueDate dueDate = _dueDate;
        PaymDayId paymDayId = _paymDayId;
        TransDate lastValidDate;

        if (_dueDateLimit_ES)
        {
            lastValidDate = _dueDateLimit_ES.getLastValidDate(_transDate);
            if (lastValidDate && (dueDate > lastValidDate))
            {
                dueDate = lastValidDate;
            }

            if ((_docTableId == tableNum(CustInvoiceJour) || _docTableId == tableNum(VendInvoiceJour)) &&
                PaymDay::roundOffDate(dueDate, paymDayId, _skipMonthForwarding) > lastValidDate)
            {
                throw error(_docTableId == tableNum(CustInvoiceJour) ? "@SYS4001054" : "@SYS4001055");
            }
        }

        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDueDateBeforeRoundOffDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust the due date before the due date is rounded.
    /// </summary>
    /// <param name = "_transDate">The transaction date.</param>
    /// <param name = "_dueDate">The due date.</param>
    /// <param name = "_paymDayId">The payment day Id.</param>
    /// <returns>
    /// The due date.
    /// </returns>
    /// <remarks>
    /// This method is an extensibility point that the due date can be further adjusted.
    /// </remarks>
    protected DueDate adjustDueDateBeforeRoundOffDueDate(TransDate _transDate, DueDate _dueDate, PaymDayId _paymDayId)
    {
        return _dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOffDueDate</Name>
				<Source><![CDATA[
    protected DueDate roundOffDueDate(DueDate _dueDate, PaymDayId _paymDayId, boolean _skipMonthForwarding = false)
    {
        return PaymDay::roundOffDate(_dueDate, _paymDayId, _skipMonthForwarding, this.CutOffDay);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a new record into the <c>PaymTerm</c> table.
    /// </summary>
    public void insert()
    {
        this.checkCash();
        this.checkPostOffsettingAR();

        super();

        LedgerCache::clearScope(LedgerCacheScope::TermMainAccountDimensionListProvider);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldnum(PaymTerm, PaymMethod):
                if (this.PaymMethod == NetCurrent::COD)
                {
                    this.CreditCardPaymentType = CreditCardPaymentType::NA;
                }
                else
                {
                    this.Cash = NoYes::No;
                    this.CashLedgerDimension = 0;
                    this.PostOffsettingAR = NoYes::No;
                }

                if (this.PaymMethod == NetCurrent::CutOffDate)
                {
                    if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#ISOJP]))
                    {
                        this.NumOfDays = 0;
                        this.NumOfMonths = 0;
                    }

                    if (this.AdditionalMonths == 0)
                    {
                        this.AdditionalMonths = 1;
                    }
                }
                else
                {
                    this.CutOffDay = 0;
                    this.AdditionalMonths = 0;
                }
                break;

            case fieldNum(PaymTerm, CreditCardPaymentType):
                if (this.CreditCardPaymentType == CreditCardPaymentType::NA)
                {
                    this.CreditCardCreditCheck = CreditCardCreditCheck::Normal;
                }
                break;

            case fieldNum(PaymTerm, Cash):
                if (this.Cash == NoYes::No)
                {
                    this.CashLedgerDimension = 0;
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates an existing record in the <c>PaymTerm</c> table.
    /// </summary>
    public void update()
    {
        PaymTerm this_Orig = this.orig();

        this.checkCash();
        this.checkPostOffsettingAR();

        super();

        if (this.CashLedgerDimension != this_Orig.CashLedgerDimension)
        {
            LedgerCache::clearScope(LedgerCacheScope::TermMainAccountDimensionListProvider);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAdditionalMonths</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the <c>additonalMonths</c> value is set between 1 and 12.
    /// </summary>
    /// <param name="_throwError">
    /// Indicates whether an error will be thrown.
    /// </param>
    /// <returns>
    /// true if the <c>additonalMonths</c> value is set between 1 and 12; otherwise, false.
    /// </returns>
    public boolean validateAdditionalMonths(boolean _throwError = false)
    {
        const AdditionalMonths MinAdditonalMonths = 1;
        const AdditionalMonths MaxAdditonalMonths = 12;

        boolean isValid = true;

        if (this.AdditionalMonths > MaxAdditonalMonths
            || this.AdditionalMonths < MinAdditonalMonths)
        {
            if (_throwError)
            {
                throw error("@GLS220365");
            }
            else
            {
                isValid = checkFailed("@GLS220365");
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCutoffDay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether cutoff day is set between 1 and 31.
    /// </summary>
    /// <param name="_throwError">
    /// Indicates whether an error will be thrown.
    /// </param>
    /// <returns>
    /// true if cutoff day is set between 1 and 31; otherwise, false.
    /// </returns>
    public boolean validateCutoffDay(boolean _throwError = false)
    {
        const PositiveDays MinCutoffDay = 1;
        const PositiveDays MaxCutoffDay = 31;

        boolean isValid = true;

        if (this.CutOffDay > MaxCutoffDay
            || this.CutOffDay < MinCutoffDay)
        {
            if (_throwError)
            {
                // Cutoff day should be set from 1 to 31.
                throw error("@GLS220364");
            }
            else
            {
                // Cutoff day should be set from 1 to 31.
                isValid = checkFailed("@GLS220364");
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldId)
    {
        boolean isValid;

        isValid = super(_fieldId);

        if (isValid)
        {
            switch (_fieldId)
            {
                case fieldNum(PaymTerm, CutOffDay):
                    if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar))
                        && this.PaymMethod == NetCurrent::CutOffDate)
                    {
                        isValid = this.validateCutoffDay();
                    }
                    break;

                case fieldNum(PaymTerm, AdditionalMonths):
                    if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar))
                        && this.PaymMethod == NetCurrent::CutOffDate)
                    {
                        isValid = this.validateAdditionalMonths();
                    }
                    break;
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean isValid;

        isValid = super();

        if (this.CashLedgerDimension && this.PaymSched)
        {
            isValid = checkFailed("@SYS25074");
        }

        isValid = isValid && this.validatePaymMethod();

        if (isValid && !this.validateCreditCardTerms())
        {
            isValid = checkFailed(
                strFmt("@DMF:InvalidValueForField",
                    enum2Symbol(enumNum(CreditCardCreditCheck), this.CreditCardCreditCheck),
                    fieldId2Name(tableNum(PaymTerm), fieldNum(PaymTerm, CreditCardCreditCheck))));
        }

        if (isValid
            && this.Cash == NoYes::No
            && this.CashLedgerDimension != 0)
        {
            isValid = checkFailed(
                strFmt("@DMF:InvalidValueForField",
                    LedgerDimensionFacade::getDisplayValueForLedgerDimension(this.CashLedgerDimension),
                    fieldId2Name(tableNum(PaymTerm), fieldNum(PaymTerm, CashLedgerDimension))));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCreditCardTerms</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validate the credit card terms.
    /// </summary>
    /// <returns>
    ///     true if the credit card payment type is specified and the credit check is normal; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean validateCreditCardTerms()
    {
        return this.CreditCardPaymentType != CreditCardPaymentType::NA 
            || this.CreditCardCreditCheck == CreditCardCreditCheck::Normal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePaymMethod</Name>
				<Source><![CDATA[
    private boolean validatePaymMethod()
    {
        boolean isValid = true;

        if (this.PaymMethod == NetCurrent::COD)
        {
            if (this.CreditCardPaymentType != CreditCardPaymentType::NA)
            {
                isValid = checkFailed(
                    strFmt("@DMF:InvalidValueForField",
                        enum2Symbol(enumNum(CreditCardPaymentType), this.CreditCardPaymentType),
                        fieldId2Name(tableNum(PaymTerm), fieldNum(PaymTerm, CreditCardPaymentType))));
            }
        }
        else
        {
            if (this.Cash == NoYes::Yes)
            {
                isValid = checkFailed(
                    strFmt("@DMF:InvalidValueForField",
                        enum2Symbol(enumNum(NoYes), this.Cash),
                        fieldId2Name(tableNum(PaymTerm), fieldNum(PaymTerm, Cash))));
            }

            if (this.PostOffsettingAR == NoYes::Yes)
            {
                isValid = checkFailed(
                    strFmt("@DMF:InvalidValueForField",
                        enum2Symbol(enumNum(NoYes), this.PostOffsettingAR),
                        fieldId2Name(tableNum(PaymTerm), fieldNum(PaymTerm, PostOffsettingAR))));
            }
        }

        if (this.PaymMethod == NetCurrent::CutOffDate)
        {
            if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#ISOJP]))
            {
                if (this.NumOfDays != 0)
                {
                    isValid = checkFailed(
                        strFmt("@DMF:InvalidValueForField",
                            this.NumOfDays,
                            fieldId2Name(tableNum(PaymTerm), fieldNum(PaymTerm, NumOfDays))));
                }

                if (this.NumOfMonths != 0)
                {
                    isValid = checkFailed(
                        strFmt("@DMF:InvalidValueForField",
                            this.NumOfMonths,
                            fieldId2Name(tableNum(PaymTerm), fieldNum(PaymTerm, NumOfMonths))));
                }
            }
        }
        else
        {
            if (this.CutOffDay != 0)
            {
                isValid = checkFailed(
                    strFmt("@DMF:InvalidValueForField",
                        this.CutOffDay,
                        fieldId2Name(tableNum(PaymTerm), fieldNum(PaymTerm, CutOffDay))));
            }

            if (this.AdditionalMonths != 0)
            {
                isValid = checkFailed(
                    strFmt("@DMF:InvalidValueForField",
                        this.AdditionalMonths,
                        fieldId2Name(tableNum(PaymTerm), fieldNum(PaymTerm, AdditionalMonths))));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>advanceDate</Name>
				<Source><![CDATA[
    public static TransDate advanceDate(
        PaymTermId _paymTermId,
        TransDate  _transDate,
        boolean _calledFromAOS = false)
    {
        return PaymTerm::find(_paymTermId).due(_transDate, '', _calledFromAOS);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashLedgerDimension</Name>
				<Source><![CDATA[
    public static LedgerDimensionDefaultAccount cashLedgerDimension(PaymTermId _paymTermId)
    {
        return (select firstonly CashLedgerDimension from paymTerm
                    order by PaymTermId
                    where paymTerm.PaymTermId == _paymTermId).CashLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    public static boolean checkExist(PaymTermId _paymTermId)
    {
        if (!PaymTerm::exist(_paymTermId))
        {
            return checkFailed(strFmt(PaymTerm::txtNotExist(),_paymTermId));
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearDefaultPaymTerm</Name>
				<Source><![CDATA[
    /// <summary>
    /// clears the default payment term.
    /// </summary>
    public static void clearDefaultPaymTerm()
    {
        PaymTerm paymTermLocal;

        update_recordSet paymTermLocal
            setting DefaultPaymTerm_PSN = NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    public static boolean exist(PaymTermId _paymTermId)
    {
        return _paymTermId != '' && (select firstonly RecId from paymTerm
            index hint TermIdx
            where paymTerm.PaymTermId == _paymTermId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    public static PaymTerm find(
        PaymTermId _paymTermId,
        boolean _forUpdate = false)
    {
        PaymTerm paymTerm;

        if (_paymTermId)
        {
            paymTerm.selectForUpdate(_forUpdate);

            select firstonly paymTerm
                index hint TermIdx
                where paymTerm.PaymTermId == _paymTermId;
        }

        return paymTerm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultPaymTerm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the default payment.
    /// </summary>
    /// <returns>
    /// A <c>PaymTerm</c> table buffer.
    /// </returns>
    public static paymTerm getDefaultPaymTerm()
    {
        PaymTerm paymTerm;

        select firstOnly paymTerm
            where PaymTerm.DefaultPaymTerm_PSN == NoYes::Yes;

        return paymTerm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isbyCashTermsofPayment_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if it is by Cash(Terms Of Payment).
    /// </summary>
    /// <param name="_paymTermId">
    /// PaymTermId.
    /// </param>
    /// <returns>
    /// true is line is by cash, otherwise false.
    /// </returns>
    public static boolean isbyCashTermsofPayment_IN(PaymTermId _paymTermId)
    {
        PaymTerm paymTerm;

        //check terms of payment
        select firstOnly PaymTermId, PaymMethod, Cash, CashLedgerDimension, RecId from paymTerm
            where paymTerm.PaymTermId == _paymTermId
                && paymTerm.PaymMethod == NetCurrent::COD
                && paymTerm.Cash == true
                && paymTerm.CashLedgerDimension  != 0;

        if (paymTerm)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCashAccount</Name>
				<Source><![CDATA[
    public static boolean isCashAccount(PaymTermId _paymTermId)
    {
        return PaymTerm::find(_paymTermId).CashLedgerDimension != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCashLedgerDimension</Name>
				<Source><![CDATA[
    public static boolean isCashLedgerDimension(PaymTermId _paymTermId)
    {
        return PaymTerm::find(_paymTermId).CashLedgerDimension != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEmplAccountUsed_RU</Name>
				<Source><![CDATA[
    public static boolean isEmplAccountUsed_RU(PaymTermId _paymTermId)
    {
        PaymTerm paymTerm;

        if (EmplParameters_RU::enableAdvanceHolders())
        {
            paymTerm = PaymTerm::find(_paymTermId);
        }

        return paymTerm.PaymMethod == NetCurrent::COD && paymTerm.UseEmplAccount_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txt</Name>
				<Source><![CDATA[
    public static FreeTxt txt(PaymTermId _paymTermId, LanguageId _languageId = CompanyInfo::languageId())
    {
        PaymTerm paymTerm = PaymTerm::find(_paymTermId);

        LanguageTxt languageTxt = LanguageTxt::find(
            paymTerm.TableId,
            paymTerm.RecId,
            _languageId);

        return languageTxt.Txt ? languageTxt.Txt: paymTerm.Description;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    public static TxtNotExist txtNotExist()
    {
        return "@SYS9592";
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipMonthForwarded</Name>
				<Source><![CDATA[
    /// <summary>
    /// check whether we should skip month forwarding or not.
    /// </summary>
    /// <param name="_transDate">
    /// transaction date
    /// </param>
    /// <returns>
    /// true if we should skip month forwarding, otherwise false.
    /// </returns>
    private boolean shouldSkipMonthForwarded(TransDate _transDate)
    {
        boolean shouldSkipMonthForwarded;

        if (this.NumOfMonths)
        {
            if (!SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion() || this.PaymMethod != NetCurrent::CutOffDate)
            {
                shouldSkipMonthForwarded = true;
            }
        }
        else if (this.NumOfMonths == 0 && this.PaymMethod == NetCurrent::CurrentMth)
        {
            PaymDayLine paymDayLine;

            select firstonly paymDayLine
                order by MonthDay
                where paymDayLine.PaymDayId == this.PaymDayId
                    && paymDayLine.WeekMonth == WeekMonth::Month
                    && paymDayLine.MonthDay >= dayofmth(_transDate);

            if (paymDayLine)
            {
                shouldSkipMonthForwarded = true;
            }
        }

        return shouldSkipMonthForwarded;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasic</ConfigurationKey>
	<DeveloperDocumentation>@SYS126020</DeveloperDocumentation>
	<FormRef>CustPaymTerm</FormRef>
	<Label>@SYS23346</Label>
	<TableGroup>Group</TableGroup>
	<TitleField1>PaymTermId</TitleField1>
	<TitleField2>Description</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>EntireTable</CacheLookup>
	<ClusteredIndex>TermIdx</ClusteredIndex>
	<DataSharingType>Duplicate</DataSharingType>
	<Modules>Bank</Modules>
	<PrimaryIndex>TermIdx</PrimaryIndex>
	<TableContents>DefaultData</TableContents>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>LanguageTxt</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>LanguageTxt</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymTermId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NumOfMonths</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NumOfDays</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymTermId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CashLedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Administration</Name>
			<Label>@SYS9853</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Cash</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NumOfMonths</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NumOfDays</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymSched</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymDayId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CutOffDay</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AdditionalMonths</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DefaultPaymTerm_PSN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UseDeliveryDateForDueDate_ES</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DueDateLimitGroupId_ES</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AdvanceHolder_RU</Name>
			<Label>@GLS100699</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>UseEmplAccount_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Credit</Name>
			<Label>@SYS7084</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ShipCarrierCertifiedCheck</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardPaymentType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardCreditCheck</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CustUpdateDueDate</Name>
			<Label>@CashManagement:GLS220363</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustomerUpdateDueDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Description</Name>
			<Label>@SYS6303</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymTermId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>LedgerPosting</Name>
			<Label>@SYS3881</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CashLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PostOffsettingAR</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Other</Name>
			<Label>@SYS1284</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ShipCarrierAncillaryCharge</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@SYS9039</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymTermId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VendUpdateDueDate</Name>
			<Label>@CashManagement:GLS220359</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VendorUpdateDueDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PaymentRequestType</Name>
			<Label>@Cashflowmanagement:PaymentRequestType</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CFMPaymentRequestTypePayment</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CFMPaymentRequestTypePrepayment</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>AdditionalMonths</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PaymCalendar</ConfigurationKey>
			<ExtendedDataType>AdditionalMonths</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Cash</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Cash</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CashLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
			<Label>@SYS103</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CreditCardCreditCheck</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CreditCardCreditCheck</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CreditCardPaymentType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CreditCardPaymentType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CustomerUpdateDueDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PaymCalendar</ConfigurationKey>
			<Label>@GLS220360</Label>
			<EnumType>PaymentDueDateUpdatePolicy</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>CutOffDay</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PaymCalendar</ConfigurationKey>
			<ExtendedDataType>PositiveDays</ExtendedDataType>
			<Label>@GLS60528</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DefaultPaymTerm_PSN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PurchFrenchRegulatory_PSN</ConfigurationKey>
			<Label>@SPS1739</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Description</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Description</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DueDateLimitGroupId_ES</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>ES</CountryRegionCodes>
			<ExtendedDataType>DueDateLimitGroupId_ES</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>NumOfDays</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PositiveDays</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>NumOfMonths</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PositiveMonths</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymDayId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymDayId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PaymMethod</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymMethod</ExtendedDataType>
			<EnumType>NetCurrent</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymSched</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymSchedId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymTermId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymTermId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PostOffsettingAR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PostOffsettingAR</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ShipCarrierAncillaryCharge</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ShipCarrierAncillaryCharge</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ShipCarrierCertifiedCheck</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ShipCarrierCertifiedCheck</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UseDeliveryDateForDueDate_ES</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>ES</CountryRegionCodes>
			<ExtendedDataType>UseDeliveryDateForDueDate_ES</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UseEmplAccount_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>CZ,EE,HU,LT,LV,PL,RU</CountryRegionCodes>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@GLS104725</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>VendorUpdateDueDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PaymCalendar</ConfigurationKey>
			<Label>@GLS220360</Label>
			<EnumType>PaymentDueDateUpdatePolicy</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CFMPaymentRequestTypePayment</Name>
			<ExtendedDataType>CFMPaymentRequestTypeRef</ExtendedDataType>
			<Label>@SYS328214</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CFMPaymentRequestTypePrepayment</Name>
			<ExtendedDataType>CFMPaymentRequestTypeRef</ExtendedDataType>
			<Label>@SYS183647</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TermIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>PaymTermId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CashLedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CashLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CashLedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CashLedgerDimension_1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>PaymTerm</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CashLedgerDimension</Name>
					<Field>CashLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PaymDay</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>PaymDay</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymDayId</Name>
					<SourceEDT>PaymDayId</SourceEDT>
					<Field>PaymDayId</Field>
					<RelatedField>PaymDayId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>PaymDayIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PaymDueDateLimit_ES</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>PaymDueDateLimit_ES</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DueDateLimitGroupId_ES</Name>
					<SourceEDT>DueDateLimitGroupId_ES</SourceEDT>
					<Field>DueDateLimitGroupId_ES</Field>
					<RelatedField>GroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DueDateGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PaymSched</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>PaymSched</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymSched</Name>
					<SourceEDT>PaymSchedId</SourceEDT>
					<Field>PaymSched</Field>
					<RelatedField>Name</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>NameIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CFMPaymentRequestTypePayment</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>CFMPaymentRequestType</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Direction</Name>
					<RelatedField>Direction</RelatedField>
					<ValueStr>CFMCashFlowDirection::Outflow</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CFMPaymentRequestTypePayment</Name>
					<Field>CFMPaymentRequestTypePayment</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CFMPaymentRequestTypePrepayment</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>CFMPaymentRequestType</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Direction</Name>
					<RelatedField>Direction</RelatedField>
					<ValueStr>CFMCashFlowDirection::Outflow</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CFMPaymentRequestTypePrepayment</Name>
					<Field>CFMPaymentRequestTypePrepayment</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>