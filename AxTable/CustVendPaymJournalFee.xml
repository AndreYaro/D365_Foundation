<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendPaymJournalFee</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustVendPaymJournalFee extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkJournalAccountControl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs a journal control validation on the current record.
    /// </summary>
    /// <returns>
    ///    true if the journal control validation succeeds; otherwise, false.
    /// </returns>
    public boolean checkJournalAccountControl()
    {
        boolean isValid;
        LedgerJournalNameId journalName;
        LedgerJournalTrans sourceLedgerJournalTrans;

        sourceLedgerJournalTrans = this.sourceLedgerJournalTrans();
        journalName = sourceLedgerJournalTrans.ledgerJournalTable().JournalName;

        isValid = LedgerJournalControlHeader::validate(
            this.company(),
            this.LedgerJournalACType,
            this.LedgerDimension,
            journalName,
            true);

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalTrans</Name>
				<Source><![CDATA[
    public void createLedgerJournalTrans()
    {
        //<GEERU>
        #ISOCountryRegionCodes
        //</GEERU>
        LedgerJournalTrans              ledgerJournalTransSource;
        LedgerJournalTrans              ledgerJournalTransDestin;

        CustPaymFee                     custPaymFee;
        VendPaymFee                     vendPaymFee;

        ExchangeRateHelper              exchangeRateHelper;
        // <GJP>
        systemSequence                  sysSequence;
        boolean                         reserveRecIdForLedgerJournalTrans_JP;
        // </GJP>

        // <GIN>
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN;
        // </GIN>

        // <GJP>
        if (VendPaymFeeUtil_JP::isVendorPaymFeeEnabled()
            && this.Module == ModuleCustVend::Vend
            && this.IsPaymFeeCoveredByVendor_JP
            && this.TaxGroup
            && this.TaxItemGroup)
        {
            reserveRecIdForLedgerJournalTrans_JP = true;
        }
        // </GJP>

        ttsbegin;

        if (this.Module == ModuleCustVend::Cust)
        {
            custPaymFee = CustPaymFee::find(this.FeeId);
        }
        else
        {
            vendPaymFee = VendPaymFee::find(this.FeeId);
        }

        select firstonly ledgerJournalTransSource
            where ledgerJournalTransSource.RecId == this.RefRecId;

        ledgerJournalTransDestin = ledgerJournalTransSource.data();
        ledgerJournalTransDestin.PostingProfile = CustVendNegInstPost::getPostingProfile(
            ledgerJournalTransDestin.ledgerJournalTable().JournalType,
                                                                                         ledgerJournalTransDestin.BankRemittanceType);

        if (ledgerJournalTransDestin.BankAccountId)
        {
            ledgerJournalTransDestin.parmOffsetAccount(ledgerJournalTransDestin.BankAccountId, LedgerJournalACType::Bank);
        }

        if (this.LedgerJournalACType == LedgerJournalACType::Ledger)
        {
            // The fee will be paid by ledger account from current company - need to override what was copied from the source
            ledgerJournalTransDestin.Company = curext();
        }

        ledgerJournalTransDestin.AccountType = this.LedgerJournalACType;
        ledgerJournalTransDestin.LedgerDimension = this.LedgerDimension;

        ledgerJournalTransDestin.DefaultDimension = this.DefaultDimension;
        ledgerJournalTransDestin.FurtherPostingType     = NoYes::No;
        ledgerJournalTransDestin.FurtherPostingRecId    = 0;
        ledgerJournalTransDestin.BankPromissoryNoteNum  = '';
        ledgerJournalTransDestin.PaymentStatus          = CustVendPaymStatus::None;
        ledgerJournalTransDestin.TransactionType        = LedgerTransType::Fee;

        ledgerJournalTransDestin.LineNum = LedgerJournalTrans::lastLineNum(ledgerJournalTransDestin.JournalNum) + 1;

        if (this.Module == ModuleCustVend::Cust)
        {
            ledgerJournalTransDestin.Txt             = (custPaymFee.TransTxt ? custPaymFee.TransTxt : ledgerJournalTransDestin.Txt);
            ledgerJournalTransDestin.AmountCurDebit  = this.FeeValue;
            ledgerJournalTransDestin.AmountCurCredit = 0;
        }
        else
        {
            ledgerJournalTransDestin.Txt             = (vendPaymFee.TransTxt ? vendPaymFee.TransTxt : ledgerJournalTransDestin.Txt);
            ledgerJournalTransDestin.AmountCurDebit  = this.FeeValue;
            ledgerJournalTransDestin.AmountCurCredit = 0;
        }

        if (!ledgerJournalTransDestin.ExchRate || this.FeeCurrency != ledgerJournalTransDestin.CurrencyCode)
        {
            this.updateExchangeRate(ledgerJournalTransDestin);
        }

        ledgerJournalTransDestin.CurrencyCode    = this.FeeCurrency;
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            // we mustn't generate payments (payment order, cheque, etc.)
            // based on payment journal fee, then these field should be cleared !!!
            ledgerJournalTransDestin.BankChequeNum = '';
            ledgerJournalTransDestin.PaymReference = '';
            ledgerJournalTransDestin.PaymMode      = '';
        }
        // </GEERU>
        ledgerJournalTransDestin.TaxGroup        = this.TaxGroup;
        ledgerJournalTransDestin.TaxItemGroup    = this.TaxItemGroup;

        ledgerJournalTransDestin.Invisible       = NoYes::Yes;
        ledgerJournalTransDestin.NoEdit          = NoYes::Yes;

        ledgerJournalTransDestin.SettleVoucher          = SettlementType::None;

        // set TaxDirectionControl to Yes so that tax direction will be properly
        // evaluated and set later
        ledgerJournalTransDestin.TaxDirectionControl = NoYes::Yes;

        // <GJP>
        // Decorate the ledgerJournalTransDestin when vendor covers the fee
        this.updateLdgrJrnTransForVendorCoveredFee_JP(ledgerJournalTransDestin);
        if (reserveRecIdForLedgerJournalTrans_JP)
        {
            // In order to get TaxDirection_JP when calculating tax, we need correct relation between
            // CustVendPaymJournal and LedgerJournalTrans with FeeTransRecId here.
            sysSequence = new systemSequence();
            sysSequence.suspendRecIds(tablenum(LedgerJournalTrans));

            ledgerJournalTransDestin.RecId = sysSequence.reserveValues(1, tablenum(LedgerJournalTrans));

            this.FeeTransRecId = ledgerJournalTransDestin.RecId;
            this.update(true);
        }
        // </GJP>

        ledgerJournalTransDestin.insert();

        // <GJP>
        if (reserveRecIdForLedgerJournalTrans_JP)
        {
            sysSequence.removeRecIdSuspension(tablenum(LedgerJournalTrans));
        }
        // </GJP>
        else
        {
            this.FeeTransRecId = ledgerJournalTransDestin.RecId;
            this.update(true);
        }

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            ledgerJournalTransTaxExtensionIN.TaxModelDocLineExtensionIN::init(ledgerJournalTransDestin);
            ledgerJournalTransTaxExtensionIN.AssessableValueTransactionCurrency = this.FeeValue;
            ledgerJournalTransTaxExtensionIN.insert();
        }
        // </GIN>
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultFromPaymFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs defaulting based on the current payment fee ID.
    /// </summary>
    /// <param name="_sourceLedgerJournalTrans">
    /// The source ledger journal line record.
    /// </param>
    /// <param name="_destinationLedgerjournalTrans">
    /// The destination ledger journal line record; "Optional"
    /// </param>
    public void defaultFromPaymFee(LedgerJournalTrans _sourceLedgerJournalTrans, LedgerJournalTrans _destinationLedgerjournalTrans = _sourceLedgerJournalTrans)
    {
        CustPaymFee     custPaymFee;
        VendPaymFee     vendPaymFee;

        if (this.Module == ModuleCustVend::Cust)
        {
            custPaymFee = CustPaymFee::find(this.FeeId);
            if (custPaymFee.FeePosting == PaymFeePostingCust::Cost)
            {
                this.LedgerJournalACType = LedgerJournalACType::Ledger;
                this.LedgerDimension = _destinationLedgerjournalTrans.getLedgerDimensionForLedgerType(custPaymFee.LedgerDimension, curext());
            }
            else
            {
                this.LedgerJournalACType = LedgerJournalACType::Cust;
                this.LedgerDimension = _sourceLedgerJournalTrans.LedgerDimension;
            }
        }
        else if (this.Module == ModuleCustVend::Vend)
        {
            vendPaymFee = VendPaymFee::find(this.FeeId);
            if (vendPaymFee.FeePosting == PaymFeePostingVend::Cost)
            {
                this.LedgerJournalACType = LedgerJournalACType::Ledger;
                this.LedgerDimension = _destinationLedgerjournalTrans.getLedgerDimensionForLedgerType(vendPaymFee.LedgerDimension, curext());
            }
            else
            {
                this.LedgerJournalACType = LedgerJournalACType::Vend;
                this.LedgerDimension = _sourceLedgerJournalTrans.LedgerDimension;
            }
        }
        else
        {
            Debug::assert(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete(boolean skipTrans = false)
    {
        super();

        if (!skipTrans && this.keepFeeInJournal())
        {
            this.deleteLedgerJournalTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLedgerJournalTrans</Name>
				<Source><![CDATA[
    public void deleteLedgerJournalTrans()
    {
        LedgerJournalTrans              ledgerJournalTransDestin;

        ttsbegin;

        delete_from ledgerJournalTransDestin
            where ledgerJournalTransDestin.RecId == this.FeeTransRecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeJournalFeeVendCovered_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the fee related to vend covered during creation.
    /// </summary>
    /// <param name="_sourceJournalTrans">
    /// The source journal.
    /// </param>
    /// <param name="_vendPaymFee">
    /// The vendor payment fee set up.
    /// </param>
    private void initializeJournalFeeVendCovered_JP(
        LedgerJournalTrans      _sourceJournalTrans,
        VendPaymFee             _vendPaymFee)
    {
        #ISOCountryRegionCodes
        boolean     isPaymFeeCoveredFromVendor;

        //Follow standard logic that vendor account is in account side
        if (VendPaymFeeUtil_JP::isVendorPaymFeeEnabled()
            && _sourceJournalTrans.Company
            && _sourceJournalTrans.AccountType == LedgerJournalACType::Vend
            && _sourceJournalTrans.parmAccount())
        {
            changeCompany(_sourceJournalTrans.Company)
            {
                isPaymFeeCoveredFromVendor = VendTable::find(_sourceJournalTrans.parmAccount()).IsPaymFeeCovered_JP();
            }

            if (isPaymFeeCoveredFromVendor)
            {
                this.IsPaymFeeCoveredByVendor_JP = true;
                this.LedgerJournalACType = LedgerJournalACType::Ledger;
                //Follow standard logic that the ledger dimension is in current company
                if (_vendPaymFee)
                {
                    this.LedgerDimension = _vendPaymFee.VendCoveredFeeLedgerDimension_JP;
                }
            }
            else
            {
                if (this.LedgerJournalACType == LedgerJournalACType::Ledger
                    && _vendPaymFee)
                {
                    //Follow standard logic that the ledger dimension is in current company
                    this.LedgerDimension = _vendPaymFee.LedgerDimension_JP;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerJournalTrans</Name>
				<Source><![CDATA[
    public LedgerJournalTrans initLedgerJournalTrans()
    {
        LedgerJournalTrans  ledgerJournalTransSource;
        LedgerJournalTrans  ledgerJournalTransDestin;
        CustPaymFee         custPaymFee;
        VendPaymFee         vendPaymFee;

        if (this.Module == ModuleCustVend::Cust)
        {
            custPaymFee = CustPaymFee::find(this.FeeId);
        }
        else
        {
            vendPaymFee = VendPaymFee::find(this.FeeId);
        }

        select firstonly ledgerJournalTransSource
            where ledgerJournalTransSource.RecId == this.RefRecId;

        ledgerJournalTransDestin = ledgerJournalTransSource.data();
        ledgerJournalTransDestin.PostingProfile = CustVendNegInstPost::getPostingProfile(
            ledgerJournalTransDestin.ledgerJournalTable().JournalType,
                                                                                         ledgerJournalTransDestin.BankRemittanceType);

        if (ledgerJournalTransDestin.BankAccountId)
        {
            ledgerJournalTransDestin.parmOffsetAccount(ledgerJournalTransDestin.BankAccountId, LedgerJournalACType::Bank);
        }
        ledgerJournalTransDestin.AccountType = this.LedgerJournalACType;
        ledgerJournalTransDestin.LedgerDimension = this.LedgerDimension;

        ledgerJournalTransDestin.DefaultDimension = this.DefaultDimension;
        ledgerJournalTransDestin.FurtherPostingType     = NoYes::No;
        ledgerJournalTransDestin.FurtherPostingRecId    = 0;
        ledgerJournalTransDestin.BankPromissoryNoteNum  = '';
        ledgerJournalTransDestin.PaymentStatus          = CustVendPaymStatus::None;

        if (this.Module == ModuleCustVend::Cust)
        {
            ledgerJournalTransDestin.Txt                = (custPaymFee.TransTxt ? custPaymFee.TransTxt : ledgerJournalTransDestin.Txt);
            ledgerJournalTransDestin.AmountCurDebit     = this.FeeValue;
            ledgerJournalTransDestin.AmountCurCredit    = 0;
        }
        else
        {
            ledgerJournalTransDestin.Txt                = (vendPaymFee.TransTxt ? vendPaymFee.TransTxt : ledgerJournalTransDestin.Txt);
            ledgerJournalTransDestin.AmountCurDebit     = 0;
            ledgerJournalTransDestin.AmountCurCredit    = this.FeeValue;
        }

        if (!ledgerJournalTransDestin.ExchRate || ledgerJournalTransDestin.CurrencyCode != this.FeeCurrency)
        {
            this.updateExchangeRate(ledgerJournalTransDestin);
        }

        ledgerJournalTransDestin.CurrencyCode           = this.FeeCurrency;
        ledgerJournalTransDestin.TaxGroup               = this.TaxGroup;
        ledgerJournalTransDestin.TaxItemGroup           = this.TaxItemGroup;
        ledgerJournalTransDestin.SettleVoucher          = SettlementType::None;

        return ledgerJournalTransDestin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValueForVendorCovered_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes value for field related to vendor covered.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The payment line.
    /// </param>
    public void initValueForVendorCovered_JP(LedgerJournalTrans _ledgerJournalTrans)
    {
        this.initializeJournalFeeVendCovered_JP(
            _ledgerJournalTrans,
            null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert(boolean skipTrans = false)
    {
        LedgerJournalTrans ledgerJournalTransSource = this.sourceLedgerJournalTrans();

        ttsbegin;

        if (this.LedgerJournalACType == LedgerJournalACType::Ledger)
        {
            // When account type is ledger the default dimension should be 0
            Debug::assert(this.DefaultDimension == 0);
            this.DefaultDimension = 0;
        }
        // Else account type not ledger
        else
        {
            // If the payment fee company is the same as the ledgerJournalTrans.Company then sync with the
            // LedgerJournalTrans.DefaultDimension.
            // If the payment fee company is different than the LedgerJournalTrans.Company the payment fee dimension will be empty
            if (!this.DefaultDimension
                && this.isCompanyEqualToLedgerJournalTransCompany(ledgerJournalTransSource))
            {
                this.DefaultDimension = ledgerJournalTransSource.DefaultDimension;
            }
        }

        super();

        if (!skipTrans && this.keepFeeInJournal())
        {
            this.createLedgerJournalTrans();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>keepFeeInJournal</Name>
				<Source><![CDATA[
    private boolean keepFeeInJournal()
    {
        LedgerJournalTrans  ledgerJournalTrans;
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalName   ledgerJournalName;

        select firstonly JournalNum from ledgerJournalTrans
        join firstonly JournalName from ledgerJournalTable
            where ledgerJournalTable.JournalNum == ledgerJournalTrans.JournalNum
        join firstonly LedgerJournalFeePosting from ledgerJournalName
            where ledgerJournalName.JournalName == ledgerJournalTable.JournalName;

        return ledgerJournalName.LedgerJournalFeePosting == LedgerJournalFeePosting::Keep;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the field.
    /// </summary>
    /// <param name="_fieldId">
    /// The field ID.
    /// </param>
    public void modifiedField(fieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldnum(CustVendPaymJournalFee, FeeId):
                this.defaultFromPaymFee(this.sourceLedgerJournalTrans());
                break;

            // <GJP>
            case fieldnum(CustVendPaymJournalFee, IsPaymFeeCoveredByVendor_JP):
                // Reset TaxDirection_JP to default value Incoming tax whenever user changes the value of paymFeeCoveredByVendor.
                this.TaxDirection_JP = VendPaymFeeTaxDirection_JP::IncomingTax;
                break;
           // </GJP>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendAccount</Name>
				<Source><![CDATA[
    public LedgerJournalAC parmCustVendAccount(
        LedgerJournalAC _account = '',
        LedgerJournalACType _accountType = this.LedgerJournalACType)
    {
        DimensionAttributeValueCombination  ledgerDimension;
        LedgerJournalAC                     account;

        if (!prmisDefault(_accountType))
        {
            this.LedgerJournalACType = _accountType;
        }

        // If account has been changed, update the backing ledger dimension value
        if (!prmisDefault(_account))
        {
            if (_account)
            {
                this.LedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_account, _accountType);
                account = _account;
            }
            else
            {
                account = '';
                this.LedgerDimension = 0;
            }
        }
        else if (this.LedgerDimension)
        {
            // If the account has not been changed, then pull the value from ledger dimension as the master
            select firstonly DisplayValue from ledgerDimension
                where ledgerDimension.RecId == this.LedgerDimension;

            account = ledgerDimension.DisplayValue;
        }

        return account;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimension</Name>
				<Source><![CDATA[
    public DimensionDynamicAccount parmLedgerDimension(DimensionDynamicAccount _ledgerDimension = this.LedgerDimension)
    {
        this.LedgerDimension = _ledgerDimension;
        return this.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the source <c>LedgerJournalTrans</c> record for the current <c>CustVendPaymJournalFee</c> record.
    /// </summary>
    /// <returns>
    /// The source <c>LedgerJournalTrans</c> record.
    /// </returns>
    public LedgerJournalTrans sourceLedgerJournalTrans()
    {
        return LedgerJournalTrans::findRecId(this.RefRecId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCompanyEqualToLedgerJournalTransCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>CustVendPaymJournalFee</c> table record company is equal to the
    /// given <c>LedgerJournalTrans</c> table record company.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> table record to check against.</param>
    /// <returns>true if the companies are equal; otherwise, false.</returns>
    public boolean isCompanyEqualToLedgerJournalTransCompany(LedgerJournalTrans _ledgerJournalTrans)
    {
        return this.company() == _ledgerJournalTrans.Company;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update(boolean skipTrans = false)
    {
        LedgerJournalTrans ledgerJournalTransSource = this.sourceLedgerJournalTrans();

        ttsbegin;

        if (this.LedgerJournalACType == LedgerJournalACType::Ledger)
        {
            // When account type is ledger the default dimension should be 0
            this.DefaultDimension = 0;
        }
        // Else account type not ledger
        else
        {
            if ((this.orig().LedgerDimension != this.LedgerDimension
                && this.orig().LedgerJournalACType == LedgerJournalACType::Ledger)
                || this.isCompanyEqualToLedgerJournalTransCompany(ledgerJournalTransSource))
            {
                this.DefaultDimension = ledgerJournalTransSource.DefaultDimension;
            }
        }

        super();

        if (!skipTrans && this.keepFeeInJournal())
        {
            TransTaxInformation transTaxInformationOld;
            boolean shouldCopyOldTaxInfo = TaxIntegrationUtils::isTaxInformationEnabled();
            if (shouldCopyOldTaxInfo)
            {
                // Current <c>LedgerJournalTrans</c> is not the expected record, thus, system will delete it and create a new one.
                // However, it will delete the tax information so the tax information buffer should be saved before delete.
                LedgerJournalTrans ledgerJournalTransFeeOld = LedgerJournalTrans::findRecId(this.feeTransRecId, false);
                
                if (ledgerJournalTransFeeOld)
                {
                    transTaxInformationOld = TransTaxInformationHelper::newHelper().findTransTaxInformation(
                        tableNum(LedgerJournalTrans),
                        ledgerJournalTransFeeOld.RecId);
                }
            }

            this.deleteLedgerJournalTrans();
            this.createLedgerJournalTrans();

            if (shouldCopyOldTaxInfo)
            {
                // Creates new tax information for the new <c>LedgerJournalTrans</c>. 
                // And updates its field values with the saved tax information buffer.
                LedgerJournalTrans ledgerJournalTransFeeNew = LedgerJournalTrans::findRecId(this.feeTransRecId, false);
                if (transTaxInformationOld && ledgerJournalTransFeeNew)
                {
                    TransTaxInformationHelper::createTransTaxInformationByOldTransTaxInfo(ledgerJournalTransFeeNew, transTaxInformationOld);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLdgrJrnTransForVendorCoveredFee_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the ledger journal line from the vendor covered payment fee.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal line.
    /// </param>
    private void updateLdgrJrnTransForVendorCoveredFee_JP(LedgerJournalTrans _ledgerJournalTrans)
    {
        AmountCur feeGrossAmount;

        if (VendPaymFeeUtil_JP::isVendorPaymFeeEnabled()
            && this.Module == ModuleCustVend::Vend
            && this.IsPaymFeeCoveredByVendor_JP)
        {
            //calculate gross amount
            feeGrossAmount = this.FeeValue;

            if ((_ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Bank)
                || (this.LedgerJournalACType != LedgerJournalACType::Ledger))
            {
                if (_ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax == NoYes::No
                    && this.TaxGroup
                    && this.TaxItemGroup)
                {
                    feeGrossAmount += Tax::calcTaxAmount(
                        this.TaxGroup,
                        this.TaxItemGroup,
                        //follow standard logic of searching fee to use journal line date
                        _ledgerJournalTrans.TransDate,
                        this.FeeCurrency,
                        this.FeeValue,
                        TaxModuleType::Voucher);
                }

                // No tax applied
                _ledgerJournalTrans.TaxGroup = "";
                _ledgerJournalTrans.TaxItemGroup = "";
            }

            //Follow the standard logic that bank account is at the offset side
            _ledgerJournalTrans.AmountCurDebit  = 0;
            _ledgerJournalTrans.AmountCurCredit = feeGrossAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(fieldId _fieldIdToCheck)
    {
        boolean isValid;

        isValid = super(_fieldIdToCheck);

        if (isValid)
        {
            switch (_fieldIdToCheck)
            {
                case fieldNum(CustVendPaymJournalFee, LedgerDimension):
                    if (this.LedgerDimension != 0)
                    {
                        switch (this.LedgerJournalACType)
                        {
                            // Check for existence of Customer or Vendor record - need to use specific message to
                            // mimic auto-validation message used by Relation validation.
                            case LedgerJournalACType::Cust:
                                if (!CustTable::exist(this.parmCustVendAccount()))
                                {
                                    isValid = checkFailed(strFmt("@SYS112224",
                                                this.parmCustVendAccount(),
                                                fieldId2pname(tableNum(CustVendPaymJournalFee), fieldNum(CustVendPaymJournalFee,LedgerDimension)),
                                                tableId2pname(tableNum(CustTable))));
                                }
                                break;

                            case LedgerJournalACType::Vend:
                                if (!VendTable::exist(this.parmCustVendAccount()))
                                {
                                    isValid = checkFailed(strFmt("@SYS112224",
                                                this.parmCustVendAccount(),
                                                fieldId2pname(tableNum(CustVendPaymJournalFee), fieldNum(CustVendPaymJournalFee,LedgerDimension)),
                                                tableId2pname(tableNum(VendTable))));
                                }
                                break;

                            default:
                                // Other types are covered by relation validation or not selectable.
                                break;
                        }
                    }

                    break;
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean isValid = super();

        if (isValid)
        {
            isValid = this.checkJournalAccountControl();
        }

        if (isValid)
        {
            isValid = this.checkAccountType();
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountType</Name>
				<Source><![CDATA[
    private boolean checkAccountType()
    {
        boolean isValid = true;

        switch (this.Module)
        {
            case ModuleCustVend::Cust:
                if (this.LedgerJournalACType != LedgerJournalACType::Cust
                    && this.LedgerJournalACType != LedgerJournalACType::Ledger)
                {
                    isValid = checkFailed("@CashManagement:CustPaymJournalFeeAccountTypeValidation");
                }
                break;

            case ModuleCustVend::Vend:
                if (this.LedgerJournalACType != LedgerJournalACType::Vend
                    && this.LedgerJournalACType != LedgerJournalACType::Ledger)
                {
                    isValid = checkFailed("@CashManagement:VendPaymJournalFeeAccountTypeValidation");
                }
                break;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalFee</Name>
				<Source><![CDATA[
    public static void createJournalFee(
        ModuleCustVend _module,
        LedgerJournalTrans  destinJournalTrans,
        LedgerJournalTrans  sourceJournalTrans = destinJournalTrans)
    {
        CustVendPaymJournalFee  custVendPaymJournalFee;
        CustVendPaymModeFeeMap  custVendPaymModeFee;
        CustPaymFee             custPaymFee;
        VendPaymFee             vendPaymFee;
        PaymFee                 paymFee;
        List                    listPaymModeFee;
        ListEnumerator          listEnumPaymModeFee;

        #isoCountryRegionCodes
        boolean                 isJPN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP]);

        if (!destinJournalTrans || !sourceJournalTrans.PaymMode)
        {
            return;
        }

        // don't delete and recreate payment fees.
        if (!CustVendPaymJournalFee::shouldDeleteJournalFee(destinJournalTrans))
        {
            return;
        }

        ttsbegin;

        CustVendPaymJournalFee::deleteJournalFee(destinJournalTrans);

        custVendPaymModeFee.initFromModule(_module);

        paymFee = PaymFee::newFromLedgerJournalTrans_OffsetAccount(_module, sourceJournalTrans);
        listPaymModeFee = paymFee.findFees();

        listEnumPaymModeFee = listPaymModeFee.getEnumerator();

        while (listEnumPaymModeFee.moveNext())
        {
            custVendPaymModeFee = listEnumPaymModeFee.current();

            custVendPaymJournalFee.clear();
            custVendPaymJournalFee.initValue();
            custVendPaymJournalFee.Module       = _module;
            custVendPaymJournalFee.RefRecId     = destinJournalTrans.RecId;
            custVendPaymJournalFee.FeeId        = custVendPaymModeFee.PaymFeeId;
            custVendPaymJournalFee.FeeCurrency  = custVendPaymModeFee.FeeCurrency ? custVendPaymModeFee.FeeCurrency : sourceJournalTrans.CurrencyCode;

            custVendPaymJournalFee.FeeValue = custVendPaymModeFee.calcFeeValue(
                custVendPaymJournalFee.FeeCurrency,
                sourceJournalTrans.CurrencyCode,
                sourceJournalTrans.amount(),
                sourceJournalTrans.TransDate,
                sourceJournalTrans.Due);

            if (custVendPaymJournalFee.FeeValue == 0)
            {
                continue;
            }

            custVendPaymJournalFee.TaxGroup     = custVendPaymModeFee.TaxGroup;
            custVendPaymJournalFee.TaxItemGroup = custVendPaymModeFee.TaxItemGroup;

            if (isJPN && _module == ModuleCustVend::Vend)
            {
                custVendPaymJournalFee.TaxDirection_JP = custVendPaymModeFee.TaxDirection_JP;
            }

            custVendPaymJournalFee.defaultFromPaymFee(sourceJournalTrans, destinJournalTrans);

            if (_module == ModuleCustVend::Cust)
            {
                custPaymFee = CustPaymFee::find(custVendPaymModeFee.PaymFeeId);

                if (custPaymFee.FeePosting == PaymFeePostingCust::Cost)
                {
                    // Type is ledger, need to merge the default ledger dimension (from CustPayFee)
                    // with default dimensions.
                    custVendPaymJournalFee.LedgerJournalACType = LedgerJournalACType::Ledger;
                    custVendPaymJournalFee.LedgerDimension = destinJournalTrans.getLedgerDimensionForLedgerType(
                        custPaymFee.LedgerDimension,
                        curext());
                }
                else
                {
                    custVendPaymJournalFee.parmCustVendAccount(sourceJournalTrans.parmAccount(), LedgerJournalACType::Cust);
                }
            }
            else
            {
                vendPaymFee = VendPaymFee::find(custVendPaymModeFee.PaymFeeId);

                if (vendPaymFee.FeePosting == PaymFeePostingVend::Cost)
                {
                    // Type is ledger, need to merge the default ledger dimension (from CustPayFee)
                    // with default dimensions.
                    custVendPaymJournalFee.LedgerJournalACType = LedgerJournalACType::Ledger;
                    custVendPaymJournalFee.LedgerDimension = destinJournalTrans.getLedgerDimensionForLedgerType(
                        vendPaymFee.LedgerDimension,
                        curext());
                }
                else
                {
                    custVendPaymJournalFee.parmCustVendAccount(sourceJournalTrans.parmAccount(), LedgerJournalACType::Vend);
                }

                custVendPaymJournalFee.initializeJournalFeeVendCovered_JP(
                    sourceJournalTrans,
                    vendPaymFee);
            }

            custVendPaymJournalFee.insert();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDeleteJournalFee</Name>
				<Source><![CDATA[
    internal static boolean shouldDeleteJournalFee(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean shouldDeleteJournalFee = true;

        if (_ledgerJournalTrans.isFormDataSource() && CustVendPaymJournalFee::existRefRecId(_ledgerJournalTrans.RecId))
        {
            DialogButton answer = Box::yesNo("@AccountsReceivable:TaskNotification_DeletePaymentFee", DialogButton::No);

            if (answer == DialogButton::No)
            {
                shouldDeleteJournalFee = false;
            }
        }

        return shouldDeleteJournalFee;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalFee_tmp</Name>
				<Source><![CDATA[
    public static void createJournalFee_tmp(
        ModuleCustVend _module,
        CustVendPaymJournalFee _custVendPaymJournalFee,
        BankAccountID _bankAccountID,
        PaymMode _paymMode,
        PaymSpec _paymSpec,
        CurrencyCode _paymCurrency,
        AmountCur _paymAmountCur,
        TransDate _paymDate,
        BankRemittanceType _bankRemittanceType,
        LedgerJournalType _journalType,
        DueDate _dueDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        CustVendPaymModeFeeMap  custVendPaymModeFee;
        PaymFee                 paymFee;
        List                    listPaymModeFee;
        ListEnumerator          listEnumPaymModeFee;

        #isoCountryRegionCodes
        boolean                 isJPN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP]);

        if (!_custVendPaymJournalFee.isTmp())
        {
            return;
        }

        ttsbegin;

        _custVendPaymJournalFee.skipDataMethods(true);

        delete_from _custVendPaymJournalFee
            where _custVendPaymJournalFee.RefRecId == 0;

        custVendPaymModeFee.initFromModule(_module);

        paymFee = new PaymFee(
            _module,
            _bankAccountID,
            _paymMode,
            _paymSpec,
            _paymCurrency,
            _paymAmountCur,
            _paymDate,
            _bankRemittanceType,
            _journalType);

        listPaymModeFee = paymFee.findFees();

        listEnumPaymModeFee = listPaymModeFee.getEnumerator();

        while (listEnumPaymModeFee.moveNext())
        {
            custVendPaymModeFee = listEnumPaymModeFee.current();

            _custVendPaymJournalFee.clear();
            _custVendPaymJournalFee.initValue();
            _custVendPaymJournalFee.Module = ModuleCustVend::Cust;
            _custVendPaymJournalFee.RefRecId = 0;
            _custVendPaymJournalFee.FeeId = custVendPaymModeFee.PaymFeeId;
            _custVendPaymJournalFee.FeeCurrency = custVendPaymModeFee.FeeCurrency ? custVendPaymModeFee.FeeCurrency : _paymCurrency;

            _custVendPaymJournalFee.FeeValue = custVendPaymModeFee.calcFeeValue(
                _custVendPaymJournalFee.FeeCurrency,
                _paymCurrency,
                _paymAmountCur,
                _paymDate,
                _dueDate);

            _custVendPaymJournalFee.TaxGroup = custVendPaymModeFee.TaxGroup;
            _custVendPaymJournalFee.TaxItemGroup = custVendPaymModeFee.TaxItemGroup;

            if (isJPN && _module == ModuleCustVend::Vend)
            {
                _custVendPaymJournalFee.TaxDirection_JP = custVendPaymModeFee.TaxDirection_JP;
            }

            _custVendPaymJournalFee.insert(true);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalFeeCust</Name>
				<Source><![CDATA[
    public static void createJournalFeeCust(
        LedgerJournalTrans _destinJournalTrans,
        LedgerJournalTrans _sourceJournalTrans = _destinJournalTrans)
    {
        CustVendPaymJournalFee::createJournalFee(ModuleCustVend::Cust, _destinJournalTrans, _sourceJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalFeeVend</Name>
				<Source><![CDATA[
    public static void createJournalFeeVend(
        LedgerJournalTrans _destinJournalTrans,
        LedgerJournalTrans _sourceJournalTrans = _destinJournalTrans)
    {
        CustVendPaymJournalFee::createJournalFee(ModuleCustVend::Vend, _destinJournalTrans, _sourceJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteJournalFee</Name>
				<Source><![CDATA[
    public static void deleteJournalFee(LedgerJournalTrans _destinJournalTrans)
    {
        CustVendPaymJournalFee  custVendPaymJournalFee;

        ttsbegin;

        delete_from custVendPaymJournalFee
            where custVendPaymJournalFee.RefRecId == _destinJournalTrans.RecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existRefRecId</Name>
				<Source><![CDATA[
    public static boolean existRefRecId(recId _refRecId)
    {
        return _refRecId
            && (select firstonly custVendPaymJournalFee index hint RefIdx
                where custVendPaymJournalFee.RefRecId == _refRecId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existVendorCoveredFee_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether exists bank fee covered by vendor.
    /// </summary>
    /// <param name="_recIdPaymLine">
    /// rec id of related ledger journal payment line.
    /// </param>
    /// <returns>
    /// True if found; otherwise, false.
    /// </returns>
    public static boolean existVendorCoveredFee_JP(recId _recIdPaymLine)
    {
        CustVendPaymJournalFee custVendPaymJournalFee;
        select firstonly RecId from custVendPaymJournalFee
            where   custVendPaymJournalFee.RefRecId == _recIdPaymLine
                &&  custVendPaymJournalFee.IsPaymFeeCoveredByVendor_JP == true;

        return custVendPaymJournalFee.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalPaymFeeTotalInAccountingCur_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the journal total payment fee amount in accounting currency.
    /// </summary>
    /// <param name="_journalNum">
    /// The journal number.
    /// </param>
    /// <param name="_isCoveredByVendor">
    /// Whether the fee is covered by vendor.
    /// </param>
    /// <returns>
    /// The total payment fee amount in accounting currency.
    /// </returns>
    public static AmountCur getJournalPaymFeeTotalInAccountingCur_JP(
        LedgerJournalId     _journalNum,
        boolean             _isCoveredByVendor)
    {
        LedgerJournalTrans  ledgerJournalTrans;
        Amount              totalAmount;

        while select RecId, CurrencyCode, TransDate from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _journalNum
        {
            totalAmount += CurrencyExchangeHelper::amountCur2MST(CustVendPaymJournalFee::getPaymFeeTotalInTransactionCurrency_JP(ledgerJournalTrans.RecId, _isCoveredByVendor), ledgerJournalTrans.CurrencyCode, 0, ledgerJournalTrans.TransDate);
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymFeeTotalInTransactionCurrency_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the payment fee total.
    /// </summary>
    /// <param name="_paymentLineRecId">
    /// rec id of the payment line.
    /// </param>
    /// <param name="_isCoveredByVendor">
    /// Whether the fee is covered by vendor.
    /// </param>
    /// <returns>
    /// The payment fee total amount in payment currency.
    /// </returns>
    public static AmountCur getPaymFeeTotalInTransactionCurrency_JP(
        RefRecId    _paymentLineRecId,
        boolean     _isCoveredByVendor)
    {
        Amount                  totalAmount;
        Amount                  taxAmount;
        LedgerJournalTrans      ledgerJournalTransPaymFee;
        LedgerJournalTrans      ledgerJournalTransPayment;
        CustVendPaymJournalFee  paymJournalFee;

        ledgerJournalTransPayment = LedgerJournalTrans::findRecId(_paymentLineRecId, false);

        while select ledgerJournalTransPaymFee
            join TaxGroup, TaxItemGroup, FeeCurrency, FeeValue, LedgerJournalACType
            from paymJournalFee
            where   paymJournalFee.RefRecId == _paymentLineRecId
                &&  paymJournalFee.IsPaymFeeCoveredByVendor_JP == _isCoveredByVendor
                &&  paymJournalFee.feeTransRecId == ledgerJournalTransPaymFee.RecId
        {
            if (ledgerJournalTransPaymFee.ledgerJournalTable().LedgerJournalInclTax == NoYes::No
                && paymJournalFee.TaxGroup
                && paymJournalFee.TaxItemGroup
                && paymJournalFee.LedgerJournalACType == LedgerJournalACType::Ledger)
            {
                taxAmount = Tax::calcTaxAmount(
                    paymJournalFee.TaxGroup,
                    paymJournalFee.TaxItemGroup,
                    //follow standard logic of searching fee to use journal line date
                    ledgerJournalTransPaymFee.TransDate,
                    paymJournalFee.FeeCurrency,
                    paymJournalFee.FeeValue,
                    TaxModuleType::Voucher);
            }
            else
            {
                taxAmount = 0;
            }

            //to payment line currency
            //company fee in debit side, while vendor fee in credit side
            totalAmount += CurrencyExchangeHelper::curAmount2CurAmount(abs(ledgerJournalTransPaymFee.AmountCurDebit - taxAmount - ledgerJournalTransPaymFee.AmountCurCredit), ledgerJournalTransPaymFee.CurrencyCode, ledgerJournalTransPayment.CurrencyCode, ledgerJournalTransPaymFee.TransDate);
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFromVoucherTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the <c>CustVendPaymJournalFee</c> records from a voucher template to a new voucher template.
    /// </summary>
    /// <param name = "_sourceVoucher">The record ID of the source voucher template.</param>
    /// <param name = "_destinationVoucher">The record ID of the new voucher template.</param>
    public static void copyFromVoucherTemplate(LedgerJournalTransRefRecId _sourceVoucher, LedgerJournalTransRefRecId _destinationVoucher)
    {
        CustVendPaymJournalFee source, destination;

        insert_recordset destination
          ( DefaultDimension,
            FeeCurrency,
            FeeId,
            feeTransRecId,
            FeeValue,
            IsPaymFeeCoveredByVendor_JP,
            LedgerDimension,
            LedgerJournalACType,
            Module,
            TaxDirection_JP,
            TaxGroup,
            TaxItemGroup,
            RefRecId)
        select
            DefaultDimension,
            FeeCurrency,
            FeeId,
            feeTransRecId,
            FeeValue,
            IsPaymFeeCoveredByVendor_JP,
            LedgerDimension,
            LedgerJournalACType,
            Module,
            TaxDirection_JP,
            TaxGroup,
            TaxItemGroup,
            _destinationVoucher
        from source
            where source.RefRecId == _sourceVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExchangeRate</Name>
				<Source><![CDATA[
    private void updateExchangeRate(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerRecId ledgerRecIdLocal = Ledger::primaryLedger(CompanyInfo::findDataArea(_ledgerJournalTrans.company()).RecId);

        _ledgerJournalTrans.ExchRate = ExchangeRateHelper::getExchangeRate1_Static(ledgerRecIdLocal, this.FeeCurrency, _ledgerJournalTrans.TransDate);
        _ledgerJournalTrans.ExchRateSecond = ExchangeRateHelper::getExchangeRate2_Static(ledgerRecIdLocal, this.FeeCurrency, _ledgerJournalTrans.TransDate);

        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(ledgerRecIdLocal, this.FeeCurrency, _ledgerJournalTrans.TransDate);
        exchangeRateHelper.parmToCurrency(Ledger::reportingCurrency());
        exchangeRateHelper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());
        _ledgerJournalTrans.ReportingCurrencyExchRate = exchangeRateHelper.getExchangeRate1();
        _ledgerJournalTrans.ReportingCurrencyExchRateSecondary = exchangeRateHelper.getExchangeRate2();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankDepositVoucherForPaymentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the journal fee lines.
    /// </summary>
    /// <param name = "_ledgerJournalTransRecID">The record ID of the source journal line.</param>
    /// <param name = "_bankDepositVoucher">The BankDepositVoucher value.</param>
    internal static void updateBankDepositVoucherForPaymentLine(RefRecId _ledgerJournalTransRecID, BankDepositVoucher _bankDepositVoucher)
    {
        CustVendPaymJournalFee custVendPaymJournalFeeLoc;
        LedgerJournalTrans ledgerJournaltransPaymentFee;

        ttsbegin;

        update_recordset  ledgerJournaltransPaymentFee
            setting BankDepositVoucher = _bankDepositVoucher
            join custVendPaymJournalFeeLoc
                where custVendPaymJournalFeeLoc.refRecID == _ledgerJournalTransRecID
                && ledgerJournaltransPaymentFee.recid == custVendPaymJournalFeeLoc.FeeTransRecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymFeeListToUpdate</Name>
				<Source><![CDATA[
    internal static List getPaymFeeListToUpdate(RefRecId _refRecId, CurrencyCode _currencyCode)
    {
        List recIdList = new List(Types::Int64);
        CustVendPaymJournalFee custVendPaymJournalFee;
        while select feeTransRecId from custVendPaymJournalFee
            where custVendPaymJournalFee.RefRecId == _refRecId
                && custVendPaymJournalFee.FeeCurrency == _currencyCode
        {
            recIdList.addEnd(custVendPaymJournalFee.feeTransRecId);
        }
        return recIdList;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasic</ConfigurationKey>
	<DeveloperDocumentation>@SYS126110</DeveloperDocumentation>
	<Label>@SYS72941</Label>
	<TableGroup>WorksheetLine</TableGroup>
	<TitleField1>Module</TitleField1>
	<TitleField2>FeeId</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>RefIdx</ClusteredIndex>
	<CreateRecIdIndex>No</CreateRecIdIndex>
	<Modules>Bank</Modules>
	<PrimaryIndex>RefIdx</PrimaryIndex>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FeeId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FeeValue</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FeeCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Module</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CustomerVendor</Name>
			<Label>@SYS22898</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Module</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerJournalACType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RefRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FeeId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>feeTransRecId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PaymFee_JP</Name>
			<Label>@SYS4003236</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IsPaymFeeCoveredByVendor_JP</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTax</Name>
			<Label>@SYS5878</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxDirection_JP</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Value</Name>
			<Label>@SYS71361</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FeeValue</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FeeCurrency</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>RefRecId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>LedgerJournalTransRefRecId</ExtendedDataType>
			<Label>@SYS22514</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDefault</ExtendedDataType>
			<Visible>No</Visible>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>FeeCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>FeeId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustVendPaymFeeId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>feeTransRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>LedgerJournalTransRefRecId</ExtendedDataType>
			<Label>@SYS72938</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>FeeValue</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymFeeValue</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsPaymFeeCoveredByVendor_JP</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VendPaymFeeCovered_JP</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDynamicAccount</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LedgerJournalACType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>LedgerJournalACType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Module</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ModuleCustVend</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxDirection_JP</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>VendPaymFeeTaxDirection_JP</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxGroup</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxItemGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxItemGroup</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>RefIdx</Name>
			<Fields>
				<AxTableIndexField>
					<DataField>RefRecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>FeeId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>FK_DimensionAttributeValueCombination_Cu</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>LedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueSetIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>DefaultDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>FeeTransRecId</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>feeTransRecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FeeCurrency</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>FeeCurrency</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustPaymFee</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125083</EntityRelationshipRole>
			<RelatedTable>CustPaymFee</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustPaymFee</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>CustVendPaymJournalFee</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Module</Name>
					<Field>Module</Field>
					<ValueStr>ModuleCustVend::Cust</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FeeId</Name>
					<Field>FeeId</Field>
					<RelatedField>FeeId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DefaultDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CustVendPaymJournalFee</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CustVendPaymJournalFee</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimension</Name>
					<Field>LedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LedgerJournalTrans</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS126111</EntityRelationshipRole>
			<RelatedTable>LedgerJournalTrans</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalTrans</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>CustVendPaymJournalFee</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefRecId</Name>
					<SourceEDT>LedgerJournalTransRefRecId</SourceEDT>
					<Field>RefRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalTrans_feeTransRecId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalTrans_feeTransRecId</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>feeTransRecId</Name>
					<SourceEDT>LedgerJournalTransRefRecId</SourceEDT>
					<Field>feeTransRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxGroup</Name>
					<SourceEDT>TaxGroup</SourceEDT>
					<Field>TaxGroup</Field>
					<RelatedField>TaxGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxItemGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxItemGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxItemGroup</Name>
					<SourceEDT>TaxItemGroup</SourceEDT>
					<Field>TaxItemGroup</Field>
					<RelatedField>TaxItemGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxItemGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendPaymFee</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS126112</EntityRelationshipRole>
			<RelatedTable>VendPaymFee</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendPaymFee</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>CustVendPaymJournalFee</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Module</Name>
					<Field>Module</Field>
					<ValueStr>ModuleCustVend::Vend</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FeeId</Name>
					<Field>FeeId</Field>
					<RelatedField>FeeId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>