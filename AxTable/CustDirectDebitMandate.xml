<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustDirectDebitMandate</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustDirectDebitMandate extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>findByCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds a <c>CustDirectDebitMandate</c> record in the given company.
    /// </summary>
    /// <param name="_companyId">
    ///    The company in which to look for the record.
    /// </param>
    /// <param name="_custAccount">
    ///    The customer account ID.
    /// </param>
    /// <param name="_forupdate">
    ///    Determines whether the returned <c>CustBankAccount</c> record is selected for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    ///    The concurrency model to use; optional.
    /// </param>
    /// <returns>
    ///    Returns the <c>CustDirectDebitMandate</c> record, if found.
    /// </returns>
    public static CustDirectDebitMandate findByCompany(
        CompanyId _companyId,
        RecId _recId,
        boolean _forupdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        CustDirectDebitMandate mandate;

        changecompany (_companyId)
        {
            mandate = CustDirectDebitMandate::find(_recId,  _forupdate, _concurrencyModel);
        }

        return mandate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreviousExpirationDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find previous ExpirationDate of the mandate
    /// </summary>
    /// <returns>Previous ExpirationDate if it exists, otherwise current ExpirationDate</returns>
    public ExpirationDate getPreviousExpirationDate()
    {
        if (CustDirectDebitMandateAvoidFindingPreviousDateFromDBLogFlight::instance().isEnabled())
        {
            return this.PreviousExpirationDate ? this.PreviousExpirationDate : this.ExpirationDate;
        }
        else
        {
            return this.getPreviousExpirationDateFromDBLog();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreviousExpirationDateFromDBLog</Name>
				<Source><![CDATA[
    private ExpirationDate getPreviousExpirationDateFromDBLog()
    {
        SysDataBaseLog mandateLog;

        while select mandateLog
            order by CreatedDateTime desc
            where mandateLog.table == this.TableId
                && mandateLog.LogRecId == this.RecId
        {
            ListEnumerator dataEnum = mandateLog.getDataAslist().getEnumerator();
            while (dataEnum.moveNext())
            {
                container logContainer = dataEnum.current();
                if (conLen(logContainer) == 3 && conPeek(logContainer, 1) == fieldNum(CustDirectDebitMandate, ExpirationDate))
                {
                    ExpirationDate expDate = conPeek(logContainer, 3);
                    return expDate ? expDate : this.ExpirationDate;
                }
            }
        }

        return this.ExpirationDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateExpirationDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the expiration date of the mandate based on the payment date provided.
    /// </summary>
    /// <param name="_paymentDate">
    /// The payment date of the invoice.
    /// </param>
    /// <returns>
    /// The expiration date of the mandate based on the payment date provided.
    /// </returns>
    public ExpirationDate calculateExpirationDate(TransDate _paymentDate)
    {
        ExpirationDate newExpirationDate = _paymentDate;

        if (this.MandatePaymentType == CustMandatePaymentType::Recurring)
        {
            // The -1 is necessary since the mandate should be valid on the actual day of expiration.
            newExpirationDate = dateMthFwd(newExpirationDate, CustParameters::find().MandateDefaultExpirationMonths) - 1;
        }

        if (newExpirationDate < this.ExpirationDate || newExpirationDate < this.SignatureDate)
        {
            // Since the calculated expiration date is less than the existing expiration date
            // or signature date, it shouldn't be updated.
            newExpirationDate = this.ExpirationDate;
        }

        return newExpirationDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBankIBAN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see if the <c>BankIBAN</c> field is set on the <c>CustBankAccount</c> table.
    /// </summary>
    /// <param name="_custBankAccountId">
    /// The accountNum of the <c>CustBankAccount</c> table.
    /// </param>
    /// <returns>
    /// A boolean indicating if <c>BankIBAN</c> is set on the <c>CustBankAccount</c> table.
    /// </returns>
    protected boolean checkBankIBAN(CustBankAccountId _custBankAccountId)
    {
        boolean ret = true;

        unchecked (Uncheck::TableSecurityPermission)
        {
            if (_custBankAccountId != ''
                && CustBankAccount::find(this.CustAccount, _custBankAccountId).BankIBAN == '')
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>decreaseUsageCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decreases UsageCount by one.
    /// </summary>
    /// <remarks>
    /// This method set IsFirst to true if UsageCount is attempted to decrease below one.
    /// </remarks>
    public void decreaseUsageCount()
    {
        this.UsageCount--;

        if (this.UsageCount <= 0)
        {
            this.IsFirst = true;
            this.UsageCount = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        super();

        //Clear the DefaultDirectDebitMandate value for the deleted record
        CustTable custTable;
        select firstonly forUpdate DefaultDirectDebitMandate from custTable
            index hint AccountIdx
            where custTable.AccountNum == this.CustAccount;

        if (custTable.DefaultDirectDebitMandate == this.RecId)
        {
            custTable.DefaultDirectDebitMandate = 0;

            ttsbegin;
            custTable.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>CustMandateStatus</c> enumeration value of the selected record.
    /// </summary>
    /// <returns>
    /// The <c>CustMandateStatus</c> enumeration value of the selected record.
    /// </returns>
    /// <remarks>
    /// This value is calculated based upon various factors and is not stored directly in the database.
    /// When these factors are modified, it is required to ensure that postLoad method is modified appropriately.
    /// </remarks>
    public display CustMandateStatus getStatus()
    {
        if (this.CancellationDate != dateNull())
        {
            return CustMandateStatus::Canceled;
        }

        if (this.SignatureDate == dateNull()
            || this.BankAccount == ''
            || this.CustomerAddress == 0)
        {
            return CustMandateStatus::Incomplete;
        }

        if (this.isExpiredByDate() || this.isOnetimeMandateUsed())
        {
            return CustMandateStatus::Expired;
        }

        if (this.IsFirst && this.UsageCount == 0)
        {
            return CustMandateStatus::New;
        }

        if (this.IsFirst && this.UsageCount > 0)
        {
            return CustMandateStatus::Modified;
        }

        return CustMandateStatus::Active;
    }

]]></Source>
			</Method>
			<Method>
				<Name>increaseUsageCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increases UsageCount by one.
    /// </summary>
    /// <remarks>
    /// This method set IsFirst to false
    /// </remarks>
    public void increaseUsageCount()
    {
        this.UsageCount++;
        this.IsFirst = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initilizes customer specific field values in a new <c>CustDirectDebitMandate</c> record
    /// from the <c>CustTable</c> record.
    /// </summary>
    /// <param name="_custTable">
    /// The customer recrod to use.
    /// </param>
    public void initFromCustTable(CustTable _custTable)
    {
        if (_custTable)
        {
            this.CustAccount = _custTable.AccountNum;
            this.CustomerAddress = _custTable.postalAddress().RecId;

            // Default mandate bank account
            CustBankAccountId custBankAccountId = _custTable.BankAccount;

            if (custBankAccountId == '')
            {
                CustBankAccount custBankAccount;
                // Only default if there is only one CustBankAccount for the customer
                select count(RecId) from custBankAccount
                    where custBankAccount.CustAccount == _custTable.AccountNum;

                if (custBankAccount.RecId == 1)
                {
                    select firstonly RecId,AccountID from custBankAccount
                        where custBankAccount.CustAccount == _custTable.AccountNum;

                    custBankAccountId = custBankAccount.AccountID;
                }
            }

            if (custBankAccountId != ''
                && this.checkBankIBAN(custBankAccountId))
            {
                this.BankAccount = custBankAccountId;
            }

            if (_custTable.PaymMode)
            {
                CustPaymModeTable paymMode = CustPaymModeTable::find(_custTable.PaymMode);

                DimensionAttributeValueCombination davc = DimensionAttributeValueCombination::find(paymMode.PaymentLedgerDimension);

                if (paymMode.IsSEPA && this.checkCreditorIbanAndDirectDebitId(davc.DisplayValue))
                {
                    this.CreditorBankAccount = davc.DisplayValue;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreditorIbanAndDirectDebitId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks to see if the <c>BankIBAN</c> and <c>DebitDirectId</c> fields are set on the <c>BankAccountTable</c> table.
    /// </summary>
    /// <param name="_bankAccountId">
    ///     The accountId of the <c>BankAccountTable</c> table.
    /// </param>
    /// <returns>
    ///     A boolean indicating if <c>BankIBAN</c> and <c>DebitDirectId</c> are set on the <c>BankAccountTable</c> table.
    /// </returns>
    public boolean checkCreditorIbanAndDirectDebitId(CompanyBankAccountId _bankAccountId)
    {
        BankAccountTable bankAccountTable = BankAccountTable::find(_bankAccountId);

        return bankAccountTable.IBAN && bankAccountTable.DebitDirectId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();

        if (this.RecId == 0)
        {
            CustParameters custParameters = CustParameters::find();

            this.ExpectedUsageCount = 0;
            this.IsFirst = true;
            this.MandateScheme = CustMandateScheme::Core;
            this.MandatePaymentType = CustMandatePaymentType::Recurring;
            this.PrenotificationDaysFirst = custParameters.PrenotificationDaysFirst;
            this.PrenotificationDaysRecurring = custParameters.PrenotificationDaysRecurring;
            this.BankSubmissionDaysFirst = custParameters.CoreSchemeBankSubmissionDaysFirst;
            this.BankSubmissionDaysRecurring = custParameters.CoreSchemeBankSubmissionDaysRecurring;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        super();

        this.setDefaultMandate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExpiredByDate</Name>
				<Source><![CDATA[
    private boolean isExpiredByDate()
    {
        return DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) > this.ExpirationDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOnetimeMandateUsed</Name>
				<Source><![CDATA[
    private boolean isOnetimeMandateUsed()
    {
        return this.MandatePaymentType == CustMandatePaymentType::Onetime
            && !this.IsFirst
            && this.UsageCount > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the fields that are not persisted into the retrieved table buffer.
    /// </summary>
    public void postLoad()
    {
        super();

        // These fields are required to determmine Status for various types of mandate in getStatus method call
        if (this.isFieldDataRetrieved(fieldStr(CustDirectDebitMandate, CancellationDate))
            && this.isFieldDataRetrieved(fieldStr(CustDirectDebitMandate, SignatureDate))
            && this.isFieldDataRetrieved(fieldStr(CustDirectDebitMandate, BankAccount))
            && this.isFieldDataRetrieved(fieldStr(CustDirectDebitMandate, CustomerAddress))
            && this.isFieldDataRetrieved(fieldStr(CustDirectDebitMandate, IsFirst))
            && this.isFieldDataRetrieved(fieldStr(CustDirectDebitMandate, UsageCount))
            && this.isFieldDataRetrieved(fieldStr(CustDirectDebitMandate, MandatePaymentType)))
        {
            this.Status = this.getStatus();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSetDefaultMandate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the default mandate.
    /// </summary>
    /// <returns>
    ///     true if the mandate is valid; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldSetDefaultMandate()
    {
        CustDirectDebitMandate existingMandates;
        boolean shouldSetDefaultMandate;
        
        select count(RecId) from existingMandates
            where existingMandates.CustAccount == this.CustAccount;
        
        if (existingMandates.RecId == 1)
        {
            shouldSetDefaultMandate = true;
        }
        
        return shouldSetDefaultMandate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultMandate</Name>
				<Source><![CDATA[
    // Sets the default mandate on the customer record.
    private void setDefaultMandate()
    {
        if (this.shouldSetDefaultMandate())
        {
            CustTable custTable;
            select firstonly forupdate DefaultDirectDebitMandate from custTable
                index hint AccountIdx
                where custTable.AccountNum == this.CustAccount;

            if (custTable.DefaultDirectDebitMandate == 0)
            {
                custTable.DefaultDirectDebitMandate = this.RecId;

                ttsbegin;
                custTable.update();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean ret = super();

        if (ret && CustDirectDebitMandate::doTransactionsExistForMandate(this.RecId))
        {
            ret = checkFailed(strFmt("@SYS4002619", this.MandateReference));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean ret = super(_fieldIdToCheck);

        if (ret)
        {
            switch (_fieldIdToCheck)
            {
                case fieldNum(CustDirectDebitMandate, SignatureDate):
                    if (this.ExpirationDate != dateNull() && this.SignatureDate > this.ExpirationDate)
                    {
                        ret = checkFailed("@SYS4002568");
                    }
                    break;

                case fieldNum(CustDirectDebitMandate, BankAccount):
                    if (this.BankAccount != ''
                        && !this.checkBankIBAN(this.BankAccount))
                    {
                        ret = checkFailed("@SYS4002533");
                    }
                    if (this.orig().BankAccount != ''
                        && this.orig().BankAccount != this.BankAccount)
                    {
                        CustMandateStatus status = this.getStatus();
                        if (status != CustMandateStatus::Expired
                            && status != CustMandateStatus::Canceled
                            && status != CustMandateStatus::Incomplete)
                        {
                            switch (this.MandateScheme)
                            {
                                case CustMandateScheme::B2B:
                                    ret = checkFailed("@SYS4009872");
                                    break;
                                case CustMandateScheme::CORE:
                                case CustMandateScheme::COR1:
                                    info("@SYS4009871");
                                    break;
                            }
                        }
                    }
                    break;

                case fieldNum(CustDirectDebitMandate, CreditorBankAccount):
                    if (this.CreditorBankAccount != ''
                        && !this.checkCreditorIbanAndDirectDebitId(this.CreditorBankAccount))
                    {
                        ret = checkFailed("@AccountsReceivable:SEPACreditorValidation");
                    }
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelMandate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels the mandate based on the current system date.
    /// </summary>
    /// <param name="_mandateRecId">
    /// The mandate ID.
    /// </param>
    /// <exception cref="Exception::Error">
    /// The mandate can't be assigned to any open invoices.
    /// </exception>
    public static void cancelMandate(CustDirectDebitMandateRecId _mandateRecId)
    {
        if (_mandateRecId)
        {
            if (CustDirectDebitMandate::doOpenTransactionsExistForMandate(_mandateRecId))
            {
                throw error("@SYS4002571");
            }

            CustDirectDebitMandate custDirectDebitMandate = CustDirectDebitMandate::find(_mandateRecId, true);

            ttsbegin;

            custDirectDebitMandate.CancellationDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            custDirectDebitMandate.doUpdate();

            info(strFmt("@SYS4002553", custDirectDebitMandate.CancellationDate));

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    public static boolean checkExist(RecId _custDirectDebitMandateId, CompanyId _company = curExt())
    {
        boolean ret = true;

        changecompany(_company)
        {
            if (!CustDirectDebitMandate::exist(_custDirectDebitMandateId))
            {
                ret = checkFailed(strFmt(CustDirectDebitMandate::txtNotExist(), _custDirectDebitMandateId));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultAndDisplayMandate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults the primary mandate for the customer and sets the mandate field's editing options.
    /// </summary>
    /// <param name="_custAccount">
    /// The customer account number.
    /// </param>
    /// <param name="_paymMode">
    /// The method of payment on the transaction.
    /// </param>
    /// <param name="_existingMandateRecId">
    /// The existing mandate on the transaction.
    /// </param>
    /// <param name="_overwriteExistingMandate">
    /// true if the default mandate should overwrite the existing mandate; otherwise false.
    /// </param>
    /// <param name="_formDataSource">
    /// The form datasource where the mandate is provided.
    /// </param>
    /// <param name="_fieldNum">
    /// The field number of the mandate in the form datasource.
    /// </param>
    /// <returns>
    /// The primary mandate for the customer when dealing with a SEPA transaction; otherwise the existing mandate value.
    /// </returns>
    /// <remarks>
    /// If defaulting logic is not required, callers should ignore the return value.
    /// </remarks>
    public static CustDirectDebitMandateRecId defaultAndDisplayMandate(
        CustAccount _custAccount,
        PaymMode _paymMode,
        CustDirectDebitMandateRecId _existingMandateRecId,
        boolean _overwriteExistingMandate,
        FormDataSource _formDataSource,
        FieldId _fieldNum)
    {
        CustDirectDebitMandateRecId mandateRecId = _existingMandateRecId;

        if (CustPaymModeTable::find(_paymMode).IsSEPA)
        {
            if (_formDataSource)
            {
                _formDataSource.object(_fieldNum).allowEdit(true);
                _formDataSource.object(_fieldNum).skip(false);
            }

            if (_existingMandateRecId == 0 || _overwriteExistingMandate)
            {
                mandateRecId = CustDirectDebitMandate::getDefaultMandate(_custAccount);
            }
        }
        else
        {
            if (_formDataSource)
            {
                _formDataSource.object(_fieldNum).allowEdit(false);
                _formDataSource.object(_fieldNum).skip(true);
            }
            mandateRecId = 0;
        }

        return mandateRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doOpenTransactionsExistForMandate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if posted and open transactions exist for the mandate.
    /// </summary>
    /// <param name="_mandateRecId">
    /// The mandate ID.
    /// </param>
    /// <returns>
    /// true if posted and open transactions exist for the mandate; otherwise, false.
    /// </returns>
    public static boolean doOpenTransactionsExistForMandate(CustDirectDebitMandateRecId _mandateRecId)
    {
        CustTrans custTrans;

        select firstonly RecId from custTrans
            where custTrans.DirectDebitMandate == _mandateRecId
                && custTrans.Closed == dateNull()
                && custTrans.AmountCur >= 0;

        return custTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doTransactionsExistForMandate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if any transactions exist for the mandate.
    /// </summary>
    /// <param name="_mandateRecId">
    /// The mandate ID.
    /// </param>
    /// <returns>
    /// true if transactions exist for the mandate; otherwise, false.
    /// </returns>
    public static boolean doTransactionsExistForMandate(CustDirectDebitMandateRecId _mandateRecId)
    {
        CustTrans custTrans;
        boolean referenced;

        select firstonly RecId from custTrans
            where custTrans.DirectDebitMandate == _mandateRecId;

        if (custTrans.RecId)
        {
            referenced = true;
        }

        if (!referenced)
        {
            CustInvoiceTable custInvoiceTable;
            select firstonly RecId from custInvoiceTable
                where custInvoiceTable.DirectDebitMandate == _mandateRecId;

            if (custInvoiceTable.RecId)
            {
                referenced = true;
            }
        }

        if (!referenced)
        {
            SalesTable salesTable;
            select firstonly RecId from salesTable
                where salesTable.DirectDebitMandate == _mandateRecId;

            if (salesTable.RecId)
            {
                referenced = true;
            }
        }

        if (!referenced)
        {
            CustInvoiceJour custInvoiceJour;
            select firstonly RecId from custInvoiceJour
                where custInvoiceJour.DirectDebitMandate == _mandateRecId;

            if (custInvoiceJour.RecId)
            {
                referenced = true;
            }
        }

        if (!referenced)
        {
            ProjInvoiceJour projInvoiceJour;
            select firstonly RecId from projInvoiceJour
                where projInvoiceJour.DirectDebitMandate == _mandateRecId;

            if (projInvoiceJour.RecId)
            {
                referenced = true;
            }
        }

        return referenced;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>CustDirectDebitMandate</c> table exists.
    /// </summary>
    /// <param name="_custDirectDebitMandateId">
    /// The <c>RecId</c> value of the <c>CustDirectDebitMandate</c> record.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean exist(RecId _custDirectDebitMandateId)
    {
        return (select firstonly RecId from custDirectDebitMandate
                    where custDirectDebitMandate.RecId == _custDirectDebitMandateId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific record in the <c>CustDirectDebitMandate</c> table.
    /// </summary>
    /// <param name="_custDirectDebitMandateId">
    /// The unique ID of the record to find.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value that determines whether to select the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when reading the record; optional.
    /// </param>
    /// <returns>
    /// A <c>CustDirectDebitMandate</c> table buffer.
    /// </returns>
    public static CustDirectDebitMandate find(
        RecId _custDirectDebitMandateId,
        boolean _forupdate = false,
        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        CustDirectDebitMandate custDirectDebitMandate;

        custDirectDebitMandate.selectForUpdate(_forupdate);
        if (_forupdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            custDirectDebitMandate.concurrencyModel(_concurrencyModel);
        }

        select firstonly custDirectDebitMandate
            index hint RecId
            where custDirectDebitMandate.RecId == _custDirectDebitMandateId;

        return custDirectDebitMandate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultMandate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the primary mandate for the customer.
    /// </summary>
    /// <param name="_accountNum">
    /// The customer account number.
    /// </param>
    /// <returns>
    /// The primary mandate for the customer if it is active; otherwise, 0.
    /// </returns>
    /// <remarks>
    /// Only active mandates will be returned, and mandates must be active with respect to the
    /// current session date.
    /// </remarks>
    public static CustDirectDebitMandateRecId getDefaultMandate(CustAccount _accountNum)
    {
        CustTable custTable;

        select firstonly DefaultDirectDebitMandate from custTable
            index hint AccountIdx
            where custTable.AccountNum == _accountNum;

        return custTable.DefaultDirectDebitMandate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionSepa</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the transaction is a SEPA transaction.
    /// </summary>
    /// <param name="_company">
    /// The Company ID.
    /// </param>
    /// <param name="_custTransRecId">
    /// The ID of the posted customer transaction.
    /// </param>
    /// <returns>
    /// true if the transaction is a SEPA transaction; otherwise, false.
    /// </returns>
    public static boolean isTransactionSepa(CompanyId _company, RecId _custTransRecId)
    {
        boolean isSepa;
        CustPaymModeTable custPaymModeTable;
        CustTrans custTrans;

        container companyContext = [_company];

        select firstonly crosscompany:companyContext IsSEPA from custPaymModeTable
            join DirectDebitMandate, TransType from custTrans
            where custTrans.RecId == _custTransRecId
                && custTrans.PaymMode == custPaymModeTable.PaymMode;

        isSepa = custPaymModeTable.IsSEPA;

        if (isSepa && custTrans.TransType != LedgerTransType::Payment)
        {
            // Invoices must have a mandate present to be considered SEPA
            isSepa = isSepa && custTrans.DirectDebitMandate;
        }

        return isSepa;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the custom mandate lookup and returns the <c>CustDirectDebitMandate</c> table record selected by the user.
    /// </summary>
    /// <param name="_custAccount">
    /// The customer account number.
    /// </param>
    /// <param name="_callingControl">
    /// The reference group control of the mandate.
    /// </param>
    /// <returns>
    /// The <c>CustDirectDebitMandate</c> table record selected by the user.
    /// </returns>
    /// <remarks>
    /// This should be called from the lookupReference method of the mandate's reference group control.
    /// </remarks>
    public static CustDirectDebitMandate lookupReference(CustAccount _custAccount, FormReferenceControl _callingControl)
    {
        SysReferenceTableLookup sysTableLookup = SysReferenceTableLookup::newParameters(
            tableNum(CustDirectDebitMandate),
            _callingControl,
            true);

        CustDirectDebitMandate selectedMandate;
        selectedMandate.addLookupReferenceFields(sysTableLookup);

        // Filter the mandates to only show those related to the selected customer
        Query lookupQuery = new Query();
        QueryBuildDataSource mandateQbds = lookupQuery.addDataSource(tableNum(CustDirectDebitMandate));
        mandateQbds.addRange(fieldNum(CustDirectDebitMandate, CustAccount)).value(queryValue(_custAccount));
        mandateQbds.addSortField(fieldNum(CustDirectDebitMandate, MandateReference), SortOrder::Ascending);
        sysTableLookup.parmQuery(lookupQuery);

        // Return the record selected by the user.
        selectedMandate = sysTableLookup.performFormLookup();

        return selectedMandate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLookupReferenceFields</Name>
				<Source><![CDATA[
	/// <summary>
    /// Adds lookup fields to an existing <c>SysReferenceTableLookup</c> instance to Show the Mandate reference and status of <c>CustDirectDebitMandate</c> fields in lookup.
    /// </summary>
    /// <param name = "_sysTableLookup">
    /// An existing <c>SysReferenceTableLookup</c> instance.
	/// </param>
    protected void addLookupReferenceFields(SysReferenceTableLookup _sysTableLookup)
    {
        _sysTableLookup.addLookupfield(fieldNum(CustDirectDebitMandate, MandateReference));
        _sysTableLookup.addLookupfield(fieldNum(CustDirectDebitMandate, BankAccount));
        _sysTableLookup.addLookupfield(fieldNum(CustDirectDebitMandate, Status));

    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedCustBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the mandate with respect to the modified bank account.
    /// </summary>
    /// <param name="_custBankAccount">
    /// The bank account.
    /// </param>
    public static void modifiedCustBankAccount(CustBankAccount _custBankAccount)
    {
        CustDirectDebitMandate mandate;
        boolean displayMessage;

        while select mandate
            where mandate.CustAccount == _custBankAccount.CustAccount
                && mandate.BankAccount == _custBankAccount.AccountID
                && (mandate.MandateScheme == CustMandateScheme::CORE
                    || mandate.MandateScheme == CustMandateScheme::COR1)
        {
            CustMandateStatus status = mandate.getStatus();
            if (status != CustMandateStatus::Expired && status != CustMandateStatus::Canceled && status != CustMandateStatus::Incomplete)
            {
                displayMessage = true;
            }
        }

        if (displayMessage)
        {
            info("@SYS4002579");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetMandate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the mandate status from Active to New.
    /// </summary>
    /// <param name="_mandateRecId">
    /// The mandate ID.
    /// </param>
    public static void resetMandate(CustDirectDebitMandateRecId _mandateRecId)
    {
        if (_mandateRecId)
        {
            CustDirectDebitMandate custDirectDebitMandate = CustDirectDebitMandate::find(_mandateRecId, true);

            if (custDirectDebitMandate.getStatus() == CustMandateStatus::Active)
            {
                ttsbegin;
                custDirectDebitMandate.IsFirst = true;
                custDirectDebitMandate.doUpdate();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>CustDirectDebitMandate</c> table record typed in by the user if it is valid for the customer.
    /// </summary>
    /// <param name="_custAccount">
    /// The customer account number.
    /// </param>
    /// <param name="_callingControl">
    /// The reference group control of the mandate.
    /// </param>
    /// <returns>
    /// The <c>CustDirectDebitMandate</c> table record typed in by the user if it is valid for the customer; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This should be called from the resolveReference method of the mandate's reference group control.
    /// </remarks>
    public static CustDirectDebitMandate resolveReference(CustAccount _custAccount, FormReferenceControl _callingControl)
    {
        CustDirectDebitMandate selectedMandate;
        CustMandateId mandateReference = _callingControl.filterValue(
            AbsoluteFieldBinding::construct(
                fieldStr(CustDirectDebitMandate, MandateReference),
                tableStr(CustDirectDebitMandate))).value();

        // Filter the mandates to only allow mandates assigned to the current customer
        select firstonly selectedMandate
            where selectedMandate.CustAccount == _custAccount
                && selectedMandate.MandateReference == mandateReference;

        return selectedMandate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    public static TxtNotExist txtNotExist()
    {
        return "@SYS102169";
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the mandate with respect to the provided bank account.
    /// </summary>
    /// <param name="_custBankAccount">
    /// The bank account.
    /// </param>
    /// <returns>
    /// true if the mandate is still valid; otherwise, false
    /// </returns>
    public static boolean validateCustBankAccount(CustBankAccount _custBankAccount)
    {
        CustDirectDebitMandate mandate;
        boolean ret = true;

        while select mandate
            where mandate.CustAccount == _custBankAccount.CustAccount
                && mandate.BankAccount == _custBankAccount.AccountID
                && mandate.MandateScheme == CustMandateScheme::B2B
        {
            CustMandateStatus status = mandate.getStatus();

            if (status != CustMandateStatus::Canceled && status != CustMandateStatus::Expired && status != CustMandateStatus::Incomplete)
            {
                ret = checkFailed("@SYS4002536");
                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMandate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the given mandate
    /// </summary>
    /// <param name="_shouldValidateBankAccount">
    /// true if the bank account should be validated against the mandate.
    /// </param>
    /// <param name="_throwErrors">
    /// Determines if errors should be thrown for an invalid mandate.
    /// </param>
    /// <param name="_validateOnetimeMandateUsed">
    /// true if usage count should be validated for the onetime mandate.
    /// </param>
    /// <param name="_invoiceCustTrans">
    /// The optional <c>CustTrans</c> table record that represents the invoice.
    /// </param>
    /// <returns>
    /// true if the mandate is valid; otherwise, false
    /// </returns>
    /// <exception cref="Exception::Error">
    /// A valid mandate must be selected
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The mandate must be complete
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The mandate must not be cancelled
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The mandate must not be expired
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The bank account of the transaction must match the mandate
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The transaction date plus pre-notification days must be less than or equal to the due date
    /// </exception>
    public static boolean validateMandate(
        CustDirectDebitMandateRecId _mandateRecId,
        boolean _shouldValidateBankAccount,
        boolean _throwErrors,
        boolean _validateOnetimeMandateUsed = true,
        CustTrans _invoiceCustTrans = null)
    {
        boolean result = true;
        // Sub method to perform the error handling
        void handleError(str _errorMessage)
        {
            result = false;

            if (_throwErrors)
            {
                throw error(_errorMessage);
            }
        }

        CustDirectDebitMandate directDebitMandate = CustDirectDebitMandate::find(_mandateRecId);
        CustPrenotificationDays prenotificationDays = directDebitMandate.IsFirst ? directDebitMandate.PrenotificationDaysFirst : directDebitMandate.PrenotificationDaysRecurring;
        CustBankAccountId bankAccountId = _invoiceCustTrans.ThirdPartyBankAccountId;

        if (directDebitMandate.RecId == 0)
        {
            handleError(directDebitMandate.getMandateNotFoundMessage(_invoiceCustTrans));
        }
        else if (directDebitMandate.Status == CustMandateStatus::Incomplete)
        {
            handleError(strFmt("@SYS4002554", directDebitMandate.MandateReference, directDebitMandate.CustAccount));
        }
        else if (directDebitMandate.Status == CustMandateStatus::Canceled)
        {
            handleError(strFmt("@SYS4002551", directDebitMandate.CustAccount, directDebitMandate.BankAccount));
        }
        else if (directDebitMandate.isExpiredByDate()
            || (_validateOnetimeMandateUsed
            && directDebitMandate.isOnetimeMandateUsed()))
        {
            handleError(strFmt("@SYS4002552", directDebitMandate.CustAccount, directDebitMandate.BankAccount));
        }
        else if (_shouldValidateBankAccount
            && bankAccountId != ''
            && directDebitMandate.BankAccount != bankAccountId)
        {
            handleError(strFmt("@SYS4002532", directDebitMandate.BankAccount, bankAccountId));
        }
        else if (_invoiceCustTrans
            && directDebitMandate.validateTransTypeForMandate(_invoiceCustTrans.TransType)
            && (_invoiceCustTrans.TransDate + prenotificationDays > _invoiceCustTrans.DueDate))
        {
            handleError(strFmt("@SYS4002545", _invoiceCustTrans.TransDate, prenotificationDays, _invoiceCustTrans.DueDate));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransTypeForMandate</Name>
				<Source><![CDATA[
	/// <summary>
    /// Validate the transaction type for the current mandate.
    /// </summary>
    /// <param name = "_transType">
    /// The transaction type.
	/// </param>
    /// <returns>
    /// true, if transaction type is valid for the current mandate; otherwise, false.
	/// </returns>
    protected boolean validateTransTypeForMandate(LedgerTransType _transType)
    {
        return _transType != LedgerTransType::Interest
            && _transType != LedgerTransType::CollectionLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMandateNotFoundMessage</Name>
				<Source><![CDATA[
	/// <summary>
    /// Gets a error message value when a <c>CustDirectDebitMandate</c> table record is not found.
    /// </summary>
    /// <param name = "_invoiceCustTrans">
    /// The <c>CustTrans</c> table record that represents the invoice.
	/// </param>
    /// <returns>
    /// The error message returned when a mandate is not found.
	/// </returns>
    protected str getMandateNotFoundMessage(CustTrans _invoiceCustTrans)
    {
        return "@SYS4002657";
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the settlement between a SEPA payment and invoice is valid.
    /// </summary>
    /// <param name="_custAccountNum">
    /// The customer account.
    /// </param>
    /// <param name="_paymentCompany">
    /// The company of the payment document.
    /// </param>
    /// <param name="_paymentMethodOfPayment">
    /// The method of payment for the payment document.
    /// </param>
    /// <param name="_invoiceCustTrans">
    /// The <c>CustTrans</c> table record that represents the invoice.
    /// </param>
    public static void validateSettlement(
        AccountNum _custAccountNum,
        CompanyId _paymentCompany,
        PaymMode _paymentMethodOfPayment,
        CustTrans _invoiceCustTrans)
    {
        boolean isValid = true;

        if (CustPaymModeTable::findByCompany(_paymentCompany, _paymentMethodOfPayment).IsSEPA)
        {
            if (!CustPaymModeTable::findByCompany(_invoiceCustTrans.company(), _invoiceCustTrans.PaymMode).IsSEPA)
            {
                isValid = false;
            }
            else
            {
                changecompany(_invoiceCustTrans.company())
                {
                    isValid = CustDirectDebitMandate::validateMandate(_invoiceCustTrans.DirectDebitMandate, false, false, true, _invoiceCustTrans);
                }
            }
        }

        if (!isValid)
        {
            warning (strFmt("@SYS4002546", _custAccountNum));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>increaseLastLogNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increases the <c>LastLogNum</c> field by one.
    /// </summary>
    public void increaseLastLogNum()
    {
        this.LastLogNum++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initExpirationDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes new Expiration date based on Signature date.
    /// </summary>
    /// <returns>The expiration date.</returns>
    public ExpirationDate initExpirationDate()
    {
        return dateMthFwd(this.SignatureDate, CustParameters::find().MandateDefaultExpirationMonths) - 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(CustDirectDebitMandate, SignatureDate):
                ExpirationDate expirationDate = this.initExpirationDate();

                if (Box::yesNoCancel(strFmt("@SYS4004445", this.ExpirationDate, expirationDate), DialogButton::Cancel) == DialogButton::Yes)
                {
                    this.ExpirationDate = expirationDate;
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastDirectDebitMandateLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds last <c>CustDirectDebitMandateLog</c> record with given state.
    /// </summary>
    /// <returns></returns>
    public CustDirectDebitMandateLog findLastDirectDebitMandateLog(
        CustDirectDebitMandateState _state = CustDirectDebitMandateState::Generated,
        boolean _forupdate = false)
    {
        return CustDirectDebitMandateLog::findLastWithState(this.RecId, _state, _forupdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>LogisticsPostalAddress_updated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the customer address reference on all mandates that use the original <c>LogisticsPostalAddress</c> record
    /// to point to the new <c>LogisticsPostalAddress</c> record.
    /// </summary>
    /// <param name="_originalPostalAddress">The original <c>LogisticsPostalAddress</c> record.</param>
    /// <param name="_updatedPostalAddress">The updated <c>LogisticsPostalAddress</c> record.</param>
    [SubscribesTo(tableStr(LogisticsPostalAddress), delegateStr(LogisticsPostalAddress, updated))]
    public static void LogisticsPostalAddress_updated(LogisticsPostalAddress _originalPostalAddress, LogisticsPostalAddress _updatedPostalAddress)
    {
        // All changes to a direct debit mandate need to be logged. This is currently done using the built-in AX database logging
        // functionality. When the address changes, a new date-effective record will be inserted into the LogisticsPostalAddress
        // table, this event handler will trigger, the mandate records that used that address will be updated, and the kernel will
        // log the change. Even though we are only interested in having mandates point to the latest address at any given time,
        // we use the the LogisticsPostalAddress instead of LogisticsLocation as our reference so that these changes are logged.
        if (_originalPostalAddress.RecId != _updatedPostalAddress.RecId)
        {
            CustDirectDebitMandate mandate;
            update_recordset mandate
                setting CustomerAddress = _updatedPostalAddress.RecId
                where mandate.CustomerAddress == _originalPostalAddress.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        CustDirectDebitMandate orig = this.orig();
        if (orig.ExpirationDate && orig.ExpirationDate != this.ExpirationDate)
        {
            this.PreviousExpirationDate = orig.ExpirationDate;
        }

        super();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<DeveloperDocumentation>@SYS4002535</DeveloperDocumentation>
	<FormRef>CustDirectDebitMandateView</FormRef>
	<Label>@SYS4002602</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>CustAccount</TitleField1>
	<TitleField2>MandateReference</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>AccountsReceivable</Modules>
	<ReplacementKey>MandateReferenceIdx</ReplacementKey>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankSubmissionDaysFirst</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankSubmissionDaysRecurring</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CancellationDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustomerAddress</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpectedUsageCount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpirationDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsFirst</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MandatePaymentType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MandateReference</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MandateScheme</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PrenotificationDaysFirst</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PrenotificationDaysRecurring</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SignatureDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SignatureLocation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UsageCount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PreviousIBAN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MandateReference</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankAccount</Name>
			<Label>@SYS1517</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankAccount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Customer</Name>
			<Label>@SYS302</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustomerAddress</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Expiration</Name>
			<Label>@SYS343213</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpirationDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CancellationDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS318403</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MandateReference</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>MandateScheme</Name>
			<Label>@SYS4002633</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MandateScheme</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MandatePaymentType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Miscellaneous</Name>
			<Label>@SYS73543</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IsFirst</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Status</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PreviousIBAN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Signature</Name>
			<Label>@SYS11487</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SignatureDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SignatureLocation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Timing</Name>
			<Label>@SYS52549</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankSubmissionDaysFirst</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankSubmissionDaysRecurring</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PrenotificationDaysFirst</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PrenotificationDaysRecurring</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>UsageCount</Name>
			<Label>@SYS4002630</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpectedUsageCount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UsageCount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustBankAccountId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>BankSubmissionDaysFirst</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustBankSubmissionDays</ExtendedDataType>
			<Label>@SYS4002609</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>BankSubmissionDaysRecurring</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustBankSubmissionDays</ExtendedDataType>
			<Label>@SYS4002605</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>CancellationDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustMandateCancellationDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CreditorBankAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
			<Label>@AccountsReceivable:SEPACreditorBankAccount</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustAccount</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>CustAccount</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CustomerAddress</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>LogisticsPostalAddressRecId</ExtendedDataType>
			<Label>@SYS16717</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>ExpectedUsageCount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustMandateExpectedUsageCount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ExpirationDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExpirationDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsFirst</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS4002627</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>LastLogNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Counter</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>MandatePaymentType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CustMandatePaymentType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MandateReference</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>CustMandateId</ExtendedDataType>
			<Label>@SYS4002628</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>MandateScheme</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CustMandateScheme</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>PrenotificationDaysFirst</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustPrenotificationDays</ExtendedDataType>
			<Label>@SYS4002611</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>PrenotificationDaysRecurring</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustPrenotificationDays</ExtendedDataType>
			<Label>@SYS4002607</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>PreviousExpirationDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExpirationDate</ExtendedDataType>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PreviousIBAN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankIBAN</ExtendedDataType>
			<Label>@SYS4002648</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>SignatureDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustMandateSignatureDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SignatureLocation</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LogisticsAddressCityName</ExtendedDataType>
			<Label>@SYS4002670</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Status</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<SaveContents>No</SaveContents>
			<EnumType>CustMandateStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>UsageCount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustMandateUsageCount</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>MandateReferenceIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>MandateReference</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CustTableIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CustAccount</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CustBankAccountIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>BankAccount</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CustAccount</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LogisticsPostalAddressIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CustomerAddress</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustBankAccount</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>CustBankAccount</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustAccount</Name>
					<Field>CustAccount</Field>
					<RelatedField>CustAccount</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankAccount</Name>
					<Field>BankAccount</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustAccount</Name>
					<SourceEDT>CustAccount</SourceEDT>
					<Field>CustAccount</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LogisticsPostalAddress</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LogisticsPostalAddress</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustomerAddress</Name>
					<Field>CustomerAddress</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankAccountTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankAccountTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CreditorBankAccount</Name>
					<SourceEDT>CompanyBankAccountId</SourceEDT>
					<Field>CreditorBankAccount</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>