<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSLoadLine</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class WHSLoadLine extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        this.validateIfAllowedToModify();

        Qty origQty = this.orig().Qty;
        WHSShipmentId origShipmentId = this.orig().ShipmentId;

        this.assertLoadLineNotPartOfWaveInProcess();

        ttsbegin;

        Weight loadLineWeight  = this.loadLineWeight();
        Weight loadLineNetWeight = this.loadLineNetWeight();

        WHSLoadLineSyncInvalid::delete(this);

        this.deleteRelatedWorkLines();

        WHSLoadTable loadTable = this.whsLoadTable(true);

        WHSCrossDockLoadLine whsCrossDockLoadLine;
        WHSLoadLine origLoadLine = this.orig();

        
        select whsCrossDockLoadLine where whsCrossDockLoadLine.LoadLineRecId == this.RecId;

        super();
        
        this.unmarkPlannedCrossDockQty(whsCrossDockLoadLine, origLoadLine);
 
        if (loadTable)
        {
            if (!loadTable.existWHSLoadLine())
            {
                this.onLastLoadLineDeleted(loadTable);
            }
            else
            {
                WHSLoadTable::addLoadWeightsForLoadLine(this, -this.InventQty);

                WHSLoadStatusUpdater loadStatusUpdater = WHSLoadStatusUpdater::newFromLoadId(loadTable.LoadId);
                loadStatusUpdater.updateWhenLoadLineDeleted();
            }
        }

        WHSShipmentTable    shipmentTable;
        WHSLoadLine         loadLineForSameShipment;
        delete_from shipmentTable
            where shipmentTable.ShipmentId == this.ShipmentId
            notexists join loadLineForSameShipment
                where loadLineForSameShipment.ShipmentId == this.ShipmentId;

        if (shipmentTable.RowCount() == 0)
        {
            WHSShipmentStatusUpdater shipmentStatusUpdater = WHSShipmentStatusUpdater::newFromShipmentId(this.ShipmentId);
            shipmentStatusUpdater.updateWhenLoadLineDeleted();
        }

        if (this.ShipmentId)
        {
            shipmentTable = WHSShipmentTable::find(this.ShipmentId, true);

            if (shipmentTable
                && !shipmentTable.OrderNum)
            {
                if (shipmentTable.assignOriginInfo(AddRemove::Remove))
                {
                    shipmentTable.update();
                }
            }           
        }

        this.onQuantityOnLoadChange(this.InventTransId, origQty, '', '', '', true);
        WHSLoadTable::setOriginInfo(this.LoadId, AddRemove::Remove);

        if (this.mustCheckAndNotifyQtyOnShipmentChanged(origQty, 0, this.orig().UOM, this.orig().UOM, origShipmentId, ""))
        {
            this.checkAndNotifyQtyOnShipmentChanged(this.InventTransId, origQty, 0, this.orig().UOM, this.orig().UOM, this.ItemId, origShipmentId, "");
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeUsedForPlannedCrossDock</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the planning cross dock can be used for the load line
    /// </summary>
    /// <returns>true if the cross dock can be used; Otherwise, false.</returns>
    internal boolean canBeUsedForPlannedCrossDock()
    {
        return !this.Invalid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDeleteLoadWhenLastLineIsDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the load should be deleted when the last line is deleted.
    /// </summary>
    /// <returns>true if the load should be deleted; Otherwise, false.</returns>
    protected boolean mustDeleteLoadWhenLastLineIsDeleted()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onLastLoadLineDeleted</Name>
				<Source><![CDATA[
    protected void onLastLoadLineDeleted(WHSLoadTable _loadTable)
    {
        if (this.mustDeleteLoadWhenLastLineIsDeleted())
        {
            _loadTable.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRelatedWorkLines</Name>
				<Source><![CDATA[
    private void deleteRelatedWorkLines()
    {
        if (this.canDeleteRelatedWorkLines())
        {
            // Clean up the related work lines
            WHSWorkLine::removeLoadLineReference(this.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteRelatedWorkLines</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean canDeleteRelatedWorkLines()
    {
        return true; // Used as an extension point.
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceCrossDockEvaluatedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reduces the cross dock evaluated quantity on the load line.
    /// </summary>
    /// <param name = "_loadLineRecId">Rec ID of the load line to reduce the quantity on.</param>
    /// <param name = "_reduceQuantity">The amount of quantity to reduce by.</param>
    [Hookable(false)]
    internal static void reduceCrossDockEvaluatedQuantity(
        WHSLoadLineRefRecId     _loadLineRecId,
        InventHandlingQtyRemain _reduceQuantity)
    {
        if (appl.ttsLevel() == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        WHSLoadLine loadLine = WHSLoadLine::findbyRecId(_loadLineRecId, true);

        loadLine.CrossDockEvaluatedQuantity -= _reduceQuantity;
        loadLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateReleasedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the released quantity must be updated.
    /// </summary>
    /// <param name="_origShipmentId">
    /// The parameter of type <c>WHSShipmentId</c>.
    /// </param>
    /// <param name="_shipmentId">
    /// The parameter of type <c>WHSShipmentId</c>.
    /// </param>
    /// <returns>
    /// true if the released quantity must be updated; otherwise, false.
    /// </returns>
    protected boolean mustUpdateReleasedQty(WHSShipmentId _origShipmentId, WHSShipmentId _shipmentId)
    {
        return _origShipmentId || _shipmentId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckAndNotifyQtyOnShipmentChanged</Name>
				<Source><![CDATA[
    private boolean mustCheckAndNotifyQtyOnShipmentChanged(
        Qty                 _origQty,
        Qty                 _newQty,
        UnitOfMeasureSymbol _origUOM,
        UnitOfMeasureSymbol _newUOM,
        WHSShipmentId       _origShipmentId,
        WHSShipmentId       _newShipmentId)
    {
        boolean res = this.mustUpdateReleasedQty(_origShipmentId, _newShipmentId);

        return res && (_origShipmentId != _newShipmentId
                        || _origUOM != _newUOM
                        || _origQty != _newQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCustAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Display method for customer account of the sales line.
    /// </summary>
    /// <returns>
    /// Returns <c>CustAccount</c> object.
    /// </returns>
    display CustAccount displayCustAccount()
    {
        CustAccount custAccount;

        if (WHSInventTransTypeSalesRefactoringFlight::instance().isEnabled())
        {
            if (this.InventTransType == InventTransType::Sales)
            {
                SalesLine salesLine = this.getOrderCommonFromLoadLine() as SalesLine;

                if (salesLine.RecId)
                {
                    custAccount = salesLine.CustAccount;
                }
            }
        }
        else
        {
            SalesLine   salesLine = this.getOrderCommonFromLoadLine() as SalesLine;

            if (salesLine.RecId)
            {
                custAccount = salesLine.CustAccount;
            }
        }

        return custAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCustName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the name of the customer.
    /// </summary>
    /// <returns>
    /// The name of the customer.
    /// </returns>
    display CustName displayCustName()
    {
        CustName    custName;
        SalesLine   salesLine = this.getOrderCommonFromLoadLine() as SalesLine;

        if (salesLine.RecId)
        {
            custName = CustTable::find(salesLine.CustAccount).name();
        }

        return custName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayDropOffDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the Drop off date for the shipment line.
    /// </summary>
    /// <returns>
    ///     The Drop off date for the shipment line.
    /// </returns>
    public display TransDate displayDropOffDate()
    {
        TransDate           ret;
        Common              orderLine;
        SalesLine           salesLine;
        InventTransferLine  inventTransferLine;

        if (this.LoadDirection == WHSLoadDirection::Inbound)
        {
            ret = WHSShipmentTable::find(this.ShipmentId).shipmentArrivalDate();
        }
        else if (this.LoadDirection == WHSLoadDirection::Outbound)
        {
            orderLine = this.getOrderCommonFromLoadLine();

            if (orderLine is SalesLine)
            {
                salesLine = orderLine as SalesLine;

                ret = salesLine.ReceiptDateConfirmed ? salesLine.ReceiptDateConfirmed : salesLine.ReceiptDateRequested;
            }

            if (orderLine is InventTransferLine)
            {
                inventTransferLine = orderLine as InventTransferLine;

                ret = inventTransferLine.ReceiveDate;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayReceivedInventoryQuantity</Name>
				<Source><![CDATA[
    public display InventQty displayReceivedInventoryQuantity()
    {
        return this.receivedInventoryQuantity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the inventory quantity associated with the current item.
    /// </summary>
    /// <returns>
    /// The inventory quantity for the item.
    /// </returns>
    public display InventQty displayInventQty()
    {
        return this.displayHandlingQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the handling quantity associated with the current item.
    /// </summary>
    /// <returns>
    /// The handling quantity for the item.
    /// </returns>
    [Hookable(false)]
    internal display InventHandlingQty displayHandlingQty()
    {
        EcoResProductUnitConverter ecoResProductUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(this.ItemId,
                                                                                                                                  this.InventDimId,
                                                                                                                                  this.UOM,
                                                                                                                                  this.displayHandlingUOM(),
                                                                                                                                  NoYes::Yes);
        if (ecoResProductUnitConverter.canValueBeConverted())
        {
            return ecoResProductUnitConverter.convertValue(this.Qty);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayInventUOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the inventory unit of measure associated with the item on the Load Line.
    /// </summary>
    /// <returns>
    /// The inventory unit of measure for the item.
    /// </returns>
    public display InventUnitId displayInventUOM()
    {
        return this.displayHandlingUOM();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayHandlingUOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the handling unit of measure associated with the item on the Load Line.
    /// </summary>
    /// <returns>
    /// The handling unit of measure for the item.
    /// </returns>
    [Hookable(false)]
    internal display UnitOfMeasureSymbol displayHandlingUOM()
    {
        return WHSCatchWeightHelper::inventHandlingUnitId(this.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayItemName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds item name of the product in load line. Use default item name if translation is not found
    /// </summary>
    /// <returns>
    /// The item name of the product.
    /// </returns>
    display ItemName displayItemName()
    {
        return EcoResProductTranslation::getNameOrDefaultName(InventTable::itemProduct(this.ItemId), Global::currentUserLanguage());
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayItemVolume</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display the volume of a load line.
    /// </summary>
    /// <returns>
    /// The volume of a load line.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display Volume displayItemVolume()
    {
        WHSPhysDimUOM whsPhysDimUOM = WHSPhysDimUOM::getPhysDimUOMByItem(this.ItemId, this.UOM);

        if (whsPhysDimUOM)
        {
            return whsPhysDimUOM.displayVolume() * this.Qty;
        }

        return InventTable::find(this.ItemId).UnitVolume * this.displayHandlingQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayItemWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the weight of a load line.
    /// </summary>
    /// <returns>
    /// The weight of a load line.
    /// </returns>
    public display Weight displayItemWeight()
    {
        WHSPhysDimUOM whsPhysDimUOM = WHSPhysDimUOM::getPhysDimUOMByItem(this.ItemId, this.UOM);

        if (whsPhysDimUOM)
        {
            return whsPhysDimUOM.Weight * this.Qty;
        }

        return this.grossWeight() * this.displayHandlingQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>grossWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the gross weight of the load line.
    /// </summary>
    /// <returns>The gross weight of the load line.</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display ItemGrossWeight grossWeight()
    {
        if (!this.ItemNetWeight && !this.ItemTareWeight)
        {
            return InventTable::find(this.ItemId).grossWeight();
        }

        return this.ItemNetWeight + this.ItemTareWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadAccountNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display load account number.
    /// </summary>
    /// <returns>
    /// The account number of the load.
    /// </returns>
    display WHSAccountNum displayLoadAccountNum()
    {
        return this.whsLoadTable().AccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadCarNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds car number of the load.
    /// </summary>
    /// <returns>
    /// The car number of the load.
    /// </returns>
    display TMSCarNumber displayLoadCarNumber()
    {
        return this.whsLoadTable().CarNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadCarrierCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display carrier code of the load.
    /// </summary>
    /// <returns>
    /// The carrier code of the load.
    /// </returns>
    display TMSCarrierCode displayLoadCarrierCode()
    {
        return this.whsLoadTable().CarrierCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadCarrierServiceCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display carrier service code of load.
    /// </summary>
    /// <returns>
    /// Carrier service code of the load.
    /// </returns>
    display TMSCarrierServiceCode displayLoadCarrierServiceCode()
    {
        return this.whsLoadTable().CarrierServiceCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadGrossWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display gross weight of the load.
    /// </summary>
    /// <returns>
    /// The gross weight of the load.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TMSActualGrossWeight displayLoadGrossWeight()
    {
        WHSLoadTable loadTable = this.whsLoadTable();

        return loadTable.effectiveGrossWeight();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadNetWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display net weight of the load.
    /// </summary>
    /// <returns>
    /// The net weight of the load.
    /// </returns>
    display WHSLoadNetWeight displayLoadNetWeight()
    {
        WHSLoadTable loadTable = this.whsLoadTable();

        return loadTable.ActualNetWeight ? loadTable.ActualNetWeight : loadTable.LoadNetWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadOrderNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display order number of the load.
    /// </summary>
    /// <returns>
    /// The order number of the load.
    /// </returns>
    display WHSOrderNum displayLoadOrderNum()
    {
        return this.whsLoadTable().OrderNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadSchedShipDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display the scheduled ship date of the load.
    /// </summary>
    /// <returns>
    /// The scheduled ship date of the load.
    /// </returns>
    display WHSLoadSchedShipDate displayLoadSchedShipDate()
    {
        return this.whsLoadTable().loadSchedShipDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadTractorNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display the tractor number of the load.
    /// </summary>
    /// <returns>
    /// The tractor number of the load.
    /// </returns>
    display TMSTractorNumber displayLoadTractorNumber()
    {
        return this.whsLoadTable().TractorNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadTrailerNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display the trailer number of the load.
    /// </summary>
    /// <returns>
    /// Trailer number of the load.
    /// </returns>
    display WHSTrailerNumber displayLoadTrailerNumber()
    {
        return this.whsLoadTable().TrailerNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadVolume</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display volume of the load.
    /// </summary>
    /// <returns>
    /// The volume of the load.
    /// </returns>
    display WHSLoadTipVolume displayLoadVolume()
    {
        return this.whsLoadTable().LoadTipVolume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayLoadWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display weight of the load.
    /// </summary>
    /// <returns>
    /// The weight of the load.
    /// </returns>
    display WHSLoadTipWeight displayLoadWeight()
    {
        return this.whsLoadTable().LoadTipWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderHold</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(true)]
    display MCROrderStopped orderHold()
    {
        return ASOHOrderManagement::setOrderStopped(this, ASOHRelatedDocuments::Shipment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayOrderedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display ordered quantity of the load line.
    /// </summary>
    /// <returns>
    /// The ordered quantity of the load line.
    /// </returns>
    display ProductQuantity displayOrderedQty()
    {
        Qty         orderedQty;
        SalesLine   salesLine = this.getOrderCommonFromLoadLine() as SalesLine;

        if (salesLine.RecId)
        {
            orderedQty = salesLine.SalesQty;
        }

        return orderedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayOrderedUOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display UOM of the ordered item in the load line.
    /// </summary>
    /// <returns>
    /// The UOM of the ordered item in the load line.
    /// </returns>
    display UnitOfMeasureSymbol displayOrderedUOM()
    {
        UnitOfMeasureSymbol salesUnit;
        SalesLine           salesLine = this.getOrderCommonFromLoadLine() as SalesLine;

        if (salesLine.RecId)
        {
            salesUnit = salesLine.SalesUnit;
        }

        return salesUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPackingZoneId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display packing zone id of the load line.
    /// </summary>
    /// <returns>
    /// The packing zone id of the load line.
    /// </returns>
    display WHSZoneId displayPackingZoneId()
    {
        WHSWorkLine     workLine;
        WMSLocation     wmsLocation;
        WHSWorkTable    workTable;

        select firstonly WorkId from workLine
            join WorkId from workTable
            where workTable.WorkId   == workLine.WorkId
                join firstonly ZoneId from wmsLocation
                where workLine.LoadLineRefRecId     == this.RecId                   &&
                      workLine.WorkStatus           != WHSWorkStatus::Cancelled     &&
                      wmsLocation.wmsLocationId     == workLine.wmsLocationId       &&
                      wmsLocation.InventLocationId  == workTable.InventLocationId;

        return wmsLocation.ZoneId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPickUpDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the Pick up date for the shipment line.
    /// </summary>
    /// <returns>
    ///     The Pick up date for the shipment line.
    /// </returns>
    public display TransDate displayPickUpDate()
    {
        TransDate           ret;
        Common              orderLine;
        SalesLine           salesLine;
        InventTransferLine  inventTransferLine;

        if (this.LoadDirection == WHSLoadDirection::Inbound)
        {
            ret = WHSShipmentTable::find(this.ShipmentId).shipmentArrivalDate();
        }
        else if (this.LoadDirection == WHSLoadDirection::Outbound)
        {
            orderLine = this.getOrderCommonFromLoadLine();

            if (orderLine is SalesLine)
            {
                salesLine = orderLine as SalesLine;

                ret = salesLine.deliveryDate();
            }

            if (orderLine is InventTransferLine)
            {
                inventTransferLine = orderLine as InventTransferLine;

                ret = inventTransferLine.ShipDate;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displaySalesLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display sales line number of the load line.
    /// </summary>
    /// <returns>
    /// The sales line number of the load line.
    /// </returns>
    display LineNum displaySalesLineNum()
    {
        return this.salesLine().LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCWItem</Name>
				<Source><![CDATA[
    private boolean isCWItem()
    {
        return PdsGlobal::pdsIsCWItem(this.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalSalesLineValue</Name>
				<Source><![CDATA[
    private Amount totalSalesLineValue(SalesLine _salesLine)
    {
        InventHandlingQty handlingQty = (this.isCWItem() ? _salesLine.PdsCWQty : _salesLine.QtyOrdered);

        return this.totalLineValue(handlingQty, _salesLine.LineAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalPurchLineValue</Name>
				<Source><![CDATA[
    private Amount totalPurchLineValue(PurchLine _purchLine)
    {
        InventHandlingQty handlingQty = (this.isCWItem() ? _purchLine.PdsCWQty : _purchLine.QtyOrdered);

        return this.totalLineValue(handlingQty, _purchLine.LineAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalLineValue</Name>
				<Source><![CDATA[
    private Amount totalLineValue(InventHandlingQty _orderHandlingQty, Amount _lineAmount)
    {
        Amount amount;

        if (_orderHandlingQty)
        {
            amount = (this.InventQty / _orderHandlingQty) * _lineAmount;
        }

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display the total value of a load line.
    /// </summary>
    /// <returns>
    /// The total value of a load line.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public Amount displayTotalValue()
    {
        SalesLine           salesLine;
        PurchLine           purchLine;
        Amount              ret;

        switch (this.InventTransType)
        {
            case InventTransType::Sales:
                ret = this.totalSalesLineValue(this.salesLine());

                break;

            case InventTransType::Purch:
                ret = this.totalPurchLineValue(this.purchLine());
                break;

            case InventTransType::TransferOrderShip:
                InventTableModule inventTableModule = InventTableModule::find(this.ItemId, ModuleInventPurchSales::Invent);
                ret = this.InventQty * inventTableModule.Price / (inventTableModule.PriceUnit ? inventTableModule.PriceUnit : 1);
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWorkLineCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display number of work lines completed.
    /// </summary>
    /// <returns>
    /// The number of work lines completed.
    /// </returns>
    Qty displayWorkLineCompleted()
    {
        WHSWorkLine         workLine;

        select count(InventQtyWork) from workLine
            where workLine.LoadLineRefRecId  == this.RecId   &&
                  workLine.WorkStatus        == WHSWorkStatus::Closed;

        return workLine.InventQtyWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWorkLineTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display number of work lines in total for the load line.
    /// </summary>
    /// <returns>
    /// The number of work lines in total.
    /// </returns>
    Qty displayWorkLineTotal()
    {
        WHSWorkLine         workLine;

        select count(InventQtyWork) from workLine
            where workLine.LoadLineRefRecId  == this.RecId
               && workLine.WorkStatus        != WHSWorkStatus::Cancelled;

        return workLine.InventQtyWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWorkStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display the status of the work created for the load line.
    /// </summary>
    /// <returns>
    /// The status of the work created for the load line.
    /// </returns>
    display WHSLoadUserDef1 displayWorkStatus()
    {
        str     ret;
        Qty     total = this.displayWorkLineTotal();

        if (total)
        {
            ret = strFmt("@WAX:PercentOfInitialPickWorkCompleted", this.displayWorkLineCompleted() / total * 100);
        }
        else
        {
            ret = "@WAX1674";
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderCommonFromLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the order line associated with the current record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The  order line record.
    /// </returns>
    public Common getOrderCommonFromLoadLine(boolean _forUpdate = false)
    {
        Common sourceOrder = this.sourceOrder(_forUpdate);

        // If there is no record found, and the buffer type has not been updated to the correct related table, throw an error.
        if (sourceOrder.RecId   == 0
        &&  sourceOrder.TableId == tableNum(Common))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return sourceOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasDimTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the loadLine has work which used dim tracking during execution
    /// </summary>
    /// <returns>
    /// true if the load line has work that used dim tracking; otherwise, false
    /// </returns>
    public boolean hasDimTracking()
    {
        WHSWorkLine     workLine;
        WHSDimTracking  dimTracking;

        select firstonly RecId from workLine
            where workLine.LoadLineRefRecId == this.RecId
                exists join dimTracking
                where dimTracking.LineNum   == workLine.LineNum
                &&    dimTracking.WorkId    == workLine.WorkId;

        return workLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Uses data from a Purchase Order Line to fill in data on the new Load Line.
    /// </summary>
    /// <param name="_purchLine">
    /// The Purchase Order Line that will be used for the new Load Line.
    /// </param>
    public void initFromPurchLine(PurchLine _purchLine)
    {
        this.LoadDirection      = WHSLoadDirection::Inbound;
        this.InventTransType    = InventTransType::Purch;
        this.OrderNum           = _purchLine.PurchId;
        this.InventTransId      = _purchLine.InventTransId;
        this.ItemId             = _purchLine.ItemId;
        this.InventDimId        = _purchLine.InventDimId;
        if (PdsGlobal::pdsIsCWItem(_purchLine.ItemId))
        {
            this.Qty            = _purchLine.PdsCWQty;
            this.UOM            = _purchLine.pdsCWUnitId();
        }
        else
        {
            this.Qty            = _purchLine.PurchQty;
            this.UOM            = _purchLine.PurchUnit;
        }
        this.OverDeliveryPct    = _purchLine.OverDeliveryPct;
        this.UnderDeliveryPct   = _purchLine.UnderDeliveryPct;

        this.LoadReadyToShipUTCDateTime = _purchLine.deliveryTransDateTime();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a load line record from a sales line.
    /// </summary>
    /// <param name="_salesLine">
    /// Sales line to be used to initialize.
    /// </param>
    public void initFromSalesLine(SalesLine _salesLine)
    {
        this.LoadDirection      = WHSLoadDirection::Outbound;
        this.InventTransType    = InventTransType::Sales;
        this.OrderNum           = _salesLine.SalesId;
        this.InventTransId      = _salesLine.InventTransId;
        this.ItemId             = _salesLine.ItemId;
        if (PdsGlobal::pdsIsCWItem(_salesLine.ItemId))
        {
            this.Qty            = _salesLine.PdsCWQty;
            this.UOM            = _salesLine.pdsCWUnitId();
        }
        else
        {
            this.Qty            = _salesLine.SalesQty;
            this.UOM            = _salesLine.SalesUnit;
        }
        this.InventDimId        = _salesLine.InventDimId;
        this.OverDeliveryPct    = _salesLine.OverDeliveryPct;
        this.UnderDeliveryPct   = _salesLine.UnderDeliveryPct;
        this.PackingQty         = WHSSalesLine::find(_salesLine.InventTransId).PackingQty;
        this.LoadReadyToShipUTCDateTime  = _salesLine.deliveryTransDateTime();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTransferLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the load line record from a transfer order line.
    /// </summary>
    /// <param name="_inventTransferLine">
    /// Transfer order line to be used to initialize.
    /// </param>
    void initFromTransferLine(InventTransferLine _inventTransferLine)
    {
        this.LoadDirection      = WHSLoadDirection::Outbound;
        this.InventTransType    = InventTransType::TransferOrderShip;
        this.OrderNum           = _inventTransferLine.TransferId;
        this.InventTransId      = _inventTransferLine.InventTransId;
        this.ItemId             = _inventTransferLine.ItemId;
        if (PdsGlobal::pdsIsCWItem(_inventTransferLine.ItemId))
        {
            this.Qty            = _inventTransferLine.PdsCWQtyTransfer;
            this.UOM            = _inventTransferLine.pdsCWUnitId();
        }
        else
        {
            this.Qty            = _inventTransferLine.QtyTransfer;
            this.UOM            = _inventTransferLine.UnitId;
        }
        this.InventDimId        = _inventTransferLine.InventDimId;
        this.PackingQty         = WHSInventTransferLine::find(_inventTransferLine.RecId).PackingQty;
        this.LoadReadyToShipUTCDateTime = _inventTransferLine.shipTransDateTime();
        this.OverDeliveryPct    = _inventTransferLine.OverDeliveryPct;
        this.UnderDeliveryPct   = _inventTransferLine.UnderDeliveryPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTransportRequestLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the current load line from a transport request line.
    /// </summary>
    /// <param name="_transportRequestLine">
    ///    The <c>TMSTransportRequestLine</c> buffer to initialize the current load line from.
    /// </param>
    public void initFromTransportRequestLine(TMSTransportRequestLine   _transportRequestLine)
    {
        this.TransportRequest           = NoYes::Yes;
        this.LoadDirection              = _transportRequestLine.LoadDirection;
        this.InventTransType            = _transportRequestLine.InventTransType;
        this.OrderNum                   = _transportRequestLine.TransportRequestId;
        this.InventTransId              = _transportRequestLine.InventTransId;
        this.ItemId                     = _transportRequestLine.ItemId;
        this.Qty                        = _transportRequestLine.Qty;
        this.UOM                        = _transportRequestLine.UOM;
        this.InventDimId                = _transportRequestLine.InventDimId;
        this.PackingQty                 = _transportRequestLine.PackingQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a load line record from an item.
    /// </summary>
    /// <param name="_inventTable">Item to be used to initialize.</param>
    private void initFromInventTable(InventTable _inventTable)
    {
        this.ItemId = _inventTable.ItemId;
        this.initializeItemWeight(_inventTable.NetWeight, _inventTable.TaraWeight);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeItemWeight</Name>
				<Source><![CDATA[
    protected void initializeItemWeight(ItemNetWeight _netWeight, ItemTaraWeight _taraWeight)
    {
        this.ItemNetWeight = _netWeight;
        this.ItemTareWeight = _taraWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record into the <c>WHSLoadLine</c> table.
    /// </summary>
    /// <param name="_assignOriginInfoToLoadTable">
    /// A boolean that determines if the origin info on the related <c>WHSLoadTable</c> table should be updated. For performance reasons this can be skipped and done later for scenarios where multiple lines are inserted for the same load.
    /// </param>
    /// <param name="_assignTransTemplateToLoadTable">
    /// A boolean that determines if the transportation template on the related <c>WHSLoadTable</c> table should be updated. For performance reasons this can be skipped and done later for scenarios where multiple lines are inserted for the same load.
    /// </param>
    /// </param>
    /// <param name="_assignEarliestSchedShipDateTime">
    /// A boolean that determines if scheduled ship date time on load should be updated to earlier requested ship date on order.
    /// </param>
    public void insert(
        boolean _assignOriginInfoToLoadTable = true,
        boolean _assignTransTemplateToLoadTable = true,
        boolean _assignEarliestSchedShipDateTime = true)
    {
        WHSLoadTable        loadTable;
        WHSShipmentTable    shipment;
        boolean             isShipmentTableBufferModified = false;
        boolean             isLoadTableBufferModified     = false;
        Qty                 qtyOrig;

        boolean             whsShipmentTableUpdateConflictOnLoadLineInsertFlightEnabled = WHSShipmentTableUpdateConflictOnLoadLineInsertFlight::instance().isEnabled();

        ttsbegin;

        this.initFromInventTable(InventTable::find(this.ItemId));

        if (PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            // Catch weight items hold load line quantities in the catch weight unit.
            this.InventQty = this.Qty;
        }
        else
        {
            if (this.InventQty)
            {
                qtyOrig = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.ItemId,
                                                                                                this.InventDimId,
                                                                                                this.InventQty,
                                                                                                InventTableModule::find(this.ItemId, ModuleInventPurchSales::Invent).UnitId,
                                                                                                this.UOM,
                                                                                                NoYes::No);
            }

            if (this.Qty != qtyOrig)
            {
                this.InventQty = InventTableModule::unitConvert(this.ItemId,
                                                                ModuleInventPurchSales::Invent,
                                                                this.UOM,
                                                                this.Qty,
                                                                this.InventDimId);
            }
        }

        if (!this.PackingQty)
        {
            this.setPackingQty();
        }

        // <GBR>
        if (!this.VolumeQty_BR && !this.VolumeType_BR && BrazilParameters::isEnabled())
        {
            this.initializeVolumeInformation_BR();
        }
        // </GBR>

        WHSLoadLineSyncInvalid::insert(this);

        this.onQuantityOnLoadChange(this.InventTransId, 0 - this.Qty);
        this.QtyLeftToStructure = this.Qty;

        this.validateNonNegativeWorkCreatedQty();

        super();

        WHSLoadLineInsertMethodParameters insertParameters = WHSLoadLineInsertMethodParameters::current();
        boolean skipWHSLoadTableUpdate;
        boolean forceShipmentQtyUpdates;

        if (insertParameters)
        {
            skipWHSLoadTableUpdate = insertParameters.skipWHSLoadTableUpdate;
            forceShipmentQtyUpdates = insertParameters.parmForceShipmentQtyUpdates();
        }

        if (this.LoadId || forceShipmentQtyUpdates)
        {
            if (this.mustCheckAndNotifyQtyOnShipmentChanged(0, this.Qty, this.UOM, this.UOM, '', this.ShipmentId))
            {
                this.checkAndNotifyQtyOnShipmentChanged(this.InventTransId, 0, this.Qty, this.UOM, this.UOM, this.ItemId, '', this.ShipmentId);
            }

            if (!whsShipmentTableUpdateConflictOnLoadLineInsertFlightEnabled)
            {
                shipment = WHSShipmentTable::find(this.ShipmentId, true);

                // Update shipment Status if currently Loaded
                if (shipment && shipment.ShipmentStatus == WHSShipmentStatus::Loaded)
                {
                    shipment.ShipmentStatus = WHSShipmentStatus::InProcess;
                    isShipmentTableBufferModified = true;
                }

                isShipmentTableBufferModified = this.initShipmentSiteAndWarehouseIfNeeded(shipment) || isShipmentTableBufferModified;
            }

            if (!skipWHSLoadTableUpdate)
            {
                loadTable = this.whsLoadTable(true);
                isLoadTableBufferModified = loadTable.assignLoadWeightsForLoadLine(this, this.InventQty);

                // Update load Status if currently Loaded
                if (loadTable.LoadStatus == WHSLoadStatus::Loaded)
                {
                    loadTable.LoadStatus = WHSLoadStatus::InProcess;
                    isLoadTableBufferModified = true;
                }

                if (!loadTable.InventLocationId && !loadTable.InventSiteId)
                {
                    // Update Site and Warehouse dimensions on load header based on current load line, if not set.
                    isLoadTableBufferModified = loadTable.assignSiteAndWarehouse(this.inventDim()) || isLoadTableBufferModified;
                }

                isLoadTableBufferModified = this.tmsSetCarrierOnOrigin(loadTable, false) || isLoadTableBufferModified;

                if (_assignOriginInfoToLoadTable)
                {
                    isLoadTableBufferModified = loadTable.assignOriginInfo(AddRemove::Add) || isLoadTableBufferModified;
                }

                if (_assignTransTemplateToLoadTable)
                {
                    isLoadTableBufferModified = loadTable.assignTransTemplate() || isLoadTableBufferModified;
                }

                if (_assignEarliestSchedShipDateTime)
                {
                    isLoadTableBufferModified = loadTable.assignEarliestSchedShipDateTime(this.LoadReadyToShipUTCDateTime) || isLoadTableBufferModified;
                }
            }
        }

        if (!skipWHSLoadTableUpdate
            && isLoadTableBufferModified)
        {
            loadTable.update();
        }

        //Update shipment record at the end of the method to prevent possible conflicts between updates 
        //made in this method and in loadTable.update().
        if (whsShipmentTableUpdateConflictOnLoadLineInsertFlightEnabled)
        {
            if (this.LoadId)
            {
                shipment = WHSShipmentTable::find(this.ShipmentId, true);

                // Update shipment Status if currently Loaded
                if (shipment && shipment.ShipmentStatus == WHSShipmentStatus::Loaded)
                {
                    shipment.ShipmentStatus = WHSShipmentStatus::InProcess;
                    isShipmentTableBufferModified = true;
                }

                isShipmentTableBufferModified = this.initShipmentSiteAndWarehouseIfNeeded(shipment) || isShipmentTableBufferModified;
            }
        }

        if (shipment && isShipmentTableBufferModified)
        {
            shipment.update();
        }

        if (this.ShipmentId || this.LoadId)
        {
            this.validateOnlyOneShipmentForOrder();
        }
        
        ttscommit;

        if (this.Invalid)
        {
            this.logLoadLineInvalidation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logLoadLineInvalidation</Name>
				<Source><![CDATA[
    private void logLoadLineInvalidation()
    {
        WHSInstrumentationLogger logger = WHSInstrumentationLogger::createLogger(tableId2Name(this.TableId));
        logger.logInformation(strFmt('{"WHSLoadLine.RecId":%1"} was invalidated', this.RecId));
        logger.logCallStack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initShipmentSiteAndWarehouseIfNeeded</Name>
				<Source><![CDATA[
    private boolean initShipmentSiteAndWarehouseIfNeeded(WHSShipmentTable _shipment)
    {
        boolean isShipmentTableBufferModified;

        if (_shipment.RecId != 0
            && !_shipment.InventLocationId)
        {
            // One scenario where this can happen is if ASN is imported through data enties (e.g. WHSInboundASNV3Entity).
            _shipment.assignSiteAndWarehouse(this.inventDim());
            isShipmentTableBufferModified = true;
        }

        return isShipmentTableBufferModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the inventory dimensions of the load line.
    /// </summary>
    /// <param name="_forUpdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The inventory dimensions of the load line.
    /// </returns>
    InventDim inventDim(boolean  _forUpdate = false)
    {
        return InventDim::find(this.InventDimId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>InventTable</c> buffer associated with the current load line.
    /// </summary>
    /// <returns>
    ///    A <c>InventTable</c> buffer.
    /// </returns>
    public InventTable inventTable()
    {
        return InventTable::find(this.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransferLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the transfer order line associated with the current record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The transfer order line record.
    /// </returns>
    [Hookable(false), Wrappable(false)]
    public InventTransferLine inventTransferLine(boolean _forUpdate = false)
    {
        InventTransferLine      inventTransferLine;

        if (this.InventTransType == InventTransType::TransferOrderShip)
        {
            inventTransferLine = InventTransferLine::findTransIdShip(this.InventTransId, _forUpdate);
        }

        return inventTransferLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransferTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the transfer order header associated with the current record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The transfer order header record.
    /// </returns>
    private InventTransferTable inventTransferTable(boolean _forUpdate = false)
    {
        InventTransferTable     inventTransferTable;

        if (this.InventTransType == InventTransType::TransferOrderShip && this.TransportRequest == NoYes::No)
        {
            inventTransferTable = InventTransferTable::find(this.OrderNum, _forUpdate);
        }

        return inventTransferTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadLineNetWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the net weight of the load line.
    /// </summary>
    /// <returns>
    /// The net weight of the load line.
    /// </returns>
    Weight loadLineNetWeight()
    {
        return this.InventQty * InventTable::find(this.ItemId).NetWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadLineVolume</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total volume for the load line.
    /// </summary>
    /// <returns>
    /// The volume of the load line.
    /// </returns>
    Volume loadLineVolume()
    {
        return this.InventQty * InventTable::find(this.ItemId).UnitVolume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadLineWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the gross weight of the load line.
    /// </summary>
    /// <returns>
    /// The gross weight of the load line.
    /// </returns>
    public Weight loadLineWeight()
    {
        return this.InventQty * this.grossWeight();
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the order header associated with the current record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The order header record.
    /// </returns>
    public Common orderHeader(boolean _forUpdate = false)
    {
        if (this.TransportRequest == NoYes::No)
        {
            return this.findOrderHeaderInternal(_forUpdate);
        }

        return this.tmsTransportRequestTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrderHeaderInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the order header based on module.
    /// </summary>
    /// <param name = "_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>The order header record.</returns>
    private Common findOrderHeaderInternal(boolean _forUpdate)
    {
        switch (this.InventTransType)
        {
            case InventTransType::Sales:
                return this.salesTable(_forUpdate);

            case InventTransType::Purch:
                return this.purchTable(_forUpdate);

            case InventTransType::TransferOrderShip:
                return this.inventTransferTable(_forUpdate);

            default:
                return this.findOrderHeader(_forUpdate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrderHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the order header based on module.
    /// </summary>
    /// <param name = "_forUpdate">A Boolean value that indicates whether to read the record for update; optional.</param>
    /// <returns>The order header record.</returns>
    [Replaceable]
    protected Common findOrderHeader(boolean _forUpdate)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderLineReadyToShipDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the shipping date and time from the order line associated with the current load line.
    /// </summary>
    /// <returns>
    ///    The shipping date and time.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///    An unsupported transaction type is discovered.
    /// </exception>
    public TransDateTime orderLineReadyToShipDateTime()
    {
        WHSLoadReadyToShipUTCDateTime   readyToShipDateTime;
        Common                          orderLine;
        PurchLine                       purchLine;
        SalesLine                       salesLine;
        InventTransferLine              inventTransferLine;

        orderLine = this.getOrderCommonFromLoadLine();

        switch (this.InventTransType)
        {
            case InventTransType::Sales:
                salesLine = orderLine as SalesLine;
                readyToShipDateTime = salesLine.deliveryTransDateTime();
                break;

            case InventTransType::Purch:
                purchLine = orderLine as PurchLine;
                readyToShipDateTime = purchLine.deliveryTransDateTime();
                break;

            case InventTransType::TransferOrderShip:
                inventTransferLine = orderLine as InventTransferLine;
                readyToShipDateTime = inventTransferLine.shipTransDateTime();
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return readyToShipDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipUpdatedInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the packing slip updated inventory quantity for an load line.
    /// </summary>
    /// <returns>
    /// A inventory quantity.
    /// </returns>
    public InventQty packingSlipUpdatedInventQty()
    {
        InventQty       packingSlipQty;
        PdsInventQty    packingSlipCWQty;

        [packingSlipQty, packingSlipCWQty] = this.packingSlipQuantities();

        return packingSlipQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipUpdatedQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the packing slip updated inventory quantities for an load line.
    /// </summary>
    /// <returns>
    /// The inventory quantity and catch weight quantity as a container.
    /// </returns>
    [Hookable(false)]
    internal container packingSlipUpdatedQuantities()
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), this.ItemId))
        {
            InventQty packingSlipQty;

            packingSlipQty = this.packingSlipUpdatedInventQty();

            return [packingSlipQty, 0];
        }

        return this.packingSlipQuantities();
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipQuantities</Name>
				<Source><![CDATA[
    private container packingSlipQuantities()
    {
        CustPackingSlipJour                 custPackingSlipJour;
        CustPackingSlipTrans                custPackingSlipTrans;
        WHSLoadTableCustPackingSlipJour     whsLoadTableCustPackingSlipJour;

        if (this.LoadId && this.InventTransId)
        {
            select sum(InventQty), sum(PdsCWQty) from custPackingSlipTrans
                where custPackingSlipTrans.InventTransId == this.InventTransId
                join RecId from custPackingSlipJour
                    where custPackingSlipJour.PackingSlipId == custPackingSlipTrans.PackingSlipId
                        && custPackingSlipJour.SalesId      == custPackingSlipTrans.SalesId
                        && custPackingSlipJour.DeliveryDate == custPackingSlipTrans.DeliveryDate
                    exists join whsLoadTableCustPackingSlipJour
                        where whsLoadTableCustPackingSlipJour.whsLoadTableLoadId        == this.LoadId
                            && whsLoadTableCustPackingSlipJour.whsLoadTableDataAreaId   == this.DataAreaId
                            && whsLoadTableCustPackingSlipJour.CustPackingSlipJourRecId == custPackingSlipJour.RecId;
        }
        return [custPackingSlipTrans.InventQty, custPackingSlipTrans.PdsCWQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentInventTransferTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the parent transfer order header associated with the current record.
    /// </summary>
    /// <returns>
    ///    The parent transfer order header record.
    /// </returns>
    private InventTransferTable parentInventTransferTable()
    {
        InventTransferTable     inventTransferTable;

        if (this.ParentInventTransType == InventTransType::TransferOrderShip)
        {
            inventTransferTable = InventTransferTable::find(this.ParentOrderNum);
        }

        return inventTransferTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentOrderHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the parent order header associated with the current record.
    /// </summary>
    /// <returns>
    ///    The parent order header record.
    /// </returns>
    public Common parentOrderHeader()
    {
        Common      ret;

        switch (this.ParentInventTransType)
        {
            case InventTransType::Sales:
                ret = this.parentSalesTable();
                break;

            case InventTransType::Purch:
                ret = this.parentPurchTable();
                break;

            case InventTransType::TransferOrderShip:
                ret = this.parentInventTransferTable();
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the parent purchase order header associated with the current record.
    /// </summary>
    /// <returns>
    ///    The parent purchase order header record.
    /// </returns>
    private PurchTable parentPurchTable()
    {
        PurchTable   purchTable;

        if (this.ParentInventTransType == InventTransType::Purch)
        {
            purchTable = PurchTable::find(this.ParentOrderNum);
        }

        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the parent sales order header associated with the current record.
    /// </summary>
    /// <returns>
    ///    The parent sales order header record.
    /// </returns>
    private SalesTable parentSalesTable()
    {
        SalesTable   salesTable;

        if (this.ParentInventTransType == InventTransType::Sales)
        {
            salesTable = SalesTable::find(this.ParentOrderNum);
        }

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayVendName</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal display VendName displayVendName()
    {
        PurchLine purchLine = this.purchLine();
        return purchLine ? purchLine.purchTable().vendorName() : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the purchase order line associated with the current record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The purchase order line record.
    /// </returns>
    [Hookable(false), Wrappable(false)]
    public PurchLine purchLine(boolean _forUpdate = false)
    {
        PurchLine   purchLine;

        if (this.InventTransType == InventTransType::Purch)
        {
            purchLine = PurchLine::findInventTransId(this.InventTransId, _forUpdate);
        }

        return purchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayVendAccount</Name>
				<Source><![CDATA[
    display VendAccount displayVendAccount()
    {
        return this.purchLine().VendAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the purchase order header associated with the current record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The purchase order header record.
    /// </returns>
    private PurchTable purchTable(boolean _forUpdate = false)
    {
        PurchTable   purchTable;

        if (this.InventTransType == InventTransType::Purch && this.TransportRequest == NoYes::No)
        {
            purchTable = PurchTable::find(this.OrderNum, _forUpdate);
        }

        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyLeftToLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the remaining quantity to be placed on load
    /// </summary>
    /// <returns>
    /// Returns the quantity available to be put on a load
    /// </returns>
    public WHSQtyLeftToLoad qtyLeftToLoad()
    {
        InventHandlingQty qtyLeftToLoad;

        if (this.TransportRequest)
        {
            TMSTransportRequestLine transportRequestLine = TMSTransportRequestLine::findByInventTransIdOrderNumInventDimId(this.InventTransId, this.OrderNum, this.InventDimId);
            qtyLeftToLoad = transportRequestLine.qtyLeftToTransportInInventQty();
        }
        else
        {
            switch (this.InventTransType)
            {
                case InventTransType::Purch:
                    qtyLeftToLoad = WHSPurchLine::find(this.InventTransId).handlingQtyLeftToLoad();
                    break;

                default:
                    WHSInventTransSumDim inventTransSumDim;

                    select firstonly SumOfQty, SumOfPdsCWQty from inventTransSumDim
                    where inventTransSumDim.InventTransId == this.InventTransId
                        && inventTransSumDim.InventDimId  == this.InventDimId;

                    qtyLeftToLoad = inventTransSumDim.displayQtyLeftToLoadOutbound();
            }
        }

        return qtyLeftToLoad;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the sales order line associated with the current record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The sales order line record.
    /// </returns>
    [Hookable(false), Wrappable(false)]
    public SalesLine salesLine(boolean _forUpdate = false)
    {
        SalesLine   salesLine;

        if (this.InventTransType == InventTransType::Sales)
        {
            salesLine = SalesLine::findInventTransId(this.InventTransId, _forUpdate);
        }

        return salesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the sales order header associated with the current record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The sales order header record.
    /// </returns>
    private SalesTable salesTable(boolean _forUpdate = false)
    {
        SalesTable   salesTable;

        if (this.InventTransType == InventTransType::Sales && this.TransportRequest == NoYes::No)
        {
            salesTable = SalesTable::find(this.OrderNum, _forUpdate);
        }

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPackingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the packing quantity of the load line determined by transaction type.
    /// </summary>
    void setPackingQty()
    {
        switch (this.InventTransType)
        {
            case InventTransType::Sales:
                this.PackingQty = WHSSalesLine::find(this.InventTransId).PackingQty;
                break;

            case InventTransType::TransferOrderShip:
                this.PackingQty = WHSInventTransferLine::findByInventTransId(this.InventTransId).PackingQty;
                break;

            default:
                this.PackingQty = WHSInventTable::getDefaultPackingQty(this.ItemId, this.InventDimId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsDisplayAppointmentId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display appointment id of the load.
    /// </summary>
    /// <returns>
    /// The appointment id of the load.
    /// </returns>
    display TMSApptId tmsDisplayAppointmentId()
    {
        return this.whsLoadTable().tmsDisplayAppointmentId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsDisplayRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display route code of the load.
    /// </summary>
    /// <returns>
    /// The route code of the load.
    /// </returns>
    display TMSRouteCode tmsDisplayRoute()
    {
        return this.whsLoadTable().RouteCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsSetCarrierOnOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Set the Carrier information on the load.
    /// </summary>
    /// <param name="_loadTable">
    ///     The <c>WHSLoadTable</c> buffer to initialize Carrier on it.
    /// </param>
    /// <param name="doWrite">
    ///     After setting the Carrier, call the write method on the <c>WHSLoadTable</c> buffer
    /// </param>
    /// <remarks>
    ///     if the _loadTable is null, the <c>WHSLoadTable</c> buffer will be instantiated.
    /// </remarks>
    /// <returns>
    ///    Return true if <c>WHSLoadTable</c> buffer was modified; otherwise, false
    /// </returns>
    public boolean tmsSetCarrierOnOrigin(WHSLoadTable _loadTable = null, boolean doWrite = true)
    {
        WHSLoadTable    loadTable;
        SalesLine       salesLine;

        boolean isModified  = false;

        if (this.TransportRequest == NoYes::No)
        {
            ttsbegin;

            loadTable = (_loadTable.RecId != 0) ? _loadTable : this.whsLoadTable(true);

            switch (this.InventTransType)
            {
                case InventTransType::Sales:
                    salesLine = this.getOrderCommonFromLoadLine() as SalesLine;
                    isModified = loadTable.assignCarrierOnOrigin_Sales(this.OrderNum,salesLine);
                    break;

                case InventTransType::Purch:
                    isModified = loadTable.assignCarrierOnOrigin_Purch(this.OrderNum);
                    break;

                case InventTransType::TransferOrderShip:
                    isModified = loadTable.assignCarrierOnOrigin_Transfer(this.OrderNum);
                    break;
            }

            if (doWrite && isModified)
            {
                loadTable.write();
            }

            ttscommit;
        }

        return isModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsTransportRequestTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the transport request associated with the current record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    The transport request record.
    /// </returns>
    public TMSTransportRequestTable tmsTransportRequestTable(boolean _forUpdate = false)
    {
        TMSTransportRequestTable    transportRequestTable;

        if (this.TransportRequest == NoYes::Yes)
        {
            transportRequestTable = TMSTransportRequestTable::find(this.OrderNum, _forUpdate);
        }

        return transportRequestTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertLoadLineNotPartOfWaveInProcess</Name>
				<Source><![CDATA[
    private void assertLoadLineNotPartOfWaveInProcess()
    {
        if (WHSWaveUpdatedLoadLine::existForLoadLine(this.RecId))
        {
            throw error("@WAX:LoadLineCannotBeUpdatedDuringWaveProcessing");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates load line quantities based on load line prior to any quantity updates.
    /// </summary>
    /// <param name = "_origLoadLine">The load line record.</param>
    protected void updateRelatedQuantities(WHSLoadLine _origLoadLine)
    {
        UnitOfMeasureSymbol inventHandlingUOM = WHSCatchWeightHelper::inventHandlingUnitId(this.ItemId);
        Qty origworkCreatedQtyInLoadUnit = this.convertQtyWithUnitToLoadUnitOfMeasure(_origLoadLine.WorkCreatedQty, inventHandlingUOM);
        Qty newWorkCreatedQtyInLoadUnit = this.convertQtyWithUnitToLoadUnitOfMeasure(this.WorkCreatedQty, inventHandlingUOM);

        if (_origLoadLine.UOM == this.UOM)
        {
            Qty updateQty = max(_origLoadLine.Qty, origworkCreatedQtyInLoadUnit) - max(this.Qty, newWorkCreatedQtyInLoadUnit);
            if (updateQty)
            {
                this.onQuantityOnLoadChange(this.InventTransId, updateQty);
                this.QtyLeftToStructure = this.QtyLeftToStructure - updateQty;
            }
        }
        else
        {
            Qty origQtyInLoadUnit = this.convertQtyToLoadUnitOfMeasure(_origLoadLine.Qty, _origLoadLine);
            Qty updateQty = max(origQtyInLoadUnit, origworkCreatedQtyInLoadUnit) - max(this.Qty, newWorkCreatedQtyInLoadUnit);
            if (updateQty)
            {
                this.onQuantityOnLoadChange(this.InventTransId, updateQty, _origLoadLine.UOM, this.UOM, this.ItemId);
                this.QtyLeftToStructure = this.convertQtyToLoadUnitOfMeasure(this.QtyLeftToStructure, _origLoadLine) - updateQty;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onQuantityOnLoadChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the quantity left to load for non transport requests, based on the inventory transaction type.
    /// </summary>
    /// <param name = "_inventTransId">The inventory transaction ID.</param>
    /// <param name = "_qty">The quantity being updated.</param>
    /// <param name = "_unitFrom">The from unit of measure.</param>
    /// <param name = "_unitTo">The to unit of measure</param>
    /// <param name = "_itemId">The item ID.</param>
    /// <param name = "_delete">Boolean indicating whether the record is being deleted.</param>
    [Wrappable(true), Replaceable(true)]
    internal void onQuantityOnLoadChange(
        InventTransId _inventTransId,
        Qty _qty,
        WHSUOM _unitFrom = '',
        WHSUOM _unitTo = '',
        ItemId _itemId = '',
        boolean _delete = false)
    {
        this.updateQtyLeftToLoad(_inventTransId, _qty, _unitFrom, _unitTo, _itemId, _delete);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelPlannedCrossDockQtyWhenDecreasingLoadLineInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels the planned cross docking for a quantity of the passed parameter when decreasing Load Line InventQty.
    /// </summary>
    /// <param name="_plannedCrossDockQtyToCancel">
    /// The qty that has to be reduced from the cross dock load line associated to the current load line.
    /// </param>   
    private void cancelPlannedCrossDockQtyWhenDecreasingLoadLineInventQty(InventHandlingQty _plannedCrossDockQtyToCancel)
    {
        WHSCrossDockLoadLine crossDockLoadLine;
        WHSCrossDockLoadLineMinCorrespondingInventTransDateExpectedView crossDockLoadLineMinCorrespondingInventTransDateExpectedView;             

        // Filtering first on crossDockLoadLine.LoadLineRecId should be the most selective for this query.
        // forceSelectOrder and forceNestedLoop are used to make sure that the query starts the query execution from crossDockLoadLine
        // and a nested loop join is used to avoid having to perform the heavy operation of the WHSCrossDockLoadLineMinCorrespondingInventTransDateExpectedView view 
        // without having the filter from the crossDockLoadLine.
        while select forceSelectOrder forceNestedLoop forupdate crossDockLoadLine
            order by crossDockLoadLineMinCorrespondingInventTransDateExpectedView.MinDateExpected desc
            where crossDockLoadLine.LoadLineRecId == this.RecId
               && crossDockLoadLine.InventHandlingQtyRemain > 0
        join crossDockLoadLineMinCorrespondingInventTransDateExpectedView
            where crossDockLoadLineMinCorrespondingInventTransDateExpectedView.WHSCrossDockLoadLineRecId == crossDockLoadLine.RecId        
        {
            if (_plannedCrossDockQtyToCancel <= 0)
            {
                break;
            }

            InventHandlingQty availableQtyToReduceFromCrossDockLoadLine 
                = min(_plannedCrossDockQtyToCancel, crossDockLoadLine.InventHandlingQtyRemain);

            if (availableQtyToReduceFromCrossDockLoadLine > 0)
            {
                crossDockLoadLine.reduceCrossDockLoadLineQuantity(availableQtyToReduceFromCrossDockLoadLine);

                this.CrossDockQuantity -= availableQtyToReduceFromCrossDockLoadLine;

                this.CrossDockEvaluatedQuantity -= availableQtyToReduceFromCrossDockLoadLine;

                _plannedCrossDockQtyToCancel -= availableQtyToReduceFromCrossDockLoadLine;
            }
        }     
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNonCrossDockWorkCreatedQuantityForLoadLine</Name>
				<Source><![CDATA[
    private InventHandlingQty calculateNonCrossDockWorkCreatedQuantityForLoadLine()
    {
        WHSCrossDockLoadLine crossDockLoadLine; 

        select sum(InventHandlingQty), sum(InventHandlingQtyRemain) from crossDockLoadLine
            where crossDockLoadLine.LoadLineRecId == this.RecId;

        InventHandlingQty crossDockWorkCreatedForCurrentLoadLine = crossDockLoadLine.InventHandlingQty - crossDockLoadLine.InventHandlingQtyRemain;

        return this.WorkCreatedQty - crossDockWorkCreatedForCurrentLoadLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCrossDockRelatedQuantitiesWhenDecreasingInventQty</Name>
				<Source><![CDATA[
    private void updateCrossDockRelatedQuantitiesWhenDecreasingInventQty(InventHandlingQty _origInventQty, InventHandlingQty _newInventQty)
    {
        InventHandlingQty qtyToDecrease = _origInventQty - _newInventQty;

        InventHandlingQty nonCrossDockWorkCreatedQuantity = max(0, this.calculateNonCrossDockWorkCreatedQuantityForLoadLine());

        InventHandlingQty availableCrossDockReservedPhysicalToBeDecreased = min(this.CrossDockReservedPhysical - nonCrossDockWorkCreatedQuantity, qtyToDecrease);

        if (availableCrossDockReservedPhysicalToBeDecreased > 0)
        {
            this.CrossDockReservedPhysical -= availableCrossDockReservedPhysicalToBeDecreased;

            this.CrossDockEvaluatedQuantity -= availableCrossDockReservedPhysicalToBeDecreased;

            qtyToDecrease -= availableCrossDockReservedPhysicalToBeDecreased;
        }

        if (qtyToDecrease > 0)
        {
            this.cancelPlannedCrossDockQtyWhenDecreasingLoadLineInventQty(qtyToDecrease);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustRecalculateCrossDockLoadLineWhenDecreaseInventQty</Name>
				<Source><![CDATA[
    private boolean mustRecalculateCrossDockLoadLineWhenDecreaseInventQty()
    {
        var skipCrossDockLoadLineRecalculation = WHSSkipCrossDockLoadLineRecalculationWhenDecreaseLoadLineInventQtyContext::current();

        return !skipCrossDockLoadLineRecalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCrossDockReservedPhysicalQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates cross docking physical reserved quantity.
    /// </summary>
    /// <param name = "_origInventQty">Original inventory quantity.</param>
    /// <param name = "_newInventQty">New inventory quantity.</param>
    [Hookable(false)]
    internal void updateCrossDockReservedPhysicalQuantity(
        InventHandlingQty _origInventQty,
        InventHandlingQty _newInventQty)
    {
        // Update the CrossDockReservedPhysical only if we are decreasing the loadLine's less than the crossDocking and CrossDockReservedPhysical quantities
        if (this.InventQty < this.CrossDockReservedPhysical + this.CrossDockQuantity)
        {                      
            if (this.mustRecalculateCrossDockLoadLineWhenDecreaseInventQty())
            {
                this.updateCrossDockRelatedQuantitiesWhenDecreasingInventQty(_origInventQty, _newInventQty);   
            }
            else
            {
                this.CrossDockReservedPhysical -= _origInventQty - _newInventQty;
            }            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateIfAllowedToModify</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal void validateIfAllowedToModify()
    {
        if (this.orig().ShipmentId != this.ShipmentId
            || this.orig().LoadId != this.LoadId
            || this.orig().Qty != this.Qty)
        {
            this.validateOnlyOneShipmentForOrder();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a record in the <c>WHSLoadLine</c> table.
    /// </summary>
    /// <param name="_isConsolidation">
    ///     A boolean that determines whether the update to the load line is a result of consolidation.
    /// </param>
    /// <param name="_updateScheduledShipDateTime">
    ///     A boolean that determines whether scheduled ship date time on load should be updated to requested ship date and time on order.
    /// </param>
    public void update(boolean _isConsolidation = false, boolean _updateScheduledShipDateTime = true)
    {
        this.validateIfAllowedToModify();

        WHSLoadLine         otherLoadLine;
        WHSLoadTable        origLoadTable;

        // if the line is invalid, all updates are disallowed
        // the only recourse for users is to delete the line
        if (this.Invalid)
        {
            WHSWaveProcessingDataCleanupContext context = WHSWaveProcessingDataCleanupContext::current();

            boolean loadlineInvalidFieldErrorLabelFlightEnabled = WHSLoadlineInvalidFieldErrorLabelFlight::instance().isEnabled();

            if (context && context.skipThrowError)
            {
                if (context.waveProcessingDataCleanupInstrumentationLogger)
                {
                    WHSInstrumentationLogger waveProcessingDataCleanupInstrumentationLogger = context.waveProcessingDataCleanupInstrumentationLogger;
                    waveProcessingDataCleanupInstrumentationLogger.waveProcessingDataCleanupActivities().loadLineUpdate();
                    waveProcessingDataCleanupInstrumentationLogger.waveProcessingDataCleanupActivities().logWhsLoadLineUpdate("@WAX5534", this.RecId, this.whsLoadTable().RecId, context.waveExecutionId);

                    if (loadlineInvalidFieldErrorLabelFlightEnabled)
                    {
                        error(strFmt("@WAX:WHSLoadLineInvalidError", this.LoadId, this.ShipmentId, this.ItemId, this.InventTransId));
                    }
                    else
                    {
                        error(strFmt("@WAX5534",this.LoadId,this.ItemId,this.InventTransId));
                    }
                }
            }
            else
            {
                if (loadlineInvalidFieldErrorLabelFlightEnabled)
                {
                    throw error(strFmt("@WAX:WHSLoadLineInvalidError", this.LoadId, this.ShipmentId, this.ItemId, this.InventTransId));
                }
                else
                {
                    throw error(strFmt("@WAX5534",this.LoadId,this.ItemId,this.InventTransId));
                }
            }
        }

        WHSLoadLine origLoadLine = this.orig();

        if (origLoadLine.Qty != this.Qty || origLoadLine.UOM != this.UOM)
        {
            this.assertLoadLineNotPartOfWaveInProcess();
        }

        boolean changedQty = origLoadLine.Qty != this.Qty || origLoadLine.UOM != this.UOM || origLoadLine.WorkCreatedQty != this.WorkCreatedQty;

        if (changedQty)
        {
            this.updateRelatedQuantities(origLoadLine);

            if (origLoadLine.UOM != this.UOM)
            {
                WHSASNItem::convertToUnit(this, this.UOM);
            }
        }

        if (this.QtyLeftToStructure < 0)
        {
            this.QtyLeftToStructure = 0;
        }

        this.setInventQty();

        if (this.InventQty < origLoadLine.InventQty)
        {
            this.updateCrossDockReservedPhysicalQuantity(origLoadLine.InventQty, this.InventQty);
        }

        if (this.mustCheckAndNotifyQtyOnShipmentChanged(origLoadLine.Qty, this.Qty, origLoadLine.UOM, this.UOM, origLoadLine.ShipmentId, this.ShipmentId))
        {
            this.checkAndNotifyQtyOnShipmentChanged(this.InventTransId, origLoadLine.Qty, this.Qty, origLoadLine.UOM, this.UOM, this.ItemId, origLoadLine.ShipmentId, this.ShipmentId);
        }

        if (this.LoadId != origLoadLine.LoadId)
        {
            select firstonly RecId from otherLoadLine
                where otherLoadLine.LoadId  == origLoadLine.LoadId &&
                      otherLoadLine.RecId   != this.RecId;

            if (otherLoadLine.RecId == 0)
            {
                origLoadTable = WHSLoadTable::find(origLoadLine.LoadId, true);
            }
            else
            {
                origLoadTable.clear();
            }
        }

        // <GBR>
        if (BrazilParameters::isEnabled() && this.shouldInitializeVolumeQuantity_BR())
        {
            this.initializeVolumeQuantity_BR();
        }
        // </GBR>

        WHSLoadLineSyncInvalid::update(this);

        this.validateNonNegativeWorkCreatedQty();

        super();

        if (origLoadTable)
        {
            ttsbegin;
            origLoadTable.delete();
            ttscommit;
        }

        WHSLoadLineInsertMethodParameters insertParameters = WHSLoadLineInsertMethodParameters::current();
        boolean skipWHSLoadTableUpdate;

        if (insertParameters)
        {
            skipWHSLoadTableUpdate = insertParameters.skipWHSLoadTableUpdate;
        }

        // If Qty on load line has changed, update status of shipment and load
        if (changedQty)
        {
            // Update load status
            if (!skipWHSLoadTableUpdate
                && WHSLoadTable::exist(this.LoadId))
            {
                WHSLoadStatusUpdater loadStatusUpdater = WHSLoadStatusUpdater::newFromLoadId(this.LoadId);
                loadStatusUpdater.parmUpdatedLoadLine(this);
                loadStatusUpdater.updateWhenLoadLineUpdated();
            }

            if (WHSShipmentTable::exist(this.ShipmentId))
            {
                WHSShipmentStatusUpdater shipmentStatusUpdater = WHSShipmentStatusUpdater::newFromShipmentId(this.ShipmentId);
                shipmentStatusUpdater.updateWhenLoadLineUpdated();
            }
        }

        // Modify load weight
        if (!skipWHSLoadTableUpdate
            && this.LoadId)
        {
            if (this.LoadId != origLoadLine.LoadId)
            {
                WHSLoadTable loadTable = this.whsLoadTable(true);

                boolean isLoadTableModified = loadTable.assignOriginInfo(AddRemove::Add);

                isLoadTableModified = loadTable.assignLoadWeightsForLoadLine(this, this.InventQty) || isLoadTableModified;
                if (_isConsolidation)
                {
                    if (_updateScheduledShipDateTime)
                    {
                        isLoadTableModified = loadTable.assignSchedShipDateTime(origLoadTable.LoadSchedShipUTCDateTime) || isLoadTableModified;
                    }
                }
                else
                {
                    isLoadTableModified = loadTable.assignEarliestSchedShipDateTime(this.LoadReadyToShipUTCDateTime) || isLoadTableModified;
                }

                if (isLoadTableModified)
                {
                    loadTable.update();
                }
            }
            else
            {
                WHSLoadTable::addLoadWeightsForLoadLine(this, this.InventQty - origLoadLine.InventQty);
            }
        }

        if (this.Invalid && !origLoadLine.Invalid)
        {
            this.logLoadLineInvalidation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertQtyToLoadUnitOfMeasure</Name>
				<Source><![CDATA[
    protected Qty convertQtyToLoadUnitOfMeasure(Qty _qty, WHSLoadLine _origLoadLine)
    {
        return this.convertQtyWithUnitToLoadUnitOfMeasure(_qty, _origLoadLine.UOM);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertQtyWithUnitToLoadUnitOfMeasure</Name>
				<Source><![CDATA[
    private Qty convertQtyWithUnitToLoadUnitOfMeasure(Qty _qty, UnitOfMeasureSymbol _fromUOM)
    {
        return EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.ItemId,
                                                                                     this.InventDimId,
                                                                                     _qty,
                                                                                     _fromUOM,
                                                                                     this.UOM,
                                                                                     NoYes::No,
                                                                                     NoYes::No);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventQty</Name>
				<Source><![CDATA[
    protected void setInventQty()
    {
        if (PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            // Catch weight items store load line quantitites in the catch weight unit.
            this.InventQty = this.Qty;
        }
        else
        {
            this.InventQty = InventTableModule::unitConvert(this.ItemId,
                                                            ModuleInventPurchSales::Invent,
                                                            this.UOM,
                                                            this.Qty,
                                                            this.InventDimId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventAndCrossDockQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets invent quantity and updates cross dock quantities if it was decreased.
    /// </summary>
    [Hookable(false)]
    internal void setInventAndCrossDockQty()
    {
        this.setInventQty();

        if (this.InventQty < this.orig().InventQty)
        {
            this.CrossDockEvaluatedQuantity = this.InventQty;
            this.CrossDockReservedPhysical = this.InventQty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQtyLeftToLoadForPurchase</Name>
				<Source><![CDATA[
    private void updateQtyLeftToLoadForPurchase(
        InventTransId  _inventTransId,
        Qty            _qty,
        WHSUOM         _unitFrom,
        WHSUOM         _unitTo,
        ItemId         _itemId,
        InventDimId    _inventDimId)
    {
        WHSPurchLine whsPurchLine = WHSPurchLine::find(_inventTransId, true);

        if (whsPurchLine)
        {
            whsPurchLine.QtyLeftToLoad = this.convertQtyLeftToLoadUnit(whsPurchLine.QtyLeftToLoad, _unitFrom, _unitTo, _itemId, _inventDimId);

            whsPurchLine.increaseQtyLeftToLoad(_qty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuantityLeftToLoadForNonTransportRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the quantity left to load for non transport requests, based on the inventory transaction type.
    /// </summary>
    /// <param name = "_inventTransId">The inventory transaction ID.</param>
    /// <param name = "_qty">The quantity being updated.</param>
    /// <param name = "_unitFrom">The from unit of measure.</param>
    /// <param name = "_unitTo">The to unit of measure</param>
    /// <param name = "_itemId">The item ID.</param>
    /// <returns>true if the quantity was updated; otherwise, false.</returns>
    protected boolean updateQuantityLeftToLoadForNonTransportRequest(
        InventTransId  _inventTransId,
        Qty            _qty,
        WHSUOM         _unitFrom,
        WHSUOM         _unitTo,
        ItemId         _itemId)
    {
        return this.updateQtyLeftToLoadForNonTransportRequestForParameters(
            WHSLoadLineQtyUpdateParameters::newFromLoadLine(this, _inventTransId, _qty, _unitFrom, _unitTo, _itemId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQtyLeftToLoadForNonTransportRequestForParameters</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean updateQtyLeftToLoadForNonTransportRequestForParameters(WHSLoadLineQtyUpdateParameters _parameters)
    {
        switch (_parameters.parmInventTransType())
        {
            case InventTransType::Sales:

                WHSLockedOrderHandlingContext context = WHSLockedOrderHandlingContext::instance();
                InventTransId inventTransId = _parameters.parmInventTransId();

                if (context &&
                    context.lockedOrderHandling == WHSLockedOrderHandling::SkipLockedOrders &&
                    WHSSalesLine::exist(inventTransId) &&
                    !whsSalesLine::tryLockInSQL(inventTransId))
                {
                    context.skipOccurred = true;
                    info(strFmt("@WAX:SkippingSalesOrderDueToLock", SalesLine::findInventTransId(inventTransId).SalesId));

                    throw Exception::UpdateConflict;
                }

                WHSSalesLine whsSalesLine;
                if (WhsSalesLineQtyLeftToLoadInSalesLineUnitFlight::instance().isEnabled())
                {
                    UnitOfMeasureSymbol updateQtyUnitFrom, updateQtyUnitTo;

                    //in _parameters.parmUnitTo() we have unit of _parameters.parmQty() (load unit) and now, we will convert from that unit to sales line unit
                    updateQtyUnitFrom = _parameters.parmUnitTo() ? _parameters.parmUnitTo() : this.UOM;
                    updateQtyUnitTo = (select SalesUnit from salesLine where SalesLine.InventTransId == inventTransId).salesUnit;

                    if (updateQtyUnitFrom && updateQtyUnitTo != updateQtyUnitFrom)
                    {
                        whsSalesLine = WHSSalesLine::find(inventTransId, true);
                        if (whsSalesLine)
                        {
                            whsSalesLine.QtyLeftToLoad += EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(
                            _parameters.parmItemId() ? _parameters.parmItemId() : this.ItemId,
                            this.InventDimId,
                            _parameters.parmQty(),
                            updateQtyUnitFrom,
                            updateQtyUnitTo,
                            NoYes::No,
                            NoYes::No);
                        
                            whsSalesLine.update();
                        }
                    }
                    else
                    {
                        update_recordset whsSalesLine
                            setting QtyLeftToLoad = whsSalesLine.QtyLeftToLoad + _parameters.parmQty()
                            where whsSalesLine.InventTransId == inventTransId;
                    }
                }
                else if (_parameters.parmUnitFrom() && _parameters.parmUnitFrom() != _parameters.parmUnitTo())
                {
                    whsSalesLine = WHSSalesLine::find(inventTransId, true);
                    whsSalesLine.QtyLeftToLoad = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_parameters.parmItemId(),
                                                                                                                           this.InventDimId,
                                                                                                                           whsSalesLine.QtyLeftToLoad,
                                                                                                                           _parameters.parmUnitFrom(),
                                                                                                                           _parameters.parmUnitTo(),
                                                                                                                           NoYes::No,
                                                                                                                           NoYes::No);
                    whsSalesLine.QtyLeftToLoad += _parameters.parmQty();
                    whsSalesLine.update();
                }
                else
                {
                    update_recordset whsSalesLine
                            setting QtyLeftToLoad = whsSalesLine.QtyLeftToLoad + _parameters.parmQty()
                            where whsSalesLine.InventTransId == inventTransId;
                }
                return true;

            case InventTransType::Purch:
                this.updateQtyLeftToLoadForPurchase(_parameters.parmInventTransId(), _parameters.parmQty(), _parameters.parmUnitFrom(), _parameters.parmUnitTo(), _parameters.parmItemId(), _parameters.parmInventDimId());
                return true;

            case InventTransType::TransferOrderShip:
                WHSInventTransferLine   whsInventTransferLine;
                if (_parameters.parmUnitFrom() && _parameters.parmUnitFrom() != _parameters.parmUnitTo())
                {
                    whsInventTransferLine = WHSInventTransferLine::findByInventTransId(_parameters.parmInventTransId(), true);
                    whsInventTransferLine.QtyLeftToLoad = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_parameters.parmItemId(),
                                                                                                                                    _parameters.parmInventDimId(),
                                                                                                                                    whsInventTransferLine.QtyLeftToLoad,
                                                                                                                                    _parameters.parmUnitFrom(),
                                                                                                                                    _parameters.parmUnitTo(),
                                                                                                                                    NoYes::No,
                                                                                                                                    NoYes::No);
                    whsInventTransferLine.QtyLeftToLoad += _parameters.parmQty();
                    whsInventTransferLine.update();
                }
                else
                {
                    InventTransferLine      inventTransferLine;
                    update_recordset whsInventTransferLine
                            setting QtyLeftToLoad = whsInventTransferLine.QtyLeftToLoad + _parameters.parmQty()
                                exists join inventTransferLine
                                    where inventTransferLine.InventTransId == _parameters.parmInventTransId()
                                       && inventTransferLine.RecId == whsInventTransferLine.InventTransferLine;
                }
                return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQtyLeftToLoad</Name>
				<Source><![CDATA[
    private void updateQtyLeftToLoad(
        InventTransId  _inventTransId,
        Qty            _qty,
        WHSUOM         _unitFrom   = '',
        WHSUOM         _unitTo     = '',
        ItemId         _itemId     = '',
        boolean        delete      = false)
    {
        boolean recFound;

        if (this.TransportRequest == NoYes::No)
        {
            recFound = this.updateQuantityLeftToLoadForNonTransportRequest(_inventTransId, _qty, _unitFrom, _unitTo, _itemId);
        }
        else
        {
            recFound = this.updateQtyLeftToLoadForTransportRequestForParameters(
                WHSLoadLineQtyUpdateParameters::newFromLoadLine(this, _inventTransId, _qty, _unitFrom, _unitTo, _itemId));
        }

        if (!recFound && !delete && _qty)
        {
            error ("@WAX381");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQtyLeftToLoadForTransportRequestForParameters</Name>
				<Source><![CDATA[
    private boolean updateQtyLeftToLoadForTransportRequestForParameters(WHSLoadLineQtyUpdateParameters _parameters)
    {
        TMSTransportRequestLine transportRequestLine;

        update_recordset transportRequestLine
                setting QtyLeftToTransport = transportRequestLine.QtyLeftToTransport + _parameters.parmQty()
                where transportRequestLine.InventTransId         == _parameters.parmInventTransId() &&
                      transportRequestLine.PackingQty            == _parameters.parmPackingQty() &&
                      transportRequestLine.TransportRequestId    == _parameters.parmOrderNum() &&
                      transportRequestLine.InventDimId           == _parameters.parmInventDimId();

        if (transportRequestLine.RowCount() > 1)
        {
            throw error("@WAX:WHSLoadLineUpdatedTooManyTMSTransportRequestLine");
        }

        return transportRequestLine.RowCount() > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertQtyLeftToLoadUnit</Name>
				<Source><![CDATA[
    private WHSQtyLeftToLoad convertQtyLeftToLoadUnit(
        WHSQtyLeftToLoad    _qtyLeftToLoad,
        WHSUOM              _unitFrom,
        WHSUOM              _unitTo,
        ItemId              _itemId,
        InventDimId         _inventDimId)
    {
        if (_unitFrom && _unitFrom != _unitTo)
        {
            return EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_itemId,
                                                                                         _inventDimId,
                                                                                         _qtyLeftToLoad,
                                                                                         _unitFrom,
                                                                                         _unitTo,
                                                                                         NoYes::No,
                                                                                         true);
        }

        return _qtyLeftToLoad;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAndNotifyQtyOnShipmentChanged</Name>
				<Source><![CDATA[
    private void checkAndNotifyQtyOnShipmentChanged(
        InventTransId _inventTransId,
        Qty _origQty,
        Qty _newQty,
        UnitOfMeasureSymbol _origUOM,
        UnitOfMeasureSymbol _newUOM,
        ItemId _itemId,
        WHSShipmentId _origShipmentId,
        WHSShipmentId _newShipmentId)
    {
        InventHandlingQty origInventQty = this.calculateOriginalHandlingQty(_origShipmentId, _itemId, _origUOM, _origQty);
        InventHandlingQty newInventQty  = this.calculateNewHandlingQty(_newShipmentId, _itemId, _newUOM, _newQty);

        InventHandlingQty inventQtyDifference = newInventQty - origInventQty;

        if (inventQtyDifference)
        {
            this.onQuantityOnShipmentChanged(this.InventTransType, _inventTransId, inventQtyDifference);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onQuantityOnShipmentChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method executes all the necessary updates to related entities
    /// when a change in the quantity on a shipment is changed.
    /// </summary>
    /// <param name = "_inventTransType">The <c>InventTransType</c> of the load line.</param>
    /// <param name = "_inventTransId">The <c>InventTransId</c> of the load line.</param>
    /// <param name = "_inventQtyDiff">The difference in quantity on shipments.</param>
    [Wrappable(true), Replaceable(true)]
    internal void onQuantityOnShipmentChanged(
        InventTransType _inventTransType,
        InventTransId _inventTransId,
        InventHandlingQty _inventQtyDiff)
    {
        this.updateReleasedQty(_inventTransType, _inventTransId, _inventQtyDiff);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReleasedQty</Name>
				<Source><![CDATA[
    private void updateReleasedQty(
        InventTransType _inventTransType,
        InventTransId _inventTransId,
        InventHandlingQty _releasedQtyDiff)
    {
        switch (_inventTransType)
        {
            case InventTransType::Sales:
                WHSSalesLine whsSalesLine = WHSSalesLine::find(_inventTransId, true);

                if (whsSalesLine.RecId != 0)
                {
                    whsSalesLine.ReleasedQty += _releasedQtyDiff;
                    whsSalesLine.update();
                }
                break;

            case InventTransType::TransferOrderShip:
                WHSInventTransferLine whsInventTransferLine = WHSInventTransferLine::findByInventTransId(_inventTransId, true);

                if (whsInventTransferLine.RecId != 0)
                {
                    whsInventTransferLine.ReleasedQty += _releasedQtyDiff;
                    whsInventTransferLine.update();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateOrigInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the original inventory quantity
    /// </summary>
    /// <param name="_origShipmentId">
    /// The original load line shipment ID.
    /// </param>
    /// <param name="_itemId">
    /// Load line item ID.
    /// </param>
    /// <param name="_origUOM">
    /// The original load line unit of measure.
    /// </param>
    /// <param name="_origQty">
    /// The original load line quantity.
    /// </param>
    /// <returns>
    /// The calculated quantity.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the calculateOriginalHandlingQty method. Extenders should move their logic to wrap the calculateHandlingQty method.', false, 30\9\2019)]
    protected Qty calculateOrigInventQty(WHSShipmentId _origShipmentId, ItemId _itemId, UnitOfMeasureSymbol _origUOM, Qty _origQty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _itemId);

        return this.calculateHandlingQty(_origShipmentId, _itemId, _origUOM, _origQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateOriginalHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the original handling quantity.
    /// </summary>
    /// <param name="_origShipmentId">
    /// The original load line shipment ID.
    /// </param>
    /// <param name="_itemId">
    /// Load line item ID.
    /// </param>
    /// <param name="_origUOM">
    /// The original load line unit of measure.
    /// </param>
    /// <param name="_origHandlingQty">
    /// The original load line handling quantity.
    /// </param>
    /// <returns>
    /// The calculated handling quantity.
    /// </returns>
    final protected InventHandlingQty calculateOriginalHandlingQty(WHSShipmentId _origShipmentId, ItemId _itemId, UnitOfMeasureSymbol _origUOM, InventHandlingQty _origHandlingQty)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return this.calculateHandlingQty(_origShipmentId, _itemId, _origUOM, _origHandlingQty);
        }

        return this.calculateOrigInventQty(_origShipmentId, _itemId, _origUOM, _origHandlingQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNewInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the new inventory quantity.
    /// </summary>
    /// <param name="_newShipmentId">
    /// The new load line shipment ID.
    /// </param>
    /// <param name="_itemId">
    /// Load line item ID.
    /// </param>
    /// <param name="_newUOM">
    /// The new load line unit of measure.
    /// </param>
    /// <param name="_newQty">
    /// The new load line quantity.
    /// </param>
    /// <returns>
    /// The calculated quantity.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the calculateNewHandlingQty method. Extenders should move their logic to wrap the calculateHandlingQty method.', false, 30\9\2019)]
    protected Qty calculateNewInventQty(WHSShipmentId _newShipmentId, ItemId _itemId, UnitOfMeasureSymbol _newUOM, Qty _newQty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _itemId);

        return this.calculateHandlingQty(_newShipmentId, _itemId, _newUOM, _newQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNewHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the new handling quantity.
    /// </summary>
    /// <param name="_newShipmentId">
    /// The new load line shipment ID.
    /// </param>
    /// <param name="_itemId">
    /// Load line item ID.
    /// </param>
    /// <param name="_newUOM">
    /// The new load line unit of measure.
    /// </param>
    /// <param name="_newHandlingQty">
    /// The new load line handling quantity.
    /// </param>
    /// <returns>
    /// The calculated handling quantity.
    /// </returns>
    final protected InventHandlingQty calculateNewHandlingQty(WHSShipmentId _newShipmentId, ItemId _itemId, UnitOfMeasureSymbol _newUOM, InventHandlingQty _newHandlingQty)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return this.calculateHandlingQty(_newShipmentId, _itemId, _newUOM, _newHandlingQty);
        }

        return this.calculateNewInventQty(_newShipmentId, _itemId, _newUOM, _newHandlingQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates a handling quantity.
    /// </summary>
    /// <param name="_shipmentId">
    /// The load line shipment ID.
    /// </param>
    /// <param name="_itemId">
    /// Load line item ID.
    /// </param>
    /// <param name="_UOM">
    /// The new load line unit of measure.
    /// </param>
    /// <param name="_handlingQty">
    /// The load line handling quantity.
    /// </param>
    /// <returns>
    /// The calculated handling quantity.
    /// </returns>
    /// <remarks>
    /// The method is an extension and is not meant to be called directly. Callers should call the calculateNewHandlingQty or calculateOriginalHandlingQty methods.
    /// </remarks>
    [Wrappable(true)]
    protected InventHandlingQty calculateHandlingQty(WHSShipmentId _shipmentId, ItemId _itemId, UnitOfMeasureSymbol _UOM, InventHandlingQty _handlingQty)
    {
        return _shipmentId ? WHSCatchWeightHelper::convertInventQuantity(_itemId, _UOM, _handlingQty, this.InventDimId) : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAllForInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all <c>WHSLoadLines</c> related to the order line being deleted.
    /// </summary>
    /// <param name="_transId">
    /// The <c>InventTransId</c> from the order line being deleted.
    /// </param>
    /// <param name="_errorMessage">
    /// The Error message shown if load line validateDelete fails.
    /// </param>
    [Hookable(false)]
    internal static void deleteAllForInventTransId(InventTransId _transId, str _errorMessage = strFmt("@WAX:WHSCannotDeleteRecordInTable", tablePName(WHSLoadLine)))
    {
        WHSLoadLine loadLine;

        while select forupdate loadLine
            where loadLine.InventTransId == _transId
        {
            if (!loadLine.validateDelete())
            {
                throw error(_errorMessage);
            }

            loadLine.delete();
            warning(strFmt("@WAX:LoadLineWarning", loadLine.LoadId, loadLine.ItemId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check that the load to delete has no ongoing work.
    /// </summary>
    /// <returns>true if the validation is successful, otherwise false.</returns>
    public boolean validateDelete()
    {
        boolean ret = super();

        ret = ret && 
              this.validateLoadLineDoesNotHaveNonCanceledWork("@WAX836") && 
              this.validateRegisteredOrReceivedTransactionDoesNotExistForLoad();
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyValidateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check that the load to delete has no ongoing work.
    /// </summary>
    /// <remarks>
    /// This method has the same behavior as <code>validateDelete</code> except that the error message is different.
    /// The reason is that this method is called when removing a purchase line related to an intercompany sales order line,
    /// and the expected error message to display when it is not possible to remove the purchase line is different than the error displayed
    /// by <code>validateDelete</code>.
    /// </remarks>
    /// <returns>true if the validation is successful, otherwise false.</returns>
    public boolean intercompanyValidateDelete()
    {
        return this.validateLoadLineDoesNotHaveNonCanceledWork("@WAX:CannotDeletePurchLineActiveWork");
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRegisteredOrReceivedTransactionDoesNotExistForLoad</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean validateRegisteredOrReceivedTransactionDoesNotExistForLoad()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLoadLineDoesNotHaveNonCanceledWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check that the load to delete has no ongoing work.
    /// </summary>
    /// <remarks>
    /// This method has the same behavior as <code>validateDelete</code> except that the error message is different.
    /// </remarks>
    /// <param name = "_errorMessage">Message to add to log as a warning.</param>
    /// <returns>true if the validation is successful, otherwise false.</returns>
    [Hookable(false)]
    internal boolean validateLoadLineDoesNotHaveNonCanceledWork(str _errorMessage)
    {
        boolean ret = true;

        this.validateNonNegativeWorkCreatedQty();

        if (this.WorkCreatedQty > 0)
        {
            if (InventTable::find(this.ItemId).ItemType != ItemType::Service ||
                this.whsLoadTable().LoadStatus > WHSLoadStatus::Shipped)
            {
                ret = checkFailed(_errorMessage);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDirection</Name>
				<Source><![CDATA[
    private boolean validateDirection()
    {
        if (this.whsLoadTable().LoadId
            && this.LoadDirection != this.whsLoadTable().LoadDirection)
        {
            return checkFailed(strFmt("@WAX1682", this.whsLoadTable().LoadDirection));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the inventDim of the loadLine does not include any dimensions at or below location in the reservation hierarchy.
    /// </summary>
    /// <returns>
    /// true if no dimensions at or below location are specified on the inventDim, otherwise; false.
    /// </returns>
    public boolean validateInventDim()
    {
        boolean  ret = true;

        if (this.isForOutboundShipment()
            &&  WHSReservationHierarchyInventDimUtil::isLocationOrBelowSpecified(InventTable::find(this.ItemId), this.inventDim()))
        {
            ret = checkFailed(strFmt("@WAX:WHSLoadLineInventDimValidationError", this.InventTransType, this.OrderNum, this.ItemId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to make sure that the quantity of the load line is valid.
    /// </summary>
    /// <returns>
    /// true if the quantity is valid; otherwise, false.
    /// </returns>
    public boolean validateQty()
    {
        str                 errorText;
        InventHandlingQty   inventHandlingQty;
        InventHandlingQty   inventHandlingQtyLeftToStructure;
        InventHandlingQty   diffQty;
        Qty                 qtyOrig;
        boolean             isCWItem = PdsGlobal::pdsIsCWItem(this.ItemId);

        if (isCWItem)
        {
            // Catch weight items hold load line quantities in the catch weight unit.
            inventHandlingQty = this.Qty;
        }
        else
        {
            if (this.InventQty)
            {
                qtyOrig = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.ItemId,
                                                                                                this.InventDimId,
                                                                                                this.InventQty,
                                                                                                InventTableModule::find(this.ItemId, ModuleInventPurchSales::Invent).UnitId,
                                                                                                this.UOM,
                                                                                                NoYes::No);
            }

            if (this.Qty == qtyOrig)
            {
                inventHandlingQty = this.InventQty;
            }
            else
            {
                inventHandlingQty = InventTableModule::unitConvert(this.ItemId, ModuleInventPurchSales::Invent, this.UOM, this.Qty, this.InventDimId);
            }
        }

        // For catch weight items the Qty, InventQty fields and as result the inventHandlingQty variable have values in the catch weight unit.
        diffQty = inventHandlingQty - this.orig().InventQty; // Diff Qty will be negative if loadLine qty is being decreased.

        if (!this.isQuantityDifferenceValid(diffQty))
        {
            errorText += strFmt("@WAX:QuantityTooHighForLoadLine", this.InventTransType, this.OrderNum);
        }

        errorText += this.validateInventHandlingQty(inventHandlingQty);

        if (this.isForExternalInboundShipment())
        {
            inventHandlingQtyLeftToStructure = isCWItem ? this.QtyLeftToStructure : InventTableModule::unitConvert(this.ItemId, ModuleInventPurchSales::Invent, this.UOM, this.QtyLeftToStructure, this.InventDimId);

            if (inventHandlingQtyLeftToStructure + diffQty < 0)
            {
                errorText += "@WAX685";
            }
        }

        if (this.Qty < this.orig().Qty)
        {
            WHSWaveLabel        waveLabel;
            WHSWaveLabelHistory labelHistory;
            WHSShipmentTable    shipmentTable;

            select firstonly TableId from waveLabel
            exists join labelHistory
                where  labelHistory.RecId  == waveLabel.WaveLabelHistoryRecId
            exists join shipmentTable
                where  shipmentTable.WaveId == labelHistory.WaveId
                    && shipmentTable.LoadId == this.LoadId;

            if(waveLabel)
            {
                warning("@WAX:WaveLabelLoadLineWarning");
            }
        }

        return errorText ? checkFailed(errorText) : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventHandlingQty</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal str validateInventHandlingQty(InventHandlingQty _inventHandlingQty)
    {
        if (_inventHandlingQty < this.WorkCreatedQty)
        {
            return "@WAX684";
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForExternalInboundShipment</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean isForExternalInboundShipment()
    {
        return this.InventTransType == InventTransType::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isQuantityDifferenceValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the quantity difference is lower than the quantity left to load if it has been changed.
    /// </summary>
    /// <param name="_diffQty">
    /// The difference in the inventory quantity.
    /// </param>
    /// <returns>
    /// true if the quantity difference is lower than the quantity left to load if it has been changed; otherwise, false.
    /// </returns>
    protected boolean isQuantityDifferenceValid(InventQty _diffQty)
    {
        return !_diffQty || _diffQty <= this.qtyLeftToLoad();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isShippedQuantityReductionAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if reduction of shipped quantity is allowed on the load.
    /// </summary>
    /// <returns>
    /// true if reduction of shipped quantity is allowed on the load; otherwise false.
    /// </returns>
    public boolean isShippedQuantityReductionAllowed()
    {
        WHSLoadStatus loadStatus = WHSLoadTable::find(this.LoadId).LoadStatus;

        return (loadStatus		!= WHSLoadStatus::Shipped
                && loadStatus	!= WHSLoadStatus::PartiallyShipped);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the load is in a status which can be edited.
    /// </summary>
    /// <returns>
    /// true if the load is in a status which can be edited; otherwise, false.
    /// </returns>
    protected boolean validateStatus()
    {
        WHSLoadTable loadTable;

        select firstonly LoadStatus from loadTable
            where loadTable.LoadId == this.LoadId;

        if (loadTable.LoadStatus == WHSLoadStatus::Shipped
            || loadTable.LoadStatus == WHSLoadStatus::Received)
        {
            return checkFailed(strFmt("@WAX4657", loadTable.LoadStatus));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the current warehouse can be used for creating a load.
    /// </summary>
    /// <returns>
    /// true if the current warehouse can be used for creating a load; otherwise, false.
    /// </returns>
    public boolean validateWarehouse()
    {
        InventDim inventDim = this.inventDim();

        if (!inventDim.InventLocationId)
        {
            return checkFailed("@WAX4658");
        }
        else if (!inventDim.inventLocation().isLoadEnabled())
        {
            return checkFailed(strFmt("@SYS4009637", inventDim.InventLocationId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOverDelivery</Name>
				<Source><![CDATA[
    private boolean validateOverDelivery()
    {
        if (this.isForExternalInboundShipment())
        {
            if (this.OverDeliveryPct < 0)
            {
                return checkFailed("@SYS26776");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        return super()
            && this.validateStatus()
            && this.validateQty()
            && this.validateDirection()
            && this.validateWarehouse()
            && this.validateInventDim()
            && this.validateOverDelivery()
            && this.Qty > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInsertInBulkFromLoadPlanningWorkbench</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls if the line can be inserted or 
    /// should be skipped when bulk adding lines 
    /// to a load from the load planning workbench.
    /// </summary>
    /// <returns>
    /// true if line can be inserted; false if line should be skipped.
    /// </returns>
    [Hookable(false)]
    internal boolean canInsertInBulkFromLoadPlanningWorkbench()
    {
        return this.validateWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>warehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the warehouse id of the load line.
    /// </summary>
    /// <returns>
    /// The warehouse id of the load line.
    /// </returns>
    InventLocationId warehouse()
    {
        return this.inventDim().InventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsLoadTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the load record that the load line belongs to.
    /// </summary>
    /// <param name="_forUpdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The load record that the load line belongs to.
    /// </returns>
    public WHSLoadTable whsLoadTable(boolean _forUpdate = false)
    {
        return WHSLoadTable::find(this.LoadId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForOrderNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check to see if a <c>WHSLoadLine</c> record exists for the specified <c>WHSOrderNum</c>.
    /// </summary>
    /// <param name="_orderNum">
    /// The Order Number.
    /// </param>
    /// <param name="_inventTransType">
    /// The inventTransType for the order.
    /// </param>
    /// <returns>
    /// True if the load line exists; otherwise False.
    /// </returns>
    /// <remarks>
    /// The method only searches for load lines that are not transport requests.
    /// </remarks>
    public static boolean existForOrderNum(
        WHSOrderNum     _orderNum,
        InventTransType _inventTransType
    )
    {
        return (select firstonly RecId from whsLoadLine
            where whsLoadLine.OrderNum          == _orderNum
               && whsLoadLine.InventTransType   == _inventTransType
               && whsLoadLine.TransportRequest  == NoYes::No).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForOrderNumWithShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check to see if a <c>WHSLoadLine</c> record exists for the specified <c>WHSOrderNum</c> which has an associated shipment.
    /// </summary>
    /// <param name="_orderNum">
    /// The Order Number.
    /// </param>
    /// <param name="_inventTransType">
    /// The inventTransType for the order.
    /// </param>
    /// <returns>
    /// True if the load line exists; otherwise False.
    /// </returns>
    /// <remarks>
    /// The method only searches for load lines that are not transport requests.
    /// </remarks>
    public static boolean existForOrderNumWithShipment(
        WHSOrderNum     _orderNum,
        InventTransType _inventTransType
    )
    {
        return (select firstonly RecId from whsLoadLine
            where whsLoadLine.OrderNum          == _orderNum
               && whsLoadLine.InventTransType   == _inventTransType
               && whsLoadLine.TransportRequest  == NoYes::No
               && WHSLoadLine.ShipmentId        != '').RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsForInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a load line exists for the inventTransId specified.
    /// </summary>
    /// <param name="_inventTransId">
    /// InventTransId which to check for relating load lines.
    /// </param>
    /// <returns>
    /// true if a load line exists for the inventTransId specified; otherwise, false.
    /// </returns>
    public static boolean existsForInventTransId(InventTransId _inventTransId)
    {
        return _inventTransId
               && (select firstonly RecId from whsLoadLine
                   where whsLoadLine.InventTransId == _inventTransId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsForRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a load line exists for the RecId specified.
    /// </summary>
    /// <param name="_loadLineRecId">
    /// RecId which to check for relating load lines.
    /// </param>
    /// <returns>
    /// true if a load line exists for the RecId specified; otherwise, false.
    /// </returns>
    public static boolean existsForRecId(RecId _loadLineRecId)
    {
        return _loadLineRecId
               && (select firstonly RecId from whsLoadLine
                   where whsLoadLine.RecId == _loadLineRecId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findbyRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific <c>WHSLoadLine</c> record by id.
    /// </summary>
    /// <param name="_recId">
    /// The id of the record.
    /// </param>
    /// <param name="_forUpdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    static WHSLoadLine findbyRecId(RecId _recId, boolean _forUpdate = false)
    {
        WHSLoadLine     loadLine;

        if (_recId)
        {
            loadLine.selectForUpdate(_forUpdate);

            select firstonly loadLine
                where loadLine.RecId == _recId;
        }

        return loadLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecIdWithPessimisticLock</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific <c>WHSLoadLine</c> record by id and applies pessimistic Locking.
    /// </summary>
    /// <param name="_recId">
    /// The id of the record.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    private static WHSLoadLine findByRecIdWithPessimisticLock(RecId _recId)
    {
        WHSLoadLine     loadLine;

        if (_recId)
        {
            select firstonly pessimisticlock loadLine
                where loadLine.RecId == _recId;
        }

        return loadLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstForLoadId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a single <c>WHSLoadLine</c> buffer associated with a load.
    /// </summary>
    /// <param name="_loadId">
    /// Specifies the load ID used to select the <c>WHSLoadLine</c>.
    /// </param>
    /// <returns>
    /// A <c>WHSLoadLine</c> buffer.
    /// </returns>
    /// <remarks>
    /// The first <c>WHSLoadLine</c> buffer is not selected in any specific order.
    /// </remarks>
    public static WHSLoadLine findFirstForLoadId(WHSLoadId _loadId)
    {
        WHSLoadLine loadLine;

        if (_loadId)
        {
            select firstonly loadLine
                   where loadLine.LoadId == _loadId;
        }

        return loadLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstForOrderNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a single <c>WHSLoadLine</c> buffer associated with an order.
    /// </summary>
    /// <param name="_orderNum">
    /// The Order Number.
    /// </param>
    /// <param name="_inventTransType">
    /// The inventTransType for the order.
    /// </param>
    /// <returns>
    /// A <c>WHSLoadLine</c> buffer.
    /// </returns>
    /// <remarks>
    /// The method only searches for load lines that are not transport requests.
    /// </remarks>
    public static WHSLoadLine findFirstForOrderNum(
        WHSOrderNum     _orderNum,
        InventTransType _inventTransType
    )
    {
        WHSLoadLine loadLine;

        if (_orderNum)
        {
            select firstonly loadLine
                where loadLine.OrderNum          == _orderNum
                   && loadLine.InventTransType   == _inventTransType
                   && loadLine.TransportRequest  == NoYes::No;
        }

        return loadLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstForShipmentId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a single <c>WHSLoadLine</c> buffer associated with a shipment.
    /// </summary>
    /// <param name="_shipmentId">
    /// Specifies the shipment ID used to select the <c>WHSLoadLine</c>.
    /// </param>
    /// <returns>
    /// A <c>WHSLoadLine</c> buffer.
    /// </returns>
    /// <remarks>
    /// The first <c>WHSLoadLine</c> buffer is not selected in any specific order.
    /// </remarks>
    public static WHSLoadLine findFirstForShipmentId(WHSShipmentId _shipmentId)
    {
        WHSLoadLine loadLine;

        if (_shipmentId)
        {
            select firstonly loadLine
                   where loadLine.ShipmentId == _shipmentId;
        }

        return loadLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLoadId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the LoadId from the <c>WHSLoadLine</c> table depending on the specified InventTransId.
    /// </summary>
    /// <param name="_inventTransId">
    /// InventTransId of the <c>WHSLoadLine</c> to get the load id from.
    /// </param>
    /// <returns>
    /// LoadId from the <c>WHSLoadLine</c> table if exists; otherwise empty.
    /// </returns>
    public static WHSLoadId getLoadId(InventTransId _inventTransId)
    {
        WHSLoadLine      loadLine;

        if (_inventTransId)
        {
            select firstonly LoadId from loadLine
                where loadLine.InventTransId == _inventTransId
                    && loadLine.LoadId       != '';
        }

        return loadLine.LoadId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getShipmentId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the shipmentId from the <c>WHSLoadLine</c> table depending on the specified InventTransId and InventTransType.
    /// </summary>
    /// <param name="_inventTransId">
    /// InventTransId of the <c>WHSLoadLine</c> to get the shipment id from.
    /// </param>
    /// <returns>
    /// shipmentId from the <c>WHSLoadLine</c> table if exists; otherwise empty.
    /// </returns>
    public static WHSShipmentId getShipmentId(InventTransId _inventTransId)
    {
        WHSLoadLine      loadLine;

        if (_inventTransId)
        {
            select firstonly ShipmentId from loadLine
                where loadLine.InventTransId == _inventTransId
                   && loadLine.ShipmentId    != '';
        }

        return loadLine.ShipmentId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves inventory on the source order for the the loadLine.
    /// </summary>
    /// <param name="_loadLine">
    /// The loadLine that inventory is being reserved for.
    /// </param>
    /// <param name="_inventQty">
    /// The quantity that is to be reserved.
    /// </param>
    /// <returns>
    /// true if the loadLine could successfully reserve inventory; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If the source order is already reserve or partially reserved this method will not try to reserve more than the amount that is still on Order for the movement and match the loadLine inventDim.
    /// </remarks>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the reserveLoadLineHandlingQty method. Extenders should move their logic to wrap the reserveLoadLineQuantities method.', false, 30\9\2019)]
    public static boolean reserveLoadLine(
        WHSLoadLine  _loadLine,
        InventQty    _inventQty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _loadLine.ItemId);

        return WHSLoadLine::reserveLoadLineQuantities(_loadLine, _inventQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveLoadLineHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves inventory on the source order for the the loadLine.
    /// </summary>
    /// <param name="_loadLine">
    /// The loadLine that inventory is being reserved for.
    /// </param>
    /// <param name="_handlingQty">
    /// The handling quantity that is to be reserved.
    /// </param>
    /// <returns>
    /// true if the loadLine could successfully reserves inventory; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If the source order is already reserve or partially reserved this method will not try to reserve more than the amount that is still on Order for the movement and match the loadLine inventDim.
    /// </remarks>
    [Hookable(false)]
    public static boolean reserveLoadLineHandlingQty(
        WHSLoadLine         _loadLine,
        InventHandlingQty   _handlingQty)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _loadLine.ItemId))
        {
            return WHSLoadLine::reserveLoadLineQuantities(_loadLine, _handlingQty);
        }

        return WHSLoadLine::reserveLoadLine(_loadLine, _handlingQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveLoadLineQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves inventory on the source order for the the loadLine.
    /// </summary>
    /// <param name="_loadLine">
    /// The loadLine that inventory is being reserved for.
    /// </param>
    /// <param name="_handlingQty">
    /// The handling quantity that is to be reserved.
    /// </param>
    /// <returns>
    /// true if the loadLine could successfully reserves inventory; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The method is an extension and is not meant to be called directly. Callers should call the reserveLoadLineHandlingQty method.
    /// </remarks>
    [Wrappable(true)]
    protected static boolean reserveLoadLineQuantities(
        WHSLoadLine         _loadLine,
        InventHandlingQty   _handlingQty)
    {
        InventUpd_Reservation   reservation;
        InventMovement      movement;
        InventDimParm       inventDimParm;
        InventTable         inventTable;
        InventDim           inventDimMovement;
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        InventHandlingQty   availQty;
        InventHandlingQty   handlingQty = _handlingQty;
        PdsCWQty            pdsCWAvailReservation;
        boolean             ret = true;

        inventTable = InventTable::find(_loadLine.ItemId);

        // Skip all reservation logic for service items
        if (inventTable.ItemType == ItemType::Service)
        {
            return ret;
        }

        inventDimMovement.data(InventDim::find(_loadLine.InventDimId));

        // Sum up the on order amount for all transactions that are the same inventDim as the loadLine.
        select sum(Qty), sum(PdsCWQty) from  inventTrans
            where inventTrans.StatusIssue == StatusIssue::OnOrder
            &&    inventTrans.StatusReceipt == StatusReceipt::None
            &&    inventTrans.InventDimId == _loadLine.InventDimId
                exists join inventTransOrigin
                    where inventTrans.InventTransOrigin     == inventTransOrigin.RecId
                    &&    inventTransOrigin.InventTransId   == _loadLine.InventTransId;

        // If there is no on order qty for the order then we don't need to reserve
        if (!inventTrans.Qty)
        {
            return ret;
        }

        // Reserve the full qty unless there is less on order qty.
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_loadLine.ItemId);
        handlingQty = isCWItem ? min(handlingQty, -inventTrans.PdsCWQty) : min(handlingQty, -inventTrans.Qty);

        if (inventTable.whsAllowPhysNeg())
        {
            if (isCWItem)
            {
                pdsCWAvailReservation = _loadLine.InventQty;
            }
            else
            {
                availQty = _loadLine.InventQty;
            }
        }
        else
        {
            [availQty, pdsCWAvailReservation] = InventOnhand::availReservationDimensions(_loadLine.ItemId, [inventDimMovement], InventParameters::find().ReserveOnOrdered);
        }

        InventQty   reserveInventQty;
        PdsCWQty    reserveCWQty;
        boolean     mustReserveQty;
        boolean     mustReservePartialQtyCrossDockIntended;

        // If there is enough available then reserve the loadLine
        if (isCWItem && (pdsCWAvailReservation >= handlingQty))
        {
            reserveInventQty    = WHSInvent::defaultCatchWeightReserveQuantity(_loadLine.ItemId, -handlingQty);
            reserveCWQty        = -handlingQty;
            mustReserveQty      = true;
        }
        else if (!isCWItem && (availQty >= handlingQty))
        {
            reserveInventQty    = -handlingQty;
            reserveCWQty        = 0;
            mustReserveQty      = true;
        }

        else if (!isCWItem && handlingQty > 0 && availQty > 0 
            && WHSAllowReservePartialLoadLineIfCrossDockIsOnFlight::instance().isEnabled()
            && WHSLoadPostMethod::existMethodName(methodStr(WHSLoadPostEngineBase, planCrossDocking))
            && WHSCrossDockTemplate::beforeSupplyReceiptPolicyCrossDockingTemplateExists(inventDimMovement.InventLocationId)
            && _loadLine.canBeUsedForPlannedCrossDock())
        {
            reserveInventQty    = -handlingQty;
            reserveCWQty        = 0;
            mustReservePartialQtyCrossDockIntended = true;
            ret = false;
        }

        if (mustReserveQty || mustReservePartialQtyCrossDockIntended)
        {
            WhsLoadLineInventTransValidator validator = WhsLoadLineInventTransValidator::construct();
            validator.parmReserveLoadLineRecId(_loadLine.RecId);

            movement = InventMovement::construct(_loadLine.getOrderCommonFromLoadLine(true));
            movement.parmConsistencyValidator(validator);

            inventDimParm.initFromInventDim(_loadLine.inventDim());

            reservation = InventUpd_Reservation::newParameters(movement,
                                                           _loadLine.inventDim(),
                                                           inventDimParm,
                                                           InventDimFixedClass::inventDimParm2InventDimFixed(inventDimParm),
                                                           reserveInventQty,
                                                           false,
                                                           false,
                                                           reserveCWQty);
            if (mustReservePartialQtyCrossDockIntended)
            {
                reservation.parmAllowReserveReduction(true);
            }
            reservation.updateNow();
        }
        else
        {
            ret = checkFailed(strFmt("@WAX2737", handlingQty, _loadLine.ItemId, _loadLine.OrderNum));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfVolTypeCanConvertToInventUnit_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the inventory unit can be converted to the volume type unit.
    /// </summary>
    /// <returns>
    /// True if there is a conversion from the inventory unit to the volume type unit; otherwise, false.
    /// </returns>
    public boolean checkIfVolTypeCanConvertToInventUnit_BR()
    {
        InventTable        item;

        if (this.VolumeType_BR)
        {
            item = InventTable::find(this.ItemId);

            return EcoResProductUnitConverter::canBeConvertedGivenUnitSymbolsForReleasedProduct(item.ItemId,
                                                                                                this.InventDimId,
                                                                                                item.inventUnitId(),
                                                                                                this.VolumeType_BR);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRequestedLicensePlates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the list of requested license plates from the source document
    /// </summary>
    /// <returns>
    /// List of requested license plates
    /// </returns>
    /// <remarks>
    /// Works only with transfer order shipment now
    /// </remarks>
    public List getRequestedLicensePlates()
    {
        InventTransferLine                  transferLine;
        InventTransferCombinedLineDelivery  combinedDelivery;
        InventTransferRequestedLicensePlate requestedLicensePlate;

        List licensePlates;

        if (this.InventTransType == InventTransType::TransferOrderShip)
        {
            transferLine = this.inventTransferLine();

            if (transferLine.RecId)
            {
                combinedDelivery = InventTransferCombinedLineDelivery::find(transferLine.CombinedTransferOrderLineDelivery);

                if (combinedDelivery.RecId)
                {
                    licensePlates = new List(Types::String);

                    while select RequestedLicensePlateID from requestedLicensePlate
                        where requestedLicensePlate.CombinedTransferOrderLineDelivery == combinedDelivery.RecId
                    {
                        licensePlates.addEnd(requestedLicensePlate.RequestedLicensePlateID);
                    }
                }
            }
        }

        if (!licensePlates || licensePlates.empty())
        {
            return null;
        }

        return licensePlates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeVolumeInformation_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes volume type and volume quantity fields.
    /// </summary>
    /// <remarks>
    /// Volume type is initialized by getting the maximum unit of measure from the unit of measure
    /// sequence group of the invent table.
    /// Volume quantity is initialized by converting the picking quantity from the inventory unit to the
    /// unit of measure of the volume type.
    /// </remarks>
    private void initializeVolumeInformation_BR()
    {
        this.VolumeType_BR = InventTable::find(this.ItemId).inventUnitId();

        if (this.VolumeType_BR)
        {
            this.initializeVolumeQuantity_BR();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeVolumeQuantity_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes volume quantity field.
    /// </summary>
    /// <remarks>
    /// Volume quantity is initialized by converting the picking quantity from the inventory unit to the
    /// unit of measure of the volume type.
    /// </remarks>
    private void initializeVolumeQuantity_BR()
    {
        if (this.checkIfVolTypeCanConvertToInventUnit_BR())
        {
            this.VolumeQty_BR = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.ItemId,
                                                                                                      this.InventDimId,
                                                                                                      this.PickedQty,
                                                                                                      WHSCatchWeightHelper::inventHandlingUnitId(this.ItemId),
                                                                                                      this.VolumeType_BR,
                                                                                                      NoYes::Yes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInitializeVolumeQuantity_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the volume quantity should be initialized or not.
    /// </summary>
    /// <returns>
    /// True if the volume quantity should be initialized; otherwise; false.
    /// </returns>
    /// <remarks>
    /// The volume quantity should be initialized if the volume type or the picked quantity has changed.
    /// </remarks>
    private boolean shouldInitializeVolumeQuantity_BR()
    {
        WHSLoadLine origLoadLine = this.orig();

        return this.PickedQty != origLoadLine.PickedQty || this.VolumeType_BR != origLoadLine.VolumeType_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchLineFromLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>PurchLine</c> record from a specific load and item id, which has an ordered quantity
    /// and matches with the product dimensions of the passed <c>InventDim</c> record if specified.
    /// </summary>
    /// <param name="_loadId">
    /// Load id to be checked against
    /// </param>
    /// <param name="_itemId">
    /// Item id to be checked against
    /// </param>
    /// <param name="_itemInventDim">
    /// InventDim Id to be checked against
    /// </param>
    /// <returns>
    /// The <c>PurchLine</c> record that was retrieved
    /// </returns>
    public static PurchLine getPurchLineFromLoadLine(
                                WHSLoadId   _loadId,
                                ItemId      _itemId,
                                InventDim   _itemInventDim = null)
    {
        WHSLoadLine     loadLine;
        PurchLine       purchLine;
        InventDim       localInventDim;
        InventDimParm   inventDimParm;

        if (_itemInventDim.anyProductDimensionSpecified())
        {
            inventDimParm.initProductDimensionsAllGroups();

            while select loadLine
                where loadLine.LoadId            == _loadId
                    && loadLine.ItemId           == _itemId
                    && loadLine.InventTransType  == InventTransType::Purch
            #InventDimExistsJoinNoField(loadLine.InventDimId, localInventDim, _itemInventDim, inventDimParm)
            {
                purchLine = loadLine.getOrderCommonFromLoadLine() as PurchLine;

                if (purchLine.ordered() > 0)
                {
                    break;
                }
            }
        }
        else
        {
            while select loadLine
                where loadLine.LoadId            == _loadId
                    && loadLine.ItemId           == _itemId
                    && loadLine.InventTransType  == InventTransType::Purch
            {
                purchLine = loadLine.getOrderCommonFromLoadLine() as PurchLine;

                if (purchLine.ordered() > 0)
                {
                    break;
                }
            }
        }

        return purchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQtyLeftToStructure</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Calculate the new QtyLeftToStructure by decreasing quantity.
    /// </summary>
    /// <param name="_includeOverDelivery">
    ///   Determines whether to include over delivery quantities; optional.
    /// </param>
    /// <param name="_decreasingQty">
    ///   Determines the decreasing quantity; optional.
    /// </param>
    /// <returns>
    ///   The new QtyLeftToStructure quantity.
    /// </returns>
    /// <remarks>
    ///   If try to validate whether the decreasing quantities is acceptable, _includeOverDelivery should use true;
    ///   Otherwise, if try to calculate new QtyLeftToStructure, _includeOverDelivery should use false.
    ///   If _decreasingQty is not provided, the new QtyLeftToStructure will be calculated based only on the existing ASN items.
    /// </remarks>
    public Qty getQtyLeftToStructure(boolean _includeOverDelivery = true, Qty _decreasingQty = 0)
    {
        Qty                ret;
        Qty                totalQty;
        Qty                totalAsnItemQty;
        WHSASNItem         whsAsnItem;

        if (_includeOverDelivery && this.isForExternalInboundShipment())
        {
            WHSReceiptOrderLine orderLine = this.sourceOrder();
            OverDeliveryPct overDeliveryPct = orderLine.OverDeliveryPct;
            
            real orderLineQty;
            UnitOfMeasureSymbol orderLineUnit;
            if (PdsGlobal::pdsIsCWItem(this.ItemId))
            {
                orderLineQty = orderLine.PdsCWQty;
                orderLineUnit = orderLine.pdsCWUnitId();
            }
            else
            {
                orderLineQty = orderLine.Qty;
                orderLineUnit = orderLine.Unit;
            }
            
            totalQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(
                this.ItemId,
                this.InventDimId,
                orderLineQty,
                orderLineUnit,
                this.UOM,
                NoYes::No,
                NoYes::No);

            totalQty += totalQty * overDeliveryPct / 100;

            while select sum(Qty), Uom from whsAsnItem
            group by Uom
                where whsAsnItem.InventTransId == this.InventTransId
            {
                totalAsnItemQty += EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.ItemId,
                                                                                                         this.InventDimId,
                                                                                                         whsAsnItem.Qty,
                                                                                                         whsAsnItem.UOM,
                                                                                                         this.UOM,
                                                                                                         NoYes::No,
                                                                                                         NoYes::No);
            }
        }
        else
        {
            totalQty = this.Qty;

            while select sum(Qty), Uom from whsAsnItem
            group by Uom
                where whsAsnItem.LoadLineRefRecId == this.RecId
            {
                totalAsnItemQty += EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.ItemId,
                                                                                                         this.InventDimId,
                                                                                                         whsAsnItem.Qty,
                                                                                                         whsAsnItem.UOM,
                                                                                                         this.UOM,
                                                                                                         NoYes::No,
                                                                                                         NoYes::No);
            }
        }

        ret = totalQty - totalAsnItemQty + _decreasingQty;

        if (ret < 0)
        {
            ret = 0;
        }
        else if (!_includeOverDelivery && ret > this.Qty)
        {
            ret = this.Qty;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkCreatedQtyAndQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work created quantity and the quantity fields of the specified load line.
    /// </summary>
    /// <param name = "_recId">The rec ID of the load line</param>
    /// <param name = "_inventQtyToAdjust">The inventory quantity to adjust</param>
    /// <param name = "_inventDimId">The invent dim ID</param>
    public static void updateWorkCreatedQtyAndQty(
                                            RecId               _recId,
                                            WHSWorkCreatedQty   _inventQtyToAdjust,
                                            InventDimId         _inventDimId)
    {
        WHSLoadLine::updateQuantities(false, _recId, _inventQtyToAdjust, _inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkCreatedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work created quantity of the specified load line.
    /// </summary>
    /// <param name = "_recId">The rec ID of the load line</param>
    /// <param name = "_inventQtyToAdjust">The inventory quantity to adjust</param>
    public static void updateWorkCreatedQty(RecId _recId, WHSWorkCreatedQty _inventQtyToAdjust)
    {
        WHSLoadLine::updateQuantities(true, _recId, _inventQtyToAdjust);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuantities</Name>
				<Source><![CDATA[
    private static void updateQuantities(
                                boolean             _updateOnlyWorkCreatedQty,
                                RecId               _recId,
                                WHSWorkCreatedQty   _inventQtyToAdjust,
                                InventDimId         _inventDimId = '')
    {
        if (_recId)
        {
            ttsbegin;

            var lockLoadLineContext = WHSScheduleWorkCreationLockLoadLineContext::current();
            WHSLoadLine loadLine;

            if (lockLoadLineContext && lockLoadLineContext.parmLockLoadLine())
            {
                // We are intentionally locking the record/waiting to get the lock to avoid update conflicts
                // in scenarios with high number of parallel updates to the loadline.
                loadLine = WHSLoadLine::findByRecIdWithPessimisticLock(_recId);
            }
            else
            {
                loadLine = WHSLoadLine::findbyRecId(_recId, true);
            }

            loadLine.WorkCreatedQty += _inventQtyToAdjust;

            if (!_updateOnlyWorkCreatedQty)
            {
                EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

                loadLine.Qty += releasedProductUnitConverter.convert(_inventQtyToAdjust,
                                                            UnitOfMeasure::unitOfMeasureIdBySymbol(WHSCatchWeightHelper::inventHandlingUnitId(loadLine.ItemId)),
                                                            UnitOfMeasure::unitOfMeasureIdBySymbol(loadLine.uom),
                                                            NoYes::No,
                                                            loadLine.ItemId,
                                                            _inventDimId,
                                                            NoYes::No);
            }

            loadLine.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateQtyDemandForWorkAndQtyNotPhysRes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calulates the quantity demanded for work creation.
    /// </summary>
    /// <param name = "_includeLoadLineInventQty">Specifies if the load line inventory qty needs to be included in the calculations</param>
    /// <returns>
    /// A container with the quantity in the inventory unit which work should be created for and the quantity
    /// that is not physically reserved.
    /// </returns>
    public container calculateQtyDemandForWorkAndQtyNotPhysRes(boolean _includeLoadLineInventQty = true)
    {
        WHSLoadLine sumLoadLine;

        // Determine how much quantity is available for work creation.
        select sum(InventQty), sum(WorkCreatedQty), sum(CrossDockQuantity) from sumLoadLine
            where sumLoadLine.InventTransId == this.InventTransId &&
                  sumLoadLine.InventDimId   == this.InventDimId;

        InventHandlingQty qtyNotPhysicallyReserved;
        InventHandlingQty workQtyDemand;

        if (sumLoadLine.CrossDockQuantity)
        {
            workQtyDemand = this.CrossDockReservedPhysical - (this.WorkCreatedQty - WHSCrossDockLoadLine::calculateProcessedCrossDockQuantity(this.RecId));
            qtyNotPhysicallyReserved = this.InventQty - this.CrossDockReservedPhysical;
        }
        else
        {
            InventHandlingQty handlingQtyPhysicallyReserved = WHSInvent::calculateCommittedHandlingQuantity(this.InventTransId, this.InventDimId);

            // Max qty available for work creation is Total Qty on load line minus work created qty minus total qty on load lines that has yet to be reserved.
            workQtyDemand = handlingQtyPhysicallyReserved - sumLoadLine.WorkCreatedQty - this.sumOfTmpWorkLineInventQty();

            if (_includeLoadLineInventQty)
            {
                workQtyDemand = min(workQtyDemand, this.InventQty - this.WorkCreatedQty);
            }

            qtyNotPhysicallyReserved  = sumLoadLine.InventQty - handlingQtyPhysicallyReserved;
        }

        return [workQtyDemand, qtyNotPhysicallyReserved];
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumOfTmpWorkLineInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calulates the quantity for which temporary work lines have already been created for the same inventory transaction id and inventory dimensions id.
    /// </summary>
    /// <returns>
    /// The quantity which was already considered for temporary work lines.
    /// </returns>
    private InventHandlingQty sumOfTmpWorkLineInventQty()
    {
        WHSTmpWorkLine  tmpWorkLine;
        WHSWaveTable    wave;

        tmpWorkLine.allowIndexHint(true);
        // We assume that when processing a wave in batch the wave status will be executing.
        // WHSTmpWorkLines which were created but not cleaned up should be ignored adding this condition.
        select forceselectorder forcenestedloop sum(InventQty) from tmpWorkLine
            index hint InventTransIdIdx
            where tmpWorkLine.InventTransId == this.InventTransId
                && tmpWorkLine.InventDimId  == this.InventDimId
                && tmpWorkLine.WorkType     == WHSWorkType::Pick
            exists join wave
                where wave.WaveId       == tmpWorkLine.WaveId
                    && wave.WaveStatus  == WHSWaveStatus::Executing;

        return tmpWorkLine.InventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceTransportData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the load line with a source transport request data.
    /// </summary>
    /// <param name = "_sourceTransportRequest">A source transport request.</param>
    public void updateSourceTransportData(TMSTransportRequestTable _sourceTransportRequest)
    {
        this.ParentInventTransType      = this.InventTransType;
        this.ParentOrderNum             = this.OrderNum;

        if (this.InventTransType == InventTransType::Purch)
        {
            this.OrderNum                = _sourceTransportRequest.TransportRequestId;
            this.TransportRequest        = NoYes::Yes;
        }

        if (!this.validateWrite())
        {
            throw error(strFmt("@WAX:WHSCannotWriteRecordInTable", tablePName(WHSLoadLine)));
        }
        else
        {
            this.write();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>decrementWorkCreatedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decrement the <c>WorkCreatedQty</c> for the specified load line, as well as tracking information for the load line during wave processing.
    /// </summary>
    /// <param name = "_loadLineRecId">Load line record identifier.</param>
    /// <param name = "_workCreatedQtyDecrement">Quantity to decrement by.</param>
    /// <param name = "_waveId">Wave identifier used to update the tracking information for the load line during wave processing.</param>
    public static void decrementWorkCreatedQty(RecId _loadLineRecId, InventQty _workCreatedQtyDecrement, WHSWaveId _waveId = '')
    {
        if (WHSLoadLine::validWorkCreatedQtyUpdateParameters(_loadLineRecId, _workCreatedQtyDecrement))
        {
            WHSLoadLine::decrementLoadLineAndWaveUpdatedDeltaTrackingWorkCreatedQty(_loadLineRecId, _workCreatedQtyDecrement, _waveId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>decrementWaveUpdatedLoadLineWorkCreatedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decrement the work created quantity tracking information for the load line during wave processing.
    /// </summary>
    /// <param name = "_loadLineRecId">Load line record identifier.</param>
    /// <param name = "_workCreatedQtyDecrement">Quantity to decrement by.</param>
    /// <param name = "_waveId">Wave identifier used to update the tracking information for the load line during wave processing.</param>
    public static void decrementWaveUpdatedLoadLineWorkCreatedQty(RecId _loadLineRecId, InventQty _workCreatedQtyDecrement, WHSWaveId _waveId)
    {
        if (WHSLoadLine::validWorkCreatedQtyUpdateParameters(_loadLineRecId, _workCreatedQtyDecrement))
        {
            WHSLoadLine::decrementWaveLineWorkCreatedQty(_loadLineRecId, _workCreatedQtyDecrement, _waveId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>decrementLoadLineAndWaveUpdatedDeltaTrackingWorkCreatedQty</Name>
				<Source><![CDATA[
    private static void decrementLoadLineAndWaveUpdatedDeltaTrackingWorkCreatedQty(RecId _loadLineRecId, InventQty _workCreatedQtyDecrement, WHSWaveId _waveId)
    {
        WHSLoadLine loadLine = WHSLoadLine::findbyRecId(_loadLineRecId, true);
        if (loadLine.RecId)
        {
            loadLine.WorkCreatedQty -= _workCreatedQtyDecrement;
            loadLine.update();

            if (_waveId)
            {
                WHSLoadLine::decrementWaveUpdatedLoadLineWorkCreatedQty(_loadLineRecId, _workCreatedQtyDecrement, _waveId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>decrementWaveLineWorkCreatedQty</Name>
				<Source><![CDATA[
    private static void decrementWaveLineWorkCreatedQty(RecId _loadLineRecId, InventQty _workCreatedQtyDecrement, WHSWaveId _waveId)
    {
        WHSWaveUpdatedLoadLine waveUpdLoadLine = WHSWaveUpdatedLoadLine::find(_waveId, _loadLineRecId, true);
        if (waveUpdLoadLine)
        {
            waveUpdLoadLine.WorkCreatedQtyDelta -= _workCreatedQtyDecrement;
            if (waveUpdLoadLine.WorkCreatedQtyDelta < 0)
            {
                throw error(strFmt("@WAX:DecreasingWorkCreatedQtyDeltaToNegativeError", _workCreatedQtyDecrement, _loadLineRecId, _waveId));
            }
            waveUpdLoadLine.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceQuantitiesForLoadToMatchPickedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reduce the quantity on the load line if the actual picked quantity is less than the quantity to be loaded.
    /// </summary>
    /// <param name = "_loadId">Load ID used to select the <c>WHSLoadLine</c>.</param>
    public static void reduceQuantitiesForLoadToMatchPickedQuantity(WHSLoadId _loadId)
    {
        if (WHSLoadLine::shouldLoadQtyBeReducedToMatchPickedQuantity(_loadId))
        {
            WHSLoadLine loadLine;

            while select forupdate loadLine
                where loadLine.LoadId == _loadId
            {
                loadLine.reduceLineQuantityToMatchPickedQuantity();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldLoadQtyBeReducedToMatchPickedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the load quantity can be reduced based on the load and work statuses.
    /// </summary>
    /// <param name = "_loadId">Load ID used to select the <c>WHSLoadLine</c>.</param>
    /// <returns>true if the load qty can be reduced; otherwise, false</returns>
    private static boolean shouldLoadQtyBeReducedToMatchPickedQuantity(WHSLoadId _loadId)
    {
        boolean ret;
        WHSLoadTable loadTable = WHSLoadTable::find(_loadId);

        // Only for load that has work or work in completed state. In certain scenarios like sales line with TMS enabled items
        // during confirmation no work is created but the shipment should be confirmed. Similarly a transfer order with single
        // line and if short picked to 0, the load.hasWork() returns false, so we need to ensure the work is completed.
        if (loadTable.LoadingStrategy == WHSLoadingStrategy::FullLoadShippingOnly
            && (loadTable.hasWork() || WHSWorkTable::isWorkComplete(loadTable.LoadId)))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceLineQuantityToMatchPickedQuantity</Name>
				<Source><![CDATA[
    private void reduceLineQuantityToMatchPickedQuantity()
    {
        if (this.shouldLineQuantityBeReducedToMatchPickedQuantity())
        {
            EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
            this.Qty = releasedProductUnitConverter.convert(this.PickedQty,
                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(WHSCatchWeightHelper::inventHandlingUnitId(this.ItemId)),
                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(this.uom),
                                                        NoYes::No,
                                                        this.ItemId,
                                                        this.InventDimId,
                                                        NoYes::No);
            if (this.Qty == 0 && WHSLoadLine::preventZeroQuantity())
            {
                warning(strFmt("@WAX:LoadLineWarningUpdatedToZero", this.ItemId, this.ShipmentId));
            }
            this.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preventZeroQuantity</Name>
				<Source><![CDATA[
    static public boolean preventZeroQuantity()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldLineQuantityBeReducedToMatchPickedQuantity</Name>
				<Source><![CDATA[
    private boolean shouldLineQuantityBeReducedToMatchPickedQuantity()
    {        
        return this.isForOutboundShipment() && this.isPickedQtyWithInUnderDeliveryLimits();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPickedQtyWithInUnderDeliveryLimits</Name>
				<Source><![CDATA[
    private boolean isPickedQtyWithInUnderDeliveryLimits()
    {
        boolean ret;

        if (this.InventQty > 0 && this.InventQty > this.PickedQty)
        {
            real result = ((this.PickedQty - this.InventQty) / this.InventQty) * 100;
            ret = (result < 0 && abs(result) <= this.UnderDeliveryPct);

            if (!ret
                && WHSUseLockForShipConfirmAndReducePickedQtyV3Flight::instance().isEnabled())
            {
                throw Error(strfmt("@WAX:WHSUnderdeliveryConcurrentIssueError", this.LoadId, this.ItemId));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNonNegativeWorkCreatedQty</Name>
				<Source><![CDATA[
    internal void validateNonNegativeWorkCreatedQty()
    {
        if (this.WorkCreatedQty < 0)
        {
            throw error(strFmt("@WAX:Error_LoadLineWorkCreatedQtyNegative", this.RecId, this.LoadId, this.ItemId, this.WorkCreatedQty));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validWorkCreatedQtyUpdateParameters</Name>
				<Source><![CDATA[
    private static boolean validWorkCreatedQtyUpdateParameters(RecId _loadLineRecId, InventQty _workCreatedQtyDecrement)
    {
        return _loadLineRecId != 0 && _workCreatedQtyDecrement > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInboundTransportRequestLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the load line is an inbound transport request line.
    /// </summary>
    /// <returns>true if the load line is an inbound transport request line; otherwise, false</returns>
    public boolean isInboundTransportRequestLine()
    {
        return this.TransportRequest == NoYes::Yes
            && this.LoadDirection    == WHSLoadDirection::Inbound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInboundLoadFromTransportRequestLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes and update the load line and load with the given transport request line values.
    /// </summary>
    /// <param name = "_transportRequestLine">The <c>TMSTransportRequestLine</c> record used to update the load and load line.</param>
    public void initializeInboundLoadFromTransportRequestLine(TMSTransportRequestLine _transportRequestLine)
    {
        this.OrderNum         = _transportRequestLine.OrderNum;
        this.InventTransType  = _transportRequestLine.InventTransType;
        this.update();

        WHSLoadTable loadTable = this.whsLoadTable(true);
        loadTable.OrderNum = this.OrderNum;
        loadTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceToPickedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reduces quantities on the load line.
    /// </summary>
    /// <param name="_performRounding">Specifies whether rounding should be performed when converting picked quantity in inventory unit to load line unit of measure.</param>
    [Hookable(false)]
    internal void reduceToPickedQuantity(boolean _performRounding = NoYes::Yes)
    {
        this.WorkCreatedQty = this.PickedQty;
        this.InventQty      = this.PickedQty;

        this.Qty            = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.ItemId,
                                                                                                    this.InventDimId,
                                                                                                    this.InventQty,
                                                                                                    WHSCatchWeightHelper::inventHandlingUnitId(this.ItemId),
                                                                                                    this.UOM,
                                                                                                    NoYes::Yes,
                                                                                                    _performRounding);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCrossDockConsumedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums the total quantity of inventory that is physically reserved or greater, and is assigned to load lines through cross docking.
    /// </summary>
    /// <returns>
    /// The quantity, in the inventory unit, that is physically reserved on the source order and has been assigned to loadLines with the same dimensions.
    /// </returns>
    /// <remarks>
    /// Consumed physically reserved = sum(LL.physRes) + (sum(CDLL.InvQty) - sum(CDLL.QtyRem))
    /// Sum quantity across the transaction + inventDim criteria.
    /// </remarks>
    [Hookable(false)]
    internal InventHandlingQty calculateCrossDockConsumedQuantity()
    {
        WHSLoadLine loadLine;

        select sum(CrossDockReservedPhysical) from loadLine
            where loadLine.InventTransId    == this.InventTransId
            &&    loadLine.InventDimId      == this.InventDimId
            &&    !loadLine.Invalid;

        InventHandlingQty tmpQty = loadLine.CrossDockReservedPhysical;

        WHSCrossDockLoadLine crossDockLoadLine;

        select sum(InventHandlingQty), sum(InventHandlingQtyRemain) from crossDockLoadLine
            exists join loadLine
            where loadLine.RecId            == crossDockLoadLine.LoadLineRecId
            &&    loadLine.InventTransId    == this.InventTransId
            &&    loadLine.InventDimId      == this.InventDimId
            &&    !loadLine.Invalid;

        // The difference between the InventQty and the InventRemainQty should represent cross docking that has already been received and physically reserved.
        tmpQty += (crossDockLoadLine.InventHandlingQty - crossDockLoadLine.InventHandlingQtyRemain);

        return tmpQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumCrossDockLoadLineQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the remaining inventory quantity of cross dock load lines that are associated to open planned cross docking.
    /// </summary>
    /// <returns>
    /// The total quantity, in the invent unit, that is marked and associated to open planned cross docking.
    /// </returns>
    /// <remarks>
    /// Sum quantity across the transaction + inventDim criteria.
    /// </remarks>
    [Hookable(false)]
    internal InventHandlingQty sumCrossDockLoadLineQuantity()
    {
        WHSLoadLine             loadLine;
        WHSCrossDockLoadLine    crossDockLoadLine;

        select sum(InventHandlingQtyRemain) from crossDockLoadLine
            exists join loadLine
            where crossDockLoadLine.LoadLineRecId   == loadLine.RecId
            &&    loadLine.InventTransId            == this.InventTransId
            &&    loadLine.InventDimId              == this.InventDimId
            &&    !loadLine.Invalid;

        return crossDockLoadLine.InventHandlingQtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>HMIMADRPointsForLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates ADR Hazardous material points for load line.
    /// </summary>
    /// <returns>ADR points</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display Amount HMIMADRPointsForLoadLine()
    {
        InventTable      inventTable;
        HMIMItemMaterial itemMaterial;

        select firstonly RecId from inventTable
            where inventTable.ItemId == this.ItemId
                && InventTable.HMIMIndicator == NoYes::Yes
        join Qty, Multiplier from itemMaterial
            where itemMaterial.ItemId == inventTable.ItemId
                && itemMaterial.RegCode == this.whsLoadTable().HMIMGetRegCode();

        return  this.HMIMHandlingQty() * itemMaterial.Qty *  itemMaterial.Multiplier;
    }

]]></Source>
			</Method>
			<Method>
				<Name>HMIMLimitedQtyNetWeightForLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates Limited Quantity Net Weight for load line.
    /// </summary>
    /// <returns>Limited Quantity NetWeight</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display ItemNetWeight HMIMLimitedQtyNetWeightForLoadLine()
    {
        InventTable      inventTable;
        HMIMItemMaterial itemMaterial;

        select firstonly NetWeight from inventTable
            where inventTable.ItemId == this.ItemId
                && InventTable.HMIMIndicator == NoYes::Yes
        exists join itemMaterial
            where itemMaterial.ItemId == inventTable.ItemId
                && itemMaterial.RegCode == this.whsLoadTable().HMIMGetRegCode()
                && itemMaterial.LimitedQty == NoYes::Yes;

        return  this.displayInventQty() * inventTable.NetWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>HMIMHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the Hazardous material regulation's unit of measure quantity associated with the item on the Load Line.
    /// </summary>
    /// <returns>
    /// The handling quantity for the item.
    /// </returns>
    internal InventHandlingQty HMIMHandlingQty()
    {
        EcoResProductUnitConverter ecoResProductUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(this.ItemId,
                                                                                                                                  this.InventDimId,
                                                                                                                                  this.UOM,
                                                                                                                                  this.HMIMHandlingUOM(),
                                                                                                                                  NoYes::Yes);
        if (ecoResProductUnitConverter.canValueBeConverted())
        {
            return ecoResProductUnitConverter.convertValue(this.Qty);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>HMIMHandlingUOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the Hazardous material regulation's unit of measure associated with the item on the Load Line.
    /// </summary>
    /// <returns>
    /// The handling unit of measure for the item.
    /// </returns>
    internal UnitOfMeasureSymbol HMIMHandlingUOM()
    {
        return HMIMItemMaterial::findByItemRegCode(this.ItemId, this.whsLoadTable().HMIMGetRegCode()).UnitOfMeasure;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registeredInboundQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// For a load line linked to a purchase order, retrieves the registered quantity of the purchase order line linked to this load.
    /// If the item is WHS enabled, this only includes the quantity registered against the specific load. If the item is only TMS enabled, this is the registered quantity on the purchase order.
    /// </summary>
    /// <returns>
    /// Container with registered quantities in three units: [inventory, catch weight, purchase order line unit]
    /// </returns>
    [Hookable(false)]
    internal WhsItemQty registeredInboundQuantity()
    {
        if (!this.isForExternalInboundShipment())
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        WHSReceiptOrderLine orderLine = this.sourceOrder();
        if (!orderLine || !orderLine.isStocked())
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }
        
        InventQty inventQty;
        PdsCWQty cwQty;
        Qty orderQty;
        if (WHSInventEnabled::exist(orderLine.ItemId))
        {
            var inventTransIdSum = InventTransIdSum_WHSLoad::newLoad(InventTransOrigin::findByInventTransId(this.InventTransId).RecId, this.LoadId);

            inventQty = inventTransIdSum.registered();
            cwQty = inventTransIdSum.pdsCWRegistered();
            orderQty = orderLine.unitConvertInvent2Order(inventTransIdSum.registered());
        }
        else
        {
            // Used for TMS enabled items
            inventQty = orderLine.registered();
            cwQty = orderLine.pdsCWRegistered();
            orderQty = orderLine.unitConvertInvent2Order(inventQty);
        }
            
        return WhsItemQty::newFromAllUnits(orderLine.ItemId, inventQty, cwQty, orderQty, orderLine.Unit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>receivedInboundQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// For a load line linked to a purchase order, retrieves the received (registered + physically updated + financially updated) quantity of the purchase order line linked to this load.
    /// If the item is WHS enabled, this only includes the quantity received against the specific load. If the item is only TMS enabled, this is the received quantity on the purchase order.
    /// </summary>
    /// <returns>
    /// Container with registered quantities in three units: [inventory, catch weight, purchase order line unit]
    /// </returns>
    [Hookable(false)]
    internal WhsItemQty receivedInboundQuantity()
    {
        WHSReceiptOrderLine orderLine = this.sourceOrder();
        if (!orderLine || !orderLine.isStocked())
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        if (WHSInventEnabled::exist(orderLine.ItemId))
        {
            var inventTransIdSum = InventTransIdSum_WHSLoad::newLoad(InventTransOrigin::findByInventTransId(this.InventTransId).RecId, this.LoadId);
            var receivedQtyInInventUnit = inventTransIdSum.registered() + inventTransIdSum.physical() + inventTransIdSum.financial();
            var receivedCwQty = inventTransIdSum.pdsCWRegistered() + inventTransIdSum.pdsCWPhysical() + inventTransIdSum.pdsCWFinancial();
            var receivedQtyInOrderUnit = orderLine.unitConvertInvent2Order(receivedQtyInInventUnit);

            return WhsItemQty::newFromAllUnits(orderLine.ItemId,
                                    receivedQtyInInventUnit,
                                    receivedCwQty,
                                    receivedQtyInOrderUnit,
                                    orderLine.Unit);
        }
        else
        {
            PurchLine purchLine = orderLine;
            if (!purchLine)
            {
                throw error(error::wrongUseOfFunction(funcName()));
            }

            // Used for TMS enabled items
            return WhsItemQty::newFromAllUnits(
                                    purchLine.ItemId,
                                    purchLine.registered() + purchLine.receivedInventInTotal(),
                                    purchLine.pdsCWRegistered() + purchLine.pdsCWReceivedInTotal(),
                                    purchLine.registeredInPurchUnit() + purchLine.receivedInTotal(),
                                    purchLine.PurchUnit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLoadLineAcceptReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// For a load line linked to a purchase order, determines whether the line can receive the specified quantity (expressed in given unit of measure), based on currently registered quantity against the load line and the load line quantity.
    /// </summary>
    /// <param name = "_qtyToReceive">Quantity to be received.</param>
    /// <param name = "_uomToReceive">Unit of measure for the quantity to be received.</param>
    /// <returns>true, if the receipt can be made against this load line; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean canLoadLineAcceptReceipt(Qty _qtyToReceive, UnitOfMeasureSymbol _uomToReceive)
    {
        boolean isDeliveryRatioAtOrBelowMaxAfterAdditionalQty = this.compareDeliveryRatioToMaxAfterReceipt(_qtyToReceive, _uomToReceive) <= 0;

        return isDeliveryRatioAtOrBelowMaxAfterAdditionalQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFullyReceived</Name>
				<Source><![CDATA[
    /// <summary>
    /// For an inbound load line, checks whether the line has registered quantity associated to it that is equal to the load line quantity.
    /// </summary>
    /// <returns>true, if the line has registrations equal to its quantity; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean isFullyReceived()
    {
        boolean isDeliveryRatioAtMaxEvenWithoutAdditionalQty = this.compareDeliveryRatioToMaxAfterReceipt(0, '') == 0;

        return isDeliveryRatioAtMaxEvenWithoutAdditionalQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFullyReceivedAfterAdditionalQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// For an inbound load line, checks whether the line will be fully received after an additional quantity (expressed in given unit of measure) is added to the currently registered quantity against the load.
    /// </summary>
    /// <param name = "_additionalQty">Additional quantity to add to currently registered.</param>
    /// <param name = "_additionalQtyUoM">Unit of measure for the additional quantity.</param>
    /// <returns>true, if the line has registrations equal to its quantity; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean isFullyReceivedAfterAdditionalQty(Qty _additionalQty, UnitOfMeasureSymbol _additionalQtyUoM)
    {
        boolean isDeliveryRatioAtMaxAfterAdditionalQty = this.compareDeliveryRatioToMaxAfterReceipt(_additionalQty, _additionalQtyUoM) == 0;

        return isDeliveryRatioAtMaxAfterAdditionalQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>compareDeliveryRatioToMaxAfterReceipt</Name>
				<Source><![CDATA[
    private int compareDeliveryRatioToMaxAfterReceipt(Qty _qtyToReceive, UnitOfMeasureSymbol _uomToReceive)
    {
        WHSReceiptOrderLine orderLine = this.sourceOrder();
        if (!orderLine || !orderLine.isStocked())
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        var loadLineReceivedQty = this.receivedInboundQuantity();

        var releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
        var receivingQtyInHandlingUnit = releasedProductUnitConverter.convert(_qtyToReceive,
                                                                UnitOfMeasure::unitOfMeasureIdBySymbol(_uomToReceive),
                                                                UnitOfMeasure::unitOfMeasureIdBySymbol(WHSCatchWeightHelper::inventHandlingUnitId(orderLine.ItemId)),
                                                                NoYes::No,
                                                                orderLine.ItemId,
                                                                orderLine.InventDimId,
                                                                NoYes::No);

        Qty receivedQtyAfterReceipt;

        if (this.isCWItem())
        {
            receivedQtyAfterReceipt = loadLineReceivedQty.qtyInCWUnit() + receivingQtyInHandlingUnit;
        }
        else
        {
            receivedQtyAfterReceipt = loadLineReceivedQty.qtyInInventUnit() + receivingQtyInHandlingUnit;
        }

        var deliveryRatio = (receivedQtyAfterReceipt / this.InventQty);
        var maxDeliveryRatio = (1.0 + (this.OverDeliveryPct / 100.0));

        switch (true)
        {
            case deliveryRatio <  maxDeliveryRatio:
                return -1;
            case deliveryRatio == maxDeliveryRatio:
                return 0;
            default:
                return 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    [Hookable(false)]
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLineReceived</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean checkLineReceived()
    {
        if (this.LoadDirection != WHSLoadDirection::Inbound)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (WHSInventEnabled::exist(this.ItemId))
        {
            return this.checkLineReceivedWHS();
        }

        return this.checkLineReceivedTMS();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLineReceivedWHS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the load line is considered received for WHS enabled items. In this case, the received and purchased qty in inventory linked to this load line need to cover this load line. Additionaly, no registered quantities are allowed.
    /// </summary>
    /// <returns>True, if the line is considered received; otherwise, false.</returns>
    private boolean checkLineReceivedWHS()
    {
        InventTransIdSum inventTransIdSum;

        if (WHSReceiptOrderLine::shouldIgnoreInventTransLoadIdToDetermineRegisteredQty(this.InventTransId))
        {
            inventTransIdSum = InventTransIdSum::newTransOriginId(InventTransOrigin::findByInventTransId(this.InventTransId).RecId);
        }
        else
        {
            inventTransIdSum = InventTransIdSum_WHSLoad::newLoad(InventTransOrigin::findByInventTransId(this.InventTransId).RecId, this.LoadId);
        }

        if (inventTransIdSum.registered() || inventTransIdSum.pdsCWRegistered())
        {
            return false;
        }

        WHSInventQty receivedAndPurchasedHandlingQty;

        // Deducted and Sold included as they are the cancellations of Received and Purchased
        if (PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            receivedAndPurchasedHandlingQty = inventTransIdSum.pdsCWReceived() + inventTransIdSum.pdsCWDeducted() + inventTransIdSum.pdsCWPurchased() + inventTransIdSum.pdsCWSold();
        }
        else
        {
            receivedAndPurchasedHandlingQty = inventTransIdSum.received() + inventTransIdSum.deducted() + inventTransIdSum.purchased() + inventTransIdSum.pdsSold();
        }

        if (receivedAndPurchasedHandlingQty < this.InventQty)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLineReceivedTMS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the load line is considered received for TMS-only items. In this case, the total received and purchased qty in inventory need to be sufficient to cover this load line and all other
    /// already received load lines. Additionaly, no registered quantities are allowed.
    /// </summary>
    /// <returns>True, if the line is considered received; otherwise, false.</returns>
    private boolean checkLineReceivedTMS()
    {
        var inventTransIdSum = InventTransIdSum::newTransOriginId(InventTransOrigin::findByInventTransId(this.InventTransId).RecId);

        if (inventTransIdSum.registered() || inventTransIdSum.pdsCWRegistered())
        {
            return false;
        }

        WHSInventQty receivedAndPurchasedHandlingQty;

        // Deducted and Sold included as they are the cancellations of Received and Purchased.
        if (PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            receivedAndPurchasedHandlingQty = inventTransIdSum.pdsCWReceived() + inventTransIdSum.pdsCWDeducted() + inventTransIdSum.pdsCWPurchased() + inventTransIdSum.pdsCWSold();
        }
        else
        {
            receivedAndPurchasedHandlingQty = inventTransIdSum.received() + inventTransIdSum.deducted() + inventTransIdSum.purchased() + inventTransIdSum.pdsSold();
        }

        WHSLoadLine otherReceivedLoadLineForInventTransId;
        WHSLoadTable otherReceivedLoadTableForInventTransId;

        select sum(InventQty) from otherReceivedLoadLineForInventTransId
            where otherReceivedLoadLineForInventTransId.RecId != this.RecId
               && otherReceivedLoadLineForInventTransId.InventTransId == this.InventTransId
            exists join otherReceivedLoadTableForInventTransId
                where otherReceivedLoadTableForInventTransId.LoadId == otherReceivedLoadLineForInventTransId.LoadId
                   && otherReceivedLoadTableForInventTransId.LoadStatus == WHSLoadStatus::Received;

        if (receivedAndPurchasedHandlingQty < (this.InventQty + otherReceivedLoadLineForInventTransId.InventQty))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyInUOM</Name>
				<Source><![CDATA[
    internal real qtyInUOM(UnitOfMeasureSymbol _toUnitId)
    {
        EcoResProductUnitConverter unitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(
                                                                            this.ItemId,
                                                                            this.InventDimId,
                                                                            this.UOM,
                                                                            _toUnitId,
                                                                            NoYes::Yes);
        if (unitConverter.canValueBeConverted())
        {
            return unitConverter.convertValue(this.Qty);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteZeroLoadLines</Name>
				<Source><![CDATA[
    public static void deleteZeroLoadLines(WHSWorkId _workId)
    {
        WHSWorkLine workLine;
        WHSLoadLine loadLine;

        ttsbegin;

        delete_from loadLine
                where !loadLine.Qty
            exists join workLine
            where loadLine.RecId  == workLine.LoadLineRefRecId
                  && workLine.WorkId == _workId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderLineInventMovement</Name>
				<Source><![CDATA[
    public InventMovement orderLineInventMovement()
    {
        InventMovement inventMovement;

        switch(this.InventTransType)
        {
            case InventTransType::Sales:
                inventMovement = InventMov_Sales::newFromSalesLine(this.salesLine());
                break;
            case InventTransType::Purch:
                inventMovement = InventMov_Purch::newFromPurchLine(this.purchLine());
                break;
            case InventTransType::TransferOrderShip:
                inventMovement = InventMov_TransferFrom::newFromInventTransferLine(this.inventTransferLine());
                break;
        }

        return inventMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmarkPlannedCrossDockQty</Name>
				<Source><![CDATA[
    private void unmarkPlannedCrossDockQty(WHSCrossDockLoadLine _whsCrossDockLoadLine, WHSLoadLine _whsLoadLine)
    {
        while (_whsCrossDockLoadLine)
        {
            _whsCrossDockLoadLine.unmarkPlannedCrossDockQty(-_whsCrossDockLoadLine.InventQtyMarked, _whsLoadLine);

            next _whsCrossDockLoadLine;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the order line associated with the current record.
    /// </summary>
    /// <param name = "_forUpdate">A Boolean value that indicates whether to read the record for update; optional.</param>
    /// <returns>The  order line record.</returns>
    public Common sourceOrder(boolean _forUpdate = false)
    {
        Common sourceOrder;

        switch (this.InventTransType)
        {
            case InventTransType::Sales:
                SalesLine salesLine = this.salesLine(_forUpdate);

                sourceOrder = salesLine;
                break;

            case InventTransType::Purch:
                PurchLine purchLine = this.purchLine(_forUpdate);

                sourceOrder = purchLine;
                break;

            case InventTransType::TransferOrderShip:
                InventTransferLine inventTransferLine = this.inventTransferLine(_forUpdate);

                sourceOrder = inventTransferLine;
                break;
        }

        return sourceOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSourceOrder</Name>
				<Source><![CDATA[
    public void initFromSourceOrder(Common _sourceOrder)
    {
        if (_sourceOrder is SalesLine)
        {
            this.initFromSalesLine(_sourceOrder);
        }
        else if (_sourceOrder is PurchLine)
        {
            this.initFromPurchLine(_sourceOrder);
        }
        else if (_sourceOrder is InventTransferLine)
        {
            this.initFromTransferLine(_sourceOrder);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doUpdateValidateIfCanModify</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void doUpdateValidateIfCanModify()
    {
        this.validateIfAllowedToModify();
        this.doUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsForReleaseToWarehouseId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean existsForReleaseToWarehouseId(WHSReleaseToWarehouseId _releaseToWarehouseId)
    {
        WHSLoadLine loadLine;

        select firstonly RecId from loadLine
            where loadLine.ReleaseToWarehouseId == _releaseToWarehouseId;

        return loadLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForOutboundShipment</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean isForOutboundShipment()
    {
        return this.InventTransType == InventTransType::Sales
            || this.InventTransType == InventTransType::TransferOrderShip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>receivedInventoryQuantity</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal Qty receivedInventoryQuantity()
    {
        if (this.LoadDirection == WHSLoadDirection::Inbound)
        {
            InventTransIdSum_WHSLoad inventTransIdSum = InventTransIdSum_WHSLoad::newLoad(InventTransOrigin::findByInventTransId(this.InventTransId).RecId, this.LoadId);
            return inventTransIdSum.registered();
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUnderOrOverDelivery</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean isUnderOrOverDelivery()
    {
        if (this.LoadDirection != WHSLoadDirection::Inbound)
        {
            return false;
        }

        InventQty receivedInventQuantityForLoadLine = this.receivedInventoryQuantity();
        real result = ((receivedInventQuantityForLoadLine - this.InventQty) / this.InventQty) * 100;

        return (result < 0 && abs(result) > this.UnderDeliveryPct)
            || (result > 0 && result > this.OverDeliveryPct);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalWorkCreatedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums all work created quantity for the load line.
    /// </summary>
    /// <param name = "_inventTransId">
    /// The inventTransId for inventory transactions to sum qty from.
    /// </param>
    /// <returns>The total work created quantity for the load line.</returns>
    [Hookable(false)]
    internal static WHSWorkCreatedQty getTotalWorkCreatedQty(InventTransId _inventTransId)
    {
        WHSLoadLine loadLine;

        select sum(WorkCreatedQty) from loadLine
            where loadLine.InventTransId == _inventTransId;

        return loadLine.WorkCreatedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOnlyOneShipmentForOrder</Name>
				<Source><![CDATA[
    private void validateOnlyOneShipmentForOrder()
    {
        if (this.LoadDirection != WHSLoadDirection::Outbound
            || this.OrderNum == ''
            || !WHSValidateOneOrderOneShipmentSettingFlight::instance().isEnabled())
        {
            return;
        }

        WHSShipmentTable shipment = WHSShipmentTable::find(this.ShipmentId);
        WHSOutboundShipmentProcessingPolicy shipmentProcessingPolicy = WHSOutboundShipmentProcessingPolicy::find(shipment.OutboundShipmentProcessingPolicy);
        if (!shipmentProcessingPolicy.EnforceShipmentToOrderMatching)
        {
            return;
        }

        WHSLoadLine loadLine;
        select firstonly RecId from loadLine
            where loadLine.OrderNum == this.OrderNum
                && ((loadLine.ShipmentId != this.ShipmentId && loadLine.ShipmentId != '' && this.ShipmentId != '')
                    || (loadLine.LoadId != this.LoadId && loadLine.LoadId != '' && this.LoadId != ''))
                && loadLine.InventTransType == this.InventTransType
                && loadLine.RecId != this.RecId;

        if (loadLine.RecId)
        {
            throw error(strFmt("@WAX:OrderCanHaveOnlyOneShipment", this.OrderNum));
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>WHSandTMS</ConfigurationKey>
	<DeveloperDocumentation>@WAX4386</DeveloperDocumentation>
	<Label>@WAX313</Label>
	<TableGroup>WorksheetLine</TableGroup>
	<TitleField1>LoadId</TitleField1>
	<TitleField2>ItemId</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>FoundAndEmpty</CacheLookup>
	<ClusteredIndex>LoadIdIdx</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Inventory</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LoadId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UOM</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCreatedQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShipmentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtyLeftToStructure</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PackingQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadDirection</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OverDeliveryPct</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UnderDeliveryPct</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReleaseToWarehouseId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransportRequest</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentOrderNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentInventTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadClosedUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadInProcessUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadOpenUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadReadyToShipUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PickedQty</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@WAX2277</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LoadId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UOM</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCreatedQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShipmentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtyLeftToStructure</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PackingQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadDirection</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OverDeliveryPct</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UnderDeliveryPct</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReleaseToWarehouseId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransportRequest</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentOrderNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentInventTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadClosedUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadInProcessUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadOpenUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadReadyToShipUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PickedQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Invalid</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShipConsolidationPolicy</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dates</Name>
			<Label>@SYS80293</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LoadOpenUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadInProcessUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadReadyToShipUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadClosedUTCDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Delivery</Name>
			<Label>@SYS4508</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OverDeliveryPct</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UnderDeliveryPct</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PackingQty</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>General</Name>
			<Label>@WAX3670</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LoadId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadDirection</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransportRequest</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShipmentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReleaseToWarehouseId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Inventory</Name>
			<Label>@SYS981</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Order</Name>
			<Label>@SYS69861</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OrderNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UOM</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCreatedQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>displayInventUOM</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>displayWorkStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadDirection</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>FiscalDocumentShipmentParcel_BR</Name>
			<Label>@GLS63846</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VolumeQty_BR</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VolumeType_BR</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Invalid</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSInvalid</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>InventQty</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSInventQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>OII</AssetClassification>
			<ExtendedDataType>InventTransId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InventTransType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>InventTransType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>LoadClosedUTCDateTime</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLoadClosedUTCDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LoadDirection</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>WHSLoadDirection</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LoadId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLoadId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>LoadInProcessUTCDateTime</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLoadInProcessUTCDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>LoadOpenUTCDateTime</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLoadOpenUTCDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>LoadReadyToShipUTCDateTime</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLoadReadyToShipUTCDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OrderNum</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSOrderNum</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>OverDeliveryPct</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>OverDeliveryPct</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PackingQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSPackingQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ParentInventTransType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>InventTransType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ParentOrderNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSOrderNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PickedQty</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSPickedQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>QCQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSQCQty</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Qty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProductQuantity</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>QtyLeftToStructure</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSQtyLeftToStructure</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReleaseToWarehouseId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSReleaseToWarehouseId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ShipmentId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSShipmentId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TransportRequest</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TMSTransportRequest</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>UnderDeliveryPct</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>UnderDeliveryPct</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>UOM</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSUOM</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>WorkCreatedQty</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkCreatedQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>VolumeQty_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>VolumeQty_BR</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VolumeType_BR</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>VolumeType_BR</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PickedWeight</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWeightPickedQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CrossDockEvaluatedQuantity</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSCrossDockEvaluatedQuantity</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CrossDockQuantity</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSCrossDockQuantity</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CrossDockReservedPhysical</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSCrossDockReservedPhysical</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ShipConsolidationPolicy</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>WHSShipConsolidationPolicyRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ItemNetWeight</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemNetWeight</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ItemTareWeight</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemTaraWeight</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>InventTransIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ShipmentId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>OrderNumIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>OrderNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransportRequest</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ShipmentId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ShipmentIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ShipmentId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransportRequest</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>OrderNum</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LoadIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>LoadId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ReleaseToWarehouseIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ReleaseToWarehouseId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ShipmentId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>InventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimId</Name>
					<SourceEDT>InventDimId</SourceEDT>
					<Field>InventDimId</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<SourceEDT>ItemId</SourceEDT>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTransferLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>InventTransferLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>InventTransType</Name>
					<Field>InventTransType</Field>
					<ValueStr>InventTransType::TransferOrderShip</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransId</Name>
					<Field>InventTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTransferTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransferTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>TransportRequest</Name>
					<Field>TransportRequest</Field>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>InventTransType</Name>
					<Field>InventTransType</Field>
					<ValueStr>InventTransType::TransferOrderShip</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>TransferId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOrigin</Name>
			<Cardinality>OneMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransId</Name>
					<SourceEDT>InventTransId</SourceEDT>
					<Field>InventTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventTransIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PurchLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>PurchLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>InventTransType</Name>
					<Field>InventTransType</Field>
					<ValueStr>InventTransType::Purch</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransId</Name>
					<Field>InventTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PurchTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PurchTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>TransportRequest</Name>
					<Field>TransportRequest</Field>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>InventTransType</Name>
					<Field>InventTransType</Field>
					<ValueStr>InventTransType::Purch</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>PurchId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>SalesLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>InventTransType</Name>
					<Field>InventTransType</Field>
					<ValueStr>InventTransType::Sales</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransId</Name>
					<Field>InventTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SalesTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>TransportRequest</Name>
					<Field>TransportRequest</Field>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>InventTransType</Name>
					<Field>InventTransType</Field>
					<ValueStr>InventTransType::Sales</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>SalesId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TMSTransportRequestTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TMSTransportRequestTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>TransportRequest</Name>
					<Field>TransportRequest</Field>
					<ValueStr>NoYes::Yes</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>TransportRequestId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>UnitOfMeasure</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UnitOfMeasure</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>UOM</Name>
					<Field>UOM</Field>
					<RelatedField>Symbol</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSInventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSInventTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSLoadTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>WHSLoadTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LoadId</Name>
					<SourceEDT>WHSLoadId</SourceEDT>
					<Field>LoadId</Field>
					<RelatedField>LoadId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WHSShipConsolidationPolicy</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSShipConsolidationPolicy</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ShipConsolidationPolicy</Name>
					<Field>ShipConsolidationPolicy</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSShipmentTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Cascade</OnDelete>
			<RelatedTable>WHSShipmentTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ShipmentId</Name>
					<SourceEDT>WHSShipmentId</SourceEDT>
					<Field>ShipmentId</Field>
					<RelatedField>ShipmentId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>UnitOfMeasureVolumeType_BR</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UnitOfMeasure</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>PackingVolumeUnitOfMeasure</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>PackingVolumeUnitOfMeasure</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VolumeType_BR</Name>
					<Field>VolumeType_BR</Field>
					<RelatedField>Symbol</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>