<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWaveTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class WHSWaveTable extends common
{

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>scheduledWorkCreationWaveStepMaximumRetries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines how many retry attempts are allowed for the scheduled work creation wave step.
    /// </summary>
    /// <returns>The number of allowed retry stpes.</returns>
    public int scheduledWorkCreationWaveStepMaximumRetries()
    {
        #OCCRetryCount

        return #RetryNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the user should be able to delete the record.
    /// </summary>
    /// <returns>
    /// true if the user should be able the edit the record otherwise false.
    /// </returns>
    public boolean allowDelete()
    {
        if (this.waveTemplate().WaveTemplateType == WHSWaveTemplateType::Shipping
            && this.waveStatus() == WHSWaveStatus::Picked
            && !this.existWaveLines())
        {
            return true;
        }

        return this.WaveStatus < WHSWaveStatus::Released
                && this.WaveStatus != WHSWaveStatus::Executing
                && !this.inBatch();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the user should be able to edit the record.
    /// </summary>
    /// <returns>
    /// true if the user should be able the edit the record otherwise false.
    /// </returns>
    public boolean allowEdit()
    {
        return this.WaveStatus == WHSWaveStatus::Created;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPercentComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the percentage of the work completed for the wave.
    /// </summary>
    /// <returns>
    /// The percentage of the work completed for the wave.
    /// </returns>
    real calcPercentComplete()
    {
        real ret = 0;
        WHSNumWorkCreated numWorkCreated = this.numWorkCreated();

        if (numWorkCreated)
        {
            ret = (1 - (this.numWorkRemaining() / numWorkCreated)) * 100;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the wave has work.
    /// </summary>
    /// <returns>true if the wave has work. false otherwise.</returns>
    [Hookable(false)]
    internal boolean hasWork()
    {
        int numWorkCreated = this.calculateNumOfWorkCreated(false);

        return numWorkCreated != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numWorkCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of work created for the wave.
    /// </summary>
    /// <returns>The number of work created.</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display WHSNumWorkCreated numWorkCreated()
    {
        return this.calculateNumOfWorkCreated(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNumOfWorkCreated</Name>
				<Source><![CDATA[
    private int calculateNumOfWorkCreated(boolean _returnCount)
    {
        WHSWorkTable workTable;

        if (_returnCount)
        {
            select count(RecId) from workTable
                where workTable.WaveId == this.WaveId
                &&    workTable.WorkTransType != WHSWorkTransType::TransferReceipt
                &&    workTable.WorkTransType != WHSWorkTransType::SortedInventoryPicking
                &&    workTable.WorkStatus != WHSWorkStatus::Cancelled;

            return int642int(workTable.RecId);
        }
        else
        {
            select firstonly RecId from workTable
                where workTable.WaveId == this.WaveId
                &&    workTable.WorkTransType != WHSWorkTransType::TransferReceipt
                &&    workTable.WorkTransType != WHSWorkTransType::SortedInventoryPicking
                &&    workTable.WorkStatus != WHSWorkStatus::Cancelled;

            return workTable.RecId ? 1 : 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>numWorkRemaining</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of work remaining for the wave.
    /// </summary>
    /// <returns>The number of work remaining.</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display WHSNumWorkRemaining numWorkRemaining()
    {
        WHSWorkTable    workTable;

        select count(RecId) from workTable
            where workTable.WaveId        == this.WaveId
            &&    workTable.WorkTransType != WHSWorkTransType::TransferReceipt
            &&    workTable.WorkTransType != WHSWorkTransType::SortedInventoryPicking
            &&    workTable.WorkStatus    < WHSWorkStatus::Closed;

        return int642int(workTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>countOpenWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Counts the amount of work in open status.
    /// </summary>
    /// <returns>
    /// The count of work in open status.
    /// </returns>
    int countOpenWork()
    {
        WHSWorkTable    workTable;

        select count(RecId) from workTable
            where workTable.WaveId       == this.WaveId &&
                  workTable.WorkStatus   == WHSWorkStatus::Open;

        return int642int(workTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>waveStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the wave status.
    /// </summary>
    /// <returns>
    /// The current wave status.
    /// </returns>
    /// <remarks>
    /// The waves are not moved into the picked state automatically, but remains in the Released state.
    /// To signal that a wave is fully picked this display method can be used.
    /// </remarks>
    [SysClientCacheDataMethodAttribute(true)]
    public display WHSWaveStatus waveStatus()
    {
        switch (this.WaveStatus)
        {
            case WHSWaveStatus::Released:          
                if (this.isAnyWorkRemaining())
                {
                    return WHSWaveStatus::Released;
                }
                return WHSWaveStatus::Picked;
        }

        return this.WaveStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAnyWorkRemaining</Name>
				<Source><![CDATA[
    private boolean isAnyWorkRemaining()
    {
        WHSWorkTable workTable;

        select firstonly RecId from workTable
            where workTable.WaveId        == this.WaveId
            &&    workTable.WorkTransType != WHSWorkTransType::TransferReceipt
            &&    workTable.WorkTransType != WHSWorkTransType::SortedInventoryPicking
            &&    workTable.WorkStatus    < WHSWorkStatus::Closed;

        return workTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        if (this.WaveStatus == WHSWaveStatus::Held)
        {
            WHSWorkTable workTable;

            while select WorkId from workTable
                where workTable.WaveId       == this.WaveId              &&
                      workTable.WorkStatus   != WHSWorkStatus::Cancelled &&
                      workTable.WorkStatus   != WHSWorkStatus::Closed    &&
                      workTable.WorkStatus   != WHSWorkStatus::Combined
            {
                WHSWorkTable::cancelWork(workTable.WorkId, false);
            }
        }

        this.reread();
        
        ttsbegin;
    
        this.deleteWaveProcessingStatusUsingIndexHint();

        super();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveProcessingStatusUsingIndexHint</Name>
				<Source><![CDATA[
    private void deleteWaveProcessingStatusUsingIndexHint()
    {
        WHSWaveProcessingStatus waveProcessingStatus;

        Microsoft.Dynamics.Ax.Xpp.PlatformExtensions.CommonExtensions::SetSqlDeleteIndexHint(waveProcessingStatus, indexStr(WHSWaveProcessingStatus, WaveWorkBuildIdx));

        delete_from waveProcessingStatus
            where waveProcessingStatus.WaveId == this.WaveId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayHasReplenishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display an image if the wave contains replenishment work.
    /// </summary>
    /// <returns>
    /// An image if the wave contains replenishment work.
    /// </returns>
    display container displayHasReplenishment()
    {
        if (this.hasReplenishment())
        {
            return ImageReference::constructForSymbol(ImageReferenceSymbol::Checkmark).pack();
        }

        return connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayInBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display an image if the wave is in batch.
    /// </summary>
    /// <returns>
    /// An image if the wave is in batch.
    /// </returns>
    display container displayInBatch()
    {
        if (this.inBatch())
        {
            return ImageReference::constructForSymbol(ImageReferenceSymbol::Processing).pack();
        }

        return connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPercentComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display the percentage of the completed work.
    /// </summary>
    /// <returns>
    /// The percentage of the completed work in string format.
    /// </returns>
    display WHSPercentCompleteStr displayPercentComplete()
    {
        return strFmt("@WAX1638", real2int(decRound(this.calcPercentComplete(), 0)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalGrossWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display total gross weight of the items in wave.
    /// </summary>
    /// <returns>
    /// The total gross weight of the items in wave.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display Weight displayTotalGrossWeight()
    {
        WHSWaveLine             waveLine;
        WHSLoadLine             loadLine;
        WHSProdWaveLine         prodWaveLine;
        WHSKanbanWaveLine       kanbanWaveLine;
        ProdBOM                 prodBOM;
        InventTable             inventTable;
        GrossWeight             grossWeight;

        switch (this.waveTemplate().WaveTemplateType)
        {
            case WHSWaveTemplateType::Shipping:
                while select WaveId from waveLine
                    where waveLine.WaveId == this.WaveId
                    join ItemId,Qty from loadLine
                        where loadLine.ShipmentId == waveLine.ShipmentId
                    join inventTable
                        where inventTable.ItemId == loadLine.ItemId
                {
                    grossWeight += inventTable.grossWeight() * loadLine.Qty;
                }
                break;
            case WHSWaveTemplateType::Production:
                while select ItemId from prodWaveLine
                    where prodWaveLine.WaveId == this.WaveId
                    join QtyInventCalc from prodBOM
                        where prodBOM.InventTransId == prodWaveLine.InventTransId
                    join inventTable
                        where inventTable.ItemId == prodWaveLine.ItemId
                {
                    grossWeight += inventTable.grossWeight() * prodBOM.QtyInventCalc;
                }
                break;
            case WHSWaveTemplateType::Kanban:
                KanbanJobPickingListAll kanbanJobPickingListAll;

                while select ItemId from kanbanWaveLine
                    where kanbanWaveLine.WaveId == this.WaveId
                    join Quantity from kanbanJobPickingListAll
                        where kanbanJobPickingListAll.InventTransId == kanbanWaveLine.InventTransId
                    join inventTable
                        where inventTable.ItemId == kanbanWaveLine.ItemId
                {
                    grossWeight += inventTable.grossWeight() * kanbanJobPickingListAll.Quantity;
                }
                break;
        }

        return grossWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display total quantity of the items in wave.
    /// </summary>
    /// <returns>
    /// The total quantity of the items in wave.
    /// </returns>
    display ProductQuantity displayTotalInventQty()
    {
        WHSLoadLine             loadLine;
        WHSWaveLine             waveLine;
        ProdBOM                 prodBOM;
        WHSProdWaveLine         prodWaveLine;
        WHSKanbanWaveLine       kanbanWaveLine;
        Qty                     qty;

        switch (this.waveTemplate().WaveTemplateType)
        {
            case WHSWaveTemplateType::Shipping:
                select sum(InventQty) from loadLine
                    exists join waveLine
                        where waveLine.WaveId == this.WaveId
                           && waveLine.ShipmentId == loadLine.ShipmentId;
                qty = loadLine.InventQty;
                break;

            case WHSWaveTemplateType::Production:
                select sum(QtyInventCalc) from prodBOM
                    exists join prodWaveLine
                        where prodWaveLine.InventTransId == prodBOM.InventTransId
                           && prodWaveLine.WaveId        == this.WaveId;
                qty = prodBOM.QtyInventCalc;
                break;

            case WHSWaveTemplateType::Kanban:
                KanbanJobPickingListAll kanbanJobPickingListAll;

                select sum(Quantity) from kanbanJobPickingListAll
                    exists join kanbanWaveLine
                        where kanbanWaveLine.WaveId        == this.WaveId
                           && kanbanWaveLine.InventTransId == kanbanJobPickingListAll.InventTransId;
                qty = kanbanJobPickingListAll.Quantity;
                break;
        }

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display the total amount of lines in the wave.
    /// </summary>
    /// <returns>
    /// The total amount of lines in the wave.
    /// </returns>
    display WHSTotalLines displayTotalLines()
    {
        WHSTotalLines   totalLines;

        switch (this.waveTemplate().WaveTemplateType)
        {
            case WHSWaveTemplateType::Shipping:
                totalLines = (select count(RecId) from whsWaveLine
                                where whsWaveLine.WaveId == this.WaveId).RecId;
                break;
            case WHSWaveTemplateType::Production:
                totalLines = (select count(RecId) from whsProdWaveLine
                                where whsProdWaveLine.WaveId == this.WaveId).RecId;
                break;
            case WHSWaveTemplateType::Kanban:
                totalLines = (select count(RecId) from whsKanbanWaveLine
                                where whsKanbanWaveLine.WaveId == this.WaveId).RecId;
                break;
        }

        return totalLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existWaveLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the current wave has lines.
    /// </summary>
    /// <returns>
    /// true if the current wave has lines; otherwise, false.
    /// </returns>
    [Hookable(false)]
    internal boolean existWaveLines()
    {
        switch (this.waveTemplate().WaveTemplateType)
        {
            case WHSWaveTemplateType::Shipping:
                return (select firstonly RecId from whsWaveLine
                            where whsWaveLine.WaveId == this.WaveId).RecId != 0;

            case WHSWaveTemplateType::Production:
                return (select firstonly RecId from whsProdWaveLine
                            where whsProdWaveLine.WaveId == this.WaveId).RecId != 0;

            case WHSWaveTemplateType::Kanban:
                return (select firstonly RecId from whsKanbanWaveLine
                            where whsKanbanWaveLine.WaveId == this.WaveId).RecId != 0;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalLoadLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display total amount of load lines in the wave.
    /// </summary>
    /// <returns>
    /// The total amount of load lines in the wave.
    /// </returns>
    display WHSTotalLoadLines displayTotalLoadLines()
    {
        WHSWaveLine         waveLine;
        WHSLoadLine         loadLine;

        select count(RecId) from loadLine
            join WaveId from waveLine
            where loadLine.ShipmentId    == waveLine.ShipmentId &&
                  waveLine.WaveId        == this.WaveId;

        return loadLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// The method to display total number of orders in the wave.
    /// </summary>
    /// <returns>
    /// The total number of orders in the wave.
    /// </returns>
    display RefRecId displayTotalOrders()
    {
        return (select count(RecId) from whsWaveLine
                    group by OrderNum
                    where whsWaveLine.WaveId == this.WaveId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalVolume</Name>
				<Source><![CDATA[
    /// <summary>
    /// The method to display total volume of the wave.
    /// </summary>
    /// <returns>
    /// The total volume of the wave.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display Volume displayTotalVolume()
    {
        WHSWaveLine             waveLine;
        WHSProdWaveLine         prodWaveLine;
        ProdBOM                 prodBOM;
        WHSLoadLine             loadLine;
        InventTable             inventTable;
        Volume                  volume;
        WHSKanbanWaveLine       kanbanWaveLine;

        switch (this.waveTemplate().WaveTemplateType)
        {
            case WHSWaveTemplateType::Shipping:
                while select WaveId from waveLine
                    where waveLine.WaveId == this.WaveId
                    join ItemId,Qty from loadLine
                        where loadLine.ShipmentId == waveLine.ShipmentId
                    join UnitVolume from inventTable
                        where inventTable.ItemId == loadLine.ItemId
                {
                    volume += inventTable.UnitVolume * loadLine.Qty;
                }
                break;
            case WHSWaveTemplateType::Production:
                while select ItemId from prodWaveLine
                    where prodWaveLine.WaveId == this.WaveId
                    join QtyInventCalc from prodBOM
                        where prodBOM.InventTransId == prodWaveLine.InventTransId
                    join UnitVolume from inventTable
                        where inventTable.ItemId == prodWaveLine.ItemId
                {
                    volume += inventTable.UnitVolume * prodBOM.QtyInventCalc;
                }
                break;
            case WHSWaveTemplateType::Kanban:
                KanbanJobPickingListAll kanbanJobPickingListAll;

                while select ItemId from kanbanWaveLine
                    where kanbanWaveLine.WaveId == this.WaveId
                    join Quantity from kanbanJobPickingListAll
                        where kanbanJobPickingListAll.InventTransId == kanbanWaveLine.InventTransId
                    join UnitVolume from inventTable
                        where inventTable.ItemId == kanbanWaveLine.ItemId
                {
                    volume += inventTable.UnitVolume * kanbanJobPickingListAll.Quantity;
                }
                break;
        }

        return volume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCompletedDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the completion time stamp for the wave.
    /// </summary>
    /// <returns>The completion date time.</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display WHSCompletedUTCDateTime displayCompletedDateTime()
    {
        if (this.waveStatus() > WHSWaveStatus::Released)
        {
            WHSWorkTable workTable;

            select firstonly maxof(ModifiedDateTime) from workTable
                where workTable.WorkStatus == WHSWorkStatus::Closed
                    && workTable.WaveId == this.WaveId;

            return workTable.ModifiedDateTime;
        }

        return utcDateTimeNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWaveProgress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to display progress of the wave execution.
    /// </summary>
    /// <returns>
    /// The progress of the wave execution.
    /// </returns>
    display WHSProgress displayWaveProgress()
    {
        WHSWaveMethodStatus waveMethodStatus;
        WHSProgress         progress;
        int                 totalSteps;

        if (WHSParameters::find().WaveProgressLog)
        {
            while select ExecutedSteps, TotalSteps from waveMethodStatus
            where waveMethodStatus.WaveId == this.WaveId &&
                  waveMethodStatus.RefRecId  == 0
            {
                totalSteps++;
                progress += waveMethodStatus.ExecutedSteps / waveMethodStatus.TotalSteps;
            }

            if (totalSteps)
            {
                progress = (progress / totalSteps) * 100;
            }
        }
        else
        {
            progress = 100;
        }

        return progress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasReplenishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the wave has replenishment work.
    /// </summary>
    /// <returns>
    /// true if the wave contains a replenishment work.
    /// </returns>
    boolean hasReplenishment()
    {
        WHSWorkTable        workTable;
        WHSReplenWorkLink   replenWorkLink;

        select firstonly forceselectorder WaveId from workTable
            where workTable.WaveId == this.WaveId
                && workTable.WorkStatus < WHSWorkStatus::Cancelled
            join TableId from replenWorkLink
                where replenWorkLink.DemandWorkId == workTable.WorkId;

        return workTable.WaveId != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasSuccessfulLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the wave has a successfully waved line.
    /// </summary>
    /// <returns>
    /// true if the wave has a successfully waved line.
    /// </returns>
    public boolean hasSuccessfulLine()
    {
        WHSProdBOMPool              prodBOMPool;
        WHSProdWaveLine             prodWaveLine;
        ProdBOM                     prodBOM;
        WHSKanbanJobPickingListPool kanbanJobPickingListPool;
        WHSKanbanWaveLine           kanbanWaveLine;
        boolean                     result = false;

        switch (this.waveTemplate().WaveTemplateType)
        {
            case WHSWaveTemplateType::Production:
                // If we have one line on the wave where the wavedQty is more than the needed qty then we know that it was successful this wave.
                select firstonly RecId from prodWaveLine
                    where prodWaveLine.WaveId == this.WaveId
                    exists join prodBOMPool
                        where prodBOMPool.InventTransId == prodWaveLine.InventTransId
                    exists join prodBOM
                        where prodBOM.InventTransId  == prodBOMPool.InventTransId
                           && prodBOM.QtyInventCalc  <  prodBOMPool.WavedQty;

                result = prodWaveLine.RecId != 0;
                break;
            case WHSWaveTemplateType::Kanban:
                KanbanJobPickingListAll     kanbanJobPickingListAll;

                select firstonly WaveId from kanbanWaveLine
                    where kanbanWaveLine.WaveId == this.WaveId
                join InventTransId from kanbanJobPickingListPool
                    where kanbanJobPickingListPool.InventTransId == kanbanWaveLine.InventTransId
                join InventTransId, Quantity from kanbanJobPickingListAll
                    where kanbanJobPickingListAll.InventTransId == kanbanJobPickingListPool.InventTransId
                        && kanbanJobPickingListAll.Quantity     == kanbanJobPickingListPool.WavedQty;

                result = kanbanWaveLine.RecId != 0;
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the wave is in batch.
    /// </summary>
    /// <returns>
    /// true if the wave is in batch.
    /// </returns>
    public boolean inBatch()
    {
        WHSWaveTableBatch   waveTableBatch;
        BatchJob            batchJob;

        if (this.WaveId)
        {
            select firstonly RecId from waveTableBatch
                where waveTableBatch.whsWaveTable == this.RecId
                exists join batchJob
                where batchJob.RecId    == waveTableBatch.Batch
                    && batchJob.Status  != BatchStatus::Finished
                    && batchJob.Status  != BatchStatus::Canceled
                    && batchJob.Status  != BatchStatus::Error;
        }

        return waveTableBatch.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the record from wave template.
    /// </summary>
    public void initFromTemplate()
    {
        WHSWaveTemplateTable template = WHSWaveTemplateTable::find(this.WaveTemplateName);

        if (this.isWaveAttributeCodeSet() == false)
        {
            this.WaveAttributeCode = template.WaveAttributeCode;
        }

        this.InventSiteId       = template.InventSiteId ? template.InventSiteId : this.InventSiteId;
        this.InventLocationId   = template.InventLocationId ? template.InventLocationId : this.InventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertMandatoryFieldsNotBlank</Name>
				<Source><![CDATA[
    private void assertMandatoryFieldsNotBlank()
    {
        WHSMandatoryFieldValidator::assertNotBlank(this, fieldNum(WHSWaveTable, WaveId));
        WHSMandatoryFieldValidator::assertNotBlank(this, fieldNum(WHSWaveTable, WaveTemplateName));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        ttsbegin;
        if (this.WaveTemplateName)
        {
            this.initFromTemplate();
        }

        super();
        this.assertMandatoryFieldsNotBlank();
        ttscommit;

        WHSWaveCreatedApplicationInsightsLogEvent::trackEvent(this.WaveId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWaveAttributeCodeSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the field WaveAttributeCode is set or not
    /// </summary>
    /// <returns>
    /// Returns true if the field WaveAttributeCode is set
    /// </returns>
    boolean isWaveAttributeCodeSet()
    {
        int length = dimOf(this.WaveAttributeCode);
        int currentIndex;

        for (currentIndex = 1; currentIndex <= length ; currentIndex++)
        {
            if (this.WaveAttributeCode[currentIndex] != '')
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>overThreshold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the wave has exceeded template limits.
    /// </summary>
    /// <param name="_showError">
    /// Boolean indicating that error will be shown in case of values are over threshold; optional.
    /// </param>
    /// <returns>
    /// True if the wave has exceeded template limits.
    /// </returns>
    boolean overThreshold(boolean _showError = false)
    {
        boolean                 ret;
        WHSWaveTemplateTable    waveTemplate;

        waveTemplate = WHSWaveTemplateTable::find(this.WaveTemplateName);

        if (waveTemplate.WaveTemplateType == WHSWaveTemplateType::Shipping)
        {
            // Check weight limit
            if (waveTemplate.WaveMaxWeight && this.displayTotalGrossWeight() >= waveTemplate.WaveMaxWeight)
            {
                ret = true;

                if (_showError)
                {
                    error("@WAX3174");
                }
            }

            // Check Shipment Limit
            if (waveTemplate.WaveShipmentLimit && this.displayTotalLines() >= waveTemplate.WaveShipmentLimit)
            {
                ret = true;

                if (_showError)
                {
                    error("@WAX3227");
                }
            }

            // Check load line limit
            if (waveTemplate.WaveLineThreshold && this.displayTotalLoadLines() >= waveTemplate.WaveLineThreshold)
            {
                ret = true;

                if (_showError)
                {
                    error("@WAX3228");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWaveId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets wave id of the record.
    /// </summary>
    void setWaveId()
    {
        this.WaveId = NumberSeq::newGetNum(WHSParameters::numRefWHSWaveId()).num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates open work lines to skipped where the work lines are associated with the loads referenced by the wave lines for the current wave.
    /// </summary>
    public void skipWorkLines()
    {
        WHSWorkLine     workLine;
        WHSWorkTable    workTable;
        WHSWaveLine     waveLine;

        ttsbegin;

        while select workTable
            where workTable.WorkStatus  != WHSWorkStatus::Cancelled
               && workTable.WorkStatus  != WHSWorkStatus::Combined
            exists join waveLine
                where waveLine.WaveId   == this.WaveId
                join TableId from workLine
                where workLine.LoadId   == waveLine.LoadId
                    && workTable.WorkId  == workLine.WorkId
        {
            workTable.skipLines();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventLocationIdMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if <c>InventLocationId</c> is mandatory.
    /// </summary>
    /// <returns>true if <c>InventLocationId</c> is mandatory; otherwise, false.</returns>
    protected boolean isInventLocationIdMandatory()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        this.assertMandatoryFieldsNotBlank();
        
        WHSWaveTable orig = this.orig();

        if (orig.InventLocationId != this.InventLocationId)
        {
            if (this.isInventLocationIdMandatory())
            {
                WHSMandatoryFieldValidator::assertNotBlank(this, fieldNum(WHSWaveTable, InventLocationId));
            }
        }

        if (orig.WaveTemplateName != this.WaveTemplateName)
        {
            if (this.inBatch())
            {
                throw error("@WAX3223");
            }

            WHSWaveTemplateTable whsWaveTemplateTable = WHSWaveTemplateTable::find(this.WaveTemplateName);

            if (!WHSWaveTemplateTable::validateWaveTemplate(whsWaveTemplateTable.WaveTemplateType, this, '', true))
            {
                throw error ("@WAX3164");
            }

            this.initFromTemplate();
        }

        if (orig.WaveStatus == WHSWaveStatus::Created
            || this.WaveStatus == WHSWaveStatus::Created)
        {
            WHSWaveTemplateTable::validateWaveAssignment_RemoveIDFromCache(this.WaveTemplateName, this.RecId);
        }

        super();

        if (this.WaveStatus != orig.WaveStatus)
        {
            // Wave status Released can also mean Picked, as Picked status is not directly saved on the wave record. See the waveStatus method for details.
            // However, for telemetry purposes, this is a good enough check.
            WHSWaveStatusChangedApplicationInsightsLogEvent::trackEvent(this.WaveId, orig.WaveStatus, this.WaveStatus);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean ret;

        ret = super();

        if (!this.allowDelete())
        {
            ret = checkFailed("@SYS78374");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>waveTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds wave template of the record.
    /// </summary>
    /// <returns>
    /// <c>WHSWaveTemplateTable</c> record that is the template of the wave.
    /// </returns>
    WHSWaveTemplateTable waveTemplate()
    {
        return WHSWaveTemplateTable::find(this.WaveTemplateName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignOrCreateWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assign the shipment to a new or existing wave based on the wave template setup.
    /// </summary>
    /// <param name="_shipmentTable">
    /// Shipment to assign to a wave.
    /// </param>
    /// <param name="_pool">
    /// KanbanPickingList or ProdBOM pool to assign to a wave.
    /// </param>
    /// <param name="_waveSet">
    /// Previously created waves.
    /// </param>
    /// <returns>
    /// The wave the shipment was assigned to.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// No parameters were passed into the method.
    /// </exception>
    public static WHSWaveTable assignOrCreateWave(
        WHSShipmentTable _shipmentTable = null,
        WHSPool          _pool          = null,
        Set              _waveSet       = null)
    {
        WHSWaveTable            waveTable;
        WHSWaveTable            retWaveTable;
        WHSWaveLine             waveLine;
        QueryRun                queryRun;
        Query                   q;
        InventDim               inventDim;
        WHSWaveTemplateType     waveTemplateType = WHSWaveTemplateType::None;
        ListEnumerator          listEnum;
        InventLocationId        inventLocationId;
        InventSiteId            inventSiteId;
        NoYes                   assignableWave;
        container               packedWaveTemplateQuery;
        WHSWaveTemplateName     waveTemplateName;
        Num                     identification;
        boolean                 waveTemplatesFound;

        if (_shipmentTable.RecId != 0)
        {
            // Check to see if shipment is already on an open wave
            select firstonly waveTable
                exists join waveLine
                where waveLine.WaveId == waveTable.WaveId
                    && waveLine.ShipmentId == _shipmentTable.ShipmentId
                    && waveTable.WaveStatus < WHSWaveStatus::Held;

            if (waveTable)
            {
                return waveTable;
            }

            waveTemplateType = WHSWaveTemplateType::Shipping;
            inventLocationId = _shipmentTable.InventLocationId;
            inventSiteId     = _shipmentTable.InventSiteId;
            identification   = _shipmentTable.ShipmentId;
        }
        else if (_pool)
        {
            waveTemplateType = _pool.pool().RecId != 0 ? _pool.waveTemplateType() : waveTemplateType;
            inventDim = _pool.inventDim();
            inventLocationId = inventDim.InventLocationId;
            inventSiteId     = inventDim.InventSiteId;
            identification   = _pool.inventTransId();
        }

        if (waveTemplateType == WHSWaveTemplateType::None)
        {
            throw error(strFmt("@WAX3305", funcName()));
        }

        listEnum = WHSWaveTemplateTable::waveTemplateCachedQuery(waveTemplateType, inventLocationId, inventSiteId).getEnumerator();

        ttsbegin;

        while (listEnum.moveNext())
        {
            [waveTemplateName, assignableWave, packedWaveTemplateQuery] = listEnum.current();

            q = WHSWaveTable::buildWaveQuery(waveTemplateName, identification, packedWaveTemplateQuery, waveTemplateType, assignableWave);

            queryRun = new QueryRun(q);

            if (q.dataSourceTable(tableNum(WHSWaveTable)))
            {
                // When the READ_COMMITTED_SNAPSHOT is set to ON (the default on SQL Azure Database) we should use READCOMMITTEDLOCK hint to avoid reading not-actual data.
                // For example, we can get a wave with Created status when in fact the status has been changed to Executing by other thread.
                waveTable.readCommittedLock(true);
                waveTable.readPast(true);
                queryRun.setCursor(waveTable);
            }

            while (queryRun.next())
            {
                waveTemplatesFound = true;

                // Try to assign shipment to an existing wave.
                if (assignableWave)
                {
                    waveTable = queryRun.get(tableNum(WHSWaveTable));

                    if (waveTable)
                    {
                        // By taking a lock we guarantee that we never add to the wave which is in the middle of processing.
                        // For production waves, in certain scenarios wave is automatically deleted after wave execution. Empty buffer will be returned in that case here.
                        waveTable = WHSWaveTable::lockAndRereadWave(waveTable);
                    }

                    if (waveTable &&
                        waveTable.WaveStatus == WHSWaveStatus::Created &&
                        !waveTable.inBatch())
                    {
                        switch (waveTemplateType)
                        {
                            case WHSWaveTemplateType::Shipping:
                                if (WHSWaveTemplateTable::validateWaveAssignment(waveTemplateType, waveTable, _shipmentTable.ShipmentId))
                                {
                                    retWaveTable = waveTable;
                                    info(strFmt("@WAX3224", _shipmentTable.ShipmentId, retWaveTable.WaveId));
                                }
                                break;

                            case WHSWaveTemplateType::Production,
                                 WHSWaveTemplateType::Kanban:
                                if (WHSWaveTemplateTable::validateWaveAssignment(waveTemplateType, waveTable, _pool.inventTransId()))
                                {
                                    retWaveTable = waveTable;

                                    info(strFmt("@WAX3313", _pool.displayOrderIdAndItemId(), retWaveTable.WaveId));
                                }
                                break;
                        }

                        if (retWaveTable)
                        {
                            break;
                        }
                    }
                }
            }

            if (waveTemplatesFound && !retWaveTable)
            {
                // If no wave table could be assigned then try to create a wave table using the template
                retWaveTable = WHSWaveTable::createWaveTableFromTemplate(WHSWaveTemplateTable::find(waveTemplateName), _waveSet, identification, _shipmentTable, _pool, inventDim);
            }

            // If a wave table has been assigned or created break and return wave table
            if (retWaveTable)
            {
                break;
            }
        }

        ttscommit;

        return retWaveTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockAndRereadWave</Name>
				<Source><![CDATA[
    private static WHSWaveTable lockAndRereadWave(WHSWaveTable _waveTable)
    {
        WHSWaveTable waveTableLocal;

        waveTableLocal.readCommittedLock(true);
        waveTableLocal.readPast(true);

        select firstonly pessimisticlock waveTableLocal
            where waveTableLocal.WaveId == _waveTable.WaveId;

        return waveTableLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoExecuteWaves</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method determines which waves should be auto executed.
    /// If so, it submits the wave for execution.
    /// </summary>
    /// <param name="_waveSet">
    /// Set of waves
    /// </param>
    /// <param name="_releaseToWarehouseId">
    /// The release to warehouse identifier
    /// </param>
    public static void autoExecuteWaves(Set _waveSet, WHSReleaseToWarehouseId _releaseToWarehouseId = '')
    {
        Set                         wavesToExecute = new Set(Types::Class);
        BatchCaption                batchCaption;
        List                        waveRecIdList = new List(Types::Int64);
        
        SetEnumerator enumerator = _waveSet.getEnumerator();

        while (enumerator.moveNext())
        {
            WHSWaveTable waveTable = WHSWaveTable::find(enumerator.current());
            WHSWaveTemplateTable waveTemplate = WHSWaveTemplateTable::find(waveTable.WaveTemplateName);

            // If the wave template is setup to auto execute at load post execute it.
            // Also execute if it is over threshold and the wave template is set to auto execute at threshold.
            if (waveTemplate.AutoExecuteWaveAtLoadPost || (waveTemplate.AutoExecuteWaveAtThreshold && waveTable.overThreshold()))
            {
                if (waveTable.canProcessInBatch())
                {
                    wavesToExecute.add(WHSWaveExecute::newInstance(waveTable));
                    info(strFmt("@WAX2610", waveTable.WaveId));

                    // Create caption for batch job
                    if (batchCaption)
                    {
                        batchCaption = batchCaption + ", " + waveTable.WaveId;
                    }
                    else
                    {
                        batchCaption = strFmt("@WAX3167", waveTable.WaveId);
                    }

                    waveRecIdList.addEnd(waveTable.RecId);
                }
                else
                {
                    using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newPerformanceTaskWithoutWaveStep(waveTable, '', tableStr(WhsWaveTable)+'AutoExecuteWaveSingle'))
                    {
                        WHSPostEngine::post(waveTable, _releaseToWarehouseId);
                    }
                }
            }
        }

        if (!wavesToExecute.empty())
        {
            RefRecId batchRecId = WHSParameters::createBatchJob(wavesToExecute, batchCaption);
            WHSWaveTableBatch::createBatchRelationship(waveRecIdList, batchRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoExecuteWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes all work for the selected wave that has to be executed automatically.
    /// </summary>
    /// <param name="_waveId">
    /// The wave ID.
    /// </param>
    /// <remarks>
    /// Work that has Replenishment dependent work blocking policy on individual work lines cannot be auto-executed.
    /// </remarks>
    public static void autoExecuteWork(WHSWaveId _waveId)
    {
        WHSWorkTable    workTable;

        while select workTable
            where workTable.WaveId       == _waveId      &&
                  workTable.AutoExecute  == NoYes::Yes   &&
                  workTable.Frozen       == NoYes::No    &&
                  workTable.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::EntireWorkOrder &&
                  workTable.WorkStatus   == WHSWorkStatus::Open
        {
            WHSWorkTable::autoExecuteWork(workTable.WorkId);

            if (workTable.validateWorkExecution())
            {
                info(strFmt("@WAX2158", workTable.WorkId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWaveFromShipments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a set of waves from shipments.
    /// </summary>
    /// <param name="_shipmentIds">
    /// Ids of the shipments that waves will be built for.
    /// </param>
    public static void buildWaveFromShipments(container _shipmentIds)
    {
        Set waveSet = new Set(Types::String);

        ttsbegin;

        int length = conLen(_shipmentIds);

        for (int i = 1; i <= length; ++i)
        {
            WHSShipmentTable currentShipment = WHSShipmentTable::find(conPeek(_shipmentIds, i));
            WHSWaveTable::findOrCreateWaveForShipment(currentShipment, waveSet, true, true);
        }

        ttscommit;

        // Execute waves that should be autoExecuted.
        WHSWaveTable::autoExecuteWaves(waveSet);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateWaveForShipment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static WHSWaveTable findOrCreateWaveForShipment(
        WHSShipmentTable    _shipment,
        Set                 _waveSet,
        boolean             _showErrorOnCreateFromWaveIdAndShipmentFail,
        boolean             _skipCheckForWaveLineExist)
    {
        WHSWaveTable waveTable;

        if (!_shipment.ShipmentId)
        {
            return waveTable;
        }

        if (_shipment.validForNewWaveLine())
        {
            if (_shipment.isWaveAutoCreationAllowed())
            {
                waveTable = WHSWaveTable::assignOrCreateWave(_shipment, null, _waveSet);

                if (waveTable)
                {
                    if (_skipCheckForWaveLineExist 
                        || !WHSWaveLine::exist(waveTable.WaveId, _shipment.ShipmentId))
                    {
                        WHSWaveLine::createFromWaveIdAndShipment(waveTable.WaveId, _shipment, _showErrorOnCreateFromWaveIdAndShipmentFail);
                    }               
                }
            }
        }
        else 
        {
            waveTable = WHSWaveTable::findOpenWaveFromShipment(_shipment);
        }

        if (waveTable)
        {
            _waveSet.add(waveTable.WaveId);
        }

        return waveTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOpenWaveFromShipment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static WHSWaveTable findOpenWaveFromShipment(WHSShipmentTable _shipmentTable)
    {
        WHSWaveTable waveTable;
        
        if (_shipmentTable.ShipmentId)
        {
            WHSWaveLine waveLine;

            select firstonly waveTable
                where waveTable.WaveStatus == WHSWaveStatus::Created
            exists join waveLine
                where waveLine.WaveId == waveTable.WaveId
                    && waveLine.ShipmentId == _shipmentTable.ShipmentId;
        }

        return waveTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWaveFromForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record using values from the <c>WHSWaveTableCreateNew</c> form.
    /// </summary>
    /// <param name="_fields">
    /// A container with the Wave Id, Description, Template Name, and Attribute Code values.
    /// </param>
    public static void createWaveFromForm(container _fields)
    {
        WHSWaveTable waveTable;

        ttsbegin;

        waveTable.WaveId = conPeek(_fields, 1);
        waveTable.Description = conPeek(_fields, 2);
        waveTable.WaveTemplateName = conPeek(_fields, 3);
        waveTable.WaveAttributeCode[1] = conPeek(_fields, 4);
        waveTable.WaveAttributeCode[2] = conPeek(_fields, 5);
        waveTable.WaveAttributeCode[3] = conPeek(_fields, 6);
        waveTable.WaveAttributeCode[4] = conPeek(_fields, 7);

        waveTable.insert();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWaveTableFromTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>WHSWaveTable</c> record from the passed template.
    /// </summary>
    /// <param name = "_waveTemplate">
    /// The passed <c>WHSWaveTemplateTable</c> record to create from.
    /// </param>
    /// <param name="_waveSet">
    /// Previously created waves.
    /// </param>
    /// <param name="_identification">
    /// Id of the underlying transaction of the wave.
    /// </param>
    /// <param name="_shipmentTable">
    /// Shipment to assign to a wave.
    /// </param>
    /// <param name="_pool">
    /// KanbanPickingList or ProdBOM pool to assign to a wave
    /// </param>
    /// <param name = "_inventDim">
    /// A <c>InventDim</c> record.
    /// </param>
    /// <returns>
    /// A <c>WHSWaveTable</c> record.
    /// </returns>
    protected static WHSWaveTable createWaveTableFromTemplate(
        WHSWaveTemplateTable _waveTemplate,
        Set                  _waveSet,
        Num                  _identification,
        WHSShipmentTable     _shipmentTable,
        WHSPool              _pool,
        InventDim            _inventDim)
    {
        WHSWaveTable retWaveTable;

        if (_waveTemplate.AutoCreateWave)
        {
            // Loop over all previously created waves to see if we've already created a wave for this template
            if (_waveSet)
            {
                SetEnumerator enum = _waveSet.getEnumerator();
                while (enum.moveNext())
                {
                    WHSWaveTable waveTable = WHSWaveTable::find(enum.current());

                    if (waveTable.canAssignToOpenWave(_waveTemplate, _shipmentTable, _pool, _inventDim)
                        && WHSWaveTemplateTable::validateWaveTemplate(_waveTemplate.WaveTemplateType, waveTable, _identification))
                    {
                        retWaveTable = waveTable;

                        info(strFmt("@WAX3314", _shipmentTable.RecId ? _shipmentTable.ShipmentId : _pool.displayOrderIdAndItemId(), retWaveTable.WaveId));
                        break;
                    }
                }
            }

            // If no previously created waves match, create a new wave.
            if (!retWaveTable)
            {
                retWaveTable.setWaveId();
                retWaveTable.WaveTemplateName   = _waveTemplate.WaveTemplateName;

                if (_shipmentTable.RecId)
                {
                    retWaveTable.InventSiteId          = _shipmentTable.InventSiteId;
                    retWaveTable.InventLocationId      = _shipmentTable.InventLocationId;
                    retWaveTable.Description           = _shipmentTable.ShipmentId;
                    info(strFmt("@WAX3225", retWaveTable.WaveId, _shipmentTable.ShipmentId));
                }
                else
                {
                    retWaveTable.InventSiteId          = _inventDim.InventSiteId;
                    retWaveTable.InventLocationId      = _inventDim.InventLocationId;
                    retWaveTable.Description           = _pool.id();
                    info(strFmt("@WAX3310", retWaveTable.WaveId, _pool.displayOrderIdAndItemId()));
                }

                retWaveTable.insert();
            }
        }

        return retWaveTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAssignToOpenWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the wave can be reused for a wave template, shipment and pool.
    /// </summary>
    /// <param name = "_waveTemplate">
    /// The passed <c>WHSWaveTemplateTable</c> record to create from.
    /// </param>
    /// <param name="_shipmentTable">
    /// Shipment to be assigned to a wave.
    /// </param>
    /// <param name="_pool">
    /// KanbanPickingList or ProdBOM pool to assign to a wave
    /// </param>
    /// <param name = "_inventDim">
    /// A <c>InventDim</c> record.
    /// </param>
    /// <returns>true if the open wave can be reused; otherwise, false.</returns>
    protected boolean canAssignToOpenWave(
        WHSWaveTemplateTable _waveTemplate,
        WHSShipmentTable     _shipmentTable,
        WHSPool              _pool,
        InventDim            _inventDim
        )
    {
        if (this.WaveTemplateName != _waveTemplate.WaveTemplateName)
        {
            return false;
        }
        
        switch (_waveTemplate.WaveTemplateType)
        {
            case WHSWaveTemplateType::Shipping:
            case WHSWaveTemplateType::Production:
            case WHSWaveTemplateType::Kanban:
                return this.validateWaveAssignment(_shipmentTable.ShipmentId);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWaveAssignment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether a shipment can be assigned to the current wave.
    /// </summary>
    /// <param name = "_shipmentId">
    /// A shipment ID to validate .
    /// </param>
    /// <param name = "_showError">
    /// A Boolean value that defines whether to show errors; optional.
    /// <returns>
    /// true if the shipment can be assigned; otherwise, false.
    /// </returns>
    internal boolean validateWaveAssignment(
        WHSShipmentId   _shipmentId,
        boolean         _showError = false)
    {
        boolean ret = WHSWaveTemplateTable::validateWaveTemplateGrouping(this, _shipmentId);

        if (!ret && _showError)
        {
            checkFailed("@WAX:Error_ShipmentDoesNotMatchWaveTemplateGroupingBreakFields");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a specific <c>whsWaveTable</c> record exists.
    /// </summary>
    /// <param name="_waveId">
    /// Wave id of the record.
    /// </param>
    /// <returns>
    /// True if the record exists.
    /// </returns>
    static boolean exist(WHSWaveId _waveId)
    {
        return _waveId && (select firstonly RecId from whsWaveTable
                 where whsWaveTable.WaveId == _waveId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific <c>WHSWaveTable</c> record with given parameters.
    /// </summary>
    /// <param name="_waveId">
    /// Wave id of the record.
    /// </param>
    /// <param name="_forupdate">
    /// Determines whether the record is selected for update.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    public static WHSWaveTable find(WHSWaveId   _waveId,
                                    boolean     _forupdate = false)
    {
        WHSWaveTable    waveTable;

        if (_waveId)
        {
            waveTable.selectForUpdate(_forupdate);

            select firstonly waveTable
                where waveTable.WaveId == _waveId;
        }

        return waveTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId</Name>
				<Source><![CDATA[
    internal static WHSWaveTable findByRecId(RefRecId _waveRecId, boolean _forupdate = false)
    {
        WHSWaveTable    waveTable;

        if (_waveRecId)
        {
            waveTable.selectForUpdate(_forupdate);

            select firstonly waveTable
                where waveTable.RecId == _waveRecId;
        }

        return waveTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextWaveId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds next wave id from number sequences.
    /// </summary>
    /// <returns>
    /// The next wave id.
    /// </returns>
    public static WHSWaveId getNextWaveId()
    {
        return NumberSeq::newGetNum(WHSParameters::numRefWHSWaveId()).num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the work type from the template of the wave.
    /// </summary>
    /// <param name="_waveId">
    /// Id of the wave.
    /// </param>
    /// <returns>
    /// The work type of the wave.
    /// </returns>
    public static WHSWorkTransType getWorkTransType(WHSWaveId _waveId)
    {
        WHSWorkTransType    workTransType;
        WHSWaveTemplateType waveTemplateType;

        if (_waveId)
        {
            waveTemplateType = WHSWaveTable::find(_waveId).waveTemplate().WaveTemplateType;

            switch (waveTemplateType)
            {
                case WHSWaveTemplateType::Shipping:
                    workTransType = (select firstonly WorkTransType from whsWaveLine
                                        where whsWaveLine.WaveId == _waveId).WorkTransType;
                    break;
                case WHSWaveTemplateType::Production:
                    workTransType = WHSWorkTransType::ProdPick;
                    break;
                case WHSWaveTemplateType::Kanban:
                    workTransType = WHSWorkTransType::KanbanPick;
                    break;
            }
        }

        return workTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Releases and updates the selected wave.
    /// </summary>
    /// <param name="_waveId">
    /// The wave ID.
    /// </param>
    public static void releaseWave(WHSWaveId _waveId)
    {
        WHSWaveTable::releaseWaveWorkBlocking(_waveId, WHSWorkBlockingReasonType::HeldWave);
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseWaveWorkBlocking</Name>
				<Source><![CDATA[
    private static void releaseWaveWorkBlocking(WHSWaveId _waveId, WHSWorkBlockingReasonType _workBlockingReasonType)
    {
        ttsbegin;

        WHSWaveTable waveTable = WHSWaveTable::find(_waveId, true);
        waveTable.ReleasedUTCDateTime   = DateTimeUtil::utcNow();
        waveTable.WaveStatus            = waveTable.WaveStatus > WHSWaveStatus::Released    ?
                                                waveTable.WaveStatus                        :
                                                WHSWaveStatus::Released;
        waveTable.update();

        // When updating the wave, an exclusive lock for the wave table is acquired.
        // When a work is being split a lock on the related wave is acquired so unblocking of the works will wait while a work associated to the current wave is being split.

        WHSWaveWorkUnblocker::unblockWaveWorkBlockedByReason(_waveId, _workBlockingReasonType);

        WHSWaveTable::autoExecuteWork(_waveId);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canWorkBeUnblocked</Name>
				<Source><![CDATA[
    private static boolean canWorkBeUnblocked(WHSWorkTable _workTable)
    {
        return _workTable.canBeUnBlockedInfoWarning()
            && WHSWaveTable::validateWorkIsNotBlockedByUnProcessedStagingPickWork(_workTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkIsNotBlockedByUnProcessedStagingPickWork</Name>
				<Source><![CDATA[
    private static boolean validateWorkIsNotBlockedByUnProcessedStagingPickWork(WHSWorkTable _workTable)
    {
        WHSWorkId unProcessedOverPickWorkId = _workTable.firstUnProcessedRelatedStagingPickWorkId();

        if (unProcessedOverPickWorkId)
        {
            return checkFailed(strFmt("@WAX3103", unProcessedOverPickWorkId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canWaveBeShipped</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean canWaveBeShipped(WHSWaveId _waveId)
    {
        WHSShipmentTable shipmentTable;
        WHSWaveLine waveLine;

        select firstonly RecId from shipmentTable
            where shipmentTable.ShipmentStatus < WHSShipmentStatus::Shipped
            exists join waveLine
                where waveLine.ShipmentId == shipmentTable.ShipmentId
                &&    waveLine.WaveId == _waveId;
                    
        return !shipmentTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates status of the wave.
    /// </summary>
    /// <param name="_waveId">
    /// Id of the wave.
    /// </param>
    /// <param name="_waveStatus">
    /// New status of the wave.
    /// </param>
    public static void updateWaveStatus(WHSWaveId _waveId, WHSWaveStatus _waveStatus)
    {
        if (_waveId)
        {
            ttsbegin;
            WHSWaveTable waveTable = WHSWaveTable::find(_waveId, true);
            
            if (waveTable.WaveStatus != _waveStatus)
            {            
                waveTable.WaveStatus = _waveStatus;
                waveTable.update();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWaveQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates queries used for wave assignment.
    /// </summary>
    /// <param name="_waveTemplateName">
    /// Name of the wave template used for wave assignment.
    /// </param>
    /// <param name="_identification">
    /// An ID of the kanban, production or shipment subject to wave assignment.
    /// </param>
    /// <param name="_packedTemplateQuery">
    /// A packed <c>Query</c> class object from the wave template.
    /// </param>
    /// <param name="_waveTemplateType">
    /// The type of the wave template.
    /// </param>
    /// <param name="_assignableWave">
    /// A boolean determining if the wave template allows assignment to open waves. true, if assignment is allowed; otherwise, false.
    /// </param>
    /// <returns>
    /// A <c>Query</c> class object.
    /// </returns>
    public static Query buildWaveQuery(
        WHSWaveTemplateName     _waveTemplateName,
        Num                     _identification,
        container               _packedTemplateQuery,
        WHSWaveTemplateType     _waveTemplateType,
        NoYes                   _assignableWave)
    {
        WHSWaveTableBuildWaveQueryCache waveTableBuildWaveQueryCache;
        QueryBuildDataSource            qbdsShipmentTable;
        QueryBuildDataSource            qbdsWaveTable;
        QueryBuildDataSource            qbdsInventDim;
        QueryBuildDataSource            qbdsProdBOM;
        QueryBuildDataSource            qbdsKanbanJobPickingList;
        Query                           query;

        waveTableBuildWaveQueryCache = WHSWaveTableBuildWaveQueryCache::newFromCacheKey(WHSWaveTableBuildWaveQueryCache::createCacheKeyForCompany(_waveTemplateName));
        if (_assignableWave && !waveTableBuildWaveQueryCache.hasExpired())
        {
            query = new Query(waveTableBuildWaveQueryCache.cacheValue());
        }
        else
        {
            query = new Query(_packedTemplateQuery);
        }

        switch (_waveTemplateType)
        {
            case WHSWaveTemplateType::Shipping:
                qbdsShipmentTable = query.dataSourceTable(tableNum(WHSShipmentTable));
                SysQuery::findOrCreateRange(qbdsShipmentTable, fieldNum(WHSShipmentTable, ShipmentId)).value(queryValue(_identification));
                break;

            case WHSWaveTemplateType::Production:
                qbdsProdBOM = query.dataSourceTable(tableNum(ProdBOM));
                SysQuery::findOrCreateRange(qbdsProdBOM, fieldNum(ProdBOM, InventTransId)).value(queryValue(_identification));
                break;

            case WHSWaveTemplateType::Kanban:
                qbdsKanbanJobPickingList = query.dataSourceTable(tableNum(KanbanJobPickingListAll));
                SysQuery::findOrCreateRange(qbdsKanbanJobPickingList, fieldNum(KanbanJobPickingListAll, InventTransId)).value(queryValue(_identification));
                break;
        }

        if (_assignableWave && waveTableBuildWaveQueryCache.hasExpired())
        {
            switch (_waveTemplateType)
            {
                case WHSWaveTemplateType::Shipping:
                    qbdsWaveTable = qbdsShipmentTable.addDataSource(tableNum(WHSWaveTable));
                    qbdsWaveTable.addLink(fieldNum(WHSShipmentTable, InventSiteId), fieldNum(WHSWaveTable, InventSiteId));
                    qbdsWaveTable.addLink(fieldNum(WHSShipmentTable, InventLocationId), fieldNum(WHSWaveTable, InventLocationId));
                    break;

                case WHSWaveTemplateType::Production:
                    qbdsInventDim = qbdsProdBOM.addDataSource(tableNum(InventDim));
                    qbdsWaveTable = qbdsInventDim.addDataSource(tableNum(WHSWaveTable));

                    qbdsInventDim.fetchMode(QueryFetchMode::One2One);
                    qbdsInventDim.relations(false);
                    qbdsInventDim.addlink(fieldNum(ProdBOM, InventDimId),
                                        fieldNum(InventDim, InventDimId));

                    qbdsWaveTable.addlink(fieldNum(InventDim, InventSiteId),
                                        fieldNum(WHSWaveTable, InventSiteId));
                    qbdsWaveTable.addlink(fieldNum(InventDim, InventLocationId),
                                        fieldNum(WHSWaveTable, InventLocationId));

                    break;

                case WHSWaveTemplateType::Kanban:
                    qbdsInventDim = qbdsKanbanJobPickingList.addDataSource(tableNum(InventDim));
                    qbdsWaveTable = qbdsInventDim.addDataSource(tableNum(WHSWaveTable));
                    qbdsInventDim.addlink(fieldNum(KanbanJobPickingListAll, InventDimId),
                                            fieldNum(InventDim, InventDimId));
                    qbdsInventDim.addLink(fieldNum(KanbanJobPickingListAll, InventDimDataAreaId),
                                            fieldNum(InventDim, DataAreaId));
                    break;
            }

            if (qbdsWaveTable)
            {
                qbdsWaveTable.addRange(fieldNum(WHSWaveTable, WaveTemplateName)).value(queryValue(_waveTemplateName));
                qbdsWaveTable.addRange(fieldNum(WHSWaveTable, WaveStatus)).value(queryValue(WHSWaveStatus::Created));
                qbdsWaveTable.joinMode(JoinMode::OuterJoin);
                qbdsWaveTable.fetchMode(QueryFetchMode::One2One);
            }

            waveTableBuildWaveQueryCache.markInCache(query.pack());
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canExecute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the wave can be executed.
    /// </summary>
    /// <returns>True if the wave can be executed; otherwise false.</returns>
    public boolean canExecute()
    {
        return this.WaveStatus < WHSWaveStatus::Executing && this.InventLocationId && !this.inBatch();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRelease</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the wave can be released.
    /// </summary>
    /// <returns>True if the wave can be released; otherwise false.</returns>
    public boolean canRelease()
    {
        return this.WaveStatus == WHSWaveStatus::Held;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCancelWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the related work can be cancelled.
    /// </summary>
    /// <returns>True if the related work can be cancelled; otherwise false.</returns>
    public boolean canCancelWork()
    {
        return this.WorkBuildId != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPrintPickList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the pick list can be printed.
    /// </summary>
    /// <returns>True if the pick list can be printed; otherwise false.</returns>
    public boolean canPrintPickList()
    {
        return this.WaveStatus >= WHSWaveStatus::Executing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReverseWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the related work can be reversed.
    /// </summary>
    /// <returns>True if the related work can be reversed; otherwise false.</returns>
    public boolean canReverseWork()
    {
        return this.WaveStatus >= WHSWaveStatus::Held
            && this.WaveStatus != WHSWaveStatus::Shipped
            && !this.containsCWTagItem();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canViewProgress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the wave is in a state where it can have progress.
    /// </summary>
    /// <returns>True if the wave is in a state where it can have progress; otherwise false.</returns>
    public boolean canViewProgress()
    {
        return this.WaveStatus >= WHSWaveStatus::Executing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canViewBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the wave has any batch information.
    /// </summary>
    /// <returns>True if the wave has any batch information; otherwise false.</returns>
    [Hookable(false)]
    internal boolean canViewBatch()
    {
        return WHSWaveTableBatch::existWave(this.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canViewWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the wave is in a state where it can have work.
    /// </summary>
    /// <returns>True if the wave is in a state where it can have work; otherwise false.</returns>
    public boolean canViewWork()
    {
        return this.WaveStatus >= WHSWaveStatus::Executing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalLoadLinesWithWorkLineNotCancelled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total number of load lines that are referred by all the non cancelled work lines
    /// of the work tables related to the current wave table.
    /// </summary>
    ///<returns>The calculated count.</returns>
    public int totalLoadLinesWithWorkLineNotCancelled()
    {
        WHSWorkLine     workLine;
        WHSWorkTable    workTable;
        int             loadLinesCount = 0;

        while select TableId from workLine
            group by workLine.LoadLineRefRecId
            where workLine.workStatus != WHSWorkStatus::Cancelled
                && workLine.LoadLineRefRecId != 0
            exists join workTable
                where workTable.WorkId == workLine.WorkId
                    && workTable.WaveId == this.WaveId
        {
            loadLinesCount++;
        }

        return loadLinesCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetWhenWorkIsRemoved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets a wave when the work created has been removed.
    /// </summary>
    /// <param name = "_waveId">The id of the wave to reset.</param>
    public static void resetWhenWorkIsRemoved(WHSWaveId _waveId)
    {
        ttsbegin;
        WHSWaveTable waveTable = WHSWaveTable::find(_waveId, true);

        if (waveTable && waveTable.numWorkCreated() == 0)
        {
            waveTable.resetToStatusCreated();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetToStatusCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reset Wave fields according to status <c>Created</c>.
    /// </summary>
    public void resetToStatusCreated()
    {
        this.WaveStatus            = WHSWaveStatus::Created;
        this.ExecutingUTCDateTime  = utcDateTimeNull();
        this.HeldUTCDateTime       = utcDateTimeNull();
        this.ReleasedUTCDateTime   = utcDateTimeNull();
        this.WorkBuildId           = '';

        this.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canProcessInBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the wave can be processed in batch.
    /// </summary>
    /// <returns>true if the wave can be processed in batch; otherwise, false.</returns>
    public boolean canProcessInBatch()
    {
        return WHSParameters::find().ExecuteWaveInBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findEnsureRecordIsReadInsideTTS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specific <c>WHSWaveTable</c> record with given parameters. The record is read in a transaction scope to ensure it has been freshly updated in the cache in the transaction.
    /// </summary>
    /// <param name="_waveId">
    /// Wave id of the record.
    /// </param>
    /// <returns>
    /// The record that is searched for.
    /// </returns>
    public static WHSWaveTable findEnsureRecordIsReadInsideTTS(WHSWaveId _waveId)
    {
        WHSWaveTable  waveTable;
        
        ttsbegin;
        waveTable = WHSWaveTable::find(_waveId);
        ttscommit;

        return waveTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>containsCWTagItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the wave has a catch weight tag tracked item on it or not.
    /// </summary>
    /// <param name = "_waveTable">The record.</param>
    /// <returns>
    /// true if the wave contains a catch weight tag tracked item; otherwise, false.
    /// </returns>
    private boolean containsCWTagItem()
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
        {
            WHSCatchWeightItemHandlingPolicy   itemHandlingPolicy;
            WHSInventTable                     whsInventTable;
            WHSLoadLine		                loadLine;
            WHSWaveLine		                waveLine;

            select firstOnly RecId from itemHandlingPolicy
                where itemHandlingPolicy.CatchWeightTagTracking             == NoYes::Yes
                exists join whsInventTable
                    where whsInventTable.CatchWeightItemHandlingPolicyName  == itemHandlingPolicy.PolicyName
                exists join loadLine
                    where loadLine.ItemId                                   == whsInventTable.ItemId
                exists join waveLine
                    where waveLine.ShipmentId                               == loadLine.ShipmentId
                        && waveLine.WaveId                                  == this.WaveId;

            return itemHandlingPolicy.RecId != 0;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfLoadLinesToAllocate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the count of load lines will be allocated during wave processing.
    /// </summary>
    /// <returns>
    /// The count of load lines will be allocated during wave processing.
    /// </returns>
    [Hookable(false)]
    internal int64 numberOfLoadLinesToAllocate()
    {
        WHSLoadLine         loadLine;
        WHSWaveLine         waveLine;

        select count(RecId) from loadLine
            where loadLine.InventQty != loadLine.WorkCreatedQty
        exists join waveLine
            where waveLine.ShipmentId == loadLine.ShipmentId
            &&    waveLine.WaveId     == this.WaveId;

        return loadLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfShipmentLinesToBuild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount of shipment lines to build loads for during wave procesing.
    /// </summary>
    /// <returns>
    /// The amount of shipmet lines.
    /// </returns>
    [Hookable(false)]
    internal Counter numberOfShipmentLinesToBuild()
    {
        WHSLoadLine         loadLine;
        WHSWaveLine         waveLine;

        select count(RecId) from  loadLine
            exists join waveLine
            where loadLine.ShipmentId    == waveLine.ShipmentId   &&
                  waveLine.WaveId        == this.WaveId      &&
                  loadLine.LoadId        == '';

        return any2Int(loadLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasWaveBeenExecutedForOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if any waves associated with an order have been executed.
    /// </summary>
    /// <param name = "_orderNum">
    /// <c>WHSOrderNum</c> id.
    /// </param>
    /// <param name = "_workTransType">
    /// The <c>WHSWorkTransType</c> of the <c>WHSOrderNum</c>.
    /// </param>
    /// <param name = "_inventTransType">
    /// The <c>InventTransType</c> of the <c>WHSOrderNum</c>.
    /// </param>
    /// <returns>
    /// true if any waves associated to the order have been executed; otherwise, false.
    /// </returns>
    [Hookable(false)]
    internal static boolean hasWaveBeenExecutedForOrder(
        WHSOrderNum         _orderNum,
        WHSWorkTransType    _workTransType,
        InventTransType     _inventTransType)
    {
        WHSShipmentTable    shipmentTable;
        WHSLoadLine         loadLine;
        WHSWaveTable        waveTable;
        boolean             ret;
        
        if (WHSWaveTableSearchShipmentUsingLoadLineOrderNumFlight::instance().isEnabled())
        {
            select firstOnly RecId from shipmentTable
            where  shipmentTable.WorkTransType == _workTransType
            exists join loadLine
                where loadLine.OrderNum == _orderNum
                    && loadLine.ShipmentId == shipmentTable.ShipmentId
                    && loadLine.InventTransType == _inventTransType
                    && loadLine.TransportRequest == NoYes::No
            exists join waveTable
                where waveTable.WaveId == shipmentTable.WaveId
                    && waveTable.WaveStatus > WHSWaveStatus::Created;
        }
        else 
        {
            select firstOnly RecId from shipmentTable
            where shipmentTable.OrderNum == _orderNum
                && shipmentTable.WorkTransType == _workTransType
            exists join loadLine
                where loadLine.ShipmentId == shipmentTable.ShipmentId
                    && loadLine.InventTransType == _inventTransType
            exists join waveTable
                where waveTable.WaveId == shipmentTable.WaveId
                    && waveTable.WaveStatus > WHSWaveStatus::Created;
        }

        if (shipmentTable.RecId != 0)
        {
            ret = true;
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfSortPositionsForWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Counts the number of sort positions tied to the wave.
    /// </summary>
    /// <param name = "_waveId">The record.</param>
    /// <returns>
    /// The number of sort positions tied to the wave.
    /// </returns>
    [Hookable(false)]
    internal static WHSNumberOfSortPositions numberOfSortPositionsForWave(WHSWaveId _waveId)
    {
        WHSOutboundSortPosition sortPosition;

        if (_waveId)
        {
            select count(RecId) from sortPosition
                where sortPosition.WaveId == _waveId;
        }

        return int642int(sortPosition.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsAnyLinesWithFlexibleReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the wave is related to any work lines with order-committed reservations.
    /// </summary>
    /// <returns>true if the wave is related to any work lines with order-committed reservations; false, otherwise.</returns>
    internal boolean existsAnyLinesWithFlexibleReservation()
    {
        WHSWorkTable workTable;
        WHSWorkLine workLine;

        select firstonly RecId from workTable
            where workTable.WaveId == this.WaveId
            exists join workLine
                where  workLine.WorkId == workTable.WorkId
                    && workLine.OrderCommittedInventDimId != '';

        return workTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaskBasedWaveProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if wave step is setup for task based processing and threshold exceeded.
    /// </summary>
    /// <param name = "_postMethodName">The post method name for the wave step.</param>
    /// <param name = "_postEngine">The post engine used for execution of wave processing.</param>
    /// <returns>
    /// true, if wave process method is setup for task based processing and threshold exceeded; otherwise, false.
    /// </returns>
    [Hookable(false)]
    internal boolean useTaskBasedWaveProcessing(WHSPostMethodName _postMethodName, WHSPostEngine _postEngine)
    {
        if (_postMethodName && _postEngine && WHSBaseWaveStepMethod::isWaveStepTaskBased(_postMethodName, this.WaveTemplateName))
        {
            return WhsPostEngineBase::taskBasedProcessingThresholdExceeded(_postMethodName, _postEngine); 
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    [Hookable(false)]
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkBuildId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true)]
    internal WHSWorkBuildId getWorkBuildId()
    {
        return this.WorkBuildId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>WHSandTMS</ConfigurationKey>
	<DeveloperDocumentation>@WAX4479</DeveloperDocumentation>
	<Label>@WAX1494</Label>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>WaveId</TitleField1>
	<TitleField2>Description</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>WaveIdIdx</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Inventory</Modules>
	<PrimaryIndex>WaveIdIdx</PrimaryIndex>
	<ReplacementKey>WaveIdIdx</ReplacementKey>
	<TableContents>DefaultData</TableContents>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>WHSProdWaveLine</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>WHSProdWaveLine</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>WHSWaveLine</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>WHSWaveLine</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WaveId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveAttributeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkBuildId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>numWorkCreated</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>numWorkRemaining</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Execute</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventSiteId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DemandWaveId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExecutingUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReleasedUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>displayCompletedDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>HeldUTCDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WaveId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@WAX2277</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WaveId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveAttributeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkBuildId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Execute</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventSiteId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveTemplateName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DemandWaveId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExecutingUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReleasedUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>HeldUTCDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WHSWaveAttributeCode</Name>
			<Label>@WAX1598</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WaveAttributeCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DemandWaveId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSDemandWaveId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Description</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Description</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Execute</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSExecute</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ExecutingUTCDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSExecutingUTCDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>HeldUTCDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSHeldUTCDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventLocationId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventLocationId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventSiteId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventSiteId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ReleasedUTCDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSReleasedUTCDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WaveAttributeCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveAttributeCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WaveId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WaveStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>WHSWaveStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WaveTemplateName</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveTemplateName</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkBuildId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkBuildId</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>WaveIdIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>WaveId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WaveTemplateNameIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>WaveTemplateName</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WaveStatus</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DemandWaveIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>DemandWaveId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventLocation</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventLocation</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventLocationId</Name>
					<SourceEDT>InventLocationId</SourceEDT>
					<Field>InventLocationId</Field>
					<RelatedField>InventLocationId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventLocationIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventSite</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventSite</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventSiteId</Name>
					<SourceEDT>InventSiteId</SourceEDT>
					<Field>InventSiteId</Field>
					<RelatedField>SiteId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>SiteIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WaveAttributeCode1</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWaveAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveAttributeCode</Name>
					<Field>WaveAttributeCode[1]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute1</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WaveAttributeCode2</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWaveAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code2</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute2</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveAttributeCode</Name>
					<Field>WaveAttributeCode[2]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WaveAttributeCode3</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWaveAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code3</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute3</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveAttributeCode</Name>
					<Field>WaveAttributeCode[3]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WaveAttributeCode4</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWaveAttributes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Code4</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AttributeTitle_Extern</Name>
					<RelatedField>AttributeTitle</RelatedField>
					<ValueStr>WHSAttributeTitle::Attribute4</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveAttributeCode</Name>
					<Field>WaveAttributeCode[4]</Field>
					<RelatedField>AttributeNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWaveTemplate</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSWaveTemplateTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveTemplateName</Name>
					<SourceEDT>WHSWaveTemplateName</SourceEDT>
					<Field>WaveTemplateName</Field>
					<RelatedField>WaveTemplateName</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>