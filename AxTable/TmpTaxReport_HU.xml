<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TmpTaxReport_HU</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class TmpTaxReport_HU extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>initFromCustTrans</Name>
				<Source><![CDATA[
    private void initFromCustTrans(TaxTrans _taxTrans, CustTrans _custTrans, ReportMode_W _reportMode)
    {
        this.LedAccType     = LedgerJournalACType::Cust;
        this.InvoiceAccount = _custTrans.AccountNum;
        this.InvoiceId      = _custTrans.Invoice;
        this.initTaxAmounts(_taxTrans, _reportMode, tableNum(CustInvoiceJour));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromGeneralJournalAccountEntry</Name>
				<Source><![CDATA[
    private void initFromGeneralJournalAccountEntry(TaxTrans _taxTrans, GeneralJournalAccountEntry _generalJournalAccountEntry, ReportMode_W _reportMode)
    {
        this.LedAccType = LedgerJournalACType::Ledger;
        this.InvoiceAccount = MainAccount::findByLedgerDimension(_generalJournalAccountEntry.LedgerDimension).MainAccountId;
        this.Name = _generalJournalAccountEntry.Text;
        this.initTaxAmounts(_taxTrans, _reportMode, tableNum(LedgerJournalTrans));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TmpTaxReport_HU</c> record
    /// </summary>
    /// <param name="_taxTrans">
    ///     The <c>TaxTrans</c> record to initialize the tax amounts on the <c>TmpTaxReport_HU</c> record.
    /// </param>
    /// <param name="_periodStart">
    ///     The report period starting date.
    /// </param>
    /// <param name="_rundate">
    ///     The report run date (end of period in the case of Itemized VAT Statement).
    /// </param>
    /// <param name="_reportMode_W">
    ///     The report run mode.
    /// </param>
    /// <param name="_searchRelatedTaxTrans">
    ///     Shows whether to search related (correction and original) tax transactions in the case of Itemized VAT report.
    /// </param>
    /// <param name="_excludeForeignTrade">
    ///     checks to exclude foreigntrade or not.
    /// </param>
    /// <returns>
    ///     The packed set of correction tax transactions.
    /// </returns>
    public Set initFromTaxTrans(TaxTrans    _taxTrans,
                                TransDate   _periodStart,
                                TransDate   _rundate,
                                ReportMode_W _reportMode_W,
                                boolean      _searchRelatedTaxTrans = true,
                                boolean      _excludeForeignTrade = false)
    {
        CustTrans                           custTrans;
        VendTrans                           vendTrans;
        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntry;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        TaxTransRefundableVAT               taxTransRefundableVAT;
        CustTable                           custTable;
        VendTable                           vendTable;
        TaxTrans_W                          taxTrans_W;

        CustInvoiceJour                     custInvoiceJour;
        VendInvoiceJour                     vendInvoiceJour;
        TaxParameters                       taxParameters = TaxParameters::find();
        boolean                             isCorrected;
        Set                                 relatedTaxTransSet = new Set(Types::Int64); // this set is used to collect related (correction/original) tax
                                                                                        // transactions which have to be shown in the Itemized VAT report,
                                                                                        // but which might not be selected by the query (e.g. they are in the previous periods)
        container                           con;

        ;
        select firstOnly RecId
            from taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.TaxTrans == _taxTrans.RecId &&
                    taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
            join LedgerDimension, Text from generalJournalAccountEntry
                where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry;

        taxTransRefundableVAT   = TaxTransRefundableVAT::findByTaxTrans(_taxTrans.RecId);

        taxTrans_W = _taxTrans.taxTrans_W();

        this.SetOffAccount      = MainAccount::findByLedgerDimension(generalJournalAccountEntry.LedgerDimension).MainAccountId;
        this.SettleDate         = taxTransRefundableVAT.SettleDate;
        this.InvoiceDate        = _taxTrans.TransDate;
        this.Transfer           = (taxTrans_W.VatDueDate_W < _periodStart) ? false : true;
        this.TaxCode            = _taxTrans.TaxCode;
        this.TransDate          = taxTrans_W.VatDueDate_W;
        this.Voucher            = _taxTrans.Voucher;
        this.SourceCurrencyCode = _taxTrans.SourceCurrencyCode;

        switch (_taxTrans.Source)
        {
            case TaxModuleType::SalesInvoice,
                 TaxModuleType::FreeTxtInvoice,
                 TaxModuleType::CustCollectionLetter,
                 TaxModuleType::CustInterestNote,
                 TaxModuleType::ProjectInvoice,
                 TaxModuleType::Sales:

                select firstonly custTrans
                    where custTrans.Voucher    == _taxTrans.Voucher &&
                        custTrans.TransDate  == _taxTrans.TransDate;

                if (!_excludeForeignTrade || IntrastatCountryRegionParameters::isDomestic(CustTable::find(custTrans.AccountNum).postalAddress().CountryRegionId))
                {
                this.initFromCustTrans(_taxTrans, custTrans, _reportMode_W);
                }

                if (taxParameters.ItemizedVATStatement_HU)
                {
                    select firstonly RecId
                        from    custInvoiceJour
                        where   custInvoiceJour.LedgerVoucher   == _taxTrans.Voucher &&
                                custInvoiceJour.InvoiceDate     == _taxTrans.TransDate;

                    [isCorrected, con]      = this.processCorrectionsCust(_taxTrans, _runDate, _searchRelatedTaxTrans);
                    relatedTaxTransSet      = Set::create(con);
                    this.InvoiceRefRecId    = custInvoiceJour.RecId;
                    this.DirPartyRecId      = CustTable::find(custTrans.AccountNum).Party;
                }
                break;

            case TaxModuleType::PurchInvoice,
                 TaxModuleType::Purch:

                select firstonly vendTrans
                     where vendTrans.Voucher   == _taxTrans.Voucher &&
                        vendTrans.TransDate == _taxTrans.TransDate;

                if (!_excludeForeignTrade || IntrastatCountryRegionParameters::isDomestic(VendTable::find(vendtrans.AccountNum).postalAddress().CountryRegionId))
                {
                this.initFromVendTrans(_taxTrans, vendTrans, _reportMode_W);
                }

                if (taxParameters.ItemizedVATStatement_HU)
                {
                    select firstonly RecId
                        from    vendInvoiceJour
                        where   vendInvoiceJour.LedgerVoucher   == _taxTrans.Voucher &&
                                vendInvoiceJour.InvoiceDate     == _taxTrans.TransDate;

                    [isCorrected, con]      = this.processCorrectionsVend(_taxTrans, _runDate, _searchRelatedTaxTrans);
                    relatedTaxTransSet      = Set::create(con);
                    this.InvoiceRefRecId    = vendInvoiceJour.RecId;
                    this.DirPartyRecId      = VendTable::find(vendTrans.AccountNum).Party;
                }
                break;

            case TaxModuleType::Project:

                this.initTaxAmounts(_taxTrans, _reportMode_W, tableNum(ProjInvoiceJour));

                if (taxParameters.ItemizedVATStatement_HU)
                {
                    custTrans = CustTrans::findVoucherDate(_taxTrans.Voucher, _taxTrans.TransDate);

                    if (custTrans)
                    {
                        this.DirPartyRecId = CustTable::find(custTrans.AccountNum).Party;
                    }
                }
                break;

            case TaxModuleType::Voucher:

                select firstonly vendTrans
                     where vendTrans.Voucher   == _taxTrans.Voucher &&
                           vendTrans.TransDate == _taxTrans.TransDate;

                if (vendTrans)
                {
                    if (! _excludeForeignTrade || IntrastatCountryRegionParameters::isDomestic(VendTable::find(vendtrans.AccountNum).postalAddress().CountryRegionId))
                    {
                    this.initFromVendTrans(_taxTrans, vendTrans, _reportMode_W);
                    }

                    if (taxParameters.ItemizedVATStatement_HU)
                    {
                        select firstonly RecId
                            from    vendInvoiceJour
                            where   vendInvoiceJour.LedgerVoucher   == _taxTrans.Voucher &&
                                    vendInvoiceJour.InvoiceDate     == _taxTrans.TransDate;

                        [isCorrected, con]      = this.processCorrectionsVend(_taxTrans, _runDate, _searchRelatedTaxTrans);
                        relatedTaxTransSet      = Set::create(con);
                        this.InvoiceRefRecId    = vendInvoiceJour.RecId;
                        this.DirPartyRecId      = VendTable::find(vendTrans.AccountNum).Party;
                    }
                }
                else
                {
                    select firstonly custTrans
                        where custTrans.Voucher == _taxTrans.Voucher &&
                            custTrans.TransDate == _taxTrans.TransDate;

                    if (custTrans)
                    {
                        if (!_excludeForeignTrade || IntrastatCountryRegionParameters::isDomestic(CustTable::find(custTrans.AccountNum).postalAddress().CountryRegionId))
                        {
                        this.initFromCustTrans(_taxTrans, custTrans, _reportMode_W);
                        }

                        if (taxParameters.ItemizedVATStatement_HU)
                        {
                            select firstonly RecId
                                from    custInvoiceJour
                                where   custInvoiceJour.LedgerVoucher   == _taxTrans.Voucher &&
                                        custInvoiceJour.InvoiceDate     == _taxTrans.TransDate;

                            [isCorrected, con]      = this.processCorrectionsCust(_taxTrans, _runDate, _searchRelatedTaxTrans);
                            relatedTaxTransSet      = Set::create(con);
                            this.InvoiceRefRecId    = custInvoiceJour.RecId;
                            this.DirPartyRecId      = CustTable::find(custTrans.AccountNum).Party;
                        }
                    }
                    else
                    {
                        this.initFromGeneralJournalAccountEntry(_taxTrans, generalJournalAccountEntry, _reportMode_W);
                    }
                }
                break;

            default:
                break;
        }

        if (this.LedAccType == LedgerJournalACType::Vend &&
            (_taxTrans.TaxDirection == TaxDirection::IncomingTax ||
                _taxTrans.TaxDirection == TaxDirection::IncomingTax_W ||
                _taxTrans.TaxDirection == TaxDirection::UseTax))
        {
            this.Settled = (taxTransRefundableVAT.SettleDate && _rundate >= taxTransRefundableVAT.SettleDate);
        }
        else
        {
            this.Settled = true;
        }

        switch (_taxTrans.TaxDirection)
        {
            case TaxDirection::IncomingTax:
            case TaxDirection::IncomingTax_W:
                this.TaxDirection = TaxDirection::IncomingTax;
                break;

            case TaxDirection::OutgoingTax:
            case TaxDirection::OutgoingTax_W:
                this.TaxDirection = TaxDirection::OutgoingTax;
                break;

            default:
                this.TaxDirection = _taxTrans.TaxDirection;
                break;
        }

        if (this.InvoiceAccount)
        {
            switch (this.LedAccType)
            {
                case LedgerJournalACType::Cust :
                    custTable = CustTable::find(this.InvoiceAccount);

                    if (custTable)
                    {
                        this.Name = custTable.name();
                    }
                    break;
                case LedgerJournalACType::Vend :
                    vendTable = VendTable::find(this.InvoiceAccount);

                    if (vendTable)
                    {
                        this.Name = vendTable.name();
                    }
                    break;
                default:
                    break;
            }
        }

        if (taxParameters.ItemizedVATStatement_HU)
        {
            if (this.OriginalInvoiceRefRecId == 0)
            {
                this.OriginalInvoiceRefRecId = this.InvoiceRefRecId;
            }

            // this field is used to sort the data in the report in order to show the original invoice first
            this.IsOriginal = (this.OriginalInvoiceRefRecId == this.InvoiceRefRecId);

            if (this.TaxDirection == TaxDirection::OutgoingTax)
            {
                this.SectionNo = (! this.IsOriginal || isCorrected || ! _searchRelatedTaxTrans) ? 2 : 1;
                this.TaxAmount     = -this.TaxAmount;
                this.TaxBaseAmount = -this.TaxBaseAmount;
            }
            else if (   this.TaxDirection == TaxDirection::IncomingTax
                     || this.TaxDirection == TaxDirection::UseTax)
            {
                this.SectionNo = (! this.IsOriginal || isCorrected || ! _searchRelatedTaxTrans) ? 4 : 3;
            }
        }

        return relatedTaxTransSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromVendTrans</Name>
				<Source><![CDATA[
    private void initFromVendTrans(TaxTrans _taxTrans, VendTrans _vendTrans, ReportMode_W _reportMode)
    {
        this.LedAccType     = LedgerJournalACType::Vend;
        this.InvoiceAccount = _vendTrans.AccountNum;
        this.InvoiceId      = _vendTrans.Invoice;
        this.initTaxAmounts(_taxTrans, _reportMode, tableNum(VendInvoiceJour));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxAmounts</Name>
				<Source><![CDATA[
    private void initTaxAmounts(TaxTrans _taxTrans, ReportMode_W _reportMode, TableId _taxTransOrigin)
    {
        container taxAmounts;

        taxAmounts = TmpTaxReport_HU::getTaxAmounts(_taxTrans, _reportMode, true, _taxTransOrigin);

        this.TaxBaseAmount = conPeek(taxAmounts, 1);
        this.TaxAmount = conPeek(taxAmounts, 2);
        this.ExchRate = conPeek(taxAmounts, 3);

        this.initTaxRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxRate</Name>
				<Source><![CDATA[
    private void initTaxRate()
    {
        TaxValue vatExemptPct;

        if (this.TaxBaseAmount)
        {
            this.TaxRate = TaxData::percent(this.TaxCode,
                                            this.InvoiceDate,
                                            this.TaxBaseAmount);

            vatExemptPct = TaxData::find(this.TaxCode, this.InvoiceDate, this.TaxBaseAmount).vatExemptPct;

            if (vatExemptPct)
            {
                this.TaxBaseAmount = CurrencyExchangeHelper::amount(this.TaxBaseAmount * (100 - vatExemptPct)/100);
            }
        }
        else
        {
            this.TaxRate = 0;
        }

        if (!this.TaxRate && this.TaxAmount && this.TaxBaseAmount)
        {
            this.TaxRate = round(this.TaxAmount * 100 / this.TaxBaseAmount, 0.01);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCorrectionsCust</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the <c>TaxTrans</c> was corrected and searches all related (correction and original) tax transactions which have to be included in the report.
    /// </summary>
    /// <param name="_taxTrans">
    ///     The <c>TaxTrans</c> record to search related transactions for.
    /// </param>
    /// <param name="_runDate">
    ///     The report run date (end of period in the case of Itemized VAT Statement).
    /// </param>
    /// <param name="_searchRelatedTaxTrans">
    ///     Shows whether to search related tax transactions.
    /// </param>
    /// <returns>
    ///     The container with two parameters: whether the tax transaction was corrected, and the packed set of related transactions.
    /// </returns>
    private container processCorrectionsCust(TaxTrans    _taxTrans,
                                             TransDate   _runDate,
                                             boolean     _searchRelatedTaxTrans)
    {
        CustInvoiceTrans        custInvoiceTrans,   custInvoiceTransCorrective;
        CustInvoiceTrans_W      custInvoiceTrans_W, custInvoiceTrans_WCorrective;

        boolean                 isCorrected;
        TaxTrans                taxTransLoc;
        TaxTrans_W              taxTrans_W;
        Set                     relatedTaxTransRecIdSet = new Set(Types::Int64);

        if (_taxTrans.InventTransId)
        {
            custInvoiceTrans = CustInvoiceTrans::findInventTransid(_taxTrans.InventTransId);
        }
        else if (_taxTrans.SourceTableId == tableNum(custInvoiceTrans))
        {
            custInvoiceTrans = CustInvoiceTrans::findRecId(_taxTrans.SourceRecId);
        }
        else
        {
            // looking for the taxTrans from the same invoice which relates to the custInvoiceTrans
            select firstOnly taxTransLoc
                where taxTransLoc.Voucher       == _taxTrans.Voucher
                    && taxTransLoc.TransDate     == _taxTrans.TransDate
                    && taxTransLoc.SourceTableId == tableNum(custInvoiceTrans);

            custInvoiceTrans = CustInvoiceTrans::findRecId(taxTransLoc.SourceRecId);
        }

        if (custInvoiceTrans)
        {
            custInvoiceTrans_W = custInvoiceTrans.custInvoiceTrans_W();

            select firstonly custInvoiceTransCorrective
            join custInvoiceTrans_WCorrective
                where custInvoiceTrans_WCorrective.CustInvoiceTrans == custInvoiceTransCorrective.recId
                   && custInvoiceTrans_WCorrective.RefReturnInvoiceTrans_W == custInvoiceTrans.RecId
            exists join taxTransLoc
                where (   custInvoiceTransCorrective.InventTransId
                       && taxTransLoc.InventTransId == custInvoiceTransCorrective.InventTransId)
                   || (   taxTransLoc.SourceTableId == tableNum(custInvoiceTrans)
                       && taxTransLoc.SourceRecId == custInvoiceTransCorrective.RecId)
            exists join taxTrans_W
                where taxTrans_W.TaxTrans == taxTransLoc.RecId
                   && taxTrans_W.VatDueDate_W <= _runDate;

            if (custInvoiceTransCorrective)
                isCorrected = NoYes::Yes;

            // looking for the original invoice
            while (custInvoiceTrans_W.RefReturnInvoiceTrans_W)
            {
                custInvoiceTrans    = CustInvoiceTrans::findRecId(custInvoiceTrans_W.RefReturnInvoiceTrans_W);
                custInvoiceTrans_W  = custInvoiceTrans.custInvoiceTrans_W();
            }

            this.OriginalInvoiceId          = custInvoiceTrans.InvoiceId;
            this.OriginalInvoiceRefRecId    = custInvoiceTrans.custInvoiceJour().RecId;

            if (_searchRelatedTaxTrans)
            {
                relatedTaxTransRecIdSet = this.searchRelatedTaxTransCust(custInvoiceTrans, _taxTrans, _runDate);
            }
        }

        return [isCorrected, relatedTaxTransRecIdSet.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCorrectionsVend</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the <c>TaxTrans</c> was corrected and searches all related tax transactions (correction and original) which have to be included in the report.
    /// </summary>
    /// <param name="_taxTrans">
    ///     The <c>TaxTrans</c> record to search related transactions for.
    /// </param>
    /// <param name="_runDate">
    ///     The report run date (end of period in the case of Itemized VAT Statement).
    /// </param>
    /// <param name="_searchRelatedTaxTrans">
    ///     Shows whether to search related tax transactions.
    /// </param>
    /// <returns>
    ///     The container with two parameters: whether the tax transaction was corrected, and the packed set of related transactions.
    /// </returns>
    container processCorrectionsVend(TaxTrans    _taxTrans,
                                     TransDate   _runDate,
                                     boolean     _searchRelatedTaxTrans)
    {
        VendInvoiceTrans        vendInvoiceTrans, vendInvoiceTransCorrective;
        boolean                 isCorrected;
        TaxTrans                taxTransLoc;
        TaxTrans_W              taxTrans_W;
        Set                     relatedTaxTransRecIdSet = new Set(Types::Int64);

        if (_taxTrans.InventTransId)
        {
            vendInvoiceTrans = VendInvoiceTrans::findInventTransid(_taxTrans.InventTransId);
        }
        else if (_taxTrans.SourceTableId == tableNum(vendInvoiceTrans))
        {
            vendInvoiceTrans = VendInvoiceTrans::findRecId(_taxTrans.SourceRecId);
        }
        else
        {
            // looking for the taxTrans from the same invoice which relates to the vendInvoiceTrans
            select firstOnly taxTransLoc
                where taxTransLoc.Voucher       == _taxTrans.Voucher
                   && taxTransLoc.TransDate     == _taxTrans.TransDate
                   && taxTransLoc.SourceTableId == tableNum(custInvoiceTrans);

            vendInvoiceTrans = VendInvoiceTrans::findRecId(taxTransLoc.SourceRecId);
        }

        if (vendInvoiceTrans)
        {
            select firstonly vendInvoiceTransCorrective
                where vendInvoiceTransCorrective.RefReturnInvoiceTrans_W == vendInvoiceTrans.RecId
            exists join taxTransLoc
                where (   vendInvoiceTransCorrective.InventTransId
                       && taxTransLoc.InventTransId == vendInvoiceTransCorrective.InventTransId)
                   || (   taxTransLoc.SourceTableId == tableNum(vendInvoiceTrans)
                       && taxTransLoc.SourceRecId == vendInvoiceTransCorrective.RecId)
            exists join taxTrans_W
                where taxTrans_W.TaxTrans == taxTransLoc.RecId
                   && taxTrans_W.VatDueDate_W <= _runDate;

            if (vendInvoiceTransCorrective)
                isCorrected = NoYes::Yes;

            // looking for the original invoice
            while (vendInvoiceTrans.RefReturnInvoiceTrans_W)
            {
                vendInvoiceTrans =  VendInvoiceTrans::findRecId(vendInvoiceTrans.RefReturnInvoiceTrans_W);
            }

            this.OriginalInvoiceId       = vendInvoiceTrans.InvoiceId;
            this.OriginalInvoiceRefRecId = vendInvoiceTrans.vendInvoiceJour().RecId;

            if (_searchRelatedTaxTrans)
            {
                relatedTaxTransRecIdSet = this.searchRelatedTaxTransVend(vendInvoiceTrans, _taxTrans, _runDate);
            }
        }

        return [isCorrected, relatedTaxTransRecIdSet.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchRelatedTaxTransCust</Name>
				<Source><![CDATA[
    private Set searchRelatedTaxTransCust(CustInvoiceTrans  _custInvoiceTrans,
                                          TaxTrans          _taxTrans,
                                          TransDate         _runDate)
    {
        CustInvoiceJour     custInvoiceJourLocal = _custInvoiceTrans.custInvoiceJour();
        CustInvoiceTrans    custInvoiceTransLocal, custInvoiceTransLocalAll;
        CustInvoiceTrans_W  custInvoiceTrans_WLocal;
        TaxTrans            taxTransLoc;
        TaxTrans_W          taxTrans_W;
        Set                 relatedTaxTransRecIdSet = new Set(Types::Int64);

        while select RecId from taxTransLoc
            where taxTransLoc.TransDate == custInvoiceJourLocal.InvoiceDate
                && taxTransLoc.Voucher   == custInvoiceJourLocal.LedgerVoucher
                && taxTransLoc.TaxPeriod == _taxTrans.TaxPeriod
                && taxTransLoc.RecId     != _taxTrans.RecId
        join RecId from taxTrans_W
            where taxTrans_W.TaxTrans == taxTransLoc.RecId
                && taxTrans_W.VatDueDate_W <= _runDate
        {
            relatedTaxTransRecIdSet.add(taxTransLoc.RecId);
        }

        while select RecId from custInvoiceTransLocalAll
            where custInvoiceTransLocalAll.SalesId                == custInvoiceJourLocal.SalesId
                && custInvoiceTransLocalAll.InvoiceId              == custInvoiceJourLocal.InvoiceId
                && custInvoiceTransLocalAll.InvoiceDate            == custInvoiceJourLocal.InvoiceDate
                && custInvoiceTransLocalAll.numberSequenceGroup    == custInvoiceJourLocal.numberSequenceGroup
        {
            while select custInvoiceTransLocal
            exists join custInvoiceTrans_WLocal
                where custInvoiceTrans_WLocal.CustInvoiceTrans == custInvoiceTransLocal.RecId
                    && custInvoiceTrans_WLocal.RefReturnInvoiceTrans_W == custInvoiceTransLocalAll.RecId
            {
                this.searchRelatedTaxTransCust(custInvoiceTransLocal, _taxTrans, _runDate);
            }
        }

        return relatedTaxTransRecIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchRelatedTaxTransVend</Name>
				<Source><![CDATA[
    private Set searchRelatedTaxTransVend(VendInvoiceTrans  _vendInvoiceTrans,
                                          TaxTrans          _taxTrans,
                                          TransDate         _runDate)
    {
        VendInvoiceJour     vendInvoiceJourLocal = _vendInvoiceTrans.vendInvoiceJour();
        VendInvoiceTrans    vendInvoiceTransLocal, vendInvoiceTransLocalAll;
        TaxTrans            taxTransLoc;
        TaxTrans_W          taxTrans_W;
        Set                 relatedTaxTransRecIdSet = new Set(Types::Int64);

        while select RecId from taxTransLoc
            where taxTransLoc.TransDate == vendInvoiceJourLocal.InvoiceDate
                && taxTransLoc.Voucher   == vendInvoiceJourLocal.LedgerVoucher
                && taxTransLoc.TaxPeriod == _taxTrans.TaxPeriod
                && taxTransLoc.RecId     != _taxTrans.RecId
        join RecId from taxTrans_W
            where taxTrans_W.TaxTrans == taxTransLoc.RecId
                && taxTrans_W.VatDueDate_W <= _runDate
        {
            relatedTaxTransRecIdSet.add(taxTransLoc.RecId);
        }

        while select RecId from vendInvoiceTransLocalAll
            where vendInvoiceTransLocalAll.PurchID                == vendInvoiceJourLocal.PurchId
                && vendInvoiceTransLocalAll.InvoiceId              == vendInvoiceJourLocal.InvoiceId
                && vendInvoiceTransLocalAll.InvoiceDate            == vendInvoiceJourLocal.InvoiceDate
                && vendInvoiceTransLocalAll.numberSequenceGroup    == vendInvoiceJourLocal.numberSequenceGroup
                && vendInvoiceTransLocalAll.InternalInvoiceId      == vendInvoiceJourLocal.InternalInvoiceId
        {
            while select vendInvoiceTransLocal
                where vendInvoiceTransLocal.RefReturnInvoiceTrans_W == vendInvoiceTransLocalAll.RecId
            {
                this.searchRelatedTaxTransVend(vendInvoiceTransLocal, _taxTrans, _runDate);
            }
        }

        return relatedTaxTransRecIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchRate</Name>
				<Source><![CDATA[
    private static ExchRate getExchRate(TaxTrans _taxTrans, TableId _taxTransOrigin)
    {
        ExchRate            exchRate;
        CustVendInvoiceJour invoiceJour;
        CustInvoiceJour     custInvoiceJour;
        VendInvoiceJour     vendInvoiceJour;
        ProjInvoiceJour     projInvoiceJour;
        boolean             isInvoiceJourExchRate;

        switch (_taxTransOrigin)
        {
            case tableNum(CustInvoiceJour):
                invoiceJour = custInvoiceJour;
                isInvoiceJourExchRate = true;
                break;

            case tableNum(VendInvoiceJour):
                invoiceJour = vendInvoiceJour;
                isInvoiceJourExchRate = true;
                break;

            case tableNum(ProjInvoiceJour):
                invoiceJour = projInvoiceJour;
                isInvoiceJourExchRate = true;
                break;

            case tableNum(ledgerJournalTrans):
                exchRate = TmpTaxReport_HU::getExchRateForFinancialJournal(_taxTrans);
                break;
        }

        if (isInvoiceJourExchRate)
        {
            select firstOnly ExchRate
                from invoiceJour
                    where invoiceJour.LedgerVoucher   == _taxTrans.Voucher &&
                        invoiceJour.InvoiceDate     == _taxTrans.TransDate;

            if (invoiceJour)
            {
                exchRate = round(invoiceJour.ExchRate/100, 0.01);
            }
            else
            {
                if (_taxTrans.SourceTableId == tableNum(LedgerJournalTrans))
                {
                    // Try find the exchange rate through LedgerJournalTrans.
                    // Note LedgerJournalTrans record might not exist because its JournalName 'delete lines after posting' setting is true
                    exchRate = TmpTaxReport_HU::getExchRateForFinancialJournal(_taxTrans);
                }
            }
        }

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchRateForFinancialJournal</Name>
				<Source><![CDATA[
    private static ExchRate getExchRateForFinancialJournal(TaxTrans _taxTrans)
    {
        ExchRate            exchRate;
        LedgerJournalTrans  ledgerJournalTrans;

        // Try find the exchange rate through LedgerJournalTrans.
        // Note LedgerJournalTrans record might not exist because its JournalName 'delete lines after posting' setting is true

        select firstOnly ExchRate
            from ledgerJournalTrans
                where ledgerJournalTrans.RecId == _taxTrans.SourceRecId;

        exchRate = round(ledgerJournalTrans.ExchRate/100, 0.01);

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax detailed amounts for the specified tax transaction.
    /// </summary>
    /// <param name="_taxTrans">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <param name="_reportMode">
    /// The reporing mode in which the tax detailed amounts are needed.
    /// </param>
    /// <param name="_includeExchRate">
    /// A Boolean value that indicates whether to include the exchange rate used to calculate the tax amounts in the company currency for accounting.
    /// </param>
    /// <param name="_taxTransOriginForExchRate">
    /// The table identity of the tax transaction origin table that should be used to find the exchange rate.
    /// </param>
    /// <returns>
    /// A container with three elements, including the tax base amount, the tax amount, and the exchange rate.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Wrong use of function.
    /// </exception>
    public static container getTaxAmounts(TaxTrans _taxTrans, ReportMode_W _reportMode, boolean _includeExchRate, TableId _taxTransOriginForExchRate)
    {
        TaxBase     taxBaseAmount;
        TaxAmount   taxAmount;
        ExchRate    exchRate;

        if (_includeExchRate && !_taxTransOriginForExchRate)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        switch (_reportMode)
        {
            case ReportMode_W::Original:
                
                taxBaseAmount = _taxTrans.SourceBaseAmountCurRegulated ? _taxTrans.SourceBaseAmountCurRegulated : _taxTrans.SourceBaseAmountCur;
                taxAmount = _taxTrans.SourceRegulateAmountCur;
                break;

            case ReportMode_W::Accounting:

                taxBaseAmount  = _taxTrans.TaxBaseAmount;
                taxAmount      = _taxTrans.TaxAmount;

                if (_includeExchRate)
                {
                    exchRate = TmpTaxReport_HU::getExchRate(_taxTrans, _taxTransOriginForExchRate);
                }
                break;

            case ReportMode_W::Reporting:
                
                taxBaseAmount = _taxTrans.TaxBaseAmountCur;
                taxAmount = _taxTrans.TaxAmountCur;
                exchRate = TmpTaxReport_HU::getTaxTransExchRateByAmounts(_taxTrans);
                break;

            default:
                break;
        }

        return [taxBaseAmount, taxAmount, exchRate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTransExchRateByAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates currency exchange rate between the transaction currency and the sales tax code currency by amounts stored in appropriate 
    /// fields of the <c>TaxTrans</c> record.
    /// </summary>
    /// <param name = "_taxTrans">The <c>TaxTrans</c> record.</param>
    /// <returns>Calculated currency exchange rate</returns>
    /// <remarks>
    /// As at the present time only exchange rate between transaction currency and accounting currency is saved in the system.
    /// For this particular case we need exchange rate between transaction currency and SALES TAX currency, and there is no place
    /// in the system where this exchange rate would be stored, so we have to retrieve exchange rate from appropriate amounts.
    /// </remarks>
    private static ExchRate getTaxTransExchRateByAmounts(TaxTrans _taxTrans)
    {
        ExchRate ret;

        if (_taxTrans.SourceBaseAmountCur)
        {
            ret = round(_taxTrans.TaxBaseAmountCur / _taxTrans.SourceBaseAmountCur / 100, 0.01);
        }
        if (!ret && _taxTrans.SourceRegulateAmountCur)
        {
            ret = round(_taxTrans.TaxAmountCur / _taxTrans.SourceRegulateAmountCur / 100, 0.01);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTransExchRate</Name>
				<Source><![CDATA[
    private static ExchRate getTaxTransExchRate(TaxTrans _taxTrans, TableId _taxTransOrigin)
    {
        ExchRate                        exchRate;
        CustVendInvoiceJour             invoiceJour;
        CustInvoiceJour                 custInvoiceJour;
        VendInvoiceJour                 vendInvoiceJour;
        ProjInvoiceJour                 projInvoiceJour;
        SalesTaxTransactionExchangeRate taxTransExchRate;
        boolean                         isInvoiceJourTaxTransExchRate;

        switch (_taxTransOrigin)
        {
            case tableNum(CustInvoiceJour):
                invoiceJour = custInvoiceJour;
                isInvoiceJourTaxTransExchRate = true;
                break;

            case tableNum(VendInvoiceJour):
                invoiceJour = vendInvoiceJour;
                isInvoiceJourTaxTransExchRate = true;
                break;

            case tableNum(ProjInvoiceJour):
                invoiceJour = projInvoiceJour;
                isInvoiceJourTaxTransExchRate = true;
                break;

            case tableNum(LedgerJournalTrans):
                exchRate = TmpTaxReport_HU::getTaxTransExchRateForFinancialJournal(_taxTrans);
                break;
        }

        if (isInvoiceJourTaxTransExchRate)
        {
            select firstOnly RecId
                from invoiceJour
                    where invoiceJour.LedgerVoucher   == _taxTrans.Voucher &&
                        invoiceJour.InvoiceDate     == _taxTrans.TransDate
                join SalesTaxExchangeRate from taxTransExchRate
                    where taxTransExchRate.SourceTableId == _taxTransOrigin &&
                        taxTransExchRate.SourceRecordId == invoiceJour.RecId;

            if (invoiceJour)
            {
                exchRate = round(taxTransExchRate.SalesTaxExchangeRate/100, 0.01);
            }
            else
            {
                if (_taxTrans.SourceTableId == tableNum(LedgerJournalTrans))
                {
                    exchRate = TmpTaxReport_HU::getTaxTransExchRateForFinancialJournal(_taxTrans);
                }
            }
        }

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTransExchRateForFinancialJournal</Name>
				<Source><![CDATA[
    private static ExchRate getTaxTransExchRateForFinancialJournal(TaxTrans _taxTrans)
    {
        ExchRate                        exchRate;
        SalesTaxTransactionExchangeRate taxTransExchRate;

        select firstOnly SalesTaxExchangeRate
            from taxTransExchRate
                where taxTransExchRate.SourceTableId == _taxTrans.SourceTableId &&
                    taxTransExchRate.SourceRecordId == _taxTrans.SourceRecId;

        exchRate = round(taxTransExchRate.SalesTaxExchangeRate/100, 0.01);

        return exchRate;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<CountryRegionCodes>HU</CountryRegionCodes>
	<Label>@GLS111565</Label>
	<ClusteredIndex></ClusteredIndex>
	<CreateRecIdIndex>No</CreateRecIdIndex>
	<PrimaryIndex></PrimaryIndex>
	<TableType>InMemory</TableType>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VATExchRate_W</Name>
			<Label>@GLS112405</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceCurrencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DirPartyRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>DirPartyRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ExceedsTheLimit</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchRate</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ExchRate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ExcludeFromTotals</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InvoiceAccount</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>CustVendAC</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>InvoiceDate</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InvoiceId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InvoiceId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InvoiceRefRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsOriginal</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LedAccType</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>LedgerJournalACType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TransactionTextLarge</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OriginalInvoiceId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>InvoiceId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OriginalInvoiceRefRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>SectionNo</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>Integer</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SetOffAccount</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>AccountNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Settled</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS16693</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>SettleDate</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS16693</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SourceCurrencyCode</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxAmount</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxBaseAmount</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TaxBase</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxCode</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TaxCode</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxDirection</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<EnumType>TaxDirection</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxRate</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>Percent</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>TransDate</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Transfer</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VATNum</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>VATNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Voucher</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>Voucher</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>RepOrder</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Transfer</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxDirection</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Settled</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InvoiceDate</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations />
	<StateMachines />
</AxTable>