<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TrvExpTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class TrvExpTrans extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>itemizedLinesDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Itemized lines were deleted
    /// </summary>
    /// <param name="newCategory">
    /// The new category that triggered the itemization deletion
    /// </param>
    delegate void itemizedLinesDeleted(TrvCostType newCategory) {}

]]></Source>
			</Method>
			<Method>
				<Name>guestsDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Guest information was delete
    /// </summary>
    delegate void guestsDeleted() {}

]]></Source>
			</Method>
			<Method>
				<Name>amountCurrWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the amount in transaction currency, alongwith the transaction currency code.
    /// </summary>
    /// <returns>
    /// The amount in transaction currency, alongwith the transaction currency code.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvTransactionAmountWithCurrencyCode amountCurrWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithTransactionCurrencyCode(this.AmountCurr, this.ExchangeCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the amount in with the currency code.
    /// The local amount and currency is used for credit card transactions, otherwise amountCurr is used.
    /// </summary>
    /// <returns>
    /// The amount to be displayed.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvTransactionAmountWithCurrencyCode amountWithCurrencyCode()
    {
        if (this.isCreditCardTransaction())
        {
            return TrvExpenseHelper::amountWithTransactionCurrencyCode(this.CreditCardTransactionCurrencyAmount, this.CreditCardTransactionCurrency);
        }
       
        return TrvExpenseHelper::amountWithTransactionCurrencyCode(this.AmountCurr, this.ExchangeCode);

    }

]]></Source>
			</Method>
			<Method>
				<Name>amountCurrWithoutTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the amount in transaction currency without the corrected tax.
    /// </summary>
    /// <returns>
    /// The amount in transaction currency without the corrected tax.
    /// </returns>
    display AmountCur amountCurrWithoutTax()
    {
        if (this.LineType == TrvExpLineType::ItemizedHeader)
        {
            return TrvExpTrans::totalOfChildLinesWithoutTax(this);
        }
        else
        {
            return TrvExpTrans::amountCurExpLineWithoutTax(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the AmountMST field based on the transaction amount, exchange code and exchange rate.
    /// </summary>
    void amountMST()
    {
        boolean             isCreditCardTransaction = this.isCreditCardTransaction();
        TrvCurrencyCode     exchangeCode = this.ExchangeCode;
        AmountCur           transactionCurrencyAmount = this.AmountCurr;

        // for card transactions, see if we have local currency fields set
        if (isCreditCardTransaction && this.CreditCardTransactionCurrency)
        {
            exchangeCode = this.CreditCardTransactionCurrency;
            transactionCurrencyAmount = this.CreditCardTransactionCurrencyAmount;
        }
            

        if (this.ExchangeRate)
        {
            this.AmountMST = CurrencyExchangeHelper::amountCur2MST(transactionCurrencyAmount, exchangeCode, this.ExchangeRate);
        }
        else
        {
            this.AmountMST = transactionCurrencyAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountMSTWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the amount in company currency, alongwith the company currency code.
    /// </summary>
    /// <returns>
    /// The amount in company currency, alongwith the company currency code.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvAmountCurrency amountMSTWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithCurrencyCode(this.AmountMST, this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyPolicyViolations</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns whether the expense line has any expense policy violations or project policy violations.
    /// </summary>
    /// <returns>
    ///     True if the expense line has policy violations, false otherwise.
    /// </returns>
    public display TrvAnyPolicyViolations anyPolicyViolations()
    {
        List violations = this.policyViolationLevelMsg();

        return (violations.elements() != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyProjectPolicyViolations</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns whether the expense line has any project policy violations on expense level.
    /// </summary>
    /// <returns>
    ///     True if the expense line has project policy violations, false otherwise.
    /// </returns>
    public boolean anyProjectPolicyViolations()
    {
        return this.ProjPolicyStatus == ProjExpPolicyStatus::ExpenseFailed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyDayOrReportProjectPolicyViolations</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns whether the expense line has any project policy violations on day or report level.
    /// </summary>
    /// <returns>
    ///     True if the expense line has project policy violations, false otherwise.
    /// </returns>
    public boolean anyDayOrReportProjectPolicyViolations()
    {
        return (this.ProjPolicyStatus == ProjExpPolicyStatus::DayFailed
                || this.ProjPolicyStatus == ProjExpPolicyStatus::DayWarning
                || this.ProjPolicyStatus == ProjExpPolicyStatus::ReportFailed
                || this.ProjPolicyStatus == ProjExpPolicyStatus::ReportWarning);
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyUserFieldsHaveChanged</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns whether an expense line field which is being tracked for changes has been updated.
    /// </summary>
    /// <returns>
    ///     True if any of the tracked expense line fields have been changed, false otherwise.
    /// </returns>
    protected boolean anyUserFieldsHaveChanged()
    {
        TrvExpTrans orig = this.orig();
        boolean     ret = false;

        //this list doesn't include the fields which are allowed to change after approved, e.g. tax related fields, merchantid etc.
        if (
            this.AdditionalInformation != orig.AdditionalInformation ||
            this.AmountCurr != orig.AmountCurr ||
            this.AmountMST != orig.AmountMST ||
            this.ExchangeCode != orig.ExchangeCode ||
            this.TransDate != orig.TransDate ||
            this.PayMethod != orig.PayMethod ||
            this.Description != orig.Description ||
            this.TrvLocations != orig.TrvLocations ||
            this.DeduktionBreakfest != orig.DeduktionBreakfest ||
            this.DeduktionDinner != orig.DeduktionDinner ||
            this.DeduktionLunch != orig.DeduktionLunch ||
            this.kmOwnCar != orig.kmOwnCar ||
            this.Reason != orig.Reason ||
            this.TicketClass != orig.TicketClass ||
            this.TicketNumber != orig.TicketNumber ||
            this.TicketUsed != orig.TicketUsed)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>approverJustification</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns concatenated string of justifications entered by the other approvers, excluding the current approver.
    /// </summary>
    /// <returns>
    ///     Returns all approvers' justifications, other than the current approver's justification.
    /// </returns>
    display TrvPreviousApproversJustifications approverJustification()
    {
        return TrvJustificationHelper::otherApproversJustifications(this.RecId, TrvPolicyViolationJustificationTypeEnum::TrvExpLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>authorizedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives the amount on the requisition line to which the expense line is mapped.
    /// </summary>
    /// <returns>
    ///     The authorized amount in company currency.
    /// </returns>
    display AmountMST authorizedAmount()
    {
        TrvRequisitionLine  trvRequisitionLine;
        AmountMST           authorizedAmount;

        if (this.MappedToRequisitionLine)
        {
            select firstonly AccountingCurrencyAmount from trvRequisitionLine
                where trvRequisitionLine.RecId == this.MappedToRequisitionLine;

            authorizedAmount =  trvRequisitionLine.AccountingCurrencyAmount;
        }

        return authorizedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>authorizedAmountWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the amount on the requisition line to which the expense line is mapped in company currency, alongwith the company currency code.
    /// </summary>
    /// <returns>
    /// The authorized amount in company currency in company currency, alongwith the company currency code.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvAmountCurrency authorizedAmountWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithCurrencyCode(this.authorizedAmount(), this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>authorizedApproveAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the amount for approval in company currency for the current user.
    /// </summary>
    /// <param name="_trvExpTrans">
    ///     The expense line record.
    /// </param>
    /// <returns>
    ///     The amount for approval in company currency.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display AmountMST authorizedApproveAmount(TrvExpTrans _trvExpTrans)
    {
        TrvWorkflowExpProviderCache trvWorkflowExpProviderCache;
        AmountMST amountToApprove = 0;

        if (TrvWorkflowExpProviderCache::existForExpense(this.TrvExpTable, curUserId()))
        {
            select sum(TransactionAmount) from trvWorkflowExpProviderCache where trvWorkflowExpProviderCache.TrvExpTable == _trvExpTrans.TrvExpTable &&
                                                                                 trvWorkflowExpProviderCache.TrvExpTrans == _trvExpTrans.RecId &&
                                                                                 trvWorkflowExpProviderCache.WorkflowUser == curUserId();

            amountToApprove = trvWorkflowExpProviderCache.TransactionAmount;
        }
        else
        {
            amountToApprove = _trvExpTrans.AmountMST;
        }

        return amountToApprove;
    }

]]></Source>
			</Method>
			<Method>
				<Name>authorizedApproveAmountWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the amount for approval in company currency, alongwith the company currency code.
    /// </summary>
    /// <returns>
    /// The amount for approval in company currency, alongwith the company currency code.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvAmountCurrency authorizedApproveAmountWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithCurrencyCode(this.authorizedApproveAmount(this), this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>budgetCheckResult</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the budget check and project budget check result for an expense line.
    /// </summary>
    /// <returns>
    ///     Budget check and project budget check result for an expense line.
    /// </returns>
    /// <remarks>
    ///     For itemized header, we return the result based on the itemized lines.
    /// </remarks>
    display BudgetCheckResult budgetCheckResult()
    {
        BudgetSource        budgetSource;
        TrvExpTrans         trvExpTransItemizedLines;
        BudgetCheckResult   budgetCheckResult;
        ProjBudgetCheckResult projBudgetCheckResult;
        ProjBudgetStatus    projBudgetStatus;

        if (this.LineType != TrvExpLineType::ItemizedHeader)
        {
            budgetCheckResult = BudgetSourceSourceDocumentLine::findBudgetCheckResult(this.SourceDocumentLine);
            projBudgetStatus = ProjBudgetStatus::findBySourceDocumentLine(this.SourceDocumentLine);

            projBudgetCheckResult = projBudgetStatus ? projBudgetStatus.BudgetCheckResult : ProjBudgetCheckResult::NoCheck;
        }
        else
        {
            // add fields from alternate key similar to helper function above, for perf reasons
            select maxof(CheckResult) from budgetSource
                join SourceDocumentLine, RecId from trvExpTransItemizedLines
                    where budgetSource.SourceDocumentLine == trvExpTransItemizedLines.SourceDocumentLine
                        && budgetSource.BudgetSourceType == BudgetSourceType::SourceDocumentLine
                        && budgetSource.BudgetTransactionLine == 0
                        && budgetSource.LedgerEntryGeneralJournalEntry == 0
                        && budgetSource.LedgerEntryJournalNumber == ''
                        && budgetSource.LedgerEntryJournalReferenceNumber == ''
                        && budgetSource.LedgerEntryJournalLegalEntity == 0
                        && trvExpTransItemizedLines.ParentRecId == this.RecId;

            select maxof(BudgetCheckResult) from projBudgetStatus
                join SourceDocumentLine, RecId from trvExpTransItemizedLines
                    where projBudgetStatus.SourceDocumentLine == trvExpTransItemizedLines.SourceDocumentLine
                        && trvExpTransItemizedLines.ParentRecId == this.RecId;

            budgetCheckResult       = budgetSource ? budgetSource.CheckResult : BudgetCheckResult::NoCheck;
            projBudgetCheckResult   = projBudgetStatus ? projBudgetStatus.BudgetCheckResult : ProjBudgetCheckResult::NoCheck;
        }

        //adding projBudgetCheckResult + 1, since this base enum value starts from 0
        if (enum2int(budgetCheckResult) >= enum2int(projBudgetCheckResult) + 1)
        {
            budgetCheckResult = budgetCheckResult;
        }
        else
        {
            budgetCheckResult = enum2int(projBudgetCheckResult) + 1;
        }

        return budgetCheckResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcIntercompanyAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the intercompany amount fields, which store the transfer price of the expense between the entities, as well as the
    /// sales price in the borrowing legal entity.
    /// </summary>
    public void calcIntercompanyAmounts()
    {
        ProjTable                       projTable;
        ProjInvoiceTable                contract;
        ProjCategory                    category;
        boolean                         projectSalesPriceFound;
        CostPrice                       costPriceLocal;
        SalesPrice                      transferPrice;
        TrvExpTransSourceDocLineItem    sdLineItem;
        InterCompanyTradingPartner      tradingPartner;
        ExchRate                        transactionCurrencytoSalesCurrencyExchangeRate;

        if (this.isIntercompany() && this.ProjId != '')
        {
            if (!this.IntercompanyTransferCurrency)
            {
                tradingPartner  = InterCompanyTradingPartner::findTradingCustomer(this.ReferenceDataAreaId, this.InterCompanyLE);
                this.IntercompanyTransferCurrency = CustTable::findByPartyRecId(tradingPartner.CustomerParty).Currency;
                if (!this.IntercompanyTransferCurrency)
                {
                    changecompany (this.InterCompanyLE)
                    {
                        this.IntercompanyTransferCurrency = Ledger::accountingCurrency();
                    }
                }
            }

            sdLineItem =  SourceDocumentLineItem::newFromSourceDocumentLineImplementation(this);

            costPriceLocal = sdLineItem.parmSourceDocumentAmountMap().lookup(MonetaryAmount::ExtendedPrice).parmAmount();

            if (sdLineItem.parmQuantity() > 0)
            {
                costPriceLocal = costPriceLocal / sdLineItem.parmQuantity();
            }

            ProjPriceGroupID priceGroupId;

            changecompany(this.InterCompanyLE)
            {
                // We need to retrieve the final sales price in the company that will charge the expense to a customer.
                // This amount can be used to calculate the transfer price depending on the transfer price model.
                select firstonly ProjInvoiceProjId, CustAccount, ProjPriceGroup from projTable
                    where projTable.ProjId == this.ProjId;

                select firstonly CurrencyId, ProjPriceGroup from contract
                    where contract.ProjInvoiceProjId == projTable.ProjInvoiceProjId;

                priceGroupId = projTable.ProjPriceGroup;
                
                if (priceGroupId == '' && contract.ProjPriceGroup != '')
                {
                    priceGroupId = contract.ProjPriceGroup;
                }

                if (contract.CurrencyId)
                {
                    this.IntercompanySalesCurrency = contract.CurrencyId;
                }
                else
                {
                    this.IntercompanySalesCurrency = CustTable::find(projTable.CustAccount).Currency;
                }
            }

            if(this.IntercompanySalesCurrency)
            {

                SalesPrice salesCurrencyAmount = ExchangeRateHelper::curPrice2CurPrice(costPriceLocal , this.ExchangeCode , this.IntercompanySalesCurrency, this.TransDate);

                transactionCurrencytoSalesCurrencyExchangeRate = costPriceLocal == 0 ? this.ExchangeRate : (salesCurrencyAmount / costPriceLocal * 100.0);

            }

            changecompany(this.InterCompanyLE)
            {
                ProjPriceParameters priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
                    this.ProjId,
                    ResourceFacade::findByWorker(this.CreatingWorker, this.LegalEntity),
                    this.InterCompanyCategory,
                    costPriceLocal,
                    this.ExchangeCode,
                    this.IntercompanySalesCurrency,
                    this.TransDate,
                    priceGroupId,
                    projTable.ProjInvoiceProjId,
                    '',
                    this.IntercompanySalesCurrency ? transactionCurrencytoSalesCurrencyExchangeRate : this.ExchangeRate );

                [this.IntercompanySalesPrice, projectSalesPriceFound] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams, true, false);

                select firstonly RecId from category
                    where category.CategoryId == this.InterCompanyCategory;
            }

            if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                transferPrice = abs(costPriceLocal);
            }
            else
            {
                // First search using the currency which the other legal entity will be charged.
                // In order to ensure the cost price conversion to MST happens on expense transaction date, exchange rate and transaction date parameters are added
                transferPrice = ProjTransferPrice::findTransferPrice(ResourceFacade::findByWorker(this.CreatingWorker, this.LegalEntity),
                                                                    this.InterCompanyLE,
                                                                    projTable.RecId,
                                                                    category.RecId,
                                                                    this.ProjStatusId,
                                                                    this.TransDate,
                                                                    curext(),
                                                                    this.IntercompanyTransferCurrency,
                                                                    contract.RecId,
                                                                    CurrencyExchangeHelper::amountCur2MST(costPriceLocal < 0 ? -costPriceLocal : costPriceLocal, this.CreditCardTransactionCurrency ? this.CreditCardTransactionCurrency : this.ExchangeCode, this.ExchangeRate, this.TransDate),
                                                                    ExchangeRateHelper::curPrice2CurPrice(this.IntercompanySalesPrice, this.IntercompanySalesCurrency, this.IntercompanyTransferCurrency),
                                                                    ProjTransferPriceTransType::Expense);

                // Second attempt using invoicing company's own currency. This will be used if an specific sales amount exists in that currency.
                // We then ignore the contract company's sales price since if a valid setup using it existed, it would have been  used in the
                // first attempt.
                if (!transferPrice)
                {
                    transferPrice = ProjTransferPrice::findTransferPrice(ResourceFacade::findByWorker(this.CreatingWorker, this.LegalEntity),
                                                                  this.InterCompanyLE,
                                                                  projTable.RecId,
                                                                  category.RecId,
                                                                  this.ProjStatusId,
                                                                  this.TransDate,
                                                                  curext(),
                                                                  Ledger::accountingCurrency(),
                                                                  contract.RecId,
                                                                  (costPriceLocal < 0) ? -costPriceLocal : costPriceLocal,
                                                                  0,
                                                                  ProjTransferPriceTransType::Expense);
                    transferPrice = ExchangeRateHelper::curPrice(transferPrice, this.IntercompanyTransferCurrency);
                }
            }

            if (costPriceLocal < 0)
            {
                this.IntercompanyTransferPrice = -transferPrice;
            }
            else
            {
                this.IntercompanyTransferPrice = transferPrice;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWorkerVehicleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get default vehicle type for mileage transactions for a worker if needed.
    /// </summary>
    private void initWorkerVehicleType()
    {
        // prevent unnecessary use of this method
        Debug::assert(this.expType == TrvExpType::Transport);

        if (!this.VehicleType && this.CostType && this.TransDate)
        {
            this.VehicleType = TrvMileageHelper::getWorkerDefaultVehicleType(this.CreatingWorker, this.CostType, this.TransDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcKM</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculate amount for the mileage expense line.
    /// </summary>
    public void calcKM()
    {
        // prevent unnecessary use of this method
        Debug::assert(this.expType == TrvExpType::Transport);

        this.initWorkerVehicleType();
        if (this.KMOwnCar != 0 || this.KMPrice != 0)
        {
            TrvMileageHelper::calculateMileage(this);
            this.updateNetTransactionAmount();
            this.setCorrectedTaxAmountMST();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionCurrencyAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction currency amount.
    /// </summary>
    /// <param name = "_isCreditCardTransaction">
    /// Boolean value indicating if the transaction has any payments using credit card.
    /// </param>
    /// <returns>
    /// <c>AmountCur</c> value of the transaction record.
    /// </returns>
    public AmountCur getTransactionCurrencyAmount(boolean _isCreditCardTransaction)
    {
        return _isCreditCardTransaction ? this.CreditCardTransactionCurrencyAmount : this.AmountCurr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLegalEntityForTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets legal entity for tax references.
    /// </summary>
    /// <param name = "_trvExpTrans">The table buffer containing expense line information.</param>
    /// <returns> Legal entity </returns>
    /// <remarks>
    /// By default, this method returns the current company.
    /// For the intercompany expense, it returns InterCompanyLE if the legal entity in
    /// general ledger tax setup is set to destination, else it returns current company.
    /// </remarks>
    public static TrvLegalEntity getLegalEntityForTax(TrvExpTrans _trvExpTrans)
    {
        // By default, return reference data area ID.
        TrvLegalEntity legalEntity = _trvExpTrans.ReferenceDataAreaId;

        // If inter-company, check the general ledger tax setup.
        // It's under General Ledger Parameters >> Sales Tax >> Legal Entity for inter-company tax posting.
        if (_trvExpTrans.isIntercompany())
        {
            TaxObligationCompany legalEntityForTaxPosting = TaxParameters::find().TaxObligationCompany;
            if (legalEntityForTaxPosting == TaxObligationCompany::Destination)
            {
                legalEntity = _trvExpTrans.InterCompanyLE;
            }
        }

        return legalEntity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchangeCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the exchange currency code.
    /// </summary>
    /// <param name = "_isCreditCardTransaction">
    /// Boolean value indicating if the transaction has any payments using credit card.
    /// </param>
    /// <returns>
    /// Exchange currency code of the transaction.
    /// </returns>
    public TrvCurrencyCode getExchangeCurrencyCode(boolean _isCreditCardTransaction)
    {
        return _isCreditCardTransaction ? this.CreditCardTransactionCurrency : this.ExchangeCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBaseAmountExcludingTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and gets the base transaction amount without the tax.
    /// </summary>
    /// <param name = "_isCreditCardTransaction">
    /// Boolean value indicating if the transaction has any payments using credit card.
    /// </param>
    /// <param name = "_transactionCurrencyAmount">
    /// Amount with tax in transaction currency.
    /// </param>
    /// <returns>
    /// Base amount without tax.
    /// </returns>
    protected TaxBase getBaseAmountExcludingTax(boolean _isCreditCardTransaction, AmountCur _transactionCurrencyAmount)
    {
        TaxBase baseAmountCur;

        TaxModuleType moduleType = TrvSalesTaxCalcBasedOnPurchFeature::isEnabled() ? TaxModuleType::Purch : TaxModuleType::Sales;

        if (this.TaxIncluded)
        {
            TrvCurrencyCode exchangeCode = this.getExchangeCurrencyCode(_isCreditCardTransaction);

            try
            {
                baseAmountCur = Tax::baseAmountExclTax(this.TaxGroup, this.TaxItemGroup, this.TransDate, exchangeCode, _transactionCurrencyAmount, moduleType, 0, '', '', TaxDirection::OutgoingTax , 0,
                        false); // no rounding
            }
            catch
            {
                exchangeCode = CompanyInfoHelper::standardCurrency();
                baseAmountCur = Tax::baseAmountExclTax(this.TaxGroup, this.TaxItemGroup, this.TransDate, exchangeCode, _transactionCurrencyAmount, moduleType, 0, '', '', TaxDirection::OutgoingTax , 0,
                            false); // no rounding
            }
        }
        else
        {
            baseAmountCur = _transactionCurrencyAmount;
        }

        return baseAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the associated <c>smmActivities</c> record.
    /// </summary>
    /// <returns>The associated <c>smmActivities</c> record; otherwise, an empty record.</returns>
    public smmActivities getProjActivity()
    {
        smmActivities activity;

        if (this.ProjActivityNumber != '')
        {
            DataAreaId dataAreaId;

            if (this.InterCompanyLE != '')
            {
                dataAreaId = this.InterCompanyLE;
            }
            else
            {
                dataAreaId = this.ReferenceDataAreaId;
            }

            CompanyInfo foundDataArea = CompanyInfo::findDataArea(dataAreaId);

            if (foundDataArea)
            {
                changecompany(dataAreaId)
                {
                    activity = smmActivities::find(this.ProjActivityNumber);
                }
            }
        }

        return activity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCalculateTaxBasedOnTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the transaction has valid tax group and tax item group.
    /// </summary>
    /// <returns>
    /// true, if <c>TrvExpTrans</c> table buffer has valid tax group and tax item group; otherwise, false.
    /// </returns>
    public boolean shouldCalculateTaxBasedOnTaxGroup()
    {
        boolean ret = false;

		if (this.TaxGroup && this.TaxItemGroup && this.transactionAmount() != 0 && this.TransDate != dateNull())
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate tax amount for the expense line.
    /// </summary>
    /// <returns>
    /// Calculated Tax amount for the expense line.
    /// </returns>
    /// <remarks>
    /// The exception will not always be handled in this method if there is any exception occurs in
    /// the baseAmountExclTax method
    /// </remarks>
    display CalcTaxAmountCur calcTaxAmount()
    {
        TrvLegalEntity legalEntity = TrvExpTrans::getLegalEntityForTax(this);

        CalcTaxAmountCur taxAmountCur = 0;
       
        CompanyInfo foundDataArea = CompanyInfo::findDataArea(legalEntity);

        if (foundDataArea)
        {
            changecompany(legalEntity)
            {
                if (this.shouldCalculateTaxBasedOnTaxGroup())
                {
                    boolean                 isCreditCardTransaction = this.isCreditCardTransaction();
                    TrvCurrencyCode         exchangeCode = this.getExchangeCurrencyCode(isCreditCardTransaction);
                    AmountCur               transactionCurrencyAmount = this.getTransactionCurrencyAmount(isCreditCardTransaction);

                    if (TrvSalesTaxCalcBasedOnPurchFeature::isEnabled())
                    {
                        taxAmountCur = Tax::calcTaxAmount(this.TaxGroup, this.TaxItemGroup, this.TransDate, exchangeCode, this.getBaseAmountExcludingTax(isCreditCardTransaction, transactionCurrencyAmount), TaxModuleType::Purch);
                    }
                    else
                    {
                        taxAmountCur = Tax::calcTaxAmount(this.TaxGroup, this.TaxItemGroup, this.TransDate, exchangeCode, this.getBaseAmountExcludingTax(isCreditCardTransaction, transactionCurrencyAmount), TaxModuleType::Sales);
                    }

                    taxAmountCur = CurrencyExchange::round(taxAmountCur, exchangeCode);
                }
            }
        }
        else
        {
            throw error("@Expense:InvalidExpenseInterCompanyLE");
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryDescription</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the category description of the category on the expense line.
    /// </summary>
    /// <returns>
    ///     The category description of the category on the expense line.
    /// </returns>
    display TrvCostTxt categoryDescription()
    {
        TrvCostType trvCostType;

        select firstonly CostTxt from trvCostType where trvCostType.CostType == this.CostType;

        return trvCostType.CostTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryOrSubCategoryName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the category or the subcategory name.
    /// </summary>
    /// <returns>
    ///     The category name for default and header lines, the subcategory name for the itemized or split lines.
    /// </returns>
    display TrvCategoryOrSubCategoryName categoryOrSubCategoryName()
    {
        TrvExpSubCategory trvExpSubCategory;

        if (this.LineType == TrvExpLineType::ItemizedLine && this.SubCategoryRecId)
        {
            select firstonly trvExpSubCategory where trvExpSubCategory.RecId == this.SubCategoryRecId;
            if (trvExpSubCategory.RecId)
            {
                return trvExpSubCategory.name();
            }
        }

        return this.CostType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a budget check on the expense line.
    /// </summary>
    /// <remarks>
    /// When budget check is not triggered by explicit user action, the check is performed only when the
    /// "budget check on entry" flag is set.
    /// </remarks>
    public void checkBudget()
    {
        BudgetControlSourceDocumentProcessor::submitSourceDocumentLineToCheckBudget(
                                        SourceDocumentLine::find(this.SourceDocumentLine),
                                        true,  // is draft reservation
                                        null,  // caller
                                        false);  // is not on demand check
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBudgetOnDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs an on demand budget check on the expense line.
    /// </summary>
    public void checkBudgetOnDemand()
    {
        BudgetControlSourceDocumentProcessor::submitSourceDocumentLineToCheckBudget(
                                        SourceDocumentLine::find(this.SourceDocumentLine),
                                        true,  // is draft reservation
                                        null,  // caller
                                        true); // is on demand check
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjectBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a project budget check on the expense line.
    /// </summary>
    public void checkProjectBudget()
    {
        SourceDocumentLineItem  sourceDocumentLineItem;

        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(this.SourceDocumentLine));
        if (ProjectCommitmentFacade::isProjectBudgetControlEnabled(sourceDocumentLineItem, false))
        {
            ProjectCommitmentFacade::checkProjectBudgets(sourceDocumentLineItem, false, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjectBudgetOnDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs an on demand project budget check on the expense line.
    /// </summary>
    public void checkProjectBudgetOnDemand()
    {
        SourceDocumentLineItem  sourceDocumentLineItem;

        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(this.SourceDocumentLine));
        if (ProjectCommitmentFacade::isProjectBudgetControlEnabled(sourceDocumentLineItem, true))
        {
            ProjectCommitmentFacade::checkProjectBudgets(sourceDocumentLineItem, false, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearSDLForItemizedAndSplitHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Removes distributions, accounting event and budget for the itemized and split header expense line.
    /// </summary>
    /// <remarks>
    ///     This is needed, when a default expense line becomes an itemized header or split header.
    /// </remarks>
    private void clearSDLForItemizedAndSplitHeader()
    {
        AccountingDistribution  accountingDistribution;

        if ((this.LineType == TrvExpLineType::ItemizedHeader || this.SplitLineType == TrvExpSplitLineType::SplitHeader) && this.SourceDocumentLine)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                ProjFundingLimitTrackingManager::updateUsingSourceDocumentLine(this.SourceDocumentLine, ProjFundingLimitTrackingAction::Release);
            }

            ProjectCommitmentFacade::deleteProjectCommitments(this.SourceDocumentLine);

            // Remove budget explicitly
            BudgetControlSourceDocumentProcessor::submitSourceDocumentLineToRemoveBudget(
                                                            SourceDocumentLine::find(this.SourceDocumentLine));

            // Remove distributions explicitly
            delete_from accountingDistribution
                where accountingDistribution.SourceDocumentLine == this.SourceDocumentLine;

            TaxUncommitted::deleteForDocumentLine(tableNum(TrvExpTrans),this.RecId);

            if (this.SplitLineType == TrvExpSplitLineType::SplitHeader)
            {
                this.handleCleanupPolicyJustificationsAndViolations();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTaxFields</Name>
				<Source><![CDATA[
    private void clearTaxFields()
    {
        this.TaxGroup = '';
        this.TaxItemGroup = '';
        this.TaxIncluded = NoYes::No;
        this.CorrectedTaxAmount = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies the expense line fields to the specified buffer. Skips certain fields used by other methods
    ///     called downstream which expect empty/different values in them.
    /// </summary>
    /// <param name="_trvExpTrans">
    ///     The expense line buffer to be copied to.
    /// </param>
    void copyFields(TrvExpTrans _trvExpTrans)
    {
        _trvExpTrans.AccountingCurrencyOverBudgetAmount     = this.AccountingCurrencyOverBudgetAmount;
        _trvExpTrans.AccountingCurrencyReconciledAmount     = this.AccountingCurrencyReconciledAmount;
        _trvExpTrans.AdditionalInformation                  = this.AdditionalInformation;
        _trvExpTrans.AddressCity                            = this.AddressCity;
        _trvExpTrans.AddressState                           = this.AddressState;
        _trvExpTrans.AddressZipCode                         = this.AddressZipCode;
        _trvExpTrans.AmountCurr                             = this.AmountCurr;
        _trvExpTrans.AmountMST                              = this.AmountMST;
        _trvExpTrans.ApplyAction                            = this.ApplyAction;
        _trvExpTrans.ApprovalStatus                         = this.ApprovalStatus;
        _trvExpTrans.ApprovedDate                           = this.ApprovedDate;
        _trvExpTrans.BillIssuedTo                           = this.BillIssuedTo;
        _trvExpTrans.BusinessPurpose                        = this.BusinessPurpose;
        _trvExpTrans.City                                   = this.City;
        _trvExpTrans.CorrectedTaxAmount                     = this.TaxIncluded == NoYes::Yes ? 0 : this.CorrectedTaxAmount;
        _trvExpTrans.CorrectedTaxAmountMST                  = this.TaxIncluded == NoYes::Yes ? 0 : this.CorrectedTaxAmountMST;
        _trvExpTrans.CostOwner                              = this.CostOwner;
        _trvExpTrans.CostType                               = this.CostType;
        _trvExpTrans.CreatingWorker                         = this.CreatingWorker;
        _trvExpTrans.CountryRegion                          = this.CountryRegion;
        _trvExpTrans.CreditCardTransactionCurrency          = this.CreditCardTransactionCurrency;
        _trvExpTrans.CreditCardTransactionCurrencyAmount    = this.CreditCardTransactionCurrencyAmount;
        _trvExpTrans.DateFrom                               = this.DateFrom;
        _trvExpTrans.DateTo                                 = this.DateTo;
        _trvExpTrans.Deduktion                              = this.Deduktion;
        _trvExpTrans.DeduktionBreakfest                     = this.DeduktionBreakfest;
        _trvExpTrans.DeduktionDinner                        = this.DeduktionDinner;
        _trvExpTrans.DeduktionLunch                         = this.DeduktionLunch;
        _trvExpTrans.DefaultDimension                       = this.DefaultDimension;
        _trvExpTrans.Description                            = this.Description;
        _trvExpTrans.EntertainmentLocation                  = this.EntertainmentLocation;
        _trvExpTrans.ExchangeCode                           = this.ExchangeCode;
        _trvExpTrans.ExchangeRate                           = this.ExchangeRate;
        _trvExpTrans.ExpNumber                              = this.ExpNumber;
        _trvExpTrans.ExpTransNumber                         = this.ExpTransNumber;
        _trvExpTrans.ExpType                                = this.ExpType;
        _trvExpTrans.IntercompanyBilled                     = this.IntercompanyBilled;
        _trvExpTrans.InterCompanyCategory                   = this.InterCompanyCategory;
        _trvExpTrans.InterCompanyLE                         = this.InterCompanyLE;
        _trvExpTrans.kmOwnCar                               = this.kmOwnCar;
        _trvExpTrans.kmPrice                                = this.kmPrice;
        _trvExpTrans.IntercompanySalesCurrency              = this.IntercompanySalesCurrency;
        _trvExpTrans.IntercompanySalesPrice                 = this.IntercompanySalesPrice;
        _trvExpTrans.IntercompanyTransferCurrency           = this.IntercompanyTransferCurrency;
        _trvExpTrans.IntercompanyTransferPrice              = this.IntercompanyTransferPrice;
        _trvExpTrans.InvoiceAmt                             = this.InvoiceAmt;
        _trvExpTrans.IsBudgetCheckPending                   = this.IsBudgetCheckPending;
        _trvExpTrans.IsPreAuthorized                        = this.IsPreAuthorized;
        _trvExpTrans.IsSplit                                = this.IsSplit;
        _trvExpTrans.LegalEntity                            = this.LegalEntity;
        _trvExpTrans.LineLevelPosting                       = this.LineLevelPosting;
        _trvExpTrans.LineNumber                             = this.LineNumber;
        _trvExpTrans.LineType                               = this.LineType;
        _trvExpTrans.MappedToRequisitionLine                = this.MappedToRequisitionLine;
        _trvExpTrans.MerchantId                             = this.MerchantId;
        _trvExpTrans.MileageFromAddress                     = this.MileageFromAddress;
        _trvExpTrans.MileageToAddress                       = this.MileageToAddress;
        _trvExpTrans.Mobile_Statement                       = this.Mobile_Statement;
        _trvExpTrans.NetTransactionAmount                   = this.NetTransactionAmount;
        _trvExpTrans.NotApprovedDate                        = this.NotApprovedDate;
        _trvExpTrans.NumberOfPassengers                     = this.NumberOfPassengers;
        _trvExpTrans.OriginalReceiptsRecvd                  = this.OriginalReceiptsRecvd;
        _trvExpTrans.OriginalSourceDocumentLine             = this.OriginalSourceDocumentLine;
        _trvExpTrans.ParentRecId                            = this.ParentRecId;
        _trvExpTrans.PayMethod                              = this.PayMethod;
        _trvExpTrans.pbs_Statement                          = this.pbs_Statement;
        _trvExpTrans.pbsRecId                               = this.pbsRecId;
        _trvExpTrans.PerdiemTimezone                        = this.PerdiemTimezone;
        _trvExpTrans.PostAccount                            = this.PostAccount;
        _trvExpTrans.PostAccountType                        = this.PostAccountType;
        _trvExpTrans.POSTINGERRORS                          = this.PostingErrors;
        _trvExpTrans.ProjActivityNumber                     = this.ProjActivityNumber;
        _trvExpTrans.ProjId                                 = this.ProjId;
        _trvExpTrans.ProjPolicyStatus                       = this.ProjPolicyStatus;
        _trvExpTrans.ProjPolicyText                         = this.ProjPolicyText;
        _trvExpTrans.ProjStatusId                           = this.ProjStatusId;
        _trvExpTrans.ProjTransId                            = this.ProjTransId;
        _trvExpTrans.Reason                                 = this.Reason;
        _trvExpTrans.ReceiptNumber                          = this.ReceiptNumber;
        _trvExpTrans.ReferenceDataAreaId                    = this.ReferenceDataAreaId;
        _trvExpTrans.ReimburseAmt                           = this.ReimburseAmt;
        _trvExpTrans.SplitLineType                          = this.SplitLineType;
        _trvExpTrans.SubCategoryRecId                       = this.SubCategoryRecId;
        _trvExpTrans.TaxGroup                               = this.TaxGroup;
        _trvExpTrans.TaxIncluded                            = this.TaxIncluded;
        _trvExpTrans.TaxItemGroup                           = this.TaxItemGroup;
        _trvExpTrans.TicketClass                            = this.TicketClass;
        _trvExpTrans.TicketNumber                           = this.TicketNumber;
        _trvExpTrans.TicketUsed                             = this.TicketUsed;
        _trvExpTrans.TransactionText                        = this.TransactionText;
        _trvExpTrans.TransDate                              = this.TransDate;
        _trvExpTrans.TransRowNum                            = this.TransRowNum;
        _trvExpTrans.TrvExpTable                            = this.TrvExpTable;
        _trvExpTrans.TrvLocations                           = this.TrvLocations;
        _trvExpTrans.VehicleType                            = this.VehicleType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFieldsForItemization</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies fields needed for itemization Lines from the Header line
    /// </summary>
    /// <param name="_trvExpTrans">
    ///     The expene line buffer to be copied to.
    /// </param>
    void copyFieldsForItemization(TrvExpTrans _trvExpTrans)
    {
        _trvExpTrans.RecId                  = this.RecId;
        _trvExpTrans.CostType               = this.CostType;
        _trvExpTrans.PayMethod              = this.PayMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyValuesToChildLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies values needed for itemization Lines.
    /// </summary>
    /// <param name = "_oldTrvExpTrans">The original expense line buffer.</param>
    [Wrappable(true)]
    protected final void copyValuesToChildLines(TrvExpTrans _oldTrvExpTrans)
    {
        TrvExpTrans     itemLines;

        if ( _oldTrvExpTrans.ExchangeRate != this.ExchangeRate ||
            (_oldTrvExpTrans.ExchangeCode != this.ExchangeCode) ||
            (_oldTrvExpTrans.TaxGroup != this.TaxGroup) )
        {
            update_recordset itemLines setting ExchangeRate = this.ExchangeRate,
                    ExchangeCode = this.ExchangeCode, TaxGroup = this.TaxGroup
                    where itemLines.ParentRecId == this.RecId;
        }

        if (_oldTrvExpTrans.TaxGroup != this.TaxGroup)
        {
            update_recordset itemLines setting TaxGroup = this.TaxGroup
                where itemLines.ParentRecId == this.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemizedLinesPaymentMethod</Name>
				<Source><![CDATA[
    private void updateItemizedLinesPaymentMethod(TrvExpTrans _oldTrvExpTrans)
    {
        TrvExpTrans     itemLines;

        if (_oldTrvExpTrans.PayMethod != this.PayMethod)
        {
            update_recordset itemLines setting PayMethod = this.PayMethod
                where itemLines.ParentRecId == this.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPerGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total expense amount for the statistics group of the category on the expense line.
    /// </summary>
    /// <returns>
    /// Total expense amount for the statistics group of the category on the expense line.
    /// </returns>
    /// <remarks>This method is used by the TrvCostStatistics report.</remarks>
    public display AmountMST costPerGroup()
    {
        TrvCostType           trvCostType;

        select firstonly TrvCostTypeStatisticsId from trvCostType where trvCostType.CostType == this.CostType;

        return TrvExpenseTransHelper::costPerCostType(trvCostType.TrvCostTypeStatisticsId, this.ExpNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculate and create TaxUncommitted record for the expense line, if needed
    /// </summary>
    /// <param name="_forceRecreate">
    ///     If true, tax will be recalculated even if there is an existing TaxUncommitted record.
    ///     If false, tax will only be recalculated if there is not an existing TaxUncommitted record.
    /// </param>
    public void createTaxUncommitted(boolean _forceRecreate = false)
    {
        TrvTaxDocumentExpense   trvTaxDocumentExpense;
        TrvTaxExpense   trvTaxExpense;
        TaxAmountCur    taxAmountCur;
        TrvLegalEntity taxCompany = TrvExpTrans::getLegalEntityForTax(this);

        CompanyInfo foundDataArea = CompanyInfo::findDataArea(taxCompany);

        if (foundDataArea)
        {
            changeCompany(taxCompany)
            {
                if (this.TaxGroup && this.TaxItemGroup && this.ApprovalStatus != TrvAppStatus::Ledger && this.isDistributionsEnabled())
                {
                    if (_forceRecreate || (!TaxUncommitted::existByDocumentLineId(tableNum(TrvExpTrans),this.RecId)))
                    {
                        trvTaxDocumentExpense = TrvTaxDocumentExpense::newTrvExpTrans(this);
                        trvTaxExpense = TaxCalculation::newForSourceTypeWithTaxUncommitted(TaxSourceType::Expense, trvTaxDocumentExpense, false, false); // don't load existing taxuncommited or tax trans

                        trvTaxExpense.parmExchRate(this.ExchangeRate);

                        if (Ledger::isReportingCurrencySameAsAccountingCurrencyForLegalEntity(this.LegalEntity))
                        {
                            trvTaxExpense.parmReportingCurrencyExchRate(this.ExchangeRate);
                        }

                        taxAmountCur = trvTaxExpense.calculateTax();

                        if (taxAmountCur != this.CorrectedTaxAmount)
                        {
                            trvTaxExpense.correctTaxAmount();
                        }
                    }
                }
            }
        }
        else
        {
            throw error("@Expense:InvalidExpenseInterCompanyLE");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditCardAmountWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the amount charged on the credit card, alongwith the credit card currency code.
    /// </summary>
    /// <returns>
    /// The amount charged on the credit card, alongwith the credit card currency code.
    /// </returns>
    /// <remarks>
    /// This display method is used, when the credit card currency code is different from the accounting currency code.
    /// When the currencies are the same, this is not needed, as the amount in company currency would have the same value.
    /// </remarks>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvCreditCardAmountWithCurrencyCode creditCardAmountWithCurrencyCode()
    {
        return this.isCreditCardTransaction() ? TrvExpenseHelper::amountWithTransactionCurrencyCode(this.AmountCurr, this.ExchangeCode) : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>deductionWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays deduction along with the transaction currency code.
    /// </summary>
    /// <returns>
    /// The deduction in transaction currency, along with the transaction currency code.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvDeductionWithCurrencyCode deductionWithCurrencyCode()
    {
        return TrvExpenseHelper::amountWithTransactionCurrencyCode(this.Deduktion, this.ExchangeCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Clear up when expense line is removed.
    /// </summary>
    /// <param name="_itemizedHeaderBeingDeleted">
    ///     Indicates whether the itemized header line is going to be deleted together with the itemized line
    /// </param>
    public void delete(boolean _itemizedHeaderBeingDeleted=false)
    {
        TrvCashAdvance                      trvCashAdvance;
        TrvExpTrans                         trvExpTrans, itemHeader;
        TrvPolicyViolationsCache            trvPolicyViolationsCache;
        SourceDocumentLine                  sourceDocumentLine;
        TrvParameters                       trvParameters;
        DocuRef                             docuRef;
        boolean								splitLinesDeleted;

        // Skip delete if RecID = 0.
        if (this.RecId == 0)
        {
            return;
        }
        
        if(TrvExpenseHelper::isTrvExpTransValidateDeleteFlightEnabled())
        {
            if(!this.canExpenseLineBeDeletedWithApprovalStatus() && !this.validatedelete(true))
            {
                return;
            }
        }

        // TrvParamters record is needed only when itemized header is not being deleted.
        if (!_itemizedHeaderBeingDeleted)
        {
            trvParameters = TrvParameters::find();
        }

        ttsbegin;

        // Detach receipts attached to expense before deletion.
        while select RecId from docuRef where docuRef.RefTableId == tablenum(TrvExpTrans) && docuRef.RefRecId == this.RecId
        {
            TrvReceiptsHelper::detachDocument(docuRef.RecId, true);
            // Delete document records from split/itemized line once the line is deleted.
            if (this.LineType == TrvExpLineType::ItemizedLine || this.SplitLineType == TrvExpSplitLineType::SplitLine) 
            {
                TrvReceiptsHelper::detachDocument(docuRef.RecId, true);
            }
        }

        if (this.LineType != TrvExpLineType::ItemizedLine && this.SplitLineType != TrvExpSplitLineType::SplitLine)
        {
            // Delete any guests added for the expense line.
            if (this.hasGuests())
            {
                TrvGuestHelper::deleteGuestsforExpenseLine(this.RecId);
            }

            // Delete any unreconciled mobile transaction records
            if (TrvUnreconciledExpenseTransaction::existUnreconciledUsedByExpenseLine(this.RecId))
            {
                TrvUnreconciledExpenseTransaction::deleteUnreconciledByExpenseLine(this.RecId);
            }

            if (this.CashAdvanceRecId)
            {
                select firstonly forupdate trvCashAdvance where trvCashAdvance.RecId == this.CashAdvanceRecId;

                if (trvCashAdvance.RecId)
                {
                    trvCashAdvance.Balance += trvCashAdvance.BalanceReturned;
                    trvCashAdvance.BalanceReturned = 0;
                    trvCashAdvance.doUpdate();
                }
            }
        }

        if (this.LineType == TrvExpLineType::ItemizedHeader || this.SplitLineType == TrvExpSplitLineType::SplitHeader)
        {
            // Check for the RecId and make sure it is not 0. Delete using a value of RecID = 0 causes all records into system to be deleted.
            if (this.RecId != 0)
            {
                while select forupdate trvExpTrans where trvExpTrans.ParentRecId == this.RecId
                {
                    trvExpTrans.delete(true);
                }
            }
        }
        else if ((this.LineType == TrvExpLineType::ItemizedLine
                    && !_itemizedHeaderBeingDeleted
                    && !TrvCostType::find(this.CostType).IsItemizationMandatory)
                || (this.SplitLineType == TrvExpSplitLineType::SplitLine
                    && !_itemizedHeaderBeingDeleted))
        {
            itemHeader = TrvExpTrans::find(this.ParentRecId, true);
            if (!itemHeader)
            {
                throw error(strFmt("@Expense:ParentTransactionMissing", this.RecId));
            }

            if (this.ExpType != TrvExpType::Personal && this.isTaxApplicable())
            {
                itemHeader.TaxGroup = this.TaxGroup;
                itemHeader.TaxItemGroup = this.TaxItemGroup;
                itemHeader.TaxIncluded = this.TaxIncluded;
            }

            if (itemHeader.AmountCurr != 0
                && itemHeader.TaxGroup != ''
                && itemHeader.TaxItemGroup != '' 
                && this.isTaxApplicable())
            {
                itemHeader.updateNetTransactionAmount();
                itemHeader.setCorrectedTaxAmountMST();
            }

            // Change LineType of itemized header to default, if no more itemized line
            select count(RecVersion) from trvExpTrans where trvExpTrans.ParentRecId == this.ParentRecId
                                                         && trvExpTrans.RecId       != this.RecId;

            if (trvExpTrans.RecVersion == 0)
            {   
                // when itemization is not required, return last remaining record
                // line type to default so it can be submitted without itemization
                if (!TrvCostType::find(itemHeader.CostType).IsItemizationMandatory)
                {
                    itemHeader.LineType = TrvExpLineType::Default;
                    // if correction flight is enabled 
                    // update the cash advance mapping against the itemHeader
                    // on deleting last itemized line
                    if(
                        TrvExpenseHelper::isTrvCashAdvanceForItemizedLineCorrectionFlightEnabled()
                        && TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled()
                        && (itemHeader.ExpType != TrvExpType::Advance)
                        && (itemHeader.CostOwner == TrvCostOwner::Employee || TrvPayMethod::getCostOwner(itemHeader.PayMethod) == TrvCostOwner::Employee))
                    {
                        itemHeader.updateExpCashAdvanceMap(false);
                    } 
                }
                
                // itemized line when itemized header is pending,
                // can only happen when the itemized line was canceled in line item workflow
                // since we are updating the line type of the itemized header,
                // we need to update it's status as well
                if (itemHeader.ApprovalStatus == TrvAppStatus::Pending)
                {
                    itemHeader.ApprovalStatus = TrvAppStatus::Create;
                }

                if (this.LineType == TrvExpLineType::ItemizedLine)
                {
                    itemHeader.IsSplit = NoYes::No;
                }

                if (this.SplitLineType == TrvExpSplitLineType::SplitLine)
                {
                    itemHeader.SplitLineType = TrvExpSplitLineType::NoSplit;
                    splitLinesDeleted = true;
                }

                if (splitLinesDeleted)
                {
                    itemHeader.executePolicyEvaluation();
                }

                //Reset accounting distribution for header.
                itemHeader.reinitializeSourceDocumentLine();
            }

            itemHeader.doUpdate();

            if (itemHeader.TrvExpTable != 0)
            {
                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(itemHeader, true);
                itemHeader.createTaxUncommitted(true);
            }

        }

        TaxUncommitted::deleteForDocumentHeader(this.TableId, this.RecId, true);

        delete_from trvPolicyViolationsCache
                where trvPolicyViolationsCache.Line == this.RecId && trvPolicyViolationsCache.PolicyType == SysPolicyTypeEnum::TrvExpensePolicy;

        if (this.ProjId && ProjParameters::find().TrackCommittedCostExpenseManagement)
        {
            ProjectCommitmentFacade::deleteProjectCommitments(this.SourceDocumentLine);
        }
		
		if (CompanyInfoExtension::existsDataArea(this.ReferenceDataAreaId))
		{
			this.deletePerDiemData(this.ReferenceDataAreaId);
			this.deleteSplitRecords(this.ReferenceDataAreaId);
			this.deleteMatchRecords(this.ReferenceDataAreaId);
		}
		
		this.deleteGSTRecords_MY();

        super();


		// If the itemized header is being deleted, skip evaluating policies for each itemized line being deleted.
        // Policy evaluation will happen once after all the itemized lines are deleted.
        if (!_itemizedHeaderBeingDeleted && trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave && this.TrvExpTable != 0)
        {
            TrvPolicyEvalEngine::evaluateViolationsForHdr(this.TrvExpTable, SysPolicyTypeEnum::TrvExpensePolicy);
            if (this.LineType != TrvExpLineType::ItemizedLine)
            {
                TrvExpTable::findRecId(this.TrvExpTable).validateProjPolicies(false);
            }
        }

        if (this.MappedToRequisitionLine)
        {
            TrvRequisitionTable::updateReconciliationStatus(this.requisitionTable());
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canMatchExpenses</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determine whether the passed in expenses can be matched.
    /// </summary>
    /// <param name="_ccExpense">
    ///     The expense to be hidden.
    /// </param>
    /// <param name="_manualExpense">
    ///     The  expense that was already processed.
    /// </param>
    /// <returns>
    ///     True if matching is allowed; otherwise, false.
    /// </returns>
    public static boolean canMatchExpenses(TrvExpTrans _ccExpense, TrvExpTrans _manualExpense)
    {
        if (!_ccExpense.isCreditCardTransaction()
            || _manualExpense.isCreditCardTransaction())
        {
            return checkFailed("@Expense:MatchFailedMismatchCCAndManual");
        }

        if ((_ccExpense.ApprovalStatus != TrvAppStatus::Create
            && _ccExpense.ApprovalStatus != TrvAppStatus::Matched)
            || _manualExpense.ApprovalStatus == TrvAppStatus::Create)
        {
            return checkFailed("@Expense:MatchFailedIncorrectApprovalStatus");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canMergeExpenses</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determine whether the passed in expenses can be merged together.
    /// </summary>
    /// <param name="_selectedExpense">
    ///     The expense to copy the details to.
    /// </param>
    /// <param name="_manualExpense">
    ///     The  expense to copy the details from.
    /// </param>
    /// <returns>
    ///     True if merge is allowed; otherwise, false.
    /// </returns>
    public static boolean canMergeExpenses(TrvExpTrans _selectedExpense, TrvExpTrans _manualExpense)
    {
        if (_manualExpense.isCreditCardTransaction())
        {
            return checkFailed("@Expense:MergeFailedCannotMergeTwoCreditCardExpenses");
        }

        if (_selectedExpense.ApprovalStatus != TrvAppStatus::Create
            || _manualExpense.ApprovalStatus != TrvAppStatus::Create)
        {
            return checkFailed("@Expense:MergeFailedIncorrectApprovalStatus");
        }

        if (_selectedExpense.isCreditCardTransaction() &&
            !TrvUnreconciledExpenseHelper::isSupportedCategory(_manualExpense.ExpType, true))
        {
            return checkFailed("@Expense:InvalidCategoryForCreditCard");
        }

        if (_selectedExpense.ExchangeCode != _manualExpense.ExchangeCode)
        {
            return checkFailed("@Expense:MergeFailedMismatchedExchangeCode");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchExpense</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>TrvMatchedExpenseLines</c> record to associate two expense records
    /// and updates the status of the expense to be hidden to Matched.
    /// </summary>
    /// <param name="_matchedExpense">
    /// The expense that is to be associated with the hidden expense.
    /// </param>
    public void matchExpense(TrvExpTrans _matchedExpense)
    {
        if (!TrvExpTrans::canMatchExpenses(this, _matchedExpense))
        {
            return;
        }

        ttsbegin;

        this.selectForUpdate(true);

        TrvMatchedExpenseLines::createMatchedLines(this, _matchedExpense);

        if (this.ExpNumber != '')
        {
            this.updateExpenseReport('', false);
        }

        if (this.ApprovalStatus != TrvAppStatus::Matched)
        {
            this.ApprovalStatus = TrvAppStatus::Matched;
            this.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmatchExpense</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the<c>TrvMatchedExpenseLines</c> records associated with an expense that has been hidden
    /// and updates the status of the expense back to Draft.
    /// </summary>
    /// <remarks>
    /// This method should only be called for expenses with the approval status of Matched.
    /// </remarks>
    public void unmatchExpense()
    {
        ttsbegin;

        this.selectForUpdate(true);

        TrvMatchedExpenseLines::deleteMatchedLines(this);

        // Update status back to draft after matched line associations are deleted.
        if (this.ApprovalStatus == TrvAppStatus::Matched)
        {
            this.ApprovalStatus = TrvAppStatus::Create;
            this.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeExpenseLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copy the details from the second expense record into the first expense record
    ///     when that field is not currently filled on the first expense and delete the second expense,
    ///     essentially merging the two records.
    /// </summary>
    /// <param name="_selectedExpenseRecId">
    ///     The <c>RefRecId</c> of the expense to copy the details to.
    /// </param>
    /// <param name="_manualExpenseRecId">
    ///     The <c>RefRecId</c> of the expense to copy the details from.  Will be deleted.
    /// </param>
    /// <returns>
    ///     True if the merge succeeds; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method cannot be used to merge a credit card expense with another credit card expense
    /// </remarks>
    public static boolean mergeExpenseLines(RefRecId _selectedExpenseRecId, RefRecId _manualExpenseRecId)
    {
        //
        // Additional notes regarding which fields were not copied
        //
        // Cost types of allowance, transport, and cash advance are not allowed, so the following fields are not copied over:
        // DateFrom, DateTo, Deduktion, DeduktionBreakfast, DeduktionDinner, DeduktionLunch, Location
        // KMOwnCar, KMPrice, MileageFromAddress, MileageToAddress, NumberOfPassengers, VehicleType
        // MappedToRequisitionLine, CashAdvanceRecId
        //
        // The following fields always take their value from the selected expense:
        // Transaction date, transaction amount, payment method, currency
        // PBSRecId, PBS_Statement, CreatingWorker
        //
        // Various amount and currency code fields are either not editable on CC transactions
        // or they are computed fields.
        //
        // Manual lines do not have personal amount fields, are not personal or itemized children:
        // IsSplit, ParentRecId, SubCategoryRecId
        //
        // All lines are unsubmitted, so fields related to posting are excluded:
        // OriginalReceiptsRecvd, ApprovalStatus, ApprovedDate, PostingErrors, NotApprovedDate,
        // Voucher, LineLevelPosting, PostAccount, PostAccountType
        //
        // Budget and policy will be re-evaluated upon saving record:
        // IsBudgetCheckPending, ProjPolicyStatus, ProjPolicyText
        //
        
        // Make sure every field is selected
        TrvExpTrans selectedExpense = TrvExpTrans::find(_selectedExpenseRecId, true);
        TrvExpTrans manualExpense = TrvExpTrans::find(_manualExpenseRecId, true);

        boolean mergeSucceeded = true;

        try
        {
            if (!TrvExpTrans::canMergeExpenses(selectedExpense, manualExpense))
            {
                return false;
            }

            ttsbegin;

            // Handle cost type
            boolean costTypeChanged;
            if (selectedExpense.CostType != manualExpense.CostType)
            {
                if (!selectedExpense.updateCostType(TrvCostType::find(manualExpense.CostType)))
                {
                    ttsabort;
                    return checkFailed("@Expense:MergeFailedCannotUpdateCategory");
                }
                selectedExpense.reread();
                costTypeChanged = true;
            }

            // Handle expense report number
            if (selectedExpense.ExpNumber == '' && manualExpense.ExpNumber != '')
            {
                selectedExpense.updateExpenseReport(manualExpense.ExpNumber);
                selectedExpense.reread();
            }

            // Handle expense line type based on itemization required by category
            selectedExpense.handleItemizableCategory();

            // Retrieve category description in cases where category changed in case user manually changed category description
            if (costTypeChanged)
            {
                selectedExpense.Description = manualExpense.Description;
            }

            // General fields
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, MerchantId));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, ReceiptNumber));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, BusinessPurpose));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, EntertainmentLocation));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, AdditionalInformation));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, Reason));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, TransactionText));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, TicketNumber));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, TicketUsed));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, TicketClass));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, CountryRegion));
            TrvCopyUtility::copyOverStrValueIfNotProvided(selectedExpense, manualExpense, fieldNum(TrvExpTrans, AddressState));

            // Logistics fields set by edit methods
            if (selectedExpense.editCity() == '' && manualExpense.editCity() != '')
            {
                selectedExpense.editCity(true, manualExpense.editCity());
            }
            if (selectedExpense.editZipCode() == '' && manualExpense.editZipCode() != '')
            {
                selectedExpense.editZipCode(true, manualExpense.editZipCode());
            }

            TrvExpTrans::copyOverTaxInformation(selectedExpense, manualExpense);
            TrvExpTrans::copyOverProjectInformation(selectedExpense, manualExpense);

            // Merge the default dimensions
            selectedExpense.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(selectedExpense.DefaultDimension, manualExpense.DefaultDimension);
            
            if(!TrvExpenseHelper::isTrvExpTransMergeExpenseWithTaxFlightEnabled())
            {
                // Reset the distributions
                selectedExpense.reinitializeSourceDocumentLine();
            }
               
            selectedExpense.update();
            
            TrvExpTrans::copyOverEnhancedData(selectedExpense, manualExpense);
            TrvReceiptsHelper::copyOverReceipts(selectedExpense, manualExpense);
            TrvGuestHelper::copyOverGuests(selectedExpense, manualExpense);
            TrvExpTrans::copyOverItemizations(selectedExpense, manualExpense);
            TrvJustificationHelper::copyOverJustifications(selectedExpense, manualExpense);

            ttscommit;
        }
        catch
        {
            mergeSucceeded = false;
        }

        // Delete the manual line after all data has been copied over
        if (mergeSucceeded)
        {
            ttsbegin;
            manualExpense = TrvExpTrans::find(_manualExpenseRecId, true);
            manualExpense.delete();
            ttscommit;
        }

        // evaluate policies
        if (TrvParameters::find().WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
        {
            selectedExpense.executePolicyEvaluation();
        }

        return mergeSucceeded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyOverTaxInformation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copy the tax information from the second expense record into the first expense record
    ///     when that field is not currently filled on the first expense.
    /// </summary>
    /// <param name="_destinationExpense">
    ///     The expense to copy the tax details to.
    /// </param>
    /// <param name="_sourceExpense">
    ///     The expense to copy the tax information from.
    /// </param>
    public static void copyOverTaxInformation(TrvExpTrans _destinationExpense, TrvExpTrans _sourceExpense)
    {
        boolean taxInformationChanged;

        if (_destinationExpense.BillIssuedTo == TrvBillIssuedTo::Company
            && _sourceExpense.BillIssuedTo != TrvBillIssuedTo::Company)
        {
            // Company is default value, so had to be manually set to employee on one of the lines
            _destinationExpense.BillIssuedTo = _sourceExpense.BillIssuedTo;
            taxInformationChanged = true;
        }

        taxInformationChanged = TrvCopyUtility::copyOverStrValueIfNotProvided(_destinationExpense, _sourceExpense, fieldNum(TrvExpTrans, TaxGroup))     || taxInformationChanged;
        taxInformationChanged = TrvCopyUtility::copyOverStrValueIfNotProvided(_destinationExpense, _sourceExpense, fieldNum(TrvExpTrans, TaxItemGroup)) || taxInformationChanged;

        if (!_destinationExpense.TaxIncluded && _sourceExpense.TaxIncluded)
        {
            _destinationExpense.TaxIncluded =  _sourceExpense.TaxIncluded;
            taxInformationChanged = true;
        }

        if (taxInformationChanged)
        {
            _destinationExpense.updateNetTransactionAmount();
            _destinationExpense.setCorrectedTaxAmountMST();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyOverProjectInformation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copy the project information from the second expense record into the first expense record
    ///     when that field is not currently filled on the first expense.
    /// </summary>
    /// <param name="_destinationExpense">
    ///     The expense to copy the project information to.
    /// </param>
    /// <param name="_sourceExpense">
    ///     The expense to copy the project information from.
    /// </param>
    public static void copyOverProjectInformation(TrvExpTrans _destinationExpense, TrvExpTrans _sourceExpense)
    {
        if (_destinationExpense.ProjId == '' && _sourceExpense.ProjId != '' && _sourceExpense.isCategoryIntegratedWithProject()
            && !(_destinationExpense.ExpType == TrvExpType::Personal && !_destinationExpense.isCategoryIntegratedWithProject()))
        {
            _destinationExpense.InterCompanyLE = _sourceExpense.InterCompanyLE;
            _destinationExpense.InterCompanyCategory = _sourceExpense.InterCompanyCategory;
            _destinationExpense.ProjId = _sourceExpense.ProjId;
            _destinationExpense.ProjStatusId = _sourceExpense.ProjStatusId;
            _destinationExpense.ProjActivityNumber = _sourceExpense.ProjActivityNumber;
            _destinationExpense.ProjTransId = _sourceExpense.ProjTransId;
            _destinationExpense.DefaultDimension = _sourceExpense.DefaultDimension;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyOverEnhancedData</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copy the enhanced from the second expense record into the first expense record
    ///     when that field is not currently filled on the first expense.
    /// </summary>
    /// <param name="_destinationExpense">
    ///     The expense to copy the enhanced data to.
    /// </param>
    /// <param name="_sourceExpense">
    ///     The expense to copy the enhanced data from.
    /// </param>
    public static void copyOverEnhancedData(TrvExpTrans _destinationExpense, TrvExpTrans _sourceExpense)
    {
        TrvExpTrans::copyOverEnhancedData_CarRental(_destinationExpense, _sourceExpense);
        TrvExpTrans::copyOverEnhancedData_Hotel(_destinationExpense, _sourceExpense);
        TrvExpTrans::copyOverEnhancedData_Airline(_destinationExpense, _sourceExpense);
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyOverEnhancedData_CarRental</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copy the enhanced for car rental data from the second expense record into the first expense record
    ///     when that field is not currently filled on the first expense.
    /// </summary>
    /// <param name="_destinationExpense">
    ///     The expense to copy the enhanced data to.
    /// </param>
    /// <param name="_sourceExpense">
    ///     The expense to copy the enhanced data from.
    /// </param>
    public static void copyOverEnhancedData_CarRental(TrvExpTrans _destinationExpense, TrvExpTrans _sourceExpense)
    {
        if (_destinationExpense.ExpType == TrvExpType::CarRental)
        {
            TrvEnhancedCarRentalData trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual;

            select firstonly * from trvEnhancedCarRentalData_manual where trvEnhancedCarRentalData_manual.TransactionRecord == _sourceExpense.RecId;

            if (trvEnhancedCarRentalData_manual.RecId)
            {
                select firstonly forupdate * from trvEnhancedCarRentalData_cc where trvEnhancedCarRentalData_cc.TransactionRecord == _destinationExpense.RecId;

                trvEnhancedCarRentalData_cc.TransactionRecord = _destinationExpense.RecId;

                TrvCopyUtility::copyOverDateValueIfNotMin(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, CarRentalCheckOutDate));
                TrvCopyUtility::copyOverDateValueIfNotMin(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, ReturnDate));

                TrvCopyUtility::copyOverStrValueIfNotProvided(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, CheckOutLocation));
                TrvCopyUtility::copyOverStrValueIfNotProvided(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, RegularMileageCharges));
                TrvCopyUtility::copyOverStrValueIfNotProvided(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, RenterName));
                TrvCopyUtility::copyOverStrValueIfNotProvided(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, ReservationNumber));
                TrvCopyUtility::copyOverStrValueIfNotProvided(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, ReturnLocation));

                TrvCopyUtility::copyOverNumericValueIfNotZero(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, DaysRented));
                TrvCopyUtility::copyOverNumericValueIfNotZero(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, DailyRentalRate));
                TrvCopyUtility::copyOverNumericValueIfNotZero(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, WeeklyRentalRate));
                TrvCopyUtility::copyOverNumericValueIfNotZero(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, TotalMiles));
                TrvCopyUtility::copyOverNumericValueIfNotZero(trvEnhancedCarRentalData_cc, trvEnhancedCarRentalData_manual, fieldNum(TrvEnhancedCarRentalData, MonthlyRentalRate));

                if (trvEnhancedCarRentalData_cc.VehicleClass == TrvCarRentalVehicleClassEnum::Compact
                    && trvEnhancedCarRentalData_manual.VehicleClass != TrvCarRentalVehicleClassEnum::Compact)
                {
                    trvEnhancedCarRentalData_cc.VehicleClass = trvEnhancedCarRentalData_manual.VehicleClass;
                }

                if (trvEnhancedCarRentalData_cc.RecId)
                {
                    trvEnhancedCarRentalData_cc.update();
                }
                else
                {
                    trvEnhancedCarRentalData_cc.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyOverEnhancedData_Hotel</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copy the enhanced for hotel data from the second expense record into the first expense record
    ///     when that field is not currently filled on the first expense.
    /// </summary>
    /// <param name="_destinationExpense">
    ///     The expense to copy the enhanced data to.
    /// </param>
    /// <param name="_sourceExpense">
    ///     The expense to copy the enhanced data from.
    /// </param>
    public static void copyOverEnhancedData_Hotel(TrvExpTrans _destinationExpense, TrvExpTrans _sourceExpense)
    {
        if (_destinationExpense.ExpType == TrvExpType::Hotel)
        {
            TrvEnhancedHotelData TrvEnhancedHotelData_cc, TrvEnhancedHotelData_manual;

            select firstonly * from TrvEnhancedHotelData_manual where TrvEnhancedHotelData_manual.TransactionRecord == _sourceExpense.RecId;

            if (TrvEnhancedHotelData_manual.RecId)
            {
                select firstonly forupdate * from TrvEnhancedHotelData_cc where TrvEnhancedHotelData_cc.TransactionRecord == _destinationExpense.RecId;

                TrvEnhancedHotelData_cc.TransactionRecord = _destinationExpense.RecId;

                TrvCopyUtility::copyOverDateValueIfNotMin(TrvEnhancedHotelData_cc, TrvEnhancedHotelData_manual, fieldNum(TrvEnhancedHotelData, CheckInDate));
                TrvCopyUtility::copyOverDateValueIfNotMin(TrvEnhancedHotelData_cc, TrvEnhancedHotelData_manual, fieldNum(TrvEnhancedHotelData, CheckOutDate));

                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedHotelData_cc, TrvEnhancedHotelData_manual, fieldNum(TrvEnhancedHotelData, GuestName));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedHotelData_cc, TrvEnhancedHotelData_manual, fieldNum(TrvEnhancedHotelData, FolioNumber));

                TrvCopyUtility::copyOverNumericValueIfNotZero(TrvEnhancedHotelData_cc, TrvEnhancedHotelData_manual, fieldNum(TrvEnhancedHotelData, TotalRoomNights));
                TrvCopyUtility::copyOverNumericValueIfNotZero(TrvEnhancedHotelData_cc, TrvEnhancedHotelData_manual, fieldNum(TrvEnhancedHotelData, TotalRoomRent));
                TrvCopyUtility::copyOverNumericValueIfNotZero(TrvEnhancedHotelData_cc, TrvEnhancedHotelData_manual, fieldNum(TrvEnhancedHotelData, TotalTaxAmount));
                TrvCopyUtility::copyOverNumericValueIfNotZero(TrvEnhancedHotelData_cc, TrvEnhancedHotelData_manual, fieldNum(TrvEnhancedHotelData, GuestNumber));

                if (!TrvEnhancedHotelData_cc.NoShowIndicator && TrvEnhancedHotelData_manual.NoShowIndicator)
                {
                    TrvEnhancedHotelData_cc.NoShowIndicator = TrvEnhancedHotelData_manual.NoShowIndicator;
                }

                if (TrvEnhancedHotelData_cc.RecId)
                {
                    TrvEnhancedHotelData_cc.update();
                }
                else
                {
                    TrvEnhancedHotelData_cc.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyOverEnhancedData_Airline</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copy the enhanced for airline data from the second expense record into the first expense record
    ///     when that field is not currently filled on the first expense.
    /// </summary>
    /// <param name="_destinationExpense">
    ///     The expense to copy the enhanced data to.
    /// </param>
    /// <param name="_sourceExpense">
    ///     The expense to copy the enhanced data from.
    /// </param>
    public static void copyOverEnhancedData_Airline(TrvExpTrans _destinationExpense, TrvExpTrans _sourceExpense)
    {
        if (_destinationExpense.ExpType == TrvExpType::Airline)
        {
            TrvEnhancedItineraryData TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual;

            select firstonly * from TrvEnhancedItineraryData_manual where TrvEnhancedItineraryData_manual.TransactionRecord == _sourceExpense.RecId;

            if (TrvEnhancedItineraryData_manual.RecId)
            {
                select firstonly forupdate * from TrvEnhancedItineraryData_cc where TrvEnhancedItineraryData_cc.TransactionRecord == _destinationExpense.RecId;

                TrvEnhancedItineraryData_cc.TransactionRecord = _destinationExpense.RecId;

                TrvCopyUtility::copyOverDateValueIfNotMin(TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual, fieldNum(TrvEnhancedItineraryData, DepartureDate));
                TrvCopyUtility::copyOverDateValueIfNotMin(TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual, fieldNum(TrvEnhancedItineraryData, TicketIssueDate));

                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual, fieldNum(TrvEnhancedItineraryData, ExchangeTicketNumber));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual, fieldNum(TrvEnhancedItineraryData, IssuingCarrier));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual, fieldNum(TrvEnhancedItineraryData, OriginalTicketNumber));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual, fieldNum(TrvEnhancedItineraryData, PassengerName));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual, fieldNum(TrvEnhancedItineraryData, TravelAgencyCode));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual, fieldNum(TrvEnhancedItineraryData, TravelAgencyInvoiceNumber));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual, fieldNum(TrvEnhancedItineraryData, TravelAgencyName));

                TrvCopyUtility::copyOverNumericValueIfNotZero(TrvEnhancedItineraryData_cc, TrvEnhancedItineraryData_manual, fieldNum(TrvEnhancedItineraryData, NumberOfLegs));

                if (!TrvEnhancedItineraryData_cc.DomesticIndicator && TrvEnhancedItineraryData_manual.DomesticIndicator)
                {
                    TrvEnhancedItineraryData_cc.DomesticIndicator = TrvEnhancedItineraryData_manual.DomesticIndicator;
                }

                if (TrvEnhancedItineraryData_cc.RecId)
                {
                    TrvEnhancedItineraryData_cc.update();
                }
                else
                {
                    TrvEnhancedItineraryData_cc.insert();
                }
            }

            TrvEnhancedTripLegDetail TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual;

            select firstonly * from TrvEnhancedTripLegDetail_manual where TrvEnhancedTripLegDetail_manual.ItineraryRecId == TrvEnhancedItineraryData_manual.RecId;

            if (TrvEnhancedTripLegDetail_manual.RecId)
            {
                select firstonly forupdate * from TrvEnhancedTripLegDatail_cc where TrvEnhancedTripLegDatail_cc.ItineraryRecId == TrvEnhancedItineraryData_cc.RecId;

                TrvEnhancedTripLegDatail_cc.ItineraryRecId = TrvEnhancedItineraryData_cc.RecId;

                TrvCopyUtility::copyOverDateValueIfNotMin(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, ArrivalDate));
                TrvCopyUtility::copyOverDateValueIfNotMin(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, TravelDate));

                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, CarrierCode));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, CityOfOrigin));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, DestinationCity));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, FlightNumber));
                TrvCopyUtility::copyOverStrValueIfNotProvided(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, StopOverCity));
                
                TrvCopyUtility::copyOverNumericValueIfNotZero(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, TripLegNumber));
                TrvCopyUtility::copyOverNumericValueIfNotZero(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, DepartureTax));
                TrvCopyUtility::copyOverNumericValueIfNotZero(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, FareAmount));
                TrvCopyUtility::copyOverNumericValueIfNotZero(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, FeeAmount));
                TrvCopyUtility::copyOverNumericValueIfNotZero(TrvEnhancedTripLegDatail_cc, TrvEnhancedTripLegDetail_manual, fieldNum(TrvEnhancedTripLegDetail, TaxAmount));

                if (TrvEnhancedTripLegDatail_cc.ServiceClass == TrvAirlineServiceClassEnum::EconomyClass &&
                    TrvEnhancedTripLegDetail_manual.ServiceClass != TrvAirlineServiceClassEnum::EconomyClass)
                {
                    TrvEnhancedTripLegDatail_cc.ServiceClass = TrvEnhancedTripLegDetail_manual.ServiceClass;
                }

                if (TrvEnhancedTripLegDatail_cc.RecId)
                {
                    TrvEnhancedTripLegDatail_cc.update();
                }
                else
                {
                    TrvEnhancedTripLegDatail_cc.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyOverItemizations</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copy the itemizations from the second expense record into the first expense record
    ///     when itemizations are not currently filled on the first expense.
    /// </summary>
    /// <param name="_destinationExpense">
    ///     The expense to copy the itemizations to.
    /// </param>
    /// <param name="_sourceExpense">
    ///     The expense to copy the itemizations from.
    /// </param>
    public static void copyOverItemizations(TrvExpTrans _destinationExpense, TrvExpTrans _sourceExpense)
    {
        TrvExpItemizationStatus ccExpenseItemizationState =  _destinationExpense.itemizationStatus();
        TrvExpItemizationStatus manualExpenseItemizationState = _sourceExpense.itemizationStatus();

        if ((ccExpenseItemizationState == TrvExpItemizationStatus::NoItemizedLines)
                && (manualExpenseItemizationState == TrvExpItemizationStatus::Incomplete
                    || manualExpenseItemizationState == TrvExpItemizationStatus::Completed))
        {
            trvExpTrans childRecord;
            LineNumber tempLineNumber = _destinationExpense.LineNumber;

            while select forupdate * from childRecord
				where childRecord.ParentRecId == _sourceExpense.RecId
            {
                childRecord.ParentRecId = _destinationExpense.RecId;

                tempLineNumber = tempLineNumber + 0.000001;
                childRecord.LineNumber = tempLineNumber;

                // reset the distributions
                childRecord.reinitializeSourceDocumentLine();

                childRecord.update(false);
            }

            _destinationExpense.LineType = TrvExpLineType::ItemizedHeader;
            _destinationExpense.update(false);

            _sourceExpense.LineType = TrvExpLineType::Default;
            _sourceExpense.update(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>duplicateExpenseLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Duplicates the current expense line
    /// </summary>
    /// <returns>
    ///     Recid of the duplicated expense line
    /// </returns>
    public RefRecId duplicateExpenseLine(RefRecId _trvExpTableRecId = 0, TrvDateStd _transactionDate = this.TransDate)
    {
        #timeConstants

        TrvExpTrans trvExpTransNew;

        // Make sure every field is selected
        TrvExpTrans trvExpTransOrig = TrvExpTrans::find(this.RecId);

        if (!trvExpTransOrig.isAllowedToDuplicate())
        {
            return trvExpTransNew.RecId;
        }

        ttsbegin;

        // copy expense line
        trvExpTransNew.data(trvExpTransOrig);

        if (_trvExpTableRecId)
        {
            // Move new line to the provided expense report (e.g. duplicating an entire expense report)
            TrvExpTable expensereport = TrvExpTable::findRecId(_trvExpTableRecId);
            trvExpTransNew.ExpNumber = expensereport.ExpNumber;
            trvExpTransNew.TrvExpTable = expensereport.RecId;
        }
        else if (trvExpTransNew.TrvExpTable != 0)
        {
            // Copying line from expense report that has already been submitted.  Create new unattached line.
            TrvExpTable expensereport = TrvExpTable::findRecId(trvExpTransNew.TrvExpTable);
            if (!expensereport.isEditable())
            {
                trvExpTransNew.ExpNumber = "";
                trvExpTransNew.TrvExpTable = 0;
                info("@Expense:WarningExpenseToBeCopiedOnSubmittedReport");
            }
        }

        trvExpTransNew.ExpTransNumber = '';
        trvExpTransNew.ApprovalStatus = TrvAppStatus::Create;
        trvExpTransNew.ApprovedDate = DateTimeUtil::date(DateTimeUtil::minValue());
        trvExpTransNew.IsPreAuthorized = NoYes::No;
        trvExpTransNew.AccountingCurrencyReconciledAmount = 0;
        trvExpTransNew.MappedToRequisitionLine = 0;
        trvExpTransNew.Voucher = '';
        trvExpTransNew.handleItemizableCategory();
        trvExpTransNew.RecId = 0;
        trvExpTransNew.SourceDocumentLine = 0;
        trvExpTransNew.ReceiptsAttached = false;
        trvExpTransNew.ReceiptNumber = '';
        trvExpTransNew.LineType = TrvExpLineType::Default;
        trvExpTransNew.TransDate = _transactionDate;
        trvExpTransNew.PostAccountType = LedgerJournalACType::Ledger;
        trvExpTransNew.PostAccount = '';
        trvExpTransNew.ProjTransID = '';
        trvExpTransNew.PBSRecid = 0;
        trvExpTransNew.IntercompanyBilled = NoYes::No;
        trvExpTransNew.InterCompanyCategory = '';
        trvExpTransNew.IntercompanySalesCurrency = '';
        trvExpTransNew.IntercompanySalesPrice = 0;
        trvExpTransNew.IntercompanyTransferCurrency = '';
        trvExpTransNew.IntercompanyTransferPrice = 0;
        trvExpTransNew.InvoiceAmt = 0;

        //If the duplicate expense is of type Per diem, flush dateFrom and dateTo
        if(trvExpTransNew.ExpType == TrvExpType::Allowance)
        {
            trvExpTransNew.DateFrom = dateNull();
            trvExpTransNew.DateTo = dateNull();
        }

        // Reset exchange rate if transaction date on record has changed
        if (trvExpTransOrig.TransDate != _transactionDate)
        {
            trvExpTransNew.modifiedFieldExchCode(true);
        }

        trvExpTransNew.insert();

        // copy level 3 data
        boolean anyLevel3Data = false;

        if (trvExpTransOrig.ExpType == TrvExpType::CarRental)
        {
            TrvEnhancedCarRentalData trvEnhancedCarRentalData, trvEnhancedCarRentalDataOrig;

            select firstonly * from trvEnhancedCarRentalDataOrig where trvEnhancedCarRentalDataOrig.TransactionRecord == trvExpTransOrig.RecId;
            if (trvEnhancedCarRentalDataOrig)
            {
                anyLevel3Data = true;
                trvEnhancedCarRentalData.data(trvEnhancedCarRentalDataOrig);
                trvEnhancedCarRentalData.TransactionRecord = trvExpTransNew.RecId;
                trvEnhancedCarRentalData.insert();
            }
        }

        if (trvExpTransOrig.ExpType == TrvExpType::Hotel)
        {
            TrvEnhancedHotelData trvEnhancedHotelData, trvEnhancedHotelDataOrig;

            select firstonly * from trvEnhancedHotelDataOrig where trvEnhancedHotelDataOrig.TransactionRecord == trvExpTransOrig.RecId;
            if (trvEnhancedHotelDataOrig)
            {
                anyLevel3Data = true;
                trvEnhancedHotelData.data(trvEnhancedHotelDataOrig);
                trvEnhancedHotelData.TransactionRecord = trvExpTransNew.RecId;
                trvEnhancedHotelData.insert();
            }
        }

        if (trvExpTransOrig.ExpType == TrvExpType::Airline)
        {
            TrvEnhancedItineraryData trvEnhancedItineraryData, trvEnhancedItineraryDataOrig;

            select firstonly * from trvEnhancedItineraryDataOrig where trvEnhancedItineraryDataOrig.TransactionRecord == trvExpTransOrig.RecId;
            if (trvEnhancedItineraryDataOrig)
            {
                anyLevel3Data = true;
                trvEnhancedItineraryData.data(trvEnhancedItineraryDataOrig);
                trvEnhancedItineraryData.TransactionRecord = trvExpTransNew.RecId;
                trvEnhancedItineraryData.insert();

                TrvEnhancedTripLegDetail trvEnhancedTripLegDetail, trvEnhancedTripLegDetailOrig;

                select firstonly * from trvEnhancedTripLegDetailOrig where trvEnhancedTripLegDetailOrig.ItineraryRecId == trvEnhancedItineraryDataOrig.RecId;
                if (trvEnhancedTripLegDetailOrig)
                {
                    trvEnhancedTripLegDetail.data(trvEnhancedTripLegDetailOrig);
                    trvEnhancedTripLegDetail.ItineraryRecId = trvEnhancedItineraryData.RecId;
                    trvEnhancedTripLegDetail.insert();
                }
            }
        }

        // Copy guests
        if (trvExpTransOrig.hasGuests())
        {
            TrvExpTransGuest    expTransGuest;
            TrvExpTransGuest    expTransGuestOrig;
            RefRecId            newTransRecId = trvExpTransNew.RecId;

            insert_recordset expTransGuest(TrvExpTrans, TrvExpGuest, AmountCurr)
                select newTransRecId, TrvExpGuest, AmountCurr
                    from expTransGuestOrig
                    where expTransGuestOrig.TrvExpTrans == trvExpTransOrig.RecId;
        }

        // Default distributions if line is on an expense report
        if (trvExpTransNew.trvExpTable != 0)
        {
            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(trvExpTransNew,false,SourceDocumentLineAccountingStatus::FullyDistributed);
        }

        ttscommit;

        // if there is L3 data, evaluate policies after L3 data is saved
        if (anyLevel3Data && TrvParameters::find().WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
        {
            trvExpTransNew.executePolicyEvaluation();
        }

        return trvExpTransNew.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editAmountLocal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enter and view itemized line amount in transaction currency
    /// </summary>
    /// <param name="_set">
    /// Boolean indicating the project value is being set
    /// </param>
    /// <param name="_amountLocal">
    /// Amount to set, in transaction currency.
    /// </param>
    /// <returns>
    /// Amount of itemized line, in transaction currency.
    /// </returns>
    /// <remarks>
    /// Transaction currency and rate is determined by looking up the <c>TrvPBSMaindata</c> line
    /// that corresponds to the itemized header line.  If none exists, this method effectively
    /// just sets and gets the value for <c>AmountCurr</c> directly.
    /// </remarks>
    public edit Amount editAmountLocal(boolean _set = false, Amount _amountLocal = 0)
    {
        Amount          totalAmountLocal = 0;
        Amount          itemizedAmountLocal = 0;
        Amount          itemizedAmountCur = 0;
        container       conv;
        CurrencyCode    currencyCodeLocal, currencyCodeCur;
        ExchRate        exchRate;
        TrvExpTrans     itemizedHeaderExpTrans, itemizedExpTrans;

        if ( _set )
        {
            conv = TrvExpItemizationManager::creditCardExchangeRate( TrvExpLineType::ItemizedHeader, this.ParentRecId, this.SplitLineType);

            if ( conv != conNull() )
            {
                // get exchrate, local and transaction currencies
                [exchRate, currencyCodeLocal, currencyCodeCur] = conv;

                // calculate total amount in local currency
                select firstonly AmountCurr from itemizedHeaderExpTrans where itemizedHeaderExpTrans.RecId == this.ParentRecId;
                totalAmountLocal = TrvExpItemizationManager::localFromCurrWithRate( itemizedHeaderExpTrans.AmountCurr, exchRate, currencyCodeLocal);

                // calculate itemized amount in transaction & local currencies
                while select AmountCurr from itemizedExpTrans
                    where itemizedExpTrans.ParentRecId == this.ParentRecId &&
                        itemizedExpTrans.RecId != this.RecId
                {
                    itemizedAmountCur += itemizedExpTrans.AmountCurr;
                    // The way to calculate itemized amount in local currency has to be consistent with TrvItemization.itemizedAmountLocal method
                    // i.e. summing each rounded value
                    itemizedAmountLocal += TrvExpItemizationManager::localFromCurrWithRate( itemizedExpTrans.AmountCurr, exchRate, currencyCodeLocal);
                }

                if ((totalAmountLocal - itemizedAmountLocal) == _amountLocal)
                {
                    //Itemization is complete in local currency, put all remaining amountCurr in this line.
                    this.AmountCurr = itemizedHeaderExpTrans.AmountCurr - itemizedAmountCur;
                }
                else
                {
                    this.AmountCurr = TrvExpItemizationManager::currFromLocalWithRate( _amountLocal, exchRate, currencyCodeLocal);
                }
            }
        }

        return TrvExpItemizationManager::localFromCurr( this.AmountCurr, TrvExpLineType::ItemizedHeader, this.ParentRecId, this.SplitLineType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>editCity</Name>
				<Source><![CDATA[
    public edit LogisticsAddressCityName editCity(boolean _set = false, LogisticsAddressCityName _logisticsAddressCity = '')
    {
        LogisticsAddressCity  logisticsAddressCity;
        LogisticsAddressCityName addressCityName = _logisticsAddressCity;

        if (_set)
        {
            if (_logisticsAddressCity)
            {
                logisticsAddressCity = this.CountryRegion ?
                                            LogisticsAddressCity::findCityCountryRegion(_logisticsAddressCity, this.CountryRegion) :
                                            LogisticsAddressCity::find(_logisticsAddressCity);

                if (logisticsAddressCity)
                {
                    this.City = '';
                    this.AddressCity = logisticsAddressCity.RecId;
                    this.CountryRegion = logisticsAddressCity.CountryRegionId;
                }
                else
                {
                    // value not found in logistics table, user is entering free-text for city
                    this.City = _logisticsAddressCity;
                    this.AddressCity = 0;
                }
            }
            else
            {
                // user is blanking the values
                this.City = '';
                this.AddressCity = 0;
            }
            addressCityName = this.City;
        }
        else
        {
            if (this.City)
            {
                addressCityName = this.City;
            }
            else
            {
                select firstonly Name from logisticsAddressCity where logisticsAddressCity.RecId == this.AddressCity;
                addressCityName = logisticsAddressCity.Name;
            }

        }

        return addressCityName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editExchRate</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(true)]
    public edit ExchRate editExchRate(boolean _set, ExchRate _exchRate)
    {
        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), this.ExchangeCode);
        boolean isCreditCardTransaction = this.isCreditCardTransaction();
        ExchRate exchangeRate = _exchRate;

        if (_set)
        {
            if (exchangeRate >= 0)
            {
                if (isCreditCardTransaction)
                {
                    exchangeRateHelper.parmFromCurrency(this.CreditCardTransactionCurrency);
                }
                this.ExchangeRate = exchangeRateHelper.prepareExchangeRateForStorage(exchangeRate);
                this.amountMST();
            }
            else
            {
                checkFailed(strFmt("@SYS71086", fieldPName(ExchangeRate, ExchangeRate), 0));
                exchangeRate = exchangeRateHelper.displayStoredExchangeRate(this.ExchangeRate);
            }
        }
        else
        {
            if (isCreditCardTransaction)
            {
                exchangeRateHelper.parmFromCurrency(this.CreditCardTransactionCurrency);
            }
            exchangeRate = exchangeRateHelper.displayStoredExchangeRate(this.ExchangeRate);
        }

        return exchangeRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editSubCategory</Name>
				<Source><![CDATA[
    edit TrvCategoryOrSubCategoryName editSubCategory(boolean _set, TrvCategoryOrSubCategoryName _subCategoryName)
    {
        TrvExpTrans       trvExpTrans;
        TrvExpSubCategory trvExpSubCategory;
        DataAreaId        companyDataArea;

        // If this is called on a empty buffer, which is not initialized, we return immediately
        if (this.LegalEntity == 0)
        {
            return '';
        }

        if (_set)
        {
            trvExpTrans         = TrvExpTrans::find(this.ParentRecId);
            trvExpSubCategory   = TrvExpSubCategory::find(trvExpTrans.CostType, _subCategoryName);

            if (!trvExpSubCategory)
            {
                checkFailed(strFmt("@SYS310243", _subCategoryName));
            }
            else
            {
                // don't initialize subcategory from parent record
                this.SubCategoryRecId = trvExpSubCategory.RecId;
                this.initFromTrvExpItemizedHeader(trvExpTrans);
            }
        }
        else
        {
            companyDataArea = CompanyInfo::getDataArea(this.LegalEntity);
            changecompany(companyDataArea)
            {
                if (this.LineType == TrvExpLineType::ItemizedLine && this.SubCategoryRecId)
                {
                    select firstonly trvExpSubCategory where trvExpSubCategory.RecId == this.SubCategoryRecId;
                    if (trvExpSubCategory.RecId)
                    {
                        return trvExpSubCategory.name();
                    }
                }
            }
        }

        return this.CostType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editSubCategoryDescription</Name>
				<Source><![CDATA[
    //[SysObsolete('Method TrvExpTrans.editSubCategoryDescription is not used and will be removed in the near future. Edit the subcategory description on the Expense category setup.', false, 30\06\2020)]
    edit TrvDescription editSubCategoryDescription(boolean _set, TrvCategoryOrSubCategoryName _subCategoryDescription)
    {
        DataAreaId        companyDataArea;

        // If this is called on a empty buffer, which is not initialized, we return immediately
        // This happens in the print page when trvExpTrans is used as an outer joined data source.
        if (this.LegalEntity == 0)
        {
            return '';
        }

        if (_set)
        {
            return this.editSubCategory(_set, _subCategoryDescription);
        }
        else
        {
            if (this.LineType == TrvExpLineType::ItemizedLine && this.SubCategoryRecId)
            {
                return this.editSubCategory(_set, _subCategoryDescription);
            }
            else
            {
                companyDataArea = CompanyInfo::getDataArea(this.LegalEntity);
                changecompany(companyDataArea)
                {
                    _subCategoryDescription = TrvCostType::find(this.CostType).CostTxt;
                }
            }
        }

        return _subCategoryDescription;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editZipCode</Name>
				<Source><![CDATA[
    public edit LogisticsAddressZipCodeId editZipCode(boolean _set = false, LogisticsAddressZipCodeId _logisticsAddressZipCodeId = '')
    {
        LogisticsAddressZipCode logisticsAddressZipCode;
        LogisticsAddressZipCodeId zipCodeId = _logisticsAddressZipCodeId;

        if (_set)
        {
            if (zipCodeId)
            {
                logisticsAddressZipCode = this.CountryRegion ?
                                            LogisticsAddressZipCode::findZipCodeCountryRegion(_logisticsAddressZipCodeId, this.CountryRegion) :
                                            LogisticsAddressZipCode::find(zipCodeId);

                if (logisticsAddressZipCode)
                {
                    this.AddressZipCode = logisticsAddressZipCode.RecId;
                    this.CountryRegion = logisticsAddressZipCode.CountryRegionId;
                    this.editCity(true, logisticsAddressZipCode.City);
                }
                else
                {
                    warning(strFmt("@SYS24626", zipCodeId));
                    this.AddressZipCode = 0;
                }
            }
            else
            {
                // user is blanking the values
                this.AddressZipCode = 0;
                zipCodeId = '';
            }
        }
        else
        {
            zipCodeId = LogisticsAddressZipCode::findRecId(this.AddressZipCode).ZipCode;
        }

        return zipCodeId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluateProjectPoliciesAndSave</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Evaluates the project policies, and saves them.
    /// </summary>
    public void evaluateProjectPoliciesAndSave()
    {
        ProjExpPolicyStatus oldProjPolicyStatus = this.ProjPolicyStatus;
        SysInfoLogStr       oldProjPolicyText   = this.ProjPolicyText;

        this.validateProjExpPoliciesExpense();

        if (oldProjPolicyStatus != this.ProjPolicyStatus ||
            oldProjPolicyText   != this.ProjPolicyText)
        {
            ttsbegin;
            this.selectForUpdate(true);
            this.doUpdate();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchrate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Default exchange rate from currency exchange rate setup
    /// </summary>
    /// <param name="_throwException">
    ///     True if the caller wants this method to throw an exception, false otherwise. Defaulted to false.
    /// </param>
    /// <remarks>
    ///     The exchange rate will store a direct cross rate, which factors in triangulation, between transaction currency and company currency.
    /// </remarks>
    public void exchrate(boolean _throwException = false)
    {
        if (this.ExchangeCode)
        {
            ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(Ledger::primaryLedger(this.LegalEntity),
                                                                                        this.ExchangeCode,
                                                                                        this.TransDate);

            // Call this code in a try/catch to handle scenario where currency code without
            // a valid exchange rate is provided. In this case, user should still be able to
            // enter an exchange rate.
            try
            {
                this.ExchangeRate = exchangeRateHelper.getCrossRate();
            }
            catch (Exception::Error)
            {
                // If caller wants exception to be thrown, throw exception if exists.
                // Nothing really to do otherwise since it defaults but user can change the exchange rate.
                if (_throwException)
                {
                    throw Exception::Error;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expTable</Name>
				<Source><![CDATA[
    TrvExpTable expTable()
    {
        return TrvExpTable::find(this.ExpNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expTypeSpecificValidation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the expense line for specific expense types.
    /// </summary>
    /// <returns>
    ///     True if validation succeeded, false otherwise.
    /// </returns>
    public boolean expTypeSpecificValidation()
    {
        boolean retval = true;

        switch (this.ExpType)
        {
            case TrvExpType::Allowance:
                if (!this.TrvLocations || !this.DateFrom || !this.DateTo)
                {
                    retval = checkFailed("@SYS138265");
                }
                break;

            case TrvExpType::Transport:
                if (this.kmOwnCar <= 0)
                {
                    retval = checkFailed("@SYS138266");
                }
                break;

            case TrvExpType::Advance:
                if (!this.CashAdvanceRecId)
                {
                    retval = checkFailed("@Expense:CashAdvanceNumberRequired");
                }
                break;
        }
        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineNumber_MY</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets line number of a trvExpLine line.
    /// </summary>
    /// <returns>
    /// Line number of the markup trans line.
    /// </returns>
    public int64 getLineNumber_MY()
    {
        const TrvLineNumber LineNumberInterval = 10;

        TrvExpTrans trvExpTransLoc;

        select count(RecId) from trvExpTransLoc
        where trvExpTransLoc.ExpNumber   == this.ExpNumber
            && trvExpTransLoc.LineNumber <= this.LineNumber;

        return any2Int64(LineNumberInterval * trvExpTransLoc.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultCostRate</Name>
				<Source><![CDATA[
    public TrvCostRate getDefaultCostRate()
    {
        TrvCostTypeRates    ctrate;

        ctrate = TrvCostTypeRates::getApplicableRate(this.CostType, 1, this.TransDate);

        return ctrate.CostRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleItemizableCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the lineType based off the whether the itemization is mandatory in the Category
    /// </summary>
    /// <param name = "_ignoreCurrentItemizations">True if you want to change the LineType even if there are itemizations</param>
    private void handleItemizableCategory(boolean _ignoreCurrentItemizations = false)
    {
        TrvExpTrans itemizations;

        if (TrvCostType::find(this.CostType).IsItemizationMandatory)
        {
            if (this.LineType == TrvExpLineType::Default)
            {
                this.LineType = TrvExpLineType::ItemizedHeader;
            }
        }
        else
        {
            if (this.LineType == TrvExpLineType::ItemizedHeader)
            {
                if (_ignoreCurrentItemizations)
                {
                    this.LineType = TrvExpLineType::Default;
                }
                else
                {
                    // Check to see if there are itemizations before changing LineType
                    select firstonly RecId from itemizations
                        where itemizations.ParentRecId == this.RecId;
                    if (!itemizations.RecId)
                    {
                        this.LineType = TrvExpLineType::Default;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasActiveWorkflowStatus</Name>
				<Source><![CDATA[
    public display boolean hasActiveWorkflowStatus()
    {
        WorkflowTrackingStatusTable trackingStatusTable;

        trackingStatusTable = Workflow::findTrackingStatusForCurrentUser(this);

        return (trackingStatusTable.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasGuests</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns whether the expense line has guests, persons entertained or gift recipients specified for it.
    /// </summary>
    /// <returns>
    ///     true if the expense line has guests, persons entertained or gift recipients specified, false otherwise.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display boolean hasGuests()
    {
        TrvExpTransGuest expTransGuest;

        select firstonly RecId from expTransGuest
            where expTransGuest.TrvExpTrans == this.RecId;

        return (expTransGuest.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hotelSubCategoryExpenseType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the specific expense type of the hotel itemized lines based on the subcategory.
    /// </summary>
    /// <returns>
    /// The specific expense type of the hotel itemized lines based on the subcategory.
    /// </returns>
    public display TrvExpTypeEDT hotelSubCategoryExpenseType()
    {
        TrvExpSubCategory   trvExpSubCategory;
        TrvExpType          expenseType = this.ExpType;

        if (this.SubCategoryRecId != 0 && this.ExpType == TrvExpType::Hotel)
        {
            select firstonly trvExpSubCategory where trvExpSubCategory.RecId == this.SubCategoryRecId;

            if (trvExpSubCategory.RecId)
            {
                switch (trvExpSubCategory.chargeType())
                {
                    case TrvHotelChargeType::Gift:
                        expenseType = TrvExpType::Gift;
                        break;
                    case TrvHotelChargeType::BusinessEntertainment:
                        expenseType = TrvExpType::Entertainment;
                        break;
                }
            }
        }

        return expenseType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCreditCardTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initalize expense line from credit card transaction.
    /// </summary>
    /// <param name="_creditCardTransactionRecId">
    ///     Record Id of credit card transaction.
    /// </param>
    public void initFromCreditCardTransaction(RecId _creditCardTransactionRecId)
    {
        TrvPBSMaindata trvPBSMaindata;

        trvPBSMaindata = TrvPBSMaindata::findRecId(_creditCardTransactionRecId);

        this.initFromCreditCardTransactionRecord(trvPBSMaindata);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCreditCardTransactionRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initalize expense line from credit card transaction.
    /// </summary>
    /// <param name="_trvPBSMaindata">
    ///     The record of the credit card transaction.
    /// </param>
    public void initFromCreditCardTransactionRecord(TrvPBSMaindata _trvPBSMaindata)
    {
        if (_trvPBSMaindata.RecId)
        {
            this.PayMethod       = _trvPBSMaindata.Paymethod;

            this.initValue();
            this.pbsRecId        = _trvPBSMaindata.RecId;
            this.MerchantId      = _trvPBSMaindata.BusinessName;
            this.TransDate       = _trvPBSMaindata.TransDate;
            this.CountryRegion   = _trvPBSMaindata.Country;
            this.PBS_Statement   = NoYes::Yes;

            //Boolean to check if the fields AMOUNT_LOCALCURRENCY and EXCHCODE_LOCALCURRENCY are to be mapped with "AMOUNTCURR' and "EXCHANGECODE" fields in TrvExpTrans
            boolean isCreditCardImportLocalTransactionCurrencyFlightEnabled = TrvExpenseHelper::isCreditCardImportLocalTransactionCurrencyFlightEnabled();
            
            this.AmountCurr      = !isCreditCardImportLocalTransactionCurrencyFlightEnabled && _trvPBSMaindata.AmountLocal != 0 ? _trvPBSMaindata.AmountLocal : _trvPBSMaindata.AmountCurr;
            if (this.CreatingWorker == 0)
            {
                this.CreatingWorker  = _trvPBSMaindata.Worker;
                this.InterCompanyLE  = _trvPBSMaindata.DataAreaId;
            }

            // Populate the data into CreditCardTransaction* fields at all times
            this.CreditCardTransactionCurrencyAmount = _trvPBSMaindata.AmountLocal != 0 ? _trvPBSMaindata.AmountLocal : _trvPBSMaindata.AmountCurr;
            this.CreditCardTransactionCurrency       = strLRTrim(_trvPBSMaindata.ExchCodeLocal) != "" ? _trvPBSMaindata.ExchCodeLocal : _trvPBSMaindata.ExchCode;
            this.ExchangeCode    = !isCreditCardImportLocalTransactionCurrencyFlightEnabled && strLRTrim(_trvPBSMaindata.ExchCodeLocal) != "" ? _trvPBSMaindata.ExchCodeLocal : _trvPBSMaindata.ExchCode;

            // Validate currency codes and exchange rate and catch the exception.
            this.exchrate(true);
            this.ExchangeRate = TrvExpenseHelper::calcCreditCardTransactionExchRate(this);
            this.amountMST();

            // Update tax information
            this.setTaxGroup();
            this.updateNetTransactionAmount();
            this.setCorrectedTaxAmountMST();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromImportedTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the expense line from the unreconciled expense transaction.
    /// </summary>
    /// <param name="_importedTransactionRecId">
    ///     The <c>RecId</c> of the unreconciled expense transaction.
    /// </param>
    public void initFromImportedTransaction(RecId _importedTransactionRecId)
    {
        TrvUnreconciledExpenseTransaction trvUnreconciledExpenseTransaction;

        trvUnreconciledExpenseTransaction = TrvUnreconciledExpenseTransaction::find(_importedTransactionRecId);

        this.initFromImportedTransactionRecord(trvUnreconciledExpenseTransaction);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromImportedTransactionRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the expense line from the unreconciled expense transaction.
    /// </summary>
    /// <param name="_trvUnreconciledExpenseTransaction">
    ///     The record of the unreconciled expense transaction.
    /// </param>
    /// <param name="_calculateExchangeRate">
    ///     Whether to calculate exchange rate based on the transaction currency.
    /// </param>
    public void initFromImportedTransactionRecord(TrvUnreconciledExpenseTransaction _trvUnreconciledExpenseTransaction, boolean _calculateExchangeRate = true)
    {
        if (_trvUnreconciledExpenseTransaction.RecId)
        {
            if (this.CostType)
            {
                this.PayMethod = TrvCostType::find(this.CostType).StdPaiMethod;
            }

            this.initValue();
            this.Mobile_Statement = NoYes::Yes;
            this.TransDate  = _trvUnreconciledExpenseTransaction.TransDate;
            this.AmountCurr  = _trvUnreconciledExpenseTransaction.TransactionCurrencyAmount;
            if (this.CreatingWorker == 0)
            {
                this.CreatingWorker = _trvUnreconciledExpenseTransaction.Worker;
            }

            if (!this.MerchantId)
            {
                this.MerchantId  = _trvUnreconciledExpenseTransaction.MerchantId;
            }

            // Exchange code is set to Accounting currency in initValue
            if (_trvUnreconciledExpenseTransaction.TransactionCurrencyCode != '' && Currency::exist(_trvUnreconciledExpenseTransaction.TransactionCurrencyCode))
            {
                this.ExchangeCode = _trvUnreconciledExpenseTransaction.TransactionCurrencyCode;

                if (_calculateExchangeRate)
                {
                    // Manually call the modifiedField method for exchange code to catch exception.
                    this.modifiedFieldExchCode(true);
                }
            }

            this.AdditionalInformation  = _trvUnreconciledExpenseTransaction.Notes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTrvExpItemizedHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initalize the itemized line according to its parent itemized or header line.
    /// </summary>
    /// <param name="_itemizedHeader">
    ///     The itemized header expense line from which to initialize the new record.
    /// </param>
    /// <remarks>
    ///     Should be called for a new itemized line instead of initValue().
    ///     This is used for split lines as well. Note the TransDate and Amount fields are not set,
    ///     and should be set callers.
    ///     Note the TransDate and Amount fields are not set and should be from all callers.
    /// </remarks>
    void initFromTrvExpItemizedHeader(TrvExpTrans _itemizedHeader)
    {
        // Note the TransDate is NOT defaulted

        this.LineType = TrvExpLineType::ItemizedLine;
        this.ParentRecId = _itemizedHeader.RecId;
        this.ApprovalStatus = TrvAppStatus::Create;
        this.IsPreAuthorized = false;

        this.CreatingWorker  = _itemizedHeader.CreatingWorker;
        this.LegalEntity = _itemizedHeader.LegalEntity;
        this.ReferenceDataAreaId = _itemizedHeader.ReferenceDataAreaId;
        this.InterCompanyLE = _itemizedHeader.InterCompanyLE;


        // don't overwrite values set for cost type or subcategory
        if (!this.CostType)
        {
            this.CostType = _itemizedHeader.CostType;
            this.ExpType = _itemizedHeader.ExpType;
        }
        if (!this.SubCategoryRecId)
        {
            this.SubCategoryRecId = _itemizedHeader.SubCategoryRecId;
        }

        this.ExpNumber = _itemizedHeader.ExpNumber;
        this.TrvExpTable = _itemizedHeader.TrvExpTable;
        this.PayMethod = _itemizedHeader.PayMethod;
        this.ExchangeCode = _itemizedHeader.ExchangeCode;
        this.ExchangeRate = _itemizedHeader.ExchangeRate;
        this.CreditCardTransactionCurrency = _itemizedHeader.CreditCardTransactionCurrency;
        this.MerchantId = _itemizedHeader.MerchantId;
        this.BillIssuedTo = _itemizedHeader.BillIssuedTo;
        this.TrvLocations    = _itemizedHeader.TrvLocations;
        this.ReceiptsAttached = _itemizedHeader.ReceiptsAttached;
        this.DefaultDimension = _itemizedHeader.DefaultDimension;

        TrvExpTrans::copyOverProjectInformation(this, _itemizedHeader);

        // Transport expense initialization
        this.KMPrice = _itemizedHeader.KMPrice;
        this.KMOwnCar = _itemizedHeader.KMOwnCar;
        
        // tax data not needed for personal expenses
        if (this.ExpType != TrvExpType::Personal)
        {
            this.TaxIncluded = _itemizedHeader.TaxIncluded;
            this.TaxGroup = _itemizedHeader.TaxGroup;

            this.CountryRegion  = _itemizedHeader.CountryRegion;
            this.AddressState   = _itemizedHeader.AddressState;
            this.AddressCity    = _itemizedHeader.AddressCity;
            this.AddressZipCode = _itemizedHeader.AddressZipCode;

            // TaxItemGroup comes from the subcategory
            this.setTaxItemGroup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSplitHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initalize the itemized line according to its parent split header line
    /// </summary>
    /// <param name="_itemizedHeader">
    ///     The split header expense line
    /// </param>
    /// <remarks>
    ///     Should be called for a new itemized line after setting category, and before the initValue.
    /// </remarks>
    void initFromSplitHeader(TrvExpTrans _splitHeader)
    {
        this.SplitLineType = TrvExpSplitLineType::SplitLine;
        this.PBS_Statement = _splitHeader.PBS_Statement;
        this.ParentRecId = _splitHeader.RecId;

        this.ExpNumber = _splitHeader.ExpNumber;
        this.TrvExpTable = _splitHeader.TrvExpTable;
        this.ReferenceDataAreaId = _splitHeader.ReferenceDataAreaId;
        this.PayMethod = _splitHeader.PayMethod;
        this.ExchangeCode = _splitHeader.ExchangeCode;
        this.ExchangeRate = _splitHeader.ExchangeRate;
        this.CreditCardTransactionCurrency = _splitHeader.CreditCardTransactionCurrency;

        if (_splitHeader.MerchantId)
        {
            this.MerchantId = _splitHeader.MerchantId;
        }

        if (this.CostType)
        {
            this.ExpType = TrvCostType::find(this.CostType).ExpType;
        }

        this.TransDate = _splitHeader.TransDate;

        if (this.ExpType != TrvExpType::Personal || !this.isPersonalExpensePaidByEmployee())
        {
            this.TaxIncluded = _splitHeader.TaxIncluded;
            this.TaxGroup = _splitHeader.TaxGroup;
            this.setTaxItemGroup();

            this.CountryRegion  = _splitHeader.CountryRegion;
            this.AddressCity    = _splitHeader.AddressCity;
            this.AddressZipCode = _splitHeader.AddressZipCode;
            this.AddressState   = _splitHeader.AddressState;
        }

        // initializes interCompanyLE from the header line.
        if (!this.InterCompanyLE)
        {
            this.InterCompanyLE = _splitHeader.InterCompanyLE;
        }

        this.InterCompanyCategory = _splitHeader.InterCompanyCategory;
        this.BillIssuedTo = _splitHeader.BillIssuedTo;
        this.CreatingWorker  = _splitHeader.CreatingWorker;
        this.TrvLocations    = _splitHeader.TrvLocations;
        this.ReceiptsAttached = _splitHeader.ReceiptsAttached;
        this.TransactionText = _splitHeader.TransactionText;
        this.AdditionalInformation = _splitHeader.AdditionalInformation;
        this.Reason = _splitHeader.Reason;

        if (this.isCategoryIntegratedWithProject())
        {
            if (this.ProjId == _splitHeader.ProjId)
            {
                this.DefaultDimension = _splitHeader.DefaultDimension;
            }
            else
            {
                this.DefaultDimension = ProjTable::find(this.ProjId).DefaultDimension;
            }
        }
        else
        {
            if (this.ProjId)
            {
                // for the case itemized header has project id and itemized line is not project related, we don't default dimension from itemized header but from worker
                this.DefaultDimension = HcmEmployment::findByWorkerLegalEntity(this.CreatingWorker, this.LegalEntity).DefaultDimension;
            }
            else
            {
                this.DefaultDimension = _splitHeader.DefaultDimension;
            }
        }

        this.IsPreAuthorized = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTrvExpTable</Name>
				<Source><![CDATA[
    void initFromTrvExpTable(TrvExpNumber _expNumber)
    {
        if (_expNumber)
        {
            TrvExpTable trvExpTable = TrvExpTable::find(_expNumber);
            this.TrvExpTable = trvExpTable.RecId;

            this.CreatingWorker  = trvExpTable.CreatingWorker;
            this.InterCompanyLE  = trvExpTable.intercompanyLegalEntityName();
        }

        this.ExchangeCode    = CompanyInfoHelper::standardCurrency();
        this.ExchangeRate    = 100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInterCompanyCategory</Name>
				<Source><![CDATA[
    private void initializeInterCompanyCategory()
    {
        ProjCategory        projCategory;
        CategoryTable       categoryTable;
        SharedCategory      sharedCategory;
        boolean             isIntercompanyExpneseLine;

        if (this.InterCompanyLE != '' && this.ReferenceDataAreaId != '' &&
            this.InterCompanyLE != this.ReferenceDataAreaId)
        {
            isIntercompanyExpneseLine = true;
        }

        if (this.InterCompanyLE)
        {
            categoryTable = CategoryTable::find(this.CostType);
            sharedCategory = SharedCategory::findRecId(categoryTable.SharedCategory);
            boolean changeItemTaxGroup = this.isTaxObligationDestination();

            changecompany(this.InterCompanyLE)
            {
                categoryTable.clear();

                select firstonly CategoryId from categoryTable
                    where categoryTable.SharedCategory == sharedCategory.RecId &&
                          categoryTable.UseInExpense == NoYes::Yes;

                if (categoryTable.CategoryId)
                {
                    select firstonly RecId, CategoryId from projCategory
                    where projCategory.CategoryId  == categoryTable.CategoryId &&
                          projCategory.CategoryType == ProjCategoryType::Cost;
                }

                if (projCategory.RecId &&
                    TrvExpTrans::checkWorkerCategory(this.CreatingWorker, projCategory.CategoryId, isIntercompanyExpneseLine, false, this.LegalEntity))
                {
                    this.InterCompanyCategory = projCategory.CategoryId;
                }
                else
                {
                    this.InterCompanyCategory = '';
                }

                //If tax obligation is destination change tax item group
                if (changeItemTaxGroup)
                {
                    this.setTaxItemGroup();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();

        //put additional business logic in initValueHelper function instead of here
        this.initValueHelper();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValueHelper</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Helper method for initializing values on the expense line.
    /// </summary>
    /// <exception cref="Exception::Error">
    ///     Throws an error, when the expense line is a non-editable state.
    /// </exception>
    public void initValueHelper()
    {
        if (this.ApprovalStatus != TrvAppStatus::Create &&
            this.ApprovalStatus != TrvAppStatus::Returned &&
            this.ApprovalStatus != TrvAppStatus::None )
        {
            throw error(strFmt ("@SYS136836", enum2str(this.ApprovalStatus)));
        }

        this.LegalEntity = CompanyInfo::current();
        this.ReferenceDataAreaId = curext();

        if (this.LineType != TrvExpLineType::ItemizedLine && this.SplitLineType != TrvExpSplitLineType::SplitLine)
        {
            this.initFromTrvExpTable(this.ExpNumber);
        }

        // The previous block might have updated the <c>TrvExpTable</c> field.
        // If so, we can skip the query call.
        else if (this.ExpNumber && this.TrvExpTable == 0)
        {
            this.TrvExpTable = TrvExpTable::find(this.ExpNumber).RecId;
        }

        this.ApprovalStatus = TrvAppStatus::Create;

        if (!this.InterCompanyLE)
        {
            this.InterCompanyLE = curExt();
        }

        if (this.isIntercompany())
        {
            this.initializeInterCompanyCategory();
        }

        this.initFromCostType();

        // will set the LineType based on the IsItemizationMandatory flag
        this.handleItemizableCategory();

        //Defaulting from header tax fields takes higher precedence
        if (this.LineType != TrvExpLineType::ItemizedLine)
        {
            if (!this.TaxGroup)
            {
                this.setTaxGroup();
            }

            this.TaxIncluded = TrvParameters::find().TaxIncluded;
        }

		//Defaulting current date as expense date, if date is not provided
		if (this.TransDate == dateNull())
        {
			this.TransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        // Defaulting item sales tax for both itemized header and line
        this.setTaxItemGroup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleSourceDocumentAndPolicies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create source document line and handle calculations dependent on it. After source document line is created,
    /// evaluate policies.
    /// </summary>
    /// <param name = "_trvExpTransRecId">RecId of <c>TrvExpTrans</c> record.</param>
    /// <param name = "_evaluatePolicies">True if policies should be evaluated; otherwise, false.</param>
    /// <remarks>
    /// This method can be used to complete the actions that are skipped when the expense is inserted (or updated).
    /// See insert method's skipSourceDocAndPolicies parameter.
    /// </remarks>
    public static void handleSourceDocumentAndPolicies(RefRecId _trvExpTransRecId, boolean _evaluatePolicies = true)
    {
        TrvExpTrans trvExpTrans;
        TrvParameters trvParameters = TrvParameters::find();

        try
        {
            ttsbegin;

            // Get the latest record.
            trvExpTrans = TrvExpTrans::find(_trvExpTransRecId, true);

            // Do not create or update source document line if line is not on an expense report
            if (trvExpTrans.TrvExpTable != 0)
            {
                // Create or update source document line.
                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(trvExpTrans);
                trvExpTrans.calcIntercompanyAmounts();
                trvExpTrans.doUpdate();

                // Calculate and create taxUncommitted
                trvExpTrans.createTaxUncommitted(true);

                if (_evaluatePolicies && trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
                {
                    // If policies are set to be evaluated on line save, then distributions should be created since
                    // there might be policies which need to evaluate the distributions
                    SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(trvExpTrans, true, SourceDocumentLineAccountingStatus::FullyDistributed);
                }
            }
            else if (!trvExpTrans)
            {
                // Valid recId is passed, but couldn't fetch the expense.
                throw Exception::Error;
            }

            ttscommit;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                // If update conflict is encountered, retry upto 3 times.
                // This may happen if there are multiple updates to the same expense at the same time.
                if (xSession::currentRetryCount() > 3)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Deadlock)
        {
            // If deadlock is encountered, retry upto 3 times.
            // This may happen if there are multiple updates to the tax records at the same time.
            if (appl.ttsLevel() == 0 && xSession::currentRetryCount() <= 3)
            {
                retry;
            }
            else
            {
                throw Exception::Deadlock;
            }
        }
        catch (Exception::Error)
        {
            // If valid recId is passed and we couldn't fetch the expense, retry upto 3 times.
            // This may happen if the previous insert is not committed yet.
            if (!trvExpTrans && xSession::currentRetryCount() <= 3)
            {
                retry;
            }
            else
            {
                throw Exception::Error;
            }
        }

        if (trvExpTrans)
        {
            if (_evaluatePolicies && trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
            {
                trvExpTrans.executePolicyEvaluation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTrvExpenseMobileInterCompanyCategoryDefaultingEnabled</Name>
				<Source><![CDATA[
    private static boolean isTrvExpenseMobileInterCompanyCategoryDefaultingEnabled()
    {
        return FeatureStateProvider::isFeatureEnabled(TrvExpenseMobileInterCompanyCategoryDefaulting::instance());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAndDefaultInterCompanyCategory</Name>
				<Source><![CDATA[
    private void checkAndDefaultInterCompanyCategory()
    {
        // If the mobile app sends an empty InterCompanyCategory field to be inserted into the DB (This field is
        // mandatory by default, but can be hidden by customization), and the feature for defaulting the intercompany
        // category is enabled, the following snippet defaults the inter company category.
        if(SysAppMobile::isMobileMode()
            && TrvExpTrans::isTrvExpenseMobileInterCompanyCategoryDefaultingEnabled())
        {
            this.initializeInterCompanyCategory();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert a new expense.
    /// </summary>
    /// <param name = "_evaluatePolicies">
    /// True if policies need to be evaluated; False if policy evaluation can be skipped.
    /// If general parameters has been set to skip policy evaluation on line save, then policies won't be evaluated regardless of this parameter.
    /// </param>
    /// <param name = "_evaluateSourceDocAndPolicies">
    /// Used to skip executing source document related code and policy evaluation. True if they should not be skipped; otherwise, false.
    /// If this is false, then regardless of the previous parameter, policy evaluation will be skipped.
    /// </param>
    public void insert(boolean _evaluatePolicies = true, boolean _evaluateSourceDocAndPolicies = true)
    {
        TrvExpTrans                     expTransHeader;
        TrvParameters                   trvParameters = TrvParameters::find();
        boolean                         useCorectedTaxAmount;
        boolean                         needToUpdateReqReconciliationStatus;
        TrvPartyEmployeeRelationship    trvPartyEmployeeRelationship;

        this.modifyVatDueDate_W();
        this.initFromCostType(true);

        if (this.ExpType == TrvExpType::Allowance)
        {
            this.perDiem();
        }

        if ( (TrvCostType::find(this.CostType).IsItemizationMandatory) && (this.LineType != TrvExpLineType::ItemizedLine))
        {
            this.LineType = TrvExpLineType::ItemizedHeader;
        }

        this.LineNumber = this.calculateNextLineNumber();

        this.AmountCurr = CurrencyExchangeHelper::amount(this.AmountCurr, this.ExchangeCode);

        // For itemized lines calculate credit card transaction exchange rate
        if (this.LineType == TrvExpLineType::ItemizedLine && this.isCreditCardTransaction()
            && this.CreditCardTransactionCurrencyAmount != 0 && this.ExchangeRate == 0)
        {
            this.ExchangeRate = TrvExpenseHelper::calcCreditCardTransactionExchRate(this);
        }

        this.amountMST();

        if (!this.isTaxApplicable())
        {
            this.clearTaxFields();
        }

        this.setItemizedLineCorrectedTaxAmount();

        // when corrected tax is 0, we want to default it to calculated tax; for the insert through service scenario
        useCorectedTaxAmount = (this.CorrectedTaxAmount != 0);
        this.updateNetTransactionAmount(useCorectedTaxAmount);
        this.setCorrectedTaxAmountMST();

        this.checkAndDefaultInterCompanyCategory();

        try
        {
            ttsbegin;

            if (this.LineType == TrvExpLineType::ItemizedLine)
            {
                // Update header only if line type is "Default".
                select forupdate firstOnly expTransHeader where expTransHeader.RecId == this.ParentRecId
                    && expTransHeader.LineType == TrvExpLineType::Default;

                if (expTransHeader)
                {
                    expTransHeader.LineType = TrvExpLineType::ItemizedHeader;
                    expTransHeader.IsSplit = this.IsSplit;
                    expTransHeader.clearSDLForItemizedAndSplitHeader();
                    expTransHeader.doUpdate();
                }
            }
            else if (this.SplitLineType == TrvExpSplitLineType::SplitLine)
            {
                // Update header only if line type is "Default".
                select forupdate firstOnly expTransHeader where expTransHeader.RecId == this.ParentRecId
                    && expTransHeader.SplitLineType == TrvExpSplitLineType::NoSplit;

                if (expTransHeader)
                {
                    expTransHeader.SplitLineType = TrvExpSplitLineType::SplitHeader;
                    expTransHeader.clearSDLForItemizedAndSplitHeader();
                    expTransHeader.doUpdate();
                }
            }

            if (this.ProjId && !this.ProjStatusId)
            {
                this.setProjectFields();
            }

            // project policies updates field values, and has to be done before super
            if (trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
            {
                this.validateProjExpPoliciesExpense();
            }

            // before super, as the trvExpTrans.AccountingCurrencyReconciledAmount is updated, and orig values should be got before super
            this.mapToRequisitionLine();
            needToUpdateReqReconciliationStatus = this.needToUpdateReqReconciliationStatus(this.orig());

            if (this.SourceDocumentLine != 0)
            {
                // Clearing the SDL reference to set the value based on SDF settings
                this.SourceDocumentLine = 0;
            }

            if (_evaluateSourceDocAndPolicies)
            {
                // We create SDL for every trvExpTrans; the following call will set this.SourceDocumentLine field
                // The state transition model will update distributions, and check budget as required
                // Eg only if budget check on line save is on, distributions would be created, and move to fully distributed state
                if (this.TrvExpTable != 0)
                {
                    SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this);
                    this.calcIntercompanyAmounts();
                }
            }

            if (!this.ExpTransNumber)
            {
                this.ExpTransNumber = TrvExpTrans::GetNewExpTransNumber();
            }

            if (this.ProjId != '' && this.ProjTransId == '')
            {
                this.ProjTransId   = ProjParameters::newTransId();
            }

            super();

            // Insert per diem lines.
            if ((this.ExpType == TrvExpType::Allowance) && !(trvParameters.MealReductionType == TrvMealReductionType::MealTypePerTrip))
            {
                // Fetch the record only for an allowance type and only if needed.
                select firstonly PerDiem from trvPartyEmployeeRelationship where trvPartyEmployeeRelationship.Worker == this.CreatingWorker;

                if (!(trvPartyEmployeeRelationship.PerDiem > 0))
                {
                    this.insertPerDiemDataLines();
                }
            }

            if (needToUpdateReqReconciliationStatus)
            {
                TrvRequisitionTable::updateReconciliationStatus(this.requisitionTable());
            }

            if (_evaluateSourceDocAndPolicies)
            {
                // Calculate and create taxUncommitted before sourcedoc implementation so that related distributions will be
                // created during line save instead of post.
                this.createTaxUncommitted(true);

                // If policies are set to be evaluated on line save, then distributions should be created since
                // there might be policies which need to evaluate the distributions
                if (trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
                {
                    if (this.TrvExpTable != 0)
                    {
                        SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this,true,SourceDocumentLineAccountingStatus::FullyDistributed);
                    }
                }

                if (_evaluatePolicies && trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
                {
                    this.executePolicyEvaluation();
                }
            }

            //update cash advance mapping
            this.updateExpCashAdvanceMap();

            ttscommit;
        }
        // Catch update conflict exception when more than one itemized lines are trying to update expense line.
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= 3)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNextLineNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the next available line number for the expense report of the current expense line
    /// </summary>
    /// <returns>
    /// The next <c>LineNumber</c> for an expense line in the expense report
    /// </returns>
    public LineNumber calculateNextLineNumber()
    {
        LineNumber number;
        TrvExpTrans expTrans;

        if (this.SplitLineType == TrvExpSplitLineType::SplitLine)
        {
            // Split line numbers need to be in relationship to the split header
            select firstonly maxof(LineNumber) from expTrans
                    where expTrans.TrvExpTable == this.TrvExpTable &&
                    ((expTrans.RecId == this.ParentRecId) ||      // parent line - first split line
                     (expTrans.ParentRecId == this.ParentRecId && expTrans.SplitLineType == TrvExpSplitLineType::SplitLine));   // sibling lines
            
            number = expTrans.LineNumber + 0.1;
        }
        else if (this.LineType != TrvExpLineType::ItemizedLine)
        {
            select firstonly maxof(LineNumber) from expTrans
                    where expTrans.TrvExpTable == this.TrvExpTable &&
                          expTrans.LineType != TrvExpLineType::ItemizedLine;
            number = expTrans.LineNumber + 1.0;
        }
        else
        {
            select firstonly maxof(LineNumber) from expTrans
                    where expTrans.TrvExpTable == this.TrvExpTable &&
                          (expTrans.ParentRecId == this.ParentRecId || expTrans.RecId == this.ParentRecId);
            number = expTrans.LineNumber + 0.000001;
        }

        return number;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPerDiemDataLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert a row in TrvExpPerdiemData table for each day in trip.
    /// </summary>
    public void insertPerDiemDataLines()
    {
        TrvExpPerdiemData trvExpPerdiemData;
        int numberOfDaysCount;
        // Counts the number of days (Partial and Full days) based in 24h or calendar setup.
       
        TrvExpPerDiemDataContract trvExpPerDiemDataContract = this.initializeExpensePerDiemContract();

        // Insert per diem lines only if is a per diem expense line with date from, date to and location.
        if (this.canInsertPerDiemDataLines())
        {
            trvExpPerDiemDataContract = this.calculatePerDiemHoursAndDays(trvExpPerDiemDataContract);
            trvExpPerDiemDataContract.parmTrvPerDiems(this.getPerdiemRateSetup());

            for (numberOfDaysCount = 0; numberOfDaysCount < trvExpPerdiemDataContract.parmNumDays(); numberOfDaysCount++)
            {
                trvExpPerDiemDataContract.parmNumberOfDaysCount(numberOfDaysCount);
                trvExpPerDiemDataContract = trvExpPerdiemData.initializeTrvExpPerDiemData(trvExpPerDiemDataContract);
                trvExpPerdiemData = trvExpPerDiemDataContract.parmTrvExpPerdiemData();

                trvExpPerdiemData.insert();
            }

            // Delete any record in perdiem data that are not in the range of current entry.
            TrvExpPerdiemData::removePerDiemDataWhichIsNotInDateRange(this.DateFrom, this.DateTo, this.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePerDiemHoursAndDays</Name>
				<Source><![CDATA[
    private TrvExpPerDiemDataContract calculatePerDiemHoursAndDays(TrvExpPerDiemDataContract _trvExpPerDiemDataContract)
    {
        TrvExpPerDiemDataContract perDiemDataContract = _trvExpPerDiemDataContract;

        if (DateTimeUtil::date(perDiemDataContract.parmDateFrom()) == DateTimeUtil::date(perDiemDataContract.parmDateTo()))
        {
            perDiemDataContract = this.calculatePerDiemHoursAndDaysForToDateEqualsFromDate(perDiemDataContract);
        }
        else
        {
            perDiemDataContract = this.calculatePerDiemHoursAndDaysForToDateNotEqualFromDate(perDiemDataContract);
        }

        return this.calculatePerDiemHoursAndDaysForFullDayHourCalculation(perDiemDataContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePerDiemHoursAndDaysForToDateEqualsFromDate</Name>
				<Source><![CDATA[
    private TrvExpPerDiemDataContract calculatePerDiemHoursAndDaysForToDateEqualsFromDate(TrvExpPerDiemDataContract _trvExpPerDiemDataContract)
    {
        // If the first day is the same as last day, the number of days is 1.
        const int secondsPerHour = 3600;
        real hrsFirstDay = 0;

        hrsFirstDay += DateTimeUtil::getDifference(_trvExpPerDiemDataContract.parmDateTo(), _trvExpPerDiemDataContract.parmDateFrom())/secondsPerHour;

        _trvExpPerDiemDataContract.parmHoursFirstDay(hrsFirstDay);
        _trvExpPerDiemDataContract.parmHoursLastDay(0);
        _trvExpPerDiemDataContract.parmNumMiddleDays(0);
        _trvExpPerDiemDataContract.parmNumDays(1);

        return _trvExpPerDiemDataContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePerDiemHoursAndDaysForToDateNotEqualFromDate</Name>
				<Source><![CDATA[
    private TrvExpPerDiemDataContract calculatePerDiemHoursAndDaysForToDateNotEqualFromDate(TrvExpPerDiemDataContract _trvExpPerDiemDataContract)
    {
        utcDatetime dateFrom = _trvExpPerDiemDataContract.parmDateFrom();
        utcDatetime dateTo = _trvExpPerDiemDataContract.parmDateTo();
        const int secondsPerMinute = 60;
        const int hoursPerDay = 24;
        const int twoDays = 2;
        real hrsFirstDay = 0;
        real hrsLastDay = 0;

        if (_trvExpPerDiemDataContract.parmTrvParameters().PerDiemCalculation == TrvPerDiemCalculation::CalendarDayNoTime)
        {
            hrsFirstDay = hoursPerDay;
            hrsLastDay = hoursPerDay;
        }
        else
        {
            hrsFirstDay = hoursPerDay - DateTimeUtil::hour(dateFrom) - (DateTimeUtil::minute(dateFrom)/secondsPerMinute);
            hrsLastDay = DateTimeUtil::hour(dateTo) + (DateTimeUtil::minute(dateTo)/secondsPerMinute);
        }

        date startMidnight = DateTimeUtil::date(DateTimeUtil::addDays(dateFrom, 1));
        date lastMidnight = DateTimeUtil::date(dateTo);

        // Number of full travel days, not counting first and last.
        int numMiddleDays = lastMidnight - startMidnight;
        // If the first day is not the same as last day:
        // the number of total days is the count of days in the middle plus 2 days (first and last) this is using by default a calculation based on calendar days.
        int numDays = numMiddleDays + twoDays;

        _trvExpPerDiemDataContract.parmHoursFirstDay(hrsFirstDay);
        _trvExpPerDiemDataContract.parmHoursLastDay(hrsLastDay);
        _trvExpPerDiemDataContract.parmNumMiddleDays(numMiddleDays);
        _trvExpPerDiemDataContract.parmNumDays(numDays);

        return _trvExpPerDiemDataContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePerDiemHoursAndDaysForFullDayHourCalculation</Name>
				<Source><![CDATA[
    private TrvExpPerDiemDataContract calculatePerDiemHoursAndDaysForFullDayHourCalculation(TrvExpPerDiemDataContract _trvExpPerDiemDataContract)
    {
        const int hoursInADay = 24;
        real hrsFirstDay = _trvExpPerDiemDataContract.parmHoursFirstDay();
        real hrsLastDay = _trvExpPerDiemDataContract.parmHoursLastDay();
        int numMiddleDays = _trvExpPerDiemDataContract.parmNumMiddleDays();
        real numdays = _trvExpPerDiemDataContract.parmNumDays();
        boolean isTrvPerdiemsFullDayHourFlightEnabled =
                TrvExpenseHelper::isTrvPerdiemsFullDayHourFlightEnabled();

        if (this.isFullDayPerDiemCalculation(_trvExpPerDiemDataContract.parmTrvParameters().PerDiemCalculation))
        {
            // calculate the total of hours in the trip, including first and last day.
            int numHours = hrsFirstDay + (numMiddleDays * hoursInADay) + hrsLastDay;
            if (numHours >= hoursInADay)
            {
                // Calculate number of full days based on 24h setup
                numDays = real2int(numHours / hoursInADay);

                // if total hours in the trip is more than 24h, set first day hours to 24 hour
                hrsFirstDay = isTrvPerdiemsFullDayHourFlightEnabled ? hoursInADay : 0;
                hrsLastDay = numHours - (numdays * hoursInADay);

                if (numHours > hoursInADay && hrsLastDay > 0)
                {
                    // If there are hours in the last day, count it as another partial day.
                    numDays++;
                }
                // if trip has multiple days and total hours in the trip is multiple of 24h, set last day hours to 24 hour
                if(isTrvPerdiemsFullDayHourFlightEnabled && numDays > 1 && hrsLastDay == 0)
                {
                    hrsLastDay = hoursInADay;
                }
            }
            else
            {
                // If the total of hours in the trip is less than a day:
                hrsFirstDay = numHours;
                hrsLastDay = 0;
                numDays = 1;
            }
        }

        _trvExpPerDiemDataContract.parmHoursFirstDay(hrsFirstDay);
        _trvExpPerDiemDataContract.parmHoursLastDay(hrsLastDay);
        _trvExpPerDiemDataContract.parmNumMiddleDays(numMiddleDays);
        _trvExpPerDiemDataContract.parmNumDays(numDays);

        return _trvExpPerDiemDataContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFullDayPerDiemCalculation</Name>
				<Source><![CDATA[
    private boolean isFullDayPerDiemCalculation(TrvPerDiemCalculation _perDiemCalculation)
    {
        return (_perDiemCalculation == TrvPerDiemCalculation::FullDayHourPeriod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInsertPerDiemDataLines</Name>
				<Source><![CDATA[
    private boolean canInsertPerDiemDataLines()
    {
        return (this.ExpType == TrvExpType::Allowance && this.DateFrom && this.DateTo && this.TrvLocations);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeExpensePerDiemContract</Name>
				<Source><![CDATA[
    private TrvExpPerDiemDataContract initializeExpensePerDiemContract()
    {
        TrvParameters trvParameters = TrvParameters::find();
        CurrencyCode perDiemCurrency = TrvPerDiems::getPerDiemCurrency(this.TrvLocations, this.DateFrom, this.DateTo);
        TrvExpPerDiemDataContract trvExpPerDiemDataContract = new TrvExpPerDiemDataContract();

        trvExpPerDiemDataContract.parmDateFrom(this.DateFrom);
        trvExpPerDiemDataContract.parmDateTo(this.DateTo);
        trvExpPerDiemDataContract.parmTrvParameters(trvParameters);
        trvExpPerDiemDataContract.parmTrvCurrency(perDiemCurrency);
        trvExpPerDiemDataContract.parmLegalEntity(this.LegalEntity);
        trvExpPerDiemDataContract.parmExpenseTransRecId(this.RecId);

        return trvExpPerDiemDataContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditCardTransCurDiffThanCompanyCur</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the credit card transaction currency and the accounting currency are different.
    /// </summary>
    /// <returns>
    ///     true if the credit card transaction currency and the accounting currency are different, false otherwise.
    /// </returns>
    public boolean isCreditCardTransCurDiffThanCompanyCur()
    {
        return this.isCreditCardTransaction() && (this.CreditCardTransactionCurrency != Ledger::accountingCurrency(this.LegalEntity));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllowedToDuplicate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if current expense line is allowed to duplicate
    /// </summary>
    /// <returns>
    ///     Boolean value that indicates whether the expense line is allowed to duplicate
    /// </returns>
    public boolean isAllowedToDuplicate()
    {
        boolean         isAllowedToDuplicate = true;
        
        if (this.RecId == 0)
        {
            isAllowedToDuplicate = checkFailed(strFmt("@Expense:SaveLineBeforeDuplicating", this.CostType, this.TransDate, this.AmountMST));
        }

        if (this.pbsRecId != 0)
        {
            isAllowedToDuplicate = checkFailed(strFmt("@Expense:CannotCopyCreditCardTransaction", this.CostType, this.TransDate, this.AmountMST));
        }

        if (this.CashAdvanceRecId !=0)
        {
            isAllowedToDuplicate =  checkFailed(strFmt("@Expense:CannotCopyCashAdvance", this.CostType, this.TransDate, this.AmountMST));
        }

        if (this.LineType == TrvExpLineType::ItemizedLine)
        {
            return false;
        }

        if (this.SplitLineType == TrvExpSplitLineType::SplitLine)
        {
            return false;
        }

        if (this.LineType == TrvExpLineType::ItemizedHeader)
        {
            info(strFmt("@Expense:WillNotCopyItemizations", this.CostType, this.TransDate, this.AmountMST));
        }

        if (this.SplitLineType == TrvExpSplitLineType::SplitHeader)
        {
            info(strFmt("@Expense:WillNotCopySplitLines", this.CostType, this.TransDate, this.AmountMST));
        }

        return isAllowedToDuplicate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetCheckDone</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if budget check was performed for the expense line.
    /// </summary>
    /// <returns>
    ///     true if budget check was performed, false otherwise.
    /// </returns>
    display boolean isBudgetCheckDone()
    {
        boolean ret = false;

        if (this.SourceDocumentLine)
        {
            ret = BudgetSourceSourceDocumentLine::existBudgetSource(this.SourceDocumentLine);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetCheckRequired</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if budget check is needed for the expense line.
    /// </summary>
    /// <returns>
    ///     true if budget check is needed, false otherwise.
    /// </returns>
    public boolean isBudgetCheckRequired()
    {
        if (this.LineType == TrvExpLineType::ItemizedHeader
            || this.SplitLineType == TrvExpSplitLineType::SplitHeader)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetFailed</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the expense line has GL budget status of failed.
    /// </summary>
    /// <returns>
    ///     true if GL budget check failed on the expense line, false otherwise.
    /// </returns>
    display boolean isBudgetFailed()
    {
        BudgetSource        budgetSource;
        TrvExpTrans         trvExpTransItemizedLines;
        BudgetCheckResult   budgetCheckResult;

        if (this.LineType != TrvExpLineType::ItemizedHeader)
        {
            budgetCheckResult = BudgetSourceSourceDocumentLine::findBudgetCheckResult(this.SourceDocumentLine);
        }
        else
        {
            select maxof(CheckResult) from budgetSource
                join SourceDocumentLine, RecId from trvExpTransItemizedLines
                    where budgetSource.SourceDocumentLine == trvExpTransItemizedLines.SourceDocumentLine
                        && budgetSource.BudgetSourceType == BudgetSourceType::SourceDocumentLine
                        && budgetSource.BudgetTransactionLine == 0
                        && budgetSource.LedgerEntryGeneralJournalEntry == 0
                        && budgetSource.LedgerEntryJournalNumber == ''
                        && budgetSource.LedgerEntryJournalReferenceNumber == ''
                        && budgetSource.LedgerEntryJournalLegalEntity == 0
                        && trvExpTransItemizedLines.ParentRecId == this.RecId;

            budgetCheckResult = budgetSource ? budgetSource.CheckResult : BudgetCheckResult::NoCheck;
        }

        return (budgetCheckResult == BudgetCheckResult::Failed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCategoryIntegratedWithProject</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates if the category on the expense line, is integrated with project.
    /// </summary>
    /// <returns>
    ///     True if the expense line category is integrated with project, false otherwise.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display boolean isCategoryIntegratedWithProject()
    {
        return CategoryTable::find(this.CostType).UseInProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditCardAndCompanyCurrencyDifferent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the credit card currency and the accounting currency are different.
    /// </summary>
    /// <returns>
    /// true if the credit card currency and the accounting currency are different, false otherwise.
    /// </returns>
    [SysClientCacheDataMethodAttribute(false)]
    display boolean isCreditCardAndCompanyCurrencyDifferent()
    {
        return this.isCreditCardTransaction() && this.ExchangeCode != Ledger::accountingCurrency(this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditCardTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the transaction is a credit card transaction.
    /// </summary>
    /// <returns>
    /// true if the transaction is a credit card transaction, false otherwise.
    /// </returns>
    [SysClientCacheDataMethodAttribute(false)]
    display boolean isCreditCardTransaction()
    {
        TrvExpTrans expTransParent;

        if (this.LineType == TrvExpLineType::ItemizedLine || this.SplitLineType == TrvExpSplitLineType::SplitLine)
        {
            expTransParent = TrvExpTrans::find(this.ParentRecId);
            return expTransParent.isCreditCardTransaction();
        }
        else
        {
            return (this.pbsRecId != 0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditCardTransanctionInLocalCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the credit card transaction occurred in a currency different from the credit card currency.
    /// </summary>
    /// <returns>
    /// true if the credit card transaction occured in a currency different from the credit card currency, false otherwise.
    /// </returns>
    display boolean isCreditCardTransanctionInLocalCurrency()
    {
        TrvExpTrans expTransParent;

        if (this.LineType == TrvExpLineType::ItemizedLine || this.SplitLineType == TrvExpSplitLineType::SplitLine)
        {
            expTransParent = TrvExpTrans::find(this.ParentRecId);
            return expTransParent.isCreditCardTransanctionInLocalCurrency();
        }
        else
        {
            return (this.pbsRecId && this.CreditCardTransactionCurrencyAmount != 0 && this.CreditCardTransactionCurrency != this.ExchangeCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDistributed</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the expense line has been distributed.
    /// </summary>
    /// <returns>
    ///     true if the expense line has more than one distribution, false otherwise.
    /// </returns>
    display boolean isDistributed()
    {
        AccountingDistribution accountingDistribution;

        select count(RecVersion) from accountingDistribution
            where accountingDistribution.SourceDocumentLine == this.SourceDocumentLine;

        return accountingDistribution.RecVersion > 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDistributionsCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the expense line is fully distributed.
    /// </summary>
    /// <returns>
    ///     true if the expense line is fully distributed, false otherwise.
    /// </returns>
    public boolean isDistributionsCompleted()
    {
        return SourceDocumentLine::find(this.SourceDocumentLine).AccountingStatus == SourceDocumentLineAccountingStatus::FullyDistributed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDistributionsEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether distributions should be enabled for the current expense line.
    /// </summary>
    /// <returns>
    ///     true if distributions should be enabled, false otherwise.
    /// </returns>
    /// <remarks>
    ///     We disable distributions for unattached expenses, personal expenses paid by employee, itemized headers and when the amount is zero.
    /// </remarks>
    display boolean isDistributionsEnabled()
    {
        if (!this.TrvExpTable
           || (this.RecId != 0 && this.AmountCurr == 0)  // we do not check for amount being zero in insert mode
           || (this.ExpType == TrvExpType::Personal && TrvParameters::find().PersonalPaidBy == TrvPersonalPaidBy::Employee)
           || this.LineType == TrvExpLineType::ItemizedHeader
           || this.SplitLineType == TrvExpSplitLineType::SplitHeader)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEditable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether the current expense transaction is editable depending on the workflow status.
    /// </summary>
    /// <param name="_checkUserAccess">
    /// Boolean value that indicates if we check if the user has access to edit the document.
    /// </param>
    /// <param name="_splitLineTypeCheck">
    /// Boolean value that indicates if we check for the split line type.
    /// </param>
    /// <returns>
    /// true if status is either Create (Not Submitted) or Returned, and the user has access to the document; false otherwise.
    /// </returns>
    public display boolean isEditable(boolean _checkUserAccess = true, boolean _splitLineTypeCheck = true)
    {
        if (_splitLineTypeCheck && this.SplitLineType == TrvExpSplitLineType::SplitHeader)
        {
            return false;
        }

        switch (this.ApprovalStatus)
        {
            case TrvAppStatus::Approved:
            case TrvAppStatus::Cancelled:
            case TrvAppStatus::Ledger:
            case TrvAppStatus::Pending:
            case TrvAppStatus::Submitted:
            case TrvAppStatus::Ready:
            case TrvAppStatus::None:
            case TrvAppStatus::Matched:
                return false;
        }

        return _checkUserAccess ? TrvAccessHelper::canCreateNewTransactions(this.CreatingWorker) : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGuestType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if an expense is allowed to have guests.
    /// </summary>
    /// <returns>
    /// True if expense type allows guests to be added, false otherwise.
    /// </returns>
    public display boolean isGuestType()
    {
        switch (this.ExpType)
        {
            case TrvExpType::Meals:
            case TrvExpType::Entertainment:
            case TrvExpType::Gift:
                return true && this.LineType != TrvExpLineType::ItemizedLine;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the expense is intercompany.
    /// </summary>
    /// <returns>
    /// true if this is an intercompany transaction; false otherwise.
    /// </returns>
    public boolean isIntercompany()
    {
        return (this.InterCompanyLE && this.InterCompanyLE != this.ReferenceDataAreaId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIntercompanyWithProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the expense is intercompany and with project.
    /// </summary>
    /// <returns>
    /// true if this is an intercompany transaction with project; false otherwise.
    /// </returns>
    public boolean isIntercompanyWithProject()
    {
        return this.isIntercompany() && this.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemizedLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the expense line is itemized
    /// </summary>
    /// <returns>
    /// true if the expense line has been itemized, false otherwise.
    /// </returns>
    public boolean isItemizedLine()
    {
        return (this.LineType == TrvExpLineType::ItemizedLine) ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemizable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the expense line is itemizable.
    /// </summary>
    /// <returns>
    ///     True if the expense line is itemizable, false otherwise.
    /// </returns>
    display boolean isItemizable()
    {
        return (this.LineType != TrvExpLineType::ItemizedLine
            && TrvExpenseType::supportsItemization(this.ExpType)
            && TrvCostType::numberOfExpSubCategories(this.CostType) > 0
            && this.SplitLineType != TrvExpSplitLineType::SplitHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjBudgetFailed</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the expense line has project budget status of failed.
    /// </summary>
    /// <returns>
    ///     true if project budget check failed on the expense line, false otherwise.
    /// </returns>
    display boolean isProjBudgetFailed()
    {
        return (ProjBudgetStatus::findBySourceDocumentLine(this.SourceDocumentLine).BudgetCheckResult == ProjBudgetCheckResult::Failed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSplittable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether the current expense line can be split to personal
    /// </summary>
    /// <returns>
    /// true if expense line can be split; otherwise, false.
    /// </returns>
    /// <remarks>
    /// An expense line can be split to personal if it is an imported credit card transaction, not already itemized,
    /// the category does not mandate itemization, and there are personal categories for the payment method.
    /// </remarks>
    display boolean isSplittable()
    {
        boolean isSplittable = false;
        boolean itemized = this.LineType == TrvExpLineType::ItemizedLine ||
            (this.LineType == TrvExpLineType::ItemizedHeader && this.IsSplit == NoYes::No);

        if (this.isCreditCardTransaction() &&
            !itemized &&
            TrvCostType::find(this.CostType).IsItemizationMandatory == NoYes::No &&
            TrvPersonalExpenseHelper::numberOfPersonalCategories(this.PayMethod) > 0)
        {
            isSplittable = true;
        }

        return isSplittable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPersonalExpensePaidByEmployee</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Checks whether the personal expense amount is paid by employee.
    /// </summary>
    /// <returns>
    ///  True if the personal expense is paid by employee; otherwise, false.
    /// </returns>
    public boolean isPersonalExpensePaidByEmployee()
    {
        return (this.ExpType == TrvExpType::Personal && TrvParameters::find().PersonalPaidBy == TrvPersonalPaidBy::Employee);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxApplicable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether tax is applicable for this expense line
    /// </summary>
    /// <returns>
    ///     true if tax is applicable, false otherwise.
    /// </returns>
    /// <remarks>
    ///     Tax is not applicable for cash advance return, personal expense.
    ///     Tax is not applicable for itemized line with sub category, which is excluded from tax.
    /// </remarks>
    [SysClientCacheDataMethodAttribute(true)]
    display boolean isTaxApplicable()
    {
        boolean             isTaxApplicable = true;
        TrvExpSubCategory   trvExpSubCategory;

        if ( this.ExpType == TrvExpType::Advance ||
            this.isPersonalExpensePaidByEmployee() ||
            this.SplitLineType == TrvExpSplitLineType::SplitHeader)
        {
            isTaxApplicable = false;
        }
        else if (this.LineType==TrvExpLineType::ItemizedLine && this.SubCategoryRecId)
        {
            select firstonly * from trvExpSubCategory where trvExpSubCategory.RecId == this.SubCategoryRecId;
            if (trvExpSubCategory.RecId && trvExpSubCategory.excludeFromRecovery())
            {
                isTaxApplicable = false;
            }
        }

        return isTaxApplicable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxFieldsMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the tax fields are mandatory.
    /// </summary>
    /// <returns>
    ///     true whether the tax fields are mandatory, false otherwise.
    /// </returns>
    boolean isTaxFieldsMandatory()
    {
        TrvExpSubCategory trvExpSubCategory;

        if ( this.isPersonalExpensePaidByEmployee() ||
             this.ExpType == TrvExpType::Advance    ||
             this.SplitLineType == TrvExpSplitLineType::SplitHeader)
        {
            return false;
        }
        else if (this.LineType == TrvExpLineType::ItemizedLine && this.SubCategoryRecId)
        {
            select firstonly * from trvExpSubCategory where trvExpSubCategory.RecId == this.SubCategoryRecId;
            if (trvExpSubCategory.excludeFromRecovery())
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxRecoverable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the expense line tax is recoverable.
    /// </summary>
    /// <returns>
    /// true if the expense line tax is recoverable, false otherwise.
    /// </returns>
    display TrvTaxRecoverable isTaxRecoverable()
    {
        TrvExpSubCategory trvExpSubCategory;

        if ( this.ExpType == TrvExpType::Advance   ||
            this.isPersonalExpensePaidByEmployee() ||
            this.LineType == TrvExpLineType::ItemizedHeader ||
            this.SplitLineType == TrvExpSplitLineType::SplitHeader)
        {
            return NoYes::No;
        }

        if (TrvParametersTableHelper::isTaxRecoveryEnabled(TrvParameters::find()))
        {
            if (this.LineType==TrvExpLineType::ItemizedLine)
            {
                select firstonly * from trvExpSubCategory where trvExpSubCategory.RecId == this.SubCategoryRecId;
                if (trvExpSubCategory.RecId && trvExpSubCategory.excludeFromRecovery())
                {
                    return NoYes::No;
                }
            }

            return NoYes::Yes;
        }

        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionAndCompanyCurrencyDifferent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the transaction currency and the accounting currency are different.
    /// </summary>
    /// <returns>
    /// true if the transaction currency and the accounting currency are different, false otherwise.
    /// </returns>
    [SysClientCacheDataMethodAttribute(false)]
    display boolean isTransactionAndCompanyCurrencyDifferent()
    {
        return this.ExchangeCode != Ledger::accountingCurrency(this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMatchingWithIntercompanyLegalEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether a given legal entity is matching with expense intercommpany legal entity.
    /// </summary>
    /// <param name = "_intercompanyLegalEntity">Intercompany legal entity.</param>
    /// <returns>True if a given legal entity matches with the intercompany legal entity of this expense; otherwise, false.</returns>
    protected boolean isMatchingWithIntercompanyLegalEntity(SelectableDataArea _legalEntity)
    {
        return _legalEntity == this.InterCompanyLE;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemizationStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value indicating the itemization status.
    /// </summary>
    /// <returns>
    /// The itemization status.
    /// </returns>
    display TrvExpItemizationStatus itemizationStatus()
    {
        TrvExpTrans     expTrans;
        Amount          totalAmount = 0;
        boolean         hasItemizedLines = false;

        if (this.LineType == TrvExpLineType::ItemizedHeader && TrvExpenseType::supportsItemization(this.ExpType))
        {
            if (this.RecId != 0)
            {
                // If the transaction was done in a currency different than the credit card currency (for credit card expenses), the exact itemized line
                // amounts are stored in CreditCardTransactionCurrencyAmount field.
                if (this.isCreditCardTransanctionInLocalCurrency())
                {
                    select count(RecId), sum(CreditCardTransactionCurrencyAmount) from expTrans where expTrans.ParentRecId == this.RecId;
                    totalAmount = expTrans.CreditCardTransactionCurrencyAmount;
                }
                // In all other cases, CreditCardTransactionCurrencyAmount = AmountCurr for itemized lines.
                else
                {
                    select count(RecId), sum(AmountCurr) from expTrans where expTrans.ParentRecId == this.RecId;
                    totalAmount = expTrans.AmountCurr;
                }

                // RecId is a count aggregate column
                hasItemizedLines = expTrans.RecId > 0;
            }

            if (!hasItemizedLines)
            {
                return this.checkItemizationStatusNoLines();
            }

            // If the transaction was done in a currency different than the credit card currency (for credit card expenses),
            // then the itemization total must be compared against the CreditCardTransactionCurrencyAmount of the header.
            // In all other cases, compare against the AmountCurr.
            if ((!this.isCreditCardTransanctionInLocalCurrency() && this.AmountCurr == totalAmount) ||
                (this.isCreditCardTransanctionInLocalCurrency() && this.CreditCardTransactionCurrencyAmount == totalAmount))
            {
                return TrvExpItemizationStatus::Completed;
            }
            else
            {
                return TrvExpItemizationStatus::Incomplete;
            }
        }

        if (this.LineType == TrvExpLineType::Default
            && TrvExpenseType::supportsItemization(this.ExpType))
        {
            return this.checkItemizationStatusNoLines();
        }

        return TrvExpItemizationStatus::NotApplicable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemizationStatusNoLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the itemization status for a line when no itemized lines exist for the expense.
    /// </summary>
    /// <returns>The itemization status of the line.</returns>
    private TrvExpItemizationStatus checkItemizationStatusNoLines()
    {
        TrvCostType trvCostType = TrvCostType::find(this.CostType);

        // recheck category to determine if itemization is necessary
        if (trvCostType.IsItemizationMandatory)
        {
            if (this.ExpNumber)
            {
                // only apply an itemization is incomplete when the line hasn't been approved
                TrvAppStatus approvalStatus = TrvExpTable::find(this.ExpNumber).ApprovalStatus;
                if (approvalStatus != TrvAppStatus::Approved && approvalStatus != TrvAppStatus::Ledger)
                {
                    return TrvExpItemizationStatus::Incomplete;
                }
            }
            else
            {
                return TrvExpItemizationStatus::Incomplete;
            }
        }

        return TrvExpItemizationStatus::NoItemizedLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value indicating the itemization status.
    /// </summary>
    /// <returns>
    /// The itemization status.
    /// </returns>
    display TrvExpSplitStatus splitStatus()
    {
        TrvExpTrans     expTrans;
        Amount          totalAmount = 0;
        boolean         hasSplitLines = false;

        if (this.SplitLineType == TrvExpSplitLineType::SplitHeader && this.PBSRecId != 0)
        {
            if (this.RecId != 0)
            {
                // If the transaction was done in a currency different than the credit card currency (for credit card expenses), the exact itemized line
                // amounts are stored in CreditCardTransactionCurrencyAmount field.
                if (this.isCreditCardTransanctionInLocalCurrency())
                {
                    select count(RecId), sum(CreditCardTransactionCurrencyAmount) from expTrans where expTrans.ParentRecId == this.RecId;
                    totalAmount = expTrans.CreditCardTransactionCurrencyAmount;
                }
                // In all other cases, CreditCardTransactionCurrencyAmount = AmountCurr for itemized lines.
                else
                {
                    select count(RecId), sum(AmountCurr) from expTrans where expTrans.ParentRecId == this.RecId;
                    totalAmount = expTrans.AmountCurr;
                }

                // RecId is a count aggregate column
                hasSplitLines = expTrans.RecId > 0;
            }

            if (!hasSplitLines)
            {
                return TrvExpSplitStatus::NoSplitLines;
            }

            // If the transaction was done in a currency different than the credit card currency (for credit card expenses),
            // then the itemization total must be compared against the CreditCardTransactionCurrencyAmount of the header.
            // In all other cases, compare against the AmountCurr.
            if ((!this.isCreditCardTransanctionInLocalCurrency() && this.AmountCurr == totalAmount) ||
                (this.isCreditCardTransanctionInLocalCurrency() && this.CreditCardTransactionCurrencyAmount == totalAmount))
            {
                return TrvExpSplitStatus::Completed;
            }
            else
            {
                return TrvExpSplitStatus::Incomplete;
            }
        }
    
        return TrvExpSplitStatus::NotApplicable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>localCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transaction currency corresponding to current itemized line.
    /// </summary>
    /// <returns>
    /// Currency code of transaction currency.
    /// </returns>
    /// <remarks>
    /// Determines this by looking at the <c>TrvPBSMaindata</c> record that corresponds to
    /// the itemized header line.
    /// </remarks>
    display CurrencyCode localCurrency()
    {
        TrvPBSMaindata trvPBSMaindata;
        TrvExpTrans trvExpTrans;
        TrvExpTrans splitHeader;

        // pull local currency code from corresponding TrvPBSMainData row
        if ( this.LineType == TrvExpLineType::ItemizedLine )
        {
            if (this.SplitLineType != TrvExpSplitLineType::SplitLine)
            {
                select firstonly RecId, pbsRecId from trvExpTrans
                    where trvExpTrans.RecId == this.ParentRecId
                    join ExchCodeLocal, RecId from trvPBSMaindata where trvPBSMaindata.RecId == trvExpTrans.pbsRecId;
            }
            else
            {
                select firstonly RecId, ParentRecId from trvExpTrans
                    where trvExpTrans.RecId == this.ParentRecId
                join PBSRecId, RecId from splitHeader
                    where splitHeader.RecId == trvExpTrans.ParentRecId
                join ExchCodeLocal, RecId from trvPBSMaindata
                    where trvPBSMaindata.RecId == splitHeader.PBSRecId;
            }
        }
        else if ( this.LineType == TrvExpLineType::ItemizedHeader )
        {
            if (this.SplitLineType != TrvExpSplitLineType::SplitLine)
            {
                select firstonly RecId, ExchCodeLocal from trvPBSMaindata
                    where trvPBSMaindata.RecId == this.pbsRecId;
            }
            else
            {
                select firstonly RecId,PBSRecId from trvExpTrans
                    where TrvExpTrans.RecId == this.ParentRecId
                join ExchCodeLocal, RecId from trvPBSMaindata
                    where trvPBSMaindata.RecId == trvExpTrans.PBSRecId;
            }
        }

        if ( trvPBSMaindata.RecId != 0 )
        {
            return trvPBSMaindata.ExchCodeLocal;
        }
        else
        {
            return this.ExchangeCode;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapToRequisitionLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Maps the expense line to a travel requisition line.
    /// </summary>
    public void mapToRequisitionLine()
    {
        TrvRequisitionLine  trvRequisitionLine;
        RefRecId            trvRequisitionTableRecId;
        AmountMST           amountToBeReconciled;

        if (this.MappedToRequisitionLine)
        {
            trvRequisitionTableRecId = TrvRequisitionLine::find(this.MappedToRequisitionLine).TrvRequisitionTable;

            trvRequisitionLine = TrvRequisitionLine::find(this.MappedToRequisitionLine);
            amountToBeReconciled = trvRequisitionLine.amountToBeReconciled(this.RecId);

            if (this.AmountMST > amountToBeReconciled)
            {
                this.AccountingCurrencyReconciledAmount = amountToBeReconciled ;
            }
            else
            {
                this.AccountingCurrencyReconciledAmount = this.AmountMST;
            }
        }
        else
        {
            this.AccountingCurrencyReconciledAmount = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrvExpTransSplit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the split table record linked to this expense.
    /// </summary>
    /// <param name = "_expenseSplitRecId">Expense line recid</param>
    public void updateTrvExpTransSplit(RefRecId _expenseSplitRecId)
    {
        TrvExpTransSplit  relatedSplitLine = TrvExpTransSplit::findRelatedSplitLine(_expenseSplitRecId, true);

        if (relatedSplitLine.RecId)
        {
            relatedSplitLine.initFromTrvExpTrans(this, relatedSplitLine);
        
            relatedSplitLine.SplitAmount = this.CreditCardTransactionCurrencyAmount;

            TrvTransactionCurrencyAmount splitHeaderTotal = this.splitHeaderAmount(this.ParentRecId);

            if (splitHeaderTotal != 0)
            {
                relatedSplitLine.SplitAllocationFactor = (this.CreditCardTransactionCurrencyAmount / splitHeaderTotal) * 100;
            }

            relatedSplitLine.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitHeaderAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the credit card transaction amount for a given expense line recid.
    /// </summary>
    /// <param name = "_splitHeaderRecId">
    /// Expense line recid.
    /// </param>
    /// <returns>
    /// Get the credit card transaction amount.
    /// </returns>
    public TrvTransactionCurrencyAmount splitHeaderAmount(RefRecId _splitHeaderRecId)
    {
        TrvExpTrans splitHeader;

        select CreditCardTransactionCurrencyAmount from splitHeader
            where splitHeader.RecId == _splitHeaderRecId;

        return splitHeader.CreditCardTransactionCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExpenseSubCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the expense sub category is active
    /// </summary>
    /// <returns>true if the expense sub category is active; otherwise, false.</returns>
    private boolean validateExpenseSubCategory()
    {
        TrvSharedSubCategory trvSharedSubCategory;
        TrvExpSubCategory trvExpSubCategory;

        select firstonly RecId, Name from trvSharedSubCategory
            exists join trvExpSubCategory
                where trvExpSubCategory.RecId == this.SubCategoryRecId &&
                      trvExpSubCategory.IsInactive == NoYes::Yes &&
                      trvSharedSubCategory.RecId == trvExpSubCategory.TrvSharedSubCategory;

        if (trvSharedSubCategory.RecId)
        {
            return checkFailed(strFmt("@Expense:SubCategoryIsInactive", trvSharedSubCategory.Name));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldExchCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// The modifiedField method for exchange code field which allows user to specify
    /// whether exceptions should be thrown or ignored.
    /// </summary>
    /// <param name = "_throwException">True if exceptions should be thrown, false otherwise.</param>
    public void modifiedFieldExchCode(boolean _throwException)
    {
        // Avoid re-calculating exchange rate for credit card expenses.
        if (!this.isCreditCardTransaction())
        {
            this.exchrate(_throwException);
        }
        this.amountMST();
        this.setCorrectedTaxAmountMST();
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {
        boolean isPerDiemEnabled = ExpensePerdiemHelper::isPerDiemEnabled();
        super(_fieldId);

        switch (_fieldId)
        {
            case (fieldNum(TrvExpTrans,DateFrom)):
                // Set the TransDate value
                if (this.ExpType == TrvExpType::Allowance)
                {
                    this.TransDate = DateTimeUtil::date(this.DateFrom);
                    if (this.DateFrom != this.orig().DateFrom || isPerDiemEnabled)
                    {
                        this.perDiem(true);
                    }
                }
                if (this.ExpType == TrvExpType::Transport)
                {
                    this.calcKM();
                }
                break;

            case (fieldNum(TrvExpTrans,DateTo)):
                if (this.ExpType == TrvExpType::Allowance)
                {
                    if (this.DateTo != this.orig().DateTo || isPerDiemEnabled)
                    {
                        this.perDiem(true);
                    }
                }
                break;

            case (fieldnum(TrvExpTrans,CostType)):
                TrvCostType newCostType = TrvCostType::find(this.CostType);
                TrvExpType  oldExpType  = this.ExpType;

                if (newCostType.ExpType != oldExpType)
                {
                    this.clearCommonFieldsNotApplicable(newCostType.ExpType);
                }

                this.handleItemizableCategory(true);

                //if ProjId is already populated, reset the data based on Category-Project setup
                //else select default project from expense header
                if (this.ProjId &&
                    this.isCategoryIntegratedWithProject() &&
                    TrvExpTrans::checkWorkerCategory(this.CreatingWorker, this.CostType, this.isIntercompany(), false, this.LegalEntity))
                {
                    this.setValuesOnProjIdModified();
                }
                else
                {
                    this.setDefaultProjectFromExpenseReport();
                }
                this.initFromCostType();
                this.initializeInterCompanyCategory();

                if (this.ExpType == TrvExpType::Advance)
                {
                    // Cannot get the cash from one company and trying to return to another.
                    this.InterCompanyLE = this.ReferenceDataAreaId;

                    if (!this.CashAdvanceRecId)
                    {
                        TrvReturnCashHelper::defaultCashAdvanceToReturn(this);
                    }
                }
                else if (this.expType == TrvExpType::Personal)
                {
                    // Forces the deletion of any distribution lines that are no longer needed
                    this.reinitializeSourceDocumentLine();
                }

                this.setTaxItemGroup();
                this.updateNetTransactionAmount();
                this.setCorrectedTaxAmountMST();
                break;

            case (fieldNum(TrvExpTrans, BillIssuedTo)):
                this.setTaxItemGroup();
                this.updateNetTransactionAmount();
                this.setCorrectedTaxAmountMST();
                break;

            case (fieldNum(TrvExpTrans,AmountCurr)):
                this.amountMST();
                if (this.setItemizedLineCorrectedTaxAmount())
                {
                    this.updateNetTransactionAmount(true);
                }
                else
                {
                    this.updateNetTransactionAmount();
                }
                this.setCorrectedTaxAmountMST();
                break;

            case (fieldNum(TrvExpTrans, CreditCardTransactionCurrencyAmount)):
                this.updateAmountCurrFromCreditCardAmount();
                this.amountMST();
                this.setCorrectedTaxAmountMST();
                break;

            case (fieldNum(TrvExpTrans,PayMethod)):
                this.updateCostOwner();
                this.updateExpCashAdvanceMap();
                break;

            case (fieldNum(TrvExpTrans, ExpNumber)):
                this.updateExpenseReport(this.ExpNumber);
                break;

            case (fieldNum(TrvExpTrans,ExchangeCode)):
                this.modifiedFieldExchCode(false);
                break;

            case (fieldNum(TrvExpTrans,ExchangeRate)):
                this.amountMST();
                this.setCorrectedTaxAmountMST();
                break;

            case (fieldNum(TrvExpTrans,kmOwnCar)):
                this.calcKM();
                break;

            case (fieldNum(TrvExpTrans, SubCategoryRecId)):
                this.setTaxItemGroup();
                break;

            case (fieldNum(TrvExpTrans, TaxIncluded)):
                this.updateNetTransactionAmount();
                this.setCorrectedTaxAmountMST();
                break;

            case (fieldNum(TrvExpTrans, TaxGroup)):
            case (fieldNum(TrvExpTrans, TaxItemGroup)):
                if (this.setItemizedLineCorrectedTaxAmount())
                {
                    this.updateNetTransactionAmount(true);
                }
                else
                {
                    this.updateNetTransactionAmount();
                }
                this.setCorrectedTaxAmountMST();
                break;

            case (fieldNum(TrvExpTrans, CorrectedTaxAmount)):
                this.updateNetTransactionAmount(true);
                this.setCorrectedTaxAmountMST();
                break;

            case (fieldNum(TrvExpTrans, CountryRegion)):

                if (this.CountryRegion != this.orig().CountryRegion)
                {
                    this.AddressState = '';
                    this.AddressZipCode = 0;
                    this.AddressCity = 0;
                    this.City = '';
                }

                this.setTaxGroup();
                this.updateNetTransactionAmount();
                this.setCorrectedTaxAmountMST();
                break;

            case (fieldNum(TrvExpTrans, AddressState)):
                this.setTaxGroup();
                this.updateNetTransactionAmount();
                this.setCorrectedTaxAmountMST();
                break;

            case (fieldNum(TrvExpTrans, ProjId)):
                this.setValuesOnProjIdModified();
                break;

            case (fieldnum(TrvExpTrans, InterCompanyLE)):
                // Reset exchange rate
                this.modifiedFieldExchCode(false);
                
                // clear intercompany fields
                this.IntercompanyBilled = false;
                this.IntercompanySalesCurrency = '';
                this.IntercompanySalesPrice = 0.0;
                this.IntercompanyTransferCurrency = '';
                this.IntercompanyTransferPrice = 0.0;
                this.ProjId = '';
                this.TransactionText = '';

                this.setDefaultProjectFromExpenseReport();

                this.initializeInterCompanyCategory();
                this.modifiedField(fieldNum(TrvExpTrans, ProjId));
                break;

            case (fieldNum(TrvExpTrans, TransDate)):
                if (this.ExpType == TrvExpType::Transport)
                {
                    this.calcKM();
                }

                if (this.LineType != TrvExpLineType::ItemizedLine)
                {
                    this.modifiedFieldExchCode(false);
                }
                this.reinitializeSourceDocumentLine();

                break;

            case (fieldNum(TrvExpTrans, VehicleType)):
            case (fieldNum(TrvExpTrans, NumberOfPassengers)):
                if (this.ExpType == TrvExpType::Transport)
                {
                    this.calcKM();
                }
                break;

            case (fieldNum(TrvExpTrans, TrvLocations)):
                if (this.ExpType == TrvExpType::Allowance)
                {
                    this.perDiem(true);
                }
                break;

            case (fieldNum(TrvExpTrans, MappedToRequisitionLine)):
                TrvRequisitionLine trvRequisitionLine = TrvRequisitionLine::find(this.MappedToRequisitionLine);
                if (trvRequisitionLine.projTable)
                {
                    ProjTable projTable = ProjTable::findRecId(trvRequisitionLine.projTable);
                    if (projTable.projId)
                    {
                        this.projId = projTable.projId;
                    }
                }
                this.setDefaultDimension();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setValuesOnProjIdModified</Name>
				<Source><![CDATA[
    private void setValuesOnProjIdModified()
    {
        if (this.canSetTaxGroupOnProjIdModified())
        {
            this.TaxGroup = '';

            //By default IntercompanyLE; if IntercompanyLE is blank, current dataAreaID.
            LegalEntityDataAreaId legalEntity = this.legalEntityName();

            // If this is intercompany expense, reset Item tax group
            if (this.isIntercompany())
            {
                this.TaxItemGroup = '';
                
                //Since Tax obligation is destination (validated within canSetTaxGroupOnProjIdModified)
                // Change company context
                changecompany(legalEntity)
                {
                    this.setTaxItemGroup();
                }
            }

            if (this.isIntercompanyWithProject())
            {
                changeCompany(legalEntity)
                {
                    this.setTaxGroup();
                }
            }
            else
            {
                this.setTaxGroup();
            }
        }

        if (strLen(strLRTrim(this.ProjId)) == 0)
        {
            this.ProjStatusId = '';
            this.ProjTransId = '';
        }
        else
        {
            this.setProjectFields();
        }
        
        this.setDefaultDimension();
        
        this.ProjActivityNumber = '';

        if (this.setItemizedLineCorrectedTaxAmount())
        {
            this.updateNetTransactionAmount(true);
        }
        else
        {
            this.updateNetTransactionAmount();
        }
        this.setCorrectedTaxAmountMST();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSetTaxGroupOnProjIdModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to set tax group on ProjId modified.
    /// </summary>
    /// <returns>true if tax group has to set; otherwise, false.</returns>
    protected boolean canSetTaxGroupOnProjIdModified()
    {
        boolean ret = true;

        if (this.checkInterCompanyFieldModified() ||
            this.isIntercompany())
        {
            ret = this.isTaxObligationDestination();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCommonFieldsNotApplicable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Will reset the value on fields specific to a different expense type than the current one.
    /// The reason is that these expense types have their own logic to calculate these fields, even though they are common across all expenses.
    /// This method will be called upon category changing.
    /// </summary>
    /// <param name = "newExpenseType">New expense type taken from the updated cost type.</param>
    private void clearCommonFieldsNotApplicable(TrvExpType newExpenseType)
    {
        if (!this.isCreditCardTransaction())
        {
            this.PayMethod = '';
        }

        // Cash advanceRecid will be defaulted if needed, but on expense type change it should always be set to 0.
        this.CashAdvanceRecId = 0;

        // Airline
        this.TicketClass = '';
        this.TicketNumber = '';
        this.TicketUsed = NoYes::No;

        // Entertainment
        this.BusinessPurpose = '';
        this.EntertainmentLocation = '';

        // Hotel
        this.BillIssuedTo = TrvBillIssuedTo::Company;

        if (newExpenseType == TrvExpType::Advance || newExpenseType == TrvExpType::Allowance || newExpenseType == TrvExpType::Transport)
        {
            // Generic types
            this.MerchantId = '';
            this.ReceiptNumber = '';
            this.CreditCardTransactionCurrency = '';
            this.CreditCardTransactionCurrencyAmount = 0;
            this.AmountCurr = 0;
            this.AmountMST = 0;
            this.ExchangeCode = CompanyInfoHelper::standardCurrency();
            this.ExchangeRate = 100;

            // Mileage
            this.KMOwnCar = 0;
            this.KMPrice = 0;
            this.VehicleType = '';
            this.NumberOfPassengers = 0;
            this.MileageFromAddress = '';
            this.MileageToAddress = '';

            // Perdiem
            this.DateFrom = utcDateTimeNull();
            this.DateTo = utcDateTimeNull();
            this.TrvLocations = 0;
            this.Deduktion = 0;
            if (ExpensePerdiemHelper::isPerDiemEnabled())
            {
                this.PerDiemHotelAllowance = 0;
            }
            this.DeduktionBreakfest = 0;
            this.DeduktionLunch = 0;
            this.DeduktionDinner = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>needToUpdateReqReconciliationStatus</Name>
				<Source><![CDATA[
    private boolean needToUpdateReqReconciliationStatus(TrvExpTrans _originalTrvExpTrans)
    {
        return ((this.MappedToRequisitionLine               != _originalTrvExpTrans.MappedToRequisitionLine) ||
                (this.AccountingCurrencyReconciledAmount    != _originalTrvExpTrans.AccountingCurrencyReconciledAmount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRateDate</Name>
				<Source><![CDATA[
    public AccountingDate parmExchangeRateDate()
    {
        return this.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceDocumentLine</Name>
				<Source><![CDATA[
    public SourceDocumentLine parmParentSourceDocumentLine()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineTypeEnumName</Name>
				<Source><![CDATA[
    public EnumName parmSourceDocLineTypeEnumName()
    {
        return enumStr(SourceDocumentLine_ExpenseReport);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineTypeEnumValue</Name>
				<Source><![CDATA[
    public SourceDocumentTypeEnumValue parmSourceDocLineTypeEnumValue()
    {
        return SourceDocumentLine_ExpenseReport::ExpenseReportLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocumentHeader</Name>
				<Source><![CDATA[
    public SourceDocumentHeader parmSourceDocumentHeader()
    {
        SourceDocumentHeader sourceDocumentHeader;
        TrvExpTable trvExpTable;

        if (this.TrvExpTable)
        {
            select firstonly sourceDocumentHeader exists join trvExpTable
                where trvExpTable.SourceDocumentHeader == sourceDocumentHeader.RecId &&
                    trvExpTable.RecId == this.TrvExpTable;
        }

        return sourceDocumentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>percentOfParent</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the percent of the itemized line amount with respect to its parent amount.
    /// </summary>
    /// <returns>
    ///     The percent of the itemized line amount with respect to its parent amount
    /// </returns>
    display Percent percentOfParent()
    {
        TrvExpTrans     expTrans;

        if (this.ParentRecId)
        {
            select firstonly AmountCurr from expTrans where expTrans.RecId == this.ParentRecId;
        }

        return expTrans.AmountCurr ? (this.AmountCurr * 100)/expTrans.AmountCurr : 0.00;
    }

]]></Source>
			</Method>
			<Method>
				<Name>perDiem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the per diem total for the transaction and fills out the amount and currency fields.
    /// </summary>
    /// <param name="_implicitSave">
    ///  True if Expense line will save before creating per diem lines.
    /// </param>
    /// <remarks>
    /// If <c>DateFrom</c>, <c>DateTo</c>, or <c>Location</c> fields are not set, this method returns
    /// without setting anything.
    /// </remarks>
    public void perDiem(boolean _implicitSave = false)
    {
        TrvPartyEmployeeRelationship    trvPartyEmployeeRelationship;
        TrvPerDiems         trvPerDiems;
        TrvAllowanceRate    trvAllowanceRate, trvAllowanceRateAnyExist;
        TrvExpPerdiemData   trvExpPerdiemData;
        TrvParameters       trvParameters = TrvParameters::find();

        real    hrsFirstDay = 0;
        real    hrsLastDay = 0;
        real    numHours = 0;
        date    startMidnight;
        date    lastMidnight;
        int     numDaysWithAllowance;
        // Counts the number of days (Partial and Full days) based in 24h or calendar setup.
        int     numTotalDays = 0;
        real    mealAllowance;
        real    hotelAllowance;
        real    otherAllowance;
        real    expAmount;
        int     numberOfDaysCount;
        boolean firstLastSame = false;
        utcdatetime dateFrom;
        utcdatetime dateTo;
        utcdatetime startDateTo;
        real    mealReduction;
        boolean isMealReductionPerTrip = true;
        boolean isInserted = this.RecId;
        boolean isTrvPerdiemsFullDayHourFlightEnabled = 
                TrvExpenseHelper::isTrvPerdiemsFullDayHourFlightEnabled();
        const int hoursInADay = 24;

        // Only applies for per diems.
        if (this.ExpType != TrvExpType::Allowance)
        {
            return;
        }

        dateFrom = this.DateFrom;
        dateTo = this.DateTo;
        startDateTo = dateTo;

        if (!dateFrom || !dateTo || TrvCostType::find(this.CostType).ExpType != TrvExpType::Allowance)
        {
            this.AmountCurr = 0;
            return;
        }

        firstLastSame = (DateTimeUtil::date(dateFrom) == DateTimeUtil::date(dateTo));

        if (firstLastSame)
        {
            if (trvParameters.PerDiemCalculation == TrvPerDiemCalculation::CalendarDayNoTime)
            {
                hrsFirstDay = hoursInADay;
            }
            else
            {
                hrsFirstDay += DateTimeUtil::getDifference(dateTo, dateFrom)/3600;
            }

            // If the first day is the same as last day, the number of total days is 1.
            hrsLastDay = 0;
            numDaysWithAllowance = 0;
            numTotalDays = 1;
        }
        else
        {
            if (trvParameters.PerDiemCalculation == TrvPerDiemCalculation::CalendarDayNoTime)
            {
                hrsFirstDay = hoursInADay;
                hrsLastDay = hoursInADay;
            }
            else
            {
                hrsFirstDay = hoursInADay - DateTimeUtil::hour(dateFrom) - (DateTimeUtil::minute(dateFrom)/60);
                hrsLastDay = DateTimeUtil::hour(dateTo) + (DateTimeUtil::minute(dateTo)/60);
            }

            startMidnight = DateTimeUtil::date(DateTimeUtil::addDays(dateFrom, 1));
            lastMidnight = DateTimeUtil::date(dateTo);

            //number of full travel days, not counting first and last
            numDaysWithAllowance = lastMidnight - startMidnight;

            // If the first day is not the same as last day:
            // the number of total days is the count of days in the middle plus 2 days (first and last) this is using by default a calculation based on calendar days.
            numTotalDays = numDaysWithAllowance + 2;
        }

        // for the per diem calculation is based on 24 hour period
        if (trvParameters.PerDiemCalculation == TrvPerDiemCalculation::FullDayHourPeriod)
        {
            // Calculate the total of hours in the trip, including first and last day.
            numHours = hrsFirstDay + (numDaysWithAllowance * hoursInADay) + hrsLastDay;
            if (numHours >= hoursInADay)
            {
                // If there is one or more days, we can calculate the number of full days by dividing into 24h.
                numDaysWithAllowance = real2int(numHours / hoursInADay);
                // if total hours in the trip is more than 24h, set first day hours to 24 hour
                hrsFirstDay = isTrvPerdiemsFullDayHourFlightEnabled? hoursInADay : 0;
                hrsLastDay = numHours - (numDaysWithAllowance * hoursInADay);

                numTotalDays = numDaysWithAllowance;
                if (numHours > hoursInADay && hrsLastDay > 0)
                {
                    // If there are hours in the last day, count it as another partial day.
                    numTotalDays++;
                }
                if(isTrvPerdiemsFullDayHourFlightEnabled)
                {
                    // if trip has multiple days and total hours in the trip is multiple of 24h, set last day hours to 24 hour
                    if( numDaysWithAllowance > 1 && hrsLastDay == 0 )
                    {
                        hrsLastDay = hoursInADay;
                        // number of full travel days, not counting last day
                        numDaysWithAllowance--;
                    }
                    // number of full travel days, not counting first day
                    numDaysWithAllowance--;
                }
                // Calculate the beginning of the last day based on 24 h setup.
                startDateTo = DateTimeUtil::addDays(dateFrom, numTotalDays -1);
            }
            else
            {
                // If the total of hours in the trip is less than a day:
                numDaysWithAllowance = 0;
                // There is 1 partial day.
                numTotalDays = 1;
                hrsFirstDay = numHours;
                hrsLastDay = 0;
                // The beginning of the last day is the same as the first day, because there is only 1 day.
                startDateTo = dateFrom;
            }
        }

        select firstonly PerDiem from trvPartyEmployeeRelationship where trvPartyEmployeeRelationship.Worker == this.CreatingWorker;
        if (trvPartyEmployeeRelationship.PerDiem > 0)
        {
            if (firstLastSame)
            {
                this.AmountCurr = hrsFirstDay > 0 ? trvPartyEmployeeRelationship.PerDiem : 0;
            }
            else
            {
                if (hrsFirstDay)
                {
                    numDaysWithAllowance++;
                }

                if (hrsLastDay)
                {
                    numDaysWithAllowance++;
                }

                this.AmountCurr = trvPartyEmployeeRelationship.PerDiem * numDaysWithAllowance;
            }
            //update dependant fields
            this.exchrate();
            this.amountMST();
            return;
        }

        //now that we didn't find an employee rule, we need
        //a travel location to look up a general rule
        if (!this.TrvLocations)
        {
            this.AmountCurr = 0;
            return;
        }

        trvPerDiems = this.getPerdiemRateSetup();
        if (!trvPerDiems.RecId)
        {
            this.AmountCurr = 0;
            return;
        }

        isMealReductionPerTrip = (trvParameters.MealReductionType == TrvMealReductionType::MealTypePerTrip);

        // If it is not meal reduction per trip insert trvExpTrans record as per diem lines needs to show up in grid, so insert trvExpTrans record first.
        if (!isMealReductionPerTrip && _implicitSave)
        {
            if (isInserted)
            {
                this.update();
            }
            else
            {
                this.insert();
            }
            return;
        }

        // Handle first day.
        trvAllowanceRate = null;
        // Check if any allowance rates exist for the per diem.
        select firstonly RecId from trvAllowanceRateAnyExist where
            trvAllowanceRateAnyExist.PerDiemRecId == trvPerDiems.RecId &&
            (trvAllowanceRateAnyExist.TrvFirstLastBoth == TrvFirstLastBoth::FirstDay || trvAllowanceRateAnyExist.TrvFirstLastBoth == TrvFirstLastBoth::Both);

        if (!trvAllowanceRateAnyExist.RecId)
        {
            // If no rates have been setup, then count day as a full day only if hrs > 0.
            if (hrsFirstDay > 0)
            {
                numDaysWithAllowance++;
            }
        }
        else
        {
            trvAllowanceRate = TrvAllowanceRate::find(trvPerDiems.RecId, TrvFirstLastBoth::FirstDay, hrsFirstDay);

            if (trvAllowanceRate.RecId && hrsFirstDay > 0)
            {
                // rates are setup and found for first day, use it
                if (trvParameters.PerDiemRounding == TrvPerDiemRounding::RoundUp)
                {
                    mealAllowance += roundUp(trvPerDiems.MealAllowance * trvAllowanceRate.MealReduction / 100, 1.0);
                    hotelAllowance += roundUp(trvPerDiems.HotelAllowance * trvAllowanceRate.HotelReduction / 100, 1.0);
                    otherAllowance += roundUp(trvPerDiems.OtherAllowance * trvAllowanceRate.OtherReduction / 100, 1.0);
                }
                else
                {
                    mealAllowance += trvPerDiems.MealAllowance * trvAllowanceRate.MealReduction / 100;
                    hotelAllowance += trvPerDiems.HotelAllowance * trvAllowanceRate.HotelReduction / 100;
                    otherAllowance += trvPerDiems.OtherAllowance * trvAllowanceRate.OtherReduction / 100;
                }
            }
            // else pay nothing
        }

        // Calculate meal reduction first day
        if (!isMealReductionPerTrip && isInserted)
        {
            ttsbegin;
            trvExpPerdiemData = TrvExpPerdiemData::findOrCreate(this.RecId, dateFrom, true);
            trvExpPerdiemData.NumberOfHrsDay = hrsFirstDay;
            trvExpPerdiemData.TypeOfDate = TrvFirstLastBoth::FirstDay;
            trvExpPerdiemData.calculateMealDeduction(trvParameters.PerDiemRounding, trvParameters.MealReductionType, trvPerDiems, trvAllowanceRate);
            trvExpPerdiemData.LegalEntity = this.LegalEntity;
            trvExpPerdiemData.ExchangeCode = trvPerDiems.Currency;
            trvExpPerdiemData.update();
            ttscommit;

            mealReduction = trvExpPerdiemData.MealDeduction;
            this.DeduktionBreakfest = trvExpPerdiemData.NumberOfBreakfast;
            this.DeduktionLunch = trvExpPerdiemData.NumberOfLunch;
            this.DeduktionDinner = trvExpPerdiemData.NumberOFDinner;
        }

        // handle last day
        trvAllowanceRate = null;
        // do not apply last day reductions if first and last days are the same
        if (!firstLastSame)
        {
            // check if any allowance rates exist for the perdiem
            select firstonly RecId from trvAllowanceRateAnyExist where
                trvAllowanceRateAnyExist.PerDiemRecId == trvPerDiems.RecId &&
                (trvAllowanceRateAnyExist.TrvFirstLastBoth == TrvFirstLastBoth::LastDay || trvAllowanceRateAnyExist.TrvFirstLastBoth == TrvFirstLastBoth::Both);

            trvAllowanceRate = TrvAllowanceRate::find(trvPerDiems.RecId, TrvFirstLastBoth::LastDay, hrsLastDay);

            if (!trvAllowanceRateAnyExist.RecId)
            {
                // if no rates have been setup, then count day as a full day only if hrs > 0 or per diem calculation is based on Calendar Day.
                if (hrsLastDay > 0 || trvParameters.PerDiemCalculation == TrvPerDiemCalculation::CalendarDay || trvParameters.PerDiemCalculation == TrvPerDiemCalculation::CalendarDayNoTime)
                {
                    numDaysWithAllowance++;
                }
            }
            else if (hrsLastDay > 0)
            {
                if (trvAllowanceRate.RecId)
                {
                    // rates are setup and found for last day, use it
                    if (trvParameters.PerDiemRounding == TrvPerDiemRounding::RoundUp)
                    {
                        mealAllowance += roundUp(trvPerDiems.MealAllowance * trvAllowanceRate.MealReduction / 100, 1.0);
                        hotelAllowance += roundUp(trvPerDiems.HotelAllowance * trvAllowanceRate.HotelReduction / 100, 1.0);
                        otherAllowance += roundUp(trvPerDiems.OtherAllowance * trvAllowanceRate.OtherReduction / 100, 1.0);
                    }
                    else
                    {
                        mealAllowance += trvPerDiems.MealAllowance * trvAllowanceRate.MealReduction / 100;
                        hotelAllowance += trvPerDiems.HotelAllowance * trvAllowanceRate.HotelReduction / 100;
                        otherAllowance += trvPerDiems.OtherAllowance * trvAllowanceRate.OtherReduction / 100;
                    }
                }
                // else pay nothing
            }

            // Calculate meal reduction last day
            if (!isMealReductionPerTrip && isInserted && numTotalDays > 1)
            {
                ttsbegin;
                trvExpPerdiemData = TrvExpPerdiemData::findOrCreate(this.RecId, startDateTo, true);
                trvExpPerdiemData.NumberOfHrsDay = hrsLastDay;
                trvExpPerdiemData.TypeOfDate = TrvFirstLastBoth::LastDay;
                trvExpPerdiemData.calculateMealDeduction(trvParameters.PerDiemRounding, trvParameters.MealReductionType, trvPerDiems, trvAllowanceRate);
                trvExpPerdiemData.LegalEntity = this.LegalEntity;
                trvExpPerdiemData.ExchangeCode = trvPerDiems.Currency;
                trvExpPerdiemData.update();
                ttscommit;

                mealReduction += trvExpPerdiemData.MealDeduction;
                this.DeduktionBreakfest += trvExpPerdiemData.NumberOfBreakfast;
                this.DeduktionLunch += trvExpPerdiemData.NumberOfLunch;
                this.DeduktionDinner += trvExpPerdiemData.NumberOFDinner;
            }
        }

        if (!isMealReductionPerTrip && isInserted)
        {
            // If the total number of days in the trip is more than 2 (First and last day), then create entries for days in between of the trip.
            for (numberOfDaysCount =1; numberOfDaysCount + 2 <= numTotalDays; numberOfDaysCount++)
            {
                ttsbegin;
                trvExpPerdiemData = TrvExpPerdiemData::findOrCreate(this.RecId, DateTimeUtil::addDays(dateFrom, numberOfDaysCount), true);
                trvExpPerdiemData.NumberOfHrsDay = hoursInADay;
                trvExpPerdiemData.TypeOfDate = TrvFirstLastBoth::MiddleDay;
                trvExpPerdiemData.calculateMealDeduction(trvParameters.PerDiemRounding, trvParameters.MealReductionType, trvPerDiems);
                trvExpPerdiemData.LegalEntity = this.LegalEntity;
                trvExpPerdiemData.ExchangeCode = trvPerDiems.Currency;
                trvExpPerdiemData.update();
                ttscommit;

                mealReduction += trvExpPerdiemData.MealDeduction;
                this.DeduktionBreakfest += trvExpPerdiemData.NumberOfBreakfast;
                this.DeduktionLunch += trvExpPerdiemData.NumberOfLunch;
                this.DeduktionDinner += trvExpPerdiemData.NumberOFDinner;
            }

            // Delete any record in perdiem data that are not in the range of current entry.
            delete_from trvExpPerdiemData
                where trvExpPerdiemData.TrvExpTrans == this.RecId && (trvExpPerdiemData.TransDate > DateTimeUtil::date(startDateTo) || trvExpPerdiemData.TransDate <  DateTimeUtil::date(dateFrom));
        }
        else
        {
            // Calculate meal reduction for rest of days
            mealReduction = (trvPerDiems.MealAllowance *
                (this.DeduktionBreakfest * trvParameters.DeductBreakf +
                this.DeduktionDinner * trvParameters.DeductDinner +
                this.DeduktionLunch * trvParameters.DeductLunch) / 100);
        }
        mealAllowance += numDaysWithAllowance * trvPerDiems.MealAllowance;
        if (mealReduction > mealAllowance)
        {
            throw error("@SYS138653");
        }
        hotelAllowance += numDaysWithAllowance * trvPerDiems.HotelAllowance;
        otherAllowance += numDaysWithAllowance * trvPerDiems.OtherAllowance;

        expAmount = mealAllowance + hotelAllowance + otherAllowance - mealReduction;

        //if per diem feature is enabled, save hotel allowance for meals and incidentals calculations
        if (ExpensePerdiemHelper::isPerDiemEnabled())
        {
            this.PerDiemHotelAllowance = hotelAllowance;
            this.checkDeductions(numTotalDays);
        }

        this.AmountCurr = expAmount;
        this.ExchangeCode = trvPerDiems.Currency;
        this.Deduktion = mealReduction;

        //update dependant fields
        this.exchrate();
        this.amountMST();

        this.updateNetTransactionAmount();
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>policyViolationLevelMsg</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives a list of <c>TrvPolicyViolation</c> objects for the line.
    ///     It includes the project policy errors/warnings.
    /// </summary>
    /// <returns>
    ///     A list of <c>TrvPolicyViolation</c> objects for the line.
    /// </returns>
    public List policyViolationLevelMsg()
    {
        List                trvPolicyViolations;
        TrvPolicyViolation  trvPolicyViolation = new TrvPolicyViolation();

        trvPolicyViolations = TrvPolicyEvalEngine::displayPolicyViolationLevelMsg(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);

        if (this.ProjPolicyText && this.ProjPolicyStatus != ProjExpPolicyStatus::NoPolicy)
        {
            if (this.ProjPolicyStatus == ProjExpPolicyStatus::DayWarning ||
            this.ProjPolicyStatus == ProjExpPolicyStatus::ExpenseWarning ||
                this.ProjPolicyStatus == ProjExpPolicyStatus::ReportWarning)
            {
                trvPolicyViolation.parmAdjustedViolationLevel(TrvPolicyViolationLevel::Warning);
                trvPolicyViolation.parmViolationLevel(TrvPolicyViolationLevel::Warning);
                trvPolicyViolation.parmViolationMessage(this.ProjPolicyText);
                trvPolicyViolations.addEnd(trvPolicyViolation);
            }
            else if (this.ProjPolicyStatus == ProjExpPolicyStatus::DayFailed ||
                    this.ProjPolicyStatus == ProjExpPolicyStatus::ExpenseFailed ||
                    this.ProjPolicyStatus == ProjExpPolicyStatus::ReportFailed)
            {
                trvPolicyViolation.parmAdjustedViolationLevel(TrvPolicyViolationLevel::Error);
                trvPolicyViolation.parmViolationLevel(TrvPolicyViolationLevel::Error);
                trvPolicyViolation.parmViolationMessage(this.ProjPolicyText);
                trvPolicyViolations.addEnd(trvPolicyViolation);
            }
        }

        return trvPolicyViolations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postApprove</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the committed cost for the expense line.
    /// </summary>
    /// <param name="_trvExpTransRecId">
    /// Recid of <c>TrvExpTrans</c>
    /// </param>
    public void postApprove(RecId _trvExpTransRecId)
    {
        TrvExpTrans                             trvExpTrans;
        SourceDocumentLineItem                  sourceDocumentLineItem;

        select firstonly trvExpTrans where trvExpTrans.ProjId != '' && trvExpTrans.RecId == _trvExpTransRecId;
        if (trvExpTrans)
        {
            if ( !CostControlTransCommittedCost::existOpenBySourceDocumentLine(trvExpTrans.SourceDocumentLine) && AccountingDistribution::existSourceDocumentLine(trvExpTrans.SourceDocumentLine) )
            {
                sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLineImplementation(trvExpTrans);
                ProjectCommitmentFacade::updateProjectCommitments(sourceDocumentLineItem);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainingAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the remaining amount to be itemized or split for the itemized or split header expense line.
    /// </summary>
    /// <returns>
    ///     The remaining amount to be itemized or split for the itemized or split header expense line.
    /// </returns>
    display AmountCur remainingAmount()
    {
        TrvExpTrans     expTrans;

        select sum(AmountCurr) from expTrans where expTrans.ParentRecId == this.RecId;

        return (this.AmountCurr - expTrans.AmountCurr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>requisitionTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the requisition to which the expense report is mapped.
    /// </summary>
    /// <returns>
    ///     The <c>RecId</c> of the requisition to which the expense report is mapped.
    /// </returns>
    display RefRecId requisitionTable()
    {
        TrvExpTableTrvRequisitionTable  trvExpTableTrvRequisitionTable;

        select firstonly TrvRequisitionTable from trvExpTableTrvRequisitionTable
                where trvExpTableTrvRequisitionTable.TrvExpTable == this.TrvExpTable;

        return trvExpTableTrvRequisitionTable.TrvRequisitionTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCorrectedTaxAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Default tax amount in company currency for the expense line.
    /// </summary>
    void setCorrectedTaxAmountMST()
    {
        TrvCurrencyCode exchangeCode = this.isCreditCardTransaction() ? this.CreditCardTransactionCurrency : this.ExchangeCode;

        this.CorrectedTaxAmountMST = CurrencyExchangeHelper::amountCur2MST(this.CorrectedTaxAmount, exchangeCode, this.ExchangeRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method sets default dimension for the expense line.
    /// </summary>
    /// <remarks>
    /// The default dimension is derived from the a requisition line, the expense report or the worker. If a project is
    /// selected, the default dimension from the project is merged with the default dimension.
    /// </remarks>
    public void setDefaultDimension()
    {
        DimensionDefault dimensionDefaultFromProject = 0;
        DimensionDefault dimensionDefaultReqLine = 0;
        DimensionDefault dimensionDefaultWorker = 0;
        DimensionDefault dimensionDefaultFromExpenseReport = 0;
        LegalEntityDataAreaId workerProjectDimensionLE = this.legalEntityName();
        LegalEntityDataAreaId defaultDimensionLE = this.defaultDimensionLegalEntityName();
        LegalEntityDataAreaId expenseReportLE = this.ReferenceDataAreaId;
        LegalEntityDataAreaId reqLineLE;

        
        // get default dimensions from an associated travel requisition line if one is mapped
        if (this.MappedToRequisitionLine)
        {
            dimensionDefaultReqLine = TrvRequisitionLine::find(this.MappedToRequisitionLine).DefaultDimension;
            reqLineLE = this.ReferenceDataAreaId;
        }

        if (this.CreatingWorker)
        {
            changecompany (workerProjectDimensionLE)
            {
                // obtain default dimension from worker's employment using the intercompanyLE - or current company if not an intercompany transaction
                dimensionDefaultWorker =  HcmEmployment::findByWorkerLegalEntity(this.CreatingWorker, CompanyInfo::findDataArea(workerProjectDimensionLE).RecId).DefaultDimension;
            }
        }

        if (this.TrvExpTable)
        {
            // include DefaultDimension from the expense report if one is set
            dimensionDefaultFromExpenseReport = TrvExpTable::findRecId(this.TrvExpTable).DefaultDimension;
        }

        if (dimensionDefaultFromExpenseReport == 0)
        {
            // line is not on an expense report or the header does not have any default - use the worker's default dimensions and LE
            dimensionDefaultFromExpenseReport = dimensionDefaultWorker;
            expenseReportLE = workerProjectDimensionLE;
        }
        

        // Intercompany expense with project should not consider project dimensions.
        if (this.ProjId && !this.isIntercompanyWithProject())
        {
            // project is from the expense report company, use to set default dimension on the expense line
            dimensionDefaultFromProject = ProjTable::find(this.ProjId).DefaultDimension;
        }

        if (dimensionDefaultReqLine)
        {
            // when a requisition line is mapped, merge dimensions from Project+ReqLine+Expense report
            this.DefaultDimension = TrvExpenseDimensionHelper::generateDefaultDimensionForExpenseLine(defaultDimensionLE,
                                                                                                    dimensionDefaultReqLine,
                                                                                                    reqLineLE,
                                                                                                    dimensionDefaultFromProject,
                                                                                                    workerProjectDimensionLE,
                                                                                                    dimensionDefaultFromExpenseReport,
                                                                                                    expenseReportLE);
        }
        else if (dimensionDefaultFromProject)
        {
            // include project dimension Project+ExpenseReport+Worker
            this.DefaultDimension = TrvExpenseDimensionHelper::generateDefaultDimensionForExpenseLine(defaultDimensionLE,
                                                                                                    dimensionDefaultFromExpenseReport,
                                                                                                    expenseReportLE,
                                                                                                    dimensionDefaultFromProject,
                                                                                                    workerProjectDimensionLE,
                                                                                                    dimensionDefaultWorker,
                                                                                                    workerProjectDimensionLE);;
        }
        else
        {
            // merge header and worker dimension - if intercompany transaction, only shared dimensions will be included in merge
            this.DefaultDimension = TrvExpenseDimensionHelper::generateDefaultDimensionFromWorkerAndProject(dimensionDefaultWorker,
                                                                                                    dimensionDefaultFromExpenseReport,
                                                                                                    workerProjectDimensionLE,
                                                                                                    expenseReportLE,
                                                                                                    defaultDimensionLE);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimensionLegalEntityName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the legal entity on which the expense line's financial dimensions are valid.
    /// </summary>
    /// <returns>The legal entity on which the expense line's financial dimensions are valid.</returns>
    public LegalEntityDataAreaId defaultDimensionLegalEntityName()
    {
        return TrvExpenseDimensionHelper::getDefaultDimensionLegalEntityName(this.isIntercompany(),
                                                                            this.ReferenceDataAreaId,
                                                                            this.InterCompanyLE,
                                                                            this.isIntercompanyWithProject());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjectFields</Name>
				<Source><![CDATA[
    private void setProjectFields(ProjLinePropertyId _projStatusId = '')
    {
        LegalEntityDataAreaId legalEntity = this.legalEntityName();
        this.ProjStatusId = _projStatusId;

        changeCompany(legalEntity)
        {
            if (this.ProjId)
            {
                if(!this.ProjStatusId || (this.orig().ProjId && this.orig().ProjId != this.ProjId))
                {
                    this.ProjStatusId = ProjLinePropertySetup::findLinePropertyId(this.ProjId, this.CostType);
                }

                if (this.ProjTransId == '')
                {
                    this.ProjTransId   = ProjParameters::newTransId();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setItemizedLineCorrectedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Set corrected tax amount in expense line based on pro-data basis by considering the percentage
    ///  of header actual sales tax amount and line amount.
    /// </summary>
    /// <returns>
    ///  Returns true If corrected tax amount is updated otherwise returns false.
    /// </returns>
    public boolean setItemizedLineCorrectedTaxAmount()
    {
        TrvExpTrans expTransHeader;
        Percent     correctedTaxPercent;

        expTransHeader = TrvExpTrans::find(this.ParentRecId);

        if (this.LineType == TrvExpLineType::ItemizedLine &&
                expTransHeader.CorrectedTaxAmount != 0 &&
                this.TaxGroup == expTransHeader.TaxGroup &&
                this.TaxItemGroup == expTransHeader.TaxItemGroup)
        {
            correctedTaxPercent = (expTransHeader.CorrectedTaxAmount / expTransHeader.AmountCurr) * 100;

            this.CorrectedTaxAmount =  CurrencyExchange::round(this.AmountCurr *  correctedTaxPercent / 100, this.ExchangeCode) ;

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Default tax group for the expense from tax country configuration, project or vendor
    /// </summary>
    /// <remarks>
    ///     This method is called during init, when country region is changed, or when project is changed.
    /// </remarks>
    private void setTaxGroup()
    {
        TrvLegalEntity legalEntityContext = CompanyInfoExtension::existsDataArea(this.ReferenceDataAreaId)? this.ReferenceDataAreaId : curExt();

        if(this.isTaxObligationDestination() && this.isIntercompany())
        {
            legalEntityContext = this.legalEntityName();
        }
        
        changecompany(legalEntityContext)
        {
        
            boolean isTaxGroupSetForCountry = false;

            if (this.CountryRegion)
            {
                isTaxGroupSetForCountry = this.setTaxGroupForCountryRegionSettings();
            }

            if (!(this.CountryRegion && this.setTaxGroupForCountryRegionSettings()))
            {
                this.defaultTaxGroupFromWorker();

                this.defaultTaxGroupFromProject();

                this.defaultTaxGroupFromVendor();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxGroupDefaulting</Name>
				<Source><![CDATA[
    /// <summary>
    /// 
    /// </summary>

    [Hookable(false)]
    public void taxGroupDefaulting()
    {
        this.setTaxGroup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxGroupForCountryRegionSettings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the tax group for the country region from <c>TrvExpenseTaxConfiguration</c> record.
    /// </summary>
    /// <returns>
    /// Returns true if tax group is set for the country region; otherwise, false.
    /// </returns>
    protected boolean setTaxGroupForCountryRegionSettings()
    {
        boolean isTaxGroupSetForCountry;
        TrvExpenseTaxConfiguration trvExpenseTaxConfiguration;

        select count(RecVersion) from trvExpenseTaxConfiguration
            where trvExpenseTaxConfiguration.CountryRegionId == this.CountryRegion
                && trvExpenseTaxConfiguration.StateId == this.AddressState;

        if (trvExpenseTaxConfiguration.RecVersion == 1)
        {
            select firstonly TaxGroup from trvExpenseTaxConfiguration
                where trvExpenseTaxConfiguration.CountryRegionId == this.CountryRegion
                    && trvExpenseTaxConfiguration.StateId == this.AddressState;

            this.TaxGroup = trvExpenseTaxConfiguration.TaxGroup;
        }
        else if (this.TaxGroup)
        {
            this.TaxGroup = "";
        }

        if (trvExpenseTaxConfiguration.RecVersion > 0)
        {
            // when multiple country setups exists, do not default tax group from project or vendor
            isTaxGroupSetForCountry = true;
        }

        return isTaxGroupSetForCountry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTaxGroupFromWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults the tax group from the worker's vendor account settings.
    /// </summary>
    [Wrappable(true)]
    protected final void defaultTaxGroupFromWorker()
    {
        TrvPartyEmployeeRelationship trvEmpSetup = TrvPartyEmployeeRelationship::find(this.CreatingWorker);

        if (trvEmpSetup.AccountType == LedgerJournalACType::Vend)
        {
            CustVendAC custVendAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(trvEmpSetup.LedgerDimension);

            if (custVendAccount)
            {
                this.TaxGroup = VendTable::find(custVendAccount).TaxGroup;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultSalesTaxFromWorkerWrapper</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public void defaultSalesTaxFromWorkerWrapper()
    {
        this.defaultTaxGroupFromWorker();
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTaxGroupFromProject</Name>
				<Source><![CDATA[
    private void defaultTaxGroupFromProject()
    {
        if (!this.TaxGroup && this.ProjId)
        {
            this.TaxGroup = ProjTable::find(this.ProjId).TaxGroupId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTaxGroupFromVendor</Name>
				<Source><![CDATA[
    private void defaultTaxGroupFromVendor()
    {
        if (!this.TaxGroup)
        {
            TrvExpTable trvExpTable = TrvExpTable::findRecId(this.TrvExpTable);

            if (trvExpTable.VendAccount)
            {
                this.TaxGroup = VendTable::find(trvExpTable.VendAccount).TaxGroup;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the item tax group for the transaction.
    /// </summary>
    protected void setTaxItemGroup()
    {
        TrvExpSubCategory   trvExpSubCategory;
        TrvCostType         trvCostType;

        // Reset TaxItemGroup
        this.TaxItemGroup = '';

        // precedence for expense line when the line type is ItemizedLine :
        //          sub category item sales tax > expense Line item sales tax > expense category item sales tax
        // precedence for normal line :
        //          sub category item sales tax > expense category item sales tax
        // precedence for hotel expense billed to employee :
        //          sub category alternate item sales tax > sub category item sales tax >
        //          expense category alternate item sales tax > expense category item sales tax
        if (this.SubCategoryRecId)
        {
            TrvLegalEntity legalEntityContext = TrvExpTrans::getLegalEntityForTax(this);

            if (CompanyInfoExtension::existsDataArea(legalEntityContext))
            {
                changecompany (legalEntityContext)
                {
                    select firstonly TaxItemGroup, TaxItemGroupIfBilledToEmployee 
                        from trvExpSubCategory where trvExpSubCategory.RecId == this.SubCategoryRecId;
                }
            }
            else
            {
                throw error("@Expense:InvalidExpenseLegalEntity");
            }

            // If this is hotel and billed to employee, use the alternate item sales tax
            if (this.ExpType == TrvExpType::Hotel &&
                this.BillIssuedTo == TrvBillIssuedTo::Employee &&
                trvExpSubCategory.TaxItemGroupIfBilledToEmployee)
            {
                this.TaxItemGroup = trvExpSubCategory.TaxItemGroupIfBilledToEmployee;
            }
            else
            {
                this.TaxItemGroup = trvExpSubCategory.TaxItemGroup;
            }
        }

        if (this.TaxItemGroup == '' && (this.LineType == TrvExpLineType::ItemizedLine || this.SplitLineType == TrvExpSplitLineType::SplitLine))
        {
            this.TaxItemGroup = TrvExpTrans::find(this.ParentRecId).TaxItemGroup;
        }

        if (this.TaxItemGroup == '')
        {
            trvCostType = TrvCostType::find(this.CostType);

            // If this is hotel and billed to employee, use the alternate item sales tax
            if (this.ExpType == TrvExpType::Hotel &&
                this.BillIssuedTo == TrvBillIssuedTo::Employee &&
                trvCostType.TaxItemGroupIfBilledToEmployee)
            {
                this.TaxItemGroup = this.isTaxItemGroupValidForIntercompanyLE(trvCostType.TaxItemGroupIfBilledToEmployee)? 
                                                trvCostType.TaxItemGroupIfBilledToEmployee : '';
            }
            else
            {
                this.TaxItemGroup = this.isTaxItemGroupValidForIntercompanyLE(trvCostType.TaxItemGroup)? trvCostType.TaxItemGroup : '';
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxItemGroupDefaulting</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public void taxItemGroupDefaulting()
    {
        this.setTaxItemGroup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>subCategoryCanShowGuests</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the guests button is shown for this itemized expense line.
    /// </summary>
    /// <returns>
    /// True if the guests button is shown for this category or subcategory, otherwise false
    /// </returns>
    /// <remarks>
    /// We show the guests button for the subcategories of gift and entertainment.
    /// </remarks>
    public boolean subCategoryCanShowGuests()
    {
        TrvExpSubCategory   trvExpSubCategory;
        boolean             subCategoryCanHaveGuests = false;

        if (this.RecId != 0)
        {
            // itemized lines with subCategory
            if (this.LineType == TrvExpLineType::ItemizedLine && this.SubCategoryRecId)
            {
                select firstonly trvExpSubCategory where trvExpSubCategory.RecId == this.SubCategoryRecId;
                if (trvExpSubCategory.RecId)
                {
                    switch (trvExpSubCategory.chargeType())
                    {
                        case TrvHotelChargeType::Gift:
                        case TrvHotelChargeType::BusinessEntertainment:
                            subCategoryCanHaveGuests = true;
                            break;
                    }
                }
            }
        }

        return subCategoryCanHaveGuests;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSubCategoryExcludedForTaxRecovery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the expense sub category has exclude tax recovery enabled.
    /// </summary>
    /// <returns>
    /// True if expense sub category has exclude tax recovery enabled; otherwise false by default.
    /// </returns>
    [SysClientCacheDataMethodAttribute]
    public boolean isSubCategoryExcludedForTaxRecovery()
    {
        TrvExpSubCategory trvExpSubCategory;
        TrvSharedSubCategory trvSharedSubCategory;

        if (this.RecId != 0 && this.LineType == TrvExpLineType::ItemizedLine && this.SubCategoryRecId)
        {
            select ExcludeFromRecovery from trvSharedSubCategory
                join trvExpSubCategory
                where trvExpSubCategory.TrvSharedSubCategory == trvSharedSubCategory.RecId
                    && trvExpSubCategory.RecId == this.SubCategoryRecId;
        }

        return (trvSharedSubCategory.ExcludeFromRecovery == NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwInfologsForPolicyViolationLevelMsg</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Writes the policy violation messages for the line to the infolog.
    /// </summary>
    public void throwInfologsForPolicyViolationLevelMsg()
    {
        List                violations = this.policyViolationLevelMsg();
        ListEnumerator      listEnumerator;
        TrvPolicyViolation  violation;

        listEnumerator = violations.getEnumerator();

        while (listEnumerator.moveNext())
        {
            violation = listEnumerator.current();
            
            switch (violation.parmAdjustedViolationLevel())
            {
                case TrvPolicyViolationLevel::None:
                    continue;

                case TrvPolicyViolationLevel::Error:
                    error(violation.parmViolationMessage());
                    break;

                default:
                    warning(violation.parmViolationMessage());
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustedPolicyViolationLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the adjusted policy violation level for the line. This will be none or error or warning.
    /// </summary>
    /// <param name = "_suppressJustificationError">
    /// True if justification related policy errors can be suppressed to warnings; otherwise false by default.
    /// This is used when the caller knows that justification record exists and policy re-evaluation might not have been done.
    /// </param>
    display TrvPolicyViolationLevel adjustedPolicyViolationLevel(boolean _suppressJustificationError = false)
    {
        List                    violations = this.policyViolationLevelMsg();
        ListEnumerator          listEnumerator;
        TrvPolicyViolation      violation;

        TrvPolicyViolationLevel adjustedViolationLevel = TrvPolicyViolationLevel::None;
        TrvPolicyViolationLevel violationLevel = TrvPolicyViolationLevel::None;

        listEnumerator = violations.getEnumerator();

        while (listEnumerator.moveNext())
        {
            violation = listEnumerator.current();
            // The enum value of error > value of warning > value of none.
            // The final violation level will be greatest of these 3.
            if (violation.parmAdjustedViolationLevel() > adjustedViolationLevel)
            {
                adjustedViolationLevel = violation.parmAdjustedViolationLevel();
                violationLevel = violation.parmViolationLevel();
            }
        }

        // If needed, convert submit justification related errors to warnings.
        if (_suppressJustificationError && (violationLevel == TrvPolicyViolationLevel::SubmitJustification
            || violationLevel == TrvPolicyViolationLevel::SubmitApproveJustification))
        {
            adjustedViolationLevel = TrvPolicyViolationLevel::Warning;
        }

        return adjustedViolationLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>receiptRequiredByPolicies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if receipts are required for the record.
    /// Note that this only works for Receipt Required policies, not other policies that check the receiptAttached field.
    /// </summary>
    /// <returns>True if receipts are required, ortherwise false.</returns>
    public boolean receiptRequiredByPolicies()
    {
        SysPolicyTypeEnum   policyType = SysPolicyTypeEnum::TrvExpensePolicy;
        int64               orgIds[];
        boolean             ret;

        SysPolicyRuleType policyRuleType = SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvReceiptsRequired, policyType);

        // The LE associated with the expense/req header
        orgIds[1] = this.LegalEntity;

        // The Department OU(s) for the worker (based on position) as of the expense date
        container workerDepts = HcmWorkerHelper::getDepartmentRecIds(this.CreatingWorker);
        int numWorkerDepts = conLen(workerDepts);
        for (int i = 1; i <= numWorkerDepts; i++)
        {
            orgIds[i+1] = conPeek(workerDepts, i);
        }

        utcdatetime applyDate = TrvPolicyEvalEngine::getPolicyCheckDateTime(this.TransDate);
        
        Array applicablePolicyRules = SysPolicies::getPolicyRuleIDs(orgIds, policyRuleType.RecId, policyType, applyDate);

        for (int i = 1; i <= applicablePolicyRules.lastIndex(); i++)
        {
            TrvPolicyRule currentTrvRule;
            select firstonly currentTrvRule where currentTrvRule.RecId == applicablePolicyRules.value(i);

            if (TrvPolicyEvalEngine::isPolicyViolated(currentTrvRule, this.RecId, policyType, false))
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCostType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the expense line based on the cost type on the record.
    /// </summary>
    /// <param name = "_isCalledFromInsert">Indicates if the method is being called from the insert method or not.</param>
    void initFromCostType(boolean _isCalledFromInsert = false)
    {
        TrvCostType trvCostType = TrvCostType::find(this.CostType);

        this.ExpType = trvCostType.ExpType;

        this.defaultPaymentMethod(trvCostType);
        this.updateCostOwner();

        // When called from modifiedField or when description is empty, reset the description.
        if (!this.Description || !_isCalledFromInsert)
        {
            this.Description = trvCostType.CostTxt;
        }

        if (this.ExpType == TrvExpType::Transport)
        {
            this.initWorkerVehicleType();
            this.calcKM();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPaymentMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Re-defaults the payment method from the category selected.
    /// </summary>
    /// <param name = "_newCostType">
    /// The cost type to use when determining a default payment method.
    /// </param>
    private void defaultPaymentMethod(TrvCostType _newCostType)
    {
        // Do not update payment method on credit card as it should remain locked to the value it received during import.
        if (this.isCreditCardTransaction())
        {
            return;
        }

        // Do NOT change payment method for personal expenses as they inherit their payment method from the credit card line.
        if (this.isCreditCardPersonalTrans())
        {
            return;
        }

        // Payment method is empty, so we default with new standard payment method if new standard payment method is NOT import only
        if (this.isOriginalPaymentMethodInvalid(_newCostType))
        {
            this.PayMethod = _newCostType.StdPaiMethod;
        }

        // Payment method has been provided, but it is NOT valid for new cost type, so we clear value and force user explicitly to provide new input.
        if (this.PayMethod && !TrvCostType::validatePaymentMethod(this.CostType, this.PayMethod))
        {
            this.PayMethod = '';
        }

        //
        // If the expense type is Cash Advance or Allowance, and the payment method was cleared out because it was no longer going
        // to be valid, then we will try to reset based on standard payment method for new category.  If that is not allowed
        // because it is import only, show an error.  The payment method field is hidden for these expense types, so
        // AP clerk will have to correct the configuration issue.
        //
        if (!this.PayMethod && (this.ExpType == TrvExpType::Advance || this.ExpType == TrvExpType::Allowance))
        {
            if (TrvPayMethod::isAutomaticPayment(_newCostType.StdPaiMethod))
            {
                error(strFmt("@Expense:DefaultPaymentCategoryIsImportOnly", _newCostType.CostType));
            }
            else
            {
                this.PayMethod = _newCostType.StdPaiMethod;
            }
        }

        // Default case: Payment method has been provided already and is already valid for new cost type, so DO NOTHING
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOriginalPaymentMethodInvalid</Name>
				<Source><![CDATA[
    private boolean isOriginalPaymentMethodInvalid(TrvCostType _newCostType)
    {
        boolean valid;

        if ((!this.PayMethod || (this.PayMethod && this.orig().costType && this.orig().costType != _newCostType.CostType))
            && !TrvPayMethod::isAutomaticPayment(_newCostType.StdPaiMethod))
        {
            valid = true;
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the amount in transaction currency, alongwith the transaction currency code.
    /// </summary>
    /// <returns>
    /// The amount in transaction currency, alongwith the transaction currency code.
    /// </returns>
    display TrvTransactionCurrencyAmount transactionAmount()
    {
        return this.isCreditCardTransanctionInLocalCurrency() ? this.CreditCardTransactionCurrencyAmount : this.AmountCurr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionCurrency</Name>
				<Source><![CDATA[
    display CurrencyCode transactionCurrency()
    {
        return this.isCreditCardTransanctionInLocalCurrency() ? this.CreditCardTransactionCurrency : this.ExchangeCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemizationMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays if the expense line is required to be itemized.
    /// </summary>
    /// <returns>True if the expense line needs to be itemized, otherwise false.</returns>
    public display boolean isItemizationMandatory()
    {
        return TrvCostType::find(this.CostType).IsItemizationMandatory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>computePerdiemOnUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluates if per diem amounts should be recalculated.
    /// </summary>
    /// <returns>
    /// Returns true if per diem amounts should be recalculated; otherwise, false.
    /// </returns>
    protected boolean computePerdiemOnUpdate()
    {
        boolean computePerdiem = false;

        if (this.ExpType == TrvExpType::Allowance &&
            this.ApprovalStatus != TrvAppStatus::Approved &&
            this.ApprovalStatus != TrvAppStatus::Ledger)
        {
            computePerdiem = true;
        }

        return computePerdiem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCorrectedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updated corrected tax amount and net transaction amount during update of expense line.
    /// </summary>
    private void updateCorrectedTaxAmount()
    {
        boolean useCorectedTaxAmount = false;

        if (!this.isTaxApplicable())
        {
            this.clearTaxFields();
        }

        if (this.LineType == TrvExpLineType::ItemizedLine && (this.TaxGroup != this.orig().TaxGroup || this.TaxItemGroup != this.orig().TaxItemGroup))
        {
            useCorectedTaxAmount = false;
        }
        else
        {
            useCorectedTaxAmount = true;
        }

        this.updateNetTransactionAmount(useCorectedTaxAmount);
        this.setCorrectedTaxAmountMST();
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update(boolean _evaluateSourceDocAndPolicies = true)
    {
        TrvLegalEntity origCompany = this.orig().InterCompanyLE;

        this.modifyVatDueDate_W();

        // Recalculate per diem deductions, if applicable.
        if (this.computePerdiemOnUpdate())
        {
            this.perDiem();
        }

        this.AmountCurr = CurrencyExchangeHelper::amount(this.AmountCurr, this.ExchangeCode);

        // Update net transaction amount based on corrected tax, if applicable.
        this.updateCorrectedTaxAmount();
        
        this.amountMST();

        this.checkAndDefaultInterCompanyCategory();

        ttsbegin;

        if (this.LineType == TrvExpLineType::ItemizedHeader)
        {
            this.copyValuesToChildLines(this.orig());
            if (this.isCreditCardTransaction())
            {
                this.updateItemizedLinesCreditCardExchRate();
            }
            else
            {
                // Payment method changed on manual itemized header, update child lines.
                this.updateItemizedLinesPaymentMethod(this.orig());
            }
        }

        boolean needToCreateOrUpdateTax = false;
        boolean needToDeleteTax = false;
        [needToCreateOrUpdateTax, needToDeleteTax] = this.determineTaxRecalculationState();

        // project policies updates field values, and has to be done before super
        TrvParameters trvParameters = TrvParameters::find();
        if (trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave && this.SplitLineType != TrvExpSplitLineType::SplitHeader)
        {
            this.validateProjExpPoliciesExpense();
        }
        
        // Billable field value is updated based on Project, when we update the expense line record from mobile app.
        if (this.ProjId)
        {
            this.setProjectFields(this.ProjStatusId);
        }

        // before super, as the trvExpTrans.AccountingCurrencyReconciledAmount is updated, and orig values should be got before super
        this.mapToRequisitionLine();
        boolean needToUpdateReqReconciliationStatus = this.needToUpdateReqReconciliationStatus(this.orig());

        if (this.SplitLineType == TrvExpSplitLineType::SplitLine
            && (this.CostType != this.orig().CostType
                || this.InterCompanyLE != this.orig().IntercompanyLE
                || this.ProjId != this.orig().ProjId
                || this.ProjActivityNumber != this.orig().ProjActivityNumber
                || this.ProjStatusId != this.orig().ProjStatusId
                || this.CreditCardTransactionCurrencyAmount != this.orig().CreditCardTransactionCurrencyAmount))
        {
            this.updateTrvExpTransSplit(this.RecId);
        }

        if (_evaluateSourceDocAndPolicies)
        {
            if (needToCreateOrUpdateTax)
            {
                this.createTaxUncommitted(true);
            }

            // Re-submit distributions only if expense is on an expense report and it is not posted
            if(_evaluateSourceDocAndPolicies 
                && this.TrvExpTable != 0 
                && this.ApprovalStatus != TrvAppStatus::Ledger
                && this.ApprovalStatus != TrvAppStatus::Approved)
            {
                // The state transition model will update distributions, and check budget as required
                // based on existing state, budget settings and any fields in the state container that changed
                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(this, true);
            }

            if(this.TrvExpTable)
            {
                this.calcIntercompanyAmounts();
            }
        }

        super();

		if (this.ExpNumber == '' && this.LineType != TrvExpLineType::ItemizedLine && this.SplitLineType != TrvExpSplitLineType::SplitLine)
        {
		    TrvReceiptsHelper::updateReceiptsAttachedForExpense(this.RecId);
        }

        if (_evaluateSourceDocAndPolicies && trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
        {
            // run eval if flight is disabled. Or if flight is enabled but intercompany billed is not true
            if(!(TrvSkipPolicyEvaluationWithInterCompanyBilledFlight::instance().isEnabled() && this.IntercompanyBilled))
            {
                this.executePolicyEvaluation();
            }
        }

        if (needToDeleteTax)
        {
            if (origCompany != '' && this.InterCompanyLE != origCompany)
            {
                CompanyInfo foundDataArea = CompanyInfo::findDataArea(origCompany);

                if (foundDataArea)
                {
                    changecompany(origCompany)
                    {
                        TaxUncommitted::deleteForDocumentLine(tableNum(TrvExpTrans),this.RecId);
                    }
                }
            }
            else
            {
                TaxUncommitted::deleteForDocumentLine(tableNum(TrvExpTrans),this.RecId);
            }
        }

        if (needToUpdateReqReconciliationStatus)
        {
            TrvRequisitionTable::updateReconciliationStatus(this.requisitionTable());
        }

        ttscommit;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTaxRecalculationState</Name>
				<Source><![CDATA[
    protected container determineTaxRecalculationState()
    {
        boolean needToCreateOrUpdateTax = false;          
        boolean needToDeleteTax = false;
        boolean taxUncommittedExists = false;

        // Check if tax recalculation is needed. Skip this if already posted.
        if (this.isTaxRecalcNeeded())
        {
            if (this.orig().InterCompanyLE != '' && (this.checkInterCompanyFieldModified() || this.isIntercompany()))
            {
                CompanyInfo foundDataArea = CompanyInfo::findDataArea(this.orig().InterCompanyLE);

                if (foundDataArea)
                {
                    changecompany(this.orig().InterCompanyLE)
                    {
                        taxUncommittedExists = TaxUncommitted::existByDocumentLineId(tableNum(TrvExpTrans), this.RecId);
                    }
                }
            }
            else
            {
                taxUncommittedExists = TaxUncommitted::existByDocumentLineId(tableNum(TrvExpTrans), this.RecId);
            }
            if (!taxUncommittedExists)
            {
                // Create taxUncommitted, if taxUncommitted doesn't exist and is needed.
                needToCreateOrUpdateTax = this.doesTaxNeedToBeCreated();
            }
            else
            {
                if (this.doesTaxNeedToBeDeleted())
                {
                    // Delete taxUncommitted, if any of above fields is empty.
                    needToDeleteTax = true;
                }
                else
                {
                    // Update taxUncommitted, if any above field is changed.
                    needToCreateOrUpdateTax = this.doesTaxNeedToBeUpdated();
                }
            }
        }
        return [needToCreateOrUpdateTax, needToDeleteTax];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxRecalcNeeded</Name>
				<Source><![CDATA[
    protected boolean isTaxRecalcNeeded()
    {
        return (this.ApprovalStatus != TrvAppStatus::Ledger && this.isDistributionsEnabled());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInterCompanyFieldModified</Name>
				<Source><![CDATA[
    private boolean checkInterCompanyFieldModified()
    {
        return (this.InterCompanyLE != this.orig().InterCompanyLE);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesTaxNeedToBeCreated</Name>
				<Source><![CDATA[
    protected boolean doesTaxNeedToBeCreated()
    {
        return (this.TaxGroup && this.TaxItemGroup && this.NetTransactionAmount != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesTaxNeedToBeDeleted</Name>
				<Source><![CDATA[
    protected boolean doesTaxNeedToBeDeleted()
    {
        if(TrvExpenseHelper::isClearTaxOnZeroTaxFlightEnabled() && this.CorrectedTaxAmount == 0 && this.orig().CorrectedTaxAmount != 0)
        {
            return true;
        }

        return (!this.TaxGroup || !this.TaxItemGroup || this.AmountCurr == 0 || this.checkInterCompanyFieldModified());
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesTaxNeedToBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the Tax related transactions need to be updated.
    /// </summary>
    /// <returns>
    /// Returns true if Tax related transactions need to be updated; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean doesTaxNeedToBeUpdated()
    {
        return (this.TaxGroup != this.orig().TaxGroup ||
                    this.TaxItemGroup != this.orig().TaxItemGroup ||
                    this.TaxIncluded != this.orig().TaxIncluded ||
                    this.CorrectedTaxAmount != this.orig().CorrectedTaxAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemizedLinesCreditCardExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update itemized lines credit card transaction exchange rate when its itemized header exchange rate is updated.
    /// </summary>
    private void updateItemizedLinesCreditCardExchRate()
    {
        TrvExpTrans     itemizedTrvExpTrans;

        if (this.LineType == TrvExpLineType::ItemizedHeader)
        {
            update_recordSet itemizedTrvExpTrans
            setting ExchangeRate = this.ExchangeRate
                where itemizedTrvExpTrans.ParentRecId == this.RecId
                   && itemizedTrvExpTrans.LineType == TrvExpLineType::ItemizedLine;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAmountCurrFromCreditCardAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update amountCurr according to CreditCardTransactionCurrencyAmount
    /// </summary>
    /// <remarks>
    ///     If the itemization is complete in credit card transaction currency, we put all header remaining amountCurr to it.
    /// </remarks>
    public void updateAmountCurrFromCreditCardAmount()
    {
        Amount          totalAmountLocal = 0;
        Amount          itemizedAmountLocal = 0;
        ExchRate        exchRate;
        TrvExpTrans     itemizedHeaderExpTrans, itemizedExpTrans;

        if (this.isCreditCardTransanctionInLocalCurrency())
        {
            // calculate total amount in local currency
            select firstonly AmountCurr, CreditCardTransactionCurrencyAmount from itemizedHeaderExpTrans where itemizedHeaderExpTrans.RecId == this.ParentRecId;
            totalAmountLocal = itemizedHeaderExpTrans.CreditCardTransactionCurrencyAmount;

            exchRate = itemizedHeaderExpTrans.CreditCardTransactionCurrencyAmount / itemizedHeaderExpTrans.AmountCurr;

            select sum(CreditCardTransactionCurrencyAmount), sum(AmountCurr) from itemizedExpTrans
                where itemizedExpTrans.ParentRecId == this.ParentRecId &&
                    itemizedExpTrans.RecId != this.RecId;

            itemizedAmountLocal = itemizedExpTrans.CreditCardTransactionCurrencyAmount;

            if ((totalAmountLocal - itemizedAmountLocal) == this.CreditCardTransactionCurrencyAmount)
            {
                //Itemization is complete in local currency, put all remaining amountCurr in this line.
                this.AmountCurr = itemizedHeaderExpTrans.AmountCurr - itemizedExpTrans.AmountCurr;
            }
            else
            {
                this.AmountCurr = TrvExpItemizationManager::currFromLocalWithRate( this.CreditCardTransactionCurrencyAmount, exchRate, this.ExchangeCode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectInfoForItemizedLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the itemzied lines project information based on itemized header.
    /// </summary>
    public void updateProjectInfoForItemizedLines()
    {
        TrvExpTrans     trvExpTransItemizedLines;

        update_recordset trvExpTransItemizedLines
            setting InterCompanyLE = this.InterCompanyLE,
                    InterCompanyCategory = this.InterCompanyCategory,
                    ProjId = this.ProjId,
                    ProjStatusId = this.ProjStatusId,
                    ProjActivityNumber = this.ProjActivityNumber,
                    ProjTransId = this.ProjTransId,
                    DefaultDimension = this.DefaultDimension
            where trvExpTransItemizedLines.LineType == TrvExpLineType::ItemizedLine
                && trvExpTransItemizedLines.ParentRecId == this.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNetTransactionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the actual sales tax amount if needed and the net transaction amount.
    /// </summary>
    /// <param name="usingCorectedTaxAmount">
    /// true indicates actual sales tax as entered by the user is used and is not calculated; false
    /// indicates the tax amount will be calculated.
    /// </param>
    public void updateNetTransactionAmount(boolean usingCorectedTaxAmount = false)
    {
        AmountCur transactionCurrencyAmount = this.isCreditCardTransaction() ? this.CreditCardTransactionCurrencyAmount : this.AmountCurr;
        // There is no tax for cash advance return.
        if (this.ExpType == TrvExpType::Advance)
        {
            this.NetTransactionAmount = this.AmountCurr;
        }
        else if (this.TaxGroup && this.TaxItemGroup)
        {
            this.modifyVatDueDate_W();

            if (!usingCorectedTaxAmount)
            {
                this.CorrectedTaxAmount = this.calcTaxAmount();
            }

            if (this.TaxIncluded)
            {
                this.NetTransactionAmount = transactionCurrencyAmount - this.CorrectedTaxAmount;
            }
            else
            {
                this.NetTransactionAmount = transactionCurrencyAmount;
            }
        }
        else
        {
            this.NetTransactionAmount = transactionCurrencyAmount;
            this.CorrectedTaxAmount = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjLineProperty</Name>
				<Source><![CDATA[
    void updateProjLineProperty()
    {
        if (this.isCategoryIntegratedWithProject())
        {
            this.ProjStatusId = ProjCategory::find(this.CostType).projLinePropertyId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateApprove</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that approval can be performed.
    /// </summary>
    /// <returns>
    ///     true if approval can be performed, false otherwise.
    /// </returns>
    /// <remarks>
    ///     We check for necessary approver justifications and budget.
    /// </remarks>
    public boolean validateApprove()
    {
        TrvParameters trvParameters = TrvParameters::find();

        List                violations = this.policyViolationLevelMsg();
        ListEnumerator      listEnumerator;
        TrvPolicyViolation  violation;

        listEnumerator = violations.getEnumerator();

        while (listEnumerator.moveNext())
        {
            violation = listEnumerator.current();
            if (violation.parmAdjustedViolationLevel() == TrvPolicyViolationLevel::Error)
            {
                return false;
            }
        }

        SourceDocumentProcessorFacade::submitOnDemandSourceDocLineImpl(this);

        if ((!trvParameters.IsAllowApproveExpenseOnBudgetFail && this.isBudgetFailed()) || this.isProjBudgetFailed())
        {
            error(strFmt("@SYS304369", this.CostType, this.AmountCurr, this.ExchangeCode));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDateTo</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the perdiem date fields.
    /// </summary>
    /// <returns>
    ///     true if the perdiem from and to dates are valid, false otherwise.
    /// </returns>
    public boolean validateDateTo(boolean _checkForFuture = false)
    {
        if (this.DateTo && this.ExpType == TrvExpType::Allowance)
        {
            if (this.DateFrom && this.DateTo < this.DateFrom)
            {
                return checkFailed(strFmt("@SYS101492", this.DateFrom, this.DateTo));
            }

            if (this.DateTo == this.DateFrom && TrvParameters::find().PerDiemCalculation != TrvPerDiemCalculation::CalendarDayNoTime)
            {
                return checkFailed("@SYS329287");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the current expense transaction can be deleted.
    /// </summary>
    /// <param name="_throwError">
    ///     Boolean value that indicates whether to throw an infolog error if validate fails. Defaulted to true.
    /// </param>
    /// <returns>True if the expense can be deleted, false otherwise.</returns>
    public boolean validateDelete(boolean _throwError = true)
    {
        boolean ret;

        ret = super();

        // If framework validation succeeds, then check additional validation.
        if (ret)
        {
            if (this.PBSRecId != 0)
            {
                ret = _throwError ? checkFailed("@Expense:CannotDeleteCreditCardTransactions") : false;
            }
            else if (this.ApprovalStatus != TrvAppStatus::Create)
            {
                if (ret && TrvWorkflowUtilities::recordHasActiveWorkItem(this))
                {
                    ret = _throwError ? checkFailed("@Expense:WorkflowRecordDeleteError") : false;
                }
                else
                {
                    ret = _throwError ? checkFailed("@Expense:CannotDeleteAlreadySubmitted") : false;
                }
            }
            else if (!TrvAccessHelper::canCreateNewTransactions(this.CreatingWorker) && !TrvAccessHelper::userHasCurrentDelegateAccessFor(this.CreatingWorker))
            {
                ret = _throwError ? checkFailed("@Expense:ExpenseReportNotEditable") : false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExpenseLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes all the validations in common between expense line and itemized line.
    /// It doesn't validate if itemized lines are over the expense line amount.
    /// </summary>
    /// <returns>
    /// true if the record is valid; otherwise, false.
    /// </returns>
    public boolean validateExpenseLine()
    {
        boolean             ret;
        ProjValCheckTrans   projValCheckTrans;
        ProjParameters      projParameters;
        ProjTable           projTable;
        DataAreaId          companyDataArea;
        boolean             isIntercompany;

        ret = true;
        // Ensure that the line/report has not been submitted
        if (this.anyUserFieldsHaveChanged())
        {
            TrvExpTable trvExpTable;
            
            if (this.TrvExpTable)
            {
                trvExpTable = TrvExpTable::findRecId(this.TrvExpTable);
            }
            
            if (trvExpTable.RecId && this.ApprovalStatus == TrvAppStatus::Returned)
            {
                ret = true;
            }
            else if (!this.isEditable(false)
                || (trvExpTable && !trvExpTable.isEditableBasedOnWorkflowStatus()))
            {
                throw error("@SYS125764");
            }
        }

        if (strLen(strLRTrim(this.ProjId)) > 0 && this.InterCompanyLE == this.ReferenceDataAreaId)
        {
            if (this.ExpType != TrvExpType::Personal && !this.isCategoryIntegratedWithProject())
            {
                ret = checkFailed("@SYS327727");
            }
            else
            {
                projTable = ProjTable::find(this.ProjId);
                if ((projTable.Status == ProjStatus::Completed) || (projTable.Header == NoYes::Yes))
                {
                    ret = checkFailed("@SYS327728");
                }
            }
        }
        
        companyDataArea = this.InterCompanyLE != '' ? this.InterCompanyLE : this.ReferenceDataAreaId;
        if (companyDataArea == '')
        {
            companyDataArea = curext();
        }

        isIntercompany = this.InterCompanyLE != '' && this.ReferenceDataAreaId != '' && this.InterCompanyLE != this.ReferenceDataAreaId;

        if (isIntercompany && ret && this.ExpType == TrvExpType::Advance)
        {
            ret = checkFailed(strFmt("@Expense:IntercompanyCashAdvanceException", this.ReferenceDataAreaId));
        }

        if (ret && this.ProjId != '')
        {
            changecompany(companyDataArea)
            {
                projParameters = ProjParameters::find();

                if (projParameters.ValidationEmplProj || projParameters.ValidationProjCategory)
                {
                    projValCheckTrans = new ProjValCheckTrans();

                    projValCheckTrans.parmIsIntercompany(isIntercompany);
                    if (!projValCheckTrans.validateMandatory(this))
                    {
                        return false;
                    }
                }
            }
        }

        if (ret && isIntercompany)
        {
            changecompany(companyDataArea)
            {
                ret = ret && TrvExpTrans::checkWorkerCategory(this.CreatingWorker, this.InterCompanyCategory, isIntercompany,
                     true, CompanyInfo::findDataArea(this.InterCompanyLE).RecId);
            }
        }

        if (this.CountryRegion && this.AddressState && LogisticsAddressState::find(this.CountryRegion, this.AddressState).RecId == 0)
        {
            ret = ret && checkFailed(strFmt("@SYS316757", tablePName(LogisticsAddressState)));
        }

        ret = ret && this.validateLineProperty();

        ret = ret && this.validateProjActivityNumber();

        ret = ret && this.validateTaxFields();

        ret = ret && this.validateExchRate();

        // validate project category when intercompanyexpense is enabled & Line is created in different LE
        if (TrvParameters::find().UseInterCompanyExpense &&
                this.ReferenceDataAreaId != this.InterCompanyLE &&
                this.ProjId != '' &&
                this.InterCompanyCategory == '')
        {
            ret = ret && checkFailed("@SYS4110117");
        }

        ret = ret && this.validateDateTo();

        ret = ret && this.expTypeSpecificValidation();

        ret = ret && this.validateNonChangingItemizedLineFields();

        ret = ret && this.validateMandatoryTravelRequisitionLine();

        if (this.ReferenceDataAreaId)
        {
            changecompany(this.ReferenceDataAreaId)
            {
                ret = ret && TrvCostType::validatePaymentMethod(this.CostType, this.PayMethod);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExpNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether expense report selected is valid for the expense line
    /// </summary>
    /// <param name = "_expNumber">The expense report number selected</param>
    /// <param name = "_isEditable">Whether the method should validate that selected expense report is editable.</param>
    /// <returns>True if selected expense report is valid; otherwise, false.</returns>
    public boolean validateExpNumber(boolean _checkEditable = true)
    {
        // Empty selection is valid
        if (this.ExpNumber == "")
        {
            return true;
        }

        TrvExpTable expenseReport = TrvExpTable::find(this.ExpNumber);

        if (expenseReport.RecId == 0)
        {
            return checkFailed("@Expense:CannotUpdateExpenseReport_DoesNotExist");
        }

        if (expenseReport.CreatingWorker != this.CreatingWorker)
        {
            return checkFailed("@Expense:CannotUpdateExpenseReport_WorkerMismatch");
        }

        if (expenseReport.LegalEntity != this.LegalEntity)
        {
            return checkFailed("@Expense:CannotUpdateExpenseReport_LegalEntityMismatch");
        }

        if (_checkEditable && expenseReport.ApprovalStatus != TrvAppStatus::Create)
        {
            return checkFailed("@Expense:CannotUpdateExpenseReport_AlreadySubmitted");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldId)
    {
        boolean             ret;
        DataAreaId          companyDataArea;

        // Skip the super for projectid and tax fields to check data in case of intercompany.
        if (this.isIntercompany() && (_fieldId == fieldnum(TrvExpTrans, ProjId)
                || _fieldId == fieldnum(TrvExpTrans, ProjActivityNumber)
                || _fieldId == fieldnum(TrvExpTrans, ProjStatusId)
                || _fieldId == fieldnum(TrvExpTrans, InterCompanyCategory)
                || _fieldId == fieldNum(TrvExpTrans, TaxGroup)
                || _fieldId == fieldNum(TrvExpTrans, TaxItemGroup)))
        {
            ret = true;
        }
        else
        {
            ret = super(_fieldId);
        }

        switch (_fieldId)
        {
            case (fieldNum(TrvExpTrans, kmPrice)):
                if (this.kmPrice < 0)
                {
                    ret = ret && checkFailed("@SYS105575");
                }
                break;

            case (fieldNum(TrvExpTrans, SubCategoryRecId)):
                ret = this.validateExpenseSubCategory()
                        && this.validateSubCategoryForCostType(this.SubCategoryRecId, this.CostType);
                break;

            case (fieldNum(TrvExpTrans, DeduktionBreakfest)):
            case (fieldNum(TrvExpTrans, DeduktionDinner)):
            case (fieldNum(TrvExpTrans, DeduktionLunch)):
                if (this.(_fieldId) < 0)
                {
                    ret = checkFailed("@SYS106933");
                }
                else
                {
                    // this method also validates that the reductions are not more than the actual allowance
                    this.perDiem();
                }
                break;

            case (fieldNum(TrvExpTrans, ExchangeRate)):
                ret = ret && this.validateExchRate();
                break;

            case (fieldNum(TrvExpTrans, ExchangeCode)):
                if (!this.ExchangeCode)
                {
                    ret = ret && checkFailed("@SYS25991");
                }
                break;

            case (fieldNum(TrvExpTrans, ExpNumber)):
                ret = ret && this.validateExpNumber();
                break;

            case (fieldNum(TrvExpTrans, TaxIncluded)):
                if (this.TaxIncluded && (this.CorrectedTaxAmount >= this.AmountCurr && this.AmountCurr > 0) || (this.CorrectedTaxAmount <= this.AmountCurr && this.AmountCurr < 0))
                {
                    ret = ret && checkFailed("@SYS322343");
                }
                break;

            case (fieldNum(TrvExpTrans, CorrectedTaxAmount)):
                if (this.CorrectedTaxAmount != 0 && (this.TaxGroup == '' || this.TaxItemGroup == ''))
                {
                    ret = ret && checkFailed("@SYS343338");
                }
                else
                {
                    if (this.TaxIncluded && (this.CorrectedTaxAmount >= this.AmountCurr && this.AmountCurr > 0) || (this.CorrectedTaxAmount <= this.AmountCurr && this.AmountCurr < 0))
                    {
                        ret = ret && checkFailed("@SYS322343");
                    }
                }
                break;

            case (fieldnum(TrvExpTrans, CostType)):
                ret = ret && this.validateCostType(this.CostType);
                break;

            case (fieldNum(TrvExpTrans, PayMethod)):
                // Skip the allowed payment method validation if user hasn't selected expense category.
                if (this.CostType)
                {
                    ret = ret && TrvCostType::validatePaymentMethod(this.CostType, this.PayMethod) &&
                        this.validatePaymentMethod(this.PayMethod);
                }
                break;

            case (fieldNum(TrvExpTrans, ProjId)):
                if (this.ProjId != '')
                {
                    companyDataArea = this.InterCompanyLE != '' ? this.InterCompanyLE : this.ReferenceDataAreaId;

                    changecompany(companyDataArea)
                    {
                        if (!ProjTable::find(this.ProjId).RecId)
                        {
                            ret = ret && checkFailed(strFmt("@Expense:TableFieldFKViolationMessage",
                                                        this.ProjId,
                                                        fieldpname(TrvExpTrans, ProjId),
                                                        tablepname(ProjTable)));
                        }
                        if (this.CostType)
                        {
                            ret = ret && TrvCostType::isValidCostTypeForProject(this.CostType, this.ProjId);
                        }
                    }

                    if (ret && this.InterCompanyLE == this.ReferenceDataAreaId && !this.isCategoryIntegratedWithProject())
                    {
                        ret = ret && checkFailed("@SYS327727");
                    }
                    else
                    {
                        changecompany(companyDataArea)
                        {
                            ret = ret && this.validateProject();
                        }
                    }

                }
                break;

            case (fieldNum(TrvExpTrans, ProjActivityNumber)):
                ret = ret && this.validateProjActivityNumber();
                break;

            case (fieldNum(TrvExpTrans, ProjStatusId)):
                ret = ret && this.validateLineProperty();
                break;

            case (fieldnum(TrvExpTrans, InterCompanyCategory)):
                if (TrvParameters::find().UseInterCompanyExpense)
                {
                    if (this.InterCompanyCategory != '')
                    {
                        changecompany(this.InterCompanyLE)
                        {
                            ProjCategory projCategory = ProjCategory::find(this.InterCompanyCategory);
                            if (!projCategory.RecId)
                            {
                                ret = ret && checkFailed(strFmt("@Expense:TheValue1InField2IsNotFoundInTheRelatedTable3", this.InterCompanyCategory,
                                        fieldId2name(tableNum(TrvExpTrans), fieldNum(TrvExpTrans, InterCompanyCategory)),
                                        tableId2pname(tableNum(ProjCategory))));
                            }
                            else if (projCategory.CategoryType != ProjCategoryType::Cost)
                            {
                                ret = ret && checkFailed(strFmt("@Expense:Intercompany_ProjectCategoryTypeInvalid", enum2str(ProjCategoryType::Cost)));
                            }
                            else
                            {
                                ret = ret && TrvExpTrans::checkWorkerCategory(this.CreatingWorker, this.InterCompanyCategory, this.isIntercompany(),
                                    true, this.isIntercompany() ? CompanyInfo::findDataArea(this.InterCompanyLE).RecId : this.LegalEntity);
                            }
                        }
                    }
                }
                break;

            case (fieldNum(TrvExpTrans, DateFrom)):
            case (fieldNum(TrvExpTrans, DateTo)):
                ret = this.validateDuplicateExpenses();
                ret = ret && this.validateDateTo();
                break;
            case (fieldNum(TrvExpTrans, TrvLocations)):
                ret = this.isOverlappingPerDiem(!TrvExpenseHelper::isTrvOverlappingPerdiemsForSameLocationFlightEnabled());
                break;
            case (fieldNum(TrvExpTrans, kmOwnCar)):
                if (this.kmOwnCar < 0)
                {
                    ret = ret && checkFailed("@SYS106811");
                }
                this.calcKM();
            case (fieldNum(TrvExpTrans, Amountcurr)):
            case (fieldNum(TrvExpTrans, Amountcurr)):
            case (fieldNum(TrvExpTrans, MappedToRequisitionLine)):
                changeCompany(this.InterCompanyLE ? this.InterCompanyLE : curExt())
                {
                    if (Ledger::isLedgerBudgetControlEnabled(Ledger::current()) && this.MappedToRequisitionLine
                        && CurrencyExchangeHelper::amountCur2MST(this.AmountCurr, this.ExchangeCode, this.ExchangeRate) > this.authorizedAmount())
                    {
                        ret = checkFailed("@Expense:AmountGreaterThanAuthorizedAmount");
                    }
                }
                break;
            case (fieldNum(TrvExpTrans, TaxGroup)):
            case (fieldNum(TrvExpTrans, TaxItemGroup)):
                ret = ret && this.validateTaxFields();
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSubCategoryForCostType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the expense sub category belongs to selected expense category.
    /// </summary>
    /// <param name = "_subCategoryRecId">
    /// The expense subcategory record Id.
    /// </param>
    /// <param name = "_costType">
    /// The expense cost type.
    /// </param>
    /// <returns>
    /// True, if the expense sub category belongs to selected expense category; otherwise, false.
    /// </returns>
    public boolean validateSubCategoryForCostType(TrvExpSubCategoryEDT _subCategoryRecId, TrvCostTypeEDT _costType)
    {
        TrvExpSubCategory trvExpSubCategory;

        select firstonly RecId from trvExpSubCategory
            where trvExpSubCategory.RecId == _subCategoryRecId
                && trvExpSubCategory.CostType == _costType;

        if (!trvExpSubCategory.RecId)
        {
            return checkFailed(strFmt("@SYS317893", _costType));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldNotChanged</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that the specified field is not changed.
    /// </summary>
    /// <param name="fieldId">
    ///     The field ID.
    /// </param>
    /// <returns>
    ///     true if the specified field value has changed, false otherwise.
    /// </returns>
    public boolean validateFieldNotChanged(FieldId fieldId)
    {
        // no check on insert, as we are settting the values
        if (!this.RecId)
        {
            return true;
        }

        if (this.(fieldId) != this.orig().(fieldId))
        {
            // You cannot change values for %1 field
            error(strFmt("@SYS97425",  fieldId2pname(tableNum(TrvExpTrans), fieldId)));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCostType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if the cost type selected is valid for the expense record
    /// </summary>
    /// <param name="_costType">
    /// The cost type to validate.
    /// </param>
    /// <returns>
    /// true if cost type is valid for record; otherwise, false.
    /// </returns>
    public boolean validateCostType(TrvCostTypeEDT _costType)
    {
        TrvCostType costType = TrvCostType::find(_costType);
        if (!costType.RecId || costType.IsInactive)
        {
            return checkFailed("@Expense:InvalidCostType");
        }

        // if this has already been set to an import only type, do not allow it to be changed
        if (this.orig().CostType && (this.Orig().CostType != _costType))
        {
            TrvCostType currentCostType = TrvCostType::find(this.orig().CostType);
            if (currentCostType && currentCostType.isImportOnly == NoYes::Yes)
            {
                return checkFailed("@Expense:CannotChangeImportOnlyCostType");
            }
            else if (currentCostType && costType.isImportOnly && !currentCostType.isImportOnly)
            {
                return checkFailed("@Expense:CannotChangeExistingCostTypeToImportOnly");
            }
        }

        boolean ret = true;
        if (ret && this.ProjId)
        {
            changecompany(this.InterCompanyLE)
            {
                ret = ret && TrvCostType::isValidCostTypeForProject(_costType, this.ProjId);

                // if cost type is valid, then validate if the cost type is valid for the creating worker.
                if (ret)
                {
                    ret = TrvCostType::isValidCostTypeForWorker(costType, this.CreatingWorker, this.LegalEntity);
                }
            }
        }
       
        // Cannot change to a personal category when not a credit card transaction and is not a personal line
        if (!this.isCreditCardTransaction() && costType.ExpType == TrvExpType::Personal && this.ParentRecId == 0)
        {
            ret = ret && checkFailed("@Expense:CannotSelectPersonalForOutOfPocket");
        }

        // Only certain categories are supported for credit card transactions
        if (this.isCreditCardTransaction() && !TrvUnreconciledExpenseHelper::isSupportedCategory(costType.ExpType, true))
        {
            ret = ret && checkFailed("@Expense:InvalidCategoryForCreditCard");
        }

        // Only certain categories are supported for mobile transactions
        if (this.Mobile_Statement && !TrvUnreconciledExpenseHelper::isSupportedCategory(costType.ExpType, false))
        {
            ret = ret && checkFailed("@Expense:InvalidCategoryForMobile");
        }

        //
        // Verify category allows the current payment method on credit card transactions ONLY
        // as payment method should never change on a credit card transaction.
        // Do not check for this on manual lines as defaulting may correct the error or the user
        // can manually correct the payment method before line save when invalid payment methods will be rejected.
        //
        if (this.isCreditCardTransaction() && !TrvCostType::validatePaymentMethod(costType.CostType, this.PayMethod))
        {
            ret = ret && checkFailed(strFmt("@Expense:InvalidCategoryForCreditCardExpenseDueToPaymentMethod", costType.CostType, this.PayMethod));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateItemization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if the total of all itemized lines (except for the current) is greater that total of the line,
    /// and fail if is over the amount of the expense line. Or if the amount categorized as personal is negative.
    /// </summary>
    /// <returns>
    /// true if the record is valid; otherwise, false.
    /// </returns>
    private boolean validateItemization()
    {
        boolean             ret;
        TrvExpTrans         header;
        TrvExpTrans         itemizedLine;
        AmountCur           totalItemized;

        ret = true;

        // Check for over itemization.
        if (this.ParentRecId && this.LineType == TrvExpLineType::ItemizedLine)
        {
            header = TrvExpTrans::find(this.ParentRecId);

            if (header.RecId)
            {
                if (header.isCreditCardTransaction() && this.ExpType == TrvExpType::Personal && this.AmountCurr < 0)
                {
                    ret = checkFailed("@Expense:AmountsThatAreCategorizedAsPersonalCannotBeNegative");
                }

                // Calculate sum of all child records but not current one because that could be changed from the time inserted.
                select sum(AmountCurr) from itemizedLine where itemizedLine.LineType == TrvExpLineType::ItemizedLine
                                                               && itemizedLine.ParentRecId == header.RecId
                                                               && itemizedLine.RecId != this.RecId;

                totalItemized = itemizedLine.AmountCurr + this.AmountCurr;

                if ((header.AmountCurr < 0.0 && totalItemized < header.AmountCurr) ||
                    (header.AmountCurr > 0.0 && totalItemized > header.AmountCurr))
                {
                    ret = checkFailed("@SYS309736");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLineProperty</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the line property field.
    /// </summary>
    /// <returns>
    ///     true if the line property is valid and not empty, false otherwise.
    /// </returns>
    private boolean validateLineProperty()
    {
        DataAreaId      dataAreaId;

        if (this.InterCompanyLE != '')
        {
            dataAreaId = this.InterCompanyLE;
        }
        else
        {
            dataAreaId = this.ReferenceDataAreaId;
        }

        if (dataAreaId && this.ProjStatusId != '')
        {
            changecompany(dataAreaId)
            {
                if (!ProjLineProperty::find(this.ProjStatusId).RecId)
                {
                    return checkFailed(strFmt("@Expense:TheValue1InField2IsNotFoundInTheRelatedTable3", this.ProjStatusId,
                            fieldId2name(tableNum(TrvExpTrans), fieldNum(TrvExpTrans, ProjStatusId)),
                            tableId2pname(tableNum(ProjLineProperty))));
                }
            }
        }
        else if (this.ProjId != '')
        {
            return checkFailed("@SYS76857");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNonChangingItemizedLineFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that payment method, exchange code and exchange code fields on the itemized lines have not been changed.
    /// </summary>
    /// <returns>
    ///     true if the non-changing itemized line fields are not changed, false otherwise.
    /// </returns>
    boolean validateNonChangingItemizedLineFields()
    {
        TrvExpTrans itemHeader;

        if (this.LineType == TrvExpLineType::ItemizedLine)
        {
            itemHeader = TrvExpTrans::find(this.ParentRecId);
            if ( (this.PayMethod    != itemHeader.PayMethod)    ||
                 (this.ExchangeCode != itemHeader.ExchangeCode) ||
                 (this.ExchangeRate != itemHeader.ExchangeRate)  )
            {
                return checkFailed("@SYS113379");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determine if the expense line is valid to post
    /// </summary>
    /// <returns>
    ///     True if it's valide to post. Otherwise, false.
    /// </returns>
    public boolean validatePost()
    {
        TrvParameters   trvParameters = TrvParameters::find();
        boolean         retval = true;
        TrvExpTrans     trvExpTransChild;

        if (this.LineType == TrvExpLineType::ItemizedHeader)
        {
            while select trvExpTransChild where trvExpTransChild.ParentRecId == this.RecId
            {
                retval = retval && trvExpTransChild.validatePost() ;
            }
        }
        else
        {
            // verify tax recovery
            if (TrvParametersTableHelper::isTaxRecoveryEnabled(trvParameters))
            {
                if (this.isTaxFieldsMandatory() && (!this.TaxGroup || !this.TaxItemGroup) )
                {
                    warning("@SYS134510");
                    retval = false;
                }
            }

            if (!this.validateProject())
            {
                retval = false;
            }

            // Create taxUncommitted, if taxUncommitted doesn't exist and is needed.
            if (this.TaxGroup && this.TaxItemGroup)
            {
                this.createTaxUncommitted();
            }

            if (!this.isProjectCostCommitted())
            {
                SourceDocumentProcessorFacade::submitOnDemandSourceDocLineImpl(this);
                if (this.budgetCheckResult() == BudgetCheckResult::Failed)
                {
                    error(strFmt("@SYS304370", this.CostType, this.AmountCurr, this.ExchangeCode));
                    retval = false;
                }
            }
        }

        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjActivityNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the project activity number field.
    /// </summary>
    /// <returns>
    ///     true if the project activity number is valid, false otherwise.
    /// </returns>
    private boolean validateProjActivityNumber()
    {
        DataAreaId  dataAreaId;

        if (this.InterCompanyLE != '')
        {
            dataAreaId = this.InterCompanyLE;
        }
        else
        {
            dataAreaId = this.ReferenceDataAreaId;
        }

        changecompany(dataAreaId)
        {
            if (this.ProjActivityNumber != '')
            {
                if (!smmActivities::find(this.ProjActivityNumber).RecId)
                {
                    return checkFailed(strFmt("@Expense:TheValue1InField2IsNotFoundInTheRelatedTable3", this.ProjActivityNumber,
                            fieldId2name(tableNum(TrvExpTrans), fieldNum(TrvExpTrans, ProjActivityNumber)),
                            tableId2pname(tableNum(smmActivities))));
                }
                else
                {
                    if (this.ProjId &&
                        smmActivityParentLinkTable::findByActivityAndParent(this.ProjActivityNumber, smmActivityParentType::Project, ProjTable::find(this.ProjId).RecId, tableNum(ProjTable)).RecId == 0)
                    {
                        return checkFailed(strFmt("@Proj:ActivityNumberNotAssociatedToProject",this.ProjActivityNumber, this.ProjId));
                    }
                }
            }
            else
            {
                if (this.ProjId && ProjTable::checkRequireActivity(this.ProjId, tableNum(TrvExpTrans)))
                {
                    // Fail because a project has been specified which requires activiy number.
                    return checkFailed("@Expense:ActivityNumberMissing");
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProject</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determine whether the project used in expense line is valid
    /// </summary>
    /// <returns>
    ///     True if the project used in valid. Otherwise, false.
    /// </returns>
    /// <remarks>
    ///     This is supposed to be called during submission and posting.
    /// </remarks>
    private boolean validateProject()
    {
        ProjTable           projTable;
        boolean             ret = true;
        ProjValCheckTrans   projValCheckTrans;
        boolean             isIntercompany;
        TrvLegalEntity      legalEntity;

        if (this.ProjId)
        {
            projValCheckTrans = new ProjValCheckTrans();

            isIntercompany = this.InterCompanyLE != '' && this.ReferenceDataAreaId != '' && this.InterCompanyLE != this.ReferenceDataAreaId;
            projValCheckTrans.parmIsIntercompany(isIntercompany);
            if (!projValCheckTrans.validateMandatory(this))
            {
                ret = false;
            }

            // For an inter company expense change the current company context.
            legalEntity = isIntercompany ? this.InterCompanyLE : curExt();

            changecompany(legalEntity)
            {
                projTable = ProjTable::find(this.ProjId);
                if (!projTable.status().validateWriteCreateJournal())
                {
                    // validateWriteCreateJournal will give failure message
                    ret = false;
                }

                if (projTable.Type == ProjType::Time)
                {
                    ret = checkFailed(strFmt("@SYS53011", ProjType::Time));
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjExpPoliciesExpense</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the project policies defined for the Expense line.
    /// </summary>
    /// <returns>
    ///     true if there was a failure, false otherwise.
    /// </returns>
    boolean validateProjExpPoliciesExpense()
    {
        boolean doValidateProjExpPoliciesExpense()
        {
            CustAccount          sClient;
            ProjInvoiceProjId    sContract;
            ProjExpPolicies      tProjPolicies;
            boolean              ret = true;
            ProjLineProperty     tProjLineProperty;
            str                  dateStr;

            //reset policy status
            this.ProjPolicyStatus = ProjExpPolicyStatus::NoPolicy;
            this.ProjPolicyText = '';

            //reset amounts
            this.ReimburseAmt = 0;
            this.InvoiceAmt = 0;

            sContract = ProjTable::find(this.ProjId).ProjInvoiceProjId;
            sClient = ProjFundingSource::findCustAccount(sContract).CustAccount;
            dateStr = date2str(this.TransDate, 312, 2,3,2,3,4, DateFlags::FormatAll);

            //retrieve company rules
            tProjPolicies = ProjExpPolicies::findRulesByType(this.TransDate, this.ExchangeCode,
                this.CostType, this.CreatingWorker, this.editCity(), sClient, sContract, this.ProjId,
                ProjExpPolicyPerUnit::Expense, ProjExpPolicyType::Company);

            //Check Company Rules
            while (tProjPolicies)
            {
                str receiptMessage = '';
                str projPolicyMessage = '';

                //Check Receipt Required
                if (tProjPolicies.ReceiptRequired == NoYes::Yes && (tProjPolicies.ReceiptMin == 0 || tProjPolicies.ReceiptMin <= this.AmountCurr))
                {
                    this.ReceiptRequired = NoYes::Yes;

                    // Set the warning only if there is no receipt.
                    if (this.ReceiptsAttached == NoYes::No)

                    {
                        // If there is already an error, that takes precedence. Don't overwrite.
                        if ((this.ProjPolicyStatus != ProjExpPolicyStatus::DayFailed) && (this.ProjPolicyStatus != ProjExpPolicyStatus::ReportFailed) && (this.ProjPolicyStatus != ProjExpPolicyStatus::ExpenseFailed))
                        {
                            this.ProjPolicyStatus = ProjExpPolicyStatus::ExpenseWarning;
                        }

                        receiptMessage = strFmt("@SYS341324", tProjPolicies.ReceiptMin);

                        if (this.ProjPolicyText != '')
                        {
                            this.ProjPolicyText += ' ' + receiptMessage;
                        }
                        else
                        {
                            this.ProjPolicyText = receiptMessage;
                        }
                    }
                }

                //Check Amount
                if (this.AmountCurr > tProjPolicies.AllowableAmount)
                {
                    if (tProjPolicies.MaximumAmount == 0 || this.AmountCurr > tProjPolicies.MaximumAmount)
                    {
                        //fail
                        this.ReimburseAmt = 0;
                        this.ProjPolicyStatus = ProjExpPolicyStatus::ExpenseFailed;
                        ret = false;
                    }
                    else
                    {
                        // If there is already an error, that takes precedence. Don't overwrite.
                        if ((this.ProjPolicyStatus != ProjExpPolicyStatus::DayFailed) && (this.ProjPolicyStatus != ProjExpPolicyStatus::ReportFailed) && (this.ProjPolicyStatus != ProjExpPolicyStatus::ExpenseFailed))
                        {
                            this.ProjPolicyStatus = ProjExpPolicyStatus::ExpenseWarning;
                            this.ReimburseAmt = tProjPolicies.AllowableAmount;
                        }
                    }

                    projPolicyMessage = strFmt("@Expense:ProjectPolicyMessage_ExpenseLevel", this.AmountCurr, this.CostType, tProjPolicies.AllowableAmount);
                    if (this.ProjPolicyText != '')
                    {
                        this.ProjPolicyText += ' ' + projPolicyMessage;
                    }
                    else
                    {
                        this.ProjPolicyText = projPolicyMessage;
                    }
                }
                else
                {
                    // no check for DayFailed or ReportFailed
                    // they get set at submit time; this is updated on every line edit
                    if (this.ProjPolicyStatus != ProjExpPolicyStatus::ExpenseFailed)
                    {
                        this.ReimburseAmt = this.AmountCurr;
                    }
                }
                next tProjPolicies;
            }

            if (!ret)
            {
                return ret;
            }

            //If To Be Invoiced: Check Client Rules
            select firstonly ToBeInvoiced from tProjLineProperty
                where tProjLineProperty.LinePropertyId == this.ProjStatusId;

            if (tProjLineProperty.ToBeInvoiced == NoYes::Yes && this.ProjId)
            {
                //find client rules
                tProjPolicies.clear();
                tProjPolicies = ProjExpPolicies::findRulesByType(this.TransDate, this.ExchangeCode,
                    this.CostType, this.CreatingWorker, this.editCity(), sClient, sContract,
                    this.ProjId, ProjExpPolicyPerUnit::Expense, ProjExpPolicyType::Client);

                while (tProjPolicies)
                {
                    str receiptMessage = '';
                    str projPolicyMessage = '';

                    //Check Receipt Required
                    if (tProjPolicies.ReceiptRequired == NoYes::Yes && (tProjPolicies.ReceiptMin == 0 || tProjPolicies.ReceiptMin <= this.AmountCurr))
                    {
                        this.ReceiptRequired = NoYes::Yes;

                        // Set the warning only if there is no receipt.
                        if (this.ReceiptsAttached == NoYes::No)
                        {
                            // If there is already an error, that takes precedence. Don't overwrite.
                            if ((this.ProjPolicyStatus != ProjExpPolicyStatus::DayFailed) && (this.ProjPolicyStatus != ProjExpPolicyStatus::ReportFailed) && (this.ProjPolicyStatus != ProjExpPolicyStatus::ExpenseFailed))
                            {
                                this.ProjPolicyStatus = ProjExpPolicyStatus::ExpenseWarning;
                            }

                            receiptMessage = strFmt("@SYS341324", tProjPolicies.ReceiptMin);

                            if (this.ProjPolicyText != '')
                            {
                                this.ProjPolicyText += ' ' + receiptMessage;
                            }
                            else
                            {
                                this.ProjPolicyText = receiptMessage;
                            }
                        }
                    }

                    //Check Amount
                    if (this.AmountCurr > tProjPolicies.AllowableAmount)
                    {
                        if (tProjPolicies.MaximumAmount == 0 || this.AmountCurr > tProjPolicies.MaximumAmount)
                        {
                            this.InvoiceAmt = 0;
                            this.ProjPolicyStatus = ProjExpPolicyStatus::ExpenseFailed;
                            ret = false;
                        }
                        else
                        {
                            if ((this.ProjPolicyStatus != ProjExpPolicyStatus::DayFailed) && (this.ProjPolicyStatus != ProjExpPolicyStatus::ReportFailed) && (this.ProjPolicyStatus != ProjExpPolicyStatus::ExpenseFailed))
                            {
                                this.ProjPolicyStatus = ProjExpPolicyStatus::ExpenseWarning;
                                this.InvoiceAmt = tProjPolicies.AllowableAmount;
                            }
                        }

                        projPolicyMessage = strFmt("@Expense:ProjectPolicyMessage_ExpenseLevel", this.AmountCurr, this.CostType, tProjPolicies.AllowableAmount);
                        if (this.ProjPolicyText != '')
                        {
                            this.ProjPolicyText += ' ' + projPolicyMessage;
                        }
                        else
                        {
                            this.ProjPolicyText = projPolicyMessage;
                        }
                    }
                    else
                    {
                        if ((this.ProjPolicyStatus != ProjExpPolicyStatus::DayFailed) && (this.ProjPolicyStatus != ProjExpPolicyStatus::ReportFailed) && (this.ProjPolicyStatus != ProjExpPolicyStatus::ExpenseFailed))
                        {
                            this.InvoiceAmt = this.AmountCurr;
                        }
                    }
                    next tProjPolicies;
                }
            }

            return ret;
        }

        if (this.InterCompanyLE != '')
        {
            changecompany(this.InterCompanyLE)
            {
                return doValidateProjExpPoliciesExpense();
            }
        }
        else
        {
            return doValidateProjExpPoliciesExpense();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateResubmit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method validates the expense line before it can be resubmitted.
    /// </summary>
    /// <returns>
    ///     Boolean indicating whether validation succeeded or not.
    /// </returns>
    /// <remarks>
    ///     The validations include incomplete distributions, policy and budget errors.
    /// </remarks>
    public boolean validateResubmit()
    {
        TrvParameters           trvParameters = TrvParameters::find();
        boolean                 personalPaidByEmployee = (trvParameters.PersonalPaidBy == TrvPersonalPaidBy::Employee);
        AccountingDistribution  accountingDistribution;
        boolean                 invalidLedgerDimension = false;

        this.evaluateProjectPoliciesAndSave();

        if (this.anyProjectPolicyViolations())

        {
            return false;
        }

        TrvPolicyEvalEngine::evaluateViolationsForLine(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);
        // check policies
        if (TrvPolicyEvalEngine::anyPolicyErrorsForLine(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy))
        {
            return false;
        }

        if (this.LineType != TrvExpLineType::ItemizedHeader &&
            this.SplitLineType != TrvExpSplitLineType::SplitHeader &&
           !(this.ExpType == TrvExpType::Personal && personalPaidByEmployee))
        {
            // only check distributions for lines for which distributions are created
            if (!this.isDistributionsCompleted())
            {
                error(strFmt("@SYS340882",this.CostType, this.AmountCurr, this.ExchangeCode));
                return false;
            }
        }

        // Validate project id used
        if (!this.validateProject())
        {
            return false;
        }

        // This will create distributions if they don't exist
        // It will check budget, even if the line is fully distributed
        SourceDocumentProcessorFacade::submitOnDemandSourceDocLineImpl(this);
        if (!trvParameters.IsAllowSubmitExpenseOnBudgetFail && (this.isBudgetFailed() || this.isProjBudgetFailed()) )
        {
            error(strFmt("@SYS304368", this.CostType, this.AmountCurr, this.ExchangeCode));
            return false;
        }

        // Validate the ledge dimension value of the accounting distributions
        while select AccountingLegalEntity, LedgerDimension, AccountingDate from accountingDistribution
            where accountingDistribution.SourceDocumentLine == this.SourceDocumentLine
        {
            if (!TrvExpTable::validateLedgerDimension(accountingDistribution.AccountingLegalEntity, accountingDistribution.LedgerDimension, accountingDistribution.AccountingDate))
            {
                invalidLedgerDimension = true;
            }
        }

        if (invalidLedgerDimension)
        {
            error("@SYS138712");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaxFields</Name>
				<Source><![CDATA[
    private boolean validateTaxFields()
    {
        TrvLegalEntity taxCompany = TrvExpTrans::getLegalEntityForTax(this);

        CompanyInfo foundDataArea = CompanyInfo::findDataArea(taxCompany);

        if (foundDataArea)
        {
            changeCompany(taxCompany)
            {
                if (this.TaxGroup != '' && !TaxGroupHeading::find(this.TaxGroup).RecId)
                {
                    return checkFailed(strFmt("@Expense:TheValue1InField2IsNotFoundInTheRelatedTable3", this.TaxGroup,
                    fieldId2name(tableNum(TrvExpTrans), fieldNum(TrvExpTrans, TaxGroup)),
                    tableId2pname(tableNum(TaxGroupHeading))));
                }

                if (this.TaxItemGroup != '' && !TaxItemGroupHeading::find(this.TaxItemGroup).RecId)
                {
                    return checkFailed(strFmt("@Expense:TheValue1InField2IsNotFoundInTheRelatedTable3", this.TaxItemGroup,
                    fieldId2name(tableNum(TrvExpTrans), fieldNum(TrvExpTrans, TaxItemGroup)),
                    tableId2pname(tableNum(TaxItemGroupHeading))));
                }
            }
        }
        else
        {
            throw error("@Expense:InvalidExpenseInterCompanyLE");
        }


        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransactionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validate the amount entered by the use is not zero.
    /// </summary>
    /// <returns>
    ///     true if the amount is zero, false otherwise.
    /// </returns>
    /// <remarks>
    ///     For Mileage, Perdiem expense types, the amount cannot be entered and is not validated.
    ///     We also do not validate for Credit card and Cash advance, as the user cannot edit the amount.
    /// </remarks>
    public boolean validateTransactionAmount()
    {
        if (this.ExpType != TrvExpType::Transport &&
            this.ExpType != TrvExpType::Allowance &&
            !this.isCreditCardTransaction() &&
            this.CashAdvanceRecId == 0)
        {
            if (this.AmountCurr == 0)
            {
                error("@SYS342907");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that the exchange rate has been provided.
    /// </summary>
    /// <returns>
    ///     true if the exchange rate is valid, false otherwise.
    /// </returns>
    public boolean validateExchRate()
    {
        if (this.ExchangeRate <= 0)
        {
            return checkFailed(strFmt("@SYS84753", fieldPName(TrvExpTrans, ExchangeRate)));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean             ret;

        ret = super();

        ret = ret && this.validateExpenseLine();
        ret = ret && this.validateItemization();

        if (ret && this.ExpType == TrvExpType::Allowance && this.DateTo && this.DateFrom && this.TrvLocations)
        {
            ret = ret && this.verifyPerDiemRules();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatRecoveryTaxId</Name>
				<Source><![CDATA[
    display TrvTaxRecoveryNumber vatRecoveryTaxId()
    {
        TrvExpenseTaxRecovery trvExpenseTaxRecovery;

        select firstonly TaxRecoveryNumber from trvExpenseTaxRecovery where
            trvExpenseTaxRecovery.ExpTransRecId == this.RecId;

        return trvExpenseTaxRecovery.TaxRecoveryNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountCurExpLineWithoutTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// returns the amount in transaction currency without corrected tax for that expense line
    /// </summary>
    /// <param name="trans">
    /// The expense line for which this method computes the total
    /// </param>
    /// <returns>
    /// The amount in transaction currency without corrected tax
    /// </returns>
    public static AmountCur amountCurExpLineWithoutTax(TrvExpTrans trans)
    {
        if (trans.TaxIncluded == NoYes::Yes)
        {
            return trans.AmountCurr - trans.CorrectedTaxAmount;
        }
        else
        {
            return trans.AmountCurr;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxAmountRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount for a certain expense.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the expense.
    /// </param>
    /// <returns>
    /// The tax amount of the expense
    /// </returns>
    static TaxAmountCur calcTaxAmountRecId(RefRecId _recId)
    {
        TrvExpTrans currentTrans;

        currentTrans = TrvExpTrans::find(_recId);
        if (currentTrans)
        {
            return(currentTrans.calcTaxAmount());
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWorkerCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// This function will check the combination of the worker and category is valid for the expense line
    /// when the validation of category/worker parameter is set to mandatory
    /// </summary>
    /// <param name="_workerRecId">
    /// The record ID of the worker.
    /// </param>
    /// <param name="_categoryId">
    /// The expense category ID.
    /// </param>
    /// <param name="_isIntercompany">
    /// Is the expense line belongs to intercompany.
    /// </param>
    /// <param name="_showValidationMessage">
    /// Indicates whether validation error message to be shown or not.
    /// </param>
    /// <param name="_workerLegalEntity">
    /// The legal entity record ID of the worker.
    /// </param>
    /// <returns>
    /// true, if the combination of worker and category is valid; false, otherwise.
    /// </returns>
    /// <remarks>
    /// Performs worker/category validation.
    /// </remarks>
    public static boolean checkWorkerCategory(ProjWorkerRecId _workerRecId, ProjCategoryId _categoryId, boolean  _isIntercompany,
        boolean _showValidationMessage = true, LegalEntityRecId _workerLegalEntity = CompanyInfo::current())
    {
        ProjParameters              projParameters;
        ProjValEmplCategorySetUp    projValEmplCategorySetUp, projValEmplCategorySetUp2;
        boolean                     ret = true;
        ResourceRecId               resource = ResourceFacade::findByWorker(_workerRecId, _workerLegalEntity);

        projParameters = ProjParameters::find();
        if (projParameters.ValidationEmplCategory == ProjValParameter::Mandatory)
        {
            if (ProjCategory::createResourceConnection(resource, _isIntercompany))
            {
                select firstonly projValEmplCategorySetUp
                    where projValEmplCategorySetUp.Resource    == resource  &&
                          projValEmplCategorySetUp.CategoryId  == _categoryId;

                // Check group
                if (!projValEmplCategorySetUp)
                {
                    select firstonly projValEmplCategorySetUp
                        where projValEmplCategorySetUp.CategoryId      == _categoryId    &&
                              projValEmplCategorySetUp.GroupId
                        exists join  projValEmplCategorySetUp2
                              where projValEmplCategorySetUp2.Resource == resource   &&
                                    projValEmplCategorySetUp2.GroupId  == projValEmplCategorySetUp.GroupId;

                    if (!projValEmplCategorySetUp)
                    {
                        if (_showValidationMessage)
                        {
                            // %1 category is not valid for employee %2 in %3 with resource/category validation set to mandatory.
                            return checkFailed(strFmt("@Expense:WorkerCategoryValidationError", _categoryId, HcmWorker::find(_workerRecId).PersonnelNumber, CompanyInfo::getDataArea(_workerLegalEntity)));
                        }
                        else
                        {
                            ret = false;
                        }
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableWFControl</Name>
				<Source><![CDATA[
    static boolean enableWFControl(TrvExpNumber _expNumber)
    {
        TrvExpTrans trvExpTrans;

        return (select firstonly RecId from trvExpTrans where trvExpTrans.ExpNumber == _expNumber &&
                                                              trvExpTrans.ApplyAction == true &&
                                                              trvExpTrans.LegalEntity == CompanyInfo::current()).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    public static boolean exist(RefRecId _recId)
    {
        return (select firstonly RecId from trvExpTrans where trvExpTrans.RecId == _recId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsSourceDocumentLine</Name>
				<Source><![CDATA[
    public static boolean existsSourceDocumentLine(RefRecId _sourceDocumentLine)
    {
        return (select firstonly RecId from trvExpTrans where trvExpTrans.SourceDocumentLine == _sourceDocumentLine).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    public static TrvExpTrans find(RefRecId _recId, boolean _forUpdate = false)
    {
        TrvExpTrans trvExpTrans;
        if (_recId)
        {
            trvExpTrans.selectForUpdate(_forUpdate);
            select firstonly trvExpTrans where trvExpTrans.RecId == _recId;
        }
        return trvExpTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the expense line given the source document line.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    ///     The <c>RecId</c> of the source document line.
    /// </param>
    /// <param name="_forUpdate">
    ///     Boolean value indicating whether the returned buffer is to be selected for update.
    /// </param>
    /// <returns>
    ///     The expense line record.
    /// </returns>
    static public TrvExpTrans findBySourceDocumentLine(RefRecId _sourceDocumentLine, boolean _forUpdate = false)
    {
        TrvExpTrans trvExpTrans;

        if (_sourceDocumentLine)
        {
            trvExpTrans.selectForUpdate(_forUpdate);
            select firstonly trvExpTrans where trvExpTrans.SourceDocumentLine == _sourceDocumentLine;
        }

        return trvExpTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByTransactionNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the expense line given transaction number.
    /// </summary>
    /// <param name="_expTransNumber">
    ///     The natural key of the source document line.
    /// </param>
    /// <param name="_forUpdate">
    ///     Boolean value indicating whether the returned buffer is to be selected for update.
    /// </param>
    /// <returns>
    ///     The expense line record.
    /// </returns>
    static public TrvExpTrans findByTransactionNumber(str _expTransNumber, boolean _forUpdate = false)
    {
        TrvExpTrans trvExpTrans;

        if (_expTransNumber)
        {
            trvExpTrans.selectForUpdate(_forUpdate);
            select firstonly trvExpTrans where trvExpTrans.ExpTransNumber == _expTransNumber;
        }

        return trvExpTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateEnhancedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in the enhanced data table for this expense transaction line, if it not already
    /// present.
    /// </summary>
    /// <param name="_trvExpTrans">
    /// The transaction line for which to create the enhanced data.
    /// </param>
    /// <returns>
    /// The record ID for the enhanced data record.
    /// </returns>
    /// <remarks>
    /// Finds or creates the enhanced data that is related to the expense line.
    /// </remarks>
    public static RefRecId findOrCreateEnhancedData(TrvExpTrans _trvExpTrans)
    {
        TrvEnhancedCarRentalData    trvEnhancedCarRentalData;
        TrvEnhancedItineraryData    trvEnhancedItineraryData;
        TrvEnhancedHotelData        trvEnhancedHotelData;
        TrvEnhancedData             trvEnhancedData;
        RefRecId                    trvEnhancedDataRecId;
        ;

        select firstonly trvEnhancedData
            where trvEnhancedData.TransactionRecord == _trvExpTrans.RecId;

        // Enhanced data record already exists, do nothing
        if (trvEnhancedData != null)
        {
            return trvEnhancedData.RecId;
        }

        ttsbegin;

        switch (_trvExpTrans.ExpType)
        {
            case TrvExpType::Airline:
                trvEnhancedItineraryData.TransactionRecord = _trvExpTrans.RecId;
                trvEnhancedItineraryData.insert();
                trvEnhancedDataRecId = trvEnhancedItineraryData.RecId;
                break;

            case TrvExpType::CarRental:
                trvEnhancedCarRentalData.TransactionRecord = _trvExpTrans.RecId;
                trvEnhancedCarRentalData.insert();
                trvEnhancedDataRecId = trvEnhancedCarRentalData.RecId;
                break;

            case TrvExpType::Hotel:
                trvEnhancedHotelData.TransactionRecord = _trvExpTrans.RecId;
                trvEnhancedHotelData.insert();
                trvEnhancedDataRecId = trvEnhancedHotelData.RecId;
                break;
        }

        ttscommit;

        return trvEnhancedDataRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertNewRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds a new expense line to the specified expense report.
    /// </summary>
    /// <param name="_expNumber">
    ///     The expense report number.
    /// </param>
    /// <param name="_costType">
    ///     The category ID.
    /// </param>
    /// <exception cref="Exception::Error">
    ///     If an invalid expense number is passed, error is thrown.
    /// </exception>
    public static void insertNewRecord(TrvExpNumber _expNumber, TrvCostTypeEDT _costType)
    {
        TrvExpTable trvExpTable;
        TrvExpTrans trvExpTrans;
        boolean     evaluatePolicies = false;

        if (_expNumber)
        {
            trvExpTable = TrvExpTable::find(_expNumber);
            if (!trvExpTable.RecId)
            {
                throw error("@SYS341928");
            }
            ttsbegin;
            trvExpTrans.ExpNumber = _expNumber;
            trvExpTrans.LineType = TrvExpLineType::Default;
            trvExpTrans.ApprovalStatus = TrvAppStatus::Create;
            if (_costType)
            {
                trvExpTrans.CostType = _costType;
                trvExpTrans.initValue();
            }
            else
            {
                trvExpTrans.TrvExpTable = trvExpTable.RecId;
                trvExpTrans.LegalEntity = CompanyInfo::current();
                trvExpTrans.ReferenceDataAreaId = curext();
                trvExpTrans.InterCompanyLE = curext();
            }

            // no evaluation of policies since TransDate, Amount is still not set
            trvExpTrans.insert(evaluatePolicies);
            ttscommit;
        }
        else
        {
            throw error("@SYS341928");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPersonalLineforSplit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts an expense line of type personal
    /// </summary>
    /// <param name="_headerRecId">
    /// The expense header line recid.
    /// </param>
    /// <param name="_expCategoryId">
    /// The category ID.
    /// </param>
    /// <param name="_isSplittedToPersonal">
    /// Boolean value that indicates whether this is an itemized header or split to personal header.
    /// </param>
    /// <returns>
    /// Boolean value indicating whether the insert was successful.
    /// </returns>
    public static boolean insertPersonalLineforSplit(RecId _headerRecId, TrvCostTypeEDT _expCategoryId, NoYes _isSplittedToPersonal = NoYes::No)
    {
        TrvExpTrans     header;
        TrvExpTrans     personalExpLine;
        TrvCostType     expCategory;
        boolean         ret;

        header      = TrvExpTrans::find(_headerRecId);
        expCategory = TrvCostType::find(_expCategoryId);

        if (header && expCategory && expCategory.ExpType == TrvExpType::Personal
                    && !(TrvExpTrans::isChildLineExisting(header.RecId,TrvExpType::Personal))
                    && header.remainingAmount() > 0.0)
        {
            ttsbegin;
            personalExpLine.clear();

            personalExpLine.CostType = expCategory.CostType;
            personalExpLIne.ExpType = expCategory.ExpType;
            personalExpLine.IsSplit = _isSplittedToPersonal;
            personalExpLine.initFromTrvExpItemizedHeader(header);

            personalExpLine.AmountCurr = 0.0;
            personalExpLine.TransDate = header.TransDate;
            personalExpLine.insert();
            ret = true;
            ttscommit;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRemainingAsPersonal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new personal line with the remaining amount on the itemized or split header.
    /// </summary>
    /// <param name="_headerRecId">
    /// The <c>RecId</c> of the itemized or split header.
    /// </param>
    /// <param name="_expCategoryId">
    /// The category ID.
    /// </param>
    /// <param name="_isSplittedToPersonal">
    /// Boolean value that indicates whether this is an itemized header or split to personal header.
    /// </param>
    /// <returns>
    /// true if the insert was successful, false otherwise.
    /// </returns>
    public static boolean insertRemainingAsPersonal(RecId _headerRecId, TrvCostTypeEDT _expCategoryId, NoYes _isSplittedToPersonal = NoYes::No)
    {
        TrvExpTrans     header, itemizedLine;
        TrvExpTrans     personalExpLine;
        AmountCur       creditCardTransactionAmount = 0.0;
        TrvExpTrans     existingPersonalExpLine;
        TrvCostType     expCategory;
        AmountCur       remainingAmount;
        boolean         ret;

        header      = TrvExpTrans::find(_headerRecId);
        expCategory = TrvCostType::find(_expCategoryId);

        if (header && expCategory && expCategory.ExpType == TrvExpType::Personal)
        {
            remainingAmount = header.remainingAmount();
            if (remainingAmount <= 0.0)
            {
                ret = checkFailed("@SYS114250");
            }
            else
            {
                if (header.CreditCardTransactionCurrencyAmount > 0)
                {
                    select sum(CreditCardTransactionCurrencyAmount) from itemizedLine
                    where itemizedLine.ParentRecId == header.RecId;
                    creditCardTransactionAmount = header.CreditCardTransactionCurrencyAmount - itemizedLine.CreditCardTransactionCurrencyAmount;
                }

                // if a child line exist with same category then udpate that line instead of adding new line
                select forupdate firstonly existingPersonalExpLine where existingPersonalExpLine.CostType == expCategory.CostType && existingPersonalExpLine.ParentRecId == header.RecId;
                if (existingPersonalExpLine.RecId != 0)
                {
                    existingPersonalExpLine.AmountCurr += remainingAmount;
                    if (creditCardTransactionAmount > 0)
                    {
                        existingPersonalExpLine.CreditCardTransactionCurrencyAmount += creditCardTransactionAmount;
                    }

                    existingPersonalExpLine.update();
                }
                else
                {
                    ttsbegin;
                    personalExpLine.clear();

                    personalExpLine.CostType = expCategory.CostType;
                    personalExpLine.ExpType = expCategory.ExpType;
                    personalExpLine.IsSplit = _isSplittedToPersonal;
                    personalExpLine.initFromTrvExpItemizedHeader(header);

                    remainingAmount = header.remainingAmount();
                    personalExpLine.AmountCurr = remainingAmount;

                    if (creditCardTransactionAmount > 0)
                    {
                        personalExpLine.CreditCardTransactionCurrencyAmount = creditCardTransactionAmount;
                    }
                    personalExpLine.TransDate = header.TransDate;
                    personalExpLine.insert();
                    ret = true;
                    ttscommit;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRemainingWithGivenCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new child line of given category with the remaining amount on the itemized or split header.
    /// </summary>
    /// <param name="_headerRecId">
    /// The <c>RecId</c> of the itemized or split header.
    /// </param>
    /// <param name="_expCategoryId">
    /// The category ID.
    /// </param>
    /// <param name="_isSplittedToPersonal">
    /// Boolean value that indicates whether this is an itemized header or split to personal header.
    /// </param>
    /// <returns>
    /// true if the insert was successful, false otherwise.
    /// </returns>
    public static boolean insertRemainingWithGivenCategory(RecId _headerRecId, TrvCostTypeEDT _expCategoryId, NoYes _isSplittedToPersonal = NoYes::No)
    {
        TrvExpTrans     header;
        TrvExpTrans     expLine,itemizedLine;
        TrvCostType     expCategory;
        AmountCur       remainingAmount;
        boolean         ret;

        header      = TrvExpTrans::find(_headerRecId);
        expCategory = TrvCostType::find(_expCategoryId);

        if (header && expCategory && expCategory.ExpType != TrvExpType::Personal)
        {
            remainingAmount = header.remainingAmount();
            if (remainingAmount > 0.0)
            {
                ttsbegin;
                expLine.clear();

                expLine.CostType = expCategory.CostType;
                expLine.ExpType = expCategory.ExpType;
                expLine.IsSplit = _isSplittedToPersonal;
                expLine.initFromTrvExpItemizedHeader(header);

                expLine.AmountCurr = remainingAmount;
                expLine.TransDate = header.TransDate;
                if (header.CreditCardTransactionCurrencyAmount > 0)
                {
                    select sum(CreditCardTransactionCurrencyAmount) from itemizedLine
                        where itemizedLine.ParentRecId == header.RecId;
                    expLine.CreditCardTransactionCurrencyAmount = header.CreditCardTransactionCurrencyAmount - itemizedLine.CreditCardTransactionCurrencyAmount;
                }

                expLine.insert();
                ret = true;
                ttscommit;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChildLineExisting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a child line exists for an expense line
    /// </summary>
    /// <param name="headerRecId">
    /// The expense header line recid.
    /// </param>
    /// <param name="expType">
    /// Optional expense type
    /// </param>
    /// <returns>
    /// Boolean value that indicates whether a child line exists.
    /// </returns>
    public static boolean isChildLineExisting(RecId headerRecId,TrvExpType expType = TrvExpType::Empty)
    {
        TrvExpTrans childLine;
        TrvCostType costType;

        select firstonly RecId from childLine where childLine.ParentRecId == headerRecId;
        if (expType == TrvExpType::Empty)
        {
            if (childLine.RecId == 0)
            {
                return false;
            }
            else
            {
                return true;
            }
        }
        else
        {
            select firstonly RecId from costType where costType.CostType == childLine.CostType && costType.ExpType == expType;
            if (costType.RecId == 0)
            {
                return false;
            }
            else
            {
                return true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemizedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gives the itemized amount of the specified expense line.
    /// </summary>
    /// <param name="_headerRecId">
    /// The <c>RecId</c> of the header expense line.
    /// </param>
    /// <returns>
    /// The itemized amount of the specified expense line.
    /// </returns>
    public static Amount itemizedAmount(RefRecId _headerRecId)
    {
        TrvExpTrans itemizedExpTrans;

        if (_headerRecId == 0)
        {
            return 0.0;
        }

        select sum(AmountCurr), sum(CreditCardTransactionCurrencyAmount) from itemizedExpTrans
            where itemizedExpTrans.ParentRecId == _headerRecId
                && itemizedExpTrans.ExpType != TrvExpType::Personal;

        if (TrvExpTrans::find(_headerRecId).isCreditCardTransanctionInLocalCurrency())
        {
            return itemizedExpTrans.CreditCardTransactionCurrencyAmount;
        }
        else
        {
            return itemizedExpTrans.AmountCurr;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalOfChildLinesWithoutTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// returns the amount in transaction currency for an expense header line
    /// by summing up the amounts without tax for all the child lines
    /// </summary>
    /// <param name="trans">
    /// The expense line for which this method computes the total
    /// </param>
    /// <returns>
    /// The amount in transaction currency without corrected tax for expense header line
    /// </returns>
    public static AmountCur totalOfChildLinesWithoutTax(TrvExpTrans trans)
    {
        TrvExpTrans childLine;
        AmountCur total = 0.00;
        while select childLine where childLine.ParentRecId == trans.RecId
        {
            total += TrvExpTrans::amountCurExpLineWithoutTax(childLine);
        }
        return total;
    }

]]></Source>
			</Method>
			<Method>
				<Name>submitterJustification</Name>
				<Source><![CDATA[
    /// <summary>
    /// The submit justification entered for the current record.
    /// </summary>
    /// <returns>The justification text entered while submitting.</returns>
    display TrvSubmitterJustification submitterJustification()
    {
        return TrvJustificationHelper::submitterJustification(this.RecId, TrvPolicyViolationJustificationTypeEnum::TrvExpLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSubmitJustificationRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the expense has a policy violation that requires submit justification.
    /// </summary>
    public boolean isSubmitJustificationRequired()
    {
        if (!this.RecId)
        {
            return false;
        }

        return TrvJustificationHelper::isJustificationRequired(this.RecId, TrvPolicyViolationJustificationTypeEnum::TrvExpLine, TrvPolicyViolationLevel::SubmitJustification);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isApproveJustificationRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the expense has a policy violation that requires approve justification.
    /// </summary>
    public boolean isApproveJustificationRequired()
    {
        if (!this.RecId)
        {
            return false;
        }

        return TrvJustificationHelper::isJustificationRequired(this.RecId, TrvPolicyViolationJustificationTypeEnum::TrvExpLine, TrvPolicyViolationLevel::ApproveJustification);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReturnCash</Name>
				<Source><![CDATA[
    /// <summary>
    /// If ExpType is 'Advance', validate the cash advance tied to the expense.
    /// </summary>
    /// <returns>True if cash advance is valid or if the expense is not of 'Advance' type.</returns>
    public boolean validateReturnCash()
    {
        if (this.ExpType == TrvExpType::Advance)
        {
            if (!TrvReturnCashHelper::isCashAdvanceValidForReturn(TrvCashAdvance::findRecId(this.CashAdvanceRecId).CashAdvanceNumber, this.CreatingWorker))
            {
                return checkFailed("@Expense:ReturnCash_Invalid");
            }

            if (this.AmountCurr <= 0)
            {
                return checkFailed("@Expense:ReturnCash_AmountInvalid");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showExpenseTypeIcon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given the current expense's type this method will return the appropriate symbol.
    /// </summary>
    /// <returns>Container with the image for this expense record.</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display container showExpenseTypeIcon()
    {
        ImageReference imgRef;
        container imgContainer;

        imgRef = ImageReference::constructForSymbol(TrvExpenseHelper::getExpenseTypeIconName(this.ExpType));
        imgContainer = imgRef.pack();

        return imgContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>legalEntityName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the legal entity name selected by the user.
    /// </summary>
    /// <returns>
    /// The data area id selected, if nothing is selected, return the current company.
    /// </returns>
    public LegalEntityDataAreaId legalEntityName()
    {
        if (this.InterCompanyLE != '' && CompanyInfoExtension::existsDataArea(this.InterCompanyLE))
        {
            return this.InterCompanyLE;
        }
        else if(this.ReferenceDataAreaId != '' && CompanyInfoExtension::existsDataArea(this.ReferenceDataAreaId))
        {
            return this.ReferenceDataAreaId;
        }

        return curExt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultProjectFromExpenseReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the project fields from expense report.
    /// </summary>
    /// <param name = "_skipDimensionDefaulting">true, if the dimension defaulting has to be skipped; otherwise, false.</param>
    public void setDefaultProjectFromExpenseReport(boolean _skipDimensionDefaulting = false)
    {
        TrvExpTable             trvExpTable = TrvExpTable::findRecId(this.TrvExpTable);
        SelectableDataArea		expenseReportIntercompanyLE = trvExpTable.intercompanyLegalEntityName();

        // Default dimension and project id from expense header when both header and line reference the same company
        // and having valid worker category validation groups.
        if (this.isMatchingWithIntercompanyLegalEntity(expenseReportIntercompanyLE) &&
            this.isCategoryIntegratedWithProject() &&
            TrvExpTrans::checkWorkerCategory(this.CreatingWorker, this.CostType, this.isIntercompany(), false, this.LegalEntity))
        {
            // If the project header has a default project id, check that there is also a default project line property
            // before copying the header project properties over to the line.
            //
            // This check will also fail for expense lines that are not on an expense report, so no defaulting will occur.
            if (!this.ProjId && trvExpTable.ProjId)
            {
                ProjLinePropertyId      projLinePropertyId;

                changecompany (expenseReportIntercompanyLE)
                {
                    projLinePropertyId = ProjLinePropertySetup::findLinePropertyId(trvExpTable.ProjId, this.CostType);
                }

                if (projLinePropertyId && !ProjTable::checkRequireActivity(trvExpTable.ProjId, tableNum(TrvExpTrans)))
                {
                    this.ProjId = trvExpTable.ProjId;
                    this.ProjStatusId = projLinePropertyId;
                }

                this.setTaxGroup();
            }
        }
        else if (this.orig().ProjId)
        {
            this.ProjId = '';
            this.modifiedField(fieldNum(TrvExpTrans,ProjId));
            this.ProjActivityNumber = "";
            this.ProjPolicyStatus = ProjExpPolicyStatus::NoPolicy;
            this.ProjStatusId = "";
            this.ProjPolicyText = "";
        }

        if (!_skipDimensionDefaulting)
        {
            this.setDefaultDimension();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashAdvanceNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Edit method for cash advance number.
    /// Defaults expense fields from the selected cash advance.
    /// </summary>
    /// <param name = "_set">True, if the field is being set; False, if being read.</param>
    /// <param name = "_trvCashAdvanceNumber">Cash advance number that's entered.</param>
    /// <returns>Cash advance number.</returns>
    edit TrvCashAdvanceNumber cashAdvanceNumber(boolean _set, TrvCashAdvanceNumber _trvCashAdvanceNumber)
    {
        TrvCashAdvanceNumber cashAdvanceNumber = _trvCashAdvanceNumber;

        if (_set)
        {
            if (TrvReturnCashHelper::isCashAdvanceValidForReturn(cashAdvanceNumber, this.CreatingWorker))
            {
                // Default the fields on expense based on the selected cash advance number.
                this.initFromCashAdvance(TrvCashAdvance::find(cashAdvanceNumber));
            }
            else
            {
                this.CashAdvanceRecId = 0;
                cashAdvanceNumber = '';
                warning("@Expense:ReturnCash_Invalid");
            }
        }
        else
        {
            // Read cash advance number for the current expense.
            if (this.CashAdvanceRecId)
            {
                cashAdvanceNumber = TrvCashAdvance::findRecId(this.CashAdvanceRecId).CashAdvanceNumber;
            }
        }

        return cashAdvanceNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCashAdvance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize expense fields given a cash advance number.
    /// </summary>
    /// <param name = "_trvCashAdvance">Cash advance that will be tied to the expense.</param>
    public void initFromCashAdvance(TrvCashAdvance _trvCashAdvance)
    {
        TrvExpTrans     trvExpTrans;

        if (_trvCashAdvance.RecId)
        {
            this.CashAdvanceRecId = _trvCashAdvance.RecId;
            this.TaxIncluded = NoYes::No;
            this.TaxGroup = '';
            this.TaxItemGroup = '';
            this.TransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

            select sum(AmountCurr) from trvExpTrans
                where trvExpTrans.CashAdvanceRecId == _trvCashAdvance.RecId
                    && trvExpTrans.ApprovalStatus != TrvAppStatus::Ledger;
            
            this.ExchangeCode = _trvCashAdvance.CurrencyCode;
            this.ExchangeRate = _trvCashAdvance.ExchRate;

            if (TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled())
            {
                this.AmountMST = _trvCashAdvance.amountMSTAvailableToAllocate() - trvExpTrans.AmountMST;
                this.AmountCurr = CurrencyExchangeHelper::curAmount(this.AmountMST, this.ExchangeCode, 
                                                                this.TransDate, UnknownNoYes::Unknown,
                                                                this.ExchangeRate);

            }
            else
            {
                this.AmountCurr = _trvCashAdvance.Balance - trvExpTrans.AmountCurr;
                this.amountMST();
            }

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemizationComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check the status of itemization and if it needs to be completed before submit.
    /// </summary>
    /// <returns>true if the itemization status is completed or not applicable</returns>
    public boolean isItemizationComplete()
    {
        TrvExpItemizationStatus status = this.itemizationStatus();

        return (status == TrvExpItemizationStatus::Completed
            || status == TrvExpItemizationStatus::NotApplicable
            || (this.LineType == TrvExpLineType::Default && status == TrvExpItemizationStatus::NoItemizedLines));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditCardPersonalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether it's a personal expense under a credit card transaction.
    /// </summary>
    /// <returns>True if the current expense line is personal credit card transaction, otherwise false.</returns>
    private boolean isCreditCardPersonalTrans()
    {
        return (this.ExpType == TrvExpType::Personal
            && this.ParentRecId != 0
            && TrvExpTrans::find(this.ParentRecId).isCreditCardTransaction());
    }

]]></Source>
			</Method>
			<Method>
				<Name>projectBudgetViolationLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the project budget violation level for current expense line.
    /// </summary>
    /// <returns>The project budget violation level of the current expense line.</returns>
    public ProjBudgetControlErrorWarning projectBudgetViolationLevel()
    {
        ProjBudgetStatus projBudgetStatus;
        ProjBudgetStatusDetail projBudgetStatusDetail;

        projBudgetStatus = ProjBudgetStatus::findBySourceDocumentLine(this.SourceDocumentLine);
        if (projBudgetStatus.RecId)
        {
            select firstonly projBudgetStatusDetail
                where projBudgetStatusDetail.ProjBudgetStatus == projBudgetStatus.RecId;

            if (projBudgetStatusDetail.RecId)
            {
                return projBudgetStatusDetail.ProjBudgetControlErrorWarning;
            }
        }

        return ProjBudgetControlErrorWarning::NoError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>budgetViolationLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the budget violation level for current expense line.
    /// </summary>
    /// <returns>The budget violation level of the current expense line.</returns>
    public BudgetCheckResult budgetViolationLevel()
    {
        BudgetSource budgetSource;

        select firstonly RecId, CheckResult from budgetSource
            where budgetSource.SourceDocumentLine == this.SourceDocumentLine
                && budgetSource.BudgetSourceType == BudgetSourceType::SourceDocumentLine;

        if (budgetSource.RecId)
        {
            return budgetSource.CheckResult;
        }

        return BudgetCheckResult::NoCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayProjectBudgetViolationMsg</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the project budget violation messages.
    /// </summary>
    public void displayProjectBudgetViolationMsg()
    {
        ListEnumerator          listEnumerator = this.projectBudgetViolationMsg().getEnumerator();
        ProjBudgetStatusDetail  projBudgetStatusDetail;

        while (listEnumerator.moveNext())
        {
            projBudgetStatusDetail = listEnumerator.current();

            if (ProjBudgetStatus::find(projBudgetStatusDetail.ProjBudgetStatus).BudgetCheckResult == ProjBudgetCheckResult::Failed)
            {
                error(projBudgetStatusDetail.Message);
            }
            else
            {
                warning(projBudgetStatusDetail.Message);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>projectBudgetViolationMsg</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all the records of <c>ProjBudgetStatusDetail</c> containing errors or warnings.
    /// </summary>
    /// <returns>The list of all the records of <c>ProjBudgetStatusDetail</c> containing errors or warnings.</returns>
    public List projectBudgetViolationMsg()
    {
        List                    projBudgetStatusDetailList = new List(Types::Record);
        ProjBudgetStatus        projBudgetStatus;
        ProjBudgetStatusDetail  projBudgetStatusDetail;

        while select projBudgetStatusDetail
            join projBudgetStatus
                where projBudgetStatus.RecId == projBudgetStatusDetail.ProjBudgetStatus
                    && projBudgetStatus.SourceDocumentLine == this.SourceDocumentLine
                    && (projBudgetStatus.BudgetCheckResult == ProjBudgetCheckResult::Failed
                        || projBudgetStatus.BudgetCheckResult == ProjBudgetCheckResult::PassedWithWarnings)
        {
            if (projBudgetStatusDetail.Message != '')
            {
                projBudgetStatusDetailList.addEnd(projBudgetStatusDetail);
            }
        }

        return projBudgetStatusDetailList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyPerDiemRules</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verify the per diem rules are setup for the date ranges and location.
    /// </summary>
    public boolean verifyPerDiemRules()
    {
        TrvPerDiems         trvPerDiem;

        trvPerDiem = this.getPerdiemRateSetup();
        if (!trvPerDiem.RecId)
        {
            return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPerdiemRateSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the per diem rules setup for the date ranges and location.
    /// </summary>
    /// <returns>A record of type <c>TrvPerDiems</c> setup.</returns>
    public TrvPerDiems getPerdiemRateSetup()
    {
        TrvPerDiems         trvPerDiem, emptyTrvPerDiem;

        select trvPerDiem where
            trvPerDiem.TrvLocations == this.TrvLocations &&
            (trvPerDiem.DateFrom <= DateTimeUtil::date(this.dateFrom) || !trvPerDiem.DateFrom) &&
            (trvPerDiem.DateTo >= DateTimeUtil::date(this.dateTo) || !trvPerDiem.DateTo);

        if (!trvPerDiem.RecId)
        {
            warning("@SYS116199"); // Cannot calculate per diem for this transaction. A per diem rule must span the length of the entire trip to apply.

            // If a perdiem rate does not exist we try to find the rule that covers the trip dates.
            select RecId from trvPerDiem where
                trvPerDiem.TrvLocations == this.TrvLocations &&
                (trvPerDiem.DateFrom <= DateTimeUtil::date(this.dateFrom) || !trvPerDiem.DateFrom) &&
                (trvPerDiem.DateTo >= DateTimeUtil::date(this.dateFrom));

            if (trvPerDiem.RecId)
            {
                // There is a per diem rule covering this transaction up to %1. Please create a separate transaction for the part of your trip after this date.
                warning(strFmt("@SYS117995", date2StrUsr(trvPerDiem.DateTo, DateFlags::FormatAll)));
            }
            return emptyTrvPerDiem;
        }
        return trvPerDiem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineItemWorkflowEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether line item workflow should be shown based off the following conditions:
    /// There is line level workflow configured for expense
    /// and there exist a workflow item in the workflow status table with a valid status
    /// or the line item approval is configured for the current table record
    /// or the expense line approval status is different from the expense report status.
    /// </summary>
    /// <returns>True if line item workflow should be enabled, otherwise false.</returns>
    public boolean lineItemWorkflowEnabled()
    {
        WorkflowTrackingStatusTable workflowStatusTable = Workflow::findTrackingStatusForCurrentUser(this);

        // Check if line item workflow exists even before querying the others for performance purposes.
        return (TrvWorkflowUtilities::workflowTypeHasLineItem(this.TrvExpTable)
                && ((workflowStatusTable.RecId && (workflowStatusTable.TrackingStatus == WorkflowTrackingStatus::Pending || workflowStatusTable.TrackingStatus == WorkflowTrackingStatus::Completed))
                     || TrvWorkflowUtilities::isLineItemApprovalForExpenseReport(this.TrvExpTable)
                     || TrvExpTable::findRecId(this.TrvExpTable).anyLinesHaveDifferentApprovalStatus()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReceiptRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the receipt is required by either project or policies.
    /// </summary>
    /// <returns>True if a receipt is required for the expense line, otherwise false.</returns>
    public display boolean isReceiptRequired()
    {
        return this.ReceiptRequired || this.receiptRequiredByPolicies();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRemainingAmountLineApplicable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a remaining amount line should be created for a personal amount line.
    /// </summary>
    /// <returns>True if a remaining amount line must be created, otherwise false.</returns>
    public boolean isRemainingAmountLineApplicable()
    {
        // If itemization is mandatory or the expense line is already itemized do not create a remaining amount line.
        return !TrvCostType::find(this.CostType).IsItemizationMandatory && this.LineType != TrvExpLineType::ItemizedHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRemainingAmountLineForPersonalExisting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a remaining amount line exists for a personal expense amount.
    /// </summary>
    /// <returns>True if a remaining amount line exists, false otherwise.</returns>
    /// <remarks>
    /// Should be called from the context of the itemized header expense line.
    /// </remarks>
    public boolean isRemainingAmountLineForPersonalExisting()
    {
        TrvExpTrans remainingAmountLine;

        select RecId from remainingAmountLine where remainingAmountLine.ParentRecId == this.RecId &&
            remainingAmountLine.CostType == this.CostType && remainingAmountLine.IsSplit == NoYes::Yes &&
            remainingAmountLine.LineType == TrvExpLineType::ItemizedLine;

        return (remainingAmountLine.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRemainingWithGivenCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the amount for the remaining amount line when the personal amount is updated.
    /// </summary>
    /// <remarks>
    /// Should be called from the context of the itemized header expense line.
    /// </remarks>
    public void updateRemainingWithGivenCategory()
    {
        TrvExpTrans     remainingAmountExpenseLine,itemizedLine;
        AmountCur       remainingAmount;

        if (this.ExpType != TrvExpType::Personal)
        {
            select firstonly forupdate remainingAmountExpenseLine where remainingAmountExpenseLine.ParentRecId == this.RecId &&
                    remainingAmountExpenseLine.CostType == this.CostType && remainingAmountExpenseLine.IsSplit == NoYes::Yes;

            // If a remaining expense line exist, update the amount.
            if (remainingAmountExpenseLine)
            {
                remainingAmount = this.remainingAmount();

                // Update amount only if remaining amount is something other than zero.
                if (remainingAmount != 0.0)
                {
                    ttsbegin;

                    remainingAmountExpenseLine.initFromTrvExpItemizedHeader(this);

                    remainingAmountExpenseLine.AmountCurr += remainingAmount;
                    remainingAmountExpenseLine.TransDate = this.TransDate;

                    // If the credit card amount exists on the itemized header line, update the credit card amount on the remaining amount line.
                    if (this.CreditCardTransactionCurrencyAmount != 0)
                    {
                        select sum(CreditCardTransactionCurrencyAmount) from itemizedLine
                        where itemizedLine.ParentRecId == this.RecId;
                        remainingAmountExpenseLine.CreditCardTransactionCurrencyAmount += this.CreditCardTransactionCurrencyAmount - itemizedLine.CreditCardTransactionCurrencyAmount;
                    }

                    remainingAmountExpenseLine.update();
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRemainingWithGivenCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the remaining amount line when the personal amount line is deleted.
    /// </summary>
    /// <remarks>
    /// Should be called from the context of the itemized header expense line.
    /// </remarks>
    public void deleteRemainingWithGivenCategory()
    {
        TrvExpTrans     remainingAmountExpenseLine, header;

        ttsbegin;
        delete_from remainingAmountExpenseLine where remainingAmountExpenseLine.ParentRecId == this.RecId
            && remainingAmountExpenseLine.CostType == this.CostType
            && remainingAmountExpenseLine.IsSplit == NoYes::Yes;
        
        select firstonly forupdate LineType, IsSplit from header where header.RecId == this.RecId
            && (header.LineType == TrvExpLineType::ItemizedHeader || header.IsSplit == NoYes::Yes);
        
        if (header.RecId)
        {
            header.LineType = TrvExpLineType::Default;
            header.IsSplit = NoYes::No;
            header.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPersonalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the amount and credit card amount for the expense line.
    /// </summary>
    /// <remarks>
    /// This method is used to clear the value of personal amount from code to help delete of personal expenses,
    /// to be called only from the context for a personal expense line.
    /// </remarks>
    public void clearPersonalAmount()
    {
        this.CreditCardTransactionCurrencyAmount = 0.0;
        this.AmountCurr = 0.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executePolicyEvaluation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the policy evaluation for line and header.
    /// </summary>
    private void executePolicyEvaluation()
    {
        if (this.SplitLineType != TrvExpSplitLineType::SplitHeader)
        {
            TrvPolicyEvalEngine::evaluateViolationsForLine(this.RecId, SysPolicyTypeEnum::TrvExpensePolicy);
        }

        if (this.TrvExpTable)
        {
            TrvPolicyEvalEngine::evaluateViolationsForHdr(this.TrvExpTable, SysPolicyTypeEnum::TrvExpensePolicy);
            if (this.LineType != TrvExpLineType::ItemizedLine && this.SplitLineType != TrvExpSplitLineType::SplitHeader)
            {
                TrvExpTable::findRecId(this.TrvExpTable).validateProjPolicies(false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateCaption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate a caption for the expense line.
    /// </summary>
    /// <returns>A textual representation of the expense line.</returns>
    public str generateCaption()
    {
        return strFmt("@SYS191501", this.categoryOrSubCategoryName(), this.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostOwner</Name>
				<Source><![CDATA[
    private void updateCostOwner()
    {
        TrvPayMethod trvPayMethod = TrvPayMethod::find(this.PayMethod);

        if (trvPayMethod)
        {
            this.CostOwner = trvPayMethod.CostOwner;
        }
        else
        {
            this.CostOwner = TrvCostOwner::Company;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExpenseReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the expense report number on an expense line
    /// </summary>
    /// <param name="_expenseNumber">
    /// The expense report number of the new expense report
    /// </param>
    /// <param name="_validateAccess">
    /// Indicates if we check if the user has access to edit the document.
    /// </param>
    /// <returns>True if record was updated; otherwise, false</returns>
    public boolean updateExpenseReport(TrvExpNumber _expenseNumber = this.ExpNumber, boolean _validateAccess = true)
    {
        boolean userIsDelegate = TrvAccessHelper::userHasCurrentDelegateAccessFor(this.CreatingWorker);
        // Cannot update expense lines that are not in the Draft status
        if ((!this.isEditable(_validateAccess, false) && !userIsDelegate) || this.ApprovalStatus != TrvAppStatus::Create)
        {
            warning(strFmt("@Expense:UnableToTransferExpenseLineDueToLineStatus",
                    this.CostType, this.TransDate, this.AmountMST, this.ApprovalStatus));
            return false;
        }

        RecId originalExpTableRecId = this.TrvExpTable;
        TrvExpNumber originalExpNumber = this.ExpNumber;
        
        ttsbegin;
        this.ExpNumber   = _expenseNumber;

        TrvExpTable localExpTable;
        select firstonly RecId, ProjId from localExpTable
            where localExpTable.ExpNumber == this.ExpNumber
                && localExpTable.LegalEntity == CompanyInfo::current();

        this.TrvExpTable = localExpTable.RecId;

        if (this.ExpNumber == "")
        {
            // Since we are deleting split lines, this is not a split header anymore.
            this.SplitLineType = TrvExpSplitLineType::NoSplit;

            this.LineNumber = 0;

            TrvPolicyViolationsCache trvPolicyViolationsCache;
            update_recordset trvPolicyViolationsCache
                setting Header = 0
                where trvPolicyViolationsCache.Line == this.RecId
                    && trvPolicyViolationsCache.PolicyType == SysPolicyTypeEnum::TrvExpensePolicy
                    && trvPolicyViolationsCache.Header != 0;
        }
        else
        {
            this.LineNumber = this.calculateNextLineNumber();
        }

        boolean isTrvStopDefaultingLEAndProjectOnExpenseAttachFlightEnabled = TrvExpenseHelper::isTrvStopDefaultingLEAndProjectOnExpenseAttachFlightEnabled();

        if (localExpTable.InterCompanyLE != curExt() && !(isTrvStopDefaultingLEAndProjectOnExpenseAttachFlightEnabled && this.InterCompanyLE))
        {
            this.InterCompanyLE = localExpTable.intercompanyLegalEntityName();
            this.initializeInterCompanyCategory();
        }

        // Default in project information from expense report 
        // Skip dimension defaulting from Project, 
        //  if 
        //      there is no project in expense header and there is default dimension set at expense line.
        //  else if - 
        //      there is no default dimension set at expense line, and there is no project, default from expense header.
        if ((!this.isIntercompany() || this.InterCompanyCategory) && !(isTrvStopDefaultingLEAndProjectOnExpenseAttachFlightEnabled && this.ProjId))
        {
            boolean skipDimensionDefaulting = this.DefaultDimension && !localExpTable.ProjId ? true : false;
            this.setDefaultProjectFromExpenseReport(skipDimensionDefaulting);
        }

        // Handle receipts
        TrvReceiptsHelper::moveReceiptsForExpense(originalExpTableRecId, localExpTable.RecId, this.RecId);

        // Reset the distributions
        this.reinitializeSourceDocumentLine();

        // Detach cash advance and receipts attached to expense lines before moving it to unattached expenses.
        if (this.ExpNumber == '' && this.LineType != TrvExpLineType::ItemizedLine && this.SplitLineType != TrvExpSplitLineType::SplitLine)
        {
            DocuRef docuRef;
            
            while select docuRef where docuRef.RefTableId == tablenum(TrvExpTrans)
                    && docuRef.RefRecId == this.RecId
            {
                TrvReceiptsHelper::handleReceiptOnExpenseRemove(originalExpNumber, docuRef);
            }

            if (this.CashAdvanceRecId)
            {
                this.CashAdvanceRecId = 0;
            }
        }

        // Remove travel requisition mapped to expense lines before moving it to unattached expenses.
        if (this.ExpNumber == '' && this.MappedToRequisitionLine != 0)
        {
            this.IsPreAuthorized = NoYes::No;
            this.MappedToRequisitionLine = 0;
            this.AccountingCurrencyReconciledAmount = 0;
        }

        // Don't evaluate policies
        this.update(false);

        // Re-creates taxes and distributions
        TrvExpTrans::handleSourceDocumentAndPolicies(this.RecId, false);

        // Update any itemization, split and personal lines
        trvExpTrans childRecord;
        LineNumber tempLineNumber = this.LineNumber;

        if (this.ExpNumber == "")
        {
            // If we are moving this expense line to unattached expenses, we need to delete the associated split lines if any.
            TrvExpTrans splitTrvExpTrans;
            splitTrvExpTrans.skipDataMethods(true);
            delete_from splitTrvExpTrans where splitTrvExpTrans.ParentRecId == this.RecId;
        }
        else if (this.SplitLineType != TrvExpSplitLineType::SplitLine)
        {
            this.updateExpAndLineNumForChildLines(this.ExpNumber, tempLineNumber, localExpTable.RecId, this.RecId, 0);
        }
        else
        {
            // Update the split header
            TrvExpTrans splitHeader;
            select forupdate splitHeader
                where splitHeader.RecId == this.ParentRecId;

            splitHeader.ExpNumber = this.ExpNumber;
            splitHeader.TrvExpTable = localExpTable.RecId;

            splitHeader.LineNumber = this.calculateNextLineNumber();

            // Default in project information from expense report if not already set on expense
            if (!splitHeader.isIntercompany() || splitHeader.InterCompanyCategory)
            {
                splitHeader.setDefaultProjectFromExpenseReport();
            }

            splitHeader.reinitializeSourceDocumentLine();
            splitHeader.update(false);

            // Re-creates taxes and distributions
            TrvExpTrans::handleSourceDocumentAndPolicies(splitHeader.RecId, false);

            TrvPBSMaindata trvPBSMaindata = TrvPBSMaindata::findRecId(this.PBSRecId, true);
            if (trvPBSMaindata.RecId != 0)
            {
                trvPBSMaindata.updateTravelNo(this.ExpNumber);
            }

            // Update split lines
            childRecord.clear();
            tempLineNumber = splitHeader.LineNumber;

            this.updateExpAndLineNumForChildLines(this.ExpNumber, tempLineNumber, localExpTable.RecId, splitHeader.RecId, this.RecId);
            info("@Expense:SplitLineExpNumberUpdateMessage");
        }

        // check for valid costtype while changing the expense report if flight is enabled.

        if(FeatureStateProvider::IsFeatureEnabled(TrvValidateCostTypeOnExpRptChangeFlight::instance()) && !this.validateCostType(this.CostType))
        {
            throw error("@Expense:UpdateReportFailedByCostTypeValidation");
        }

        ttscommit;

        // update credit card transaction if needed
        TrvPBSMaindata trvPBSMaindata = TrvPBSMaindata::findRecId(this.PBSRecId, true);
        if (trvPBSMaindata.RecId != 0)
        {
            trvPBSMaindata.updateTravelNo(this.ExpNumber);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reinitializeSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the old accounting distributions
    /// </summary>
    public void reinitializeSourceDocumentLine()
    {
        ttsbegin;
        TaxUncommitted::deleteForDocumentLine(tableNum(TrvExpTrans), this.RecId);
        AccountingDistributionProcessor::deleteAllDistributionsForSourceDocLine(this.SourceDocumentLine);
        AccountingDistributionProcessor::deleteSourceDocumentLine(this.SourceDocumentLine);

        this.SourceDocumentLine = 0;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExpAndLineNumForChildLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the expense number and line number details for all the child lines.
    /// </summary>
    /// <param name = "_expNumber">Expense number</param>
    /// <param name = "_lineNumber">Line number</param>
    /// <param name = "_expHeaderRecId">Expense header recid</param>
    /// <param name = "_parentRecId">Parent expense line recid</param>
    /// <param name = "_recIdForExclusion">Expense line recid which needs to be excluded</param>
    /// <Remarks>
    /// This processes only itemized lines.
    /// </Remarks>
    public void updateExpAndLineNumForChildLines(TrvExpNumber _expNumber, TrvLineNumber _lineNumber, RefRecId _expHeaderRecId, RefRecId _parentRecId, RefRecId _recIdForExclusion)
    {
        TrvExpTrans childRecord;
        TrvLineNumber newLineNumber = _lineNumber;

        boolean isTrvStopDefaultingLEAndProjectOnExpenseAttachFlightEnabled = TrvExpenseHelper::isTrvStopDefaultingLEAndProjectOnExpenseAttachFlightEnabled();

        while select forupdate * from childRecord
        where childRecord.ParentRecId == _parentRecId
            && childRecord.LineType == TrvExpLineType::ItemizedLine
            && childRecord.RecId != _recIdForExclusion
        {
            childRecord.ExpNumber = _expNumber;
            childRecord.TrvExpTable = _expHeaderRecId;

            newlineNumber = newlineNumber + 0.000001;
            childRecord.LineNumber = newlineNumber;

            // Default in project information from expense report if not already set on expense
            if ((!childRecord.isIntercompany() || childRecord.InterCompanyCategory) && !(isTrvStopDefaultingLEAndProjectOnExpenseAttachFlightEnabled && childRecord.ProjId))
            {
                childRecord.setDefaultProjectFromExpenseReport();
            }

            // reset the distributions
            childRecord.reinitializeSourceDocumentLine();

            childRecord.update(false);

            // Re-creates taxes and distributions
            TrvExpTrans::handleSourceDocumentAndPolicies(childRecord.RecId, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCreatingWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the creating worker on an expense line and all children lines
    /// </summary>
    /// <param name="_trvExpTransRecId">
    /// The <c>RecId</c> for the expense line to update
    /// </param>
    /// <param name="_workerRecId">
    /// The <c>RecId</c> for the new creating worker
    /// </param>
    public static void updateCreatingWorker(RecId _trvExpTransRecId, HcmWorkerRecId _workerRecId)
    {
        ttsbegin;

        TrvExpTrans trvExpTrans;

        update_recordset trvExpTrans
            setting CreatingWorker = _workerRecId
                where trvExpTrans.ParentRecId == _trvExpTransRecId // all child lines -> itemized, personal, split
                || trvExpTrans.RecId == _trvExpTransRecId; // parent line

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePaymentMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the payment method on an expense line and all children lines
    /// </summary>
    /// <param name="_trvExpTransRecId">
    /// The <c>RecId</c> for the expense line to update
    /// </param>
    /// <param name="_paymentMethod">
    /// The new payment method
    /// </param>
    public static void updatePaymentMethod(RecId _trvExpTransRecId, TrvPayMethodEDT _paymentMethod)
    {
        ttsbegin;
            
        TrvPayMethod paymentMethod = TrvPayMethod::find(_paymentMethod);

        TrvExpTrans trvExpTrans;

        update_recordset trvExpTrans
            setting PayMethod = _paymentMethod, CostOwner = paymentMethod.CostOwner
                where trvExpTrans.ParentRecId == _trvExpTransRecId // all child lines -> itemized, personal, or split
                || trvExpTrans.RecId == _trvExpTransRecId; // parent line

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemizedHeaderIntercompanyBilling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Intercompany billing of an itemized header expense line.
    /// </summary>
    /// <param name="_billed">
    /// A boolean that decides to set or reset the itemized header.
    /// </param>
    /// <param name="_parentRecId">
    /// The Itemized header record to which we need to update the intercompany billing.
    /// </param>
    /// <remarks>
    /// Update should be done when all the itemized lines are billed or
    /// when any one of the itemized line is stopped from billing.
    /// </remarks>
    public static void updateItemizedHeaderIntercompanyBilling(boolean _billed, RefRecId _parentRecId)
    {
        TrvExpTrans itemizedHeaderExpTrans, itemizedLineExpTrans;
        boolean     updateItemizedHeader;

        select firstOnly RecId from itemizedLineExpTrans
            where itemizedLineExpTrans.IntercompanyBilled == 0
            &&    itemizedLineExpTrans.ParentRecId == _parentRecId
            &&    itemizedLineExpTrans.LineType == TrvExpLineType::ItemizedLine;

        updateItemizedHeader = (_billed && (itemizedLineExpTrans.Recid == 0)) || (!_billed && (itemizedLineExpTrans.Recid != 0)) ? true : false;

        if (updateItemizedHeader)
        {
            update_recordSet itemizedHeaderExpTrans
                setting intercompanyBilled = _billed
                    where itemizedHeaderExpTrans.RecId == _parentRecId
                    &&    itemizedHeaderExpTrans.LineType == TrvExpLineType::ItemizedHeader
                    &&    itemizedHeaderExpTrans.IntercompanyBilled != _billed;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the cost type of the record.
    /// </summary>
    /// <param name = "_costType">CostType to change to.</param>
    /// <returns>True if the update was sucessful, otherwise false.</returns>
    public boolean updateCostType(TrvCostType _costType)
    {
        TrvExpType previousExpType = this.ExpType;
        this.CostType = _costType.CostType;

        if (!this.validateField(fieldNum(TrvExpTrans, CostType)))
        {
            return false;
        }

        ttsbegin;

        this.modifiedField(fieldNum(TrvExpTrans, CostType));

        if (!this.validateWrite())
        {
            ttsabort;
            return false;
        }

        this.changeCategoryPreModified(_costType);
        this.update();
        this.changeCategoryPostModified(previousExpType, _costType.ExpType);

        ttscommit;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeCategoryPreModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up old records for the previous category
    /// </summary>
    /// <param name = "_newCategory">The new category the expense was changed to.</param>
    public void changeCategoryPreModified(TrvCostType _newCategory)
    {
        if (this.handleCleanupOfItemizedLines())
        {
            this.itemizedLinesDeleted(_newCategory);
        }

        // if the new cost type requires itemization, clear the SDL and related
        if (_newCategory.IsItemizationMandatory && this.SourceDocumentLine)
        {
            this.clearSDLForItemizedAndSplitHeader();
            this.reinitializeSourceDocumentLine();
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCleanupOfItemizedLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete itemized lines when the category changes.
    /// </summary>
    /// <returns>True, if any itemized lines are deleted, false otherwise.</returns>
    private boolean handleCleanupOfItemizedLines()
    {
        TrvExpTrans     itemizedExpenseLine;
        boolean         itemizedLinesDeleted = false;

        if(this.RecId != 0)
        {

            select firstonly RecId from itemizedExpenseLine where itemizedExpenseLine.ParentRecId == this.RecId && (itemizedExpenseLine.ApprovalStatus == TrvAppStatus::Create || itemizedExpenseLine.ApprovalStatus == TrvAppStatus::Returned);

            // Given that two expense categories of the same type may have different subcategories, delete the old itemizations.
            if (itemizedExpenseLine.RecId)
            {

                str logMessage = strFmt("Deleting Itemized Expense Lines with ParentRecId %1", this.RecId);
                TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage, tableMethodStr(TrvExpTrans, handleCleanupOfItemizedLines));

                itemizedExpenseLine.clear();

                // Delete any itemized line record.
                ttsbegin;
                delete_from itemizedExpenseLine where itemizedExpenseLine.ParentRecId == this.RecId && itemizedExpenseLine.ParentRecId != 0 && (itemizedExpenseLine.ApprovalStatus == TrvAppStatus::Create || itemizedExpenseLine.ApprovalStatus == TrvAppStatus::Returned);
                ttscommit;

                itemizedLinesDeleted = true;
            }
        }

        return itemizedLinesDeleted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeCategoryPostModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up old records for the previous category
    /// </summary>
    /// <param name = "previousExpenseType">The previous expense type.</param>
    /// <param name = "newExpenseType">The new expense type.</param>
    public void changeCategoryPostModified(TrvExpType previousExpenseType, TrvExpType newExpenseType)
    {
        this.handleCleanupPolicyJustificationsAndViolations();

        if (previousExpenseType != newExpenseType)
        {
            // Ensure we don't have guests for expense type that doesn't support it.
            if (this.handleCleanupOfGuests(previousExpenseType))
            {
                this.guestsDeleted();
            }

            // Ensure we don't have enhanced data for expense type that doesn't support it.
            this.handleCleanupOfEnhancedData(previousExpenseType);

            // Ensure we don't have have perdiem data lines when category is changed to not be perdiem.
            this.handleCleanupOfPerdiemDataLines(previousExpenseType);

            this.handleCleanupOfMappedToRequisitionLine();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCleanupOfMappedToRequisitionLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the mapping to a requisition line when expense type has changed.
    /// </summary>
    private void handleCleanupOfMappedToRequisitionLine()
    {
        this.MappedToRequisitionLine = 0;

        // Update AccountingCurrencyReconciledAmount
        this.mapToRequisitionLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCleanupOfGuests</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleanup of guest/gifts data when expense type has changed.
    /// </summary>
    /// <returns>True, if any guest information is updated, false otherwise.</returns>
    private boolean handleCleanupOfGuests(TrvExpType previousExpenseType)
    {
        boolean expenseLineHasGuest, expenseTypeAllowsGuest, guestRefreshNeeded;

        expenseLineHasGuest     = this.hasGuests();
        expenseTypeAllowsGuest  = this.isGuestType();

        // If guests exist for a gift expense type and new category allows guest, reset the amount field.
        if (expenseLineHasGuest && previousExpenseType == TrvExpType::Gift && expenseTypeAllowsGuest && this.ExpType != TrvExpType::Gift)
        {
            TrvGuestHelper::resetGuestAmountsforExpenseLine(this.RecId);
            guestRefreshNeeded = true;
        }
        // If guests exist and the new category does not allow guest, call delete for guests.
        else if (expenseLineHasGuest &&  !expenseTypeAllowsGuest)
        {
            TrvGuestHelper::deleteGuestsforExpenseLine(this.RecId);
            guestRefreshNeeded = true;
        }

        return guestRefreshNeeded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCleanupOfEnhancedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleanup of enhanced data record when expense type has changed, and also make sure the form is in correct state in terms of datasources.
    /// </summary>
    /// <param name="previousExpenseType">The expense type to use to determine if expense type has changed.</param>
    private void handleCleanupOfEnhancedData(TrvExpType previousExpenseType)
    {
        // If the previous expense type had enhanced data and the expense type has changed, delete the enhanced data record.
        if (TrvExpenseType::supportsEnhancedData(previousExpenseType) &&  previousExpenseType != this.ExpType)
        {
            TrvEnhancedData enhancedData;
            select firstonly forupdate enhancedData where enhancedData.TransactionRecord == this.RecId;

            if (enhancedData)
            {
                ttsbegin;
                enhancedData.delete();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCleanupOfPerdiemDataLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete perdiem data lines when the category changes.
    /// </summary>
    private void handleCleanupOfPerdiemDataLines(TrvExpType previousExpenseType)
    {
        if (previousExpenseType == TrvExpType::Allowance
            && TrvExpPerdiemData::isMealBreakdownPerDay()
            && previousExpenseType != this.ExpType)
        {
            TrvExpPerdiemData trvExpPerdiemData;

            // Delete any record in perdiem data for the expense line.
            delete_from trvExpPerdiemData
                    where trvExpPerdiemData.TrvExpTrans == this.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCleanupPolicyJustificationsAndViolations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleanup the policy violations and justifications.
    /// </summary>
    private void handleCleanupPolicyJustificationsAndViolations()
    {
        TrvPolicyViolationJustification     trvPolicyViolationJustification;
        TrvPolicyViolationsCache            trvPolicyViolationsCache;
        TrvPolicyViolationsLog              trvPolicyViolationsLog;

        // If this record hasn't been saved, there won't be any Justification violations to delete
        if (this.RecId)
        {
            // Delete the policy violation justifications
            delete_from trvPolicyViolationJustification
            where trvPolicyViolationJustification.ViolatingRecord == this.RecId
               && trvPolicyViolationJustification.ViolationJustificationType == TrvPolicyViolationJustificationTypeEnum::TrvExpLine;

            // Delete the policy violations
            if (this.TrvExpTable)
            {
                delete_from trvPolicyViolationsCache
                where (trvPolicyViolationsCache.Line == this.RecId
                    || trvPolicyViolationsCache.ParentRecId == this.RecId)
                    && trvPolicyViolationsCache.PolicyType == SysPolicyTypeEnum::TrvExpensePolicy;
            }
            else
            {
                delete_from trvPolicyViolationsCache
                where (trvPolicyViolationsCache.Line == this.RecId)
                    && trvPolicyViolationsCache.PolicyType == SysPolicyTypeEnum::TrvExpensePolicy;
            }

            delete_from trvPolicyViolationsLog
            where trvPolicyViolationsLog.Line == this.RecId
               && trvPolicyViolationsLog.PolicyType == SysPolicyTypeEnum::TrvExpensePolicy;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewExpTransNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a new value for ExpTransNumber field from the number sequence framework.
    /// </summary>
    public static TrvExpTransNumber getNewExpTransNumber()
    {
        return TrvExpenseHelper::getNewExpTransNumber();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExpensesForItemization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes sure all lines for a report are in sync with the category for itemization
    /// </summary>
    /// <param name = "_TrvExpTableRecId">The report to evaluate</param>
    /// <returns>True if no additional itemization is necessary; otherwise false</returns>
    public static boolean validateExpensesForItemization(RefRecId _trvExpTableRecId)
    {
        TrvExpTrans trvExpTrans;
        boolean     retValue = true;

        ttsbegin;

        while select forupdate trvExpTrans
            where trvExpTrans.TrvExpTable == _TrvExpTableRecId
                && TrvExpTrans.LineType == TrvExpLineType::Default
        {
            if (TrvCostType::find(trvExpTrans.CostType).IsItemizationMandatory && TrvExpenseType::supportsItemization(trvExpTrans.ExpType))
            {
                trvExpTrans.LineType = TrvExpLineType::ItemizedHeader;
                trvExpTrans.update(false);
                retValue =  false;
            }
        }

        ttscommit;

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMandatoryTravelRequisitionLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates mapping of mandatory requisition line to expense line
    /// </summary>
    /// <returns>
    /// true if mandatory requisition line is mapped to expense line, otherwise false;
    /// </returns>
    public boolean validateMandatoryTravelRequisitionLine()
    {
        if (this.IsPreAuthorized
        && this.MappedToRequisitionLine == 0)
        {
            if (this.expTable().isTravelRequisitionAssociated())
            {
                return checkFailed("@SYS191406");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPendingWorkItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>WorkflowWorkItemTable</c> table for a corresponding <c>TrvExpTrans</c> table.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of a record in a <c>TrvExpTrans</c> table.
    /// </param>
    /// <returns>
    /// A <c>WorkflowWorkItemTable</c> table for the corresponding <c>TrvExpTrans</c> table.
    /// </returns>
    public static WorkflowWorkItemTable findPendingWorkItem(RecId _recId)
    {
        WorkflowWorkItemTable workItemTable;

        select firstonly workItemTable
            where workItemTable.RefRecId == _recId
            && workItemTable.RefTableId == tablenum(TrvExpTrans)
            && workItemTable.Status == WorkflowWorkItemStatus::Pending;

        return workItemTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePaymentMethod</Name>
				<Source><![CDATA[
    private boolean validatePaymentMethod(TrvPayMethodEDT _payMethod)
    {
        boolean ret = true;

        TrvPayMethod payMethod = TrvPayMethod::find(_payMethod);
        if (!payMethod.RecId && !TrvExpTrans::getAllowancePaymentMethod(this.CostType))
        {
            return checkFailed("@Expense:InvalidPayMethod");
        }

        // if this has already been set to an import only type, do not allow it to be changed
        if (this.orig().payMethod && (this.Orig().payMethod != _payMethod))
        {
            TrvPayMethod currentPayMethod = TrvPayMethod::find(this.orig().payMethod);
            if (currentPayMethod && currentPayMethod.AutomaticPayment == NoYes::Yes)
            {
                return checkFailed("@Expense:CannotChangeImportOnlyPayMethod");
            }
            else if (currentPayMethod && payMethod.AutomaticPayment && !currentPayMethod.AutomaticPayment)
            {
                return checkFailed("@Expense:CannotChangeExistingPayMethodToImportOnly");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyVatDueDate_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the VAT due date.
    /// </summary>
    public void modifyVatDueDate_W()
    {
        if (!TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            return;
        }

        this.VatDueDate_W = dateNull();

        if (this.TaxItemGroup && this.TaxGroup)
        {
            TaxGroupHeading taxGroupHeading = TaxGroupHeading::find(this.TaxGroup);
            FillVATDueDate_W fillVATDueDate = taxGroupHeading.FillVATDueDate_W;

            if (TaxVATDueDateUtility::isVATDueDateBasedOnDocumentDate(taxGroupHeading)
                || TaxVATDueDateUtility::isVATDueDateBasedOnPostingDate(taxGroupHeading)
                || fillVATDueDate == FillVATDueDate_W::LastDeliveryDate)
            {
                this.VatDueDate_W = TaxVATDueDateUtility::calculateVATDueDateBasedOnPostingDate(taxGroupHeading, this.TransDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjectCostCommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determine if the project cost is already committed for this expense line.
    /// </summary>
    /// <returns>
    ///     True if project cost is committed. Otherwise, false.
    /// </returns>
    public boolean isProjectCostCommitted()
    {
        // If there is no project associated with the line, there won't be any project committed costs.
        boolean ret = this.ProjId ? true : false;

        if (this.LineType != TrvExpLineType::ItemizedHeader &&
            this.SplitLineType != TrvExpSplitLineType::SplitHeader &&
            this.ProjId)
        {
            CostControlTransCommittedCost committedCost;
            select firstonly RecId from committedCost
                    where committedCost.SourceDocumentLine == this.SourceDocumentLine &&
                    committedCost.ProjId == this.ProjId;

            if (committedCost.RecId == 0)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllowancePaymentMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// If the expense type is Cash Advance or Allowance, and the payment method was cleared out because it was no longer going
    /// to be valid, then we will try to reset based on standard payment method for new category. If that is not allowed
    /// because it is import only, show an error. The payment method field is hidden for these expense types, so
    /// AP clerk will have to correct the configuration issue.
    /// </summary>
    /// <param name = "_costType">
    /// Expense cost type.
    /// </param>
    /// <returns>Payent method of expense type Cash Advance or Allowance</returns>
    public static TrvPayMethodEDT getAllowancePaymentMethod(TrvCostTypeEDT _costType)
    {
        TrvPayMethodEDT payMethod;
        TrvCostType costType;

        select firstonly StdPaiMethod from costType
            where costType.CostType == _costType
            && (costType.ExpType == TrvExpType::Advance || costType.ExpType == TrvExpType::Allowance);

        if (TrvPayMethod::isAutomaticPayment(costType.StdPaiMethod))
        {
            error(strFmt("@Expense:DefaultPaymentCategoryIsImportOnly", _costType));
        }

        return costType.StdPaiMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxObligationDestination</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates if tax obligation is set to destination in the source company.
    /// </summary>
    /// <returns>
    ///     True, if tax obligation is set to destination in the source company; otherwise false.
    /// </returns>
    private boolean isTaxObligationDestination()
    {
        boolean ret;

        //In case ReferenceDataAreaId is invalid, this should return false.
        if (!CompanyInfoExtension::existsDataArea(this.ReferenceDataAreaId))
        {
            return false;
        }

        changecompany(this.ReferenceDataAreaId)
        {
            TaxParameters taxParameters;

            select TaxObligationCompany from taxParameters;

            if (taxParameters.TaxObligationCompany == TaxObligationCompany::Destination)
            {
                ret = true;
            }
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxItemGroupValidForIntercompanyLE</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Validates if the item tax group is valid for the legal entity of the expense.
    /// </summary>
    /// <param name = "_taxItemGroupId">Item tax group identifier.</param>
    /// <returns>True, if the item tax group is valid; otherwise, false.</returns>
    private boolean isTaxItemGroupValidForIntercompanyLE(TaxItemGroup _taxItemGroupId)
    {
        boolean ret = true;

        if (this.isTaxObligationDestination() && this.isIntercompany())
        {
            //In case intercompany LE is invalid, this should return false.
            ret = false;

            if (CompanyInfoExtension::existsDataArea(this.InterCompanyLE) && _taxItemGroupId)
            {
                changecompany(this.InterCompanyLE)
                {
                    ret = TaxItemGroupHeading::checkExist(_taxItemGroupId);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExpCashAdvanceMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes cash advance mapping, if Payment method does not have owner as employee.
    /// Creates or updates cash advance expense mapping, if expense has more to be allocated.
    /// </summary>
    /// <param name = "_updateMapping">
    /// If set to 'true', the existing mapping is removed and new mapping is 'created'.
    /// Otherwise, only new mapping is created.
    /// </param>
    [Hookable(false)]
    public void updateExpCashAdvanceMap(boolean _updateMapping = false)
    {
        boolean isFeatureFlagEnabled = TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled();

        if (!isFeatureFlagEnabled || !this.RecId)
        {
            return;
        }

        if (this.CostOwner != TrvCostOwner::Employee ||
                TrvPayMethod::getCostOwner(this.PayMethod) != TrvCostOwner::Employee)
        {
            str logMessage = strFmt("Removal of mapping would be triggered for Expense Line = %1, as cost owner changed to %2. Payment method is %3", 
                                     this.RecId, this.CostOwner, this.PayMethod);
            TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage, tableMethodStr(TrvExpTrans, updateExpCashAdvanceMap));
            TrvExpCashAdvanceMappingHelper::removeMappingForExpenseLine(this.RecId);
        }
        else
        {
            TrvCashAdvance trvCashAdvance;
            select firstonly CashAdvanceNumber from trvCashAdvance
                where trvCashAdvance.RecId == this.CashAdvanceRecId;

            if (_updateMapping)
            {
                // If this is an update to existing mapping, first remove the mapping and recreate new.
                TrvExpCashAdvanceMappingHelper::removeMappingForExpenseLine(this.RecId);

                // if expense type is not 'ReturnCash', we should reset CashAdvanceNumber as we would want autoMapping to execute.
                // If expense type is 'ReturnCash', we want the mapping to be specific to the specified cashAdanceNumber.
                if (this.ExpType != TrvExpType::Advance)
                {
                    trvCashAdvance.CashAdvanceNumber = '';
                }
            }
            
            TrvExpCashAdvanceMappingHelper::createNewMapping(this.RecId, trvCashAdvance.CashAdvanceNumber, this.AmountMST);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mappedExpeneseAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Amount mapped to cash advance.
    /// </summary>
    /// <returns>
    /// Amount in company currency, that is already mapped to cash advances.
    /// </returns>
    [Hookable(false)]
    public final AmountMST mappedExpeneseAmountMST()
    {
        boolean isFeatureFlagEnabled = TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled();

        // Throw exception if there is any call to the function without feature enabled.
        if (!isFeatureFlagEnabled)
        {
            error(strFmt("@SYS19306", funcName()));
        }

        TrvExpCashAdvanceMapping trvExpCashAdvanceMapping;

        select sum(AmountMST) from trvExpCashAdvanceMapping
            where trvExpCashAdvanceMapping.ExpLineRecId == this.RecId;

        return trvExpCashAdvanceMapping.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReturnAdvanceWithoutMapping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if this is return cash line where the cash advance mapping is missing or deleted by user.
    /// </summary>
    /// <returns>
    /// True, if this a return cash record and missing in <c>TrvExpCashAdvanceMapping</c> table; 
    /// Otherwise, false.
    /// </returns>
    public boolean isReturnAdvanceWithoutMapping()
    {
        boolean ret = false;
        if (this.CashAdvanceRecId)
        {
            ret = !TrvExpCashAdvanceMapping::existsExpenseLine(this.RecId) ;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxDistributionExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if there is a line for tax in corresponding accounting distribution. 
    /// This method does not validates if the tax amount is fully distributed.
    /// </summary>
    /// <returns>True, if there is a line for tax in corresponding accounting distribution; Otherwise, false.</returns>
    public boolean taxDistributionExists()
    {
        boolean ret = false;
        AccountingDistribution parentAccountingDistribution;

        if (this.SourceDocumentLine != 0)
        {
            select firstonly RecId from parentAccountingDistribution 
                                   where parentAccountingDistribution.SourceDocumentLine == this.SourceDocumentLine;

            if (parentAccountingDistribution.RecId != 0)
            {
                AccountingDistribution taxAccountingDistribution;

                select firstonly RecId from taxAccountingDistribution 
                                       where taxAccountingDistribution.ParentDistribution == parentAccountingDistribution.RecId
                                       && taxAccountingDistribution.MonetaryAmount != MonetaryAmount::ExtendedPrice;
            
                ret = taxAccountingDistribution.RecId != 0;

            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesSplitLineHasParentExpWithProj</Name>
				<Source><![CDATA[
    public boolean doesSplitLineHasParentExpWithProj(TrvExpTrans _trvExpTrans)
    {
        TrvExpTrans trvExpTransParent;

        select firstonly trvExpTransParent
            where trvExpTransParent.RecId == _trvExpTrans.ParentRecId;

        return (_trvExpTrans.SplitLineType == TrvExpSplitLineType::SplitLine && trvExpTransParent.ProjId != '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletePerDiemData</Name>
				<Source><![CDATA[
    public void deletePerDiemData(DataAreaId _companyContext = curExt())
    {
		if (this.ExpType == TrvExpType::Allowance)
		{
			changecompany(_companyContext)
            {
				TrvExpPerdiemData perDiemData;
				delete_from perDiemData where perDiemData.TrvExpTrans == this.RecId;
			}
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSplitRecords</Name>
				<Source><![CDATA[
    public void deleteSplitRecords(DataAreaId _companyContext = curExt())
    {
		changecompany(_companyContext)
        {
			TrvExpTransSplit trvExpTransSplit;
			delete_from trvExpTransSplit 
                    where trvExpTransSplit.SplitLineRecId == this.RecId;
        }
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteMatchRecords</Name>
				<Source><![CDATA[
    public void deleteMatchRecords(DataAreaId _companyContext = curExt())
    {
        changecompany(_companyContext)
        {
			TrvMatchedExpenseLines trvMatchedExpenseLines;
			delete_from trvMatchedExpenseLines 
					where trvMatchedExpenseLines.MatchedExpense == this.RecId ||
						  trvMatchedExpenseLines.HiddenExpense == this.RecId;
        }
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteGSTRecords_MY</Name>
				<Source><![CDATA[
    public void deleteGSTRecords_MY()
    {
        DataAreaId companyContext = TaxParameters::isTaxObligationDestination()? this.InterCompanyLE : this.ReferenceDataAreaId;

        if (CompanyInfoExtension::existsDataArea(companyContext) &&
			TaxGSTFeatureChecker_MY::isCountryRegionMY())
        {
			changecompany(companyContext)
            {
				TaxGSTTaxInformation_MY taxGSTTaxInformationMY;
				delete_from taxGSTTaxInformationMY 
							where taxGSTTaxInformationMY.SourceRecID == this.RecId &&
								  taxGSTTaxInformationMY.SourceTableID == this.TableId;
            }
              
        }
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDimensionModified</Name>
				<Source><![CDATA[
    public boolean isDimensionModified()
    {
        boolean ret = this.DefaultDimension != this.orig().DefaultDimension;    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDuplicateExpenses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if Per Diem date periods are overlapping
    /// </summary>
    /// <returns>
    /// True, if expensess doesn't exist with same transaction dates, otherwise false
    /// </returns>
    private boolean validateDuplicateExpenses()
    {
        
        boolean isValid = true;
        
        if(this.DateFrom == DateTimeUtil::minValue()
            || this.DateTo == DateTimeUtil::maxValue())
        {
            isValid = !(this.ExpType == TrvExpType::Allowance);
        }
        else
        {
            isValid = this.isOverlappingPerDiem(!TrvExpenseHelper::isTrvOverlappingPerdiemsForSameLocationFlightEnabled());
        }
        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mealsAndIncidentalsWithCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// mealsAndIncidentals is total meals and incidentals allowance to be paid to employee after deduction, it does not include hotel allowance.
    /// </summary>
    /// <returns>The amount together with the transaction currency code.</returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvAmountCurrency mealsAndIncidentalsWithCurrencyCode()
    {
        // Total Amount = Total Calc. - Reduction
        //i.e. this.AmountMST  = mealAllowance + hotelAllowance + otherAllowance - mealReduction
        
        // MealsAndIncidentals = this.TotalAmount - this.PerDiemHotelAllowance
        // i.e. MealsAndIncidentals = mealAllowance + otherAllowance - mealReduction

        AmountCur   mealsAndIncidentals;

        mealsAndIncidentals = this.AmountCurr - this.PerDiemHotelAllowance;

        mealsAndIncidentals = mealsAndIncidentals < 0 ? 0 : mealsAndIncidentals;

        mealsAndIncidentals = CurrencyExchangeHelper::amountCur2MST(mealsAndIncidentals, this.ExchangeCode, this.ExchangeRate);

        return TrvExpenseHelper::amountWithCurrencyCode(mealsAndIncidentals, this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deductionWithLECurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays deduction along with the LE currency code.
    /// </summary>
    /// <returns>
    /// The deduction in LE currency, along with the LE currency code.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    display TrvDeductionWithCurrencyCode deductionWithLECurrencyCode()
    {
        this.Deduktion = CurrencyExchangeHelper::amountCur2MST(this.Deduktion, this.ExchangeCode, this.ExchangeRate);

        return TrvExpenseHelper::amountWithCurrencyCode(this.Deduktion, this.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDeductions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Total meal allowance is considered for only 1 breakfast/ lunch/dinner each per day.
    /// If the numberentered by user exceeds the total trip duration, then throw error.
    /// </summary>
    /// <param name = "numTotalDays">integer value to get number of total days allowance.</param>
    private void checkDeductions(int numTotalDays)
    {
        if(this.DeduktionBreakfest > numTotalDays)
        {
            throw error(strFmt("@Expense:PerDiemDeductionsCannotExceedMessage", fieldPName(TrvExpTrans, DeduktionBreakfest)));
        }
        else if(this.DeduktionLunch > numTotalDays)
        {
            throw error(strFmt("@Expense:PerDiemDeductionsCannotExceedMessage", fieldPName(TrvExpTrans, DeduktionLunch)));
        }
        else if(this.DeduktionDinner > numTotalDays)
        {
            throw error(strFmt("@Expense:PerDiemDeductionsCannotExceedMessage", fieldPName(TrvExpTrans, DeduktionDinner)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExpCurDiffThanCompanyCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the current exchange currency is different than company's standard currency
    /// </summary>
    /// <returns>
    /// True, if standard currency is different from expense currency; Otherwise, false.
    /// </returns>
    public boolean isExpCurDiffThanCompanyCur()
    {
        return CompanyInfoHelper::standardCurrency() != this.ExchangeCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsItemizedLineWithoutGroupID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if any itemized line does not have itemization group identifier.
    /// </summary>
    /// <returns>
	/// True, if any of the itemized line does not have itemization group identifier; Otherwise, false.
	/// </returns>
    public boolean existsItemizedLineWithoutGroupID()
    {
		return (select firstonly RecId from TrvExpTrans
                                        where TrvExpTrans.ParentRecId == this.RecId
                                        &&	  TrvExpTrans.LineType == TrvExpLineType::ItemizedLine
                                        &&	  TrvExpTrans.ExpenseItemizationGroupId == "").RecId != 0;

	}

]]></Source>
			</Method>
			<Method>
				<Name>checkItemizationGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if itemization group id is empty and throws an exception if it is not.
    /// </summary>
    public void checkItemizationGroupId()
    {
        if (this.isItemizationGroupIdSet())
        {
            throw error("@Expense:ExpenseItemizationNotAllowEditError");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemizationGroupIdSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if itemization group id is empty.
    /// </summary>
    /// <returns>
    /// True, if itemization group id is not empty; Otherwise, false.
    /// </returns>
    public boolean isItemizationGroupIdSet()
    {
        return this.ParentRecId != 0
            && this.ExpenseItemizationGroupId != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllocationFactorDenominator</Name>
				<Source><![CDATA[
    private Amount getAllocationFactorDenominator(CurrencyCode _exchangeCode)
    {
        Amount deductionAmount;

        deductionAmount = this.TaxIncluded == NoYes::Yes? this.CorrectedTaxAmount: 0.00;
        
        Amount denominator;

        switch(_exchangeCode)
        {
            case this.ExchangeCode: denominator = this.AmountCurr - deductionAmount;
                break;
            case this.CreditCardTransactionCurrency: denominator = this.CreditCardTransactionCurrencyAmount - deductionAmount;
                break;
            default: denominator = this.AmountMST - deductionAmount;
        }

        return denominator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOverlappingPerDiem</Name>
				<Source><![CDATA[
    private boolean isOverlappingPerDiem(boolean allowOverlappingForSameLocation)
    {
        TrvExpTrans trvExpTrans;

        if(this.TrvLocations)
        {
            if (allowOverlappingForSameLocation)
            {
                select firstonly CostType, DateFrom, DateTo, RecId from  trvExpTrans
                    where trvExpTrans.CreatingWorker == this.CreatingWorker
                        && trvExpTrans.ExpType == TrvExpType::Allowance
                        && trvExpTrans.RecId != this.RecId
                        && trvExpTrans.TrvLocations != this.TrvLocations
                        && ((trvExpTrans.DateFrom <= this.DateFrom && trvExpTrans.DateTo >= this.DateFrom)
                            || (trvExpTrans.DateFrom  <= this.DateTo && trvExpTrans.DateTo >= this.DateTo)
                            || (trvExpTrans.DateFrom >= this.DateFrom && trvExpTrans.DateTo <= this.DateTo));
            }
            else
            {
                select firstonly CostType, DateFrom, DateTo, RecId from  trvExpTrans
                    where trvExpTrans.CreatingWorker == this.CreatingWorker
                        && trvExpTrans.ExpType == TrvExpType::Allowance
                        && trvExpTrans.RecId != this.RecId
                        && ((trvExpTrans.DateFrom <= this.DateFrom && trvExpTrans.DateTo >= this.DateFrom)
                            || (trvExpTrans.DateFrom  <= this.DateTo && trvExpTrans.DateTo >= this.DateTo)
                            || (trvExpTrans.DateFrom >= this.DateFrom && trvExpTrans.DateTo <= this.DateTo));
            }
        }
        
        boolean isOverlappingPerdiemExists = (trvExpTrans.RecId) ?
            checkFailed(strFmt("@Expense:PerDiemDuplicateDateValidation", trvExpTrans.CostType, trvExpTrans.DateFrom, trvExpTrans.DateTo)) :
            true;

        return isOverlappingPerdiemExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAllocationForExpTrans</Name>
				<Source><![CDATA[
    public void updateAllocationForExpTrans()
    {
        AccountingDistribution accountingDistribution;
        
        ttsbegin;
        while select forupdate accountingDistribution
               where accountingDistribution.SourceDocumentLine == this.SourceDocumentLine
        {
            Amount denominator = this.getAllocationFactorDenominator(accountingDistribution.TransactionCurrency);
            if (denominator > 0)
            {
                AllocationFactor allocationFactor = accountingDistribution.TransactionCurrencyAmount / denominator;
                accountingDistribution.AllocationFactor = allocationFactor;
                accountingDistribution.update();
            }
        } 

        ttscommit;

    }

]]></Source>
			</Method>
			<Method>
				<Name>doDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Over-riden dodelete method to delete expense lines with allowable Approval Status
    /// </summary>
    public void doDelete()
    {
        if(!this.canExpenseLineBeDeletedWithApprovalStatus())
        {
            return;
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canExpenseLineBeDeletedWithApprovalStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// List of approval Status for which expense line can be deleted
    /// </summary>
    /// <returns> 
    ///     true if we can delete , false if not allowed
    /// </returns>
    private boolean canExpenseLineBeDeletedWithApprovalStatus()
    {
        if( this.ApprovalStatus == TrvAppStatus::None || 
            this.ApprovalStatus == TrvAppStatus::Matched || 
            this.ApprovalStatus == TrvAppStatus::Create ||
            this.ApprovalStatus == TrvAppStatus::Returned)
            {
                return true;
            }

        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Trv</ConfigurationKey>
	<DeveloperDocumentation>@SYS124842</DeveloperDocumentation>
	<Label>@SYS101487</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>ExpNumber</TitleField1>
	<TitleField2>CostType</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>TrvExpTableIdx</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<CreatedTransactionId>Yes</CreatedTransactionId>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<ModifiedTransactionId>Yes</ModifiedTransactionId>
	<Modules>Expense</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>TrvPolicyViolationsCache</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>TrvPolicyViolationsCache</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>SourceDocumentLine</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>SourceDocumentLine</Relation>
			<Table>SourceDocumentLine</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DateFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreatingWorker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AdditionalInfo</Name>
			<Label>@SYS106810</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Reason</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReimburseAmt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceAmt</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AddlInfo</Name>
			<Label>@SYS101729</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Reason</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TicketNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TicketClass</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TicketUsed</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Advance</Name>
			<Label>@SYS101319</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DateFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Advancereport</Name>
			<Label>@SYS101507</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AdditionalInformation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@SYS14437</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreatingWorker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransRowNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostOwner</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PBSRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApplyAction</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CashAdvanceRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptsAttached</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TrvExpTable</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OriginalReceiptsRecvd</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LegalEntity</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AddressZipCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Allocation</Name>
			<Label>@SYS26697</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Allowance</Name>
			<Label>@SYS101320</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Approved</Name>
			<Label>@SYS10158</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ApprovedDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CaseMoreInformation</Name>
			<Label>@SYS314356</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreatingWorker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OriginalReceiptsRecvd</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TrvLocations</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Cost</Name>
			<Label>@SYS4249</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimension</Name>
			<Label>@SYS14926</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Drive</Name>
			<Label>@SYS101321</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>KMOwnCar</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>KMPrice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MileageFromAddress</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MileageToAddress</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VehicleType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NumberOfPassengers</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>EPMiniPage</Name>
			<Label>@SYS108232</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CostType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Expense</Name>
			<Label>@SYS101318</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>General</Name>
			<Label>@SYS2952</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CreatingWorker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>IntercompanyRevenue</Name>
			<Label>@SYS96035</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IntercompanySalesPrice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntercompanyTransferPrice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntercompanySalesCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntercompanyTransferCurrency</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Itemization</Name>
			<Label>@SYS109620</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LineType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentRecId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>LedgerPosting</Name>
			<Label>@SYS101490</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PostingErrors</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>LogisticsAddress</Name>
			<Label>@SYS22223</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AddressZipCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AddressCity</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>City</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CountryRegion</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AddressState</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Posting</Name>
			<Label>@SYS12896</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LineLevelPosting</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PostAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PostAccountType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Preview</Name>
			<Label>@SYS101487</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CostType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Project</Name>
			<Label>@SYS4534</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjStatusId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjActivityNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransactionText</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InterCompanyCategory</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ProjExpPolicies</Name>
			<Label>@SYS121365</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjPolicyStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptRequired</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReimburseAmt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceAmt</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reduktion</Name>
			<Label>@SYS101506</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DeduktionBreakfest</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DeduktionLunch</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DeduktionDinner</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Deduktion</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReferenceDataArea</Name>
			<Label>@SYS135125</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReferenceDataAreaId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Rejected</Name>
			<Label>@SYS784</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>NotApprovedDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTax</Name>
			<Label>@SYS308726</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CountryRegion</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editCity</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editZipCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxIncluded</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>calcTaxAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CorrectedTaxAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NetTransactionAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Status</Name>
			<Label>@SYS25532</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ApprovalStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PBS_Statement</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TaxAmountMST</Name>
			<Label>@SYS128994</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CorrectedTaxAmountMST</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TaxesLeft</Name>
			<Label>@SYS308726</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CountryRegion</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editCity</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editZipCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroup</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TaxesRight</Name>
			<Label>@SYS308726</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxIncluded</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CorrectedTaxAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>calcTaxAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NetTransactionAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Text</Name>
			<Label>@SYS2595</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Advance</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>cashAdvanceNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Airline</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Allowance</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DateFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DeduktionBreakfest</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DeduktionLunch</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DeduktionDinner</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>deductionWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InterCompanyLE</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PerdiemTimezone</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TrvLocations</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_CarRental</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Conference</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Empty</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Entertainment</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BusinessPurpose</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EntertainmentLocation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Expense</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InterCompanyLE</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Gift</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Hotel</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BillIssuedTo</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_LegalEntity</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InterCompanyLE</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Meals</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Personal</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_Transport</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>KMOwnCar</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>KMPrice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VehicleType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NumberOfPassengers</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>amountMSTWithCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MileageFromAddress</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MileageToAddress</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InterCompanyLE</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TransactionCommon</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TravelPeriod</Name>
			<Label>@SYS130324</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DateFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PerdiemTimezone</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TravelRequisition</Name>
			<Label>@SYS153179</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IsPreAuthorized</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MappedToRequisitionLine</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountingCurrencyReconciledAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountingCurrencyOverBudgetAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VATRecovery</Name>
			<Label>@SYS314519</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>vatRecoveryTaxId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Voucher</Name>
			<Label>@SYS101372</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AdditionalInformation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PostingErrors</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Workflow</Name>
			<Label>@SYS103643</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>categoryOrSubCategoryName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>anyPolicyViolations</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_EntertainmentSpecific</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BusinessPurpose</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EntertainmentLocation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTaxCalculationGroup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CountryRegion</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editCity</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editZipCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxIncluded</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>calcTaxAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CorrectedTaxAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transaction_ItemizedExpenseLine</Name>
			<Label>@SYS15191</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InterCompanyLE</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CreditCard</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CorrectedTaxAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>NonCorrectionOnPosting</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountingCurrencyOverBudgetAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountingCurrencyReconciledAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AdditionalInformation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AddressCity</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AddressZipCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApplyAction</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovalStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApprovedDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BillIssuedTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BusinessPurpose</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CashAdvanceRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostOwner</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreatingWorker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Deduktion</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DeduktionBreakfest</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DeduktionDinner</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DeduktionLunch</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EntertainmentLocation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExpType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntercompanyBilled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InterCompanyLE</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntercompanySalesCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntercompanySalesPrice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntercompanyTransferCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntercompanyTransferPrice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceAmt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsBudgetCheckPending</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsPreAuthorized</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IsSplit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>KMOwnCar</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>KMPrice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LegalEntity</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MappedToRequisitionLine</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MerchantId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MileageFromAddress</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MileageToAddress</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NetTransactionAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NotApprovedDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NumberOfPassengers</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OriginalSourceDocumentLine</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ParentRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PayMethod</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PBS_Statement</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PBSRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PostingErrors</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjPolicyStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjPolicyText</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Reason</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptRequired</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptsAttached</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReferenceDataAreaId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReimburseAmt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SourceDocumentLine</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SubCategoryRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TicketClass</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TicketNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TicketUsed</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransRowNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TrvExpTable</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TrvLocations</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VehicleType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Mobile_Statement</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AirlineTransData</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TicketClass</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TicketNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TicketUsed</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>HotelTransData</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BillIssuedTo</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Allowance_ReadOnly</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ExchangeRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchangeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ExpTransNumber</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvExpTransNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ExchangeCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvCurrencyCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AccountingCurrencyOverBudgetAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AccountingCurrencyReconciledAmount</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Label>@SYS68025</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AdditionalInformation</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemFreeTxt</ExtendedDataType>
			<Label>@SYS101729</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>AddressCity</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LogisticsAddressCityRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>AddressZipCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LogisticsAddressZipCodeRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AmountCurr</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvTransactionCurrencyAmount</ExtendedDataType>
			<RelationContext>Currency</RelationContext>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AmountMST</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMST</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ApplyAction</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS110842</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ApprovalStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS101302</Label>
			<EnumType>TrvAppStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ApprovedDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvDateStd</ExtendedDataType>
			<Label>@SYS101561</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BillIssuedTo</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>DE</CountryRegionCodes>
			<CountryRegionContextField>LegalEntity</CountryRegionContextField>
			<EnumType>TrvBillIssuedTo</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BusinessPurpose</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvLinePurposeEDT</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CashAdvanceRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>City</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AddressCity</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CorrectedTaxAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmountJournal</ExtendedDataType>
			<Label>@SYS128972</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CorrectedTaxAmountMST</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
			<Label>@SYS128994</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CostOwner</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvCostownerEDT</ExtendedDataType>
			<EnumType>TrvCostOwner</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CostType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvCostTypeEDT</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CountryRegion</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LogisticsAddressCountryRegionId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CreatingWorker</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>TrvHcmWorkerRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CreditCardTransactionCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvCurrencyCode</ExtendedDataType>
			<Label>@Expense:CreditCardLocalCurrency</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CreditCardTransactionCurrencyAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvTransactionCurrencyAmount</ExtendedDataType>
			<Label>@Expense:CreditCardLocalAmount</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>DateFrom</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvDateTime</ExtendedDataType>
			<Label>@SYS122757</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>DateTo</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvDateTime</ExtendedDataType>
			<Label>@SYS122758</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Deduktion</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvTransactionCurrencyAmount</ExtendedDataType>
			<Label>@SYS101506</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>DeduktionBreakfest</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Integer</ExtendedDataType>
			<Label>@SYS101731</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>DeduktionDinner</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Integer</ExtendedDataType>
			<Label>@SYS101735</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>DeduktionLunch</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Integer</ExtendedDataType>
			<Label>@SYS101733</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDefaultDimensionValueSet</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Description</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvExpTransDescription</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>EntertainmentLocation</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvEntertainmentLocation</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchangeRate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExchRate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ExpNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvExpNumber</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ExpType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvExpTypeEDT</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
			<EnumType>TrvExpType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IntercompanyBilled</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>boolean</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InterCompanyCategory</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@SYS4110109</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InterCompanyLE</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvLegalEntity</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>IntercompanySalesCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Project</ConfigurationKey>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>IntercompanySalesPrice</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjSalesPriceCost</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>IntercompanyTransferCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>IntercompanyTransferPrice</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCostPriceCost</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>InvoiceAmt</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Project</ConfigurationKey>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SYS9458</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsBudgetCheckPending</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsPreAuthorized</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS153181</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsSplit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvIsSplit</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>KMOwnCar</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvMileage</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>KMPrice</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvCostRate</ExtendedDataType>
			<Label>@SYS101720</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LegalEntity</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LegalEntity</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LineNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvLineNumber</ExtendedDataType>
			<Label>@SYS101704</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LineType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>TrvExpLineType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Location</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>TrvLocation</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>MappedToRequisitionLine</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MerchantId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvExpMerchantId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MileageFromAddress</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>TrvMileageAddress</ExtendedDataType>
			<Label>@SYS333658</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MileageToAddress</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>TrvMileageAddress</ExtendedDataType>
			<Label>@SYS333659</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>NetTransactionAmount</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SYS320349</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>NotApprovedDate</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvDateStd</ExtendedDataType>
			<Label>@SYS101557</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>NumberOfPassengers</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvNumberOfPassengers</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OriginalReceiptsRecvd</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS130496</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OriginalSourceDocumentLine</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ParentRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS109616</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PayMethod</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvPayMethodEDT</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PBS_Statement</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS101723</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PBSRecId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PostingErrors</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvPostingErrors</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjActivityNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjActivityNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjPolicyStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjExpPolicyStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjPolicyText</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SysInfoLogStr</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjStatusId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Project</ConfigurationKey>
			<ExtendedDataType>ProjLinePropertyId</ExtendedDataType>
			<Label>@Expense:Billable</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Reason</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Notes</ExtendedDataType>
			<Label>@SYS86426</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReceiptNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvReceiptNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReceiptRequired</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Project</ConfigurationKey>
			<Label>@SYS121500</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReceiptsAttached</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS335196</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReferenceDataAreaId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DataAreaId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ReimburseAmt</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Project</ConfigurationKey>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SYS121502</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceDocumentLine</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SubCategoryRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>TrvExpSubCategoryEDT</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxGroup</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxIncluded</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS87715</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxItemGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxItemGroup</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TicketClass</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Description</ExtendedDataType>
			<Label>@SYS121496</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TicketNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Description</ExtendedDataType>
			<Label>@SYS101398</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TicketUsed</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS121498</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransactionText</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Project</ConfigurationKey>
			<ExtendedDataType>TransTxt</ExtendedDataType>
			<Label>@SYS30501</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>TransDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvDateStd</ExtendedDataType>
			<Label>@SYS67</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>TransRowNum</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>Integer</ExtendedDataType>
			<Label>@SYS101706</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TrvExpTable</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TrvLocations</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS115833</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VehicleType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvVehicleType</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Voucher</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Voucher</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ZipCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<IsObsolete>Yes</IsObsolete>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Mobile_Statement</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjTransId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Project</ConfigurationKey>
			<ExtendedDataType>ProjCostTransId</ExtendedDataType>
			<Label>@SYS25395</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AddressState</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LogisticsAddressStateId</ExtendedDataType>
			<Label>@SYS303358</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LineLevelPosting</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@Expense:LineLevelPosting</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PostAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalAC</ExtendedDataType>
			<HelpText>@Expense:ExpenseLinePostingAccount</HelpText>
			<Label>@SYS23136</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PostAccountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@Expense:ExpenseLinePostingAccountType</HelpText>
			<Label>@SYS23950</Label>
			<EnumType>LedgerJournalACType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SplitLineType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>TrvExpSplitLineType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PerdiemTimezone</Name>
			<IsObsolete>Yes</IsObsolete>
			<Label>@Expense:PerDiemTimezone</Label>
			<EnumType>Timezone</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>VatDueDate_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VatDueDate_W</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PerDiemHotelAllowance</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TrvPerDiemAmountCur</ExtendedDataType>
			<FeatureClass>ExpenseManagementPerDiemFeature</FeatureClass>
			<Label>@SYS115842</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ExpenseItemizationGroupId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>ExpenseItemizationGroupId</ExtendedDataType>
			<FeatureClass>ExpenseItemizationFeature</FeatureClass>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>EntryPoint</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>TrvExpEntryPointEDT</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>TrvExpEntryPoint</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TrvExpGeneratedBy</Name>
			<EnumType>TrvExpGeneratedBy</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TransactionIdIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ExpTransNumber</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TrvExpNoIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LegalEntity</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ExpNumber</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CostType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateFrom</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TrvExpLineIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LegalEntity</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ExpNumber</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNumber</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TrvExpEmplYearSatsIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LegalEntity</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ExpType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CreatingWorker</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>KMPrice</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateFrom</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>OwnerTypeDateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LegalEntity</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CostOwner</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CostType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateFrom</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TotalsCalcIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LegalEntity</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ExpNumber</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ExpType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineType</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>FK_LogisticsAddressCountryRegion_TrvExpT</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CountryRegion</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>FK_LogisticsAddressZipCode_TrvExpTrans</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>AddressZipCode</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TrvExpTableIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>TrvExpTable</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SourceDocumentLineIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceDocumentLine</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TrvCreatingWorkerIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CreatingWorker</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TrvRequisitionLineIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>MappedToRequisitionLine</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ParentRecIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ParentRecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AmountCurr</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CreditCardTransactionCurrencyAmount</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransDate</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CurrencyIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CreditCardTransactionCurrency</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TrvExpTableByLineTypeIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>TrvExpTable</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineType</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LegalEntityTransIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LegalEntity</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ProjTransId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ItemizedRecordIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ParentRecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransDate</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ExpenseByDateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ExpNumber</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransDate</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CostType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>SplitLineType</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>IntercompanyBilledActivityIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ReferenceDataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InterCompanyLE</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ProjActivityNumber</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>IntercompanyBilled</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>IntercompanyBilledIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InterCompanyLE</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>IntercompanyBilled</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ActivityNumberidx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjActivityNumber</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InterCompanyLE</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CreatedTransactionIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CreatedTransactionId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TrvExpAgentIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LegalEntity</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ExpNumber</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TrvExpGeneratedBy</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CreatingWorker</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SourceDocumentLineImplementation</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>SourceDocumentLine</MapField>
					<MapFieldTo>SourceDocumentLine</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AddressCity</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LogisticsAddressCity</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AddressCity</Name>
					<Field>AddressCity</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AddressZipCode_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LogisticsAddressZipCode</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProvidesARegionFor</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>OccurredIn</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AddressZipCode</Name>
					<Field>AddressZipCode</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CashAdvance</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124843</EntityRelationshipRole>
			<RelatedTable>TrvCashAdvance</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>IsReturnedThrough</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>Returns</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CashAdvanceRecId</Name>
					<Field>CashAdvanceRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CCImported</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TrvPBSMaindata</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>IsReportedVia</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>Reports</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PBSRecId</Name>
					<Field>PBSRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CompanyInfo</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CompanyInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>DataArea</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Key</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CostType</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124844</EntityRelationshipRole>
			<RelatedTable>TrvCostType</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>Describes</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>IsDescribedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CostType</Name>
					<SourceEDT>TrvCostTypeEDT</SourceEDT>
					<Field>CostType</Field>
					<RelatedField>CostType</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CostType</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CreditCardTransactionCurrency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CreditCardTransactionCurrency</Name>
					<SourceEDT>TrvCurrencyCode</SourceEDT>
					<Field>CreditCardTransactionCurrency</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124845</EntityRelationshipRole>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Quantifies</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>IsQuantifiedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ExchangeCode</Name>
					<SourceEDT>TrvCurrencyCode</SourceEDT>
					<Field>ExchangeCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Designates</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DesginatedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InterCompanyLE</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CompanyInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InterCompanyLE</Name>
					<Field>InterCompanyLE</Field>
					<RelatedField>DataArea</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Key</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>IntercompanySalesCurrency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>IntercompanySalesCurrency</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>IntercompanySalesCurrency</Name>
					<Field>IntercompanySalesCurrency</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>IntercompanyTransferCurrency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>IntercompanyTransferCurrency</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>IntercompanyTransferCurrency</Name>
					<Field>IntercompanyTransferCurrency</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ItemizedLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124846</EntityRelationshipRole>
			<RelatedTable>TrvExpTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BelongsTo</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>Contains</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ParentRecId</Name>
					<Field>ParentRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LegalEntity</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CompanyInfo</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>LegallyAccountsFor</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BelongsTo</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LegalEntity</Name>
					<Field>LegalEntity</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LogisticsAddressCountryRegion</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LogisticsAddressCountryRegion</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CountryRegion</Name>
					<SourceEDT>LogisticsAddressCountryRegionId</SourceEDT>
					<Field>CountryRegion</Field>
					<RelatedField>CountryRegionId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CountryRegionIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OriginalSourceDocumentLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SourceDocumentLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CopyFrom</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CopyTo</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OriginalSourceDocumentLine</Name>
					<Field>OriginalSourceDocumentLine</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PayValidate</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124848</EntityRelationshipRole>
			<RelatedTable>TrvValidatePayment</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DescribesThePaymentOf</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>IsPaidUsing</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PayMethod</Name>
					<Field>PayMethod</Field>
					<RelatedField>PayMethod</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CostType</Name>
					<Field>CostType</Field>
					<RelatedField>CostType</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CostPayIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjCategory_InterCompanyCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>ProjCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjTable_InterCompanyCategory</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TrvExpTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InterCompanyCategory</Name>
					<Field>InterCompanyCategory</Field>
					<RelatedField>CategoryId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CategoryIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjLineProperty</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjLineProperty</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjStatusId</Name>
					<SourceEDT>ProjLinePropertyId</SourceEDT>
					<Field>ProjStatusId</Field>
					<RelatedField>LinePropertyId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>StatusIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjTable_ProjId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjTable_ProjId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TrvExpTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjId</Name>
					<SourceEDT>ProjId</SourceEDT>
					<Field>ProjId</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ProjectIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>smmActivities</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>smmActivities</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjActivityNumber</Name>
					<SourceEDT>ProjActivityNumber</SourceEDT>
					<Field>ProjActivityNumber</Field>
					<RelatedField>ActivityNumber</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ActivityNumberIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SourceDocumentLine</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>SourceDocumentLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>IsAccountingDistributionFor</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>IsAccountingDistributedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceDocumentLine</Name>
					<Field>SourceDocumentLine</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SubCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TrvExpSubCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>FurtherCategorizes</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>FurtherCatergorizedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SubCategoryRecId</Name>
					<Field>SubCategoryRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxGroup</Name>
					<SourceEDT>TaxGroup</SourceEDT>
					<Field>TaxGroup</Field>
					<RelatedField>TaxGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxItemGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxItemGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxItemGroup</Name>
					<SourceEDT>TaxItemGroup</SourceEDT>
					<Field>TaxItemGroup</Field>
					<RelatedField>TaxItemGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxItemGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TrvCostTypeRates</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TrvCostTypeRates</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProvidesVehicleTypeFor</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>UsesVehicleType</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VehicleType</Name>
					<Field>VehicleType</Field>
					<RelatedField>VehicleType</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TrvExpMerchant</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>TrvExpMerchant</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MerchantId</Name>
					<SourceEDT>TrvExpMerchantId</SourceEDT>
					<Field>MerchantId</Field>
					<RelatedField>MerchantId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>MerchantIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TrvExpTableRecID</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TrvExpTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Reports</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ReportedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TrvExpTable</Name>
					<Field>TrvExpTable</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TrvHcmWorker</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>Creates</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CreatedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CreatingWorker</Name>
					<Field>CreatingWorker</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TrvLinePurpose</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TrvLinePurpose</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Link</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BusinessPurpose</Name>
					<SourceEDT>TrvLinePurposeEDT</SourceEDT>
					<Field>BusinessPurpose</Field>
					<RelatedField>BusinessPurpose</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TrvLocations</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TrvLocations</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TrvLocations</Name>
					<Field>TrvLocations</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Location</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TrvPayMethod</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TrvPayMethod</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReferenceDataAreaId</Name>
					<Field>ReferenceDataAreaId</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PayMethod</Name>
					<SourceEDT>TrvPayMethodEDT</SourceEDT>
					<Field>PayMethod</Field>
					<RelatedField>PayMethod</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>PayMethodIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TrvRequisitionLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TrvRequisitionLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MappedToRequisitionLine</Name>
					<Field>MappedToRequisitionLine</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WebAdvanceCosttype</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TrvCostType</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>DeterminesProcessingOf</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProcessindDeterminedBy</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ExpType</Name>
					<Field>ExpType</Field>
					<RelatedField>ExpType</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>AddressState</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LogisticsAddressState</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AddressState</Name>
					<SourceEDT>LogisticsAddressStateId</SourceEDT>
					<Field>AddressState</Field>
					<RelatedField>StateId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>