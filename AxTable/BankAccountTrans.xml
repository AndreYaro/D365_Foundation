<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankAccountTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class BankAccountTrans extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>amountCurModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the amounts after the <c>AmountCur</c> field is modified.
    /// </summary>
    /// <param name="_fieldId">
    /// The field ID of the modified field.
    /// </param>
    public void amountCurModified(FieldId _fieldId)
    {
        if (this.Manual                             &&
            this.AmountCur != this.orig().AmountCur &&
            (! this.BankTransAmountCur              ||
             Box::okCancel(strFmt("@GLS221025", fieldId2pname(this.TableId, _fieldId), fieldId2pname(this.TableId, fieldNum(BankAccountTrans, BankTransAmountCur))), DialogButton::Ok) == DialogButton::Ok))
        {
            this.initBankTransAmountCurFromAmountCur();
        }

        this.calcAmountMST();
        this.calcAmountReportingCurrency();

        if (Ledger::reportingCurrency())
        {
            this.calcReportingCurrencyAmount_RU();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankTransAmountCurModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the amounts after the <c>BankTransAmountCur</c> or <c>BankTransCurrencyCode</c> fields
    /// are modified.
    /// </summary>
    /// <param name="_fieldId">
    /// The field ID of the modified field.
    /// </param>
    public void bankTransAmountCurModified(FieldId _fieldId)
    {
        if (this.Manual                                                         &&
            (this.BankTransAmountCur    != this.orig().BankTransAmountCur       ||
             this.BankTransCurrencyCode != this.orig().BankTransCurrencyCode)   &&
            (! this.AmountCur                                                   ||
             Box::okCancel(strFmt("@GLS221025", fieldId2pname(this.TableId, _fieldId), fieldId2pname(this.TableId, fieldNum(BankAccountTrans, AmountCur))), DialogButton::Ok) == DialogButton::Ok))
        {
            this.initAmountCurFromBankTransAmountCur();
        }

        this.calcAmountMST();
        this.calcAmountReportingCurrency();

        if (Ledger::reportingCurrency())
        {
            this.calcReportingCurrencyAmount_RU();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountMST</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    void calcAmountMST()
    {
        ExchRate exchRate = 0;
        if (BankStmtReconcileRecordPostingExchangeRateFlight::instance().isEnabled()
            && !BankAccountTable::isAdvancedBankReconciliationEnabled(this.AccountId)
            && this.ExchRateMST)
        {
            exchRate = this.ExchRateMST;
        }
        
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.AccountingCurrencyAmountCorrect_RU = CurrencyExchangeHelper::mstAmount(this.AmountCorrect, this.CurrencyCode, this.TransDate, UnknownNoYes::Unknown, exchRate);

            this.AmountMST = CurrencyExchangeHelper::mstAmount(this.BankTransAmountCur, this.BankTransCurrencyCode, this.TransDate, UnknownNoYes::Unknown, exchRate) +
                    this.AccountingCurrencyAmountCorrect_RU;
        }
        else
        {
            // </GEERU>
            this.AmountMST = CurrencyExchangeHelper::mstAmount(this.AmountCur + this.AmountCorrect, this.CurrencyCode, this.TransDate, UnknownNoYes::Unknown, exchRate);
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and sets the amount in reporting currency for the <c>BankAccountTrans</c> record.
    /// </summary>
    public void calcAmountReportingCurrency()
    {
        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), this.TransDate);
        currencyExchangeHelper.parmErrorType(AifErrorType::Exception);
        this.AmountReportingCurrency = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(this.CurrencyCode, this.AmountCur + this.AmountCorrect);

        if (BankStmtReconcileRecordPostingExchangeRateFlight::instance().isEnabled()
            && !BankAccountTable::isAdvancedBankReconciliationEnabled(this.AccountId)
            && this.ExchRateRep)
        {
            currencyExchangeHelper.parmReportingExchangeRate1(this.ExchRateRep);
        }
        
        this.AmountReportingCurrency = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(this.CurrencyCode, this.AmountCur + this.AmountCorrect);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReportingCurrencyAmount_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and sets the amount in reporting currency for a <c>BankAccountTrans</c> record.
    /// </summary>
    void calcReportingCurrencyAmount_RU()
    {
        CurrencyExchangeHelper currencyExchangeHelper;

        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), this.TransDate);

        this.ReportingCurrencyAmountCorrect_RU = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(
            this.CurrencyCode, this.AmountCorrect);

        this.ReportingCurrencyAmount_RU = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(
            this.BankTransCurrencyCode, this.BankTransAmountCur) +
            this.ReportingCurrencyAmountCorrect_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateBankDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a bank document can be created from the table in current status.
    /// </summary>
    /// <returns>
    /// true if a bank document can be created from the table in current status; otherwise, false.
    /// </returns>
    public boolean canCreateBankDocument()
    {
        boolean                 ret = true;

        //check whether bank account trans is from existing bank document
        if (BankDocumentTable::findBySource(this.SourceTableId, this.SourceRecId))
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTransDateBeChanged_RU</Name>
				<Source><![CDATA[
    public boolean canTransDateBeChanged_RU()
    {
        LedgerTransModule   ledgerTransModule;
        LedgerTransModuleTmp  transModuleTmp;
        BankAccountTrans    bankAccountTransLocal;
        RCashTrans          rCashTrans;
        LedgerJournalTrans  ledgerJournalTransLocal;

        select firstonly bankAccountTransLocal
            where bankAccountTransLocal.Voucher   == this.Voucher   &&
                  bankAccountTransLocal.TransDate == this.TransDate &&
                  ! bankAccountTransLocal.Reconciled                &&
                  (bankAccountTransLocal.Included                   ||
                   bankAccountTransLocal.AmountCorrect);
        if (bankAccountTransLocal)
        {
            return false;
        }

        select firstonly rCashTrans
            where rCashTrans.Voucher    == this.Voucher   &&
                  rCashTrans.TransDate  == this.TransDate &&
                  (rCashTrans.AmountCur >  0              ||
                  (rCashTrans.AmountCur < 0               &&
                   rCashTrans.DocType   != RCashDocType::DisbursementSlip &&
                   rCashTrans.DocType   != RCashDocType::ReimbursementSlip));

        if (rCashTrans)
        {
            return false;
        }

        select firstonly ledgerJournalTransLocal
            where ledgerJournalTransLocal.TransDate == this.TransDate &&
                  ledgerJournalTransLocal.Voucher   == this.Voucher   &&
                  ledgerJournalTransLocal.BankDepositVoucher;

        if (ledgerJournalTransLocal)
        {
            return false;
        }

        ledgerTransModule = LedgerTransModule::construct();

        ledgerTransModule.createTransModule(GeneralLedgerExtension::findByReferenceNumberAccountingDate(this.Voucher, this.TransDate).RecId);

        transModuleTmp = ledgerTransModule.transModule();

        select firstonly transModuleTmp
            where transModuleTmp.Module != SysModule::Ledger &&
                  transModuleTmp.Module != SysModule::Bank   &&
                  transModuleTmp.Module != SysModule::Tax    &&
                  transModuleTmp.Module != SysModule::RCash;

        return ! transModuleTmp.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctedAmountCur</Name>
				<Source><![CDATA[
    edit AmountCur correctedAmountCur(boolean   _set,
                                      AmountCur _amountCur)
    {
        AmountCur   correctedAmountCur;

        if (_set)
        {
            this.AmountCorrect = _amountCur - this.AmountCur;
            correctedAmountCur = _amountCur;
        }
        else
        {
            correctedAmountCur = this.AmountCur + this.AmountCorrect;
        }

        return correctedAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctedAmountCurDebCred</Name>
				<Source><![CDATA[
    display AmountCurDebCred correctedAmountCurDebCred()
    {
        return (this.AmountCur + this.AmountCorrect);
    }

]]></Source>
			</Method>
			<Method>
				<Name>custAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays customer account number.
    /// </summary>
    /// <returns>The customer account.</returns>
    display CustAccount custAccount()
    {
        // Refactor: Switch to using CustTrans after single voucher is prohibited.
        CustAccount custAccount;
        Common sourceTable;
        LedgerJournalTrans ledgerJournalTrans;
        bankDeposit bankDeposit;
        CustTrans custTrans;

        if (this.SourceTableId && this.SourceRecId)
        {
            sourceTable = new DictTable(this.SourceTableId).makeRecord();
            select firstOnly sourceTable
               where sourceTable.RecId == this.SourceRecId;
        }

        if (sourceTable)
        {
            switch (this.SourceTableId)
            {
                case tableNum(LedgerJournalTrans) :
                    ledgerJournalTrans = sourceTable;
                    if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                    {
                        custAccount = ledgerJournalTrans.parmAccount();
                    }
                    else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
                    {
                        custAccount = ledgerJournalTrans.parmOffsetAccount();
                    }
                    break;

                case tableNum(BankDepositDocument) :
                    select firstOnly bankDeposit
                       where bankDeposit.BankDepositDocument == sourceTable.RecId;
                    custAccount = bankDeposit.CustAccount;
                    break;

                case tableNum(BankDeposit) :
                    custAccount = sourceTable.(fieldNum(BankDeposit, CustAccount));
                    break;

                case tableNum(BankChequeTable) :
                    if (sourceTable.(fieldNum(BankChequeTable, RecipientType)) == BankChequeRecipientType::Cust)
                    {
                        custAccount = sourceTable.(fieldNum(BankChequeTable, RecipientAccountNum));
                    }
                    break;

                case tableNum(CustTrans) :
                    custAccount = sourceTable.(fieldNum(CustTrans, AccountNum));
                    break;
            }
        }

        // searching by voucher and date may be ambiguous
        if (!custAccount && !VendTrans::findVoucherDate(this.Voucher, this.TransDate))
        {
            select count(RecId), maxOf(AccountNum) from custTrans
               group by AccountNum
               where custTrans.Voucher     == this.Voucher
                   && custTrans.TransDate  == this.TransDate;

            if (custTrans.RecId > 1)
            {
                custAccount = '';
            }
            else
            {
                custAccount = custTrans.AccountNum;
            }
        }

        return custAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes bank account transaction.
    /// </summary>
    public void delete()
    {
        if (BankAccountTable::isAdvancedBankReconciliationEnabled(this.AccountId))
        {
            BankDocumentProcessor::deleteBankDocument(this.TableId, this.RecId);
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayBankCashDueAnnouncement_RU</Name>
				<Source><![CDATA[
    display BankCashDueAnnouncement_RU displayBankCashDueAnnouncement_RU()
    {
        LedgerJournalTrans ledgerJournalTrans;
        select firstonly AnnouncementNum_RU from ledgerJournalTrans
             where ledgerJournalTrans.Voucher   == this.Voucher   &&
                   ledgerJournalTrans.TransDate == this.TransDate &&
                   ledgerJournalTrans.AnnouncementNum_RU;

        return ledgerJournalTrans.AnnouncementNum_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPaymReference</Name>
				<Source><![CDATA[
    display PaymReference displayPaymReference()
    {
        if (this.ChequeNum)
        {
            return this.ChequeNum;
        }

        if (this.DepositNum)
        {
            return this.DepositNum;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelatedTrans_RU</Name>
				<Source><![CDATA[
    public RecordSortedList findRelatedTrans_RU(boolean _forUpdate = false)
    {
        BankAccountTrans    bankAccountTransParent;
        RefRecId            refRecId;
        RecordSortedList    resultList;

        resultList = new RecordSortedList(tableNum(BankAccountTrans));
        resultList.sortOrder(fieldNum(BankAccountTrans, RecId));

        bankAccountTransParent.selectForUpdate(_forUpdate);

        if (this.RefRecId_RU)
        {
            select firstonly bankAccountTransParent
                where bankAccountTransParent.RecId == this.RefRecId_RU;

            if (bankAccountTransParent)
            {
                while (bankAccountTransParent.RefRecId_RU != bankAccountTransParent.RecId)
                {
                    refRecId = bankAccountTransParent.RefRecId_RU;
                    select firstonly bankAccountTransParent
                        where bankAccountTransParent.RecId == refRecId;
                }
            }
        }
        else
        {
            select firstonly bankAccountTransParent
                where bankAccountTransParent.RecId == this.RecId;
        }

        this.recursiveSearch_RU(bankAccountTransParent, resultList, _forUpdate);

        return resultList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankDocumentTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets related bank document table.
    /// </summary>
    /// <returns>
    /// The related bank document table.
    /// </returns>
    public BankDocumentTable getBankDocumentTable()
    {
        BankDocumentTable bankDocumentTable;

        bankDocumentTable = BankDocumentTable::findBySource(this.TableId, this.RecId);
        if (!bankDocumentTable)
        {
            bankDocumentTable = BankDocumentTable::findBySource(this.SourceTableId, this.SourceRecId);
        }
        return bankDocumentTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAmountCurFromBankTransAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>AmountCur</c> field from the <c>BankTransAmountCur</c> field.
    /// </summary>
    public void initAmountCurFromBankTransAmountCur()
    {
        if (!this.BankTransCurrencyCode)
        {
            this.BankTransCurrencyCode  = this.CurrencyCode;
        }

        this.AmountCur = CurrencyExchangeHelper::curAmount2CurAmount(this.BankTransAmountCur, this.BankTransCurrencyCode, this.CurrencyCode, this.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBankTransAmountCurFromAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>BankTransAmountCur</c> field from the <c>AmountCur</c> field.
    /// </summary>
    public void initBankTransAmountCurFromAmountCur()
    {
        if (!this.BankTransCurrencyCode)
        {
            this.BankTransCurrencyCode  = this.CurrencyCode;
        }

        this.BankTransAmountCur = CurrencyExchangeHelper::curAmount2CurAmount(this.AmountCur, this.CurrencyCode, this.BankTransCurrencyCode, this.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    void initValue()
    {
        this.LedgerTransType = LedgerTransType::Bank;
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    void insert()
    {
        boolean isAdvancedBankReconciliationEnabled = BankAccountTable::isAdvancedBankReconciliationEnabled(this.AccountId);
        ttsbegin;

        if (!this.AmountMST)
        {
            this.calcAmountMST();
        }

        if (!this.AmountReportingCurrency)
        {
            this.calcAmountReportingCurrency();
        }

        // <GEERU>
        if (this.shouldCalculateReportingCurrencyAmount_RU() &&
            ! this.ReportingCurrencyAmount_RU)
        {
            this.calcReportingCurrencyAmount_RU();
        }
        // </GEERU>

        if (!this.AcknowledgementDate)
        {
            this.AcknowledgementDate = this.TransDate;
        }

        if (isAdvancedBankReconciliationEnabled)
        {
            //when the bank account trans is related to a bank document
            this.setTransactionReconciledFromBankDocument();
        }

        super();

        if (isAdvancedBankReconciliationEnabled)
        {
            this.processBankDocument();
        }

        if (this.Cancel && this.SourceTableId == tableNum(LedgerJournalTrans))
        {
            BankStatementLinePaymentInformation paymentInfo = BankStatementLinePaymentInformation::findByLedgerJournalTrans(this.SourceRecId, true);

            if (paymentInfo)
            {
                BankAccountTrans reversedBankAccountTrans = BankAccountTrans::findBySource(tableNum(LedgerJournalTrans), paymentInfo.LedgerJournalTrans);
                BankDocumentTable documentTable = BankDocumentTable::findBySource(reversedBankAccountTrans.TableId, reversedBankAccountTrans.RecId);
                BankReconciliationMatchingItem statementMatchingItem = BankReconciliationMatchingItem::findValidByStatementLineRecId(paymentInfo.BankStmtISOReportEntry, true);
                BankReconciliationMatchingItem documentMatchingItem = BankReconciliationMatchingItem::findValidByDocumentRecId(documentTable.RecId, true);
                if (statementMatchingItem
                    && documentMatchingItem
                    && statementMatchingItem.BankReconciliationMatching == documentMatchingItem.BankReconciliationMatching)
                {
                    BankReconciliationMatching matching = BankReconciliationMatching::find(statementMatchingItem.BankReconciliationMatching, true);
                    if (matching.Cancelled == NoYes::Yes || !BankReconciliationHeader::find(matching.BankReconciliationHeader).IsReconciled)
                    {
                        statementMatchingItem.delete();
                        documentMatchingItem.delete();
                        matching.delete();
                    }
                }

                paymentInfo.delete();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBank2Bank_RU</Name>
				<Source><![CDATA[
    public boolean isBank2Bank_RU()
    {
        return (select firstonly bankAccountTrans
                    where bankAccountTrans.TransDate == this.TransDate &&
                          bankAccountTrans.Voucher   == this.Voucher   &&
                          bankAccountTrans.AccountId != this.AccountId &&
                          ! bankAccountTrans.RefRecId_RU).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCash2Bank_RU</Name>
				<Source><![CDATA[
    public boolean isCash2Bank_RU()
    {
        return ! this.RefRecId_RU && (select firstonly rCashTrans
                                          where rCashTrans.Voucher   == this.Voucher                    &&
                                                rCashTrans.TransDate == this.TransDate                  &&
                                                rCashTrans.AmountCur <  0                               &&
                                                (rCashTrans.DocType  == RCashDocType::ReimbursementSlip ||
                                                rCashTrans.DocType   == RCashDocType::DisbursementSlip)).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEditable_RU</Name>
				<Source><![CDATA[
    public boolean isEditable_RU()
    {
        BankAccountTrans    bankAccountTransParent, bankAccountTransChild;
        if (this.Manual || ! this.RefRecId_RU)
        {
            return true;
        }

        select firstonly AmountCur from bankAccountTransParent
            where bankAccountTransParent.RecId == this.RefRecId_RU;

        select firstonly RecId from bankAccountTransChild
            where bankAccountTransChild.RefRecId_RU == this.RecId;

        return this.RecId != this.RefRecId_RU &&
               sign(bankAccountTransParent.AmountCur) == sign(this.AmountCur) &&
               ! bankAccountTransChild;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    public void modifiedField(FieldId _fieldId)
    {
        MainAccountLegalEntity mainAccountLegalEntity;

        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(BankAccountTrans, AmountCur):
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoLT, #isoLV, #isoEE, #isoCZ]))
                {
                    this.amountCurModified(_fieldId);
                }
                else
                {
                    // </GEERU>
                    this.calcAmountMST();
                    this.calcAmountReportingCurrency();
                    // <GEERU>
                }
                // </GEERU>
                break;
            // <GEERU>
            case fieldNum(BankAccountTrans, BankTransAmountCur):
            case fieldNum(BankAccountTrans, BankTransCurrencyCode):
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    this.bankTransAmountCurModified(_fieldId);
                }
                break;
            // </GEERU>

            case fieldNum(BankAccountTrans, BankTransType):
            case fieldNum(BankAccountTrans, AmountCorrect):
                this.LedgerDimension = BankTransType::find(this.BankTransType).LedgerDimension;

            // Fall through
            case fieldNum(BankAccountTrans, LedgerDimension):
                if (this.Manual)
                {
                    mainAccountLegalEntity  = MainAccountLegalEntity::findByMainAccountLegalEntity(LedgerDimensionFacade::getMainAccountFromLedgerDimension(this.LedgerDimension).RecId, CompanyInfo::current());
                    if (BankSimpleReconciliationDefaultFinancialDimensionFlight::instance().isEnabled())
                    {
                        if (mainAccountLegalEntity.DefaultDimension)
                        {
                            this.DefaultDimension = mainAccountLegalEntity.DefaultDimension;
                        }
                        else
                        {
                            this.DefaultDimension = BankAccountTable::find(this.AccountId).DefaultDimension;
                        }
                    }
                    else
                    {
                        this.DefaultDimension   = mainAccountLegalEntity.DefaultDimension;
                    }
                    this.TaxGroup           = mainAccountLegalEntity.TaxGroup;
                    this.TaxItemGroup       = mainAccountLegalEntity.TaxItemGroup;
                }
                break;

            case fieldNum(BankAccountTrans, TransDate) :
                this.AcknowledgementDate = this.TransDate;
                break;

            // <GEELV>
            case fieldNum(BankAccountTrans, CentralBankPurposeCode_LV):
                this.CentralBankPurposeText_LV = BankCentralBankPurpose::find(this.CentralBankPurposeCode_LV).Text;
                break;
            // </GEELV>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank account id.
    /// </summary>
    /// <returns>
    /// The bank accound id.
    /// </returns>
    public CompanyBankAccountId parmBankAccount()
    {
        return this.AccountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankCurrencyAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank currency amount.
    /// </summary>
    /// <returns>
    /// The bank currency amount.
    /// </returns>
    public AmountCur parmBankCurrencyAmount()
    {
        return this.AmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankDocumentBookType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank document type.
    /// </summary>
    /// <returns>
    /// The bank document type.
    /// </returns>
    public BankDocumentBookType parmBankDocumentBookType()
    {
        return BankDocumentBookType::Others;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processBankDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes a bank document from a table.
    /// </summary>
    private void processBankDocument()
    {
        //process bank cheque document
        switch (this.SourceTableId)
        {
            case tableNum(BankChequeTable):
                this.processBankDocumentCheque();
                break;

            case tableNum(BankDeposit):
                break;

            default:
                //try creating other type bank document
                if (this.Reconciled)
                {
                    BankDocumentProcessor::submitBankDocumentTable(this, BankDocumentStatusChangeType::Reconcile);
                }
                else
                {
                    BankDocumentProcessor::submitBankDocumentTable(this);
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processBankDocumentCheque</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes a bank document cheque.
    /// </summary>
    private void processBankDocumentCheque()
    {
        BankChequeTable     bankChequeTable;
        BankDocument        bankDocument;
        //Handle check status
        bankChequeTable = BankChequeTable::findByRecId(this.SourceRecId);
        bankDocument = bankDocument::construct(bankChequeTable);

        if (bankDocument)
        {
            if (bankChequeTable.ChequeStatus == ChequeStatus::Payment)
            {
                if (this.Cancel && !this.Reconciled)
                {
                    BankDocumentProcessor::submitBankDocumentTable(bankChequeTable, BankDocumentStatusChangeType::Cancel);
                }
                else if (this.Cancel && this.Reconciled)
                {
                    BankDocumentProcessor::submitBankDocumentTable(bankChequeTable, BankDocumentStatusChangeType::Clear);
                }
            }
            else if (bankChequeTable.ChequeStatus == ChequeStatus::CancelPending
                && this.Reconciled
                && !bankDocument.getIsReconciled())
            {
                BankDocumentProcessor::submitBankDocumentTable(bankChequeTable, BankDocumentStatusChangeType::Reconcile);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recursiveSearch_RU</Name>
				<Source><![CDATA[
    private void recursiveSearch_RU(
        BankAccountTrans    _bankAccountTrans,
        RecordSortedList    _resultList,
        boolean             _forUpdate)
    {
        BankAccountTrans    bankAccountTransLocal;

        _resultList.ins(_bankAccountTrans);

        bankAccountTransLocal.selectForUpdate(_forUpdate);

        while select bankAccountTransLocal
            where bankAccountTransLocal.RefRecId_RU == _bankAccountTrans.RecId &&
                    bankAccountTransLocal.RefRecId_RU != bankAccountTransLocal.RecId &&
                    bankAccountTransLocal.RefRecId_RU
        {
            this.recursiveSearch_RU(bankAccountTransLocal, _resultList, _forUpdate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionReconciledFromBankDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the reconciled status that is based on a source bank document.
    /// </summary>
    private void setTransactionReconciledFromBankDocument()
    {
        //set reconciled if the source bank document is reconciled.
        BankDocumentTable bankDocumentTable = BankDocumentTable::findBySource(this.SourceTableId, this.SourceRecId);
        if (bankDocumentTable)
        {
            BankDocument bankDocument = BankDocument::newFromBankDocumentTable(bankDocumentTable);
            if (bankDocument && bankDocument.getIsReconciled())
            {
                this.Reconciled = true;

                if (FeatureStateProvider::isFeatureEnabled(BankBridgingVendorTransactionDetailsFeature::instance())
                    && !FeatureStateProvider::isFeatureEnabled(BankTransClearedDateAdvancedBankReconciliationFeature::instance()))
                {
                    this.ClearedDate = bankDocumentTable.getMatchingStatementLine().getBookingDate();
                }
            }

            if (bankDocument
                && (bankDocument.getIsReconciled() || bankDocument.getIsMatched() || bankDocument.getCancelled())
                && FeatureStateProvider::isFeatureEnabled(BankTransClearedDateAdvancedBankReconciliationFeature::instance()))
            {
                if (bankDocumentTable.BankDocumentBookType == BankDocumentBookType::BankStatement)
                {
                    this.ClearedDate = BankStmtISOReportEntry::find(bankDocumentTable.SourceRecId).getBookingDate();
                }
                else if (bankDocument.getCancelled())
                {
                    this.ClearedDate = this.TransDate;
                }
                else
                {
                    this.ClearedDate = bankDocumentTable.getRecentMatchingStatementLine().getBookingDate();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmount</Name>
				<Source><![CDATA[
    display TaxAmount taxAmount()
    {
        LedgerPostingController controller;
        TaxBankAccountReconcile taxBankAccountReconcile;

        if (this.TaxGroup &&
            this.TaxItemGroup)
        {
            taxBankAccountReconcile = new TaxBankAccountReconcile(NoYes::No, this);

            controller = LedgerPostingController::construct();

            // empty controller is okay because it is configured to not post to GL
            return taxBankAccountReconcile.calcAndPost(controller);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    void update()
    {
        ttsbegin;

        if (this.AmountCorrect && this.LedgerDimension && !this.LedgerTransType)
        {
            this.LedgerTransType = LedgerTransType::Bank;
        }

        if (this.AmountCorrect != this.orig().AmountCorrect)
        {
            this.calcAmountMST();
            this.calcAmountReportingCurrency();
            // <GEERU>
            if (this.shouldCalculateReportingCurrencyAmount_RU())
            {
                this.calcReportingCurrencyAmount_RU();
            }
            // </GEERU>
        }

        if (!this.AcknowledgementDate)
        {
            this.AcknowledgementDate = this.TransDate;
        }

        super();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCalculateReportingCurrencyAmount_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether calculating reporting currency amount is required.
    /// </summary>
    /// <returns>
    /// true if the country region of the legal entity is RU, LT, LV, EE or CZ and reporting currency is set for the Ledger; otherwise, false.
    /// </returns>
    public boolean shouldCalculateReportingCurrencyAmount_RU()
    {
        // <GEERU>
        return (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoLT, #isoLV, #isoEE, #isoCZ]) &&
            Ledger::reportingCurrency());
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    boolean validateDelete()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            if (!this.Manual)
            {
                ret = false;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(fieldId field)
    {
        boolean ret;

        ret = super(field);

        if (ret)
        {
            switch (field)
            {
                case fieldNum(BankAccountTrans, LedgerDimension) :
                    ret =  MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountFromLedgerDimension(this.LedgerDimension).MainAccountId, LedgerPostingType::LedgerJournal);
                    break;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays vendor account number.
    /// </summary>
    /// <returns>The vendor account.</returns>
    display VendAccount vendAccount()
    {
        // Refactor: Switch to using VendTrans after single voucher is prohibited.
        VendAccount vendAccount;
        Common sourceTable;
        LedgerJournalTrans ledgerJournalTrans;
        VendTrans vendTrans;

        if (this.SourceTableId && this.SourceRecId)
        {
            sourceTable = new DictTable(this.SourceTableId).makeRecord();
            select firstOnly sourceTable
                where sourceTable.RecId == this.SourceRecId;
        }

        if (sourceTable)
        {
            switch (this.SourceTableId)
            {
                case tableNum(LedgerJournalTrans) :
                    ledgerJournalTrans = sourceTable;
                    if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                    {
                        vendAccount = ledgerJournalTrans.parmAccount();
                    }
                    else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                    {
                        vendAccount = ledgerJournalTrans.parmOffsetAccount();
                    }
                    break;

                case tableNum(VendTrans) :
                    vendAccount = sourceTable.(fieldNum(VendTrans, AccountNum));
                    break;

                case tableNum(BankChequeTable) :
                    if (sourceTable.(fieldNum(BankChequeTable, RecipientType)) == BankChequeRecipientType::Vend)
                    {
                        vendAccount = sourceTable.(fieldNum(BankChequeTable, RecipientAccountNum));
                    }
                    break;
            }
        }

        // searching by voucher and date may be ambiguous
        if (!vendAccount && !CustTrans::findVoucherDate(this.Voucher, this.TransDate))
        {
            select count(RecId), maxOf(AccountNum) from vendTrans
                group by AccountNum
                where vendTrans.Voucher     == this.Voucher
                    && vendTrans.TransDate  == this.TransDate;

            if (vendTrans.RecId > 1)
            {
                vendAccount = '';
            }
            else
            {
                vendAccount = vendTrans.AccountNum;
            }
        }

        return vendAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendName</Name>
				<Source><![CDATA[
    display VendName vendName()
    {
        return VendTable::find(VendTrans::findVoucherDate(this.Voucher, this.TransDate).AccountNum).name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the balance in accounting currency for the specified bank account.
    /// </summary>
    /// <param name = "_bankAccountId">
    /// The bank account Id.
    /// </param>
    /// <returns>
    /// The balance for the specified bank account in accounting currency.
    /// </returns>
    public static AmountMST balanceMST(CompanyBankAccountId _bankAccountId)
    {
        BankAccountTrans bankAccountTrans;
        select sum(AmountMST) from bankAccountTrans
            where bankAccountTrans.AccountId == _bankAccountId;

        return bankAccountTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the balance in reporting currency for the specified bank account.
    /// </summary>
    /// <param name = "_bankAccountId">
    /// The bank account Id.
    /// </param>
    /// <returns>
    /// The balance for the specified bank account in reporting currency.
    /// </returns>
    public static AmountMSTSecondary balanceReportingCurrency(CompanyBankAccountId _bankAccountId)
    {
        BankAccountTrans bankAccountTrans;
        select sum(AmountReportingCurrency) from bankAccountTrans
            where bankAccountTrans.AccountId == _bankAccountId;

        return bankAccountTrans.AmountReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    public static boolean checkExist(PaymReference _paymReference )
    {
        boolean ret = true;
        if (!BankAccountTrans::exist(_paymReference))
        {
            ret = checkFailed(strFmt(BankAccountTrans::txtNotExist(), _paymReference));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    public static boolean exist(PaymReference _paymReference )
    {
        boolean found;
        found = (select firstonly
                     RecId
                from
                     bankAccountTrans
                 where
                     bankAccountTrans.PaymReference == _paymReference).RecId != 0;

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    public static BankAccountTrans find(
        PaymReference _paymReference ,
        boolean                 _forupdate = false,
        ConcurrencyModel        _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankAccountTrans bankAccountTrans;
        bankAccountTrans.selectForUpdate(_forupdate);
        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            bankAccountTrans.concurrencyModel(_concurrencyModel);
        }

        select firstonly
            bankAccountTrans
            where
            bankAccountTrans.PaymReference == _paymReference;

        return bankAccountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByAccountIDAndBorderoNum_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a BankAccountTrans record using a bank account ID and a bank bordero number.
    /// </summary>
    /// <param name="_accountID">
    /// The company bank account ID of the BankAccountTrans record.
    /// </param>
    /// <param name="_borderoNum">
    /// The bank bordero number of the BankAccountTrans record.
    /// </param>
    /// <param name="_forupdate">
    /// A Boolean value to indicate the selectForUpdate property of the table.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model to use for an update.
    /// </param>
    /// <returns>
    /// A BankAccountTrans buffer.
    /// </returns>
    /// <remarks>
    /// This method will always return a BankAccountTrans buffer.
    /// A non-zero BankAccountTrans.RecId indicates the buffer actually contains good data.
    /// </remarks>
    public static BankAccountTrans findByAccountIDAndBorderoNum_BR(
        CompanyBankAccountId    _accountID,
        BorderoSequenceNum_BR   _borderoNum,
        boolean                 _forupdate = false,
        ConcurrencyModel        _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankAccountTrans bankAccountTrans;
        bankAccountTrans.selectForUpdate(_forupdate);
        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            bankAccountTrans.concurrencyModel(_concurrencyModel);
        }

        if (_accountID != "")
        {
            select firstonly
                bankAccountTrans
            where
                bankAccountTrans.AccountId        == _accountID &&
                bankAccountTrans.PaymReference    == _borderoNum;
        }

        return bankAccountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByAccountIDAndChequeNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds a <c>BankAccountTrans</c> record using a bank account ID and a bank check number.
    /// </summary>
    /// <param name="_accountID">
    ///    The company bank account ID of the <c>BankAccountTrans</c> record.
    /// </param>
    /// <param name="_chequeNum">
    ///    The bank check number of the <c>BankAccountTrans</c> record.
    /// </param>
    /// <param name="_forupdate">
    ///    A Boolean value to indicate the <c>selectForUpdate</c> property of the table; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    ///    The concurrency model to use for an update; optional.
    /// </param>
    /// <returns>
    ///    Returns a <c>BankAccountTrans</c> buffer.
    /// </returns>
    /// <remarks>
    ///    This method will always return a <c>BankAccountTrans</c> buffer.
    ///    A non-zero
    ///    <c>BankAccountTrans.RecId</c> indicates the buffer contains good data.
    /// </remarks>
    public static BankAccountTrans findByAccountIDAndChequeNum(
        CompanyBankAccountId    _accountID,
        BankChequeNum           _chequeNum,
        boolean                 _forupdate = false,
        ConcurrencyModel        _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankAccountTrans bankAccountTrans;
        bankAccountTrans.selectForUpdate(_forupdate);
        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            bankAccountTrans.concurrencyModel(_concurrencyModel);
        }

        if (_accountID != "")
        {
            select firstonly
                bankAccountTrans
            where
                bankAccountTrans.AccountId        == _accountID &&
                bankAccountTrans.ChequeNum        == _chequeNum;
        }

        return bankAccountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByDepositNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds a <c>BankAccountTrans</c> record using a bank deposit number.
    /// </summary>
    /// <param name="_depositNum">
    ///    The bank deposit number of the <c>BankAccountTrans</c> record.
    /// </param>
    /// <param name="_forupdate">
    ///    A Boolean value to indicate the <c>selectForUpdate</c> property of the table; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    ///    The concurrency model to use for an update; optional.
    /// </param>
    /// <returns>
    ///    Returns a <c>BankAccountTrans</c> buffer.
    /// </returns>
    /// <remarks>
    ///    This method will always return a <c>BankAccountTrans</c> buffer.A non-zero
    ///    <c>BankAccountTrans.RecId</c> indicates the buffer contains good data.
    /// </remarks>
    public static BankAccountTrans findByDepositNum(
        BankDepositNum    _depositNum,
        boolean           _forupdate = false,
        ConcurrencyModel  _concurrencyModel = ConcurrencyModel::Auto)
    {
        BankAccountTrans bankAccountTrans;
        BankTransactionType bankTransTypeNSF = BankParameters::find().nsfTransactionType;
        bankAccountTrans.selectForUpdate(_forupdate);
        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            bankAccountTrans.concurrencyModel(_concurrencyModel);
        }

        if (bankTransTypeNSF)
        {
            select firstonly
                bankAccountTrans
            where
                bankAccountTrans.DepositNum    == _depositNum &&
                bankAccountTrans.BankTransType != bankTransTypeNSF &&
                bankAccountTrans.Cancel        == NoYes::No;
        }
        else
        {
            select firstonly
                bankAccountTrans
            where
                bankAccountTrans.DepositNum == _depositNum &&
                bankAccountTrans.Cancel     == NoYes::No;
        }

        return bankAccountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// find by recid
    /// </summary>
    /// <param name="_recId">
    /// recid of the record
    /// </param>
    /// <param name="_forUpdate">
    /// whether to update
    /// </param>
    /// <returns>
    /// the record found
    /// </returns>

    public static BankAccountTrans findByRecId_CN(RefRecId _recId, boolean _forUpdate = false)
    {
        BankAccountTrans bankAccountTrans;
        if (_recId)
        {
            bankAccountTrans.selectForUpdate(_forUpdate);

            select firstonly bankAccountTrans
                where bankAccountTrans.RecId == _recId;
        }
        return bankAccountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds <c>BankAccountTrans</c> record by source record id.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The source table id.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source record id.
    /// </param>
    /// <param name="_forUpdate">
    /// Whether to update the record; optional.
    /// </param>
    /// <returns>
    /// The found record.
    /// </returns>
    public static BankAccountTrans findBySource(RefTableId _sourceTableId, RefRecId _sourceRecId, boolean _forUpdate = false)
    {
        BankAccountTrans bankAccountTrans;

        if (_sourceTableId && _sourceRecId)
        {
            bankAccountTrans.selectForUpdate(_forUpdate);

            select firstonly bankAccountTrans
                where   bankAccountTrans.SourceTableId  == _sourceTableId
                    &&  bankAccountTrans.SourceRecId    == _sourceRecId;
        }
        return bankAccountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds a record in the <c>BankAccountTrans</c> table.
    /// </summary>
    /// <param name="_voucher">
    ///    The voucher number of the transaction.
    /// </param>
    /// <param name="_transDate">
    ///    The date of the transaction.
    /// </param>
    /// <returns>
    ///    The <c>BankAccountTrans</c> buffer.
    /// </returns>

    public static BankAccountTrans findByVoucher(Voucher _voucher, TransDate _transDate)
    {
        BankAccountTrans bankAccountTrans;
        bankAccountTrans.selectLocked(false);

        select firstonly bankAccountTrans
                    index VoucherDateIdx
                    where bankAccountTrans.Voucher   == _voucher &&
                          bankAccountTrans.TransDate == _transDate;

        return bankAccountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findIsReconciled</Name>
				<Source><![CDATA[
    public static boolean findIsReconciled(Voucher _voucher, TransDate _transDate, CurrencyCode _currencyCode, CompanyBankAccountId _accountId, AmountCur _amountCur)
    {
        BankAccountTrans bankAccountTrans;

        select Reconciled from   bankAccountTrans
        where bankAccountTrans.Voucher == _voucher
            && bankAccountTrans.TransDate == _transDate
            && bankAccountTrans.CurrencyCode == _currencyCode
            && bankAccountTrans.AccountId == _accountId
            && bankAccountTrans.AmountCur == _amountCur;

        return bankAccountTrans.Reconciled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBankDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens a bank document list page.
    /// </summary>
    /// <param name="_bankAccountTrans">
    /// A specified <c>BankAccountTrans</c> record.
    /// </param>
    public static void openBankDocument(BankAccountTrans _bankAccountTrans)
    {
        MenuFunction            menuFunction;
        Args                    args = new Args();

        menuFunction = new MenuFunction(menuitemDisplayStr(BankDocumentTableListPage), MenuItemType::Display);
        if (!menuFunction || !menuFunction.checkAccessRights())
        {
            // Access rights are not sufficient to use this function.
            throw error("@SYS81158");
        }
        args.record(_bankAccountTrans.getBankDocumentTable());
        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumTransCur</Name>
				<Source><![CDATA[
    static AmountCur sumTransCur(CompanyBankAccountId _accountId)
    {
        BankAccountTrans    bankAccountTrans;

        select sum(AmountCur), sum(AmountCorrect) from bankAccountTrans
            where bankAccountTrans.AccountId == _accountId;

        return bankAccountTrans.AmountCur + bankAccountTrans.AmountCorrect;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumTransMST</Name>
				<Source><![CDATA[
    static AmountMST sumTransMST(CompanyBankAccountId _accountId)
    {
        BankAccountTrans    bankAccountTrans;
        AmountMST           sumTransMST = 0;
        while select sum(AmountCur), sum(AmountCorrect) from bankAccountTrans
            group by TransDate, CurrencyCode
            where bankAccountTrans.AccountId == _accountId
        {
            if (!bankAccountTrans.CurrencyCode)
            {
                bankAccountTrans.CurrencyCode = CompanyInfoHelper::standardCurrency();
            }
            bankAccountTrans.calcAmountMST();
            sumTransMST += bankAccountTrans.AmountMST;
        }

        return sumTransMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumTransAmountReportingCurrency</Name>
				<Source><![CDATA[
    public static AmountMSTSecondary sumTransAmountReportingCurrency(CompanyBankAccountId _accountId)
    {
        BankAccountTrans    bankAccountTrans;
        AmountMSTSecondary  sumTransAmountReportingCurrency;
        while select sum(AmountCur), sum(AmountCorrect) from bankAccountTrans
            group by TransDate, CurrencyCode
            where bankAccountTrans.AccountId == _accountId
        {
            if (!bankAccountTrans.CurrencyCode)
            {
                bankAccountTrans.CurrencyCode = Ledger::reportingCurrency();
            }
            bankAccountTrans.calcAmountReportingCurrency();
            sumTransAmountReportingCurrency += bankAccountTrans.AmountReportingCurrency;
        }

        return sumTransAmountReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountDisplayCache</Name>
				<Source><![CDATA[
    static container taxAmountDisplayCache(
        container   _conSetRecId,
        container   _conMapTaxAmount
        )
    {
        BankAccountTrans    bankAccountTrans;
        Set                 setRecId            = Set::create(_conSetRecId);
        Map                 mapTaxAmount        = Map::create(_conMapTaxAmount);

        SetIterator si = new SetIterator(setRecId);
        si.begin();
        while (si.more())
        {
            select firstonly bankAccountTrans
            where bankAccountTrans.RecId == si.value();

            mapTaxAmount.insert(si.value(), bankAccountTrans.taxAmount());

            si.next();
        }

        return mapTaxAmount.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    public static TxtNotExist txtNotExist()
    {
        return "@SYS102166";
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a <c>BankAccountTrans</c> table record exists for the bank account.
    /// </summary>
    /// <param name = "_bankAccountId">The ID of the Bank account.</param>
    /// <returns>true if the record exists; otherwise, false.</returns>
    public static boolean existForBankAccount(CompanyBankAccountId _bankAccountId)
    {
        BankAccountTrans bankAccountTrans;

        select firstOnly RecId from bankAccountTrans
            where bankAccountTrans.AccountId == _bankAccountId;

        return bankAccountTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelatedCustVendInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find related customer or vendor information related to this <c>BankAccountTrans</c>
    /// </summary>
    /// <returns>Continer of account number, name and account type</returns>
    [SysObsolete('Method is no longer used. Please use findRelatedCustVendAccountInfo() instead', true, 30\6\2020)]
    public container findRelatedCustVendInfo()
    {
        CustVendAccountInfo relatedCustVendAccountInfo = CustVendAccountInfo::construct();

        switch (this.SourceTableId)
        {
            case tableNum(LedgerJournalTrans):
                relatedCustVendAccountInfo = this.findRelatedLedgerJournalTransInfo();
                break;

            case tableNum(BankChequeTable):
                relatedCustVendAccountInfo = this.findRelatedBankChequeTableInfo();
                break;

            case tableNum(BankDeposit):
                relatedCustVendAccountInfo = this.findRelatedBankDepositInfo();
                break;

            default:
                relatedCustVendAccountInfo.AccountType = DirPartyRoleType::None;
                relatedCustVendAccountInfo.AccountNum = '';
                relatedCustVendAccountInfo.AccountName = '';
        }

        return this.convertCustVendAccountInfoToContainer(relatedCustVendAccountInfo);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertCustVendAccountInfoToContainer</Name>
				<Source><![CDATA[
    //This method shall be removed later with the obsolete method findRelatedCustVendInfo.
    private container convertCustVendAccountInfoToContainer(CustVendAccountInfo _custVendAccountInfo)
    {
        return [_custVendAccountInfo.AccountNum, _custVendAccountInfo.AccountName, _custVendAccountInfo.AccountType];
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertContainerToCustVendAccountInfo</Name>
				<Source><![CDATA[
    //This method shall be removed later with the obsolete method findRelatedCustVendInfo.
    private CustVendAccountInfo convertContainerToCustVendAccountInfo(container _custVendAccountInfo)
    {
        CustVendAccountInfo relatedCustVendAccountInfo = CustVendAccountInfo::construct();

        [relatedCustVendAccountInfo.AccountNum, relatedCustVendAccountInfo.AccountName, relatedCustVendAccountInfo.AccountType] = _custVendAccountInfo;

        return relatedCustVendAccountInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelatedCustVendAccountInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find related customer or vendor information related to this <c>BankAccountTrans</c>
    /// </summary>
    /// <returns>Object of account number, name and account type</returns>
    public CustVendAccountInfo findRelatedCustVendAccountInfo()
    {
        CustVendAccountInfo relatedCustVendAccountInfo = CustVendAccountInfo::construct();

        switch (this.SourceTableId)
        {
            case tableNum(LedgerJournalTrans):
                relatedCustVendAccountInfo = this.findRelatedLedgerJournalTransInfo();
                break;

            case tableNum(BankChequeTable):
                relatedCustVendAccountInfo = this.findRelatedBankChequeTableInfo();
                break;

            case tableNum(BankDeposit):
                relatedCustVendAccountInfo = this.findRelatedBankDepositInfo();
                break;

            default:
                relatedCustVendAccountInfo.AccountType = DirPartyRoleType::None;
                relatedCustVendAccountInfo.AccountNum = '';
                relatedCustVendAccountInfo.AccountName = '';
        }
        return relatedCustVendAccountInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelatedLedgerJournalTransInfo</Name>
				<Source><![CDATA[
    private CustVendAccountInfo findRelatedLedgerJournalTransInfo()
    {
        CustVendAccountInfo custVendAccountInfo = CustVendAccountInfo::construct();
        LedgerJournalTrans ledgerJournalTrans;

        select firstonly ledgerJournalTrans
            where ledgerJournalTrans.RecId == this.SourceRecId;

        switch (ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Vend:
                custVendAccountInfo.AccountType = DirPartyRoleType::Vendor;
                custVendAccountInfo.AccountNum = VendTable::findByLedgerDimension(ledgerJournalTrans.LedgerDimension).AccountNum;
                custVendAccountInfo.AccountName = ledgerJournalTrans.accountName();
                break;

            case LedgerJournalACType::Cust:
                custVendAccountInfo.AccountType = DirPartyRoleType::Customer;
                custVendAccountInfo.AccountNum = CustTable::findByLedgerDimension(ledgerJournalTrans.LedgerDimension).AccountNum;
                custVendAccountInfo.AccountName = ledgerJournalTrans.accountName();
                break;

            default:
                custVendAccountInfo.AccountType = DirPartyRoleType::None;
                custVendAccountInfo.AccountNum = '';
                custVendAccountInfo.AccountName = '';
        }

        return custVendAccountInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelatedBankChequeTableInfo</Name>
				<Source><![CDATA[
    private CustVendAccountInfo findRelatedBankChequeTableInfo()
    {
        CustVendAccountInfo custVendAccountInfo = CustVendAccountInfo::construct();
        BankChequeTable bankChequeTable;

        select firstonly RecipientType, RecipientAccountNum, RecipientCompany from bankChequeTable
            where bankChequeTable.RecId == this.SourceRecId;

        switch (bankChequeTable.RecipientType)
        {
            case BankChequeRecipientType::Vend:
                custVendAccountInfo.AccountType = DirPartyRoleType::Vendor;
                custVendAccountInfo.AccountNum = bankChequeTable.RecipientAccountNum;
                custVendAccountInfo.AccountName = VendTable::findByCompany(bankChequeTable.RecipientCompany, custVendAccountInfo.AccountNum).name();
                break;

            case BankChequeRecipientType::Cust:
                custVendAccountInfo.AccountType = DirPartyRoleType::Customer;
                custVendAccountInfo.AccountNum = bankChequeTable.RecipientAccountNum;
                custVendAccountInfo.AccountName = CustTable::findByCompany(bankChequeTable.RecipientCompany, custVendAccountInfo.AccountNum).name();
                break;

            default:
                custVendAccountInfo.AccountType = DirPartyRoleType::None;
                custVendAccountInfo.AccountNum = '';
                custVendAccountInfo.AccountName = '';
        }

        return custVendAccountInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelatedBankDepositInfo</Name>
				<Source><![CDATA[
    private CustVendAccountInfo findRelatedBankDepositInfo()
    {
        CustVendAccountInfo custVendAccountInfo = CustVendAccountInfo::construct();
        BankDeposit bankDepositTable;

        select firstonly bankDepositTable
            where bankDepositTable.RecId == this.SourceRecId;

        if (bankDepositTable.CustAccount)
        {
            custVendAccountInfo.AccountType = DirPartyRoleType::Customer;
            custVendAccountInfo.AccountNum = bankDepositTable.CustAccount;
            custVendAccountInfo.AccountName = CustTable::find(bankDepositTable.CustAccount).name();
        }
        else
        {
            custVendAccountInfo.AccountType = DirPartyRoleType::None;
            custVendAccountInfo.AccountNum = '';
            custVendAccountInfo.AccountName = '';
        }

        return custVendAccountInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDateOfOldestTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the date of the oldest transaction for the given bank account.
    /// </summary>
    /// <param name = "_accountId">
    /// The bank account to find the oldest transaction date for.
    /// </param>
    /// <returns>
    /// The date of the oldest transaction for the given bank account.
    /// </returns>
    public static TransDate findDateOfOldestTransaction(CompanyBankAccountId _accountId)
    {
        BankAccountTrans bankAccountTrans;

        select firstonly TransDate from bankAccountTrans
            order by TransDate asc
            where bankAccountTrans.AccountId == _accountId;

        return bankAccountTrans.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRelatedCustomerPaymentJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is related to the customer payment journal.
    /// </summary>
    /// <returns>True when a customer payment journal is related to this <c>BankAccountTrans</c>.</returns>
    public boolean isRelatedCustomerPaymentJournal()
    {
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTable ledgerJournalTable;
        boolean isRelatedCustomerPaymentJournal;

        if (this.SourceTableId == tableNum(LedgerJournalTrans))
        {
            select firstonly ledgerJournalTrans
                where ledgerJournalTrans.Recid == this.SourceRecId
            join JournalType from ledgerJournalTable
                where ledgerJournalTable.JournalNum == ledgerJournalTrans.JournalNum;

            if (ledgerJournalTable.JournalType == LedgerJournalType::CustPayment)
            {
                isRelatedCustomerPaymentJournal = true;
            }
        }

        return isRelatedCustomerPaymentJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankTransClearedDates</Name>
				<Source><![CDATA[
    internal static void updateBankTransClearedDates(TransDate _clearedDate, RefRecId _bankDocumentTableRecId)
    {
        BankDocumentTable documentTable = BankDocumentTable::find(_bankDocumentTableRecId);

        BankAccountTrans bankAccountTrans;

        switch (documentTable.BankDocumentBookType)
        {
            case BankDocumentBookType::Cheque:
            case BankDocumentBookType::DepositSlip:
            case BankDocumentBookType::VendPayment:
            case BankDocumentBookType::CustPayment:
            case BankDocumentBookType::DepositSlipCancel:
                bankAccountTrans = BankAccountTrans::findBySource(documentTable.SourceRelationType, documentTable.SourceRecId);
                if (bankAccountTrans)
                {
                    bankAccountTrans.updateClearedDate(_clearedDate);
                }
                break;

            case BankDocumentBookType::Others:
                if (documentTable.SourceRelationType == tableNum(BankAccountTrans))
                {
                    bankAccountTrans = BankAccountTrans::findByRecId_CN(documentTable.SourceRecId);
                    if (bankAccountTrans)
                    {
                        bankAccountTrans.updateClearedDate(_clearedDate);
                    }
                }
                break;

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateClearedDate</Name>
				<Source><![CDATA[
    internal void updateClearedDate(TransDate _clearedDate)
    {
        ttsbegin;

        this.selectForUpdate(true);
        this.ClearedDate = _clearedDate;
        this.update();

        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Bank</ConfigurationKey>
	<DeveloperDocumentation>@SYS127008</DeveloperDocumentation>
	<FormRef>BankAccountTrans</FormRef>
	<Label>@SYS23684</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>AccountId</TitleField1>
	<TitleField2>Voucher</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>AcctTransDate</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Bank</Modules>
	<PrimaryIndex>AcctTransDate</PrimaryIndex>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AcknowledgementDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankTransCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankTransAmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountReportingCurrency</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AccountStatement</Name>
			<Label>@SYS14680</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountStatementDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountStatement</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Amount</Name>
			<Label>@SYS12227</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountReportingCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankTransCurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankTransAmountCur</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Bank</Name>
			<Label>@SYS7439</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Manual</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Correction</Name>
			<Label>@SYS4768</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AmountCorrect</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dates</Name>
			<Label>@SYS80293</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AcknowledgementDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimension</Name>
			<Label>@SYS342338</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Ledger</Name>
			<Label>@SYS13356</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>LedgerTxt_RU</Name>
			<Label>@SYS24697</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>NotificationToTheCentralBank_LV</Name>
			<Label>@GLS113218</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CentralBankPurposeText_LV</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CentralBankPurposeCode_LV</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CorrespondentCountry_LV</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankPaymentRegistrationNum_LV</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@SYS9039</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymReference</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DepositNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ChequeNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCur</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountMST</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountReportingCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Reconciled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>displayBankCashDueAnnouncement_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ClearedDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SummarizationId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Payment</Name>
			<Label>@SYS828</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymentMode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymReference</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ChequeNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DepositNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SummarizationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>displayBankCashDueAnnouncement_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reason</Name>
			<Label>@SYS107174</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReasonRefRecID</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reconciled</Name>
			<Label>@SYS22247</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Included</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Reconciled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RefRecId_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTax</Name>
			<Label>@SYS75137</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroup</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Status</Name>
			<Label>@SYS80127</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Cancel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CancelPending</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Voucher</Name>
			<Label>@SYS12371</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencyCode</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<HelpText>@Bank:CurrencyCodeHelpText</HelpText>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AccountingCurrencyAmountCorrect_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountStatement</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankAccountStatementNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>AccountStatementDate</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS26785</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>AcknowledgementDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AcknowledgementDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AmountCorrect</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@SYS28655</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<HelpText>@GLS221287</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AmountMST</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMST</ExtendedDataType>
			<HelpText>@SYS84859</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankPaymentRegistrationNum_LV</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>LV</CountryRegionCodes>
			<ExtendedDataType>LvBankPaymentRegistrationNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>BankTransAmountCur</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankTransAmountCur</ExtendedDataType>
			<HelpText>@SYS23187</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankTransCurrencyCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankTransCurrencyCode</ExtendedDataType>
			<HelpText>@SYS153369</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankTransType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankTransactionType</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Cancel</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS4412</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CancelPending</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS114141</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CentralBankPurposeCode_LV</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>LV</CountryRegionCodes>
			<ExtendedDataType>BankCentralBankPurposeCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CentralBankPurposeText_LV</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>LV</CountryRegionCodes>
			<ExtendedDataType>BankCentralBankPurposeText</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ChequeNum</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankChequeNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CorrespondentCountry_LV</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>LV</CountryRegionCodes>
			<ExtendedDataType>LVCorrespondentCountry</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionValueSet</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DepositNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankDepositNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Included</Name>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS50993</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsSummarization</Name>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionDefaultAccount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>LedgerTransType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS11115</Label>
			<EnumType>LedgerTransType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Manual</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS77405</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymentMode</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymMode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymReference</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymReference</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ReasonRefRecID</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ReasonRefRecID</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Reconciled</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS22247</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>RefRecId_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS22569</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ReportingCurrencyAmount_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU,LT,LV,EE,CZ</CountryRegionCodes>
			<ExtendedDataType>AmountMSTSecondary</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ReportingCurrencyAmountCorrect_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>AmountMSTSecondary</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceRecId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>SourceTableId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefTableId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SummarizationId</Name>
			<ExtendedDataType>BankTransSummarizationID</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxGroup</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxItemGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxItemGroup</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>TransDate</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Txt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransactionTextLarge</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Voucher</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Voucher</ExtendedDataType>
			<Label>@SYS12336</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AmountReportingCurrency</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMSTSecondary</ExtendedDataType>
			<HelpText>@SYS53088</HelpText>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ClearedDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<FeatureClass>BankBridgingVendorTransactionDetailsFeature</FeatureClass>
			<Label>@CashManagement:ClearedDate</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchRateMST</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyExchangeRate</ExtendedDataType>
			<HelpText>@Bank:ExchRateMSTHelpText</HelpText>
			<Label>@SYS4955</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchRateRep</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyExchangeRate</ExtendedDataType>
			<HelpText>@Bank:ExchRateRepHelpText</HelpText>
			<Label>@SYS4955</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>VoucherDateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Voucher</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransDate</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LedgerDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>LedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DefaultDimensionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>DefaultDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>AcctCurrAmtIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>AccountId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CurrencyCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AmountCur</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AmountMST</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AmountCorrect</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>AcctTransDate</Name>
			<Fields>
				<AxTableIndexField>
					<DataField>AccountId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransDate</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PaymRefIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>PaymReference</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DepositNumIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>DepositNum</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SourceRecidIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceRecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>SourceTableId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Cancel</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ChequeIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>AccountId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ChequeNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Cancel</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AmountCur</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ClearedDate</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ClearedDateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ClearedDate</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>BankDocumentTableMap</MappingTable>
			<Connections />
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation>
			<Name>BankAccountStatement</Name>
			<EntityRelationshipRole>@SYS127009</EntityRelationshipRole>
			<RelatedTable>BankAccountStatement</RelatedTable>
			<RelatedTableRole>BankAccountStatement</RelatedTableRole>
			<RelationshipType>Link</RelationshipType>
			<Role>BankAccountTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountId</Name>
					<Field>AccountId</Field>
					<RelatedField>AccountId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankAccountTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankAccountTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Composition</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountId</Name>
					<SourceEDT>CompanyBankAccountId</SourceEDT>
					<Field>AccountId</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankAccountTrans_RecId_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>BankAccountTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankAccountTrans_RecId_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefRecId_RU</Name>
					<Field>RefRecId_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankChequeTable</Name>
			<EntityRelationshipRole>@SYS127011</EntityRelationshipRole>
			<RelatedTable>BankChequeTable</RelatedTable>
			<RelatedTableRole>BankChequeTable</RelatedTableRole>
			<RelationshipType>Link</RelationshipType>
			<Role>BankAccountTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ChequeNum</Name>
					<Field>ChequeNum</Field>
					<RelatedField>ChequeNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountId</Name>
					<Field>AccountId</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankDeposit</Name>
			<RelatedTable>BankDeposit</RelatedTable>
			<RelationshipType>Link</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DepositNum</Name>
					<Field>DepositNum</Field>
					<RelatedField>DepositNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankDocumentTableView</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>BankDocumentTableView</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceTableId</Name>
					<Field>SourceTableId</Field>
					<RelatedField>SourceRelationType</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceRecId</Name>
					<Field>SourceRecId</Field>
					<RelatedField>SourceRecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankTransType</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankTransType</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankTransType</Name>
					<SourceEDT>BankTransactionType</SourceEDT>
					<Field>BankTransType</Field>
					<RelatedField>BankTransType</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TransType</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CentralBankPurposeCode_LV</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankCentralBankPurpose</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CentralBankPurposeCode_LV</Name>
					<SourceEDT>BankCentralBankPurposeCode</SourceEDT>
					<Field>CentralBankPurposeCode_LV</Field>
					<RelatedField>Code</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CorrespondentCountry_LV</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LogisticsAddressCountryRegion</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CorrespondentCountry_LV</Name>
					<SourceEDT>LVCorrespondentCountry</SourceEDT>
					<Field>CorrespondentCountry_LV</Field>
					<RelatedField>CountryRegionId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CountryRegionIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency_BankTransCurrencyCode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Currency_BankTransCurrencyCode</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankTransCurrencyCode</Name>
					<SourceEDT>BankTransCurrencyCode</SourceEDT>
					<Field>BankTransCurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency_CurrencyCode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>Currency_CurrencyCode</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CurrencyCode</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>CurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DefaultDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimension</Name>
					<Field>LedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ReasonRef</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS127012</EntityRelationshipRole>
			<RelatedTable>ReasonTableRef</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ReasonRef</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BankAccountTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReasonRefRecID</Name>
					<SourceEDT>ReasonRefRecID</SourceEDT>
					<Field>ReasonRefRecID</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxGroup</Name>
					<SourceEDT>TaxGroup</SourceEDT>
					<Field>TaxGroup</Field>
					<RelatedField>TaxGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxItemGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxItemGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxItemGroup</Name>
					<SourceEDT>TaxItemGroup</SourceEDT>
					<Field>TaxItemGroup</Field>
					<RelatedField>TaxItemGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxItemGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankTransSummarizationLine</Name>
			<RelatedTable>BankTransSummarizationLine</RelatedTable>
			<RelationshipType>Link</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SummarizationId</Name>
					<Field>SummarizationId</Field>
					<RelatedField>SummarizationId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountId</Name>
					<Field>AccountId</Field>
					<RelatedField>AccountId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>