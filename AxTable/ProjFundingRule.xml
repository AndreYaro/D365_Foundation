<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjFundingRule</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ProjFundingRule extends common
{

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkActivityNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the activity number that is used in the record is valid.
    /// </summary>
    /// <returns>
    /// true if the activity number exists and is valid for the project; otherwise, false.
    /// </returns>
    private boolean checkActivityNumber()
    {
        boolean retValue = true;
        RecId   projRecId;

        // Validate the activity number in ProjActivity table
        retValue = ProjActivity::exist(this.ActivityNumber);

        // ProjId required for using activities
        if (retValue && !this.ProjId)
        {
            retValue = false;
        }

        // Validate activity is associated to the project
        if (retValue)
        {
            projRecId = ProjTable::find(this.ProjId).RecId;
            if (smmActivityParentLinkTable::findByActivityAndParent(this.ActivityNumber, smmActivityParentType::Project, projRecId, tableNum(ProjTable)).RecId == 0)
            {
                retValue = false;
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCategoryGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the category group used in the record is valid.
    /// </summary>
    /// <returns>
    /// true if the category group is valid; otherwise, false.
    /// </returns>
    protected boolean checkCategoryGroupId()
    {
        ProjCategoryType    projCategoryType;
        boolean             retValue = true;

        if (this.ValidFor == ProjAllTrxType::All && this.CategoryGroupId)
        {
            retValue = false;
        }

        if (retValue && this.CategoryGroupId)
        {
            projCategoryType = ProjCategoryGroup::find(this.CategoryGroupId).CategoryType;
            switch (projCategoryType)
            {
                case ProjCategoryType::Cost :
                    if (this.ValidFor != ProjAllTrxType::Expenses)
                    {
                        retValue = false;
                    }
                    break;

                case ProjCategoryType::Hour :
                    if (this.ValidFor != ProjAllTrxType::Hours)
                    {
                        retValue = false;
                    }
                    break;

                case ProjCategoryType::Item :
                    if (this.ValidFor != ProjAllTrxType::Items)
                    {
                        retValue = false;
                    }
                    break;

                case ProjCategoryType::Revenue :
                    if (this.ValidFor != ProjAllTrxType::Fees)
                    {
                        retValue = false;
                    }
                    break;

                default:
                    retValue = false;
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCategoryId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the category used in the record is valid.
    /// </summary>
    /// <returns>
    /// true if the category is valid; otherwise, false.
    /// </returns>
    protected boolean checkCategoryId()
    {
        ProjCategoryType    projCategoryType;
        boolean             retValue = true;

        if (this.ValidFor == ProjAllTrxType::All && this.CategoryId)
        {
            retValue = false;
        }

        if (retValue && this.CategoryId)
        {
            projCategoryType = ProjCategory::find(this.CategoryId).CategoryType;
            switch (projCategoryType)
            {
                case ProjCategoryType::Cost :
                    if (this.ValidFor != ProjAllTrxType::Expenses)
                    {
                        retValue = false;
                    }
                    break;

                case ProjCategoryType::Hour :
                    if (this.ValidFor != ProjAllTrxType::Hours)
                    {
                        retValue = false;
                    }
                    break;

                case ProjCategoryType::Item :
                    if (this.ValidFor != ProjAllTrxType::Items)
                    {
                        retValue = false;
                    }
                    break;

                case ProjCategoryType::Revenue :
                    if (this.ValidFor != ProjAllTrxType::Fees)
                    {
                        retValue = false;
                    }
                    break;

                default:
                    retValue = false;
            }
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(ProjFundingRule, ValidFor) :
                if (this.ValidFor == ProjAllTrxType::All)
                {
                    this.CategoryGroupId = '';
                    this.CategoryId = '';
                }

                if ((this.ValidFor != ProjAllTrxType::All) && this.CategoryGroupId)
                {
                    if (!this.checkCategoryGroupId())
                    {
                        this.CategoryGroupId = '';
                        this.CategoryId = '';
                    }
                }

                if ((this.ValidFor != ProjAllTrxType::All) && this.CategoryId)
                {
                    if (!this.checkCategoryId())
                    {
                        this.CategoryId = '';
                    }
                }

                if ((this.ValidFor != ProjAllTrxType::All) && this.ItemId)
                {
                    if (this.ValidFor != ProjAllTrxType::Items)
                    {
                        this.ItemId = '';
                    }
                }

                if ((this.ValidFor != ProjAllTrxType::All) && this.Resource)
                {
                    if (this.ValidFor == ProjAllTrxType::Items)
                    {
                        this.Resource = 0;
                    }
                }
                break;

            case fieldNum(ProjFundingRule, CategoryGroupId) :
                if (!this.checkCategoryGroupId())
                {
                    this.CategoryGroupId = '';
                    this.CategoryId = '';
                }
                else
                {
                    if (this.CategoryGroupId == '')
                    {
                        this.CategoryId = '';
                    }
                }
                break;

            case fieldNum(ProjFundingRule, CategoryId) :
                if (!this.checkCategoryId())
                {
                    this.CategoryId = '';
                }
                else
                {
                    // Always update the Category Group to match that of the Category.
                    this.CategoryGroupId = ProjCategory::find(this.CategoryId).CategoryGroupId;
                }
                break;

            case fieldNum(ProjFundingRule, ProjId) :
                if (!this.ProjId)
                {
                    this.ActivityNumber = '';
                }
                else
                {
                    if (this.ActivityNumber)
                    {
                        if (!this.checkActivityNumber())
                        {
                            this.ActivityNumber = '';
                        }
                    }
                }
                break;

            default :
        }

        this.updateSearchKey();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSearchKey</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates an internal field on the record which is used to improve record retrieval based on the search criteria defined.
    /// </summary>
    /// <param name="projFundingSearchMap">
    ///    The map which contains <c>ProjFundingSearchCriteria</c> values.
    /// </param>
    public void updateSearchKey(Map projFundingSearchMap = null)
    {
        const int   numSearchItems = 7;
        int64       searchKey = 0;
        int         priorityOrder;
        int         factor;
        boolean     priorityFirst = true;
        int         priorityFieldOffset = 0;

        priorityOrder = projFundingSearchMap ? any2int(projFundingSearchMap.lookup(ProjFundingSearchCriteria::Priority))
                                 : ProjFundingSearchParameter::findSearchCriteria(ProjFundingSearchCriteria::Priority).Priority;

        if (priorityOrder != 0)
        {
            priorityFirst =  false;
            priorityFieldOffset = 1;
        }

        //Trans type
        priorityOrder = projFundingSearchMap ? any2int(projFundingSearchMap.lookup(ProjFundingSearchCriteria::TransactionType ))
                                 : ProjFundingSearchParameter::findSearchCriteria(ProjFundingSearchCriteria::TransactionType).Priority;

        priorityOrder = numSearchItems - 1 - priorityOrder - priorityFieldOffset;

        factor = priorityOrder * 2;

        if (this.checkTransactionType())
        {
            searchKey += any2Int64(power(10, factor));
        }

        //Category group
        priorityOrder = projFundingSearchMap ? any2int(projFundingSearchMap.lookup( ProjFundingSearchCriteria::CategoryGroup ))
                                 : ProjFundingSearchParameter::findSearchCriteria(ProjFundingSearchCriteria::CategoryGroup).Priority;

        priorityOrder = numSearchItems - 1 - priorityOrder - priorityFieldOffset;

        factor = priorityOrder * 2;

        if (this.CategoryGroupId != "")
        {
            searchKey += any2Int64(power(10, factor));
        }

        //category
        priorityOrder = projFundingSearchMap ? any2int(projFundingSearchMap.lookup( ProjFundingSearchCriteria::Category ))
                                 : ProjFundingSearchParameter::findSearchCriteria(ProjFundingSearchCriteria::Category).Priority;

        priorityOrder = numSearchItems - 1 - priorityOrder - priorityFieldOffset;

        factor = priorityOrder * 2;

        if (this.CategoryId != "")
        {
            searchKey += any2Int64(power(10, factor));
        }

        //Project
        priorityOrder = projFundingSearchMap ? any2int(projFundingSearchMap.lookup( ProjFundingSearchCriteria::Project ))
                                 : ProjFundingSearchParameter::findSearchCriteria(ProjFundingSearchCriteria::Project).Priority;

        priorityOrder = numSearchItems - 1 - priorityOrder - priorityFieldOffset;

        factor = priorityOrder * 2;

        if (this.ProjId != "")
        {
            searchKey += any2Int64(power(10, factor));
        }

        //Activity
        priorityOrder = projFundingSearchMap ? any2int(projFundingSearchMap.lookup( ProjFundingSearchCriteria::Activity ))
                                 : ProjFundingSearchParameter::findSearchCriteria(ProjFundingSearchCriteria::Activity).Priority;

        priorityOrder = numSearchItems - 1 - priorityOrder - priorityFieldOffset;

        factor = priorityOrder * 2;

        if (this.ActivityNumber != "")
        {
            searchKey += any2Int64(power(10, factor));
        }

        //Empl/Item
        priorityOrder = projFundingSearchMap ? any2int(projFundingSearchMap.lookup(ProjFundingSearchCriteria::EmplItem ))
                                 : ProjFundingSearchParameter::findSearchCriteria(ProjFundingSearchCriteria::EmplItem).Priority;

        priorityOrder = numSearchItems - 1 - priorityOrder - priorityFieldOffset;

        factor = priorityOrder * 2;

        //empl and item can never be both filled in, so the order wrt each other doesn't matter
        //arbitrarily, we make item more important than employee
        if (this.Resource != 0)
        {
            searchKey += any2Int64(power(10, factor));
        }

        if (this.ItemId != "")
        {
            searchKey += any2Int64(power(10, (factor + 1)));
        }

        //priority
        if (priorityFirst)
        {
            searchKey += any2Int64(power(10, (numSearchItems - 1) * 2) * (99 - this.Priority)); //priority is guaranteed to be 0-99, so 2 digits suffice
        }
        else
        {
            searchKey = searchKey * 100; //shift left by 2 to make room
            searchKey += (99 - this.Priority);
        }

        this.PriorityKey = searchKey;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean ret = true;

        switch (_fieldIdToCheck)
        {
            case fieldNum(ProjFundingRule, Resource) :
                if (this.Resource && !ResourceFacade::exist(this.Resource))
                {
                    ret = checkFailed("@Res:ResourceDoesNotExist");
                }
                ret = ret && ResourceFacade::checkResourceIsInCurrentCompany(this.Resource);
                break;

            case fieldNum(ProjFundingRule, ItemId) :
                if (this.ItemId && !InventTable::exist(this.ItemId))
                {
                    ret = checkFailed("@SYS133447");
                }
                break;
        }

        if (ret)
        {
            ret = super(_fieldIdToCheck);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        ProjTable   projTable;
        boolean ret;

        ret = super();

        if (ret && this.ContractId)
        {
            if (!ProjInvoiceTable::exist(this.ContractId))
            {
                ret = checkFailed("@SYS133437");
            }
        }

        if (ret && this.ProjId)
        {
            projTable = ProjTable::find(this.ProjId);
            if (!projTable)
            {
                ret = checkFailed("@SYS133438");
            }

            if (ret && projTable.ProjInvoiceProjId != this.ContractId)
            {
                ret = checkFailed(strFmt("@SYS133439", this.ProjId));
            }
        }

        if (ret && this.ActivityNumber)
        {
            if (!ProjActivity::exist(this.ActivityNumber))
            {
                ret = checkFailed("@SYS133440");
            }

            // Project is required to be used with activities
            if (ret && !this.ProjId)
            {
                ret = checkFailed("@SYS133441");
            }

            // Activity not part of the project
            if (ret && smmActivityParentLinkTable::findByActivityAndParent(this.ActivityNumber, smmActivityParentType::Project, ProjTable::find(this.ProjId).RecId, tableNum(ProjTable)).RecId == 0)
            {
                ret = checkFailed("@SYS133442");
            }
        }
        if (ret && this.CategoryGroupId)
        {
            if (!ProjCategoryGroup::exist(this.CategoryGroupId))
            {
                ret = checkFailed("@SYS133443");
            }
        }

        if (ret && this.CategoryId)
        {
            if (!ProjCategory::exist(this.CategoryId))
            {
                ret = checkFailed("@SYS133444");
            }

            if (ret && this.CategoryGroupId)
            {
                if (ProjCategory::find(this.CategoryId).CategoryGroupId != this.CategoryGroupId)
                {
                    ret = checkFailed(strFmt("@SYS133443", this.CategoryId, this.CategoryGroupId));
                }
            }
        }

        if (ret && this.Resource)
        {
            if (!ResourceFacade::exist(this.Resource))
            {
                ret = checkFailed("@Res:ResourceDoesNotExist");
            }
            if ((this.ValidFor == ProjAllTrxType::Items) ||
                (this.ValidFor == ProjAllTrxType::Revenues))
            {
                ret = checkFailed("@Res:ResourceIsNotValidAssociation");
            }
        }

        if (ret && this.ItemId)
        {
            if (!InventTable::exist(this.ItemId))
            {
                ret = checkFailed("@SYS133447");
            }

            if ((this.ValidFor == ProjAllTrxType::Expenses) ||
                (this.ValidFor == ProjAllTrxType::Fees) ||
                (this.ValidFor == ProjAllTrxType::Hours) ||
                (this.ValidFor == ProjAllTrxType::Revenues))
            {
                ret = checkFailed("@SYS133448");
            }
        }

        if (ret && this.Resource && this.ItemId)
        {
            ret = checkFailed("@Res:ResourceAndItemCantBeInSameRule");
        }

        if (ret && (this.Priority < 1 || this.Priority > 99))
        {
            ret = checkFailed("@SYS133450");
        }

        if (ret && (this.StartDate && this.EndDate))
        {
            if (this.EndDate < this.StartDate)
            {
                ret = checkFailed("@SYS134317");
            }
        }

        ret = ret && ResourceFacade::checkResourceIsInCurrentCompany(this.Resource);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDefaultFundingRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the baseline funding rule for project contracts based on the specified parameters.
    /// </summary>
    /// <param name="_contractID">
    ///     The contract for which the rule will be created.
    /// </param>
    /// <param name="_projFundingSourceRefId">
    ///     The funding source on the contract for which the default rule will be created.
    /// </param>
    /// <remarks>
    ///     If any funding rules already exist on the contract, no action is completed.
    /// </remarks>
    public static void createDefaultFundingRule(ProjInvoiceProjId _contractID, ProjFundingSourceRefId _projFundingSourceRefId)
    {
        ProjFundingRule             projFundingRule;
        ProjFundingRuleAllocation   projFundingAllocation;

        if (_contractID && _projFundingSourceRefId)
        {
            if (ProjFundingRule::numberOfRulesForContract(_contractID) == 0)
            {
                ttsbegin;
                projFundingRule.ContractId = _contractID;
                projFundingRule.ValidFor = ProjFundingRule::defaultTransactionType();
                projFundingRule.Priority = 1;
                projFundingRule.updateSearchKey();
                projFundingRule.insert();

                projFundingAllocation.FundingRule = projFundingRule.RecId;
                projFundingAllocation.FundingSource = _projFundingSourceRefId;
                projFundingAllocation.AllocateRounding = NoYes::Yes;
                projFundingAllocation.AllocationPercentage = 100.00;
                projFundingAllocation.insert();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributeToAllFunders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Distributes allocation percentage equally between all funders.
    /// </summary>
    /// <param name="_fundingRule">
    /// Record ID of a record in <c>ProjFundingRule</c> table.
    /// </param>
    public static void distributeToAllFunders(ProjFundingRuleRefId _fundingRule)
    {
        ProjFundingRuleAllocation   projFundingRuleAllocation;
        int64                       recordCount;
        AmountCur                   distributeRatio;
        AmountCur                   ratioDistributed = 0.0;
        int64                       counter = 0;

        recordCount = (select count(RecId) from projFundingRuleAllocation where projFundingRuleAllocation.FundingRule == _fundingRule).RecId;
        if (recordCount > 0)
        {
            ttsbegin;
            distributeRatio = round((100.00 / recordCount), 0.01);
            while select forupdate projFundingRuleAllocation order by projFundingRuleAllocation.AllocateRounding asc where projFundingRuleAllocation.FundingRule == _fundingRule
            {
                counter += 1;
                if (counter == recordCount)
                {
                    projFundingRuleAllocation.AllocationPercentage = 100.0 - ratioDistributed;
                }
                else
                {
                    projFundingRuleAllocation.AllocationPercentage = distributeRatio;
                    ratioDistributed += distributeRatio;
                }
                projFundingRuleAllocation.update();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified record in the <c>ProjFundingRule</c> table exists.
    /// </summary>
    /// <param name="_recId">
    ///    The record ID of the <c>ProjFundingRule</c> record.
    /// </param>
    /// <returns>
    ///    true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean exist(RecId _recId)
    {
        if (_recId)
        {
            return (select projFundingRule where projFundingRule.RecId == _recId).RecId != 0;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsForContractAndFundingSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a record in <c>ProjFundingRule</c> table exists for the specified contract ID and which
    /// has allocation to the specified funding source.
    /// </summary>
    /// <param name = "_contractID">Contract ID to which the funding rule is associated.</param>
    /// <param name = "_fundingSource">FundingSource RecId to which the funding rule has allocation.</param>
    /// <returns>RecId value for the first matching ProjFundingRule record. 0 if no match was found.</returns>
    public static ProjFundingRuleRefId existsForContractAndFundingSource(ProjInvoiceProjId _contractID, ProjFundingSourceRefId _fundingSource)
    {
        if (!_contractID || !_fundingSource)
        {
            return 0;
        }

        ProjFundingRule projFundingRule;
        ProjFundingRuleAllocation projFundingAllocation;

        select firstonly1 RecId from projFundingRule
            where projFundingRule.ContractId == _contractID
            exists join projFundingAllocation
                where projFundingAllocation.FundingRule == projFundingRule.RecId
                    && projFundingAllocation.FundingSource == _fundingSource;

        return projFundingRule.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfRulesForContractAndFundingSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Counts the number of records in <c>ProjFundingRule</c> table that exist for the specified contract ID and which
    /// have allocation to the specified funding source.
    /// </summary>
    /// <param name = "_contractID">Contract ID to which the funding rule is associated.</param>
    /// <param name = "_fundingSource">FundingSource RecId to which the funding rule has allocation.</param>
    /// <returns>Count of the number matching ProjFundingRule records.</returns>
    public static int numberOfRulesForContractAndFundingSource(ProjInvoiceProjId _contractID, ProjFundingSourceRefId _fundingSource)
    {
        if (!_contractID || !_fundingSource)
        {
            return 0;
        }

        ProjFundingRule projFundingRule;
        ProjFundingRuleAllocation projFundingAllocation;

        select count(RecId) from projFundingRule
            where projFundingRule.ContractId == _contractID
            exists join projFundingAllocation
                where projFundingAllocation.FundingRule == projFundingRule.RecId
                    && projFundingAllocation.FundingSource == _fundingSource;

        return projFundingRule.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>ProjFundingRules</c> table.
    /// </summary>
    /// <param name="_recId">
    ///    The record ID of <c>ProjFundingRule</c> record.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>ProjFundingRule</c> table; otherwise, an empty record.
    /// </returns>
    public static ProjFundingRule find(RecId _recId, boolean _forUpdate = false)
    {
        ProjFundingRule   projFundingRule = null;

        projFundingRule.selectForUpdate(_forUpdate);

        if (_recId)
        {
            select projFundingRule where projFundingRule.RecId == _recId;
        }

        return projFundingRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstByContractId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first ProjFundingRule record, without using an order by, for the specified contract ID.
    /// </summary>
    /// <param name = "_contractId">Contract ID to which the funding rule is associated.</param>
    /// <param name = "_forUpdate">Boolean value indicating whether to read the record for update; optional.</param>
    /// <returns>A record in <c>ProjFundingRule</c> table if found; otherwise, an empty record.</returns>
    public static ProjFundingRule findFirstByContractId(ProjInvoiceProjId _contractId, boolean _forUpdate = false)
    {
        ProjFundingRule   projFundingRule = null;

        projFundingRule.selectForUpdate(_forUpdate);

        if (_contractId)
        {
            select firstonly1 projFundingRule where projFundingRule.ContractId == _contractId;
        }

        return projFundingRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllocationValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the funding rule is 100 percent allocated to funding sources.
    /// </summary>
    /// <param name="_fundingRule">
    /// The funding rule for which the allocation are to be validate.
    /// </param>
    /// <returns>
    /// true if the allocation of funding sources is valid; otherwise, false.
    /// </returns>
    public static boolean isAllocationValid(ProjFundingRuleRefId _fundingRule)
    {
        return ProjFundingRule::percentOfRuleAllocated(_fundingRule) == 100.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRoundingAcctValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the funding rule has a funding source define to handle rounding amounts.
    /// </summary>
    /// <param name="_fundingRule">
    /// The funding rule being processed.
    /// </param>
    /// <returns>
    /// true if one funding source has be defined for rounding amount postings; otherwise, false.
    /// </returns>
    public static boolean isRoundingAcctValid(ProjFundingRuleRefId _fundingRule)
    {
        ProjFundingRuleAllocation  projFundingRuleAllocation;

        return (select sum(AllocateRounding) from projFundingRuleAllocation where projFundingRuleAllocation.FundingRule == _fundingRule).AllocateRounding == 1.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfFundingSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of funding source that is used in allocating amounts by the funding rule.
    /// </summary>
    /// <param name="_fundingRule">
    /// The funding rule being processed.
    /// </param>
    /// <returns>
    /// The number of funding sources for the funding rule.
    /// </returns>
    public static int64 numberOfFundingSources(ProjFundingRuleRefId _fundingRule)
    {
        ProjFundingRuleAllocation   projFundingRuleAllocation;
        int64                       recordCount;

        select count(RecId) from projFundingRuleAllocation where projFundingRuleAllocation.FundingRule == _fundingRule;
        recordCount = projFundingRuleAllocation.RecId;

        return recordCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfRulesForContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of funding rules that are defined for a contract.
    /// </summary>
    /// <param name="_contractId">
    /// The contract being processed.
    /// </param>
    /// <returns>
    /// The number of funding rules that are defined for the contract
    /// </returns>
    public static int64 numberOfRulesForContract(ProjInvoiceProjId _contractId)
    {
        return (select count(RecId) from projFundingRule where projFundingRule.ContractId == _contractId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>percentOfRuleAllocated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the percentage amount that has been allocated to funding sources.
    /// </summary>
    /// <param name="_fundingRule">
    /// The funding rule for which the allocation is to be validated.
    /// </param>
    /// <returns>
    /// The percentage that is allocated to funding sources for the specified funding rule.
    /// </returns>
    public static ProjAllocationPercentage percentOfRuleAllocated(ProjFundingRuleRefId _fundingRule)
    {
        ProjFundingRuleAllocation  projFundingRuleAllocation;

        return (select sum(AllocationPercentage) from projFundingRuleAllocation where projFundingRuleAllocation.FundingRule == _fundingRule).AllocationPercentage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetAllocationToSingleFundingSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all existing allocation of the current rule and re-allocates 100% to
    /// the specified funding source.
    /// </summary>
    /// <param name="_fundingSource">The funding source this rule will be re-allocated to.</param>
    public void resetAllocationToSingleFundingSource(ProjFundingSourceRefId _fundingSource)
    {
        ttsbegin;

        ProjFundingRuleAllocation projFundingAllocationDelete;
        delete_from projFundingAllocationDelete where projFundingAllocationDelete.FundingRule == this.RecId;

        ProjFundingRuleAllocation projFundingAllocation;
        projFundingAllocation.FundingRule = this.RecId;
        projFundingAllocation.FundingSource = _fundingSource;
        projFundingAllocation.AllocateRounding = NoYes::Yes;
        projFundingAllocation.AllocationPercentage = 100.00;
        projFundingAllocation.insert();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransactionType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the transaction type.
    /// </summary>
    /// <returns>
    ///     true if transaction type is not all; otherwise, false.
    /// </returns>
    protected boolean checkTransactionType()
    {
        return (this.ValidFor != ProjAllTrxType::All);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTransactionType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get the defaults transaction type.
    /// </summary>
    /// <returns>
    ///     The <c>ProjAllTrxType</c> enumeration value.
    /// </returns>
    public static ProjAllTrxType defaultTransactionType()
    {
        return ProjAllTrxType::All;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Project</ConfigurationKey>
	<DeveloperDocumentation>@SYS133009</DeveloperDocumentation>
	<Label>@SYS133004</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>ContractId</TitleField1>
	<TitleField2>ValidFor</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>FoundAndEmpty</CacheLookup>
	<ClusteredIndex>FundingRuleIdx</ClusteredIndex>
	<Modules>ProjectManagementAndAccounting</Modules>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>ProjFundingRuleAllocation</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>ProjFundingRuleAllocation</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ValidFor</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActivityNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Priority</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContractId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EndDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Resource</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS115561</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ValidFor</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActivityNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Priority</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContractId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EndDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StartDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CategoryGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Resource</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ActivityNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjActivityNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CategoryGroupId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryGroupId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CategoryId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContractId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjInvoiceProjId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>EndDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EndDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>Priority</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Priority</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PriorityKey</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjFundRuleSearchKey</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Resource</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ResourceRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>StartDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>StartDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ValidFor</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ProjAllTrxType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Worker</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>ProjWorkerRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>FundingRuleIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ContractId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Priority</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ProjId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ActivityNumber</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValidFor</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CategoryId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CategoryGroupId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Resource</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>EndDate</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>StartDate</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ContractIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ContractId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjFundingRule</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<SourceEDT>ItemId</SourceEDT>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ItemIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjCategory</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjFundingRule</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CategoryId</Name>
					<SourceEDT>ProjCategoryId</SourceEDT>
					<Field>CategoryId</Field>
					<RelatedField>CategoryId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CategoryIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjCategoryGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjCategoryGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjCategoryGroup</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjFundingRule</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CategoryGroupId</Name>
					<SourceEDT>ProjCategoryGroupId</SourceEDT>
					<Field>CategoryGroupId</Field>
					<RelatedField>CategoryGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CategoryGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjInvoiceTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjInvoiceTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjInvoiceTable</RelatedTableRole>
			<RelationshipType>Composition</RelationshipType>
			<Role>ProjFundingRule</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContractId</Name>
					<SourceEDT>ProjInvoiceProjId</SourceEDT>
					<Field>ContractId</Field>
					<RelatedField>ProjInvoiceProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ProjInvoiceIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjFundingRule</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjId</Name>
					<SourceEDT>ProjId</SourceEDT>
					<Field>ProjId</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ProjectIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>Resource</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ResourceView</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Resource</Name>
					<Field>Resource</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>smmActivities</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>smmActivities</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>smmActivities</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjFundingRule</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ActivityNumber</Name>
					<SourceEDT>ProjActivityNumber</SourceEDT>
					<Field>ActivityNumber</Field>
					<RelatedField>ActivityNumber</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ActivityNumberIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>