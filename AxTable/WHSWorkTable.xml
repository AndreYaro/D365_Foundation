<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.ApplicationPlatform.XppServices.Instrumentation;

public class WHSWorkTable extends common
{   
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>unBlockWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unblocks the work.
    /// </summary>
    /// <param name = "_workTable">The work that should be unblocked.</param>
    [Hookable(false)]
    internal static void unBlockWork(WHSWorkTable _workTable)
    {
        if (_workTable.Frozen)
        {
            WHSWorkTable::freezeOrUnfreezeWork(_workTable.WorkId, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unMarkWorkInventTransWorkHasReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmarks <c>WHSWorkInventTrans</c> records that were marked as reserved.
    /// </summary>
    [Hookable(false)]
    internal void unMarkWorkInventTransWorkHasReservation()
    {
        WHSWorkInventTrans workInventTrans;
        workInventTrans.skipDataMethods(true);
        // Remove all the flags that state that work has the reservation
        update_recordset workInventTrans
            setting WorkHasReservation = NoYes::No
                where workInventTrans.WorkId            == this.WorkId
                &&  workInventTrans.WorkHasReservation  == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddToPickingWorkCluster</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work can be added to a work cluster used for cluster picking.
    /// </summary>
    /// <returns>True if the current work can be added to a work cluster used for cluster picking; otherwise, false.</returns>
    public boolean canAddToPickingWorkCluster()
    {
        if (this.canHaveLinkedReplenishmentWork()
            && this.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::IndividualWorkLine
            && this.hasUnFinishedReplenWork())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canExecuteWorkThatNeedsReplenishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work can be executed when there are pending replenishment work.
    /// </summary>
    /// <returns>True if the current work can be executed when there are pending replenishment work; otherwise, false.</returns>
    public boolean canExecuteWorkThatNeedsReplenishment()
    {
        if (this.canHaveLinkedReplenishmentWork())
        {
            return (this.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::IndividualWorkLine);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConsolidatedWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work is consolidated as part of License plate consolidation flow.
    /// </summary>
    /// <returns>True if the work is consolidated; otherwise, false.</returns>
    public boolean isConsolidatedWork()
    {
        if (!WHSSessionCache::consolidatedWorkLinesExist().isConsolidationUsed())
        {
            return false;
        }

        WHSConsolidatedWorkLine consolidatedWorkLine;
        WHSWorkLine             consolidatedToWorkLine;

        select firstonly RecId from consolidatedWorkLine
            exists join consolidatedToWorkLine
                where consolidatedToWorkLine.RecId == consolidatedWorkLine.ConsolidatedWorkLine
                    && consolidatedToWorkLine.WorkId == this.WorkId;

        return consolidatedWorkLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastConsolidatedWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the last work in which the current work line was consolidated to.
    /// </summary>
    /// <param name="_workLineInOriginWork">
    /// The work line which is part of the origin work table.
    /// </param>
    /// <returns>The work table in which the work line was finally consolidated to.</returns>
    public static WHSWorkTable findLastConsolidatedWork(WHSWorkLine _workLineInOriginWork)
    {
        if (!WHSSessionCache::consolidatedWorkLinesExist().isConsolidationUsed())
        {
            WHSWorkTable notFound;
            return notFound;
        }

        return WHSWorkTable::find(WHSConsolidatedWorkLine::findLastConsolidatedWorkLineByOriginWorkLine(
                                  WHSConsolidatedWorkLine::findOriginWorkLineWithinWork(_workLineInOriginWork)).workId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkQualityOrderDocumentBlocking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the quality association document blocking policy should be triggered.
    /// </summary>
    /// <param name="_workLine">
    /// A specified <c>WHSWorkLine</c> record
    /// </param>
    public void checkQualityOrderDocumentBlocking(WHSWorkLine  _workLine)
    {
        Common  sourceDocumentLine;

        if (this.WorkTransType == WHSWorkTransType::Sales)
        {
            sourceDocumentLine = WHSInvent::getCommonFromWorkTransType(this.WorkTransType, _workLine.InventTransId);

            if (sourceDocumentLine is SalesLine)
            {
                InventQualityManagementBlockHandler::blockSalesPickingList(sourceDocumentLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>countFirstPicks</Name>
				<Source><![CDATA[
    public int countFirstPicks()
    {
        WHSWorkLine     workLine;
        boolean         havePick;
        int             numPicks;

        while select WorkType from workLine
            where workLine.WorkId == this.WorkId
        {
            if (!havePick && workLine.WorkType == WHSWorkType::Pick)
            {
                havePick = true;
            }

            if (havePick && workLine.WorkType != WHSWorkType::Pick)
            {
                break;
            }

            if (workLine.WorkType == WHSWorkType::Pick)
            {
                ++numPicks;
            }
        }

        return numPicks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayClusterPosition</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the cluster position.
    /// </summary>
    /// <returns>
    ///     The cluster position.
    /// </returns>
    display WHSClusterPosition displayClusterPosition()
    {
        WHSWorkClusterLine whsWorkClusterLine;
        WHSWorkClusterTable whsWorkClusterTable;

        select firstonly ClusterPosition from whsWorkClusterLine
            where whsWorkClusterLine.WorkId == this.WorkId
            exists join WHSWorkClusterTable
                where whsWorkClusterTable.ClusterId == whsWorkClusterLine.ClusterId
                   && whsWorkClusterTable.WorkClusterStatus != WHSWorkClusterStatus::Closed;

        return whsWorkClusterLine.ClusterPosition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalVolume</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the total volume.
    /// </summary>
    /// <returns>
    ///     The total volume.
    /// </returns>
    display Volume displayTotalVolume()
    {
        Volume      volume;
        WHSWorkLine workLine;
        WHSWorkLine putWorkLine;
        InventTable inventTable;

        select firstonly InventQtyWork,ItemId,LineNum,WorkId from putWorkLine
            order by putWorkLine.LineNum
            where putWorkLine.WorkId    == this.WorkId
                && putWorkLine.WorkType == WHSWorkType::Put;

        while select workLine
            join ItemId, UnitVolume from inventTable
            where workLine.LineNum    <  putWorkLine.LineNum
                && workLine.WorkId    == this.WorkId
                && inventTable.ItemId == workLine.ItemId
                && workLine.WorkType == WHSWorkType::Pick
        {
            volume += workLine.InventQtyWork * inventTable.UnitVolume;
        }

        return volume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTotalWeight</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays the total weight.
    /// </summary>
    /// <returns>
    ///     The total weight.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display Weight displayTotalWeight()
    {
        Weight      weight;
        WHSWorkLine workLine;
        WHSWorkLine putWorkLine;
        InventTable inventTable;

        select firstonly LineNum from putWorkLine
            order by putWorkLine.LineNum
            where putWorkLine.WorkId    == this.WorkId
                && putWorkLine.WorkType == WHSWorkType::Put;

        while select workLine
            join ItemId, NetWeight, TaraWeight from inventTable
            where workLine.LineNum    <  putWorkLine.LineNum
                && workLine.WorkId    == this.WorkId
                && inventTable.ItemId == workLine.ItemId
                && workLine.WorkType == WHSWorkType::Pick
        {
            weight += workLine.InventQtyWork * inventTable.grossWeight();
        }

        return weight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFinalPutLocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the final put location.
    /// </summary>
    /// <returns>
    ///     The final put location.
    /// </returns>
    public WMSLocationId getFinalPutLocation()
    {
        WHSWorkLine workLine;

        select firstonly wmsLocationId from workLine
            order by workLine.LineNum desc
            where workLine.WorkId == this.WorkId
                && workLine.WorkStatus != WHSWorkStatus::Cancelled
                && workLine.WorkStatus != WHSWorkStatus::Combined
                && workline.WorkType == WHSWorkType::Put;
        
        return workLine.wmsLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUnFinishedReplenWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the selected work order has pending replenishment work.
    /// </summary>
    /// <returns>True, if there is pending replenishment; otherwise, false.</returns>
    public boolean hasUnFinishedReplenWork()
    {
        if (this.canHaveLinkedReplenishmentWork())
        {
            WHSWorkLine demandWorkLine;

            select firstonly RecId from demandWorkLine
                where demandWorkLine.WorkId == this.WorkId
                    && demandWorkLine.WorkType == WHSWorkType::Pick
                    && demandWorkLine.WorkStatus == WHSWorkStatus::Open
                    && demandWorkLine.ReplenDemand == NoYes::Yes;

            if (demandWorkLine.RecId != 0)
            {
                return true;
            }

            WHSReplenWorkLink   replenWorkLink;
            WHSWorkTable        replenishmentWorkTable;

            select RecId from replenWorkLink
                where replenWorkLink.DemandWorkId == this.WorkId
            join tableid from replenishmentWorkTable
                where replenishmentWorkTable.WorkId      == replenWorkLink.ReplenWorkId
                    && replenishmentWorkTable.WorkStatus != WHSWorkStatus::Closed
                    && replenishmentWorkTable.WorkStatus != WHSWorkStatus::Cancelled
                    && replenishmentWorkTable.WorkStatus != WHSWorkStatus::Combined;

            if (replenWorkLink.RecId != 0)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allInitialPickWorkLinesNeedReplenishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if all initial pick work lines need replenishment
    /// </summary>
    /// <returns>True, if all lines have the Needs Replenishment flag set; otherwise, false.</returns>
    public boolean allInitialPickWorkLinesNeedReplenishment()
    {
        WHSWorkLine workLine;
        WHSWorkLine workLineFirstPut = WHSWorkTable::getFirstPutWorkLine(this.WorkId);

        select firstonly RecId from workLine
            where workLine.WorkId == this.WorkId
                && workLine.LineNum < workLineFirstPut.LineNum
                && workLine.ReplenDemand == NoYes::No;

        return workLine.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allInitialPickWorkLinesSkipped</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if all first pick lines are skipped.
    /// </summary>
    /// <returns>
    /// Return true if all first pick lines are skipped; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Check if all first pick lines are skipped.
    /// </remarks>
    public boolean allInitialPickWorkLinesSkipped()
    {
        WHSWorkLine     workLine;
        WHSWorkLine     workLineFirstPut = WHSWorkTable::getFirstPutWorkLine(this.WorkId);
        
        select firstOnly RecId from workLine
            where workLine.WorkId      == this.WorkId
                && workLine.LineNum    <  workLineFirstPut.LineNum
                && workLine.WorkType   == WHSWorkType::Pick
                && workLine.WorkStatus <  WHSWorkStatus::Skipped
                && workLine.Skipped    == NoYes::No;
        
        return !workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertMandatoryFieldsNotBlank</Name>
				<Source><![CDATA[
    private void assertMandatoryFieldsNotBlank()
    {
        WHSMandatoryFieldValidator::assertNotBlank(this, fieldNum(WHSWorkTable, WorkId));
        WHSMandatoryFieldValidator::assertNotBlank(this, fieldNum(WHSWorkTable, InventLocationId));
        WHSMandatoryFieldValidator::assertNotBlank(this, fieldNum(WHSWorkTable, InventSiteId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        this.validateWorkStatus();
        
        ttsbegin;
        this.WorkPriority = this.WorkPriority ? this.WorkPriority : WHSParameters::find().WorkPriority;
        this.InventoryTransactionMechanism = WHSInventoryTransactionConfigurationProvider::chooseAppropriateTransactionMechanism(this);
        super();
        this.assertMandatoryFieldsNotBlank();

        if (this.WorkStatus == WHSWorkStatus::Closed)
        {
            this.postClosed();
        }

        if (this.WorkStatus == WHSWorkStatus::Cancelled)
        {
            this.postCancelled();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReplenDemand</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if this <c>WHSWorkTable</c> is a replenishment demand.
    /// </summary>
    /// <returns>
    ///     true if it is a replenishment demand; otherwise, false.
    /// </returns>
    boolean isReplenDemand()
    {
        return (select firstonly whsReplenWorkLink
                    where whsReplenWorkLink.ReplenWorkId == this.WorkId).RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkTransTypeOutbound</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work trans type is outbound
    /// </summary>
    /// <returns>
    /// true, if the work is of an outbound work trans type; otherwise, false
    /// </returns>
    public boolean isWorkTransTypeOutbound()
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(this.WorkTransType);
            
        if (workTransactionType)
        {
            return workTransactionType.isOutbound();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveLinkedReplenishmentWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work can have replenishment.
    /// </summary>
    /// <returns>
    /// true, if the work can have replenishment; otherwise, false
    /// </returns>
    public boolean canHaveLinkedReplenishmentWork()
    {
        return WhsWorkTransactionType::singletonFromTypeOrDefault(this.WorkTransType).isReplenishmentAllowed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickAllInventoryForWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Picks all of the inventory for the associated work.
    /// </summary>
    public void pickAllInventoryForWork()
    {
        WHSClosedOutboundWorkProcessorFactory::newDefault(this).process(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOutboundSortRFInstruction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates outbound sort instructions for the work.
    /// </summary>
    [Hookable(false)]
    internal void createOutboundSortRFInstruction()
    {
        WHSOutboundSortRFInstruction::createNewFromWork(this.WorkId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceInventoryTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates source inventory transactions.
    /// </summary>
    /// <param name = "_workLine">The workline used for the update.</param>
    /// <param name = "_pickIdAllocator">The pick ID allocator to use when doing the inventory updates.</param>
    [Hookable(false)]
    internal void updateSourceInventoryTransactions(WHSWorkLine _workLine, WhsInventTransPickIdAllocator _pickIdAllocator = null)
    {
        this.checkQualityOrderDocumentBlocking(_workLine);

        if (this.isRawMaterialPick())
        {
            WHSUpdateSourceInventoryTransactionsForRawMaterialPicking  updateSourceInventoryTransactionsForRawMaterialPicking =
                WHSUpdateSourceInventoryTransactionsForRawMaterialPicking::newFromPutWorkLineAndWork(_workLine, this); 
           
            updateSourceInventoryTransactionsForRawMaterialPicking.updateSourceInventoryTransactions();
        }
        else
        {
            WHSWorkPutLineSourceInventoryPickingFactory::newPickingFromPutWorkLine(_workLine).withPickIdAllocator(_pickIdAllocator).pickInventory();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRawMaterialPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work is a raw material pick.
    /// </summary>
    /// <returns>true if the work is a raw material pick; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean isRawMaterialPick()
    {
        return (this.WorkTransType == WHSWorkTransType::ProdPick
            ||  this.WorkTransType == WHSWorkTransType::KanbanPick);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateContainersBasedOnSortPositions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates containers tied to sort work.
    /// </summary>
    /// <param name="_finalPutWMSLocationId">
    /// The final put location of the work being closed.
    /// </param>
    [Hookable(false)]
    internal void updateContainersBasedOnSortPositions(WMSLocationId _finalPutWMSLocationId)
    {
        ttsbegin;
       
        WHSOutboundSortPositionTrans    sortPositionTrans;
        WHSOutboundSortPosition         sortPosition;
        WHSWorkTable                    workTable;

        while select sortPositionTrans
            group by SortIdentifier
                where sortPositionTrans.SortTemplateType == WHSOutboundSortTemplateType::Container
            join RecId from sortPosition
                where sortPosition.RecId == sortPositionTrans.OutboundSortPosition
            join TargetLicensePlateId from workTable
                group by TargetLicensePlateId
                    where workTable.TargetLicensePlateId == sortPosition.LicensePlateId
                    &&    workTable.WorkId == this.WorkId
        {
            WHSContainerTable containerTable = WHSContainerTable::findByContainerId(sortPositionTrans.SortIdentifier, true);
            
            if (containerTable.RecId)
            {
                InventDim containerInventDim        = InventDim::find(containerTable.InventDimId);
                containerInventDim.wmsLocationId    = _finalPutWMSLocationId;
                containerInventDim.LicensePlateId   = workTable.TargetLicensePlateId;
                
                containerInventDim          = InventDim::findOrCreate(containerInventDim);
                containerTable.InventDimId  = containerInventDim.InventDimId;
                
                containerTable.update();
            }
            else
            {
                throw error("@WAX:ErrorUpdatingSortContainerOnWorkTable");
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInbound</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the work is inbound.
    /// </summary>
    /// <returns>
    /// A Boolean value to identify if the work is inbound.
    /// </returns>
    public boolean isInbound()
    {
        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(this.WorkTransType);

        if (workTransactionType)
        {
            return workTransactionType.isInbound();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectDimTrackedWorkline</Name>
				<Source><![CDATA[
    /// <summary>
    /// Selects the first <c>WHSWorkLine</c> record based on the work lines in ascending order for a specific item id if there
    /// is an associated <c>WHSDimTracking</c> record.
    /// </summary>
    /// <param name="_itemId">
    /// The item id for which the work line should be selected.
    /// </param>
    /// <param name="_consumedInventory">
    /// A map which contains the dimension set/qty combinations which have already been picked/reserved by other frozen work
    /// </param>
    /// <returns>
    /// The record searched for.
    /// </returns>
    private WHSWorkLine selectDimTrackedWorkline(ItemId _itemId, Map _consumedInventory)
    {
        WHSDimTracking  dimTracking;
        WHSWorkLine     workLine;

        if (WHSHandleOverPickValidateDimTrackingConsumedQtyFlight::instance().isEnabled()
            && _consumedInventory)
        {
            // The aim of this select is to find a work line
            // that has a related 'overpick' dimtracking
            // which quantity was not yet used for picking/reserving
            // Since dimtracking inventDimId contains 'pick' dimensions, there will be different license plates
            // in case of multiple overpicking
            while select workLine
                order by workLine.LineNum
                where workLine.WorkId   == this.WorkId
                   && workLine.ItemId   == _itemId
            join InventDimId, Qty from dimTracking
                where dimTracking.WorkId    == this.WorkId
                   && dimTracking.LineNum   == workLine.LineNum
                   && dimTracking.InventTransIdParent != workLine.InventTransId
            {
                if (_consumedInventory.exists(dimTracking.InventDimId)
                    && _consumedInventory.lookup(dimTracking.InventDimId) >= dimTracking.Qty)
                {
                    continue;
                }

                return workLine;
            }
        }
        else
        {
            select firstonly workLine
                order by workLine.LineNum
                where workLine.WorkId   == this.WorkId
                &&    workLine.ItemId   == _itemId
            exists join dimTracking
                where dimTracking.WorkId    == this.WorkId
                &&    dimTracking.LineNum   == workLine.LineNum;
        }

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveOverPickTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves inventory for over picked work units.
    /// </summary>
    /// <param name="_itemId">
    /// The item id for which the over pick was done.
    /// </param>
    /// <param name="_movement">
    /// The source document line movement for which dimensions are changed.
    /// </param>
    /// <param name="_reserveQty">
    /// The amount of frozen work quantity we are going to reserve against the production BOM line.
    /// </param>
    /// <param name="_inventDimFrom">
    /// The inventory dimension for the previous reservation.
    /// </param>
    /// <param name="_inventDimTo">
    /// The inventory dimension for new reservation which will just be used when there are no dimensions below license plate.
    /// Otherwise dimensions from the WHSDimTracking table are considered.
    /// </param>
    /// <param name="_reservedInventory">
    /// A map which contains the dimension set/qty combinations which have already been reserved by other frozen work.
    /// </param>
    /// <param name="_allowReservationReduction">
    /// Boolean value, that defines if reservation reduction is allowed.
    /// </param>
    private void reserveOverPickTransaction(
        ItemId              _itemId,
        InventMovement      _movement,
        InventHandlingQty   _reserveQty,
        InventDim           _inventDimFrom,
        InventDim           _inventDimTo,
        Map                 _reservedInventory,
        boolean             _allowReservationReduction)
    {
        ttsbegin;

        // If item has dimensions below License Plate, reference dim tracking records inventory to be picked
        WHSWorkLine workLine = this.selectDimTrackedWorkline(_itemId, _reservedInventory);
        Map         processedInventoryLocal = new Map(Types::String, Types::Real);

        if (workLine.RecId != 0)
        {
            InventHandlingQty   reserveRunningQty = _reserveQty;
            WHSDimTracking      dimTracking;
            InventDim           newInventDim;

            // The over-picking dim tracking records will have a different parent invent trans Id than the work line
            while select InventDimId, Qty from dimTracking
                where dimTracking.WorkId                == this.WorkId
                &&    dimTracking.InventTransIdParent   != workLine.InventTransId
                &&    dimTracking.LineNum               == workLine.LineNum
                join newInventDim
                    where newInventDim.InventDimId == dimTracking.InventDimId
            {
                Qty reservedQty;

                if (_reservedInventory.exists(dimTracking.InventDimId))
                {
                    reservedQty = _reservedInventory.lookup(dimTracking.InventDimId);
                }

                // Check to make sure particular dimension set has not already been reserved by other frozen work
                if (dimTracking.Qty > reservedQty)
                {
                    InventHandlingQty qtyToReserve = min((dimTracking.Qty - reservedQty), reserveRunningQty);

                    newInventDim.wMSLocationId  = _inventDimTo.wMSLocationId;
                    newInventDim.LicensePlateId = _inventDimTo.LicensePlateId;

                    // We need to keep the changed InventDim record in a new variable in order for the while select loop to correctly select the new InventDim record
                    InventDim currentInventDim = InventDim::findOrCreate(newInventDim);

                    if (_allowReservationReduction 
                        && reserveRunningQty <= qtyToReserve)
                    {
                        WHSWorkTable::changeReservedHandlingQuantityDimensionsAllowingReduction(_movement, qtyToReserve, _inventDimFrom, currentInventDim);
                    }
                    else
                    {
                        WHSWorkTable::changeReservedHandlingQuantityDimensions(_movement, qtyToReserve, _inventDimFrom, currentInventDim);
                    }
                    // Update reserved qty map with what we reserved
                    if (reservedQty)
                    {
                        _reservedInventory.insert(dimTracking.InventDimId, reservedQty + qtyToReserve);
                    }
                    else
                    {
                        _reservedInventory.insert(dimTracking.InventDimId, qtyToReserve);
                    }

                    processedInventoryLocal.insert(currentInventDim.inventDimId, qtyToReserve);

                    reserveRunningQty -= qtyToReserve;

                    if (!reserveRunningQty)
                    {
                        break;
                    }
                }
            }
        }
        else
        {
            if (_allowReservationReduction)
            {
                WHSWorkTable::changeReservedHandlingQuantityDimensionsAllowingReduction(_movement, _reserveQty, _inventDimFrom, _inventDimTo);
            }
            else
            {
                WHSWorkTable::changeReservedHandlingQuantityDimensions(_movement, _reserveQty, _inventDimFrom, _inventDimTo);
            }

            processedInventoryLocal.insert(_inventDimTo.inventDimId, _reserveQty);
        }

        ttscommit;
        
        if (_movement.buffer() is ProdBom)
        {
            WHSPostProdJournalFrozenWork postProdJournalFrozenWork = WHSPostProdJournalFrozenWork::construct();
            postProdJournalFrozenWork.parmProdBom(_movement.buffer() as ProdBom);
            postProdJournalFrozenWork.parmProcessedInventory(processedInventoryLocal);
            postProdJournalFrozenWork.createProdPickingJournal();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickOverPickTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method which picks inventory against source document lines for over-picked work units
    /// </summary>
    /// <param name="_common">
    /// The source document line we are picking inventory against
    /// </param>
    /// <param name="_pickQty">
    /// The amount of frozen work quantity we are going to pick against the production BOM line
    /// </param>
    /// <param name="_pickWeight">
    /// The weight of the frozen work quantity.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimension set down to License Plate we are picking against the production BOM line
    /// </param>
    /// <param name="_consumedInventory">
    /// A map which contains the dimension set/qty combinations which have already been picked by other frozen work
    /// </param>
    private void pickOverPickTransaction(
        Common              _common,
        InventHandlingQty   _pickQty,
        WHSHandlingWeight   _pickWeight,
        InventDim           _inventDim,
        Map                 _consumedInventory)
    {
        ProdBOM                 prodBOM;
        KanbanJobPickingList    kanbanJobPickingList;
        ItemId                  itemId;
        Qty                     consumedQty;
        InventDimParm           inventDimParmAboveLocation;
        Map                     processedInventoryLocal = new Map(Types::String, Types::Real);


        ttsbegin;
        
        switch (_common.TableId)
        {
            case tableNum(ProdBOM):
                prodBOM     = _common as ProdBOM;
                itemId      = prodBOM.ItemId;
                break;
            case tableNum(KanbanJobPickingList):
                kanbanJobPickingList    = _common as KanbanJobPickingList;
                itemId                  = kanbanJobPickingList.ItemId;
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        inventDimParmAboveLocation = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(itemId));

        // If item has dimensions below License Plate, reference dim tracking records inventory to be picked
        WHSWorkLine workLine = this.selectDimTrackedWorkline(itemId, _consumedInventory);

        if (workLine.RecId != 0)
        {
            InventHandlingQty pickRunningQty = _pickQty;

            WHSDimTracking  dimTracking;
            InventDim       newInventDim;

            // The over-picking dim tracking records will have a different parent invent trans Id than the work line
            while select InventDimId, Qty from dimTracking
                where dimTracking.InventTransIdParent   != workLine.InventTransId
                &&    dimTracking.WorkId                == this.WorkId
                &&    dimTracking.LineNum               == workLine.LineNum
                join newInventDim
                    where newInventDim.InventDimId == dimTracking.InventDimId
            {
                consumedQty = 0;

                if (_consumedInventory.exists(dimTracking.InventDimId))
                {
                    consumedQty = _consumedInventory.lookup(dimTracking.InventDimId);
                }

                // Check to make sure particular dimension set has not already been consumed by other frozen work
                if (dimTracking.Qty > consumedQty)
                {
                    InventHandlingQty qtyToPick = min((dimTracking.Qty - consumedQty), pickRunningQty);

                    newInventDim.wMSLocationId  = _inventDim.wMSLocationId;
                    newInventDim.LicensePlateId = _inventDim.LicensePlateId;

                    // We need to keep the changed InventDim record in a new variable, in order for the while select loop to correctly select the new InventDim record.
                    InventDim currentInventDim = InventDim::findOrCreate(newInventDim);
                    
                    if (PdsGlobal::pdsIsCWItem(itemId))
                    {
                        WHSHandlingWeight avgWeight = WHSCatchWeightHelper::calculateAverageWeight(qtyToPick, _pickQty, _pickWeight, InventTable::inventDecimals(itemId));
                        
                        if (prodBOM)
                        {
                            WHSPoolProdBOM::updateWithPickListTransactionsHandlingQty(prodBOM.InventTransId, itemId, currentInventDim, qtyToPick, avgWeight, InventLocation::find(this.InventLocationId).WHSRawMaterialPolicy);
                        }
                        else
                        {
                            using (var context = WhsInventPickingContext::newSkipPickIdAllocation())
                            {
                                WHSInvent::pickQuantities(_common, currentInventDim.InventDimId, avgWeight, qtyToPick, inventDimParmAboveLocation, UnknownNoYes::Unknown, true);
                            }
                        }
                    }
                    else
                    {
                        if (prodBOM)
                        {
                            WHSPoolProdBOM::updateWithPickListTransactionsHandlingQty(prodBOM.InventTransId, itemId, currentInventDim, qtyToPick, 0, InventLocation::find(this.InventLocationId).WHSRawMaterialPolicy);
                        }
                        else
                        {
                            using (var context = WhsInventPickingContext::newSkipPickIdAllocation())
                            {
                                WHSInvent::pickQuantities(_common, currentInventDim.InventDimId, qtyToPick, 0, inventDimParmAboveLocation, UnknownNoYes::Unknown, true);
                            }
                        }
                    }

                    // Update consumed qty map with what we picked
                    if (consumedQty)
                    {
                        _consumedInventory.insert(dimTracking.InventDimId, consumedQty + qtyToPick);
                    }
                    else
                    {
                        _consumedInventory.insert(dimTracking.InventDimId, qtyToPick);
                    }

                    processedInventoryLocal.insert(dimTracking.InventDimId, qtyToPick);

                    pickRunningQty -= qtyToPick;

                    if (!pickRunningQty)
                    {
                        break;
                    }
                }
            }
        }
        else
        {
            if (PdsGlobal::pdsIsCWItem(itemId))
            {
                if (prodBOM)
                {
                    WHSPoolProdBOM::updateWithPickListTransactionsHandlingQty(prodBOM.InventTransId, itemId, _inventDim, _pickQty, _pickWeight, InventLocation::find(this.InventLocationId).WHSRawMaterialPolicy);
                }
                else
                {
                    WHSInvent::pickQuantities(_common, _inventDim.InventDimId, _pickWeight, _pickQty, inventDimParmAboveLocation, UnknownNoYes::Unknown, true);
                }
            }
            else
            {
                if (prodBOM)
                {
                    WHSPoolProdBOM::updateWithPickListTransactionsHandlingQty(prodBOM.InventTransId, itemId, _inventDim, _pickQty, 0, InventLocation::find(this.InventLocationId).WHSRawMaterialPolicy);
                }
                else
                {
                    WHSInvent::pickQuantities(_common, _inventDim.InventDimId, _pickQty, 0, inventDimParmAboveLocation, UnknownNoYes::Unknown, true);
                }
            }

            processedInventoryLocal.insert(_inventDim.InventDimId, _pickQty);
        }

        if (prodBOM)
        {
            WHSPostProdJournalFrozenWork postProdJournalFrozenWork = WHSPostProdJournalFrozenWork::construct();
            postProdJournalFrozenWork.parmProdBom(prodBOM);
            postProdJournalFrozenWork.parmProcessedInventory(processedInventoryLocal);
            postProdJournalFrozenWork.createProdPickingJournal();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyLeftToPick</Name>
				<Source><![CDATA[
    private Qty qtyLeftToPick(InventTransId _inventTransId)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        select sum(Qty) from inventTrans
            where (inventTrans.StatusIssue  == StatusIssue::OnOrder
                ||  inventTrans.StatusIssue == StatusIssue::ReservOrdered
                ||  inventTrans.StatusIssue == StatusIssue::ReservPhysical)
            exists join inventTransOrigin
                where inventTransOrigin.RecId           == inventTrans.InventTransOrigin
                    && inventTransOrigin.InventTransId  == _inventTransId;

        return inventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>satisfyDemandWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Satisfy all demand work lines replenished with current work.
    /// </summary>
    public void satisfyDemandWorkLine()
    {
        if (WHSSatisfyDemandWorkLineContext::current())
        {
            this.satisfyDemandWorkLineWithWorkBuildId(WHSSatisfyDemandWorkLineContext::currentWorkBuildId());
        }
        else
        {
            this.satisfyDemandWorkLineWithoutWorkBuildId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>satisfyDemandWorkLineWithoutWorkBuildId</Name>
				<Source><![CDATA[
    private void satisfyDemandWorkLineWithoutWorkBuildId()
    {
        WHSReplenWorkLink   replenWorkLink;
        WHSWorkLine         demandWorkLine;
        Set                 demandWorkIdSet = new Set(Types::String);

        ttsbegin;

        while select forupdate replenWorkLink
            where  replenWorkLink.ReplenWorkId == this.WorkId
                && replenWorkLink.Status == WHSReplenWorkLinkStatus::Open
            exists join demandWorkLine
                where demandWorkLine.WorkId == replenWorkLink.DemandWorkId
                    && demandWorkLine.LineNum == replenWorkLink.DemandLineNum
                    && demandWorkLine.WorkStatus != WHSWorkStatus::Cancelled
        {
            replenWorkLink.satisfyDemandWorkLine();
            // Add demand work id to a Set to avoid unfreeze same demand work multiple times.
            demandWorkIdSet.add(replenWorkLink.DemandWorkId);
        }

        WHSWorkTable::unfreezeDemandWork(demandWorkIdSet);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>satisfyDemandWorkLineWithWorkBuildId</Name>
				<Source><![CDATA[
    private void satisfyDemandWorkLineWithWorkBuildId(WHSWorkBuildId _workBuildId)
    {
        WHSReplenWorkLink   replenWorkLink;
        WHSWorkTable        demandWorkTable;
        WHSWorkLine         demandWorkLine;
        Set                 demandWorkIdSet = new Set(Types::String);

        ttsbegin;

        while select forupdate replenWorkLink
            where  replenWorkLink.ReplenWorkId == this.WorkId
                && replenWorkLink.Status == WHSReplenWorkLinkStatus::Open
            exists join demandWorkLine
                where demandWorkLine.WorkId == replenWorkLink.DemandWorkId
                    && demandWorkLine.LineNum == replenWorkLink.DemandLineNum
                    && demandWorkLine.WorkStatus != WHSWorkStatus::Cancelled
            exists join demandWorkTable
                where demandWorkTable.WorkBuildId == _workBuildId
                    && demandWorkTable.WorkId == replenWorkLink.DemandWorkId
        {
            replenWorkLink.satisfyDemandWorkLine();
            // Add demand work id to a Set to avoid unfreeze same demand work multiple times.
            demandWorkIdSet.add(replenWorkLink.DemandWorkId);
        }

        WHSWorkTable::unfreezeDemandWork(demandWorkIdSet);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWorkId</Name>
				<Source><![CDATA[
    void setWorkId()
    {
        this.WorkId = NumberSeq::newGetNum(WHSParameters::numRefWHSWorkId()).num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates open optional work lines associated with the current work to Skipped. Mandatory work lines are updated to match previous pick work class
    /// </summary>
    /// <returns>
    ///    True if any work lines were skipped; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Work lines are only updated when the status of the current work is open.
    /// </remarks>
    public boolean skipLines()
    {
        WHSWorkLine     workLine;
        boolean         skipped;
        WHSWorkClassId  prevPickWorkClassID = '';

        if (this.WorkStatus == WHSWorkStatus::Open)
        {
            ttsbegin;

            workLine.skipDataMethods(true);
            update_recordset workLine
                setting WorkStatus  = WHSWorkStatus::Skipped
                where workLine.WorkId        == this.WorkId
                   && workLine.WorkStatus    == WHSWorkStatus::Open
                   && workLine.Mandatory     == NoYes::No;

            skipped = workLine.RowCount() != 0;

            while select forupdate workLine
                where workLine.WorkId     == this.WorkId
                   && workLine.WorkStatus == WHSWorkStatus::Open
                   && workLine.Mandatory  == NoYes::Yes
            {
                switch (workLine.WorkType)
                {
                    case WHSWorkType::Pick :
                        prevPickWorkClassID = workLine.WorkClassId;
                        break;

                    case WHSWorkType::Put :
                        if (prevPickWorkClassID)
                        {
                            workLine.WorkClassId = prevPickWorkClassID;
                            workLine.update();
                            prevPickWorkClassID = '';
                        }
                        break;

                    default:
                        if (prevPickWorkClassID)
                        {
                            workLine.WorkClassId = prevPickWorkClassID;
                            workLine.update();
                            break;
                        }
                }
            }

            ttscommit;
        }

        if (skipped)
        {
            WHSWorkLineCache::remove(this.WorkId);
            info("@WAX2081");
        }
        else
        {
            info("@WAX2222");
        }

        return skipped;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFrozenDiffLocationWork</Name>
				<Source><![CDATA[
    private void updateFrozenDiffLocationWork(WHSWorkFrozen _workFrozen)
    {
        WHSWorkInventTrans workInventTrans;
        WHSWorkLine        workLine;
        WMSLocationId      newLocationId = this.getFinalPutLocation();

        ttsbegin;

        while select forupdate workLine
            where workline.WorkId        == _workFrozen.FrozenWorkId
            &&    workLine.InventTransId == _workFrozen.InventTransId
            &&    workLine.InventDimId   == _workFrozen.FrozenWorkInventDimId
            join forupdate workInventTrans
                where workInventTrans.LineNum   == workLine.LineNum
                &&    workInventTrans.WorkId    == workLine.WorkId
                &&    workInventTrans.Qty       != workLine.InventQtyWork
        {
            InventDim newPickDim = InventDim::find(workInventTrans.InventDimIdFrom);

            newPickDim.wMSLocationId = newLocationId;
            newPickDim = InventDim::findOrCreate(newPickDim);

            if (workInventTrans.Qty == 0
            &&  workLine.WMSLocationId != newLocationId)
            {
                // Change the location since moving full qty.
                workLine.WMSLocationId = newLocationId;
                workLine.update();

                workInventTrans.Qty             = workLine.InventQtyWork;
                workInventTrans.InventDimIdFrom = newPickDim.inventDimId;
                workInventTrans.update();
            }
            else
            {
                // Split work line
                WhsSplitWork::splitFrozenWorkLine(workLine, workInventTrans, newLocationId, newPickDim.inventDimId);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unfreezeAndUpdateLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes frozen work related to production picking or Kanban picking work being completed.
    /// </summary>
    /// <remarks>
    /// <c>WHSWorkFrozen</c> records are created when over-picking occurs during work execution and extra inventory being picked is able to satisfy existing Open work.
    /// When the over-picked work is completed inventory is picked against the order(s) relating to the frozen work.
    /// </remarks>
    private void unfreezeAndUpdateLocation()
    {
        InventDim                   inventDim;
        WHSWorkFrozen               workFrozen;
        WHSWorkLine                 workLine;
        Common                      common;
        ProdBOM                     prodBOM;
        KanbanJobPickingList        kanbanJobPickingList;

        // Production Raw Materials Picking
        if (this.canWorkTransTypeUseStagingOverPick())
        {
            Map consumedInventory = new Map(Types::String, Types::Real);
            Map reservedInventory = new Map(Types::String, Types::Real);
            WHSRawMaterialPolicy rawMaterialPolicy = InventLocation::find(this.InventLocationId).WHSRawMaterialPolicy;
            WMSLocationId        finalPutLocation = this.getFinalPutLocation();

            ttsbegin;

            while select workFrozen
                where workFrozen.WorkId == this.WorkId
            {
                select firstonly ItemId, wmsLocationId, InventDimId, UserId from workLine
                    order by workLine.LineNum desc
                    where workLine.WorkId           == workFrozen.FrozenWorkId
                       && workLine.InventTransId    == workFrozen.InventTransId
                       && workLine.InventDimId      == workFrozen.FrozenWorkInventDimId;
                
                InventHandlingQty   pickQty     = min(workFrozen.Qty, -this.qtyLeftToPick(workFrozen.InventTransId));
                WHSHandlingWeight   pickWeight  = workFrozen.TransactionWeight;
                boolean             diffLocation;
                WHSWorkTable        workTable = WHSWorkTable::find(workFrozen.FrozenWorkId, true);

                if (workTable.WorkStatus != WHSWorkStatus::Cancelled)
                {
                    diffLocation = workTable.getFinalPutLocation() != finalPutLocation;
                    
                    WHSWorkTable::tryUnBlockStagingPickBlockedWork(workTable.WorkId);
                }

                // Get the above location dimensions of the work that was frozen.
                inventDim = InventDim::find(workFrozen.FrozenWorkInventDimId);

                common = WHSInvent::getCommonFromWorkTransType(this.WorkTransType, workFrozen.InventTransId, true);

                if (diffLocation)
                {
                    this.updateFrozenDiffLocationWork(workFrozen);
                }
                else if (common) // Need not update location if no transaction exists.
                {
                    // Should always use Location from put work line same way as not frozen work processing.
                    if (finalPutLocation)
                    {
                        inventDim.WMSLocationId = finalPutLocation;
                    }
                    else if (WHSWorkUser::allowOverride(WHSWorkLine::lastClosedWorkLine(this.WorkId).UserId, WHSWorkType::Put))
                    {
                        inventDim.wMSLocationId = (select firstonly wmsLocationId from whsWorkLine
                                                        order by LineNum desc
                                                            where whsWorkLine.WorkType    == WHSWorkType::Put
                                                                && whsWorkLine.WorkId     == workFrozen.WorkId
                                                                && whsWorkLine.WorkStatus == WHSWorkStatus::Closed).wmsLocationId;
                    }
                    else
                    {
                        switch (this.WorkTransType)
                        {
                            case WHSWorkTransType::ProdPick:
                                prodBOM = common as ProdBOM;

                                // Get Work center location
                                inventDim.wmsLocationId = WHSProdTable::getWorkCenterLocationFromProdId(prodBOM.ProdId, prodBOM.OprNum, prodBOM.InventDimId);
                                break;
                            case WHSWorkTransType::KanbanPick:
                                kanbanJobPickingList = common as KanbanJobPickingList;

                                // Get work cell location
                                inventDim.wmsLocationId = kanbanJobPickingList.kanbanJob().wrkCtrResourceGroup().InputWMSLocationId;
                                break;
                        }
                    }

                    this.assignLicensePlateForUnfrozenWork(inventDim);

                    inventDim = this.initializeInventDimForUnfrozenWork(inventDim, workFrozen);

                    // Only try and pick from the overPick if warehouse has pick policy and serials are not registered at consumption
                    if (rawMaterialPolicy == WHSRawMaterialPolicy::Pick
                        && !EcoResTrackingDimensionGroupItem::isItemActiveSerialAtConsumption(workLine.ItemId)
                        && EcoResTrackingDimensionGroup::find(InventTable::find(workLine.ItemId).trackingDimensionGroup()).CaptureSerial != WHSWhenToCapture::Packing)
                    {
                        // Pick overPick qty against target transaction
                        this.pickOverPickTransaction(common, pickQty, pickWeight, inventDim, consumedInventory);
                    }
                    else if (rawMaterialPolicy == WHSRawMaterialPolicy::Reserve)
                    {
                        InventMovement movement = InventMovement::construct(common);

                        if (common is ProdBOM)
                        {
                            InventHandlingQty remainingPickQty = this.reserveOverpickTransactionProdJournal(pickQty, common, workLine, inventDim, reservedInventory);

                            if (remainingPickQty > 0)
                            {
                                this.reserveOverPickTransaction(workLine.ItemId, movement, remainingPickQty, workLine.inventDim(), inventDim, reservedInventory, true);
                            }
                        }
                        else
                        {
                            // Reserve overPick qty against target transaction
                            this.reserveOverPickTransaction(workLine.ItemId, movement, pickQty, workLine.inventDim(), inventDim, reservedInventory, false);
                        }
                    }
                }
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveOverpickTransactionProdJournal</Name>
				<Source><![CDATA[
    private InventHandlingQty reserveOverpickTransactionProdJournal(
        InventHandlingQty _pickQty,
        ProdBOM           _prodBom,
        WHSWorkLine       _workLine,
        InventDim         _inventDimTo,
        Map               _reservedInventory)
    {
        ProdJournalBom		journalBOM;
        ProdJournalTable	journalTable;
        InventTrans			inventTrans;
        InventTransOrigin   inventTransOrigin;
        InventHandlingQty   runningQty = _pickQty;

        while select journalBOM
            where journalBOM.InventTransId			== _prodBom.InventTransId
            &&	  journalBOM.InventTransChildType	== InventTransChildType::ProdJournalBOM
        join TableId from inventTransOrigin
            where inventTransOrigin.InventTransId   == journalBOM.InventTransId
        join Qty from inventTrans
            order by Qty
            where inventTrans.InventTransOrigin == inventTransOrigin.RecId
            &&    inventTrans.TransChildRefId	== journalBOM.InventTransChildRefId
            &&	  inventTrans.inventDimId		== _workLine.InventDimId
            &&	  inventTrans.StatusIssue		== StatusIssue::ReservPhysical
            &&    inventTrans.StatusReceipt     == StatusReceipt::None
        exists join journalTable
            where journalTable.JournalId == journalBOM.JournalId
            &&	  journalTable.Posted	 == NoYes::No
        {
            InventMovement movementLoc  = InventMovement::construct(_prodBom, InventMovSubType::None, journalBOM);
            InventHandlingQty updateQty = min(runningQty, -inventTrans.Qty);

            runningQty -= updateQty;
            this.reserveOverPickTransaction(_workLine.ItemId, movementLoc, updateQty, _workLine.inventDim(), _inventDimTo, _reservedInventory, false);

            if (runningQty <= 0)
            {
                break;
            }
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventDimForUnfrozenWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory dimensions.
    /// </summary>
    /// <param name = "_inventDim">The inventory dimension record.</param>
    /// <param name = "_workFrozen">The frozen work record.</param>
    /// <returns>The initialized inventory dimension record.</returns>
    protected InventDim initializeInventDimForUnfrozenWork(InventDim _inventDim, WHSWorkFrozen _workFrozen)
    {
        return InventDim::findOrCreate(_inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignLicensePlateForUnfrozenWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assign license plate for the unfrozen work.
    /// </summary>
    /// <param name = "_inventDim">The inventory dimension to reassign license plate for.</param>
    protected void assignLicensePlateForUnfrozenWork(InventDim _inventDim)
    {
        if (_inventDim.wmsLocation().whsLocationIsLPControlled())
        {
            _inventDim.LicensePlateId = this.TargetLicensePlateId;
        }
        else
        {
            _inventDim.LicensePlateId = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryUnBlockStagingPickBlockedWorkWorkBlocking</Name>
				<Source><![CDATA[
    private static void tryUnBlockStagingPickBlockedWorkWorkBlocking(WHSWorkId _workId)
    {
        WHSWorkBlocking workBlocking = WHSWorkBlocking::newFromWorkIdSkipInProgressWorkLineWithNoPreviousPutCheck(_workId);
        workBlocking.tryUnBlockWorkWithReasonType(WHSWorkBlockingReasonType::UnProcessedOverPickWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryUnBlockStagingPickBlockedWork</Name>
				<Source><![CDATA[
    private static void tryUnBlockStagingPickBlockedWork(WHSWorkId _workId)
    {
        WHSWorkTable workTable = WHSWorkTable::find(_workId, true);

        if (workTable.WorkStatus != WHSWorkStatus::Cancelled)
        {
            WHSWorkTable::tryUnBlockStagingPickBlockedWorkWorkBlocking(workTable.workId);           
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkBlockedByUnProcessedStagingPickWorks</Name>
				<Source><![CDATA[
    private boolean isWorkBlockedByUnProcessedStagingPickWorks()
    {
        return (this.firstUnProcessedRelatedStagingPickWorkId() != '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkBlockedByHeldWave</Name>
				<Source><![CDATA[
    private boolean isWorkBlockedByHeldWave()
    {
        if (!this.waveId)
        {
            return false;
        }

        return WHSWaveTable::find(this.WaveId).WaveStatus <= WHSWaveStatus::Held;
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstUnProcessedRelatedStagingPickWorkId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the first unprocessed related overpick work id related to the current work.
    /// </summary>
    /// <returns>The first unprocessed related overpick work id related to the current work.</returns>
    public WHSWorkId firstUnProcessedRelatedStagingPickWorkId()
    {
        if (!this.canWorkTransTypeUseStagingOverPick())
        {
            return '';
        }

        WHSWorkFrozen workFrozen;
        WHSWorkTable  workTable;

        select firstonly WorkId from workFrozen
                where workFrozen.FrozenWorkId == this.WorkId
            exists join workTable
                where worktable.WorkId == workFrozen.WorkId
                && (worktable.WorkStatus == WHSWorkStatus::Open
                    ||  worktable.WorkStatus == WHSWorkStatus::InProcess);

        return workFrozen.WorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canWorkTransTypeUseStagingOverPick</Name>
				<Source><![CDATA[
    private boolean canWorkTransTypeUseStagingOverPick()
    {
        return (this.WorkTransType == WHSWorkTransType::ProdPick
            || this.WorkTransType == WHSWorkTransType::KanbanPick);
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        this.assertMandatoryFieldsNotBlank();

        boolean closed = (this.orig().WorkStatus != WHSWorkStatus::Closed &&
                          this.WorkStatus        == WHSWorkStatus::Closed);

        boolean cancelled = (this.orig().WorkStatus != WHSWorkStatus::Cancelled &&
                             this.WorkStatus        == WHSWorkStatus::Cancelled);

        boolean openWorkChangedToInProcess = this.isWorkChangedFromOpenToInProcess();
        boolean inProcessWorkChangedToOpen = this.isWorkChangedFromInProcessToOpen();

        boolean workStatusHasChanged = (this.orig().WorkStatus != this.WorkStatus);
        
        if (workStatusHasChanged)
        {
            this.validateWorkStatus();
        }

        if (this.WorkTransType == WHSWorkTransType::Packing
            && this.orig().Frozen != this.Frozen)
        {
            throw error(strFmt("@WAX:WorkCannotBeExecuted", this.WorkId, WHSWorkTransType::Packing));
        }

        if (this.orig().InventoryTransactionMechanism != this.InventoryTransactionMechanism 
            && WHSInventoryTransactionMechanismValidationFlight::instance().isEnabled())
        {
            throw error(strFmt("@WAX:WorkTableTransactionMechanismChangeError", this.WorkId));
        }

        super();

        WHSWorkChangeHandler workChangeHandler = WHSWorkChangeHandler::construct();
        
        if (this.WorkTransType == WHSWorkTransType::Replenishment && (openWorkChangedToInProcess || inProcessWorkChangedToOpen))
        {
            WMSLocation finalPutLocation = WMSLocation::find(this.getFinalPutLocation(), this.InventLocationId);

            if (finalPutLocation.isReplenishmentOverflowEnabled())
            {
                this.updateWorkBlockingForStatusChange(finalPutLocation, openWorkChangedToInProcess);
            }
        }

        if (this.shouldHandleWorkStatusChange())
        {
            workChangeHandler.handleWorkStatusChange(this, workStatusHasChanged);
        }

        if (this.WorkStatus > WHSWorkStatus::InProcess)
        {
            WHSWorkGrouping workGrouping;
       
            delete_from workGrouping
                where workGrouping.WorkId == this.WorkId;
        }

        if (closed)
        {
            boolean unMarkWorkInventTransWorkHasReservation = true;
            if (this.isWorkTransTypeOutbound())
            {
                this.pickAllInventoryForWork();
                // the pickAllInventoryForWork method updates the WorkHasReservation so we do not do it inside this method
                unMarkWorkInventTransWorkHasReservation = false;
                this.unfreezeAndUpdateLocation();
            }
            else if (this.WorkTransType == WHSWorkTransType::Replenishment)
            {
                // If this is demand based replenishment then we need to create/update WITs for the demand work.
                this.satisfyDemandWorkLine();
            }
            else if (this.WorkTransType  == WHSWorkTransType::QualityItemSampling
                || this.WorkTransType == WHSWorkTransType::QualityInQualityCheck)
            {
                // Update the location of inventory for the related quality order
                WHSQualityOrderInventory::updateInventoryAtWorkClose(this);
            }

            // Remove all the flags that state that work has the reservation
            if (unMarkWorkInventTransWorkHasReservation)
            {
                this.unMarkWorkInventTransWorkHasReservation();
            }
            
            workChangeHandler.handleWorkStatusChange(this, workStatusHasChanged);

            if (this.mustCleanUpUOMStructureOnCloseOrCancel())
            {
                WHSUOMStructure::cleanupTOUOMStructure(this.TargetLicensePlateId);
            }

            this.postClosed();

        }
        else if (cancelled)
        {
            workChangeHandler.handleWorkStatusChange(this, workStatusHasChanged);
 
            if (this.mustCleanUpUOMStructureOnCloseOrCancel())
            {
                WHSUOMStructure::cleanupTOUOMStructure(this.TargetLicensePlateId);
            }

            this.postCancelled();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postClosed</Name>
				<Source><![CDATA[
    private void postClosed()
    {
        WHSInventoryTransactionArchiveQueueEntry::addWorkToQueue(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCancelled</Name>
				<Source><![CDATA[
    private void postCancelled()
    {
        WHSInventoryTransactionArchiveQueueEntry::addWorkToQueue(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret = super();

        if (ret &&
            this.WorkStatus == WHSWorkStatus::Skipped)
        {
            ret = checkFailed("@WAX:WorkHeaderCannotHaveWorkStatusSkipped");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the current work status is allowed
    /// </summary>
    private void validateWorkStatus()
    {
        if (this.WorkStatus == WHSWorkStatus::Skipped)
        {
            throw error("@WAX:WorkHeaderCannotHaveWorkStatusSkipped");
        }

        if (this.WorkTransType == WHSWorkTransType::Packing 
            && this.WorkStatus != WHSWorkStatus::Open
            && this.WorkStatus != WHSWorkStatus::Closed
            && !(WHSPackingWorkAllowInProcessContext::current() 
                && this.WorkStatus == WHSWorkStatus::InProcess))
        {
            if (this.orig().WorkStatus != WHSWorkStatus::Cancelled && this.WorkStatus == WHSWorkStatus::Cancelled)
            {
                warning("@WAX:CancellingOpenPackingWork");
            }

            throw error(strFmt("@WAX:WorkCannotBeExecuted", this.WorkId, WHSWorkTransType::Packing));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCleanUpUOMStructureOnCloseOrCancel</Name>
				<Source><![CDATA[
    private boolean mustCleanUpUOMStructureOnCloseOrCancel()
    {
        return (this.WorkTransType == WHSWorkTransType::TransferReceipt
            ||  this.WorkTransType == WHSWorkTransType::CrossDocking);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoadStatusForSorting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the load status for sorting work
    /// </summary>
    [Hookable(false)]
    internal void updateLoadStatusForSorting()
    {
        ttsbegin;

        WHSWorkLine         workLine;
        WHSWorkInventTrans  workInventTrans;
        WHSLoadLine         loadLine;
        WHSShipmentTable    shipment;
        Set                 loadIds = new Set(Types::String);

        while select LoadId, ShipmentId from loadLine
            group by LoadId, ShipmentId
            exists join shipment
                where  (shipment.ShipmentId == loadLine.ShipmentId
                    && shipment.ShipmentStatus < WHSShipmentStatus::Shipped)
            exists join workInventTrans
                where  workInventTrans.InventTransIdParent == loadLine.InventTransId
                    && workInventTrans.WorkId == this.WorkId                        
            exists join workLine
                where workLine.WorkId == workInventTrans.WorkId                            
                    && workLine.LineNum ==  workInventTrans.LineNum
                    && workLine.WorkType == WHSWorkType::Put
        {
            if (!loadIds.in(loadLine.LoadId) 
                && WHSLoadTable::validateLoadCanBeLoaded(loadLine.LoadId))
            {
                WHSLoadTable::updateLoadStatus(loadLine.LoadId, WHSLoadStatus::Loaded);
            }

            loadIds.add(loadLine.LoadId);

            if (WHSShipmentTable::validateShipmentCanBeLoaded(loadLine.ShipmentId))
            {
                WHSShipmentTable::updateShipmentStatus(loadLine.ShipmentId, WHSShipmentStatus::Loaded);
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateContainerTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventDim on all containers related to the closed work.
    /// </summary>
    /// <param name="_finalPutWMSLocationId">
    /// The final put location of the work being closed.
    /// </param>
    [Hookable(false)]
    internal void updateContainerTable(WMSLocationId _finalPutWMSLocationId)
    {
        WHSWorkLine     conWorkLine;
        WHSWorkTable    workTable;
        
        while select WorkId, WorkType, ContainerId from conWorkLine
            where conWorkLine.WorkId    == this.WorkId
            &&    conWorkLine.WorkType  == WHSWorkType::Pick
            &&    conWorkLine.ContainerId
        join WorkId, TargetLicensePlateId, InventSiteId, InventLocationId from workTable
                where workTable.WorkId == conWorkLine.WorkId
        {
            WHSContainerTable containerTable = WHSContainerTable::findByContainerId(conWorkLine.ContainerId, true);
            if (containerTable.RecId)
            {
                containerTable.InventDimId = workTable.createInventDimFinalPut(_finalPutWMSLocationId).InventDimId;
                containerTable.update();
            }
        }
  
        this.updateCombinedContainerTable(_finalPutWMSLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStatusForAllWorkRelatedLoads</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the load related to each closed picked work line.
    /// </summary>
    [Hookable(false)]
    internal void updateStatusForAllWorkRelatedLoads()
    {
        if (this.HasWorkLineLoadLineDetails)
        {
            QueryRun queryRun = new QueryRun(WHSWorkLineLoadLineDetails::buildQueryFromWorkIdGroupByLoadId(this.WorkId));

            while (queryRun.next())
            {
                WHSLoadLine loadLine = queryRun.get(tableNum(WHSLoadLine));

                WHSLoadStatusUpdater loadStatusUpdater = WHSLoadStatusUpdater::newFromLoadId(loadLine.LoadId);
                loadStatusUpdater.updateWhenWorkClosed();
            }
        }
        else
        {
            WHSWorkLine workLine;
            WHSLoadTable loadTable;

            
            select workLine
                group by workLine.LoadId
                where workLine.WorkId       == this.WorkId
                &&    workLine.WorkType     == WHSWorkType::Pick
                &&    workLine.WorkStatus   == WHSWorkStatus::Closed
                &&    workLine.LoadId       != ''
            exists join loadTable
                where loadTable.LoadId      == workLine.LoadId;
    

            while (workLine)
            {
                WHSLoadStatusUpdater loadStatusUpdater = WHSLoadStatusUpdater::newFromLoadId(workLine.LoadId);
                loadStatusUpdater.updateWhenWorkClosed();

                next workLine;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>areLoadsAssociatedToWorkEligibleForTransportLoading</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if loads associated to this work has the correct
    /// loading strategy for transport loading.
    /// </summary>
    /// <returns>true, if work is eligible for transport loading; otherwise, false</returns>
    public boolean areLoadsAssociatedToWorkEligibleForTransportLoading()
    {
        boolean ret = true;

        WHSWorkLineLoadLineDetailsEnumerator enumerator = this.getEnumeratorGroupByLoadId();

        while (enumerator.moveNext())
        {
            if (WHSLoadTable::find(enumerator.currentLoadId()).LoadingStrategy == WHSLoadingStrategy::FullLoadShippingOnly)
            {
                ret = false;
                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkCanBeLoadedWithoutTransportLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the work can be loaded without the transport load.
    /// Work can be loaded without transport load when load strategy is Full or when it is pick-put to staging
    /// </summary>
    /// <returns>true, if the work can be loaded; otherwise false.</returns>
    public boolean validateWorkCanBeLoadedWithoutTransportLoad()
    {
        WHSLoadTable    loadTable = WHSLoadTable::find(this.LoadId);
        boolean         ret = true;

        if (loadTable.LoadingStrategy == WHSLoadingStrategy::PartialLoadShippingAllowed)
        {
            ret = WHSWorkLine::hasPutBeforePick(this.WorkId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipLoadingStrategyValidation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean shouldSkipLoadingStrategyValidation()
    {
        return this.WorkTransType == WHSWorkTransType::TransferReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkIsEligibleForTransportLoading</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if <c>WHSWorkTable</c> record is eligible
    /// for transport loading.
    /// </summary>
    /// <param name = "_transportLoadRecId">
    /// Transport load id that the <c>WHSWorkTable</c> record should be checked against.
    /// </param>
    public void validateWorkIsEligibleForTransportLoading(WHSTransportLoadRecId _transportLoadRecId)
    {
        if (!this.isWorkTransTypeOutbound())
        {
            throw error("@WAX:ErrorWorkTypeNotEligibleForTransportLoading");
        }

        if (!this.areLoadsAssociatedToWorkEligibleForTransportLoading())
        {
            throw error(strFmt("@WAX:ErrorTransportLoadingLoadHasWrongStrategy", this.WorkId));
        }

        WHSTransportLoad::validateWorkCanBeAssignedToTransportLoad(_transportLoadRecId, this.workId);

        if (!this.isNextOpenOrInProcessPutLocationShippingLocation())
        {
            throw error("@WAX:ErrorNextPutInWorkIsNotToFinalShippingLocation");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNextOpenOrInProcessPutLocationShippingLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the next open or in process put location in the work is a final shipping location.
    /// </summary>
    /// <returns>
    /// true, if the next open or in process put location in the work is a final shipping location; otherwise, false
    /// </returns>
    public boolean isNextOpenOrInProcessPutLocationShippingLocation()
    {
        WHSLocType nextPutLocationType = WMSLocation::find(WHSSingleWorkLineSelector::newFromWorkTable(this).findNextOpenOrInProcessPutWorkLine().WMSLocationId,
                                                                this.InventLocationId).whsLocationType();

        if (nextPutLocationType && nextPutLocationType == WHSParameters::find().ShipFinalLocType)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEnumeratorGroupByLoadId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the enumerator over the <c>WHSWorkLineLoadLineDetailsEnumerator</c>.
    /// </summary>
    /// <returns>The instance of <c>WHSWorkLineLoadLineDetailsEnumerator</c> type.</returns>
    /// <remarks>
    /// Depending on the <c>HasWorkLineLoadLineDetails</c> flag, the enumerator will loop over either
    /// the initial pick <c>WHSWorkLine</c> records or <c>WHSWorkLineLoadLineDetails</c> records.
    /// </remarks>
    public WHSWorkLineLoadLineDetailsEnumerator getEnumeratorGroupByLoadId()
    {
        return WHSWorkLineLoadLineDetailsEnumerator::newFromWorkIdGroupByLoadId(this.WorkId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shipmentIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>Set</c> of shipment IDs related to the work.
    /// </summary>
    /// <returns>
    /// A <c>Set</c> of shipment IDs related to the work
    ///</returns>
    public Set shipmentIds()
    {
        Set shipmentIdSet = new Set(Types::String);

        if (this.HasWorkLineLoadLineDetails)
        {
            QueryRun queryRun = new QueryRun(WHSWorkLineLoadLineDetails::buildQueryFromWorkIdGroupByShipmentIdAndQueryOpenWorkLines(this.WorkId));

            while (queryRun.next())
            {
                WHSLoadLine loadLine = queryRun.get(tableNum(WHSLoadLine));
                shipmentIdSet.add(loadLine.ShipmentId);
            }
        }
        else
        {
            WHSWorkLine workLine;
            while select workLine
            group by workLine.ShipmentId
                where workLine.WorkId == this.WorkId
                    &&  workLine.WorkType == WHSWorkType::Pick
                    &&  workLine.ShipmentId != ''
            {
                shipmentIdSet.add(workLine.shipmentId);
            }
        }

        return shipmentIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateShipmentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the shipment status during work close.
    /// </summary>
    [Hookable(false)]
    internal void updateShipmentStatus()
    {
        if (this.WorkStatus != WHSWorkStatus::Closed)
        {
            return;
        }

        Enumerator shipmentIdEnumerator = this.shipmentIds().getEnumerator();

        while (shipmentIdEnumerator.moveNext())
        {
            var shipmentId = shipmentIdEnumerator.current();

            WHSShipmentStatusUpdater shipmentStatusUpdater = WHSShipmentStatusUpdater::newFromShipmentId(shipmentId);
            shipmentStatusUpdater.updateWhenWorkClosed();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean         ret;

        ret = super();

        if ((select count(RecId) from whsWorkLine
                    where whsWorkLine.WorkId == this.WorkId
                       && whsWorkLine.WorkStatus == WHSWorkStatus::Closed).RecId > 0)
        {
            ret = checkFailed("@WAX687");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean ret;
        WHSWorkLine workLine;

        ret = super(_fieldIdToCheck);

        switch (_fieldIdToCheck)
        {
            case fieldNum(WHSWorkTable, LockedUser):
                select firstonly RecId from workLine
                    where workLine.WorkId           == this.WorkId           &&
                          workLine.InventQtyRemain  != workLine.InventQtyWork   &&
                          workLine.InventQtyRemain  != 0;

                if (workLine.RecId != 0)
                {
                    ret = checkFailed("@WAX3829");
                }
                break;

            case fieldNum(WHSWorkTable, ReplenishmentDependentWorkBlockingPolicy):
                if (this.WorkStatus != WHSWorkStatus::Open)
                {
                    ret = checkFailed("@WAX:ReplenishmentDependentWorkBlockingPolicy_WorkStatusError");
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkExecution</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that work for the current <c>WHSWorkTable</c> record has been automatically executed successfully.
    /// </summary>
    /// <returns>
    ///     False if there is work that should have been automatically executed; otherwise, false
    /// </returns>
    public boolean validateWorkExecution()
    {
        WHSWorkLine workLine;
        boolean     ret = true;

        select firstonly LineNum from workLine
            order by LineNum
            where workLine.WorkId    == this.WorkId
                && workLine.WorkStop == NoYes::Yes;

        if (workLine.LineNum)
        {
            ret =   (select firstonly RecId from whsWorkLine
                       where whsWorkLine.WorkId      == this.WorkId
                           && whsWorkLine.LineNum    <  workLine.LineNum
                           && whsWorkLine.WorkStatus <  WHSWorkStatus::Closed).RecId == 0;
        }
        else
        {
            ret = (select firstonly RecId from whsWorkLine
                    where whsWorkLine.WorkId      == this.WorkId
                        && whsWorkLine.WorkStatus <  WHSWorkStatus::Closed).RecId == 0;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTargetLicensePlate</Name>
				<Source><![CDATA[
    public static WHSWorkTable addTargetLicensePlate(WHSWorkId _workId, WHSLicensePlateId _licensePlateId)
    {
        WHSWorkTable    workTable;

        ttsbegin;

        workTable = WHSWorkTable::find(_workId, true);

        if (workTable && workTable.TargetLicensePlateId != _licensePlateId)
        {
            workTable.TargetLicensePlateId = _licensePlateId;
            workTable.write();

            WHSWorkTable::updateOutboundSortPositionWithNewLicencePlateId(workTable);
        }

        ttscommit;

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOutboundSortPositionWithNewLicencePlateId</Name>
				<Source><![CDATA[
    private static void updateOutboundSortPositionWithNewLicencePlateId(WHSWorkTable _workTable)
    {
        if (_workTable.WorkTransType == WHSWorkTransType::SortedInventoryPicking)
        {
            WHSOutboundSortPosition sortPosition;
            WHSOutboundSortPositionTrans sortPositionTrans;
            WHSWorkLine workLine;
            
            while select forupdate sortPosition
                exists join sortPositionTrans
                    where sortPositionTrans.OutboundSortPosition == sortPosition.RecId
                exists join workLine
                    where workLine.RecId == sortPositionTrans.WorkLine
                        && workLine.WorkId == _workTable.WorkId
            {
                sortPosition.LicensePlateId = _workTable.TargetLicensePlateId;
                sortPosition.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOpenCrossDockWorkByWorkBuildId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds only open work units based of work build Id. Used for finding cross docking work.
    /// </summary>
    /// <param name="_workBuildId">
    /// The work build ID used to find appropriate work units.
    /// </param>
    /// <param name="_userId">
    /// The current RF user executing work.
    /// </param>
    /// <returns>
    /// The first open line for the open work unit.
    /// </returns>
    public static WHSWorkLine findOpenCrossDockWorkByWorkBuildId(
        WHSWorkBuildId  _workBuildId, 
        WHSUserId       _userId)
    {
        WHSWorkLine workLine;

        if (_workBuildId
            && WHSWorkTable::existsCrossDockWorkForWorkBuildId(_workBuildId))
        {
            WHSWorkTable workTable;
            
            select firstonly WorkId from workTable
                where workTable.WorkBuildId == _workBuildId  &&
                        workTable.WorkStatus  == WHSWorkStatus::Open;

            if (workTable.WorkId)
            {
                WHSWorkExecute workExecute = new WHSWorkExecute();
                workLine = workExecute.getFirstOpenLine(workTable.WorkId, _userId);
            }            
        }

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsCrossDockWorkForWorkBuildId</Name>
				<Source><![CDATA[
    private static boolean existsCrossDockWorkForWorkBuildId(WHSWorkBuildId _workBuildId)
    {

        WHSWorkTable workTable;

        select firstonly RecId from workTable
                where workTable.WorkBuildId == _workBuildId &&
                      workTable.WorkTransType == WHSWorkTransType::CrossDocking;

        return workTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkBlockedByDeferredPutOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work is blocked by a deferred put operation.
    /// </summary>
    /// <returns>true if work blocked by deferred put operation, false otherwise.</returns>
    private boolean isWorkBlockedByDeferredPutOperation()
    {
        if (!this.Frozen)
        {
            return false;
        }

        WHSWorkBlocking workBlocking = WHSWorkBlocking::newFromWorkId(this.WorkId);

        return workBlocking.isBlockedByReasonType(WHSWorkBlockingReasonType::DeferredPutOperation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>anchorWorkByLoad</Name>
				<Source><![CDATA[
    [SysObsolete('The method is deprecated use WHSWorkTable::anchorRemainingWorkByLoad instead.', false, 23\4\2020)]
    public static void anchorWorkByLoad(WHSLoadId _loadId, WMSLocationId _oldLocationId, WMSLocationId _newLocationId)
    {
        WHSWorkLine     pickWorkLine;
        WHSWorkLine     putWorkLine;
        WHSWorkTable    workTable;
        WHSWorkLine     prevWorkLine;
        WhsWorkExecute  workExecute = WhsWorkExecute::construct();

        ttsbegin;

        // Loop over put workLines for the load that have the same old location as the anchoring WorkLine
        while select forupdate putWorkLine
            join workTable
            order by putWorkLine.RecId
            where workTable.WorkId           == putWorkLine.WorkId          &&
                  putWorkLine.wmsLocationId  == _oldLocationId              &&
                  putWorkLine.WorkType       == WHSWorkType::Put            &&
                  putWorkLine.WorkStatus     != WHSWorkStatus::Closed       &&
                  putWorkLine.WorkStatus     != WHSWorkStatus::Cancelled
                join pickWorkLine
                where pickWorkLine.WorkId        == workTable.WorkId &&
                      pickWorkLine.LoadId        == _loadId
        {
            prevWorkLine = WHSWorkTable::anchorWork(workTable, putWorkLine, prevWorkLine, _newLocationId, workExecute).data();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>nonAnchorableWorkStatuses</Name>
				<Source><![CDATA[
    protected static container nonAnchorableWorkStatuses()
    {
        return [WHSWorkStatus::Closed, WHSWorkStatus::Cancelled];
    }

]]></Source>
			</Method>
			<Method>
				<Name>nonAnchorableWorkTransTypes</Name>
				<Source><![CDATA[
    private static container nonAnchorableWorkTransTypes()
    {
        return [WHSWorkTransType::Packing];
    }

]]></Source>
			</Method>
			<Method>
				<Name>anchorRemainingWorkByLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Anchors all the remaining work which has the same load ID.
    /// </summary>
    /// <param name = "_loadId">Load ID.</param>
    /// <param name = "_workId">Work ID to exclude.</param>
    /// <param name = "_oldLocationId">Old location ID.</param>
    /// <param name = "_newLocationId">New location ID.</param>
    public static void anchorRemainingWorkByLoad(WHSLoadId        _loadId,
                                                 WHSWorkId        _workId,
                                                 WMSLocationId    _oldLocationId,
                                                 WMSLocationId    _newLocationId)
    {
        WHSWorkLine     pickWorkLine;
        WHSWorkLine     putWorkLine;
        WHSWorkTable    workTable;
        WHSWorkLine     prevWorkLine;
        WhsWorkExecute  workExecute = WhsWorkExecute::construct();
        Set             processedWorkSet = new Set(Types::String);

        ttsbegin;

        WhsWorkExecuteAnchoringProcessContext context = WhsWorkExecuteAnchoringProcessContext::current();

        RefRecId putWorkTemplateLineRecId;
        
        if (context)
        {
            putWorkTemplateLineRecId = context.putWorkTemplateLineRecId;
        }

        WHSAnchoringGroupId anchoringGroupId = WHSWorkTemplateLine::findByRecId(putWorkTemplateLineRecId).AnchoringGroupId;
        container nonAnchorableWorkStatuses = WHSWorkTable::nonAnchorableWorkStatuses();
        container nonAnchorableWorkTransTypes = WHSWorkTable::nonAnchorableWorkTransTypes();

        if (anchoringGroupId)
        {
            WHSWorkTemplateLine putWorkTemplateLine;

            while select forupdate putWorkLine
                order by putWorkLine.WorkId, putWorkLine.LineNum
                where putWorkLine.WorkType == WHSWorkType::Put &&
                      !(putWorkLine.WorkStatus in nonAnchorableWorkStatuses)
            join workTable
                where workTable.WorkId == putWorkLine.WorkId
                   && !(workTable.WorkTransType in nonAnchorableWorkTransTypes)
            exists join putWorkTemplateLine
                where putWorkTemplateLine.RecId == putWorkLine.WorkTemplateLineRecId
                   && putWorkTemplateLine.AnchoringGroupId == anchoringGroupId
            exists join pickWorkLine
                where pickWorkLine.WorkId == workTable.WorkId &&
                      pickWorkLine.LoadId == _loadId
            {
                if (!processedWorkSet.in(putWorkLine.WorkId))
                {
                    prevWorkLine = WHSWorkTable::anchorWork(workTable, putWorkLine, prevWorkLine, _newLocationId, workExecute).data();
                    processedWorkSet.add(prevWorkLine.WorkId);
                }
            }
        }
        else
        {
            boolean useWorkTemplateLineRecId = (_oldLocationId == '' && putWorkTemplateLineRecId != 0);

            // Loop over put workLines for the load that have the same old location as the anchoring WorkLine
            while select forupdate putWorkLine
                join workTable
                    order by putWorkLine.WorkId, putWorkLine.LineNum
                    where workTable.WorkId == putWorkLine.WorkId &&
                          !(workTable.WorkTransType in nonAnchorableWorkTransTypes) &&
                          (_oldLocationId == _newLocationId || workTable.WorkId != _workId) &&
                          ((!useWorkTemplateLineRecId && putWorkLine.wmsLocationId == _oldLocationId) || (useWorkTemplateLineRecId && putWorkLine.WorkTemplateLineRecId == putWorkTemplateLineRecId)) &&
                          putWorkLine.WorkType       == WHSWorkType::Put            &&
                          !(putWorkLine.WorkStatus in nonAnchorableWorkStatuses)
                exists join pickWorkLine
                    where pickWorkLine.WorkId == workTable.WorkId &&
                          pickWorkLine.LoadId == _loadId
            {
                if (!processedWorkSet.in(putWorkLine.WorkId))
                {
                    prevWorkLine = WHSWorkTable::anchorWork(workTable, putWorkLine, prevWorkLine, _newLocationId, workExecute).data();
                    processedWorkSet.add(prevWorkLine.WorkId);
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>anchorRemainingWorkByShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Anchors all the remaining work which has the same shipment ID.
    /// </summary>
    /// <param name = "_shipmentId">Shipment ID.</param>
    /// <param name = "_workId">Work ID to exclude.</param>
    /// <param name = "_oldLocationId">Old location ID.</param>
    /// <param name = "_newLocationId">New location ID.</param>
    public static void anchorRemainingWorkByShipment(WHSShipmentId    _shipmentId,
                                                     WHSWorkId        _workId,
                                                     WMSLocationId    _oldLocationId,
                                                     WMSLocationId    _newLocationId)
    {
        WHSWorkLine     pickWorkLine;
        WHSWorkLine     putWorkLine;
        WHSWorkTable    workTable;
        WHSWorkLine     prevWorkLine;
        WhsWorkExecute  workExecute = WhsWorkExecute::construct();
        Set             processedWorkSet = new Set(Types::String);

        ttsbegin;

        WhsWorkExecuteAnchoringProcessContext context = WhsWorkExecuteAnchoringProcessContext::current();

        RefRecId putWorkTemplateLineRecId;
        
        if (context)
        {
            putWorkTemplateLineRecId = context.putWorkTemplateLineRecId;
        }

        WHSAnchoringGroupId anchoringGroupId = WHSWorkTemplateLine::findByRecId(putWorkTemplateLineRecId).AnchoringGroupId;
        container nonAnchorableWorkStatuses = WHSWorkTable::nonAnchorableWorkStatuses();
        container nonAnchorableWorkTransTypes = WHSWorkTable::nonAnchorableWorkTransTypes();

        if (anchoringGroupId)
        {
            WHSWorkTemplateLine putWorkTemplateLine;

            while select forupdate putWorkLine
                order by putWorkLine.WorkId, putWorkLine.LineNum
                where putWorkLine.WorkType == WHSWorkType::Put &&
                      !(putWorkLine.WorkStatus in nonAnchorableWorkStatuses)
            join workTable
                where workTable.WorkId == putWorkLine.WorkId
                   && !(workTable.WorkTransType in nonAnchorableWorkTransTypes)
            exists join putWorkTemplateLine
                where putWorkTemplateLine.RecId == putWorkLine.WorkTemplateLineRecId
                   && putWorkTemplateLine.AnchoringGroupId == anchoringGroupId
            exists join pickWorkLine
                where pickWorkLine.WorkId == workTable.WorkId &&
                      pickWorkLine.ShipmentId == _shipmentId
            {
                if (!processedWorkSet.in(putWorkLine.WorkId))
                {
                    prevWorkLine = WHSWorkTable::anchorWork(workTable, putWorkLine, prevWorkLine, _newLocationId, workExecute).data();
                    processedWorkSet.add(prevWorkLine.WorkId);
                }
            }
        }
        else
        {
        boolean useWorkTemplateLineRecId = (_oldLocationId == '' && putWorkTemplateLineRecId != 0);

            // Loop over put workLines for the shipment that have the same old location as the anchoring WorkLine
            while select forupdate putWorkLine
                join workTable
                order by putWorkLine.WorkId, putWorkLine.LineNum
                    where workTable.WorkId == putWorkLine.WorkId &&
                          !(workTable.WorkTransType in nonAnchorableWorkTransTypes) &&
                          (_oldLocationId == _newLocationId || workTable.WorkId != _workId) &&
                          ((!useWorkTemplateLineRecId && putWorkLine.wmsLocationId == _oldLocationId) || (useWorkTemplateLineRecId && putWorkLine.WorkTemplateLineRecId == putWorkTemplateLineRecId)) &&
                          putWorkLine.wmsLocationId == _oldLocationId           &&
                          putWorkLine.WorkType      == WHSWorkType::Put         &&
                          !(putWorkLine.WorkStatus in nonAnchorableWorkStatuses)
                exists join pickWorkLine
                    where pickWorkLine.WorkId        == workTable.WorkId &&
                          pickWorkLine.ShipmentId    == _shipmentId
            {
            
                if (!processedWorkSet.in(putWorkLine.WorkId))
                {
                    prevWorkLine = WHSWorkTable::anchorWork(workTable, putWorkLine, prevWorkLine, _newLocationId, workExecute).data();
                    processedWorkSet.add(prevWorkLine.WorkId);
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>anchorWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the necessary updates to the _putWorkLine and the corresponding pickWorkLine.
    /// </summary>
    /// <param name = "_workTable">The work header of the workLine to anchor</param>
    /// <param name = "_putWorkLine">The put work line that needs to be anchored.</param>
    /// <param name = "_prevWorkLine">The recId of the previous put work line.</param>
    /// <param name="_newLocationId">
    /// The parameter of type <c>WMSLocationId</c>.
    /// </param>
    /// <param name="_workExecute">
    /// The parameter of type <c>WhsWorkExecute</c>.
    /// </param>
    /// <returns>The RecId of the current _putWorkLine</returns>
    private static WHSWorkLine anchorWork(
        WHSWorkTable   _workTable,
        WHSWorkLine    _putWorkLine,
        WHSWorkLine    _prevWorkLine,
        WMSLocationId  _newLocationId,
        WhsWorkExecute _workExecute)
    {
        if (_prevWorkLine.RecId == _putWorkLine.RecId)
        {
            return _prevWorkLine;
        }

        if (_workTable.isWorkBlockedByDeferredPutOperation())
        {
            return _putWorkLine;
        }

        WHSWorkLine stagingPickLine = WHSWorkTable::findAnchoringPickLine(_putWorkLine, _workTable.WorkId);

        // Check to make sure there is a staging Pick Line to update.
        if (stagingPickLine)
        {
            stagingPickLine.IsAnchored = NoYes::Yes;
            stagingPickLine.update();
            _workExecute.updateWorkLineLocation(stagingPickLine.WorkId, stagingPickLine.LineNum, _newLocationId);
        }

        // Update the put to be anchored to the new location
        _putWorkLine.IsAnchored = NoYes::Yes;
        _putWorkLine.update();
        _workExecute.updateWorkLineLocation(_putWorkLine.WorkId, _putWorkLine.LineNum, _newLocationId);

        return _putWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoExecutePick</Name>
				<Source><![CDATA[
    private static container autoExecutePick(WHSWorkExecute _workExecute,
                                            WHSParameters  _parameters,
                                            WHSWorkTable   _workTable,
                                            WHSWorkLine    _workLine,
                                            InventDim      _itemDims,
                                            boolean        _handleByLP = false)
    {
        WHSWorkExecute                  workExecute = _workExecute;
        WHSParameters                   parameters = _parameters;
        WHSWorkTable                    workTable = _workTable;
        WHSWorkLine                     workLine = _workLine;
        InventDim                       inventDimOnHandCriteria  = _itemDims;
        InventDim                       inventDim;
        InventBatchId                   inventBatchId;
        WHSLicensePlateId               licensePlateId, licensePlateIdToPickFrom;

        if (InventTable::find(workLine.ItemId).whsBatchActive())
        {
            if (workLine.inventDim().InventBatchId)
            {
                inventBatchId = workLine.inventDim().InventBatchId;
            }
            else if (!workTable.TargetLicensePlateId)
            {
                InventDim workLineDims = workLine.inventDim();
                EcoResProductDimGroupSetup::copyProductDimensionsForItem(workLine.ItemId, workLineDims, inventDimOnHandCriteria);
                inventDimOnHandCriteria.InventStatusId = workLineDims.InventStatusId;

                WHSWorkTemplateTable workTemplate = WHSWorkTemplateTable::find(
                                                        WHSWorkTemplateLine::findByRecId(workLine.WorkTemplateLineRecId).WorkTemplateCode,
                                                        workTable.WorkTransType);

                inventBatchId = WMSLocation::whsGetInventBatchIdByStrategy(
                                    workLine.wmsLocationId,
                                    workTable.InventLocationId,
                                    workLineDims.InventStatusId,
                                    inventDimOnHandCriteria,
                                    workLine.ItemId,
                                    workTemplate.BatchAllocationStrategy);
            }
            else if (inventBatchId == '')
            {
                inventBatchId = workLine.FEFOBatchId;
            }
        }

        // Build an inventDim for dimensions below license plate.
        // Currently auto execute only supports batch dimensions below license plate.
        inventDim.InventBatchId = inventBatchId;

        if (_handleByLP)
        {
            licensePlateIdToPickFrom = workLine.LocatedLPId;
        }
        else
        {
            licensePlateIdToPickFrom = workTable.TargetLicensePlateId;
        }

        if (licensePlateIdToPickFrom && WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).whsLocationIsLPControlled())
        {
            WHSLicensePlateId targetLicensePlateId = workTable.TargetLicensePlateId;

            // If we are splitting off qty from the lp we are picking from we need to generate a new target LP.
            if (workLine.AskForNewLicensePlate)
            {
                targetLicensePlateId = WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId);
            }

            inventDim.LicensePlateId = licensePlateIdToPickFrom;

            workLine = workExecute.pickWorkFromLicensePlate(licensePlateIdToPickFrom,
                                                    workLine,
                                                    parameters.GenericWorkUserId,
                                                    inventDim,
                                                    targetLicensePlateId,
                                                    0, // auto execution of work is not supported for warehouse CW enabled items
                                                    false,
                                                    NoYes::No,
                                                    false,
                                                    _handleByLP);

            if (workTable.TargetLicensePlateId != targetLicensePlateId)
            {
                workTable = WHSWorkTable::find(workTable.WorkId, true);
                workTable.TargetLicensePlateId = targetLicensePlateId;
                workTable.update();
            }
        }
        else if (workTable.TargetLicensePlateId)
        {
            workLine = workExecute.pickNonLicensePlateCheckDigitQuantities(workLine.WorkId,
                                                                 workLine.LineNum,
                                                                 workLine.ItemId,
                                                                 workLine.QtyRemain,
                                                                 0, // auto execution of work is not supported for warehouse CW enabled items
                                                                 workLine.UnitId,
                                                                 parameters.GenericWorkUserId,
                                                                 inventDim,
                                                                 workTable.TargetLicensePlateId,
                                                                 false);
        }
        else
        {
            licensePlateId = WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId);

            workLine = workExecute.pickNonLicensePlateCheckDigitQuantities(workLine.WorkId,
                                                                    workLine.LineNum,
                                                                    workLine.ItemId,
                                                                    workLine.QtyRemain,
                                                                    0, // auto execution of work is not supported for warehouse CW enabled items
                                                                    workLine.UnitId,
                                                                    parameters.GenericWorkUserId,
                                                                    inventDim,
                                                                    licensePlateId,
                                                                    false);

            workTable = WHSWorkTable::find(workTable.WorkId, true);
            workTable.TargetLicensePlateId = licensePlateId;
            workTable.update();
        }

        return [workLine, workTable];
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoExecuteWork</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Automatically executes all possible work for the associated work Id
    /// </summary>
    /// <param name="_workId">
    ///     Work will be executed for the provided Work Id.
    /// </param>
    public static void autoExecuteWork(WHSWorkId _workId)
    {
        WHSWorkTypeCustom               workTypeCustom;
        WhsWorkExecute                  workExecute = WhsWorkExecute::construct();
        WHSParameters                   parameters = WHSParameters::find();
        WHSWorkLine                     workLine;
        WHSWorkLine                     tmpWorkLine;
        WHSLocationProfile              whsLocationProfile;
        WMSLocation                     wmsLocation;
        InventTable                     inventTable;

        if (!parameters.GenericWorkUserId)
        {
            error("@WAX2758");
            return;
        }

        WHSWorkTable workTable = WHSWorkTable::find(_workId, true);

        // Invalid Work Id or the Work is not Auto-Executable.
        if (!workTable || !workTable.AutoExecute)
        {
            error("@WAX613");
            return;
        }

        workLine = workExecute.getFirstOpenLine(workTable.WorkId, parameters.GenericWorkUserId);

        // There are no open work lines to execute.
        if (!workLine)
        {
            return;
        }
        
        if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
        {
            if (WHSWorkTable::hasCatchWeightItems(workTable.WorkId))
            {
                if (!WHSWorkTable::canAutoExecuteCatchWeightItems())
                {
                    error(strFmt("@WAX:Error_WHSAutoExecuteWorkNotSupportCW", _workId));
                    return;
                }
            }
        }

        // Check to see if there is a Custom work line that requires data.
        select firstonly RecId from tmpWorkLine
            join CaptureData from workTypeCustom
            where tmpWorkLine.WorkTypeCustomCode == workTypeCustom.WorkTypeCustomCode &&
                  tmpWorkLine.WorkId             == workTable.WorkId                  &&
                  tmpWorkLine.WorkStatus         <= WHSWorkStatus::InProcess             &&
                  workTypeCustom.CaptureData     == NoYes::Yes;

        if (tmpWorkLine.RecId != 0)
        {
            error("@WAX2161");
            return;
        }

        // Check to make sure none of the Items are serial-controlled below location
        while select ItemId from inventTable
            group by ItemId
            exists join tmpWorkLine
            where tmpWorkLine.ItemId == inventTable.ItemId
               && tmpWorkLine.WorkId == workTable.WorkId
        {
            if (inventTable.isItemSerialNumberActivated() && WhsReservationHierarchyInventDimUtil::isSerialBelowLocation(inventTable))
            {
                if (!WHSWorkTable::canAutoExecuteSerialBellowLocation())
                {
                    error("@WAX:NoAutoWorkForSerialBelowLocationMessage");
                    return;
                }
            }
        }

        //Check to make sure we can handle pick on lp controlled locations
        tmpWorkLine.clear();

        if (!workTable.TargetLicensePlateId)
        {
            select firstonly RecId from tmpWorkLine
                where tmpWorkLine.WorkId == workTable.WorkId
                   && tmpWorkLine.WorkType == WHSWorkType::Pick
                   && tmpWorkLine.LocatedLPId == ''
                exists join wmsLocation
                    where wmsLocation.wmsLocationId == tmpWorkLine.wmsLocationId
                       && wmsLocation.InventLocationId == workTable.InventLocationId
                exists join whsLocationProfile
                    where whsLocationProfile.LocProfileId == wmsLocation.LocProfileId
                       && whsLocationProfile.lpControlled == NoYes::Yes;

            if (tmpWorkLine.RecId)
            {
                error("@WAX2159");
                return;
            }

            //determine if we have a mix of lines that have located LP and lines without located LP since that cannot be handled because the work will get a target LP assigned.
            if (WHSWorkTable::hasPickLinesWithoutLocatedLP(workTable.WorkId)
            &&  WHSWorkTable::hasPickLinesWithLocatedLP(workTable.WorkId))
            {
                error(strFmt("@SYP5070018", workTable.WorkId));
                return;
            }

            if (!workTable.canCompleteWorkWithMultipleLocatedLPs())
            {
                error(strFmt("@WAX:WorkWithoutDifferentLocatedLPError", workTable.WorkId));
                return;
            }
        }

        // Loop through all of the Work Lines and auto-execute them.
        WHSLicensePlateLabelBuild   labelBuild;
        InventDim                   itemDims;
        RefRecId                    prevRecId = 0;
        int                         i;
        boolean                     doReturn;
        boolean                     handleByLP;
        boolean                     assignLocatedLPAsTargetLP = false;
        WHSLicensePlateId           locatedLP;

        while (workLine.RecId != 0 && !workLine.WorkStop)
        {
            [doReturn, i] = WHSWorkTable::executeWorkLinesInit(workLine, prevRecId, i);
            prevRecId = workLine.RecId;
            if (doReturn)
            {
                return;
            }

            switch (workLine.WorkType)
            {
                case WHSWorkType::Pick:

                    //earlier checks should prevent that we have a mix of picks that need to be handled using located LP and without.
                    if (workLine.LocatedLPId)
                    {
                        workTable = WHSWorkTable::find(workTable.WorkId, true);
                        
                        //we can only use the locatedLP as the target lp if it is the only locatedLP used.
                        if (!workTable.TargetLicensePlateId)
                        {
                            if (!locatedLP && workTable.canUseLocatedLPAsTargetLP(workLine.LocatedLPId))
                            {
                                locatedLP = workLine.LocatedLPId;
                                assignLocatedLPAsTargetLP = true;
                            }
                        }

                        handleByLP = true;
                    }
                    else
                    {
                        handleByLP = false;
                    }

                    [workLine, workTable] = WHSWorkTable::autoExecutePick(workExecute, parameters, workTable, workLine, itemDims, handleByLP);
                    break;

                case WHSWorkType::Put:
                    workTable = WHSWorkTable::find(workTable.WorkId, true);
                        
                    if (!workTable.TargetLicensePlateId && assignLocatedLPAsTargetLP)
                    {
                        //if we can we use the first LocatedLp as targetLP we do it
                        workTable.TargetLicensePlateId = locatedLP;
                        workTable.update();

                        locatedLP = '';
                        assignLocatedLPAsTargetLP = false;
                    }

                    // Close work's container
                    if (!WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum))
                    {
                        WHSContainerTable::determineContainerClose(workLine.WorkId);
                    }

                    workLine = workExecute.putAwayToLocation(workLine.WorkId,
                                                             workLine.LineNum,
                                                             workLine.wmsLocationId,
                                                             WHSWorkTable::retrieveWorkPutFlow(workLine),
                                                             parameters.GenericWorkUserId,
                                                             workTable.TargetLicensePlateId,
                                                             workTable.TargetLicensePlateId,
                                                             handleByLP);

                    if (workLine.WorkStop)
                    {
                        WHSWorkTable::lockUnlockWork(workLine.WorkId, '');
                    }

                    break;

                default:
                    WhsWorkTypeHandler handler = WhsWorkTypeHandler::singletonFromType(workLine.WorkType);
                        
                    if (handler)
                    {
                        workLine = handler.executeWorkLine(workExecute, workLine, parameters.GenericWorkUserId);
                    }
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAutoExecuteCatchWeightItems</Name>
				<Source><![CDATA[
    public static boolean canAutoExecuteCatchWeightItems()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAutoExecuteSerialBellowLocation</Name>
				<Source><![CDATA[
    public static boolean canAutoExecuteSerialBellowLocation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoExecuteWorkInWorkBuildId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes all work for the selected work build ID that has to be executed automatically.
    /// </summary>
    /// <param name="_workBuildId">
    /// The work build ID.
    /// </param>
    public static void autoExecuteWorkInWorkBuildId(WHSWorkBuildId _workBuildId)
    {
        WHSWorkTable    workTable;

        while select workTable
            where workTable.WorkBuildId  == _workBuildId &&
                  workTable.AutoExecute  == NoYes::Yes   &&
                  workTable.Frozen       == NoYes::No    &&
                  workTable.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::EntireWorkOrder &&
                  workTable.WorkStatus   == WHSWorkStatus::Open
        {
            WHSWorkTable::autoExecuteWork(workTable.WorkId);

            if (workTable.validateWorkExecution())
            {
                info(strFmt("@WAX2158", workTable.WorkId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelDemandWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the demand work related to the specified replenishment work. If required and eligible, the demand
    /// work line or work will be canceled.
    /// </summary>
    /// <param name = "_replenWorkId">The replenishment work ID</param>
    /// <param name = "_lineNum">The replenishment work line number</param>
    /// <param name = "_totalInventQtyToReduce">The total inventory quantity to be reduced</param>
    /// <param name = "_log">True if a short pick exception log needs to be created; otherwise false</param>
    /// <param name = "_userId">The user ID</param>
    /// <param name = "_cancelDemandWorkLinesAndWork">True if it is allowed to cancel at this point the work or work line; otherwise false</param>
    /// <remarks>
    /// For scenarios with short pick reallocation, the potential work/work line cancellation is postponed. Once the final short picked quantity is
    /// calculated, all demand work lines will be traversed and canceled if needed.
    /// </remarks>
    public static void cancelDemandWork(
                                WHSWorkId   _replenWorkId,
                                LineNum     _lineNum = 0,
                                InventQty   _totalInventQtyToReduce = 0,
                                boolean     _log = false,
                                WHSUserId   _userId = '',
                                boolean     _cancelDemandWorkLinesAndWork = true)
    {
        WHSReplenWorkLink   replenWorkLink;
        WHSWorkLine         workLine;
        InventQty           runningQty;
        InventQty           cancelQty;
        Set                 demandWorkIdSet = new Set(Types::String);
        boolean             updateLoadLineQuantity = false; 

        WhsWorkCancelDemandContext whsWorkCancelDemandContext = WhsWorkCancelDemandContext::current();
        if (whsWorkCancelDemandContext)
        {
            updateLoadLineQuantity = whsWorkCancelDemandContext.updateLoadLineQuantity;
        }

        ttsbegin;

        // If we are canceling a full replen work header
        if (!_lineNum)
        {
            while select sum(InventQty) from replenWorkLink
                group by workLine.WorkId, workLine.LineNum, workLine.ItemId
                where replenWorkLink.ReplenWorkId   == _replenWorkId
                join WorkId, LineNum, ItemId from workLine
                    where workLine.WorkId           == replenWorkLink.DemandWorkId
                          && workLine.LineNum       == replenWorkLink.DemandLineNum
                          && workLine.WorkStatus    != WHSWorkStatus::Cancelled
            {
                using (var context = WHSDeleteExactReplenLinkOnCancelWorkContext::construct())
                {
                    context.parmWorkId(_replenWorkId);

                    // Cancel line, which will also clear qty on demand/replen link.
                    WHSWorkLine::cancelLine(workLine.WorkId, workLine.LineNum, replenWorkLink.InventQty, workLine.ItemId, updateLoadLineQuantity, true);
                    demandWorkIdSet.add(workLine.WorkId);
                }
            }
        }
        else // If we are partially canceling or shorting a workLine
        {
            runningQty = _totalInventQtyToReduce;

            while select sum(InventQty) from replenWorkLink
                group by workLine.WorkId, workLine.LineNum, workLine.ItemId
                order by workLine.WorkId asc, workLine.LineNum asc, workLine.ItemId asc
                where replenWorkLink.ReplenWorkId   == _replenWorkId
                    && replenWorkLink.ReplenLineNum == _lineNum
                join WorkId, LineNum, ItemId from workLine
                where workLine.WorkId       == replenWorkLink.DemandWorkId
                    && workLine.LineNum     == replenWorkLink.DemandLineNum
                    && workLine.WorkStatus  != WHSWorkStatus::Cancelled
            {
                if (!runningQty)
                {
                    break;
                }

                cancelQty = min(runningQty, replenWorkLink.InventQty);
                runningQty -= cancelQty;

                using (var context = WHSDeleteExactReplenLinkOnCancelWorkContext::construct())
                {
                    context.parmWorkId(_replenWorkId);
                    context.parmLineNum(_lineNum);

                    WHSWorkLine::cancelLine(workLine.WorkId, workLine.LineNum, cancelQty, workLine.ItemId, updateLoadLineQuantity, true, false, false, true, _cancelDemandWorkLinesAndWork);
                }

                if (_cancelDemandWorkLinesAndWork)
                {
                    demandWorkIdSet.add(workLine.WorkId);
                }

                if (_log)
                {
                    WHSWorkExceptionLog::createDemandReplenShortPickException(workLine.WorkId, workLine.LineNum, _userId, _replenWorkId, _lineNum);
                }
            }
        }

        WHSWorkTable::unfreezeDemandWork(demandWorkIdSet);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUnfreezeDemandWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if demand work can be unfrozen.
    /// </summary>
    /// <returns>true if demand work can be unfrozen; otherwise, false.</returns>
    protected boolean canUnfreezeDemandWork()
    {
        if (this.WorkStatus != WHSWorkStatus::Cancelled &&
            this.Frozen &&
            !this.hasUnFinishedReplenWork() &&
            !this.isWorkBlockedByHeldWave())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unfreezeDemandWork</Name>
				<Source><![CDATA[
    private static void unfreezeDemandWork(Set _demandWorkIdSet)
    {
        if (_demandWorkIdSet && !_demandWorkIdSet.empty())
        {
            SetEnumerator idSetEnumerator = _demandWorkIdSet.getEnumerator();
            while (idSetEnumerator.moveNext())
            {
                WHSWorkTable demandWork = WHSWorkTable::find(idSetEnumerator.current());
                
                if (demandWork.WorkStatus != WHSWorkStatus::Cancelled &&
                    demandWork.Frozen)
                {
                    WHSWorkBlocking::newFromWorkId(demandWork.WorkId)
                        .tryUnBlockWorkWithReasonType(WHSWorkBlockingReasonType::UnProcessedReplenishmentWork);
                }                
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseLocatedLPAsTargetLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a located license plate can be used as target license plate on the <c>WHSWorkTable</c>.
    /// </summary>
    /// <param name = "_locatedLPId">
    /// The located license plate id.
    /// </param>
    /// <returns>
    /// True if we can use the <c>WHSLocatedLPId</c> as target license plate; otherwise, false.
    /// </returns>
    public boolean canUseLocatedLPAsTargetLP(WHSLocatedLPId _locatedLPId)
    {
        if (!_locatedLPId)
        {
            return false;
        }

        WHSWorkLine workLine;
        select firstOnly recID from workLine
            where workLine.WorkId == this.WorkId
                && workLine.WorkType == WHSWorkType::Pick
                && workLine.LineNum < WHSWorkTable::getFirstPutWorkLine(this.WorkId).LineNum
                && workLine.LocatedLPId != _locatedLPId;

        return (workLine.recId == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkStatusToCancelled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the Work status to Cancelled for the specified work header.
    /// </summary>
    /// <param name = "_workId">The work Id to set work status to cancelled.</param>
    /// <returns><c>WHSWorkTable</c> record after update.</returns>
    public static WHSWorkTable updateWorkStatusToCancelled(WHSWorkId _workId)
    {
        ttsbegin;
        WHSWorkTable workTable = WHSWorkTable::find(_workId, true);
        workTable.WorkStatus               = WHSWorkStatus::Cancelled;
        workTable.WorkCancelledByUser      = curUserId();
        workTable.WorkCancelledUTCDateTime = DateTimeUtil::utcNow();
        workTable.update();
        ttscommit;

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkStatusToCancelledForOriginWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Work status to Cancelled for all the works that were consolidated to the specified work header.
    /// </summary>
    /// <param name = "_workIdConsolidated">The work Id of the consolidated work.</param>
    public static void updateWorkStatusToCancelledForOriginWork(WHSWorkId _workIdConsolidated)
    {
        if (!WHSSessionCache::consolidatedWorkLinesExist().isConsolidationUsed())
        {
            return;
        }

        WHSConsolidatedWorkLine consolidatedWorkLine;
        WHSWorkLine             workLineCons;
        WHSWorkLine             workLineOrig;

        ttsbegin;
        while select WorkId from workLineOrig
            group by WorkId
            exists join workLineCons
                where workLineCons.WorkId == _workIdConsolidated
                exists join consolidatedWorkLine
                    where consolidatedWorkLine.OriginWorkLine == workLineOrig.RecId
                        && consolidatedWorkLine.ConsolidatedWorkLine == workLineCons.RecId
        {
            // Run this recursively in case the origin was consolidated into before
            WHSWorkTable::updateWorkStatusToCancelledForOriginWork(workLineOrig.WorkId);

            WHSWorkTable::updateWorkStatusToCancelled(workLineOrig.WorkId);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performWorkCancelation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels the specified work.
    /// </summary>
    /// <param name = "_workTable">
    /// The Work to cancel.
    /// </param>
    /// <param name = "_allowCancelClosed">
    /// true if cancelling of closed work is allowed, otherwise, false.
    /// </param>
    /// <param name = "_cancelReplenishmentWorkWithDependentWork">
    /// Should the replenishment work that has dependent work be canceled? Optional.
    /// </param>
    /// <param name = "_cancellingProductReceipt">
    /// true if product receipt is being cancelled, otherwise, false.
    /// </param>
    /// <param name = "_decrementLoadLineWorkCreatedQty">
    /// true if load lines work created quantity is being decremented, otherwise, false.
    /// </param>
    public static void performWorkCancelation(
        WHSWorkTable _workTable,
        boolean      _allowCancelClosed = false,
        UnknownNoYes _cancelReplenishmentWorkWithDependentWork = UnknownNoYes::Unknown,
        boolean      _cancellingProductReceipt = false,
        boolean      _decrementLoadLineWorkCreatedQty = true)
    {
        ttsbegin;

        // If this is a Replenishment work we are cancelling, and it has linked demand work, we need to cancel that too.
        if (_workTable.WorkTransType == WHSWorkTransType::Replenishment && WHSWorkTable::isWorkLinkedToActiveDemandWork(_workTable.WorkId))
        {
            WHSWorkTable::cancelDemandWork(_workTable.WorkId);
        }

        // Set the Work Header record to Cancelled.
        _workTable = WHSWorkTable::updateWorkStatusToCancelled(_workTable.WorkId);

        // Delete all of the WIT's for all non executed Work lines
        // If we hit a partially executed WIT it should throw an error during delete.
        WHSWorkInventTrans workInventTrans;
        while select forupdate workInventTrans
            where workInventTrans.WorkId                == _workTable.WorkId
                  && workInventTrans.InventQtyRemain    > 0
        {
            workInventTrans.delete();
        }

        // Delete all of the Dim Tracking records for the Cancelled lines.
        WHSDimTracking dimTracking;
        delete_from dimTracking
            where dimTracking.WorkId == _workTable.WorkId;

        // Remove the Has Reservation flag from the WIT's.
        update_recordset workInventTrans
            setting WorkHasReservation = NoYes::No
            where workInventTrans.WorkId == _workTable.WorkId;

        // Delete all of the Quality Order Inventory records related to Cancelled work.
        WHSQualityOrderInventory::deleteInventoryAtWorkCancel(_workTable);

        // Delete qualifying sort positions tied to work.
        if (_workTable.WaveId)
        {
            WHSOutboundSortPosition::deleteSortPositionsForCancelledWork(_workTable.WorkId);
        }

        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(_workTable.WorkTransType);
        if (workTransactionType)
        {
            workTransactionType.parmDecrementLoadLineWorkCreatedQty(_decrementLoadLineWorkCreatedQty);
            workTransactionType.cancelWork(_workTable, _cancellingProductReceipt);
        }
        
        WHSWorkTable::updateOrderCommittedReservation(_workTable.WorkId);
		
        // Set all Work Lines that are not complete to Cancelled and flush remain qty.
        WHSWorkLine workLine;
        update_recordset workLine
            setting WorkStatus      = WHSWorkStatus::Cancelled,
                    InventQtyRemain = 0,
                    QtyRemain       = 0,
                    CapturedWeight  = 0
            where workLine.WorkId           == _workTable.WorkId
                   && workLine.WorkStatus   <= WHSWorkStatus::InProcess;

        if (_allowCancelClosed)
        {
            // Does not clear CapturedWeight in order to keep track of weight for cancelled work.
            update_recordset workLine
            setting WorkStatus      = WHSWorkStatus::Cancelled,
                    InventQtyRemain = 0,
                    QtyRemain       = 0
                where workLine.WorkId           == _workTable.WorkId
                      && (workLine.WorkStatus    == WHSWorkStatus::Closed
                         || workLine.WorkStatus == WHSWorkStatus::Combined);
        }

        WHSCloseCluster::closeClusterWithNoOpenOrInProcessWorkAfterCancellingWork(_workTable.WorkId);

        // Determine and close the container if there is no workline associated with container.
        WHSContainerTable::determineContainerClose(_workTable.WorkId);

        if (_workTable.canWorkTransTypeUseStagingOverPick())
        {
            WHSWorkFrozen::clearFrozenLinksForWork(_workTable.WorkId);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrderCommittedReservation</Name>
				<Source><![CDATA[
    private static void updateOrderCommittedReservation(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

		//don't expect more than one workLine with the same InventTransId, OrderCommitedInventDimId (in most cases).
        while select InventTransId, OrderCommittedInventDimId, sum(InventQtyWork) from workLine
            group by InventTransId, OrderCommittedInventDimId
			where workLine.WorkId           == _workId
				&& workLine.WorkStatus		== WHSWorkStatus::Closed
				&& workLine.WorkType		== WHSWorkType::Pick
				&& workLine.OrderCommittedInventDimId
        {
            WHSOrderCommittedReservationFacade::updateOrderCommittedReservation(workLine.InventTransId,
                                                                                workLine.OrderCommittedInventDimId,
                                                                                workLine.InventQtyWork);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels the specified work, and ensures the correct state.
    /// </summary>
    /// <param name = "_workId">
    /// The Work ID to cancel.
    /// </param>
    /// <param name = "_throwError">
    /// true if the method should throw an error on failure, otherwise, false.
    /// </param>
    /// <param name = "_allowCancelClosed">
    /// true if cancelling of closed work is allowed, otherwise, false.
    /// </param>
    /// <param name = "_cancelReplenishmentWorkWithDependentWork">
    /// Should the replenishment work that has dependent work be canceled? Optional.
    /// </param>
    /// <param name = "_cancellingProductReceipt">
    /// true if product receipt is being cancelled, otherwise, false.
    /// </param>
    /// <param name = "_decrementLoadLineWorkCreatedQty">
    /// true if load lines work created quantity is being decremented, otherwise, false.
    /// </param>
    /// <returns>
    /// true, if the work was cancelled successfully; otherwise, false.
    /// </returns>
    public static boolean cancelWork(
        WHSWorkId    _workId,
        boolean      _throwError = true,
        boolean      _allowCancelClosed = false,
        UnknownNoYes _cancelReplenishmentWorkWithDependentWork = UnknownNoYes::Unknown,
        boolean      _cancellingProductReceipt = false,
        boolean      _decrementLoadLineWorkCreatedQty = true)
    {
        WHSWorkTable    workTable;
        boolean         doReturn;

        [doReturn, workTable] = WHSWorkTable::initCancelWork(_workId, _allowCancelClosed, _cancelReplenishmentWorkWithDependentWork);

        if (doReturn)
        {
            return false;
        }

        WHSWorkTable::performWorkCancelation(workTable, _allowCancelClosed, _cancelReplenishmentWorkWithDependentWork, _cancellingProductReceipt, _decrementLoadLineWorkCreatedQty);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelWorkValidateWorkNotAssignedToActiveCluster</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels the specified work, ensures the correct state and validates before cancelling that the work is not associated to a cluster locked by user.
    /// </summary>
    /// <param name = "_workId">
    /// The Work ID to cancel.   
    /// <param name = "_cancelReplenishmentWorkWithDependentWork">
    /// Should the replenishment work that has dependent work be canceled? Optional.
    /// <returns>
    /// true, if the work was cancelled successfully; otherwise, false.
    /// </returns>
    [Hookable(false)]
    internal static boolean cancelWorkValidateWorkNotAssignedToActiveCluster(WHSWorkId _workId, UnknownNoYes _cancelReplenishmentWorkWithDependentWork = UnknownNoYes::Unknown)
    {
        if (!WHSWorkTable::validateWorkNotAssociatedToClusterLockedByUser(_workId))
        {
            return false;
        }

        return WHSWorkTable::cancelWork(_workId,
            true,
            false,
            _cancelReplenishmentWorkWithDependentWork);       
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelWorkForWorkBuildId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Cancels all work for a given work build ID.
    /// </summary>
    /// <param name="_whsWorkBuildId">
    ///    The work build ID to cancel work for.
    /// </param>
    public static void cancelWorkForWorkBuildId(WHSWorkBuildId _whsWorkBuildId)
    {
        WHSWorkTable    whsWorkTable;

        ttsbegin;
        while select WorkId from whsWorkTable
            where whsWorkTable.WorkBuildId == _whsWorkBuildId
               && whsWorkTable.WorkStatus  != WHSWorkStatus::Cancelled
        {
            WHSWorkTable::cancelWork(whsWorkTable.WorkId);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>combineWork</Name>
				<Source><![CDATA[
    public static void combineWork(WHSWorkId  _targetWorkId,
                                   WHSWorkId  _combinedWorkId)
    {
        WHSWorkTable        targetWorkTable;
        WHSWorkTable        combinedWorkTable;
        WHSWorkLine         combinedWorkLine;
        WHSWorkLine         newWorkLine;
        WHSWorkLine         targetWorkLine;
        LineNum             numPicks;
        LineNum             i;
        LineNum             oldTargetLineNum;
        Qty                 qtyWork;
        WHSWorkInventTrans  tmpCombinedWorkInventTrans;
        WHSWorkInventTrans  combinedWorkInventTrans;
        boolean             itemCleared;
        boolean             incremented;
        boolean             found;
        boolean             noUnit;
        boolean             noDim;
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        ttsbegin;

        targetWorkTable     = WHSWorkTable::find(_targetWorkId);
        combinedWorkTable   = WHSWorkTable::find(_combinedWorkId, true);

        // Update the Work header record being combined.
        combinedWorkTable.WorkStatus     = WHSWorkStatus::Combined;
        combinedWorkTable.CombinedWorkId = _targetWorkId;
        combinedWorkTable.update();

        // Update the combined Work line records.
        while select forupdate combinedWorkLine
            order by LineNum
            where combinedWorkLine.WorkId == _combinedWorkId
        {
            if (!newWorkLine.WorkId)
            {
                buf2Buf(combinedWorkLine, newWorkLine);
            }

            combinedWorkLine.WorkStatus = WHSWorkStatus::Closed;
            combinedWorkLine.update();
        }

        numPicks = targetWorkTable.countFirstPicks();
        i = numPicks + 1;

        // Store off the pick WIT from the combined work.
        select forupdate tmpCombinedWorkInventTrans
            where tmpCombinedWorkInventTrans.WorkId == _combinedWorkId  &&
                  tmpCombinedWorkInventTrans.LineNum   == 1;

        // Remove old Work Invent Trans records.
        combinedWorkInventTrans.clear();
        while select forupdate combinedWorkInventTrans
            where combinedWorkInventTrans.WorkId == _combinedWorkId  &&
                  combinedWorkInventTrans.LineNum    > 1
        {
            if (!combinedWorkInventTrans.validateDelete())
            {
                throw error(strFmt("@WAX:WHSCannotDeleteRecordInTable", tablePName(WHSWorkInventTrans)));
            }
            else
            {
                combinedWorkInventTrans.delete();
            }
        }

        // Renumber the Work lines.
        while select forupdate targetWorkLine
            order by LineNum desc
            where targetWorkLine.WorkId == _targetWorkId &&
                  targetWorkLine.LineNum    > numPicks
        {
            oldTargetLineNum = targetWorkLine.LineNum;

            if (releasedProductUnitConverter.canBeConverted(UnitOfMeasure::unitOfMeasureIdBySymbol(newWorkLine.UnitId),
                                                       UnitOfMeasure::unitOfMeasureIdBySymbol(targetWorkLine.UnitId),
                                                            newWorkLine.ItemId,
                                                            newWorkLine.InventDimId))
            {
                qtyWork = releasedProductUnitConverter.convert(newWorkLine.QtyWork,
                                                          UnitOfMeasure::unitOfMeasureIdBySymbol(newWorkLine.UnitId),
                                                          UnitOfMeasure::unitOfMeasureIdBySymbol(targetWorkLine.UnitId),
                                                          NoYes::No,
                                                               newWorkLine.ItemId,
                                                               newWorkLine.InventDimId,
                                                          NoYes::No);
            }
            else
            {
                qtyWork = newWorkLine.QtyWork;
                noUnit  = true;
            }

            if (!InventDim::isInventDimEqual(newWorkLine.inventDim(), targetWorkLine.inventDim()))
            {
                noDim = true;
            }

            ++targetWorkLine.LineNum;
            targetWorkLine.InventQtyRemain  += newWorkLine.InventQtyWork;
            targetWorkLine.InventQtyWork    += newWorkLine.InventQtyWork;
            targetWorkLine.QtyRemain        += qtyWork;
            targetWorkLine.QtyWork          += qtyWork;
            if (noUnit)
            {
                targetWorkLine.UnitId       = '';
            }
            if (noDim)
            {
                targetWorkLine.InventDimId  = '';
            }
            if (newWorkLine.InventTransId != targetWorkLine.InventTransId)
            {
                targetWorkLine.InventTransId = '';
            }
            targetWorkLine.update();

            [itemCleared, incremented, found] = WHSWorkTable::updateWorkInventTrans(_combinedWorkId, combinedWorkTable, newWorkLine, targetWorkLine, oldTargetLineNum);

            WHSWorkTable::incrementedAndFound(_combinedWorkId, incremented, found, combinedWorkTable, targetWorkLine, itemCleared);

            found = false;
        }

        WHSWorkTable::finishCombineWork(_targetWorkId, _combinedWorkId, targetWorkTable, combinedWorkTable, newWorkLine, numPicks);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countWorkHeaders</Name>
				<Source><![CDATA[
    public static int countWorkHeaders(WHSWorkBuildId _workBuildId)
    {
        return _workBuildId ? any2int((select count(RecId) from whsWorkTable
                                            where whsWorkTable.WorkBuildId == _workBuildId).RecId) : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchaseOrderQualityItemSamplingWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the work is quality item sampling work and if it is created from a purchase order receiving process.
    /// </summary>
    /// <returns>true if the work is quality item sampling work and is linked to a purchase order; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean isPurchaseOrderQualityItemSamplingWork()
    {
        boolean isCreatedFromPurchaseOrder = false;

        if (this.WorkTransType == WHSWorkTransType::QualityItemSampling)
        {
            // In case the quality association is defined to "Create work only", the
            // InventQualityOrderId field value is not set on the Work table. So
            // determine the source document type from the work line.
            WHSWorkLine workLine;
            select firstonly InventTransId from workLine
                where workLine.WorkId == this.WorkId
                    && workLine.OrderNum == this.OrderNum;

            if (InventTransOrigin::findByInventTransId(workLine.InventTransId).ReferenceCategory == InventTransType::Purch)
            {
                isCreatedFromPurchaseOrder = true;
            }
        }

        return isCreatedFromPurchaseOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>decreaseLoadLineWorkCreatedQtyForPurchaseWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decreases WorkCreatedQty for a load line associated with the purchase work.
    /// </summary>
    public void decreaseLoadLineWorkCreatedQtyForPurchaseWork()
    {
        if (!this.canDecreaseLoadLineWorkCreatedQtyForInboundWork()
            && !this.isPurchaseOrderQualityItemSamplingWork())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        ttsbegin;

        WHSWorkLine workLine;

        while select sum(InventQtyWork) from workLine
            group by LoadLineRefRecId
            where workLine.WorkId           == this.WorkId
            &&    workLine.WorkStatus       != WHSWorkStatus::Cancelled
            &&    workLine.LoadLineRefRecId != 0
        {
            WHSLoadLine loadLine = WHSLoadLine::findbyRecId(workLine.LoadLineRefRecId, true);
            loadLine.WorkCreatedQty -= workLine.InventQtyWork;
            loadLine.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDecreaseLoadLineWorkCreatedQtyForInboundWork</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean canDecreaseLoadLineWorkCreatedQtyForInboundWork()
    {
        return this.WorkTransType == WHSWorkTransType::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWorkLineAndCleanupRemainingLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete the specified work line and clean up the remaining work lines.
    /// Also update the <c>WorkCreatedQty</c> on the corresponding load line.
    /// </summary>
    /// <param name = "_workLine">Work line to delete.</param>
    public static void deleteWorkLineAndCleanupRemainingLines(WHSWorkLine _workLine)
    {
        ttsbegin;

        WHSLoadLine::decrementWorkCreatedQty(_workLine.LoadLineRefRecId, _workLine.InventQtyWork, _workLine.whsWorkTable().WaveId);

        WHSWorkId workId = _workLine.WorkId;
        LineNum deletedLineNum = _workLine.LineNum;
        if (!_workLine.validateDelete())
        {
            throw error(strFmt("@WAX:WHSCannotDeleteRecordInTable", tablePName(WHSWorkLine)));
        }
        else
        {
            _workLine.delete();
        }

        WHSWorkLineCache::remove(workId);

        // Renumber the Work Lines
        WHSWorkLine cleanupWorkLine;
        LineNum     lineNum;
        while select forupdate cleanupWorkLine
            order by LineNum
            where cleanupWorkLine.WorkId == workId
        {
            ++lineNum;
            LineNum lineNumOrig = cleanupWorkLine.LineNum;
            cleanupWorkLine.LineNum = lineNum;
            cleanupWorkLine.update();

            if (lineNumOrig != cleanupWorkLine.LineNum)
            {
                cleanupWorkLine.updateRelatedTablesLineNum(cleanupWorkLine.WorkId, lineNumOrig);
            }
        }

        LineNum                 lastPickLineNum;
        ItemId                  itemId;
        UnitOfMeasureSymbol     unitId;
        InventDimId             inventDimId;
        InventTransId           inventTransId;
        Qty                     qtyWork;
        InventQty               inventQtyWork;
        // Determine what needs to be updated on the rest of the work
        [itemId, unitId, inventDimId, inventTransId,
            qtyWork, inventQtyWork, lastPickLineNum] = WHSWorkTable::setFields(workId);

        // Update the rest of the work
        cleanupWorkLine.skipDataMethods(true);
        update_recordset cleanupWorkLine
            setting ItemId          = itemId,
                    UnitId          = unitId,
                    InventDimId     = inventDimId,
                    InventTransId   = inventTransId,
                    QtyWork         = qtyWork,
                    QtyRemain       = qtyWork,
                    InventQtyWork   = inventQtyWork,
                    InventQtyRemain = inventQtyWork
            where cleanupWorkLine.WorkId    == workId
               && cleanupWorkLine.LineNum   >  lastPickLineNum;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAndCleanupWorkLines</Name>
				<Source><![CDATA[
    [SysObsolete('Use deleteWorkLineAndCleanupRemainingLines instead.', false, 30\11\2017)]
    public static void deleteAndCleanupWorkLines(WHSWorkLine _workLine, WHSLoadLine _loadLine)
    {
        WHSWorkTable::deleteWorkLineAndCleanupRemainingLines(_workLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeWorkLinesInit</Name>
				<Source><![CDATA[
    private static container executeWorkLinesInit(WHSWorkLine _workLine,
                                                  RecId       _prevRecId,
                                                  int         _i)
    {
        #define.RetryNum(50)
        WHSWorkLine workLine = _workLine;
        RecId       prevRecId = _prevRecId;
        int         i = _i;
        boolean     doReturn = false;

        if (prevRecId && workLine.RecId == prevRecId)
        {
            ++i;

            if (i == #RetryNum)
            {
                error("@WAX4100");
                doReturn = true;
                return [doReturn, i];
            }
        }

        // There is no Location on the Work.
        if (workLine.WorkType != WHSWorkType::Print && !workLine.wmsLocationId)
        {
            error("@WAX2160");
            doReturn = true;
            return [doReturn, i];
        }

        return [doReturn, i];
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    public static boolean exist(WHSWorkId _workId)
    {
        return _workId &&
               (select firstonly RecId from whsWorkTable
                where whsWorkTable.WorkId == _workId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsForCycleCountPlanOverview</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether or not the Work Details option should be enabled based on associated work records.
    /// </summary>
    /// <param name="_cycleCoundPlanOverview">
    /// Cycle count plan overview record.
    /// </param>
    /// <returns>
    /// True/False indicating if work is tied to cycle count plan overview.
    /// </returns>
    public static boolean existsForCycleCountPlanOverview(WHSCycleCountPlanOverview _cycleCoundPlanOverview)
    {
        WHSWorkTable        workTable;

        select firstonly RecId from workTable
            where workTable.CycleCountPlanOverview == _cycleCoundPlanOverview.RecId;

        return workTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    public static WHSWorkTable find(WHSWorkId _workId,
                                    boolean   _forupdate = false)
    {
        WHSWorkTable    workTable;

        if (_workId)
        {
            workTable.selectForUpdate(_forupdate);

            select firstonly workTable
                where workTable.WorkId == _workId;
        }

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByTargetLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the work order header record by its target license plate Id.
    /// </summary>
    /// <param name = "_targetLicensePlateId">Target license plate Id.</param>
    /// <param name = "_maxWorkStatus">Maximal work status when searching for the work record; optional.</param>
    /// <param name = "_forUpdate">true, if the record should be selected for update; otherwise, false.</param>
    /// <returns>A record in the <c>WHSWorkTable</c> table; otherwise, an empty record.</returns>
    public static WHSWorkTable findByTargetLicensePlate(WHSLicensePlateId _targetLicensePlateId, WHSWorkStatus _maxWorkStatus = WHSWorkStatus::PendingReview, boolean _forUpdate = false)
    {
        WHSWorkTable workTable;

        workTable.selectForUpdate(_forUpdate);

        if (_targetLicensePlateId)
        {
            select firstonly workTable
                where workTable.TargetLicensePlateId == _targetLicensePlateId
                    && workTable.WorkStatus <= _maxWorkStatus;
        }

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfWorksForTargetLicensePlateAndMaxWorkStatus</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static NumberOfRecords numberOfWorksForTargetLicensePlateAndMaxWorkStatus(WHSLicensePlateId _targetLicensePlateId, WHSWorkStatus _maxWorkStatus)
    {
        WHSWorkTable workTable;

        if (_targetLicensePlateId)
        {
            select count(RecId) from workTable
                where workTable.TargetLicensePlateId == _targetLicensePlateId
                && workTable.WorkStatus <= _maxWorkStatus;
        }

        return workTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>WHSWorkTable</c> table by license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// The license plate ID.
    /// </param>
    /// <param name="_findByLocatedLP">
    /// A Boolean value that indicates whether to look at Located LP field of the record; optional.
    /// </param>
    /// <param name="_maxWorkStatus">
    /// A work status value that indicates maximal work status to query the <c>WHSWorkTable</c> record; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>WHSWorkTable</c> table; otherwise, an empty record.
    /// </returns>
    public static WHSWorkTable findByLicensePlate(
        WHSLicensePlateId   _licensePlateId,
        boolean             _findByLocatedLP    = false,
        WHSWorkStatus       _maxWorkStatus      = WHSWorkStatus::PendingReview)
    {
        return WHSWorkTable::findByLicensePlateForUpdate(_licensePlateId, _findByLocatedLP, _maxWorkStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByLicensePlateForUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>WHSWorkTable</c> table by license plate.
    /// </summary>
    /// <param name="_licensePlateId">
    /// The license plate ID.
    /// </param>
    /// <param name="_findByLocatedLP">
    /// A Boolean value that indicates whether to look at Located LP field of the record; optional.
    /// </param>
    /// <param name="_maxWorkStatus">
    /// A work status value that indicates maximal work status to query the <c>WHSWorkTable</c> record; optional.
    /// </param>
    /// <param name = "_forUpdate">
    /// True, if the record should be selected for update; otherwise, false.
    /// </param>
    /// <returns>
    /// A record in the <c>WHSWorkTable</c> table; otherwise, an empty record.
    /// </returns>
    public static WHSWorkTable findByLicensePlateForUpdate(
        WHSLicensePlateId   _licensePlateId,
        boolean             _findByLocatedLP    = false,
        WHSWorkStatus       _maxWorkStatus      = WHSWorkStatus::PendingReview,
        boolean             _forUpdate          = false)
    {
        WHSWorkTable workTable;

        if (_licensePlateId)
        {
            workTable = WHSWorkTable::findByTargetLicensePlate(_licensePlateId, _maxWorkStatus, _forUpdate);

            if (!workTable && _findByLocatedLP)
            {
                WHSWorkLine workLine;

                workTable.selectForUpdate(_forUpdate);

                select firstonly WorkId from workLine
                    where workLine.LocatedLPId      == _licensePlateId
                    join workTable
                    where  workTable.WorkId         == workLine.WorkId
                        && workTable.WorkStatus     <= _maxWorkStatus;

                if (!workTable)
                {
                    workTable = WHSWorkTable::findByLicensePlateUsingWorkInventTrans(_licensePlateId, _forUpdate);
                }
            }
        }

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByLicensePlateUsingWorkInventTrans</Name>
				<Source><![CDATA[
    private static WHSWorkTable findByLicensePlateUsingWorkInventTrans(
        WHSLicensePlateId   _licensePlateId,
        boolean             _forUpdate)
    {
        WHSWorkTable workTable;

        if (_licensePlateId)
        {
            WHSWorkInventTrans  workInventTrans;
            InventDim           inventDim;
            WHSWorkLine         workLine;

            workTable.selectForUpdate(_forUpdate);

            select firstonly workTable
                where  workTable.TargetLicensePlateId   == ''
                    && workTable.WorkStatus             == WHSWorkStatus::Open
            exists join workLine
                where  workLine.WorkId                      == workTable.WorkId
                    && workLine.OrderCommittedInventDimId   != ''
            exists join workInventTrans
                where workInventTrans.WorkId == workTable.WorkId
            exists join inventDim
                where  inventDim.inventDimId    == workInventTrans.InventDimIdFrom
                    && inventDim.LicensePlateId == _licensePlateId;
        }

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByTargetLicensePlateContainerLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the work order header record by its target license plate and container line.
    /// </summary>
    /// <param name = "_targetLicensePlateId">Target license plate Id.</param>
    /// <param name = "_containerLineRecId">The RecId of <c>WHSContainerLine</c>.</param>
    /// <param name = "_maxWorkStatus">Maximal work status when searching for the work record; optional.</param>
    /// <param name = "_forUpdate">true, if the record should be selected for update; otherwise, false.</param>
    /// <returns>A record in the <c>WHSWorkTable</c> table; otherwise, an empty record.</returns>
    public static WHSWorkTable findByTargetLicensePlateContainerLine(
        WHSLicensePlateId _targetLicensePlateId,
        RecId             _containerLineRecId,
        WHSWorkStatus     _maxWorkStatus         = WHSWorkStatus::PendingReview,
        boolean           _forUpdate             = false)
    {
        WHSWorkTable workTable;
        WHSWorkLine workLine;
        WHSContainerLine containerLine;

        if (_targetLicensePlateId && _containerLineRecId)
        {
            workTable.selectForUpdate(_forUpdate);

            select firstonly forceselectorder RecId from containerLine
                where containerLine.RecId           == _containerLineRecId
            join TableId from workLine
                where workLine.LoadLineRefRecId     == containerLine.LoadLine
            join workTable
                where workTable.WorkId              == workLine.WorkId
                  && workTable.TargetLicensePlateId == _targetLicensePlateId
                  && workTable.WorkStatus           <= _maxWorkStatus;
        }

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByContainerLineLocatedLP</Name>
				<Source><![CDATA[
    private static WHSWorkTable findByContainerLineLocatedLP(
        WHSLicensePlateId   _licensePlateId,
        RecId               _containerLineRecId,
        WHSWorkStatus       _maxWorkStatus      = WHSWorkStatus::PendingReview,
        boolean             _forUpdate          = false)
    {
        WHSWorkTable     workTable;
        WHSWorkLine      workLine;
        WHSContainerLine containerLine;

        workTable.selectForUpdate(_forUpdate);

        select firstonly forceselectorder RecId from containerLine
            where containerLine.RecId       == _containerLineRecId
        join TableId from workLine
            where workLine.LoadLineRefRecId == containerLine.LoadLine
                && workLine.LocatedLPId     == _licensePlateId
        join workTable
            where workTable.WorkId          == workLine.WorkId
                && workTable.WorkStatus     <= _maxWorkStatus;

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByContainerLineLocatedLPWorkTransLP</Name>
				<Source><![CDATA[
    private static WHSWorkTable findByContainerLineLocatedLPWorkTransLP(
        WHSLicensePlateId   _licensePlateId,
        RecId               _containerLineRecId,
        WHSWorkStatus       _maxWorkStatus      = WHSWorkStatus::PendingReview,
        boolean             _forUpdate          = false)
    {
        WHSWorkTable     workTable;
        WHSWorkLine      workLine;
        WHSContainerLine containerLine;
        WHSWorkTrans     workTrans;
        InventDim        inventDim;

        workTable.selectForUpdate(_forUpdate);

        if (WHSPopulateSourceAndTargetLPOnWHSWorkTransFeature::instance().isEnabled()
            || WHSConsumeTargetLPFromWHSWorkTransFlight::instance().isEnabled())
        {
            select firstonly forceselectorder RecId from containerLine
                where containerLine.RecId       == _containerLineRecId
            join TableId from workLine
                where workLine.LoadLineRefRecId == containerLine.LoadLine
                    && workLine.LocatedLPId     == _licensePlateId
            join workTable
                where workTable.WorkId          == workLine.WorkId
                    && workTable.WorkStatus     <= _maxWorkStatus
            exists join workTrans
                where workTrans.WorkId == workTable.WorkId
                    && workTrans.LineNum == workLine.LineNum
                    && workTrans.TargetLicensePlateId == _licensePlateId;
        }
        else
        {
            select firstonly forceselectorder RecId from containerLine
                where containerLine.RecId       == _containerLineRecId
            join TableId from workLine
                where workLine.LoadLineRefRecId == containerLine.LoadLine
                    && workLine.LocatedLPId     == _licensePlateId
            join workTable
                where workTable.WorkId          == workLine.WorkId
                    && workTable.WorkStatus     <= _maxWorkStatus
            exists join workTrans
                where workTrans.WorkId          == workTable.WorkId
                    && workTrans.LineNum        == workLine.LineNum
            exists join inventDim
                where inventDim.InventDimId     == workTrans.InventDimId
                    && inventDim.LicensePlateId == _licensePlateId;
        }

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByLicensePlateContainerLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>WHSWorkTable</c> table by license plate and container line.
    /// </summary>
    /// <param name = "_licensePlateId">
    /// The license plate ID.
    /// </param>
    /// <param name = "_containerLineRecId">
    /// The RecId of <c>WHSContainerLine</c>.
    /// </param>
    /// <param name = "_findByLocatedLP">
    /// A Boolean value that indicates whether to look at Located LP field of the record; optional.
    /// </param>
    /// <param name = "_maxWorkStatus">
    /// A work status value that indicates maximal work status to query the <c>WHSWorkTable</c> record; optional.
    /// </param>
    /// <param name = "_forUpdate">
    /// True, if the record should be selected for update; otherwise, false.
    /// </param>
    /// <returns>
    /// A record in the <c>WHSWorkTable</c> table; otherwise, an empty record.
    /// </returns>
    public static WHSWorkTable findByLicensePlateContainerLine(
        WHSLicensePlateId   _licensePlateId,
        RecId               _containerLineRecId,
        boolean             _findByLocatedLP    = false,
        WHSWorkStatus       _maxWorkStatus      = WHSWorkStatus::PendingReview,
        boolean             _forUpdate          = false)
    {
        WHSWorkTable workTable;

        if (_licensePlateId
            && _containerLineRecId)
        {
            workTable = WHSWorkTable::findByTargetLicensePlateContainerLine(_licensePlateId, _containerLineRecId, _maxWorkStatus, _forUpdate);
                
            if (!workTable && _findByLocatedLP)
            {
                workTable = WHSWorkTable::findByContainerLineLocatedLP(_licensePlateId, _containerLineRecId, _maxWorkStatus, _forUpdate);
            }

            if (!workTable)
            {
                workTable = WHSWorkTable::findByContainerLineLocatedLPWorkTransLP(_licensePlateId, _containerLineRecId, _maxWorkStatus, _forUpdate);
            }
        }
        else
        {
            workTable = WHSWorkTable::findByLicensePlateForUpdate(_licensePlateId, _findByLocatedLP, _maxWorkStatus, _forUpdate);
        }

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCycleCountByLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds open cycle count work for a location
    /// </summary>
    /// <param name="_inventLocationId">
    /// The warehouse to check
    /// </param>
    /// <param name="_locationId">
    /// The location to check
    /// </param>
    /// <returns>
    /// Id of the cycle counting work, if any
    /// </returns>
    static WHSWorkId findCycleCountByLocation(InventLocationId  _inventLocationId,
                                              WMSLocationId     _locationId)
    {
        WHSWorkTable    workTable;
        WHSWorkLine     workLine;

        select firstonly WorkId from workLine
            exists join workTable
            where workLine.WorkId            == workTable.WorkId             &&
                  workTable.InventLocationId == _inventLocationId            &&
                  workTable.WorkTransType    == WHSWorkTransType::CycleCount &&
                  workLine.wmsLocationId     == _locationId                  &&
                  workTable.WorkStatus       == WHSWorkStatus::Open;

        return workLine.WorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finishCombineWork</Name>
				<Source><![CDATA[
    private static void finishCombineWork(WHSWorkId           _targetWorkId,
                                          WHSWorkId           _combinedWorkId,
                                          WHSWorkTable        _targetWorkTable,
                                          WHSWorkTable        _combinedWorkTable,
                                          WHSWorkLine         _newWorkLine,
                                          LineNum             _numPicks)
    {
        WHSWorkTable        targetWorkTable = _targetWorkTable;
        WHSWorkTable        combinedWorkTable = _combinedWorkTable;
        WHSWorkLine         newWorkLine = _newWorkLine;
        LineNum             numPicks = _numPicks;
        WHSDimTracking      dimTracking;
        WHSWorkFrozen       workFrozen;
        WHSWorkFrozen       targetWorkFrozen;

        // Update the Combined Dim Tracking records if they exists
        update_recordset dimTracking
            setting WorkId  = _targetWorkId,
                    LineNum = numPicks + 1
            where dimTracking.WorkId    == _combinedWorkId
               && dimTracking.LineNum   == newWorkLine.LineNum;

        newWorkLine.WorkId   = _targetWorkId;
        newWorkLine.LineNum  = numPicks + 1;
        
        if (!newWorkLine.validateWrite())
        {
            throw error(strFmt("@WAX:WHSCannotInsertRecordInTable", tablePName(WHSWorkLine)));
        }
        else
        {
            newWorkLine.insert();
        }

        WHSWorkLineCache::remove(_targetWorkId);

        // Update the LineNum of previous pick WIT
        WHSWorkInventTrans::moveToNewWorkLine(newWorkLine.WorkId, newWorkLine.LineNum, newWorkLine.WorkId, newWorkLine.LineNum + 1);

        // Create the new pick Work Invent Trans records.
        WHSWorkInventTrans::moveToNewWorkLine(_combinedWorkId, 1, newWorkLine.WorkId, newWorkLine.LineNum);

        // Ensure the item sets on put lines are properly set.
        WHSWorkTable::rebuildItemSetOnPutLinesBasedOnPreviousPicks(_targetWorkId);

        // Update any WHSWorkFrozen records
        while select forupdate workFrozen
            where workFrozen.WorkId == combinedWorkTable.WorkId
        {
            targetWorkFrozen = WHSWorkFrozen::find(targetWorkFrozen.WorkId, workFrozen.FrozenWorkId, workFrozen.InventTransId, workFrozen.FrozenWorkInventDimId);
            
            if (targetWorkFrozen.RecId != 0)
            {
                targetWorkFrozen.Qty += workFrozen.Qty;
                
                targetWorkFrozen.update();

                if (!workFrozen.validateDelete())
                {
                    throw error(strFmt("@WAX:WHSCannotDeleteRecordInTable", tablePName(WHSWorkFrozen)));
                }
                else
                {
                    workFrozen.delete();
                }
            }
            else
            {
                workFrozen.WorkId = targetWorkTable.WorkId; 
                workFrozen.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rebuildItemSetOnPutLinesBasedOnPreviousPicks</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void rebuildItemSetOnPutLinesBasedOnPreviousPicks(WHSWorkId _workId)
    {
        WHSWorkInventTrans workInventTrans;
        WHSWorkLine workLine;

        while select WorkId, LineNum from workLine
            where  workLine.WorkId == _workId
                && workLine.WorkType == WHSWorkType::Put
                && workLine.WorkStatus != WHSWorkStatus::Closed
                && workLine.WorkStatus != WHSWorkStatus::Cancelled
                && workLine.WorkStatus != WHSWorkStatus::Combined
            exists join workInventTrans
                where workInventTrans.WorkId == workLine.WorkId
                    && workInventTrans.LineNum == workLine.LineNum
        {
            WHSWorkLine::rebuildItemSetOnPutLineBasedOnPreviousPicks(workLine.WorkId, workLine.LineNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultingDependencies</Name>
				<Source><![CDATA[
    public container getDefaultingDependencies()
    {
        return [
            [fieldNum(WHSWorkTable, Frozen),
                [fieldNum(WHSWorkTable, ReplenishmentDependentWorkBlockingPolicy)]]
        ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    public void defaultField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(WHSWorkTable, Frozen):
                if (!this.Frozen
                    && this.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::EntireWorkOrder
                    && this.hasUnFinishedReplenWork())
                {
                    this.Frozen = NoYes::Yes;
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtension</Name>
				<Source><![CDATA[
    public TableExtension getExtension()
    {
        return SysTableExtension::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>freezeOrUnfreezeWork</Name>
				<Source><![CDATA[
    public static void freezeOrUnfreezeWork(WHSWorkId   _workId,
                                            boolean     _force = false)
    { 
        WHSWorkTable workTable = WHSWorkTable::find(_workId);
        
        WHSWorkId workFrozenId = workTable.firstUnProcessedRelatedStagingPickWorkId();

        if (workFrozenId)
        {
            error(strFmt("@WAX3103", workFrozenId));
            return;
        }
        
        ttsbegin;

        if (_workId)
        {
            workTable = WHSWorkTable::find(_workId, true);

            workTable.canBeUnBlockedThrowOnError();

            WHSWorkLine     workLine;
            select firstonly WorkId, LineNum from workLine
                where workLine.WorkId        == _workId      &&
                        workLine.Skipped       == NoYes::No    &&
                        workLine.WorkStatus     < WHSWorkStatus::Skipped;

            if (!_force && workTable.WorkStatus != WHSWorkStatus::Open && !WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum))
            {
                throw error("@WAX3722");
            }

            if (workTable.RecId > 0)
            {
                workTable.Frozen = !workTable.Frozen;
                workTable.update();

                // Update Wave Status.
                // If any headers are unfrozen than the status should be released.
                // If all headers are frozen than the status should be held.
                WHSWaveTable waveTable = WHSWaveTable::find(workTable.WaveId, true);

                if (waveTable.RecId > 0 )
                {
                    WHSWorkTable    releasedWork;
                    select firstonly RecId from releasedWork
                        where releasedWork.WaveId        == workTable.WaveId &&
                                releasedWork.Frozen        == NoYes::No           &&
                                releasedWork.WorkStatus    != WHSWorkStatus::Cancelled;

                    waveTable.WaveStatus = releasedWork.RecId ? WHSWaveStatus::Released : WHSWaveStatus::Held;
                    waveTable.update();
                }

            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>freezeWorkWithReplen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark the work order as Frozen for the specified <c>WorkBuildId</c>.
    /// </summary>
    /// <param name = "_workBuildId">Work build Id.</param>
    /// <remarks>
    /// For work orders, where we freeze on the individual line level, do nothing.
    /// </remarks>
    public static void freezeWorkWithReplen(WHSWorkBuildId _workBuildId)
    {
        WHSReplenWorkLink   replenWorkLink;
        WHSWorkTable        workTable;
        WHSWorkTable        replenWorkTable;

        if (_workBuildId)
        {
            WHSWorkTable::freezeWorkWithReplenWorkBlocking(_workBuildId);            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>freezeWorkWithReplenWorkBlocking</Name>
				<Source><![CDATA[
    private static void freezeWorkWithReplenWorkBlocking(WHSWorkBuildId _workBuildId)
    {
        WHSReplenWorkLink   replenWorkLink;
        WHSWorkTable        workTable;
        WHSWorkTable        replenWorkTable;

        ttsbegin;

        while select WorkId from workTable
            where workTable.WorkBuildId  == _workBuildId
                && workTable.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::EntireWorkOrder
        exists join replenWorkLink
            where replenWorkLink.DemandWorkId == workTable.WorkId
        exists join replenWorkTable
            where replenWorkTable.WorkId       == replenWorkLink.ReplenWorkId
                && replenWorkTable.WorkStatus != WHSWorkStatus::Closed
                && replenWorkTable.WorkStatus != WHSWorkStatus::Cancelled
                && replenWorkTable.WorkStatus != WHSWorkStatus::Combined
        {
            WHSWorkBlocking::newFromWorkIdSkipInProgressWorkLineWithNoPreviousPutCheck(workTable.WorkId)
                .tryBlockWorkWithReasonType(WHSWorkBlockingReasonType::UnProcessedReplenishmentWork);
        }

        WHSWorkLine workLineWithContainer;
        // We don't want to risk mixing up containers so we don't allow starting a work with container lines even though the policy specifies it
        while select WorkId from workTable
            where workTable.WorkBuildId  == _workBuildId
                && workTable.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::IndividualWorkLine
        exists join workLineWithContainer
            where workLineWithContainer.WorkId == workTable.WorkId
                &&    workLineWithContainer.ContainerId != ''
        exists join replenWorkLink
            where replenWorkLink.DemandWorkId == workTable.WorkId
        exists join replenWorkTable
            where replenWorkTable.WorkId     == replenWorkLink.ReplenWorkId
                && replenWorkTable.WorkStatus != WHSWorkStatus::Closed
                && replenWorkTable.WorkStatus != WHSWorkStatus::Cancelled
                && replenWorkTable.WorkStatus != WHSWorkStatus::Combined
        {
            WHSWorkBlocking::newFromWorkIdSkipInProgressWorkLineWithNoPreviousPutCheck(workTable.WorkId)
                .tryBlockWorkWithReasonType(WHSWorkBlockingReasonType::UnProcessedReplenishmentWork);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasNoOtherOpenWorkForWorkBuildId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work is the last open work on the work build ID.
    /// </summary>
    /// <returns>
    /// true if the work build ID has no other open work; otherwise, false
    /// </returns>
    public boolean hasNoOtherOpenWorkForWorkBuildId()
    {
        WHSWorkTable workTable;

        select firstonly WorkId from workTable
            where workTable.WorkBuildId == this.workBuildId
            &&	  workTable.WorkStatus	== WHSWorkStatus::Open
            &&	  workTable.WorkId		!= this.workId;

        return !workTable.WorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstWorkLineOnOpenWorkByWorkBuildId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and returns the first open work line from a work build ID that is on open work.
    /// </summary>
    /// <param name = "_workBuildId">The work build ID being used.</param>
    /// <param name = "_userId">The user processing the work.</param>
    /// <returns>The first open work line if one exists; otherwise an empty buffer.</returns>
    public static WHSWorkLine getFirstWorkLineOnOpenWorkByWorkBuildId(
        WHSWorkBuildId	_workBuildId,
        WHSUserId		_userId)
    {
        WHSWorkLine     workLine;

        if (_workBuildId)
        {
            WHSWorkTable workTable;

            // We only want to select open work headers, an in process status would mean the work was already executed to a work stop.
            select firstonly WorkId from workTable
                where workTable.WorkBuildId == _workBuildId
                &&	  workTable.WorkStatus  == WHSWorkStatus::Open;

            if (workTable.WorkId)
            {
                WhsWorkExecute workExecute = WhsWorkExecute::construct();
                workLine = workExecute.getFirstOpenLine(workTable.WorkId, _userId);
            }
        }

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstWorkLineByWorkBuildId</Name>
				<Source><![CDATA[
    public static WHSWorkLine getFirstWorkLineByWorkBuildId(WHSWorkBuildId _workBuildId, WHSUserId _userId)
    {
        WhsWorkExecute  workExecute = WhsWorkExecute::construct();
        WHSWorkTable    workTable;
        WHSWorkLine     workLine;

        if (_workBuildId)
        {
            select firstonly WorkId from workTable
                where workTable.WorkBuildId == _workBuildId  &&
                      workTable.WorkStatus  <= WHSWorkStatus::InProcess;

            if (workTable.WorkId)
            {
                workLine = workExecute.getFirstOpenLine(workTable.WorkId, _userId);
            }
        }

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastWorkLine</Name>
				<Source><![CDATA[
    static WHSWorkLine getLastWorkLine(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by LineNum desc
            where workLine.WorkId == _workId;

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextWorkBuildId</Name>
				<Source><![CDATA[
    [SysObsolete('Use WHSWorkTable::getNextWorkCreateId() instead.', false, 14\12\2020)]
    public static WHSWorkBuildId getNextWorkBuildId()
    {
        return WHSWorkTable::getNextWorkCreateId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextWorkCreateId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns next work create id.
    /// </summary>
    /// <returns>Instance of <c>WHSWorkCreateId</c>.</returns>
    public static WHSWorkCreateId getNextWorkCreateId()
    {
        return NumberSeq::newGetNum(WHSParameters::numRefWHSWorkCreateId()).num();
            
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementedAndFound</Name>
				<Source><![CDATA[
    private static void incrementedAndFound(
        WHSWorkId    _combinedWorkId,
        boolean      _incremented,
        boolean      _found,
        WHSWorkTable _combinedWorkTable,
        WHSWorkLine  _targetWorkLine,
        boolean      _itemCleared)
    {
        WHSWorkTable        combinedWorkTable = _combinedWorkTable;
        WHSWorkLine         targetWorkLine = _targetWorkLine;
        WHSWorkLine         multiSKUworkLine;
        WHSWorkInventTrans  tmpCombinedWorkInventTrans;
        WHSWorkInventTrans  newWorkInventTrans;
        boolean             itemCleared = _itemCleared;
        boolean             incremented = _incremented;
        boolean             found = _found;
        InventDim           newSourceInventDimTo;

        if (!incremented && found)
        {
            select forupdate tmpCombinedWorkInventTrans
                where tmpCombinedWorkInventTrans.WorkId == _combinedWorkId  &&
                        tmpCombinedWorkInventTrans.LineNum   == 1;

            while (tmpCombinedWorkInventTrans.RecId > 0)
            {
                if (combinedWorkTable.WorkTransType != WHSWorkTransType::ProdPick
                    && combinedWorkTable.WorkTransType != WHSWorkTransType::KanbanPick)
                {
                    newWorkInventTrans.clear();
                    newWorkInventTrans.initFromWorkInventTrans(tmpCombinedWorkInventTrans);

                    newSourceInventDimTo               = InventDim::find(newWorkInventTrans.InventDimIdFrom);
                    newSourceInventDimTo.wmsLocationId = targetWorkLine.wmsLocationId;
                    newSourceInventDimTo               = InventDim::findOrCreate(newSourceInventDimTo);

                    newWorkInventTrans.InventDimIdTo    = newSourceInventDimTo.InventDimId;
                    newWorkInventTrans.LineNum          = targetWorkLine.LineNum;
                    newWorkInventTrans.WorkId           = targetWorkLine.WorkId;
                    newWorkInventTrans.InventQtyRemain  = newWorkInventTrans.Qty;

                    newWorkInventTrans.insert();
                }

                if (!itemCleared)
                {
                    // Clear ItemId from workLines since Multi-SKU
                    multiSKUworkLine.skipDataMethods(true);
                    update_recordset multiSKUworkLine
                        setting ItemId = ''
                        where multiSKUworkLine.WorkId    == targetWorkLine.WorkId
                           && multiSKUworkLine.LineNum   >= targetWorkLine.LineNum
                           && multiSKUworkLine.ItemId    !=  '';

                    itemCleared = true;
                }

                next tmpCombinedWorkInventTrans;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCancelWorkStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the current work status allows for cancellation.
    /// </summary>
    /// <param name = "_workTable">The Work to cancel.</param>
    /// <param name = "_allowCancelClosed">True if cancelling of closed work is allowed, otherwise false.</param>
    /// <returns>True if the work can be canceled, otherwise false.</returns>
    public static boolean validateCancelWorkStatus(WHSWorkTable _workTable, boolean _allowCancelClosed = false)
    {
        boolean allowCancelCombined = WHSWorkTable::find(_workTable.CombinedWorkId).WorkStatus == WHSWorkStatus::Closed;

        if (_workTable.WorkStatus > WHSWorkStatus::InProcess &&
                !(_allowCancelClosed && (_workTable.WorkStatus == WHSWorkStatus::Closed
                    || (allowCancelCombined && _workTable.WorkStatus == WHSWorkStatus::Combined))))
        {
            warning(strFmt("@WAX2190", _workTable.WorkId, _workTable.WorkStatus));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCancelWorkLockedUser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that locking work to a user doesn't prevent cancellation.
    /// </summary>
    /// <param name = "_workTable">The Work to cancel.</param>
    /// <param name = "_allowCancelClosed">True if cancelling of closed work is allowed, otherwise false.</param>
    /// <returns>True if the work can be canceled, otherwise false.</returns>
    public static boolean validateCancelWorkLockedUser(WHSWorkTable _workTable)
    {
        if (_workTable.WorkStatus == WHSWorkStatus::InProcess && _workTable.LockedUser)
        {
            warning("@WAX708");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCancelWorkLineTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the types of closed and opened work lines allow cancellation.
    /// </summary>
    /// <param name = "_workTable">The instance of <c>WHSWorkTable</c> to cancel.</param>
    /// <returns>true if the work can be canceled; otherwise, false.</returns>
    public static boolean validateCancelWorkLineTypes(WHSWorkTable _workTable)
    {
        if (_workTable.WorkStatus > WHSWorkStatus::Open)
        {
            WHSWorkLine lastClosedWorkLine = WHSWorkLine::lastClosedWorkLine(_workTable.WorkId);
            
            // Validate that the last closed line is put or there are actually no picks (with non-zero qty) before first put completed.
            if (lastClosedWorkLine &&
                !lastClosedWorkLine.canWorkLineTypeBeCanceled() &&
                WHSWorkTable::anyPicksBeforeFirstPutCompleted(_workTable.WorkId))
            {
                warning(strFmt("@WAX:LastWorkLineValidation", lastClosedWorkLine.WorkType));
                return false;
            }

            // Validate that the first open line is not a Put.
            if (WHSWorkTable::getFirstActiveWorkLine(_workTable.WorkId).WorkType == WHSWorkType::Put)
            {
                warning("@WAX1286");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCancelWorkTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the work order type can be canceled.
    /// </summary>
    /// <returns>true if the work can be canceled; otherwise, false.</returns>
    private boolean validateCancelWorkTransType()
    {
        if (this.WorkTransType == WHSWorkTransType::SortedInventoryPicking)
        {
            warning(strFmt("@WAX:CannotCancelWorkWithWorkTransType", this.WorkId, this.WorkTransType));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCancelWorkActiveDemandLinked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that linked demand work does not prevent cancellation.
    /// </summary>
    /// <param name = "_workTable">The Work to cancel.</param>
    /// <param name = "_cancelReplenishmentWorkWithDependentWork">Should the replenishment work that has dependent work be canceled? Optional.</param>
    /// <returns></returns>
    public static boolean validateCancelWorkActiveDemandLinked(WHSWorkTable _workTable, UnknownNoYes _cancelReplenishmentWorkWithDependentWork = UnknownNoYes::Unknown)
    {
        if (_workTable.WorkTransType == WHSWorkTransType::Replenishment && WHSWorkTable::isWorkLinkedToActiveDemandWork(_workTable.WorkId))
        {
            if (!WHSWorkTable::canCancelReplenishmentWorkWithDependentWork(_cancelReplenishmentWorkWithDependentWork))
            {
                warning(strFmt("@WAX:Error_ReplenWorkCannotBeCancelledDueToDependentDemandWork", _workTable.WorkId));
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCancelWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize work to be cancelled.
    /// </summary>
    /// <param name = "_workId">The work Id to be cancelled.</param>
    /// <param name = "_allowCancelClosed">true if cancelling of closed work is allowed, otherwise, false.</param>
    /// <param name = "_cancelReplenishmentWorkWithDependentWork">Should the replenishment work that has dependent work be canceled? Optional.</param>
    /// <returns>Container with the current state of the cancellation and the instance of the <c>WHSWorkTable</c> record.</returns>
    protected static container initCancelWork(
        WHSWorkId		_workId,
        boolean			_allowCancelClosed							= false,
        UnknownNoYes	_cancelReplenishmentWorkWithDependentWork	= UnknownNoYes::Unknown)
    {
        WHSWorkTable workTable = WHSWorkTable::find(_workId, true);

        if (!workTable)
        {
            warning(strFmt("@WAX:Error_WorkDoesNotExist", _workId));
            return [true, workTable];
        }

        boolean ret = true;
        
        ret = ret && WHSWorkTable::validateCancelWorkStatus(workTable, _allowCancelClosed);
        ret = ret && WHSWorkTable::validateCancelWorkLockedUser(workTable);
        ret = ret && WHSWorkTable::validateCancelWorkLineTypes(workTable);
        ret = ret && workTable.validateCancelWorkTransType();
        ret = ret && WHSWorkTable::validateCancelWorkActiveDemandLinked(workTable, _cancelReplenishmentWorkWithDependentWork);
        ret = ret && WHSWorkBlocking::canCancelBlockedWork(workTable);

        return [!ret, workTable];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkNotAssociatedToClusterLockedByUser</Name>
				<Source><![CDATA[
    private static boolean validateWorkNotAssociatedToClusterLockedByUser(WHSWorkId _workId)
    {
        WHSLockedUser lockedUser = WHSWorkClusterTable::findLockedUserFromClusterThatHasWorkIdAssociated(_workId);

        if (lockedUser)
        {
            warning(strFmt("@WAX:WHSWorkAssociatedToClusterLockedByUserError", _workId, lockedUser));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCancelReplenishmentWorkWithDependentWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Can replenishment work with dependent work be cancelled.
    /// </summary>
    /// <param name = "_cancelReplenishmentWorkWithDependentWork">Should the replenishment work that has dependent work be canceled? Optional.</param>
    /// <returns>true if replenishment work with dependent work can be cancelled; otherwise, false.</returns>
    [Replaceable]
    protected static boolean canCancelReplenishmentWorkWithDependentWork(UnknownNoYes _cancelReplenishmentWorkWithDependentWork)
    {
        switch (_cancelReplenishmentWorkWithDependentWork)
        {
            case UnknownNoYes::Yes:
                return true;
            case UnknownNoYes::Unknown:
                return Box::yesNo("@WAX4035", DialogButton::No);                
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOtherUnProcessedWorkByTargetLp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find another unprocessed work which uses provided license plate as target license plate.
    /// </summary>
    /// <param name="_workId">
    /// The current work order's work id.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate that we want to check.
    /// </param>
    /// <returns>
    /// Unprocessed work with target license plate which is same with license plate that we want to check.
    /// </returns>
    public static WHSWorkTable findOtherUnProcessedWorkByTargetLp(WHSWorkId _workId, WHSLicensePlateId _licensePlateId)
    {
        WHSWorkTable whsWorkTable;
    
        if (_licensePlateId)
        {
            select firstonly whsWorkTable
                where (whsWorkTable.WorkStatus           == WHSWorkStatus::InProcess
                         || whsWorkTable.WorkStatus      == WHSWorkStatus::PendingReview)
                    && whsWorkTable.WorkId               != _workId
                    && whsWorkTable.TargetLicensePlateId == _licensePlateId;
        }
    
        return whsWorkTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOtherUnProcessedOrOpenWorkByTargetLp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find another unprocessed or open work which uses provided license plate as target license plate.
    /// </summary>
    /// <param name="_workId">
    /// The current work order's work id.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate that we want to check.
    /// </param>
    /// <returns>
    /// Unprocessed or open work with target license plate which is same with license plate that we want to check.
    /// </returns>
    public static WHSWorkTable findOtherUnProcessedOrOpenWorkByTargetLp(WHSWorkId _workId, WHSLicensePlateId _licensePlateId)
    {
        WHSWorkTable whsWorkTable;
    
        if (_licensePlateId)
        {
            select firstonly whsWorkTable
                where whsWorkTable.TargetLicensePlateId == _licensePlateId
                   && whsWorkTable.WorkId != _workId
                   && (whsWorkTable.WorkStatus == WHSWorkStatus::InProcess ||
                       whsWorkTable.WorkStatus == WHSWorkStatus::PendingReview ||
                       whsWorkTable.WorkStatus == WHSWorkStatus::Open);
        }
    
        return whsWorkTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyPicksBeforeFirstPutCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if any of the pick work lines before the first put have been closed.
    /// </summary>
    /// <param name = "_workId">Identifier of the work order we are inquiring about.</param>
    /// <returns>true, if at least one of the picks is completed; otherwise, false.</returns>
    public static boolean anyPicksBeforeFirstPutCompleted(WHSWorkId _workId)
    {
        WHSWorkLineCache    cache = WHSWorkLineCache::newFromWorkId(_workId);
        WHSWorkLine         pickWorkLine;

        // Find any pick work line that is closed before the first put
        select firstonly RecId from pickWorkLine
            where pickWorkLine.WorkId == _workId
                && pickWorkLine.LineNum < cache.parmFirstPutLineNum()
                && pickWorkLine.WorkType == WHSWorkType::Pick
                && pickWorkLine.WorkStatus == WHSWorkStatus::Closed
                && pickWorkLine.InventQtyWork > 0;

        return pickWorkLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allPicksBeforeFirstPutCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if all the Pick work lines before the first Put have been closed.
    /// </summary>
    /// <param name = "_workId">Identifier of the work order we are inquiring about.</param>
    /// <returns>true, if all picks are completed; otherwise, false.</returns>
    public static boolean allPicksBeforeFirstPutCompleted(WHSWorkId _workId)
    {
        WHSWorkLineCache    cache = WHSWorkLineCache::newFromWorkId(_workId);
        WHSWorkLine         pickWorkLine;

        // Find any pick work line that is not closed before the first put
        select firstonly RecId from pickWorkLine
            where pickWorkLine.WorkId == _workId
                && pickWorkLine.LineNum < cache.parmFirstPutLineNum()
                && pickWorkLine.WorkType == WHSWorkType::Pick
                && pickWorkLine.WorkStatus < WHSWorkStatus::Closed;

        return pickWorkLine.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFirstPutCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the first put work line has been closed.
    /// </summary>
    /// <param name = "_workId">Identifier of the work order we are inquiring about.</param>
    /// <returns>true, if the first put work line is closed; false otherwise.</returns>
    /// <remarks>
    /// This method returning true also means that all initial picks have been completed.
    /// </remarks>
    public static boolean isFirstPutCompleted(WHSWorkId _workId)
    {
        WHSWorkLineCache    cache = WHSWorkLineCache::newFromWorkId(_workId);
        WHSWorkLine         firstPutWorkLine;

        select firstonly WorkStatus from firstPutWorkLine
            where firstPutWorkLine.WorkId == _workId
                && firstPutWorkLine.LineNum == cache.parmFirstPutLineNum();

        return firstPutWorkLine.WorkStatus == WHSWorkStatus::Closed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProdPickWorkComplete</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Checks if all work for the production order is complete.
    /// </summary>
    /// <param name="_prodId">
    ///  The Id of the production order being validated.
    /// </param>
    /// <returns>
    ///  true if all work for the production order is complete or work does not exist; otherwise, false.
    /// </returns>
    public static boolean isProdPickWorkComplete(ProdId _prodId)
    {
        WHSWorkTable        workTable;
        WHSWorkLine         workLine;
        boolean             ret = true;

        if (_prodId)
        {
            select firstonly RecId from workTable
                exists join workLine
                    where workTable.WorkId        == workLine.WorkId
                    &&    workLine.OrderNum       == _prodId
                    &&    workTable.WorkStatus    < WHSWorkStatus::Closed
                    &&    workTable.WorkTransType == WHSWorkTransType::ProdPick;

            ret = workTable.RecId == 0;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if all work for the load is complete.
    /// </summary>
    /// <param name="_loadId">
    /// The load Id of the load being validated.
    /// </param>
    /// <returns>
    /// true if all work for the load is complete; otherwise, false.
    /// </returns>
    static boolean isWorkComplete(WHSLoadId _loadId)
    {
        WHSWorkTable        workTable;
        WHSWorkLine         workLine;
        boolean             ret;

        if (_loadId)
        {
            select firstonly RecId from workTable
                join LoadId from workLine
                where workTable.WorkId       == workLine.WorkId   &&
                      workLine.LoadId        == _loadId;

            if (workTable.RecId != 0)
            {
                select firstonly RecId from workTable
                    join LoadId from workLine
                    where workTable.WorkId       == workLine.WorkId   &&
                          workLine.LoadId        == _loadId              &&
                          workTable.WorkStatus    < WHSWorkStatus::Closed;

                ret = workTable.RecId == 0;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoadId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates correct LoadId value, due to changes of related loads
    /// </summary>
    /// <param name = "_loadId">Load id related to work, that needs to be updated.</param>
    [Hookable(false)]
    internal static void updateLoadId(WHSLoadId _loadId)
    {
        MapEnumerator enumerator = WHSWorkTable::workIdsWithRelatedLoadsEnumerator(_loadId);

        ttsbegin;

        while (enumerator.moveNext())
        {
            WHSWorkId workId = enumerator.currentKey();
            WHSLoadId loadId = enumerator.currentValue();

            WHSWorkTable workTable = WHSWorkTable::find(workId, true);
            if (workTable.LoadId != loadId)
            {
                workTable.LoadId = loadId;
                workTable.update();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWorkIdByLoadId</Name>
				<Source><![CDATA[
    private static WHSWorkTable findWorkIdByLoadId(WHSLoadId _loadId, boolean _forUpdate = false)
    {
        WHSWorkLine workLine;

        select firstonly WorkId from workLine
            where workLine.LoadId == _loadId;  

        return WHSWorkTable::find(workLine.WorkId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockWorkOnCancelOrLogOut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unlocks the work when cancelling or when logging out.
    /// </summary>
    /// <param name = "_workId">
    /// The id of the work to unlock.
    /// </param>
    /// <param name = "_userId">
    /// The id of the user.
    /// </param>
    /// <remarks>
    /// This method uses the WHSSkipWorkIsBeingSplitValidationContext to mark that when updating the work the validation for the it being split should be skipped.
    /// </remarks>
    [Hookable(false)]
    internal static void unlockWorkOnCancelOrLogOut(WHSWorkId _workId)
    {
        //The context is used in order to pass the information when updating a work line that the validation for work being split should be skipped.
        WHSSkipWorkIsBeingSplitValidationContext skipWorkIsBeingSplitValidationContext = WHSSkipWorkIsBeingSplitValidationContext::current();

        // If the context is already enabled, it should not be tried to be instantiated again because an error will be thrown.
        // It is possible to end up trying to instantiate the context more than once if this method is called recursive.
        if (!skipWorkIsBeingSplitValidationContext)
        {
            using (WHSSkipWorkIsBeingSplitValidationContext context = WHSSkipWorkIsBeingSplitValidationContext::newSkipWorkBeingSplitValidation())
            {
                WHSWorkTable::lockUnlockWork(_workId, '');
            }
        }
        else
        {
            WHSWorkTable::lockUnlockWork(_workId, '');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockUnlockWork</Name>
				<Source><![CDATA[
    public static void lockUnlockWork(WHSWorkId _workId, WHSUserId _userId)
    {
        #localmacro.WorkLineFieldsToResetStatus
            WorkStatus                  = WHSWorkStatus::Open,
            UserId                      = '',
            WorkInProcessUTCDateTime    = utcDateTimeNull(),
            AskForNewLicensePlate       = NoYes::No
        #endmacro

        #localmacro.WorkLineStatusInProcessButNotStarted
            workLine.WorkId == _workId
            && workLine.WorkStatus == WHSWorkStatus::InProcess
            && workLine.QtyWork == workLine.QtyRemain
        #endmacro

        boolean skipDataMethods = WHSWorkLockUnlockWorkContext::isActive();

        ttsbegin;

        WHSWorkTable workTable = WHSWorkTable::find(_workId, true);

        WHSInstrumentationLogger instrumentationLogger = WHSWorkTable::instrumentationLogger();

        using (var activityContext = instrumentationLogger.workTableActivities().lockUnlockWork(workTable))
        {
            if (workTable.RecId != 0)
            {
                // Set the Locked User field
                workTable.LockedUser = _userId;

                if (!_userId)
                {
                    WHSWorkLine workLineUpdate;

                    workLineUpdate.skipDataMethods(skipDataMethods);
                    workLineUpdate.skipEvents(skipDataMethods);

                    switch (workTable.WorkTransType)
                    {
                        case WHSWorkTransType::CycleCount:
                            WHSWorkLine workLineClosed;
                            
                            select firstonly RecId from workLineClosed
                                where workLineClosed.WorkId == _workId
                                    && workLineClosed.WorkStatus == WHSWorkStatus::Closed;

                            if (workLineClosed.RecId == 0)
                            {
                                workTable.WorkStatus                = WHSWorkStatus::Open;
                                workTable.WorkInProcessUTCDateTime  = utcDateTimeNull();


                                update_recordset workLineUpdate
                                    setting #WorkLineFieldsToResetStatus
                                    where workLineUpdate.WorkId == _workId;

                                WHSWorkLineCycleCount   workLineCycleCount;

                                delete_from workLineCycleCount
                                    where workLineCycleCount.WorkId == workTable.WorkId;

                                activityContext.addCustomProperty('updateWorkLine', int642str(workLineUpdate.RowCount()));
                                activityContext.addCustomProperty('deleteLineCycleCount', int642str(workLineCycleCount.RowCount()));
                            }
                            else
                            {
                                update_recordset workLineUpdate
                                    setting #WorkLineFieldsToResetStatus
                                    where workLineUpdate.WorkId == _workId
                                        && workLineUpdate.WorkStatus == WHSWorkStatus::InProcess;

                                activityContext.addCustomProperty('updateWorkLine', int642str(workLineUpdate.RowCount()));
                            }
                            break;

                        default:
                            WHSWorkLine workLineQty;

                            // If we have not started any work, we can reset all work lines
                            // and the status on the work header itself
                            select firstonly RecId from workLineQty
                                order by workLineQty.LineNum
                                where workLineQty.WorkId == _workId
                                    && workLineQty.WorkStatus != WHSWorkStatus::Cancelled
                                    && (!workLineQty.QtyWork || workLineQty.QtyWork != workLineQty.QtyRemain);

                            if (workLineQty.RecId == 0)
                            {
                                workTable.WorkStatus                 = WHSWorkStatus::Open;
                                workTable.WorkInProcessUTCDateTime   = utcDateTimeNull();

                                update_recordset workLineUpdate
                                    setting #WorkLineFieldsToResetStatus
                                    where workLineUpdate.WorkId == _workId
                                        && workLineUpdate.WorkStatus != WHSWorkStatus::Cancelled
                                        && workLineUpdate.WorkStatus != WHSWorkStatus::Skipped
                                        && workLineUpdate.WorkStatus != WHSWorkStatus::Combined;

                                activityContext.addCustomProperty('updateWorkLine', int642str(workLineUpdate.RowCount()));

                                WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(workTable.WorkTransType);
        
                                if (workTransactionType)
                                {
                                    if (workTransactionType.isWorkCleanUpOnLockUnlockWorkAllowed())
                                    {
                                        if (workTable.isTargetLicensePlateClearingAllowed())
                                        {
                                            if (workTable.WorkTransType != WHSWorkTransType::PackedContainerPicking
                                            &&  workTable.WorkTransType != WHSWorkTransType::SortedInventoryPicking
                                            &&  workTable.WorkTransType != WHSWorkTransType::CrossDocking)
                                            {
                                                workTable.TargetLicensePlateId = '';
                                            }
                                        }

                                        WHSDimTracking dimTracking;

                                        delete_from dimTracking
                                            where dimTracking.WorkId == _workId
                                                && dimTracking.Processed == NoYes::No;

                                        activityContext.addCustomProperty('deleteDimTracking', int642str(dimTracking.RowCount()));
                                    }
                                }
                            }
                            else
                            {
                                // If we already have some work finished, we only reset the InProcess work lines,
                                // where no actual work has been performed so far
                                // We also ensure any DimTracking records if they exist are removed

                                WHSWorkLine workLine;

                                workLine.skipDataMethods(skipDataMethods);
                                workLine.skipEvents(skipDataMethods);

                                if (workTable.isWorkTransTypeOutbound())
                                {
                                    WHSDimTracking dimTracking;

                                    delete_from dimTracking
                                        exists join workLine
                                        where #WorkLineStatusInProcessButNotStarted
                                            && dimTracking.WorkId == workLine.WorkId
                                            && dimTracking.LineNum == workLine.LineNum
                                            && dimTracking.Processed == NoYes::No;

                                    activityContext.addCustomProperty('deleteDimTracking', int642str(dimTracking.RowCount()));
                                }

                                update_recordset workLine
                                    setting #WorkLineFieldsToResetStatus
                                    where #WorkLineStatusInProcessButNotStarted;

                                activityContext.addCustomProperty('updateWorkLine', int642str(workLine.RowCount()));
                            }
                            break;
                    }
                    
                }
                
                if (!workTable.validateWrite())
                {
                    throw error(strFmt("@WAX:WHSCannotUpdateRecordInTable", tablePName(WHSWorkTable)));
                }
                else
                {
                    workTable.update();
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTargetLicensePlateClearingAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if it is allowed to clear the target license plate ID of the work.
    /// </summary>
    /// <returns>
    /// true if it is allowed to clear the target license plate ID of the work; otherwise false.
    /// </returns>
    /// <remarks>
    /// This method is an extension point to control the clearing of the TargetLicensePlateId field.
    /// </remarks>
    protected boolean isTargetLicensePlateClearingAllowed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupFinalLocations</Name>
				<Source><![CDATA[
    static void lookupFinalLocations(FormStringControl _ctrl, RefRecId _recId, RefTableId _tableId = 0)
    {
        WHSShipmentTable        shipmentTable;
        WHSLoadTable            loadTable;
        SysTableLookup          sysTableLookup;
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;
        WHSShipFinalLocType     finalLocType = WHSParameters::find().ShipFinalLocType;

        switch (_tableId)
        {
            case tableNum(WHSLoadTable):
                loadTable = WHSLoadTable::findByRecId(_recId);
                break;

            case tableNum(WHSShipmentTable):
                select firstonly LoadId from shipmentTable
                    where shipmentTable.RecId == _recId;

                loadTable = WHSLoadTable::find(shipmentTable.LoadId);
                break;

            default:
                loadTable = WHSLoadTable::findByRecId(_recId);
                break;
        }

        sysTableLookup          = SysTableLookup::newParameters(tableNum(WMSLocation), _ctrl);
        query                   = new Query();
        queryBuildDataSource    = query.addDataSource(tableNum(WMSLocation));
        queryBuildDataSource.addRange(fieldNum(WMSLocation, InventLocationId)).value(loadTable.InventLocationId);
        queryBuildDataSource    = queryBuildDataSource.addDataSource(tableNum(WHSLocationProfile));
        queryBuildDataSource.relations(true);
        queryBuildDataSource.addRange(fieldNum(WHSLocationProfile, LocType)).value(finalLocType);

        queryBuildDataSource.relations(true);

        sysTableLookup.addLookupfield(fieldNum(WMSLocation, wmsLocationId));
        sysTableLookup.addLookupfield(fieldNum(WMSLocation, InventLocationId));

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupStagingLocations</Name>
				<Source><![CDATA[
    static void lookupStagingLocations(FormStringControl _ctrl, RefRecId _recId, TableId _tableId = 0)
    {
        WHSShipmentTable        shipmentTable;
        WHSLoadTable            loadTable;
        SysTableLookup          sysTableLookup;
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;
        WHSShipFinalLocType     finalLocType = WHSParameters::find().StageLocType;

        switch (_tableId)
        {
            case tableNum(WHSLoadTable):
                loadTable = WHSLoadTable::findByRecId(_recId);
                break;

            case tableNum(WHSShipmentTable):
                select firstonly LoadId from shipmentTable
                    where shipmentTable.RecId == _recId;

                loadTable = WHSLoadTable::find(shipmentTable.LoadId);
                break;

            default:
                loadTable = WHSLoadTable::findByRecId(_recId);
                break;
        }

        sysTableLookup          = SysTableLookup::newParameters(tableNum(WMSLocation), _ctrl);
        query                   = new Query();
        queryBuildDataSource    = query.addDataSource(tableNum(WMSLocation));
        queryBuildDataSource.addRange(fieldNum(WMSLocation, InventLocationId)).value(loadTable.InventLocationId);
        queryBuildDataSource    = queryBuildDataSource.addDataSource(tableNum(WHSLocationProfile));
        queryBuildDataSource.relations(true);
        queryBuildDataSource.addRange(fieldNum(WHSLocationProfile, LocType)).value(finalLocType);

        queryBuildDataSource.relations(true);

        sysTableLookup.addLookupfield(fieldNum(WMSLocation, wmsLocationId));
        sysTableLookup.addLookupfield(fieldNum(WMSLocation, InventLocationId));

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>multipleFinalPutsAllEqualQtyRemain</Name>
				<Source><![CDATA[
    /// <summary>
    /// When multiple final puts have same location/Unit, calculate the sum of RemainQty
    /// </summary>
    /// <param name="_whsWorkId">
    /// Work Id for the work that needs evaluated
    /// </param>
    /// <param name="_checkUnit">
    /// True if the unit in the put work lines needs to be the same; otherwise false
    /// </param>
    /// <returns>
    /// The sum of RemainQty when multiple final puts have same location/Unit; otherwise 0
    /// </returns>
    private static WHSQtyRemain multipleFinalPutsAllEqualQtyRemain(WHSWorkId _whsWorkId, boolean _checkUnit = false)
    {
        WHSQtyRemain    ret = 0;
        WHSWorkLine     whsWorkLine;
        str             key;
        str             tempKey;
        int             i;

        while select WMSLocationId, UnitId, QtyRemain, WorkType from whsWorkLine
        order by LineNum desc
        where whsWorkLine.WorkId == _whsWorkId
        {
            if (whsWorkLine.WorkType != WHSWorkType::Put)
            {
                // Work type other than put means we are done looking at the final put steps and can break out of loop.
                break;
            }

            tempKey = strFmt("%1,%2", whsWorkLine.WMSLocationId, _checkUnit ? whsWorkLine.UnitId: '');

            ret += whsWorkLine.QtyRemain;

            if (i > 0 && key != tempKey)
            {
                ret = 0;
                break;
            }

            key = tempKey;

            ++i;
        }

        if (i < 2)
        {
            ret = 0;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>multipleFinalPutsAllLocationsEqual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the multiple final put work lines have the same location.
    /// </summary>
    /// <param name="_whsWorkId">
    /// Work Id for the work that needs evaluated
    /// </param>
    /// <returns>
    /// True if the multiple final puts have same WMSLocation; otherwise false
    /// </returns>
    public static boolean multipleFinalPutsAllLocationsEqual(WHSWorkId _whsWorkId)
    {
        return WHSWorkTable::multipleFinalPutsAllEqualQtyRemain(_whsWorkId) != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>multipleFinalPutsWithLocAndUnitsEqualRemainQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of the remaining quantities of all final puts if they have the same location and unit.
    /// </summary>
    /// <param name="_whsWorkId">
    /// Work Id for the work that needs evaluated
    /// </param>
    /// <returns>
    /// The sum of RemainQty when multiple final puts have same unit and location; otherwise 0
    /// </returns>
    public static WHSQtyRemain multipleFinalPutsWithLocAndUnitsEqualRemainQty(WHSWorkId _whsWorkId)
    {
        return WHSWorkTable::multipleFinalPutsAllEqualQtyRemain(_whsWorkId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetWork</Name>
				<Source><![CDATA[
    public static void resetWork(WHSWorkId _workId)
    {
        ttsbegin;

        WHSWorkTable workTable = WHSWorkTable::find(_workId, true);
        WHSWorkLine workLine = WHSWorkLine::firstOpenOrInProcessLineForUpdate(workTable.WorkId);

        boolean skipWorkReset = workLine.RecId == 0;

        if (!skipWorkReset)
        {
            if (workLine.WorkStatus == WHSWorkStatus::Open
            || workLine.WorkStatus == WHSWorkStatus::InProcess)
            {
                if (workLine.LineNum == 1)
                {
                    workTable.WorkStatus = WHSWorkStatus::Open;
                    workTable.WorkInProcessUTCDateTime = utcDateTimeNull();
                }

                if (!workTable.UserManuallyAssigned)
                {
                    workTable.LockedUser = '';
                }

                if (!workTable.validateWrite())
                {
                    throw error(strFmt("@WAX:WHSCannotUpdateRecordInTable", tablePName(WHSWorkTable)));
                }
                else
                {
                    workTable.update();
                }

                workLine.WorkStatus = WHSWorkStatus::Open;
                workLine.WorkInProcessUTCDateTime = utcDateTimeNull();
                if (!workLine.validateWrite())
                {
                    throw error(strFmt("@WAX:WHSCannotUpdateRecordInTable", tablePName(WHSWorkLine)));
                }
                else
                {
                    workLine.update();
                }
            }
        }

        ttscommit;      
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBlankFields</Name>
				<Source><![CDATA[
    private static container setBlankFields(boolean             _blankItemId,
                                            ItemId              _itemId,
                                            boolean             _blankUnitId,
                                            UnitOfMeasureSymbol _unitId,
                                            InventDimId         _inventDimId,
                                            boolean             _blankInventTransId,
                                            InventTransId       _inventTransId,
                                            WHSWorkLine         _cleanupWorkLine)

    {
        WHSWorkLine         cleanupWorkLine = _cleanupWorkLine;
        ItemId              itemId = _itemId;
        UnitOfMeasureSymbol unitId = _unitId;
        InventTransId       inventTransId = _inventTransId;
        InventDimId         inventDimId = _inventDimId;

        if (!_blankItemId)
        {
            itemId = cleanupWorkLine.ItemId;
        }
        if (!_blankUnitId)
        {
            unitId = cleanupWorkLine.UnitId;
        }
        if (!inventDimId)
        {
            inventDimId = cleanupWorkLine.InventDimId;
        }
        if (!_blankInventTransId)
        {
            inventTransId = cleanupWorkLine.InventTransId;
        }

        return [itemId, unitId, inventDimId, inventTransId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFields</Name>
				<Source><![CDATA[
    private static container setFields(WHSWorkId _workId)
    {
        WHSWorkLine          cleanupWorkLine;
        ItemId               itemId;
        UnitOfMeasureSymbol  unitId;
        InventTransId        inventTransId;
        InventDimId          inventDimId;
        LineNum              lastPickLineNum;
        boolean              blankItemId;
        boolean              blankUnitId;
        boolean              blankInventTransId;
        Qty                  qtyWork;
        Qty                  inventQtyWork;

        while select cleanupWorkLine
            order by LineNum
            where cleanupWorkLine.WorkId == _workId
        {
            if (cleanupWorkLine.WorkType != WHSWorkType::Pick)
            {
                lastPickLineNum = cleanupWorkLine.LineNum - 1;
                break;
            }

            if (itemId && itemId != cleanupWorkLine.ItemId)
            {
                itemId = '';
                blankItemId = true;
            }
            if (unitId && unitId != cleanupWorkLine.UnitId)
            {
                unitId = '';
                blankUnitId = true;
            }
            if (!WHSWorkLine::isInventDimIdBlank(inventDimId) && inventDimId != cleanupWorkLine.InventDimId)
            {
                inventDimId = InventDim::inventDimIdBlank();
            }
            if (inventTransId && inventTransId != cleanupWorkLine.InventTransId)
            {
                inventTransId = '';
                blankInventTransId = true;
            }

            [itemId, unitId, inventDimId, inventTransId] = WHSWorkTable::setBlankFields(
                blankItemId, itemId, blankUnitId, unitId,
                inventDimId, blankInventTransId, inventTransId,
                cleanupWorkLine);

            qtyWork += cleanupWorkLine.QtyWork;
            inventQtyWork += cleanupWorkLine.InventQtyWork;
        }

        return [itemId, unitId, inventDimId, inventTransId, qtyWork, inventQtyWork, lastPickLineNum];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFrozenByWorkBuildId</Name>
				<Source><![CDATA[
    [SysObsolete('This method is deprecated and will be removed in future releases.', false, 30\06\2020)]
    public static void setFrozenByWorkBuildId(WHSWorkBuildId _workBuildId)
    {
        WHSWorkTable workTable;

        ttsbegin;

        if (_workBuildId)
        {
            update_recordset workTable
                setting Frozen = true
                where workTable.WorkBuildId == _workBuildId;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFrozenForBlockingReasonTypeByWorkBuildId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void setFrozenForBlockingReasonTypeByWorkBuildId(
        WHSWorkBuildId              _workBuildId, 
        WHSWorkBlockingReasonType   _workBlockingReasonType)
    {
        ttsbegin;

        if (_workBuildId)
        {
            WHSWorkTable workTable;

            while select WorkId from workTable
                where workTable.WorkBuildId == _workBuildId
            {
                WHSWorkBlocking::newFromWorkIdSkipInProgressWorkLineWithNoPreviousPutCheck(workTable.WorkId).tryBlockWorkWithReasonType(_workBlockingReasonType);
            }
        }

        ttscommit;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTargetLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the target license plate id.
    /// </summary>
    /// <param name="_workId">
    ///     The workId of the corresponding <c>WHSWorkTable</c>.
    /// </param>
    /// <param name="_licensePlateId">
    ///     The license plate id to be set.
    /// </param>
    public static void setTargetLicensePlate(WHSWorkId _workId, WHSLicensePlateId _licensePlateId)
    {
        WHSWorkTable    workTable = WHSWorkTable::find(_workId, true);

        ttsbegin;
        workTable.TargetLicensePlateId = _licensePlateId;
        workTable.write();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits the specified work from the current work ID
    /// </summary>
    /// <param name="_workId">
    /// The original work identifier
    /// </param>
    /// <param name="_lineNum">
    /// The original work line number
    /// </param>
    /// <param name="_qtyToPick">
    /// The quantity to be picked
    /// </param>
    /// <param name="_lockOrigWork">
    /// True if the original work should remain locked by the worker who split the work; otherwise false
    /// </param>
    /// <param name="_userId">
    /// The RF user processing the work.
    /// </param>
    /// <returns>
    /// Returns the work identifier for the newly created work
    /// </returns>
    public static WHSWorkId splitWork(
        WHSWorkId   _workId,
        LineNum     _lineNum,
        Qty         _qtyToPick      = 0,
        boolean     _lockOrigWork   = false,
        WHSUserId   _userId         = '')
    {
        WHSSplitWork whsSplitWork = WHSSplitWork::newStandard(_workId, _lineNum, _qtyToPick, _lockOrigWork, _userId);

        return whsSplitWork.splitWork();
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitGroupedWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits the specified grouped work from the current work ID.
    /// </summary>
    /// <param name="_workId">
    /// The original work identifier
    /// </param>
    /// <param name="_lineNum">
    /// The original work line number that is at the beginning of the grouped sequence not being split
    /// </param>
    /// <param name="_groupLineNum">
    /// The original work line number that is at the end of the grouped sequence not being split
    /// </param>
    /// <param name="_qtyToPick">
    /// The quantity to be picked
    /// </param>
    /// <param name="_lockOrigWork">
    /// True if the original work should remain locked by the worker who split the work; otherwise false
    /// </param>
    /// <param name="_userId">
    /// The RF user processing the work.
    /// </param>
    /// <returns>
    /// Returns the work identifier for the newly created work
    /// </returns>
    [Hookable(false)]
    internal static WHSWorkId splitGroupedWork(
        WHSWorkId   _workId,
        LineNum     _lineNum,
        LineNum     _groupLineNum,
        Qty         _qtyToPick,
        boolean     _lockOrigWork,
        WHSUserId   _userId)
        
    {
        WhsSplitWork splitWork = WhsSplitWork::newFromGroupedWorkLines(_workId, _lineNum, _groupLineNum, _qtyToPick, _lockOrigWork, _userId);

        return splitWork.splitWork();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkInventTrans</Name>
				<Source><![CDATA[
    private static container updateWorkInventTrans(
        WHSWorkId    _combinedWorkId,
        WHSWorkTable _combinedWorkTable,
        WHSWorkLine  _newWorkLine,
        WHSWorkLine  _targetWorkLine,
        LineNum      _oldTargetLineNum)
    {
        WHSWorkTable        combinedWorkTable = _combinedWorkTable;
        WHSWorkLine         newWorkLine = _newWorkLine;
        WHSWorkLine         targetWorkLine = _targetWorkLine;
        LineNum             oldTargetLineNum = _oldTargetLineNum;
        WHSWorkInventTrans  tmpCombinedWorkInventTrans;
        WHSWorkInventTrans  tmpTargetWorkInventTrans;
        WHSWorkInventTrans  targetWorkInventTrans;
        WHSWorkInventTrans  newWorkInventTrans;
        WHSWorkInventTrans  rawWorkInventTrans;
        boolean             itemCleared;
        boolean             incremented;
        boolean             found;
        InventDim           newSourceInventDimTo;

        while select forupdate targetWorkInventTrans
            order by InventTransIdParent
            where targetWorkInventTrans.WorkId  == targetWorkLine.WorkId
               && targetWorkInventTrans.LineNum == oldTargetLineNum
        {
            found = true;

            if (targetWorkLine.WorkType == WHSWorkType::Put)
            {
                select forupdate tmpCombinedWorkInventTrans
                    where tmpCombinedWorkInventTrans.WorkId     == _combinedWorkId
                       && tmpCombinedWorkInventTrans.LineNum    == 1;

                while (tmpCombinedWorkInventTrans.RecId > 0)
                {
                    if (   tmpCombinedWorkInventTrans.InventTransIdParent  == targetWorkInventTrans.InventTransIdParent
                        && InventDim::isInventDimEqualWHSNonWork(InventDim::find(tmpCombinedWorkInventTrans.InventDimIdTo), InventDim::find(targetWorkInventTrans.InventDimIdFrom), targetWorkInventTrans.ItemId))
                    {
                        // When operating in new stack, we shouldn't just set Qty fields to some new value and then delete because 
                        // in the new stack we rely on those values to create the compensating "remove reservation" transaction.
                        // So putting some artificial number in Qty, which was never saved, and then deleting a record leads to wrong results.
                        // Apart from that, such approach in general is prone to errors.
                        tmpTargetWorkInventTrans.clear();
                        buf2Buf(targetWorkInventTrans, tmpTargetWorkInventTrans);

                        targetWorkInventTrans.delete();

                        tmpTargetWorkInventTrans.LineNum          = targetWorkLine.LineNum;
                        tmpTargetWorkInventTrans.InventQtyRemain += newWorkLine.InventQtyWork;
                        tmpTargetWorkInventTrans.Qty             += newWorkLine.InventQtyWork;

                        tmpTargetWorkInventTrans.insert();
                        incremented = true;
                    }
                    else
                    {
                        targetWorkInventTrans.LineNum   = targetWorkLine.LineNum;
                        targetWorkInventTrans.update();

                        if (   combinedWorkTable.WorkTransType == WHSWorkTransType::ProdPick
                            || combinedWorkTable.WorkTransType == WHSWorkTransType::KanbanPick)
                        {
                            select firstonly rawWorkInventTrans
                                where rawWorkInventTrans.WorkId              == targetWorkLine.WorkId
                                   && (rawWorkInventTrans.LineNum            == targetWorkLine.LineNum
                                   ||  rawWorkInventTrans.LineNum             == oldTargetLineNum)
                                   && rawWorkInventTrans.InventTransIdParent == tmpCombinedWorkInventTrans.InventTransIdParent;

                            if (rawWorkInventTrans.RecId == 0)
                            {
                                newWorkInventTrans.clear();
                                newWorkInventTrans.initFromWorkInventTrans(tmpCombinedWorkInventTrans);

                                newSourceInventDimTo = InventDim::find(newWorkInventTrans.InventDimIdFrom);
                                newSourceInventDimTo.wmsLocationId = targetWorkLine.wmsLocationId;
                                newSourceInventDimTo = InventDim::findOrCreate(newSourceInventDimTo);

                                newWorkInventTrans.InventDimIdTo      = newSourceInventDimTo.InventDimId;
                                newWorkInventTrans.LineNum            = targetWorkLine.LineNum;
                                newWorkInventTrans.WorkId             = targetWorkLine.WorkId;
                                newWorkInventTrans.InventQtyRemain    = newWorkInventTrans.Qty;
                                newWorkInventTrans.WorkHasReservation = NoYes::No;
                                newWorkInventTrans.insert();

                                if (tmpCombinedWorkInventTrans.ItemId == targetWorkInventTrans.ItemId)
                                {
                                    itemCleared = true;
                                }
                            }
                        }
                        else
                        {
                            if (tmpCombinedWorkInventTrans.ItemId == targetWorkInventTrans.ItemId)
                            {
                                itemCleared = true;
                            }
                        }
                    }

                    next tmpCombinedWorkInventTrans;
                }
            }
            else
            {
                // When operating in new stack, we shouldn't just set Qty fields to some new value and then delete because 
                // in the new stack we rely on those values to create the compensating "remove reservation" transaction.
                // So putting some artificial number in Qty, which was never saved, and then deleting a record leads to wrong results.
                // Apart from that, such approach in general is prone to errors.
                tmpTargetWorkInventTrans.clear();
                buf2Buf(targetWorkInventTrans, tmpTargetWorkInventTrans);

                targetWorkInventTrans.delete();

                tmpTargetWorkInventTrans.LineNum         = targetWorkLine.LineNum;
                tmpTargetWorkInventTrans.InventQtyRemain = targetWorkLine.InventQtyWork;
                tmpTargetWorkInventTrans.Qty             = targetWorkLine.InventQtyWork;

                tmpTargetWorkInventTrans.insert();
            }
        }

        return [itemCleared, incremented, found];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkInCluster</Name>
				<Source><![CDATA[
    static boolean validateWorkInCluster(WHSWorkId  _workId)
    {
        WHSWorkClusterLine  workClusterLine;

        if (_workId)
        {
            WHSWorkClusterTable workClusterTable;
        
            // Validate work is not part of active cluster
            select firstonly WorkId from workClusterLine
                 where workClusterLine.WorkId == _workId
            exists join workClusterTable
                where workClusterTable.ClusterId            == workClusterLine.ClusterId
                    && workClusterTable.WorkClusterStatus   != WHSWorkClusterStatus::Closed;
        }

        return workClusterLine.WorkId == '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasDeferredPutProcessingTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if there are deferred put processing task records for the work.
    /// </summary>
    /// <returns>
    /// True if there are related <c>WHSWorkDeferredPutProcessingTask</c> records, otherwise false.
    /// </returns>
    [Hookable(false)]
    internal boolean hasDeferredPutProcessingTasks()
    {
        WHSWorkDeferredPutProcessingTask workDeferredPutProcessingTask;

        select firstonly RecId from workDeferredPutProcessingTask
            where workDeferredPutProcessingTask.WorkId == this.WorkId;

        return workDeferredPutProcessingTask.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCatchWeightItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines that catch weight enabled item does not exist on current work unit.
    /// </summary>
    /// <param name="_workId">
    /// The Id of the work being validated.
    /// </param>
    /// <returns>
    /// True if no catch weight items exist; otherwise false.
    /// </returns>
    [Hookable(false)]
    internal static boolean hasCatchWeightItems(WHSWorkId _workId)
    {
        WHSWorkLine         cwWorkLine;
        PdsCatchWeightItem  catchWeightItem;

        if (WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
        {
            select firstOnly RecId from cwWorkLine
                where cwWorkLine.WorkId == _workId
                exists join catchWeightItem
                    where catchWeightItem.ItemId == cwWorkLine.ItemId;
        }

        return cwWorkLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstPutWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first put work line for a provided work ID.
    /// </summary>
    /// <param name="_workId">
    /// The work ID.
    /// </param>
    /// <returns>
    /// The first put work line.
    /// </returns>
    public static WHSWorkLine getFirstPutWorkLine(WHSWorkId _workId)
    {
        return WHSWorkTable::getFirstWorkLineByType(_workId, WHSWorkType::Put, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstPickWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first pick work line for a provided work ID.
    /// </summary>
    /// <param name="_workId">
    /// The work ID.
    /// </param>
    /// <returns>
    /// The first pick work line.
    /// </returns>
    public static WHSWorkLine getFirstPickWorkLine(WHSWorkId _workId)
    {
        return WHSWorkTable::getFirstWorkLineByType(_workId, WHSWorkType::Pick);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstWorkLineByType</Name>
				<Source><![CDATA[
    private static WHSWorkLine getFirstWorkLineByType(WHSWorkId _workId, WHSWorkType _workType, boolean _includeCancelledLines = true)
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by workLine.LineNum asc
            where workLine.WorkId     == _workId
                 && workLine.WorkType   == _workType
                 && (_includeCancelledLines || workLine.WorkStatus != WHSWorkStatus::Cancelled);

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstActiveWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the first work line which is not Closed or Cancelled for a given work Id.
    /// </summary>
    /// <param name = "_workId">A work Id.</param>
    /// <returns>The first work line which is not Closed or Cancelled for a given work Id.</returns>
    private static WHSWorkLine getFirstActiveWorkLine(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by LineNum asc
            where workLine.WorkId == _workId
                && workLine.WorkStatus != WHSWorkStatus::Closed
                && (!WhsDontFailWorkCancelIfFirstPutIsSkippedFlight::instance().isEnabled() || workLine.WorkStatus != WHSWorkStatus::Skipped)
                && workLine.WorkStatus != WHSWorkStatus::Cancelled;

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextOpenPickWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the next pick work line with WorkStatus == Open for the provided work ID.
    /// </summary>
    /// <param name = "_workId">The Work ID.</param>
    /// <returns>The next Open Pick work line record.</returns>
    public static WHSWorkLine getNextOpenPickWorkLine(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by LineNum asc
            where workLine.WorkId == _workId
                &&  workLine.WorkType == WHSWorkType::Pick
                &&  workLine.WorkStatus == WHSWorkStatus::Open;

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastClosedPutWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the last closed put work line for a provided work ID.
    /// </summary>
    /// <param name="_workId">
    /// The work ID.
    /// </param>
    /// <returns>
    /// The last put work line.
    /// </returns>
    public static WHSWorkLine getLastClosedPutWorkLine(WHSWorkId _workId)
    {
        WHSWorkLine lastPutLine;

        // Find first Put
        select firstonly lastPutLine
            order by lastPutLine.LineNum desc
            where lastPutLine.WorkId     == _workId
               && lastPutLine.WorkStatus == WHSWorkStatus::Closed
               && lastPutLine.WorkType   == WHSWorkType::Put;

        return lastPutLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPickLinesWithLocatedLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work has any pick work lines with a located license plate ID.
    /// </summary>
    /// <param name="_workId">
    /// A work ID.
    /// </param>
    /// <returns>
    /// true if the work has any pick work lines with a located license plate ID; otherwise, false.
    /// </returns>
    public static boolean hasPickLinesWithLocatedLP(WHSWorkId _workId)
    {
        return WHSWorkTable::hasPickLinesWithOrWithoutLocatedLP(_workId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPickLinesWithOrWithoutLocatedLP</Name>
				<Source><![CDATA[
    private static boolean hasPickLinesWithOrWithoutLocatedLP(WHSWorkId _workId, boolean _findWithLocatedLP)
    {
        WHSWorkLine whsWorkLine;
        LineNum firstPutLineNum;
            
        if (!_findWithLocatedLP)
        {
            firstPutLineNum = WHSWorkTable::getFirstPutWorkLine(_workId).LineNum;
        }

        //License plate dimension is always right after the location dimension.
        //So when flexible reservation is used the WHSReservationHierarchyElementPolicyreservation always contains the license plate dimensions enabled.
        //That is why it is only required to check the OrderCommittedInventDimId field.
        select firstonly RecId from whsWorkLine
        where whsWorkLine.WorkId    == _workId
            && whsWorkLine.WorkType == WHSWorkType::Pick
            && (!firstPutLineNum || whsWorkLine.LineNum < firstPutLineNum)
            && ((!_findWithLocatedLP && whsWorkLine.LocatedLPId == '' && whsWorkLine.OrderCommittedInventDimId == '')
            ||  (_findWithLocatedLP && (whsWorkLine.LocatedLPId != '' || whsWorkLine.OrderCommittedInventDimId != '')));

        return whsWorkLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPickLinesWithDifferentLocatedLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work has any pick work lines with multiple located license plate ID.
    /// </summary>
    /// <param name="_workId">
    /// A work ID.
    /// </param>
    /// <returns>
    /// true if the work has any pick work lines with a located license plate ID; otherwise, false.
    /// </returns>
    public static boolean hasPickLinesWithDifferentLocatedLP(WHSWorkId _workId)
    {
        WHSWorkLine whsWorkLine;
        Counter countDifferentLocatedLP;

        while select LocatedLPId from whsWorkLine
            group by whsWorkLine.LocatedLPId
            where whsWorkLine.WorkId == _workId
                && whsWorkLine.WorkType == WHSWorkType::Pick
                && whsWorkLine.LocatedLPId != ''
        {
            countDifferentLocatedLP++;

            if (countDifferentLocatedLP > 1)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasTransferOrderInventLocationToWHSEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if for related transfer orders exist To warehouse which is used for warehouse management processes.
    /// </summary>
    /// <param name="_workId">
    /// A work ID.
    /// </param>
    /// <returns>
    /// true if exists To warehouse which is used for warehouse management processes; otherwise, false.
    /// </returns>
    public static boolean hasTransferOrderInventLocationToWHSEnabled(WHSWorkId _workId)
    {
        WHSWorkLine workLine;
        InventTransferLine inventTransferLine;
        InventTransferTable inventTransferTable;
        InventLocation inventLocation;

        select firstonly forceselectorder WorkId from workLine
            where workLine.WorkId == _workId &&
                workLine.WorkType == WHSWorkType::Pick
            join TableId from inventTransferLine
                where inventTransferLine.InventTransId == workLine.InventTransId
            join TableId from inventTransferTable
                where inventTransferTable.TransferId == inventTransferLine.TransferId
            join TableId from inventLocation
                where inventLocation.InventLocationId == inventTransferTable.InventLocationIdTo &&
                    inventLocation.WHSEnabled == true;

        return workLine.WorkId != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasWorkLinesWithContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work has any lines a container Id.
    /// </summary>
    /// <returns>True if any lines have a container Id; Otherwise, false.</returns>
    [Hookable(false)]
    internal boolean hasWorkLinesWithContainer()
    {
        WHSWorkLine workLine;

        select firstonly RecId from workLine
            where workLine.WorkId == this.WorkId
                && workLine.ContainerId != '';

        return (workLine.RecId != 0);
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPickLinesWithoutLocatedLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work has any pick work lines without a located license plate ID.
    /// </summary>
    /// <param name="_workId">
    /// A work ID.
    /// </param>
    /// <returns>
    /// true if the work has any pick work lines without a located license plate ID; otherwise, false.
    /// </returns>
    public static boolean hasPickLinesWithoutLocatedLP(WHSWorkId _workId)
    {
        return WHSWorkTable::hasPickLinesWithOrWithoutLocatedLP(_workId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWorkLockedByPersonImage</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Retrieves the photo of the person tasked with executing the current work order.
    /// </summary>
    /// <returns>
    /// A container containing the image of the person executing the work.
    /// </returns>
    /// <remarks>
    /// Returns a generic image with NotAvailable sign if the work order is not locked to a specific user.
    /// </remarks>
    [SysClientCacheDataMethod]
    public display container displayWorkLockedByPersonImage()
    {
        if (this.LockedUser)
        {
            return WHSWorkUser::find(this.LockedUser).workerPersonImage();
        }

        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWorkCountHeldByCurrentReplen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the number of work orders that are dependent on completing the current replenishment work.
    /// </summary>
    /// <returns>
    /// Returns <c>Counter</c> object.
    /// </returns>
    [SysClientCacheDataMethod]
    public display Counter displayWorkCountHeldByCurrentReplen()
    {
        Counter demandWorkCount;
        WHSReplenWorkLink replenWorkLink;

        while select RecId from replenWorkLink
            group by DemandWorkId
            where replenWorkLink.ReplenWorkId == this.WorkId
        {
            demandWorkCount++;
        }

        return demandWorkCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowChangeWorkLockedUser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if it should be allowed to change the work user that the work is locked to.
    /// </summary>
    /// <returns>
    /// True if the work user can be changed; otherwise, false.
    /// </returns>
    public boolean allowChangeWorkLockedUser()
    {
        switch (this.WorkStatus)
        {
            case WHSWorkStatus::Closed, WHSWorkStatus::Cancelled:
                return false;

            case WHSWorkStatus::InProcess:
                WHSWorkLine workLineLocal;
                WHSWorkLine workLinePut;

                select firstonly WorkType, RecId from workLineLocal
                    where workLineLocal.WorkId == this.WorkId
                        && workLineLocal.Skipped == NoYes::No
                        && workLineLocal.WorkStatus < WHSWorkStatus::Skipped
                    exists join workLinePut
                        where workLinePut.WorkId == workLineLocal.WorkId
                            && workLinePut.LineNum == workLineLocal.LineNum - 1
                            && workLinePut.WorkType == WHSWorkType::Put
                            && workLinePut.WorkStatus == WHSWorkStatus::Closed;

                return workLineLocal.RecId != 0 && workLineLocal.WorkType == WHSWorkType::Pick;

            default:
                return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isImmediateReplenishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays whether the work is of type of immediate replenishment
    /// </summary>
    /// <returns>true if work is immediate replenishment, otherwise not </returns>
    public display NoYes isImmediateReplenishment()
    {
        return this.ImmediateReplenishmentUnitId != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayMainNotes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the notes associated with the current work header.
    /// </summary>
    /// <returns>Notes related to <c>WHSWorkTable</c> record.</returns>
    public display Notes displayMainNotes()
    {
        Common common;

        WhsWorkTransactionType workTransactiontype = WhsWorkTransactionType::singletonFromTypeOrDefault(this.WorkTransType);

        if (workTransactiontype.isForOutboundShipment())
        {
            WHSWorkOrderInterface workOrder = WHSWorkOrderInterface::createInstanceFromBuffer(this);
            common = workTransactionType.findSourceOrderByWorkOrder(workOrder);
        }

        if (common)
        {
            WHSParameters whsParameters = WHSParameters::find();

            DocuRefSearch docuRefHead = DocuRefSearch::newTypeIdAndRestriction(common,
                whsParameters.ShipPickListNoteType,
                DocuRestriction::Internal);

            return Docu::concatDocuRefNotes(docuRefHead);
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work can be completed.
    /// </summary>
    /// <returns>true if the work can be completed; otherwise, false</returns>
    public boolean canBeCompleted()
    {
        return (this.WorkStatus == WHSWorkStatus::Open || this.WorkStatus == WHSWorkStatus::InProcess)
            && !this.Frozen && this.WorkTransType != WHSWorkTransType::CycleCount
            && (this.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::EntireWorkOrder
                || (this.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::IndividualWorkLine && !this.hasUnFinishedReplenWork()))
            && (this.WorkTransType != WHSWorkTransType::Packing);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unskipPutLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Flips all skipped flags on put lines.
    /// </summary>
    /// <param name="_workId">
    /// The <c>WHSWorkId</c> to unskip lines for.
    /// </param>
    public static void unskipPutLines(WHSWorkId _workId)
    {
        WHSWorkLine workLine;

        ttsBegin;

        workLine.skipDataMethods(true);
        update_recordSet workLine
            setting Skipped = NoYes::No
            where workLine.WorkId   == _workId
                && workLine.WorkType == WHSWorkType::Put
                && workLine.Skipped  == NoYes::Yes;

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeReservedHandlingQuantityDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes inventory dimensions for a reservation.
    /// </summary>
    /// <param name="_movement">
    /// The source document line movement which dimensions are changed for.
    /// </param>
    /// <param name="_reserveHandlingQty">
    /// The handling quantity to change dimensions for.
    /// </param>
    /// <param name="_inventDimFrom">
    /// The inventory dimension for the previous reservation.
    /// </param>
    /// <param name="_inventDimTo">
    /// The inventory dimension for new reservation.
    /// </param>
    [Hookable(false)]
    internal static void changeReservedHandlingQuantityDimensions(
        InventMovement      _movement,
        InventHandlingQty   _reserveHandlingQty,
        InventDim           _inventDimFrom,
        InventDim           _inventDimTo)
    {
        WHSWorkTable::updateReservationExtended(_movement, _reserveHandlingQty, _inventDimFrom, _inventDimTo, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeReservedHandlingQuantityDimensionsAllowingReduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes inventory dimensions for a reservation allowing reduction of reservation.
    /// </summary>
    /// <param name="_movement">
    /// The source document line movement which dimensions are changed for.
    /// </param>
    /// <param name="_reserveHandlingQty">
    /// The handling quantity to change dimensions for.
    /// </param>
    /// <param name="_inventDimFrom">
    /// The inventory dimension for the previous reservation.
    /// </param>
    /// <param name="_inventDimTo">
    /// The inventory dimension for new reservation.
    /// </param>    
    internal protected static void changeReservedHandlingQuantityDimensionsAllowingReduction(
        InventMovement      _movement,
        InventHandlingQty   _reserveHandlingQty,
        InventDim           _inventDimFrom,
        InventDim           _inventDimTo)
    {
        WHSWorkTable::updateReservationExtended(_movement, _reserveHandlingQty, _inventDimFrom, _inventDimTo, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if update reservation should be executed. 
    /// </summary>
    /// <returns>true if standard reservation logic should be executed; otherwise, false.</returns>
    /// <remarks>It is recommneded to run standard update reservation logic. Skipping it may cause serious data corruption issues.</remarks>
    protected static boolean shouldUpdateReservation()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReservationExtended</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes inventory dimensions for a reservation.
    /// </summary>
    /// <param name="_movement">
    /// The source document line movement which dimensions are changed for.
    /// </param>
    /// <param name="_reservQty">
    /// The handling quantity to change dimensions for.
    /// </param>
    /// <param name="_inventDimFrom">
    /// The inventory dimension for the previous reservation.
    /// </param>
    /// <param name="_inventDimTo">
    /// The inventory dimension for new reservation.
    /// </param>
    /// <param name="_allowReservationReduction">
    /// Determining whether reduction of reservation is allowed.
    /// </param>
    /// <remarks>
    /// The method should not be called directly.
    /// Instead the changeReservedHandlingQuantityDimensions method or
    /// changeReservedHandlingQuantityDimensionsAllowingReduction method should be called instead.
    /// </remarks>
    protected static void updateReservationExtended(
        InventMovement      _movement,
        InventHandlingQty   _reservQty,
        InventDim           _inventDimFrom,
        InventDim           _inventDimTo,
        boolean             _allowReservationReduction)
    {
        if (!WhsWorkTable::shouldUpdateReservation())
        {
            return;
        }

        InventQty           reserveQty;
        PdsInventQty        reserveCWQty;
        if (!_movement.pdsCWItem())
        {
            reserveQty      = _reservQty;
            reserveCWQty    = 0;
        }
        else
        {
            reserveQty      = WHSInvent::defaultCatchWeightReserveQuantity(_movement.itemId(), _reservQty);
            reserveCWQty    = _reservQty;
        }
        
        InventDimParm inventDimParm;
        
        ttsbegin;

        inventDimParm.setAllInventDim();

        InventUpd_Reservation reserve = WHSWorkTable::initializeUnreserveParameters(_movement,
                                                                         _inventDimFrom,
                                                                         inventDimParm,
                                                                         reserveQty,
                                                                         reserveCWQty);
        
        // Call unreserve
        reserve.updateNow();

        inventDimParm.initFromInventDim(_movement.inventdim());

        // Create reservation class for reserving more
        reserve = WHSWorkTable::initializeReserveParameters(_movement,
                                                   _inventDimTo, 
                                                   inventDimParm, 
                                                   -reserveQty, 
                                                   -reserveCWQty,
                                                   _allowReservationReduction);
        
        reserve.updateNow();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeUnreserveParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes unreserve parameters.
    /// </summary>
    /// <param name = "_movement">The source document line movement which dimensions are changed for.</param>
    /// <param name = "_inventDimFrom">The inventory dimensions of the reservation.</param>
    /// <param name = "_inventDimParm">The inventory dimension parameters.</param>
    /// <param name = "_reserveQty">Reserve quantity.</param>
    /// <param name = "_reserveCwQty">Reserve catch weight quantity.</param>
    /// <returns>Instance of <c>InventUpd_Reservation</c> with initialized parameters.</returns>
    protected static InventUpd_Reservation initializeUnreserveParameters(
        InventMovement _movement,
        InventDim      _inventDimFrom,
        InventDimParm  _inventDimParm,
        InventQty      _reserveQty,
        PdsCWInventQty _reserveCwQty)
    {
        InventUpd_Reservation reserve = InventUpd_Reservation::newParameters(_movement,
                                                       _inventDimFrom,
                                                       _inventDimParm,
                                                       InventDimFixedClass::inventDimParm2InventDimFixed(_inventDimParm),
                                                       _reserveQty,
                                                       false,
                                                       false,
                                                       _reserveCWQty);

        // Make sure parms are setup to only unreserve physical reserved transactions and also prevent reserved ordered transactions from taking newly available inventory.
        reserve.parmOnlyUnReservePhysicalReserved(true);
        reserve.parmAllowAutoReserveDim(false);

        return reserve;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeReserveParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes reserve parameters.
    /// </summary>
    /// <param name = "_movement">The source document line movement which dimensions are changed for.</param>
    /// <param name = "_inventDimCriteria">The inventory dimensions of the reservation.</param>
    /// <param name = "_inventDimParm">The inventory dimension parameters.</param>
    /// <param name = "_reserveQty">Reserve quantity.</param>
    /// <param name = "_reserveCwQty">Reserve catch weight quantity.</param>
    /// <param name = "_allowReserveReduction">A boolean determining whether reduction of reservation is allowed.</param>
    /// <returns>Instance of <c>InventUpd_Reservation</c> with initialized parameters.</returns>
    protected static InventUpd_Reservation initializeReserveParameters(
        InventMovement _movement,
        InventDim      _inventDimCriteria,
        InventDimParm  _inventDimParm,
        InventQty      _reserveQty,
        PdsCWInventQty _reserveCwQty,
        boolean        _allowReserveReduction)
    {
        InventUpd_Reservation reserve = InventUpd_Reservation::newParameters(_movement,
                                                       _inventDimCriteria,
                                                       _inventDimParm,
                                                       InventDimFixedClass::inventDimParm2InventDimFixed(_inventDimParm),
                                                       _reserveQty,
                                                       true,
                                                       false,
                                                       _reserveCwQty);

        reserve.parmAllowReserveReduction(_allowReserveReduction);
        reserve.parmAllowReserveOrdered(false);
        
        return reserve;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Displays all items in the work.
    /// </summary>
    /// <returns>
    ///  A string to list all items in the work.
    /// </returns>
    display ItemId displayItems()
    {
        str         items;
        WHSWorkLine workLine;

        while select ItemId from workLine
            group by ItemId
            where workLine.WorkId == this.WorkId
                && workLine.ItemId
        {
            if (!items)
            {
                items = workLine.ItemId;
            }
            else
            {
                items += ', ' + workLine.ItemId;
            }
        }

        return items;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFinalPutLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the final put location of the work.
    /// </summary>
    /// <returns>
    /// The final put location of the work.
    /// </returns>
    display WHSWorkFinalPutLocationId displayFinalPutLocation()
    {
        if (this.WorkTransType != WHSWorkTransType::CycleCount)
        {
            return this.getFinalPutLocation();
        }
        else
        {
            WHSWorkLine     workLine;

            select firstonly wmsLocationId from workLine
                order by workLine.LineNum desc
                where workLine.WorkId == this.WorkId;
            
            return workline.wmsLocationId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayStartLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the open start location of the work.
    /// </summary>
    /// <returns>
    /// Start location
    /// </returns>
    display WHSWorkStartLocationId displayStartLocation()
    {
        WHSWorkLine     workLine;

        select firstonly wmsLocationId from workLine
            order by workLine.LineNum asc
            where workLine.WorkId       == this.WorkId
                && workLine.WorkStatus    < WHSWorkStatus::Skipped
                && workLine.WorkType     == WHSWorkType::Pick
                && workLine.Skipped      == NoYes::No;

        return workLine.wmsLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowsExtraHandlingUnitQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the work trans type is able to use a handling unit.
    /// </summary>
    /// <param name="_workId">
    /// The <c>WHSWorkId</c> related to record.
    /// </param>
    /// <returns>
    /// True if the work type can use a handling unit, otherwise false.
    /// </returns>
    public static boolean allowsExtraHandlingUnitQty(WHSWorkId _workId)
    {
        return _workId &&
           (select firstonly RecId from whsWorkTable
            where whsWorkTable.WorkId           == _workId
                && whsWorkTable.WorkTransType   == WHSWorkTransType::ProdPick).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEnumerator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the enumerator over 'Work line Load line details'.
    /// </summary>
    /// <param name="_queryOnlyClosedWorkLines">
    /// true, if only Closed work lines should be considered; otherwise, false, which means all non-cancelled work lines will be looped.
    /// </param>
    /// <returns>
    /// The instance of <c>WHSWorkLineLoadLineDetailsEnumerator</c> type.
    /// </returns>
    /// <remarks>
    /// Depending on the <c>HasWorkLineLoadLineDetails</c> flag, the enumerator will loop over either
    /// the initial pick <c>WHSWorkLine</c> records or <c>WHSWorkLineLoadLineDetails</c> records.
    /// </remarks>
    public WHSWorkLineLoadLineDetailsEnumerator getEnumerator(boolean _queryOnlyClosedWorkLines = false)
    {
        return WHSWorkLineLoadLineDetailsEnumerator::newFromWorkId(this.WorkId, _queryOnlyClosedWorkLines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOriginForConsolidatedWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work has been consolidated into another work order
    /// as part of License plate consolidation flow.
    /// </summary>
    /// <returns>True if the work is closed and has been merged into another work; otherwise, false.</returns>
    public boolean isOriginForConsolidatedWork()
    {
        WHSConsolidatedWorkLine consolidatedWorkLine;
        WHSWorkLine             originWorkLine;

        // If the work is not closed, it means it has not been consolidated into another work order.
        if (this.WorkStatus != WHSWorkStatus::Closed)
        {
            return false;
        }

        if (!WHSSessionCache::consolidatedWorkLinesExist().isConsolidationUsed())
        {
            return false;
        }

        select firstonly RecId from consolidatedWorkLine
            exists join originWorkLine
                where originWorkLine.RecId == consolidatedWorkLine.OriginWorkLine
                    && originWorkLine.WorkId == this.WorkId;

        return consolidatedWorkLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromWorkTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes work table recrod with another work table record's fields.
    /// </summary>
    /// <param name="_workTable">
    /// The existing work unit used to initialize a new work unit.
    /// </param>
    [Hookable(false)]
    internal final void initFromWorkTable(WHSWorkTable _workTable)
    {
        this.InventLocationId           = _workTable.InventLocationId;
        this.InventSiteId               = _workTable.InventSiteId;
        this.LoadId                     = _workTable.LoadId;
        this.OrderNum                   = _workTable.OrderNum;
        this.ClusterProfileId           = _workTable.ClusterProfileId;
        this.ShipmentId                 = _workTable.ShipmentId;
        this.WaveId                     = _workTable.WaveId;
        this.WorkPoolId                 = _workTable.WorkPoolId;
        this.WorkPriority               = _workTable.WorkPriority;
        this.WorkTemplateCode           = _workTable.WorkTemplateCode;
        this.WorkTransType              = _workTable.WorkTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginWorkTransType</Name>
				<Source><![CDATA[
    public WHSWorkTransType getOriginWorkTransType()
    {
        return WHSWorkTable::calculateOriginWorkTransType(this.WorkTransType, this.ShipmentId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateOriginWorkTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// It calculates the origin work transaction type given the <c>WHSWorkTransType</c> and <c>WHSShipmentId</c> values.
    /// </summary>
    /// <param name = "_workTransType">The work transaction type of the work.</param>
    /// <param name = "_shipmentId">The shipment ID of the current work.</param>
    /// <returns>The origin work transaction type.</returns>
    [Hookable(false)]
    internal static WHSWorkTransType calculateOriginWorkTransType(WHSWorkTransType _workTransType, WHSShipmentId _shipmentId)
    {
        WHSWorkTransType originOrderWorkTransType;

        if (_workTransType == WHSWorkTransType::PackedContainerPicking)
        {
            originOrderWorkTransType = WHSShipmentTable::find(_shipmentId).WorkTransType;
        }
        else
        {
            originOrderWorkTransType = _workTransType;
        }

        return originOrderWorkTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLicensePlateSpecificReservationRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if for the specific work order we need to do the reservation on the License plate level.
    /// </summary>
    /// <returns>True, if the reservation should be performed on the License plate level; otherwise, false.</returns>
    public boolean isLicensePlateSpecificReservationRequired()
    {
        return WhsWorkTransactionType::singletonFromTypeOrDefault(this.WorkTransType).isLicensePlateSpecificReservationRequired();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkLinkedToActiveDemandWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the work with the specified work ID is linked to an active demand work.
    /// </summary>
    /// <param name = "_workId">Work ID.</param>
    /// <returns>true if the work is linked to and active demand work; otherwise false.</returns>
    public static boolean isWorkLinkedToActiveDemandWork(WHSWorkId _workId)
    {
        WHSReplenWorkLink replenWorkLink;

        select firstonly RecId, DemandWorkId from replenWorkLink
            where replenWorkLink.ReplenWorkId == _workId
                && replenWorkLink.InventQty   != 0; // Make sure an active work link record is found.

        if (replenWorkLink.RecId
            &&  WHSWorkTable::find(replenWorkLink.DemandWorkId).WorkStatus != WHSWorkStatus::Cancelled)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUnFinishedContainerizationWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work has any unfinished work lines that are prepared for containerization.
    /// </summary>
    /// <returns>True if the work has any unfinished work lines that are prepared for containerization; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean hasUnFinishedContainerizationWorkLines()
    {
        WHSWorkLine workLine;

        select firstonly RecId from workLine
            where workLine.WorkId == this.WorkId
                && workLine.ContainerId != ''
                && workLine.WorkStatus != WHSWorkStatus::Closed
                && workLine.WorkStatus != WHSWorkStatus::Cancelled
                && workLine.WorkStatus != WHSWorkStatus::Combined;

        return (workLine.recId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeUnBlockedThrowOnError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work can be unblocked. If the work cannot be unblocked an exception is thrown.
    /// </summary>
    /// <returns>True if the work can be unblocked; otherwise, false.</returns>
    public boolean canBeUnBlockedThrowOnError()
    {
        return this.validateCanBeUnBlocked(false, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeUnBlockedInfoWarning</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work can be unblocked. If the work cannot be unblocked a warning is added to the infolog.
    /// </summary>
    /// <returns>True if the work can be unblocked; otherwise, false.</returns>
    public boolean canBeUnBlockedInfoWarning()
    {
        return this.validateCanbeUnBlocked(true, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeUnBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work can be unblocked.
    /// </summary>
    /// <returns>True if the work can be unblocked; otherwise, false.</returns>
    public boolean canBeUnBlocked()
    {
        return this.validateCanBeUnBlocked(false, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCanBeUnBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work can be unblocked.
    /// </summary>
    /// <param name="_addWarning">
    /// A boolean determining if warnings should be added to the infolog if the work cannot be unblocked.
    /// </param>
    /// <param name="_throwError">
    /// A boolean determining an error should be thrown if the work cannot be unblocked.
    /// </param>
    /// <returns>True if the work can be unblocked; otherwise, false.</returns>
    private boolean validateCanBeUnBlocked(
        boolean _addWarning,
        boolean _throwError)
    {
        if (!this.Frozen)
        {
            return true;
        }

        if (this.hasUnFinishedReplenWork())
        {
            if (this.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::EntireWorkOrder)
            {
                if (_throwError)
                {
                    throw error(strFmt("@WAX4040", this.WorkId));
                }
                else if (_addWarning)
                {
                    checkFailed(strFmt("@WAX4040", this.WorkId));
                }

                return false;
            }
            else if (this.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::IndividualWorkLine
                && this.hasUnFinishedContainerizationWorkLines())
            {
                if (_throwError)
                {
                    throw error(strFmt("@WAX:CannotUnBlockWorkWithContainerLinesAndPendingReplenishment", this.WorkId));
                }
                else if (_addWarning)
                {
                    checkFailed(strFmt("@WAX:CannotUnBlockWorkWithContainerLinesAndPendingReplenishment", this.WorkId));
                }

                return false;
            }
        }

        boolean ret = true;

        if (this.WorkTransType == WHSWorkTransType::Replenishment)
        {
            ret = this.validateCanReplenishmentWorkBeUnBlocked(_throwError, _addWarning);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCompleteWorkWithMultipleLocatedLPs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check that the work can be completed in case if exists multiple located LPs.
    /// </summary>
    /// <returns>True if the work can be completed; otherwise, false.</returns>
    private boolean canCompleteWorkWithMultipleLocatedLPs()
    {
        return this.TargetLicensePlateId ||
            this.WorkTransType != WHSWorkTransType::TransferIssue ||
            !WHSWorkTable::hasPickLinesWithDifferentLocatedLP(this.WorkId) ||
            !WHSWorkTable::hasTransferOrderInventLocationToWHSEnabled(this.WorkId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCanReplenishmentWorkBeUnBlocked</Name>
				<Source><![CDATA[
    private boolean validateCanReplenishmentWorkBeUnBlocked(
        boolean _throwError,
        boolean _addWarning)
    {
        WHSWaveId waveId = this.replenForUnfinishedDemandWave();

        if (waveId)
        {
            if (_throwError)
            {
                throw error(strFmt("@WAX:ValidationErrorUnblockReplenWork", this.WorkId, waveId));
            }
            else if (_addWarning)
            {
                checkFailed(strFmt("@WAX:ValidationErrorUnblockReplenWork", this.WorkId, waveId));
            }

            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>replenForUnfinishedDemandWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the WaveId of the demand wave which is still Executing related to the current Replenishment work.
    /// </summary>
    /// <returns>The WaveId of the demand wave which is still Executing related to the current Replenishment work.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true), Replaceable(true)]
    internal WHSWaveId replenForUnfinishedDemandWave()
    {
        if (this.WorkTransType != WHSWorkTransType::Replenishment)
        {
            return '';
        }

        WHSWaveTable        demandWave;
        WHSReplenWorkLink   replenWorkLink;

        // Work build ID must be populated, or we risk finding an unrelated wave that hasn't been processed and
        // can match permanent links which are created after demand work is created and have a blank work build ID.
        select firstonly WaveId from demandWave
            where demandWave.WaveStatus <= WHSWaveStatus::Executing
            exists join replenWorkLink
                where replenWorkLink.WorkBuildId  != ''
                &&    replenWorkLink.WorkBuildId  == demandWave.WorkBuildId
                &&    replenWorkLink.ReplenWorkId == this.WorkId
                &&    replenWorkLink.InventQty;

        return demandWave.WaveId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfLinesBlockedByReplenishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the number of work lines that are blocked by replenishment.
    /// </summary>
    /// <returns>The number of work lines that are blocked by replenishment.</returns>
    public display WHSNumberOfWorkLinesBlockedByReplenishment numberOfLinesBlockedByReplenishment()
    {
        WHSWorkLine workLineBlockedByReplenishment;

        if (this.canHaveLinkedReplenishmentWork())
        {
            select count (RecId) from workLineBlockedByReplenishment
                where workLineBlockedByReplenishment.WorkId == this.WorkId
                    && workLineBlockedByReplenishment.ReplenDemand == NoYes::Yes;
        }

        return int642int(workLineBlockedByReplenishment.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfOpenWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the number of open work lines.
    /// </summary>
    /// <returns>The number of open work lines.</returns>
    [Hookable(false)]
    internal final int64 numberOfOpenWorkLines()
    {
        WHSWorkLine openWorkLines;

        if (this.WorkId)
        {
            select count(RecId) from openWorkLines
                where openWorkLines.WorkId == this.WorkId
                    && openWorkLines.WorkStatus == WHSWorkStatus::Open;
        }

        return openWorkLines.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workProcessingTimeCalculationStrategyType</Name>
				<Source><![CDATA[
    private static WHSWorkProcessingTimeCalculationStrategyType workProcessingTimeCalculationStrategyType()
    {
        WHSWorkProcessingTimeCalculationStrategyType calculationStrategyType = WHSWorkProcessingTimeCalculationStrategyType::CurrentTime;

        var workProcessingTimeCalculationStrategyContext = WHSWorkProcessingTimeCalculationStrategyContext::current();

        if (workProcessingTimeCalculationStrategyContext)
        {
            calculationStrategyType = workProcessingTimeCalculationStrategyContext.parmWorkProcessingTimeCalculationStrategyType();
        }

        return calculationStrategyType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workProcessingTimeCalculationStrategy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the strategy that should be used to calculate new processing times.
    /// </summary>
    /// <returns>The strategy that should be used to calculate new processing times.</returns>
    [Hookable(false)]
    internal static WHSWorkProcessingTimeCalculationStrategy workProcessingTimeCalculationStrategy()
    {
        var calculationStrategyType = WHSWorkTable::workProcessingTimeCalculationStrategyType();

        return WHSWorkProcessingTimeCalculationStrategy::newFromCalculationStrategyType(calculationStrategyType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>workProcessingTimeSource</Name>
				<Source><![CDATA[
    private WHSWorkProcessingTimeSource workProcessingTimeSource()
    {
        return WHSWorkProcessingTimeSource::newFromBuffer(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInProcess</Name>
				<Source><![CDATA[
    internal void setInProcess(WHSWorkProcessingTimeCalculationStrategy _workProcessingTimeCalculationStrategy)
    {
        this.WorkStatus                = WHSWorkStatus::InProcess;
        this.WorkInProcessUTCDateTime  = _workProcessingTimeCalculationStrategy.calculateNewInProcessDateTime(this.workProcessingTimeSource());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setClosed</Name>
				<Source><![CDATA[
    internal void setClosed(WHSWorkProcessingTimeCalculationStrategy _workProcessingTimeCalculationStrategy)
    {
        this.WorkStatus             = WHSWorkStatus::Closed;
        this.WorkClosedUTCDateTime  = _workProcessingTimeCalculationStrategy.calculateNewClosedDateTime(this.workProcessingTimeSource());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkStatusFromWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work order status based on the state of the related work lines
    /// </summary>
    public static void updateWorkStatusFromWorkLines(WHSWorkId _workId, WHSUserId _userId = '')
    {
        WhsWorkTableStatusUpdater::newFromWorkId(_workId).update(_userId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasOpenPickLinesPriorToFirstPut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work has any open pick line prior to first put.
    /// </summary>
    /// <returns>True, if the work has any open pick line prior to first put; otherwise, false.</returns>
    public boolean hasOpenPickLinesPriorToFirstPut()
    {
        WHSWorkLine workLine;
        LineNum     firstPutLineNum  = WHSWorkTable::getFirstPutWorkLine(this.WorkId).LineNum;

        select firstonly RecId from workLine
            where workLine.LineNum       <  firstPutLineNum
               && workLine.WorkId        == this.WorkId
               && workLine.WorkType      == WHSWorkType::Pick
               && workLine.WorkStatus    == WHSWorkStatus::Open;

        return workLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkBeingSplit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work with the passed work id is being split.
    /// </summary>
    /// <param name = "_workId">The id of the work to check if it is being split</param>
    /// <returns>
    /// Returns <c>boolean</c> object.
    /// </returns>
    [Hookable(false)]
    internal static boolean isWorkBeingSplit(WHSWorkId _workId)
    {
        WHSWorkBlocking workBlocking = WHSWorkBlocking::newFromWorkId(_workId);

        return workBlocking.isBlockedByReasonType(WHSWorkBlockingReasonType::SplitWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the number of worklines from a work header.
    /// </summary>
    /// <param name = "_workId">A work Id.</param>
    /// <returns>The number of worklines of the work with the passed work id.</returns>
    [Hookable(false)]
    internal static NumberOfRecords numberOfWorkLines(WHSWorkId _workId)
    {
        WHSWorkLine workline;

        if (_workId)
        {
            select count(RecId) from workline
                where workline.WorkId == _workId;
        }

        return workline.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFinalPutQtyWithinReplenishmentOverflowCapacity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current <c>WHSWorkTable</c> record is valid for replenishment overflow.
    /// </summary>
    /// <returns>
    /// true if it the work is valid; otherwise, false
    /// </returns>
    [Hookable(false)]
    internal boolean isFinalPutQtyWithinReplenishmentOverflowCapacity()
    {
        WHSWorkLine workLine;

        select firstonly workLine
            order by LineNum desc
            where workLine.WorkType == WHSWorkType::Put
                && workLine.WorkStatus!= WHSWorkStatus::Cancelled
                && workLine.WorkStatus != WHSWorkStatus::Combined
                && workLine.WorkId == this.WorkId;
      
        return WHSReplenishmentOverLocationCapacityValidator::newFromWorkLine(workLine)
                                                             .isWorkQtyWithinReplenishmentOverflowCapacity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkBlockingForStatusChange</Name>
				<Source><![CDATA[
    private void updateWorkBlockingForStatusChange(
        WMSLocation _wmsLocation,
        boolean     _replenOpenToInProcess)
    {
        if (_replenOpenToInProcess)
        {
            _wmsLocation.blockReplenishmentOverflowWorkOverCapacity();
        }
        else
        {
            _wmsLocation.unblockReplenishmentOverflowWorkWithinCapacity();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkChangedFromOpenToInProcess</Name>
				<Source><![CDATA[
    private boolean isWorkChangedFromOpenToInProcess()
    {
        return this.orig().WorkStatus == WHSWorkStatus::Open
            && this.WorkStatus == WHSWorkStatus::InProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkChangedFromInProcessToOpen</Name>
				<Source><![CDATA[
    private boolean isWorkChangedFromInProcessToOpen()
    {
        return this.orig().WorkStatus == WHSWorkStatus::InProcess
            && this.WorkStatus == WHSWorkStatus::Open;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCrossDockWorkBuildId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and returns the work build ID for cross docking.
    /// </summary>
    /// <param name = "_licensePlateId">The license plate ID.</param>
    /// <returns>The work build ID for cross docking.</returns>
    [Hookable(false)]
    internal static WHSWorkCreateId findCrossDockWorkBuildId(WHSLicensePlateId _licensePlateId)
    {
        WHSWorkTable workTable;

		select firstOnly WorkBuildId from workTable
			where workTable.WorkStatus           != WHSWorkStatus::Cancelled
			&&    workTable.WorkStatus           != WHSWorkStatus::Combined
			&&    workTable.WorkStatus           != WHSWorkStatus::Closed
			&&    workTable.TargetLicensePlateId == _licensePlateId
			&&    workTable.WorkTransType        == WHSWorkTransType::CrossDocking;

        return workTable.WorkBuildId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstStageLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first stage location of the work.
    /// </summary>
    /// <param name = "_workId">The work ID.</param>
    /// <returns>The first stage location of the work.</returns>
    [Hookable(false)]
    internal static WMSLocationId getFirstStageLocation(WHSWorkId _workId)
    {    
        WHSLocType stageLocType = WHSParameters::find().StageLocType;
        WMSLocationId locationId;
    
		if (stageLocType)
        {
			WHSWorkLine     workLine;

			while select WorkId, WMSLocationId from workLine
				order by workLine.LineNum
				where workLine.WorkId == _workId
				&&	  workLine.WorkType == WHSWorkType::Put
			{
				if (stageLocType == workLine.getLocType())
				{
					locationId = workLine.WMSLocationId;
					break;
				}
			}
        }
    
        return locationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkEligibleForReplenishmentOverflow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work is eligible replenishment overflow.
    /// </summary>
    /// <returns>
    /// true if the work is eligible; otherwise, false.
    /// </returns>
    [Hookable(false)]
    internal boolean isWorkEligibleForReplenishmentOverflow()
    {
        if (this.WorkTransType == WHSWorkTransType::Replenishment)
        {
            return WMSLocation::find(this.getFinalPutLocation(), this.InventLocationId).isReplenishmentOverflowEnabled();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAnchoringPickLine</Name>
				<Source><![CDATA[
    private static WHSWorkLine findAnchoringPickLine(WHSWorkLine _putWorkLine, WHSWorkId _workId)
    {
        WHSWorkLine pickWorkLine;

        select firstonly forupdate pickWorkLine
            order by pickWorkLine.LineNum
            where pickWorkLine.WorkId        == _workId                    &&
                  pickWorkLine.WorkType      == WHSWorkType::Pick          &&
                  pickWorkLine.wmsLocationId == _putWorkLine.wmsLocationId &&
                  pickWorkLine.LineNum       >  _putWorkLine.LineNum;

        return pickWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canChangeWorkPool</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current work can change to a new work pool.
    /// </summary>
    /// <returns>
    /// true if the work status is valid; otherwise, false.
    /// </returns>
    [Hookable(false)]
    internal boolean canChangeWorkPool()
    {
        return this.WorkStatus != WHSWorkStatus::Closed
            && this.WorkStatus != WHSWorkStatus::Cancelled
            && this.WorkStatus != WHSWorkStatus::Combined;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoadShipStatusForDockInventoryManagement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update load and shipment status for work that went through dock inventory management.
    /// </summary>
    [Hookable(false)]
    internal void updateLoadShipStatusForDockInventoryManagement()
    {
        WHSWorkInventTrans  workInventTrans;
        WHSLoadTable        loadTable;
        WHSLoadLine         loadLine;

        WHSWorkLine workLine = WHSWorkTable::getLastClosedPutWorkLine(this.WorkId);

        while select loadLine
            group by LoadId, ShipmentId
            exists join workInventTrans
                where workInventTrans.InventTransIdParent == loadLine.InventTransId
					&& workInventTrans.WorkId == this.WorkId
					&& workInventTrans.LineNum == workLine.LineNum
                exists join loadTable
                    where loadTable.LoadId == loadLine.LoadId
						&& loadTable.LoadStatus != WHSLoadStatus::Loaded
						&& loadTable.LoadStatus != WHSLoadStatus::Shipped
        {
            if (WHSLoadTable::validateLoadCanBeLoaded(loadLine.LoadId))
            {
                WHSLoadTable::updateLoadStatus(loadLine.LoadId, WHSLoadStatus::Loaded);
            }

            if (WHSShipmentTable::validateShipmentCanBeLoaded(loadLine.ShipmentId))
            {
                WHSShipmentTable::updateShipmentStatus(loadLine.ShipmentId, WHSShipmentStatus::Loaded);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventDimFinalPut</Name>
				<Source><![CDATA[
    private InventDim createInventDimFinalPut(WMSLocationId _finalPutWMSLocationId)
    {
        InventDim inventDim;

        inventDim.wmsLocationId    = _finalPutWMSLocationId;
        inventDim.LicensePlateId   = this.TargetLicensePlateId;
        inventDim.InventSiteId     = this.InventSiteId;
        inventDim.InventLocationId = this.InventLocationId;

        return InventDim::findOrCreate(inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCombinedContainerTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventDim on all containers on combined work.
    /// </summary>
    /// <param name = "_finalPutWMSLocationId">The final put location of the work being closed.</param>
    private void updateCombinedContainerTable(WMSLocationId _finalPutWMSLocationId)
    {
        if (!WHSDockInventoryManagementFeature::instance().isEnabled())
        {
            return;
        }

        WHSWorkLine         conWorkLine;
        WHSWorkTable        conWorkTable;
        WHSWorkTable        workTable = WHSWorkTable::find(this.WorkId);
        
        while select ContainerId from conWorkLine
            where conWorkLine.WorkType == WHSWorkType::Pick
                && conWorkLine.ContainerId
                exists join conWorkTable
                where conWorkTable.WorkId == conWorkLine.WorkId
                    && conWorkTable.CombinedWorkId == this.WorkId
        {
            WHSContainerTable containerTable = WHSContainerTable::findByContainerId(conWorkLine.ContainerId, true);
            if (containerTable.RecId)
            {
                containerTable.InventDimId = workTable.createInventDimFinalPut(_finalPutWMSLocationId).InventDimId;
                containerTable.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateWorkForDockInventoryManagement</Name>
				<Source><![CDATA[
    [Hookable(false)]
	internal boolean canUpdateWorkForDockInventoryManagement()
    {
        // This scenario occurs when pallet merging staged work.
        return (WHSDockInventoryManagementFeature::instance().isEnabled()
			&& WHSWorkTable::GetFirstStageLocation(this.WorkId) != ''
			&& WHSWorkTable::getFirstPutWorkLine(this.WorkId).InventQtyWork != WHSWorkTable::getLastClosedPutWorkLine(this.WorkId).InventQtyWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWHSWorkTableWithSameLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the WHSWorkTable table has open works with this prod id and license plate.
    /// </summary>
    /// <param name = "_orderNum"> The <c>WHSOrderNum</c>. </param>
    /// <param name = "_whsLicensePlateId">The license plate that must to be verified. </param>
    /// <returns>
    /// The WHSWorkTable line of the open work.
    /// </returns>
    internal static WHSWorkTable findWHSWorkTableWithSameLicensePlate(WHSOrderNum _orderNum, WHSTargetLicensePlateId _whsLicensePlateId)
    {
        WHSWorkTable whsWorkTable;

        select firstonly whsWorkTable
            where whsWorkTable.OrderNum == _orderNum
               && whsWorkTable.WorkStatus == WHSWorkStatus::Open
               && whsWorkTable.TargetLicensePlateId == _whsLicensePlateId;

        return whsWorkTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSingleInboundWorkByWorkBuildId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the inbound work based on work build ID, omitting cross docking and quality item sampling.
    /// </summary>
    /// <param name="_workBuildId">The work build ID used to find the inbound work unit.</param>
    /// <param name="_forUpdate">true, if the record should be selected for update; otherwise, false.</param>
    /// <returns>
    /// The work record of the inbound work unit.
    /// </returns>
    [Hookable(false)]
    public static WHSWorkTable findSingleInboundWorkByWorkBuildId(WHSWorkBuildId _workBuildId, boolean _forUpdate = false)
    {
        WHSWorkTable workTable;
    
        if (_workBuildId)
        {
            workTable.selectForUpdate(_forUpdate);
            
            select firstOnly workTable
                where workTable.WorkBuildId     == _workBuildId
                &&    workTable.WorkTransType   != WHSWorkTransType::CrossDocking
                &&    workTable.WorkTransType   != WHSWorkTransType::QualityItemSampling;
        }

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsForWorkBuildId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean existsForWorkBuildId(WHSWorkBuildId _workBuildId)
    {
        WHSWorkTable workTable;
    
        if (_workBuildId)
        {
            select firstOnly workTable
                where workTable.WorkBuildId == _workBuildId;
        }

        return workTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFinalPutawayLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the final putaway location of a work unit based on put work lines.
    /// </summary>
    /// <param name="_workId">
    /// The work Id of the work unit to be evaluated.
    /// </param>
    /// <returns>
    /// The location of a work unit's final put locations. If it has multiple, method returns empty string.
    /// </returns>
    [Hookable(false)]
    internal static WMSLocationId findFinalPutawayLocation(WHSWorkId _workId)
    {
        WHSWorkLine     workLine;
        WMSLocationId   locationId;
    
        while select WorkType, WMSLocationId from workLine
            order by LineNum desc
            where workLine.WorkId == _workId
        {
            if (workLine.WorkType != WHSWorkType::Put)
            {
                break;
            }
    
            if (locationId && locationId != workLine.WMSLocationId)
            {
                locationId = '';
                break;
            }
    
            locationId = workLine.WMSLocationId;
        }
    
        return locationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTotalQualityItemSamplingWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity of quality item sampling work that is for a specific Item/InventDim combination.
    /// </summary>
    /// <param name = "_inventTransId">The inventory transaction ID for the corresponding source document.</param>
    /// <param name = "_inventDimId">Inventory dimension ID</param>
    /// <param name = "_itemId">Item ID</param>
    /// <param name = "_keepLocationAndBelowDim">Whether the location and below dimensions should be used.</param>
    /// <param name = "_inventQualityOrderId">The quality order id</param>
    /// <returns>Quantity on the quality item sampling work</returns>
    [Hookable(false)]
    internal static InventQty calculateTotalQualityItemSamplingWork(
        InventTransId   _inventTransId,
        InventDimId     _inventDimId,
        ItemId          _itemId,
        boolean         _keepLocationAndBelowDim = false, 
        InventQualityOrderId _inventQualityOrderId = "")
    {
        InventDim inventDim = InventDim::find(_inventDimId);
        WHSLicensePlateId targetLicensePlate = inventDim.LicensePlateId;
        
        if (!_keepLocationAndBelowDim)
        {
            inventDim.clearLocationAndBelowDim(_itemId);
            inventDim = InventDim::findOrCreate(inventDim);
        }

        WHSWorkTable    workTable;
        WHSWorkLine     workLine;
        InventQty       qty;        
    
        while select InventQtyWork, WorkId, LineNum, InventDimId, WMSLocationId from workLine
            exists join workTable
                where workTable.WorkId == workLine.WorkId
                    && workTable.WorkStatus != WHSWorkStatus::Cancelled
                    && workTable.WorkStatus != WHSWorkStatus::Combined
                    && workLine.WorkStatus != WHSWorkStatus::Cancelled
                    && workLine.WorkType == WHSWorkType::Pick
                    && workTable.TargetLicensePlateId == targetLicensePlate
                    && workLine.InventTransId == _inventTransId
                    && workLine.InventDimId == inventDim.inventDimId
                    && workTable.WorkTransType == WHSWorkTransType::QualityItemSampling
                    && (_inventQualityOrderId == "" || workTable.InventQualityOrderId == _inventQualityOrderId)
        {
            if (!WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum))
            {
                qty += workLine.InventQtyWork;
            }
        }
    
        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findQualityItemSamplingWorkBuildId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the work build ID for quality item sampling work.
    /// </summary>
    /// <param name = "_licensePlateId">The license plate ID.</param>
    /// <param name = "_inventQualityOrderId">The quality order id</param>
    /// <returns>The work build ID for quality item sampling work.</returns>
    [Hookable(false)]
    internal static WHSWorkCreateId findQualityItemSamplingWorkBuildId(WHSLicensePlateId _licensePlateId, InventQualityOrderId _inventQualityOrderId = "")
    {
        WHSWorkTable    workTable;
    
        select firstOnly WorkBuildId from workTable
            where  workTable.WorkStatus != WHSWorkStatus::Cancelled
                && workTable.WorkStatus != WHSWorkStatus::Combined
                && workTable.WorkStatus != WHSWorkStatus::Closed
                && workTable.TargetLicensePlateId == _licensePlateId
                && workTable.WorkTransType == WHSWorkTransType::QualityItemSampling
                && (_inventQualityOrderId == "" || workTable.InventQualityOrderId == _inventQualityOrderId);
    
        return workTable.WorkBuildId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastPutLineNumberForSpecificPickPutPair</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the last put line number for a specific pick/put pair.
    /// </summary>
    /// <param name = "_workId">Work ID for the related work lines</param>
    /// <param name = "_pickLineNum">Line number of the pick line</param>
    /// <returns>Line number of the last put that follows the pick line.</returns>
    [Hookable(false)]
    internal static LineNum getLastPutLineNumberForSpecificPickPutPair(WHSWorkId _workId, LineNum _pickLineNum)
    {
        // Get the first put line number following the current Pick.
        LineNum firstPutLineNum = WHSWorkLine::getNextOppositeWorkLine(_workId, _pickLineNum, WHSWorkType::Pick);

        WHSWorkLine workLine;
        LineNum lastPutLineNum;

        // Check if there are multiple puts and return the last one.
        while select LineNum, WorkType from workLine
            order by LineNum
            where  workLine.WorkId     == _workId
                && workLine.LineNum    >= firstPutLineNum
                && workLine.WorkStatus != WHSWorkStatus::Closed
                && workLine.WorkStatus != WHSWorkStatus::Cancelled
        {
            if (workLine.WorkType != WHSWorkType::Put)
            {
                break;
            }

            lastPutLineNum = workLine.LineNum;
        }

        return lastPutLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qualityOrderWorkExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if open, closed or inProcess work for Quality order exists
    /// </summary>
    /// <param name = "_inventQualityOrderId">Quality order identifier</param>
    /// <returns>true if open, closed or in-progress quality order work exists; otherwise, false</returns>
    [Hookable(false)]
    public static boolean qualityOrderWorkExists(InventQualityOrderId _inventQualityOrderId)
    {
        boolean ret; 
       
        if (_inventQualityOrderId)
        {
            WHSWorkTable workTable;

            select firstOnly RecId from workTable
                where workTable.OrderNum        == _inventQualityOrderId
                    && workTable.WorkTransType  == WHSWorkTransType::QualityOrder
                    && (workTable.WorkStatus    == WHSWorkStatus::Closed    ||
                        workTable.WorkStatus    == WHSWorkStatus::InProcess ||
                        workTable.WorkStatus    == WHSWorkStatus::Open );

            if (workTable.RecId != 0)
            {
                ret = true;
            }
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldHandleWorkStatusChange</Name>
				<Source><![CDATA[
    private boolean shouldHandleWorkStatusChange()
    {
        return this.WorkStatus == WHSWorkStatus::InProcess 
            && this.WorkTransType != WHSWorkTransType::TransferReceipt
            && this.WorkTransType != WHSWorkTransType::Packing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    [Hookable(false)]
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workTableHasConsecutivePutLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work header contains consecutive put lines.
    /// </summary>
    /// <param name = "_workId">The work id of the work header.</param>
    /// <returns>true if there are consecutive put lines; otherwise, false.</returns>
    [Hookable(false)]
    internal static boolean workTableHasConsecutivePutLines(WHSWorkId _workId)
    {
        boolean isPreviousLinePut;

        WHSWorkLine putWorkLine;
        while select WorkType from putWorkLine
            order by LineNum desc
            where  putWorkLine.WorkId     == _workId
                && putWorkLine.WorkStatus != WHSWorkStatus::Closed
                && putWorkLine.WorkStatus != WHSWorkStatus::Cancelled
        {
            if (putWorkLine.WorkType != WHSWorkType::Put)
            {
                break;
            }
            
            if (isPreviousLinePut)
            {
                return true;
            }

            isPreviousLinePut = true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveWorkPutFlow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves work put flow based on work line.
    /// </summary>
    /// <param name = "_workLine">Work line.</param>
    /// <returns>Work put flow.</returns>
    [Hookable(false)]
    internal static WHSWorkPutFlow retrieveWorkPutFlow(WHSWorkLine _workLine)
    {
        WHSWorkLine prevOppositeWorkLine = WHSWorkLine::getPrevOppositeWorkLine(_workLine.WorkId, _workLine.LineNum, _workLine.WorkType);
            
        return prevOppositeWorkLine.InventQtyWork > _workLine.InventQtyWork ? WHSWorkPutFlow::SplitQuantity : WHSWorkPutFlow::MoveAll;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsActiveWorkByQualityOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if active work for Quality order exists.
    /// </summary>
    /// <param name = "_inventQualityOrderId">Quality order identifier</param>
    /// <returns>true if active work exists; otherwise, false</returns>
    [Hookable(false)]
    internal static boolean existsActiveWorkByQualityOrder(InventQualityOrderId _inventQualityOrderId)
    {
        WHSWorkTable workTable;
 
        select firstonly WorkId from workTable
            where workTable.InventQualityOrderId == _inventQualityOrderId
               && workTable.WorkStatus != WHSWorkStatus::Cancelled
               && workTable.WorkStatus != WHSWorkStatus::Closed;

        return (workTable.WorkId != '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsWithLoadLineDetailsForTagetLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if work header record with work line load line details exists with the given target license plate id
    /// </summary>
    /// <param name = "_targetLicensePlateId">Target license plate id</param>
    /// <param name = "_maxWorkStatus">Maximal work status when searching for the work record</param>
    /// <returns>true if the work exists; otherwise, false</returns>
    [Hookable(false)]
    internal static boolean existsWithLoadLineDetailsForTagetLicensePlate(WHSTargetLicensePlateId _targetLicensePlateId, WHSWorkStatus _maxWorkStatus)
    {
        WHSWorkTable workTable;
 
        if (_targetLicensePlateId)
        {
            select firstonly RecId from workTable
                where workTable.HasWorkLineLoadLineDetails 
                    && workTable.TargetLicensePlateId == _targetLicensePlateId
                    && workTable.WorkStatus <= _maxWorkStatus;
        }

        return workTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    private static WHSInstrumentationLogger instrumentationLogger()
    {
        return WHSInstrumentationLogger::createLogger(tableStr(WHSWorkTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOpenPackingWorkByTargetLicensePlate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static WHSWorkTable findOpenPackingWorkByTargetLicensePlate(WHSLicensePlateId _targetLicensePlateId, boolean _forUpdate = false)
    {
        WHSWorkTable toteWorkTable;

        toteWorkTable.selectForUpdate(_forUpdate);

        if (_targetLicensePlateId)
        {
            select firstonly toteWorkTable
                where toteWorkTable.TargetLicensePlateId == _targetLicensePlateId
                   && toteWorkTable.WorkTransType == WHSWorkTransType::Packing
                   && toteWorkTable.WorkStatus == WHSWorkStatus::Open;
        }

        return toteWorkTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwWorkFrozenError</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void throwWorkFrozenError(WHSWorkTable _workTable)
    {
        WHSWorkBeingSplitValidator::validateWorkTableIsNotBeingSplit(_workTable.WorkId);

        throw error("@WAX504");
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasOrderCommittedReservations</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean hasOrderCommittedReservations(WHSWorkId _workId)
    {
        boolean ret = false;

        str scope = strFmt('%1.%2', tableStr(WHSWorkTable), funcName());
        UnknownNoYes cachedValue = SysTransactionScopeCache::get(scope, _workId, UnknownNoYes::Unknown);

        if (cachedValue == UnknownNoYes::Unknown)
        {
            WHSWorkLine workLine;

            select firstonly RecId from workLine
                where  workLine.WorkId == _workId
                    && workLine.WorkType == WHSWorkType::Pick
                    && workLine.WorkStatus != WHSWorkStatus::Closed
                    && workLine.WorkStatus != WHSWorkStatus::Cancelled
                    && workLine.OrderCommittedInventDimId != '';

            ret = workLine.RecId != 0;

            SysTransactionScopeCache::set(scope, _workId, ret ? UnknownNoYes::Yes : UnknownNoYes::No);
        }
        else
        {
            ret = cachedValue == UnknownNoYes::Yes;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workIdsWithRelatedLoadsEnumerator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find works that are related by load
    /// </summary>
    /// <param name = "_loadId">Load id related to work.</param>
    /// <returns>Return an enumerator for the map, which consists from work as key and load as value.</returns>
    [Hookable(false)]
    private static MapEnumerator workIdsWithRelatedLoadsEnumerator(WHSLoadId _loadId)
    {
        Map workIdLoadIdMap = new Map(Types::String, Types::String);
            
        if (_loadId)
        {
            WHSWorkLine workLine;
            WHSWorkLine workLine2;

            while select  WorkId from workLine
                group by WorkId
                    where workLine.ShipmentId != ''
                        && workLine.LoadId == _loadId
                join LoadId from workLine2
                    group by LoadId
                    where workLine2.ShipmentId != ''
                       && workLine2.WorkId == workLine.WorkId
            {
                workIdLoadIdMap.insert(workLine.WorkId, workIdLoadIdMap.exists(workLine.WorkId) ? '' : workLine2.LoadId);
            }
        }

        return workIdLoadIdMap.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete()
    {
        using (var deleteWorkActivityContext = WHSWorkTableDeleteInstrumentationActivityFlight::instance().isEnabled() ? WHSWorkTable::instrumentationLogger().workTableActivities().deleteWork(this) : null)
        using (var context = WHSEnforceInventoryTransactionMechanismContext::defaultInventoryTransactionMechanism(this.InventoryTransactionMechanism))
        {
            super();
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>WHSandTMS</ConfigurationKey>
	<DeveloperDocumentation>@WAX4503</DeveloperDocumentation>
	<Label>@WAX411</Label>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>WorkId</TitleField1>
	<TitleField2>WorkStatus</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>WorkIdx</ClusteredIndex>
	<CreatedDateTime>Yes</CreatedDateTime>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Inventory</Modules>
	<PrimaryIndex>WorkIdx</PrimaryIndex>
	<ReplacementKey>WorkIdx</ReplacementKey>
	<TableContents>DefaultData</TableContents>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>WHSWorkGrouping</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>WHSWorkGrouping</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventSiteId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Frozen</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCountError</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TargetLicensePlateId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkIsMultiSKU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkBuildId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CombinedWorkId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCancelledByUser</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventJournalId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransTxt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LockedUser</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShipmentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoExecute</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkPriority</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCreatedBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkManuallyCompletedBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkTemplateCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UserManuallyAssigned</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActualTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkPoolId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EstimatedTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CycleCountPlanOverview</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkInProcessUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkClosedUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCancelledUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReplenishmentDependentWorkBlockingPolicy</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@WAX2277</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>WorkId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventSiteId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventLocationId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Frozen</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCountError</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TargetLicensePlateId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkIsMultiSKU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkBuildId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CombinedWorkId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCancelledByUser</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventJournalId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransTxt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LockedUser</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WaveId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShipmentId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AutoExecute</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkPriority</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCreatedBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkManuallyCompletedBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkTemplateCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ContainerId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UserManuallyAssigned</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActualTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkPoolId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EstimatedTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CycleCountPlanOverview</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkInProcessUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkClosedUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCancelledUTCDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UseWorkForWaveReplen</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CancelReplenWhenDemandCanceled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DispositionCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReplenishmentDependentWorkBlockingPolicy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ImmediateReplenishmentUnitId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WorkCreationFailedOnReservation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>LaborStandards</Name>
			<Label>@WAX3944</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>EstimatedTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActualTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ActualTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSActualTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AutoExecute</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSAutoExecute</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CombinedWorkId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSCombinedWorkId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ContainerId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSContainerId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CycleCountPlanOverview</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DispositionCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSDispositionCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>EstimatedTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSEstimatedTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Frozen</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSFrozen</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventJournalId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventJournalId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventLocationId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventLocationId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventSiteId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventSiteId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LoadId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLoadId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LockedUser</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>WHSLockedUser</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OrderNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSOrderNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ShipmentId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSShipmentId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TargetLicensePlateId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSTargetLicensePlateId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransTxt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransTxt</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UserManuallyAssigned</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSUserManuallyAssigned</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UseWorkForWaveReplen</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSUseWorkForWaveReplen</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WaveId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWaveId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkBuildId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkBuildId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkCancelledByUser</Name>
			<AssetClassification>End User Identifiable Information (EUII)</AssetClassification>
			<ExtendedDataType>WHSWorkCancelledByUser</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>WorkCancelledUTCDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkCancelledUTCDateTime</ExtendedDataType>
			<Label>@WAX608</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>WorkClosedUTCDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkClosedUTCDateTime</ExtendedDataType>
			<Label>@WAX5466</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkCountError</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkCountError</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkCreatedBy</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>UserId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>WorkInProcessUTCDateTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkInProcessUTCDateTime</ExtendedDataType>
			<Label>@WAX5465</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkIsMultiSKU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkIsMultiSKU</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkManuallyCompletedBy</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkManuallyCompletedBy</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkPoolId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkPoolId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>WorkPriority</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkPriority</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>WHSWorkStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WorkTemplateCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkTemplateCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkTransType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Mandatory>Yes</Mandatory>
			<EnumType>WHSWorkTransType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CancelReplenWhenDemandCanceled</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSCancelReplenWhenDemandCanceled</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>HasWorkLineLoadLineDetails</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkTableHasWorkLineLoadLineDetails</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReplenishmentDependentWorkBlockingPolicy</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>WHSReplenishmentDependentWorkBlockingPolicy</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsPartialCycleCountWork</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSIsPartialCycleCountWork</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ImmediateReplenishmentUnitId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>UnitOfMeasureSymbol</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventQualityOrderId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventQualityOrderId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ClusterProfileId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSClusterProfileId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>WorkCreationFailedOnReservation</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSWorkCreationFailedOnReservation</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InventoryTransactionMechanism</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSInventoryTransactionMechanism</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>WHSInventoryTransactionMechanismEnum</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ExecutedWithoutUserLocation</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSExecutedWithoutUserLocation</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>WorkIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LoadIdWorkStatusIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LoadId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TargetLicensePlateIdWorkStatusIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>TargetLicensePlateId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ShipmentIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ShipmentId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WaveId</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>WaveId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CycleCountPlanOverviewIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CycleCountPlanOverview</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WorkBuildIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkBuildId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ContainerIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ContainerId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WorkListIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventLocationId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Frozen</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LockedUser</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>OpenReplenWorkStatusIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventLocationId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkTransType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>UseWorkForWaveReplen</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ImmediateReplenishmentUnitId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CombinedWorkIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CombinedWorkId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventQualityOrderIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventQualityOrderId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>WorkStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WorkClosedUTCDateTimeIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>WorkClosedUTCDateTime</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventJournalTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventJournalTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventJournalId</Name>
					<SourceEDT>InventJournalId</SourceEDT>
					<Field>InventJournalId</Field>
					<RelatedField>JournalId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>JournalIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventLocation</Name>
			<Cardinality>OneMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventLocation</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventLocationId</Name>
					<SourceEDT>InventLocationId</SourceEDT>
					<Field>InventLocationId</Field>
					<RelatedField>InventLocationId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventLocationIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventSite</Name>
			<Cardinality>OneMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventSite</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Aggregation</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventSiteId</Name>
					<SourceEDT>InventSiteId</SourceEDT>
					<Field>InventSiteId</Field>
					<RelatedField>SiteId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>SiteIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTablePick</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProdTablePick</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>WorkTransType</Name>
					<Field>WorkTransType</Field>
					<ValueStr>WHSWorkTransType::ProdPick</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTablePut</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProdTablePut</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>WorkTransType</Name>
					<Field>WorkTransType</Field>
					<ValueStr>WHSWorkTransType::ProdPut</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PurchTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PurchTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>WorkTransType</Name>
					<Field>WorkTransType</Field>
					<ValueStr>WHSWorkTransType::Purch</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>PurchId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SalesTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>WorkTransType</Name>
					<Field>WorkTransType</Field>
					<ValueStr>WHSWorkTransType::Sales</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>SalesId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TransferOrderIssue</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransferTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TransferOrderIssue</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>WorkTransType</Name>
					<Field>WorkTransType</Field>
					<ValueStr>WHSWorkTransType::TransferIssue</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>TransferId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TransferOrderReciept</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransferTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TransferOrderReceipt</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>WorkTransType</Name>
					<Field>WorkTransType</Field>
					<ValueStr>WHSWorkTransType::TransferReceipt</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>TransferId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>UserInfoCancelled</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>UserInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>UserCancelled</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkCancelledByUser</Name>
					<SourceEDT>WHSWorkCancelledByUser</SourceEDT>
					<Field>WorkCancelledByUser</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>UserInfoCompleted</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>UserInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>UserCompleted</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkManuallyCompletedBy</Name>
					<SourceEDT>WHSWorkManuallyCompletedBy</SourceEDT>
					<Field>WorkManuallyCompletedBy</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSContainerTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSContainerTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ContainerId</Name>
					<SourceEDT>WHSContainerId</SourceEDT>
					<Field>ContainerId</Field>
					<RelatedField>ContainerId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSCycleCountPlanOverview</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSCycleCountPlanOverview</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CycleCountPlanOverview</Name>
					<Field>CycleCountPlanOverview</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSDispositionTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSDispositionTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DispositionCode</Name>
					<Field>DispositionCode</Field>
					<RelatedField>DispositionCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSLicensePlate</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSLicensePlate</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TargetLicensePlateId</Name>
					<SourceEDT>WHSTargetLicensePlateId</SourceEDT>
					<Field>TargetLicensePlateId</Field>
					<RelatedField>LicensePlateId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSLoadTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSLoadTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LoadId</Name>
					<SourceEDT>WHSLoadId</SourceEDT>
					<Field>LoadId</Field>
					<RelatedField>LoadId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSShipmentTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSShipmentTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ShipmentId</Name>
					<SourceEDT>WHSShipmentId</SourceEDT>
					<Field>ShipmentId</Field>
					<RelatedField>ShipmentId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWaveTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSWaveTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WaveId</Name>
					<SourceEDT>WHSWaveId</SourceEDT>
					<Field>WaveId</Field>
					<RelatedField>WaveId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkPool</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>WHSWorkPool</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkPoolId</Name>
					<SourceEDT>WHSWorkPoolId</SourceEDT>
					<Field>WorkPoolId</Field>
					<RelatedField>WorkPoolId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkTable</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>WHSWorkTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Composition</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkId</Name>
					<SourceEDT>WHSWorkId</SourceEDT>
					<Field>WorkId</Field>
					<RelatedField>WorkId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkTemplateTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSWorkTemplateTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkTemplateCode</Name>
					<SourceEDT>WHSWorkTemplateCode</SourceEDT>
					<Field>WorkTemplateCode</Field>
					<RelatedField>WorkTemplateCode</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkTransType</Name>
					<Field>WorkTransType</Field>
					<RelatedField>WorkTransType</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkUserCreated</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UserInfo</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WorkCreatedBy</Name>
					<Field>WorkCreatedBy</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSWorkUserLocked</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSWorkUser</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>UserLocked</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LockedUser</Name>
					<SourceEDT>WHSLockedUser</SourceEDT>
					<Field>LockedUser</Field>
					<RelatedField>UserId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>UnitOfMeasureImmediateReplenUnit</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UnitOfMeasure</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ImmediateReplenishmentUnitId</Name>
					<Field>ImmediateReplenishmentUnitId</Field>
					<RelatedField>Symbol</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventQualityOrderTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventQualityOrderTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventQualityOrderId</Name>
					<Field>InventQualityOrderId</Field>
					<RelatedField>QualityOrderId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WHSClusterProfile</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>WHSClusterProfile</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ClusterProfileId</Name>
					<Field>ClusterProfileId</Field>
					<RelatedField>ClusterProfileId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventQualityOrderTableByOrderNum</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventQualityOrderTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>WorkTransType</Name>
					<Field>WorkTransType</Field>
					<ValueStr>WHSWorkTransType::QualityOrder</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OrderNum</Name>
					<Field>OrderNum</Field>
					<RelatedField>QualityOrderId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>