<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>JmgJobTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class JmgJobTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>badQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the reported bad quantity if the current job is a production job.
    /// </summary>
    /// <returns>
    /// The reported bad quantity of the production job.
    /// </returns>
    public display JmgQtyBad badQuantity()
    {
        JmgQtyBad retQty;

        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
            {
                retQty = (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateErrorQtyPerProdRouteJob(this.JobId);
            }
            else
            {
                this.recordLevelSecurity(true);

                if (this.isProductionType())
                {
                    JmgTermJob_Prod prodJob = JmgTermJob::constructJobTable(this);

                    retQty = (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateErrorQtyPerProdRoute(prodJob.prodRoute());
                }
            }
        }

        return retQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current job is a production job or a project job, and finds the calculated
    /// time for the job.
    /// </summary>
    /// <returns>
    /// The calculated time if the current job is a production or project job; otherwise, 0.
    /// </returns>
    public display Hours calcHours()
    {
        JmgTermJob job = JmgTermJob::construct(this.JobId);

        var projJob = job as JmgTermJob_Proj;
        if (projJob)
        {
            return projJob.calcTimeHours();
        }

        var prodJob = job as JmgTermJob_Prod;
        if (prodJob)
        {
            return prodJob.calcTimeHours();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTimeHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total time of the job measured in hours based on whether the current job is a
    /// production job.
    /// </summary>
    /// <returns>
    /// The total time of the job measured in hours.
    /// </returns>
    public display RouteJobCalcTimeHours calcTimeHours()
    {
        RouteJobCalcTimeHours   calcTimeHours;
        ProdRoute               prodRoute;
        ProdRouteTrans          prodRouteTrans;

        RouteJobCalcTimeHours calculateTiemHours(ProdRoute _prodRoute, RouteJobType _jobType)
        {
            return  (select sum(Hours) from prodRouteTrans
                where prodRouteTrans.TransRefId == prodRoute.ProdId
                &&  prodRouteTrans.TransRefType == ProdTransRefType::Production
                &&  prodRouteTrans.OprNum       == prodRoute.OprNum
                &&  prodRouteTrans.OprPriority  == prodRoute.OprPriority
                &&  prodRouteTrans.TransType    == ProdRouteTransType::Time
                &&  prodRouteTrans.JobType      == _jobType).Hours;
        }

        if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
        {
            calcTimeHours = ProdRouteJob::findJobId(this.JobId).CalcTimeHours;
        }
        else
        {
            prodRoute = ProdRoute::findJobId(this.JobId);

            if (this.Type == JmgJobTableType::ProdSetup)
            {
                calcTimeHours = calculateTiemHours(prodRoute, RouteJobType::Setup);
            }
            else
        if (this.Type == JmgJobTableType::ProdProcess)
            {
                calcTimeHours = calculateTiemHours(prodRoute, RouteJobType::Process);
            }
        }

        return calcTimeHours;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduledHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the calculated time for the job.
    /// </summary>
    /// <param name = "_schedMethod">
    /// Scheduling method to be used for calculation. Decides whether the time should be read from job or operation.
    /// </param>
    /// <returns>
    /// Calculated time for the job.
    /// </returns>
    /// <remarks>
    /// The provided scheduling method is used for finding the calculated hours, instead of the StampLevel on <c>JmgProdParameters</c>.
    /// The hours are recalculated to account for changes made in the Load percentage of no. of resources after scheduling.
    /// </remarks>
    public JmgHours scheduledHours(ProdSchedMethod _schedMethod)
    {
        ProdTable prodTable      = ProdTable::find(this.ModuleRefId);
        ProdRoute prodRoute      = ProdRoute::findByOprId(this.ModuleRefId, this.OprNum, this.OprActId);

        if (!prodTable.RecId || !prodRoute.RecId)
        {
            return 0;
        }

        BOMCalcData          bomCalcData          = BOMCalcData::newProdTable(prodTable.QtyCalc, prodTable);
        ProdRoute            prodRoutePrimary     = prodRoute.primary();
        RouteCalcConsumption routeCalcConsumption = RouteCalcConsumption::construct(prodRoutePrimary.Formula);

        if (_schedMethod == ProdSchedMethod::JobScheduling)
        {
            switch (this.Type)
            {
                case JmgJobTableType::ProdSetup:
                    return routeCalcConsumption.calcSetUpTimePerJob(bomCalcData, prodRoutePrimary, prodRoutePrimary, prodRoute);
                case JmgJobTableType::ProdProcess:
                    return routeCalcConsumption.calcProcessTimePerJob(bomCalcData, prodRoutePrimary, prodRoutePrimary, prodRoute);
                default:
                    return 0;
            }
        }
        else
        {
            switch (this.Type)
            {
                case JmgJobTableType::ProdSetup:
                    return routeCalcConsumption.calcSetUpTime(bomCalcData, prodRoutePrimary, prodRoutePrimary, prodRoute, prodRoute);
                case JmgJobTableType::ProdProcess:
                    return routeCalcConsumption.calcProcessTime(bomCalcData, prodRoutePrimary, prodRoutePrimary, prodRoute, prodRoute);
                default:
                    return 0;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumptionDeviation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates deviation in consumption of raw materials, as compared to the started quantity.
    /// </summary>
    /// <returns>
    /// Calculated deviation in consumption.
    /// </returns>
    public JmgDeviation consumptionDeviation()
    {
        ProdBOM prodBOM;
        InventTransOriginProdBOM inventTransOriginProdBOM;
        InventTransOrigin inventTransOrigin;
        InventTrans inventTrans;

        JmgDeviation maxDeviation = 0;

        ProdRoute prodRoute = ProdRoute::findByOprId(this.ModuleRefId, this.OprNum, this.OprActId);

        while select avg(QtyBOMStUp) from prodBOM
            group by prodBOM.InventTransId, prodBOM.UnitId, prodBOM.ItemId, prodBOM.InventDimId
            where prodBOM.ProdId  == this.ModuleRefId
                && ((prodBOM.OprNum == this.OprNum)
                    || (prodRoute.isFirstOpr() && (prodBOM.OprNum == 0)))
            join inventTransOriginProdBOM
                where inventTransOriginProdBOM.ProdBOMInventTransId == prodBOM.InventTransId
                    && inventTransOriginProdBOM.ProdBOMDataAreaId   == prodBOM.DataAreaId
                join inventTransOrigin
                    where inventTransOrigin.RecId == inventTransOriginProdBOM.InventTransOrigin
                    outer join sum(Qty) from inventTrans
                        where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                           &&  (((inventTrans.StatusIssue   == StatusIssue::Deducted
                           ||  inventTrans.StatusIssue      == StatusIssue::Sold)
                           &&  inventTrans.StatusReceipt    == StatusReceipt::None)
                           ||  ((inventTrans.StatusReceipt  == StatusReceipt::Received
                           ||  inventTrans.StatusReceipt    == StatusReceipt::Purchased)
                           &&  inventTrans.StatusIssue      == StatusIssue::None))
        {
            real actualConsumption = - EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(prodBOM.ItemId,
                                                                                                             prodBOM.InventDimId,
                                                                                                             inventTrans.Qty,
                                                                                                             ProdBOM::findTransId(prodBOM.InventTransId).inventUnit(),
                                                                                                             prodBOM.UnitId,
                                                                                                             NoYes::Yes);

            real estConsumptionForStartedQty = prodBOM.QtyBOMStUp;

            JmgDeviation lineDeviation = (estConsumptionForStartedQty == 0) ? 0 :
                round(abs(actualConsumption - estConsumptionForStartedQty) / estConsumptionForStartedQty * 100, 0.01);

            maxDeviation = (maxDeviation > lineDeviation) ? maxDeviation : lineDeviation;
        }

        return maxDeviation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveStartQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the job can have start quantity specified or not.
    /// </summary>
    /// <returns>
    /// true if the start quantity can be specified; otherwise, false.
    /// </returns>
    public boolean canHaveStartQuantity()
    {
        return this.Type == JmgJobTableType::ProdProcess && this.isPrimaryOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAbsence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves how much absence time has been registered on the selected job and then returns the
    /// payroll absence cost of the job.
    /// </summary>
    /// <returns>
    /// The payroll cost price of the job.
    /// </returns>
    public display Price costAbsence()
    {
        JmgStampTrans   jmgStampTrans;
        Price           cost = 0;

        jmgStampTrans.recordLevelSecurity(true);

        while select CostAbsence, Seconds, JobId from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId
        {
            cost += jmgStampTrans.CostAbsence * jmgStampTrans.Seconds / 3600;
        }

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAdditional</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total payroll cost of the job including the additional amount in the cost categories
    /// registered for the selected job.
    /// </summary>
    /// <returns>
    /// The total payroll additional cost price of the job.
    /// </returns>
    public display Price costAdditional()
    {
        JmgStampTrans   jmgStampTrans;
        Price           cost = 0;

        jmgStampTrans.recordLevelSecurity(true);

        while select CostAbsence, CostBreak, CostFlexAdd, CostFlexSub, CostNormTime, CostOverTime, CostPayAdd, CostPayAddManual, Seconds, JobId from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId
        {
            cost += (   jmgStampTrans.CostFlexAdd +
                    jmgStampTrans.CostFlexSub +
                    jmgStampTrans.CostOverTime +
                    jmgStampTrans.CostPayAdd +
                    jmgStampTrans.CostPayAddManual) * jmgStampTrans.Seconds / 3600;
        }

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAutoPremiums</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves how much automatic premium has been registered on the selected job and then returns the
    /// payroll cost price of the job.
    /// </summary>
    /// <returns>
    /// The payroll cost price of the job.
    /// </returns>
    public display Price costAutoPremiums()
    {
        JmgStampTrans   jmgStampTrans;
        Price           cost = 0;

        jmgStampTrans.recordLevelSecurity(true);

        while select CostPayAdd, Seconds, JobId from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId
        {
            cost += jmgStampTrans.CostPayAdd * jmgStampTrans.Seconds / 3600;
        }

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costBreakTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves how much break time has been registered on the selected job and then returns the payroll
    /// cost of the job.
    /// </summary>
    /// <returns>
    /// The payroll cost price of the job.
    /// </returns>
    public display Price costBreakTime()
    {
        JmgStampTrans   jmgStampTrans;
        Price           cost = 0;

        jmgStampTrans.recordLevelSecurity(true);

        while select CostBreak, Seconds, JobId from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId
        {
            cost += jmgStampTrans.CostBreak * jmgStampTrans.Seconds / 3600;
        }

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costFlexAdd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves how much Flex+ has been registered on the selected job and then returns the payroll cost
    /// of the job.
    /// </summary>
    /// <returns>
    /// The payroll cost price of the job.
    /// </returns>
    public display Price costFlexAdd()
    {
        JmgStampTrans   jmgStampTrans;
        Price           cost = 0;

        jmgStampTrans.recordLevelSecurity(true);

        while select CostFlexAdd, Seconds, JobId from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId
        {
            cost += jmgStampTrans.CostFlexAdd * jmgStampTrans.Seconds / 3600;
        }

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costFlexSub</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves how much Flex- has been registered on the selected job and then returns the payroll cost
    /// of the job.
    /// </summary>
    /// <returns>
    /// The payroll cost price of the job.
    /// </returns>
    public display Price costFlexSub()
    {
        JmgStampTrans   jmgStampTrans;
        Price           cost = 0;

        jmgStampTrans.recordLevelSecurity(true);

        while select CostFlexSub, Seconds, JobId from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId
        {
            cost += jmgStampTrans.CostFlexSub * jmgStampTrans.Seconds / 3600;
        }

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costManPremiums</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves how much manual premium time has been registered on the selected job and then returns the
    /// payroll cost of the job.
    /// </summary>
    /// <returns>
    /// The payroll cost price of the job.
    /// </returns>
    public display Price costManPremiums()
    {
        JmgStampTrans   jmgStampTrans;
        Price           cost = 0;

        jmgStampTrans.recordLevelSecurity(true);

        while select CostPayAddManual, Seconds, JobId from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId
        {
            cost += jmgStampTrans.CostPayAddManual * jmgStampTrans.Seconds / 3600;
        }

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costOvertime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves how much overtime has been registered on the selected job, and returns the payroll cost
    /// of the job.
    /// </summary>
    /// <returns>
    /// The payroll cost price of the job.
    /// </returns>
    public display Price costOvertime()
    {
        JmgStampTrans   jmgStampTrans;
        Price           cost = 0;

        jmgStampTrans.recordLevelSecurity(true);

        while select CostOverTime, Seconds, JobId from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId
        {
            cost += jmgStampTrans.CostOverTime * jmgStampTrans.Seconds / 3600;
        }

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costStandard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves how much standard time has been registered on the selected job, and returns the payroll
    /// cost of the job.
    /// </summary>
    /// <returns>
    /// The payroll cost price of the job.
    /// </returns>
    public display Price costStandard()
    {
        JmgStampTrans   jmgStampTrans;
        Price           cost = 0;

        jmgStampTrans.recordLevelSecurity(true);

        while select CostNormTime, Seconds, JobId from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId
        {
            cost += jmgStampTrans.CostNormTime * jmgStampTrans.Seconds / 3600;
        }

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves how much total cost time has been registered on the selected job and then returns the
    /// total payroll cost of the job.
    /// </summary>
    /// <returns>
    /// Total payroll cost price of the job.
    /// </returns>
    public display Price costTotal()
    {
        JmgStampTrans   jmgStampTrans;
        Price           cost = 0;

        jmgStampTrans.recordLevelSecurity(true);

        while select CostAbsence, CostBreak, CostFlexAdd, CostFlexSub, CostNormTime, CostOverTime, CostPayAdd, CostPayAddManual, Seconds, JobId from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId
        {
            cost += (   jmgStampTrans.CostAbsence +
                    jmgStampTrans.CostBreak +
                    jmgStampTrans.CostFlexAdd +
                    jmgStampTrans.CostFlexSub +
                    jmgStampTrans.CostNormTime +
                    jmgStampTrans.CostOverTime +
                    jmgStampTrans.CostPayAdd +
                    jmgStampTrans.CostPayAddManual) * jmgStampTrans.Seconds / 3600;
        }

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the selected record, and updates the document reference table, to delete references to the
    /// job.
    /// </summary>
    public void delete()
    {
        this.updateJmgJobDocuRefTable(true);
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>emplWorking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the employees that are currently working on the selected job.
    /// </summary>
    /// <returns>
    /// A list of employees currently working on the job.
    /// </returns>
    public display HcmPersonnelNumberId emplWorking()
    {
        JmgTermReg              jmgTermReg;
        HcmWorker               hcmWorker;
        str                     tmpStr;

        jmgTermReg.recordLevelSecurity(true);

        if (this)
        {
            while select PersonnelNumber, RecId
            from  hcmWorker
            join JobActive, JobId, Worker from jmgTermReg
            where jmgTermReg.JobActive          == NoYes::Yes  &&
                  jmgTermReg.JobId              == this.JobId  &&
                  hcmWorker.RecId               == jmgTermReg.Worker
            {
                if (tmpStr)
                {
                    tmpStr += ', ';
                }

                tmpStr  += hcmWorker.PersonnelNumber;
            }
        }

        return tmpStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emplWorkingByName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the names of employees that are currently working on the selected job .
    /// </summary>
    /// <returns>
    /// A list of employees currently working on the job.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str emplWorkingByName()
    {
        DirPartyTable           party;
        JmgTermReg              jmgTermReg;
        HcmWorker               hcmWorker;
        str                     tmpStr;

        jmgTermReg.recordLevelSecurity(true);

        if (this)
        {
            while select Name from party
            exists join hcmWorker
                where hcmWorker.Person==party.RecId
            exists join JobActive, JobId, Worker from jmgTermReg
                where jmgTermReg.JobActive          == NoYes::Yes  &&
                      jmgTermReg.JobId              == this.JobId  &&
                      hcmWorker.RecId               == jmgTermReg.Worker
            {
                if (tmpStr)
                {
                    tmpStr += ', ';
                }

                tmpStr  += party.Name;
            }
        }

        return tmpStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executedPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the reported processing percentage based on whether the current job is a production job.
    /// </summary>
    /// <returns>
    /// The reported processing percentage of the production job.
    /// </returns>
    public display ProdExecutedPct executedPercent()
    {
        ProdExecutedPct     retQty;
        ProdRoute           prodRoute;

        if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
        {
            retQty = ProdRouteJob::findJobId(this.JobId).ExecutedPct;
        }
        else
        {
            prodRoute = ProdRoute::findJobId(this.JobId);

            if (this.Type == JmgJobTableType::ProdSetup)
            {
                retQty = prodRoute.ExecutedSetup;
            }
            else
            if (this.Type == JmgJobTableType::ProdProcess)
            {
                retQty = prodRoute.ExecutedProcess;
            }
        }

        return retQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the earliest time at which the job was started.
    /// </summary>
    /// <returns>
    /// The <c>DateTime</c> value of the earliest registration on the job.
    /// </returns>
    public display JmgFromDateTime fromDateTime()
    {
        JmgTermReg jmgTermReg;

        jmgTermReg.recordLevelSecurity(true);

        select firstonly RegDateTime
        from  jmgTermReg
        order by RegDateTime asc
        where jmgTermReg.JobId  == this.JobId;

        return jmgTermReg.RegDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>goodQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current job is a production job. If so, the reported good quantity is found.
    /// </summary>
    /// <returns>
    /// The reported good quantity of the job.
    /// </returns>
    public display JmgQtyGood goodQuantity()
    {
        ProdReportedGood retQty;

        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
            {
                retQty = (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateGoodQtyPerProdRouteJob(this.JobId);
            }
            else
            {
                this.recordLevelSecurity(true);

                if (this.isProductionType())
                {
                    JmgTermJob_Prod prodJob = JmgTermJob::constructJobTable(this);

                    retQty = (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateGoodQtyPerProdRoute(prodJob.prodRoute());
                }
            }
        }

        return retQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>goodQuantityByWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current job is a production job. If so, the reported good quantity is found based on a specific worker.
    /// </summary>
    /// <param name = "_worker"> Worker recID </param>
    /// <returns>
    /// The reported good quantity of the job by a specific worker.
    /// </returns>
    [Hookable(false)]
    internal JmgQtyGood goodQuantityByWorker(JmgWorkerRecId _worker)
    {
        ProdReportedGood retQty;

        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
            {
                retQty = ProdRouteJob::findJobId(this.JobId).qtyGoodByWorker(_worker);
            }
            else if (this.isProductionType())
            {
                JmgTermJob_Prod prodJob = JmgTermJob::constructJobTable(this);

                retQty  = prodJob.prodRoute().qtyGoodByWorker(_worker);
            }
        }
        
        return retQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportedQuantityByWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current job is a production job. If so, the reported quantity is found based on a specific worker.
    /// </summary>
    /// <param name = "_worker"> Worker recID </param>
    /// <returns>
    /// The sum of reported good and scrap quantity of the job by a specific worker.
    /// </returns>
    [Hookable(false)]
    internal JmgQtyGood reportedQuantityByWorker(JmgWorkerRecId _worker)
    {
        ProdReportedGood retQty;

        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
            {
                retQty = ProdRouteJob::findJobId(this.JobId).qtyReportedByWorker(_worker);
            }
            else if (this.isProductionType())
            {
                JmgTermJob_Prod prodJob = JmgTermJob::constructJobTable(this);

                retQty  = prodJob.prodRoute().qtyReportedByWorker(_worker);
            }
        }
        
        return retQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReportedQuantityByWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current job is a production job. If so, the reported catch weight quantity is found based on a specific worker.
    /// </summary>
    /// <param name = "_worker"> Worker recID </param>
    /// <returns>
    /// The sum of reported catch weight good and scrap quantity of the job by a specific worker.
    /// </returns>
    [Hookable(false)]
    internal PdsCWBatchGood pdsCWReportedQuantityByWorker(JmgWorkerRecId _worker)
    {
        PdsCWBatchGood retQty;

        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
            {
                retQty = ProdRouteJob::findJobId(this.JobId).pdsCWQtyReportedByWorker(_worker);
            }
            else if (this.isProductionType())
            {
                JmgTermJob_Prod prodJob = JmgTermJob::constructJobTable(this);

                retQty  =  prodJob.prodRoute().pdsCWQtyReportedByWorker(_worker);
            }
        }
        
        return retQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProductionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current job is a production job.
    /// </summary>
    /// <returns>
    /// True, if current job is a production job; false otherwise.
    /// </returns>
    internal boolean isProductionType()
    {
        return this.Type == JmgJobTableType::ProdOverlap    ||
            this.Type == JmgJobTableType::ProdProcess       ||
            this.Type == JmgJobTableType::ProdQueueAfter    ||
            this.Type == JmgJobTableType::ProdQueueBefore   ||
            this.Type == JmgJobTableType::ProdSetup         ||
            this.Type == JmgJobTableType::ProdTransport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>imageModule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets up the image to display, depending on the job type of the selected record.
    /// </summary>
    /// <returns>
    /// A <c>JmgModuleEnum::PROD</c> enumeration value if the selected job is a production job or a
    /// <c>JmgModuleEnum::PROJ</c> enumeration value if the selected job is a project job; otherwise, a
    /// <c>JmgModuleEnum::IPC</c> enumeration value.
    /// </returns>
    public display JmgLabelImageModule imageModule()
    {
        JmgLabelImageModule ret;

        this.recordLevelSecurity(true);

        switch (this.Type)
        {
            case JmgJobTableType::ProdOverlap:
            case JmgJobTableType::ProdProcess:
            case JmgJobTableType::ProdQueueAfter:
            case JmgJobTableType::ProdQueueBefore:
            case JmgJobTableType::ProdSetup:
            case JmgJobTableType::ProdTransport:
                ret = JmgModuleEnum::PROD;
                break;
            case JmgJobTableType::ProjActivity:
            case JmgJobTableType::ProjBudget:
            case JmgJobTableType::ProjProject:
                ret = JmgModuleEnum::PROJ;
                break;
            default:
                ret = JmgModuleEnum::IPC;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record, and updates the document reference table regarding this job.
    /// </summary>
    public void insert()
    {
        super();

        this.updateJmgJobDocuRefTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrimaryOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the corresponding operation has primary priority.
    /// </summary>
    /// <returns>
    /// true - if operation is primary, false otherwise.
    /// </returns>
    public boolean isPrimaryOperation()
    {
        return this.Priority == RouteOprPriority::Primary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the item name of the current job.
    /// </summary>
    /// <returns>
    /// The item name of the job.
    /// </returns>
    public display ItemName itemName()
    {
        return this.productVariantNameLabel(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the job name of the current job.
    /// </summary>
    /// <returns>
    /// The job name of the job.
    /// </returns>
    public display JmgJobName jobName()
    {
        if (this.imageModule() == JmgModuleEnum::PROD)
        {
            return strFmt("@SYS311966", this.JobId, this.Type);
        }
        else
        {
            return strFmt("@SYS311966", this.JobId, this.Description);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the status of the job.
    /// </summary>
    /// <returns>
    /// The status of the selected job.
    /// </returns>
    /// <remarks>
    /// If the job is a production job it returns the status from the production module; otherwise, it
    /// checks whether the job exists in the <c>JmgTermReg</c> table, and returns a status based on that.
    /// </remarks>
    public display JmgJobStatus jobStatus()
    {
        this.recordLevelSecurity(true);
        return JmgTermJob::constructJobTable(this).jobStatus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobStatusByWorker</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Returns job status for the the specified <c>JmgEmployee</c> record worker.
    /// </summary>
    /// <param>
    ///   The <c>JmgEmployee</c> record Worker RecId.
    /// </param>
    /// <returns>
    ///   A <c>JmgTermJob</c> record job status, otherwise  JmgJobStatus::NotAvailable.
    /// </returns>
    public JmgJobStatus jobStatusByWorker(JmgWorkerRecId _worker)
    {
        JmgJobStatus jobStatusByWorker = JmgJobStatus::NotAvailable;

        if (_worker)
        {
            this.recordLevelSecurity(true);
            JmgTermJob_Prod jmgTermJob_prod = JmgTermJob::constructJobTable(this) as JmgTermJob_Prod;
            jobStatusByWorker = jmgTermJob_prod.jobStatusByWorker(_worker);
        }

        return jobStatusByWorker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the operation of the next job in the route if the selected job is a production job.
    /// </summary>
    /// <returns>
    /// The operation ID of production jobs next operation.
    /// </returns>
    public display RouteOprId nextOperation()
    {
        ProdRoute       nextOperation;
        ProdRoute       thisOperation;

        nextOperation.recordLevelSecurity(true);
        thisOperation.recordLevelSecurity(true);

        if (this.isProductionType())
        {
            select firstonly OprId
            from  thisOperation
            where thisOperation.ProdId      == this.ModuleRefId     &&
                  thisOperation.OprNum      == this.OprNum          &&
                  thisOperation.OprPriority == this.Priority
            join OprId
            from  nextOperation
            where nextOperation.ProdId == thisOperation.ProdId      &&
                  nextOperation.OprNum == thisOperation.OprNumNext;

            return nextOperation.OprId;
        }

        return "@SYS80253";
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWBadQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the reported bad quantity when the current job is a production job.
    /// </summary>
    /// <returns>
    /// The reported bad quantity of the production job.
    /// </returns>
    public display PdsCWBatchErr pdsCWBadQuantity()
    {
        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            this.recordLevelSecurity(true);

            JmgTermJob_Prod prodJob = JmgTermJob::constructJobTable(this);
            return prodJob.prodRoute().pdsCWQtyError();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWGoodQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the current job is a production job; when the current job is a production job,
    /// the reported good quantity is found.
    /// </summary>
    /// <returns>
    /// The reported good quantity of the job.
    /// </returns>
    public display PdsCWBatchGood pdsCWGoodQuantity()
    {
        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            this.recordLevelSecurity(true);

            JmgTermJob_Prod prodJob = JmgTermJob::constructJobTable(this);
            return prodJob.prodRoute().pdsCWQtyGood();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWStartedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches journal registrations and sums the catch weight started quantity of the job.
    /// </summary>
    /// <returns>
    /// The sum of catch weight started quantities of the selected job.
    /// </returns>
    public display PdsCWBatchStup pdsCWStartedQuantity()
    {
        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            JmgTermReg              jmgTermReg;
            JmgStampTrans           jmgStampTrans;

            jmgTermReg.recordLevelSecurity(true);
            jmgStampTrans.recordLevelSecurity(true);

            return (select sum(PdsCWStartItems) from jmgTermReg
                    where jmgTermReg.JobId == this.JobId).PdsCWStartItems   +
               (select sum(PdsCWSysQtyStartup) from jmgStampTrans
                    where jmgStampTrans.JobId == this.JobId).PdsCWSysQtyStartup;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>percentage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums up the time registered on the selected job, and calculates the percentage with regard to the
    /// calculated time for the job.
    /// </summary>
    /// <returns>
    /// The percentage of how much time has been spent on the job with regard to the time the job has been
    /// calculated to take.
    /// </returns>
    public display Percent percentage()
    {
        JmgStampTrans           jmgStampTrans;
        JmgStampJournalTrans    jmgStampJournalTrans;
        Hours                   realHours = 0;
        Hours                   calcHours = this.calcHours();

        jmgStampJournalTrans.recordLevelSecurity(true);
        jmgStampTrans.recordLevelSecurity(true);

        if (!calcHours)
        {
            return calcHours;
        }
        select sum(Seconds) from jmgStampTrans
        where jmgStampTrans.JobId   == this.JobId;

        select sum(Seconds) from jmgStampJournalTrans
        where jmgStampTrans.JobId   == this.JobId;

        return (( (jmgStampTrans.Seconds+jmgStampJournalTrans.Seconds) / (calcHours*3600) ) * 100);
    }

]]></Source>
			</Method>
			<Method>
				<Name>previousOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the operation of the previous job in the route if the selected job is a production job.
    /// </summary>
    /// <returns>
    /// The operation ID of production jobs previous operation.
    /// </returns>
    public display RouteOprId previousOperation()
    {
        ProdRoute       previousOperation;

        previousOperation.recordLevelSecurity(true);

        if (this.isProductionType())
        {
            select firstonly OprId
            from  previousOperation
            where previousOperation.ProdId      == this.ModuleRefId     &&
                  previousOperation.OprNumNext  == this.OprNum          &&
                  previousOperation.OprPriority == this.Priority;

            return previousOperation.OprId;
        }

        return "@SYS80253";
    }

]]></Source>
			</Method>
			<Method>
				<Name>prevJobStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the job is a production job, and returns the status of the previous job in the
    /// route.
    /// </summary>
    /// <returns>
    /// The job status of production jobs previous operation.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display JmgJobStatus prevJobStatus()
    {
        if (this.isProductionType())
        {
            ProdRoute   previousOperation;

            previousOperation.recordLevelSecurity(true);

            select firstonly OprId, JobIdSetup, JobIdProcess
            from  previousOperation
            where previousOperation.ProdId      == this.ModuleRefId     &&
                  previousOperation.OprNumNext  == this.OprNum          &&
                  previousOperation.OprPriority == this.Priority;

            JmgJobId jobId = this.Type == JmgJobTableType::ProdSetup ?  previousOperation.JobIdSetup : previousOperation.JobIdProcess;

            if (jobId)
            {
                JmgJobTable prevOperationJobTable = JmgJobTable::find(jobId);

                if (prevOperationJobTable)
                {
                    return prevOperationJobTable.jobStatus();
                }
            }

            JmgJobTable jmgJobTable;

            select firstonly jmgJobTable
            where jmgJobTable.ModuleRefId       == this.ModuleRefId &&
                  jmgJobTable.OprActId          == previousOperation.OprId;

            if (jmgJobTable.JobId)
            {
                return jmgJobTable.jobStatus();
            }
        }

        return JmgJobStatus::NotAvailable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prevOperationQtyGood</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the job is a production job, and returns the reported good quantity of the job
    /// in the route.
    /// </summary>
    /// <returns>
    /// The reported good quantity of the previous operation of the production job.
    /// </returns>
    public display JmgQtyGood prevOperationQtyGood()
    {
        ProdRoute       previousOperation;

        previousOperation.recordLevelSecurity(true);

        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            select firstonly previousOperation
            where previousOperation.ProdId      == this.ModuleRefId     &&
                  previousOperation.OprNumNext  == this.OprNum          &&
                  previousOperation.OprPriority == this.Priority;

            return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateGoodQtyPerProdRoute(previousOperation);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorQtyAtAndBeforeOpr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the job is a production job, and returns the reported error quantity at the specified operation and at previous operations.
    /// </summary>
    /// <returns>
    /// The reported error quantity at the specified operation and at previous operations.
    /// </returns>
    [Hookable(false), SysClientCacheDataMethodAttribute(true)]
    public display ProdReportedError errorQtyAtAndBeforeOpr()
    {
        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateReportedErrorQtyAtAndBeforeOpr(this.ModuleRefId, this.OprNum);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWErrorQtyAtAndBeforeOpr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the job is a production job, and returns the reported CW error quantity at the specified operation and at previous operations.
    /// </summary>
    /// <returns>
    /// The reported CW error quantity at the specified operation and at previous operations.
    /// </returns>
    [Hookable(false), SysClientCacheDataMethodAttribute(true)]
    internal display ProdReportedError pdsCWErrorQtyAtAndBeforeOpr()
    {
        if (this.isProductionType() && PdsGlobal::pdsIsCWItem(this.ItemId) && 
           this.canHaveStartQuantity())
        {
            return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateCWReportedErrorQtyAtAndBeforeOpr(this.ModuleRefId, this.OprNum);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorQtyBeforeOpr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the job is a production job, and returns the reported error quantity at previous operations.
    /// </summary>
    /// <returns>
    /// The reported error quantity at previous operations.
    /// </returns>
    [Hookable(false), SysClientCacheDataMethodAttribute(true)]
    public display ProdReportedError errorQtyBeforeOpr()
    {
        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateReportedErrorQtyBeforeOpr(this.ModuleRefId, this.OprNum);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>ProdRoute</c> record for the current job.
    /// </summary>
    /// <returns>
    /// The <c>ProdRoute</c> record for the current job.
    /// </returns>
    public ProdRoute prodRoute()
    {
        ProdRoute ret;
        JmgTermJob_Prod     prodJob;

        if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
        {
            ret = ProdRouteJob::findJobId(this.JobId).prodRoute();
        }
        else
        {
            this.recordLevelSecurity(true);

            if (this.isProductionType())
            {
                prodJob = JmgTermJob::constructJobTable(this);

                ret  = prodJob.prodRoute();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projectStage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project stage of the current job.
    /// </summary>
    /// <returns>
    /// The project stage of the current job.
    /// </returns>
    public display ProjStage projectStage()
    {
        ProjStage projStage;

        this.recordLevelSecurity(true);

        switch (this.Type)
        {
            case JmgJobTableType::ProjActivity:
            case JmgJobTableType::ProjBudget:
            case JmgJobTableType::ProjProject:
                projStage = ProjTable::find(this.ModuleRefId).Stage();
                break;
            default:
                projStage = ProjStageTable::find(ProjStatus::Created).Stage;
        }

        return projStage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projStartDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the start date of the parent project for the current job.
    /// </summary>
    /// <returns>
    /// The project start date of the current job.
    /// </returns>
    public display ProjStartDate projStartDate()
    {
        ProjStartDate startDate;

        this.recordLevelSecurity(true);

        switch (this.Type)
        {
            case JmgJobTableType::ProjActivity:
            case JmgJobTableType::ProjBudget:
            case JmgJobTableType::ProjProject:
                startDate = ProjTable::find(this.ModuleRefId).StartDate;
                break;
            default:
                startDate = dateNull();
        }

        return startDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>realDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the earliest journal registration that was made on the job.
    /// </summary>
    /// <returns>
    /// The <c>DateTime</c> value for the earliest registration on the job.
    /// </returns>
    public display JmgDateTime realDateTime()
    {
        JmgStampTrans           jmgStampTrans;
        JmgStampJournalTrans    jmgStampJournalTrans;

        jmgStampJournalTrans.recordLevelSecurity(true);
        jmgStampTrans.recordLevelSecurity(true);

        select firstonly StartDate, StartTime, JobId from jmgStampTrans
        order by StartDate, StartTime
        where jmgStampTrans.JobId   == this.JobId;
        select firstonly StartDate, StartTime, JobId from jmgStampJournalTrans
        order by StartDate, StartTime
        where (jmgStampJournalTrans.StartDate < jmgStampTrans.StartDate     ||
              (jmgStampJournalTrans.StartDate == jmgStampTrans.StartDate    &&
               jmgStampJournalTrans.StartTime < jmgStampTrans.StartTime))   &&
               jmgStampJournalTrans.JobId   == this.JobId;

        if (jmgStampJournalTrans)
        {
            return DateTimeUtil::newDateTime(jmgStampJournalTrans.StartDate,jmgStampJournalTrans.StartTime,DateTimeUtil::getUserPreferredTimeZone());
        }

        return DateTimeUtil::newDateTime(jmgStampTrans.StartDate,jmgStampTrans.StartTime,DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>realizedStartDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the actual date on which the job was started.
    /// </summary>
    /// <returns>
    /// The <c>SchedFromDate</c> value of the actual start date of the job.
    /// </returns>
    public display SchedFromDate realizedStartDate()
    {
        SchedFromDate   realizedStartDate;

        if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
        {
            realizedStartDate = ProdRouteJob::findJobId(this.JobId).RealizedStartDate;
        }
        else
        {
            realizedStartDate = DateTimeUtil::date(this.fromDateTime());
        }

        return realizedStartDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>realizedStartTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the actual time at which the job was started.
    /// </summary>
    /// <returns>
    /// The <c>SchedFromTime</c> value of the actual start time of the job.
    /// </returns>
    public display SchedFromTime realizedStartTime()
    {
        SchedFromTime    realizedStartTime;

        if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
        {
            realizedStartTime = ProdRouteJob::findJobId(this.JobId).RealizedStartTime;
        }
        else
        {
            realizedStartTime = DateTimeUtil::time(this.fromDateTime());
        }

        return realizedStartTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the remaining quantity of the production job.
    /// </summary>
    /// <returns>
    /// The remaining quantity of the job.
    /// </returns>
    public display JmgQtyRemaining remainingQuantity()
    {
        return this.CalcQty - this.goodQuantity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the name of the current records assigned resource.
    /// </summary>
    /// <returns>
    /// The resource name of the current record.
    /// </returns>
    public display WrkCtrName resourceName()
    {
        return WrkCtrTable::find(this.WrkCtrId).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReportedFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reports the job as finished or unfinished.
    /// </summary>
    /// <param name="_reportedFinished">
    /// A <c>NoYes</c> enumeration value that indicates whether to report the current job as finished.
    /// </param>
    /// <remarks>
    /// If a job has already been reported finished, and the job is to be set to reported not finished, the
    /// request to report as finished is ignored.
    /// </remarks>
    private void setReportedFinished(NoYes _reportedFinished)
    {
        JmgStampJournalTrans    jmgStampJournalTrans;
        JmgStampTrans           jmgStampTrans;

        if (this.ReportedFinished != _reportedFinished && _reportedFinished == NoYes::No)
        {
            select firstonly jmgStampJournalTrans
            where jmgStampJournalTrans.JobId        == this.JobId &&
                  jmgStampJournalTrans.JobFinished  == NoYes::Yes;

            if (jmgStampJournalTrans)
            {
                this.ReportedFinished = NoYes::Yes;

                return;
            }

            select firstonly jmgStampTrans
            where jmgStampTrans.JobId       == this.JobId &&
                  jmgStampTrans.JobFinished == NoYes::Yes;

            if (jmgStampTrans)
            {
                this.ReportedFinished = NoYes::Yes;

                return;
            }
        }

        this.ReportedFinished = _reportedFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProjParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the project ID of the parent.
    /// </summary>
    /// <returns>
    /// The project ID project parent.
    /// </returns>
    public display ProjId showProjParent()
    {
        ProjId      ret;

        if (this.imageModule() != JmgModuleEnum::PROJ)
        {
            return '';
        }

        if (this.Type != JmgJobTableType::ProjActivity &&
        this.Type != JmgJobTableType::ProjBudget   &&
        this.Type != JmgJobTableType::ProjProject)
        {
            return "@SYS80100";
        }

        ret = ProjTable::find(this.ModuleRefId).ParentId;

        return ret ? ret : "@SYS80100";
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProjSiblings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of siblings in the current project.
    /// </summary>
    /// <returns>
    /// If the project has siblings, the number of siblings is returned as text; otherwise, a label saying
    /// no project siblings are present.
    /// </returns>
    public display ProjId showProjSiblings()
    {
        ProjId  parent;
        int64     ret;

        if (this.imageModule() != JmgModuleEnum::PROJ)
        {
            return '';
        }

        if (this.Type != JmgJobTableType::ProjActivity &&
        this.Type != JmgJobTableType::ProjBudget   &&
        this.Type != JmgJobTableType::ProjProject)
        {
            return "@SYS80100";
        }

        parent = ProjTable::find(this.ModuleRefId).ParentId;

        if (!parent)
        {
            return "@SYS80100";
        }

        ret = (select count(RecId) from projTable where projTable.ParentId == parent).RecId;

        ret = ret - 1;

        return int642str(ret);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProjSubProjs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the current project has sub projects.
    /// </summary>
    /// <returns>
    /// An affirmative label if project has sub projects; otherwise, a label saying the project has no sub
    /// projects.
    /// </returns>
    public display ProjId showProjSubProjs()
    {
        if (this.imageModule() != JmgModuleEnum::PROJ)
        {
            return '';
        }

        if (this.Type != JmgJobTableType::ProjActivity &&
        this.Type != JmgJobTableType::ProjBudget   &&
        this.Type != JmgJobTableType::ProjProject)
        {
            return "@SYS80100";
        }

        return ProjTable::child(this.ModuleRefId) ? "@SYS5461" : "@SYS80100";
    }

]]></Source>
			</Method>
			<Method>
				<Name>started</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the job has been started by finding a record in the <c>JmgTermReg</c> table with
    /// the job ID and a <c>JmgTermRegType::JobStart</c> enumeration value set.
    /// </summary>
    /// <returns>
    /// true if the job has a <c>JobStart</c> record in the <c>JmgTermReg</c> table; otherwise, false.
    /// </returns>
    public display boolean started()
    {
        boolean     ret;
        JmgTermReg  jmgTermReg;

        jmgTermReg.recordLevelSecurity(true);

        if (!this.ReportedFinished &&
        this.Type >= JmgJobTableType::ProdQueueBefore &&
        this.Type <= JmgJobTableType::ProdQueueAfter)
        {
            if (JmgProdParameters::find().StampLevel == JmgStampLevel::Route)
            {
                ret = ProdRoute::findJobId(this.JobId).OprStartedUp;
            }
            else
            {
                ret = ProdJobStatus::Started == ProdRouteJob::findJobId(this.JobId).JobStatus;
            }

            if (!ret)
            {
                select firstonly jmgTermReg
                where jmgTermReg.JobId      == this.JobId    &&
                      jmgTermReg.RegType    == JmgTermRegType::JobStart;
                if (jmgTermReg)
                {
                    ret = true;
                }
            }
        }

        if (!this.ReportedFinished  &&
         this.Type == JmgJobTableType::ProjBudget   &&
         this.WrkCtrId)
        {
            select firstonly jmgTermReg
            where jmgTermReg.JobId      == this.JobId    &&
                  jmgTermReg.RegType    == JmgTermRegType::JobStart;
            if (jmgTermReg)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startedDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the date at which the job was started.
    /// </summary>
    /// <returns>
    /// The <c>SchedFromDate</c> value of the started date of the job.
    /// </returns>
    public display SchedFromDate startedDate()
    {
        SchedFromDate    startedDate;

        if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
        {
            startedDate = ProdRouteJob::findJobId(this.JobId).FromDate;
        }
        else
        {
            startedDate = ProdRoute::findJobId(this.JobId).FromDate;
        }

        return startedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for journal registrations and sums the started quantity of the job.
    /// </summary>
    /// <returns>
    /// The started quantity sum on the selected job
    /// </returns>
    public display JmgStartedQty startedQuantity()
    {
        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateStartQty(this.JobId);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateStartedQtyByWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for journal registrations and sums the started quantity of the job for a given worker.
    /// </summary>
    /// <param name="_worker">
    /// The worker to filter for.
    /// </param>
    /// <returns>
    /// The started quantity sum on the selected job for a given worker.
    /// </returns>
    public JmgStartedQty calculateStartedQtyByWorker(JmgWorkerRecId _worker)
    {
        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateStartedQtyByWorker(this.JobId, _worker);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePdsCWStartedQtyByWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for journal registrations and sums the started catch weight quantity of the job for a given worker.
    /// </summary>
    /// <param name="_worker">
    /// The worker to filter for.
    /// </param>
    /// <returns>
    /// The started catch weight quantity sum on the selected job for a given worker.
    /// </returns>
    public JmgStartedQty calculatePdsCWStartedQtyByWorker(JmgWorkerRecId _worker)
    {
        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculatePdsCWStartedQtyByWorker(this.JobId, _worker);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startedQuantityByWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for journal registrations and sums the started quantity of the job for a given worker.
    /// </summary>
    /// <param name="_worker">
    /// The worker to filter for.
    /// </param>
    /// <returns>
    /// The started quantity sum on the selected job for a given worker.
    /// </returns>
    public JmgStartedQty startedQuantityByWorker(JmgWorkerRecId _worker)
    {
        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            JmgStampJournalTrans    jmgStampJournalTrans;
            JmgStampTrans           jmgStampTrans;

            jmgStampJournalTrans.recordLevelSecurity(true);
            jmgStampTrans.recordLevelSecurity(true);

            return  (select sum(SysQtyStartup) from jmgStampJournalTrans
                        where jmgStampJournalTrans.JobId == this.JobId
                              && jmgStampJournalTrans.Worker == _worker).SysQtyStartup   +
                    (select sum(SysQtyStartup) from jmgStampTrans
                        where jmgStampTrans.JobId == this.JobId
                              && jmgStampTrans.Worker == _worker).SysQtyStartup;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startedTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the time at which the job was started.
    /// </summary>
    /// <returns>
    /// The <c>SchedFromDate</c> value of the started time of the job.
    /// </returns>
    public display SchedFromTime startedTime()
    {
        SchedFromTime    startedTime;

        if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
        {
            startedTime = ProdRouteJob::findJobId(this.JobId).FromTime;
        }
        else
        {
            startedTime = ProdRoute::findJobId(this.JobId).FromTime;
        }

        return startedTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the job in the table <c>JmgTermReg</c> record, and gets the latest <c>datetime</c> value that
    /// has been registered on the job.
    /// </summary>
    /// <returns>
    /// The <c>datetime</c> value of the latest registration of the job.
    /// </returns>
    public display JmgToDateTime toDateTime()
    {
        JmgTermReg jmgTermReg;

        jmgTermReg.recordLevelSecurity(true);

        select firstonly RegDateTime
        from jmgTermReg
        order by RegDateTime desc
        where jmgTermReg.JobId  == this.JobId;

        return jmgTermReg.RegDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobStatusImage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an image/icon representing the job progress status
    /// Returns empty if the jobs has not yet been started,
    /// and returns the picture of the first worker on the job if someone is working on it
    /// Returns respective icons for stopped and not available statuses
    /// </summary>
    [SysClientCacheDataMethodAttribute(true)]
    public display container jobStatusImage(JmgJobTable _jmgJobTable)
    {
        container imgContainer = connull();

        var status = JmgTermJob::constructJobTable(_jmgJobTable).jobStatus();

        switch (status)
        {
            case JmgJobStatus::Created, JmgJobStatus::Completed, JmgJobStatus::Waiting:
                break;
            case JmgJobStatus::InProgress:
                {
                    HcmWorker hcmWorker;
                    JmgTermReg jmgTermReg;

                    select firstonly PersonnelNumber, RecId, Person
                        from  hcmWorker
                        join JobActive, JobId, Worker from jmgTermReg
                        where jmgTermReg.JobActive == NoYes::Yes  &&
                              jmgTermReg.JobId     == _jmgJobTable.JobId  &&
                              hcmWorker.RecId      == jmgTermReg.Worker;

                    var personImage = HcmPersonImage::findByPerson(hcmWorker.Person);

                    if (personImage.RecId)
                    {
                        imgContainer = personImage.Image;
                    }
                    else
                    {
                        imgContainer = ImageReference::constructForSymbol(ImageReferenceSymbol::Person).pack();
                    }
                    break;
                }
            case JmgJobStatus::Started:
                imgContainer = ImageReference::constructForSymbol(ImageReferenceSymbol::Pause).pack();
                break;
            case JmgJobStatus::NotAvailable:
                imgContainer = imageReference::constructForSymbol(ImageReferenceSymbol::NotAvailable).pack();
        }

        return imgContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobStatusSimpleImage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an image/icon representing the job progress status
    /// Returns empty if the jobs has not yet been started,
    /// and returns the picture of the start icon on the job if someone is working on it
    /// Returns respective icons for stopped and not available statuses
    /// </summary>
    /// <param name = "_jmgJobTable"><c>JmgJobTable</c> record.</param>
    /// <returns>
    /// Container with image if Job has InProgress, Started or NotAvailable status; otherwise null;
    /// </returns>
    [Hookable(false), SysClientCacheDataMethodAttribute(true)]
    internal display container jobStatusSimpleImage(JmgJobTable _jmgJobTable)
    {
        container imgContainer = connull();

        JmgJobStatus status = JmgTermJob::constructJobTable(_jmgJobTable).jobStatus();

        if (status == JmgJobStatus::NotAvailable && JmgProductionFloorExecutionProjectFlight::instance().isEnabled() && _jmgJobTable.imageModule() == JmgModuleEnum::PROJ)
        {
            status = JmgJobStatus::Created;
        }

        switch (status)
        {
            case JmgJobStatus::Completed:
                imgContainer = ImageReference::constructForSymbol(ImageReferenceSymbol::Completed, enum2Str(status)).pack();
                break;
            case JmgJobStatus::InProgress:
                imgContainer = ImageReference::constructForSymbol(ImageReferenceSymbol::PlaySolid, enum2Str(status)).pack();
                break;
            case JmgJobStatus::Started:
                imgContainer = ImageReference::constructForSymbol(ImageReferenceSymbol::Pause, enum2Str(status)).pack();
                break;
            case JmgJobStatus::NotAvailable:
                imgContainer = ImageReference::constructForSymbol(ImageReferenceSymbol::NotAvailable, enum2Str(status)).pack();
                break;
            default:
                container imageData = SysResource::getResourceNodeData(SysResource::getResourceNode(resourcestr(TransparentImage)));
                Image image = new Image();
                image.setData(imageData);
                imgContainer = ImageReference::constructForImage(image, enum2Str(status)).pack();
        }

        return imgContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the record and updates the document reference table accordingly.
    /// </summary>
    public void update()
    {
        super();

        this.updateJmgJobDocuRefTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the record for a given job ID.
    /// </summary>
    /// <param name="_jobId">
    ///    The Job ID of the record.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that determines whether the job should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    The job table record.
    /// </returns>
    public static JmgJobTable find(JmgJobId _jobId, boolean _forUpdate = false)
    {
        JmgJobTable jmgJobTable;

        jmgJobTable.selectForUpdate(_forUpdate);

        if (_jobId)
        {
            select firstonly jmgJobTable
            where jmgJobTable.JobId == _jobId;
        }

        return jmgJobTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobHasTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a job has been associated with a record in the <c>JmgTermReg</c> table.
    /// </summary>
    /// <param name="_jobTable">
    /// A <c>JmgJobTable</c> record.
    /// </param>
    /// <returns>
    /// true if any associated records exist; otherwise, false.
    /// </returns>
    private static boolean jobHasTransactions(JmgJobTable _jobTable)
    {
        JmgTermReg jmgTermReg;

        select firstonly RecId from jmgTermReg where jmgTermReg.JobId == _jobTable.JobId;

        return jmgTermReg.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSynchronize</Name>
				<Source><![CDATA[
    private static boolean mustSynchronize(ProdTable _prodTable)
    {
        return JmgParameters::find().JobTableSynchronizationMode != JmgJobTableSynchronizationMode::Offline &&
               !JmgManufacturingExecutionWorkloadConfigurationProvider::isProductionOrderDeployedOnSpoke(_prodTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustNotSynchronizeProdTable</Name>
				<Source><![CDATA[
    private static boolean mustNotSynchronizeProdTable(ProdTable _prodTable)
    {
        return !JmgJobTable::mustSynchronize(_prodTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustNotSynchronizeProdRouteJob</Name>
				<Source><![CDATA[
    private static boolean mustNotSynchronizeProdRouteJob(ProdTable _prodTable)
    {
        return !JmgJobTable::mustSynchronize(_prodTable) ||
               JmgProdParameters::find().StampLevel == JmgStampLevel::Route;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustNotSynchronizeProdRoute</Name>
				<Source><![CDATA[
    private static boolean mustNotSynchronizeProdRoute(ProdTable _prodTable)
    {
        return !JmgJobTable::mustSynchronize(_prodTable) ||
               JmgProdParameters::find().StampLevel == JmgStampLevel::Job;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeHRMAbsenceCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes jobs from the <c>HRMAbsenceCode</c> table.
    /// </summary>
    /// <param name="_hrmAbsenceCode">
    /// A <c>HRMAbsenceCode</c> record from which to synchronize.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that indicates whether the record should be deleted.
    /// </param>
    public static void synchronizeHRMAbsenceCode(HRMAbsenceCode _hrmAbsenceCode, boolean _delete = false)
    {
        if (JmgParameters::find().JobTableSynchronizationMode == JmgJobTableSynchronizationMode::Offline)
        {
            return;
        }

        JmgJobTable::doSynchronizeHRMAbsenceCode(_hrmAbsenceCode, _delete);
       
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSynchronizeHRMAbsenceCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains actual logic to synchronize jobs from the <c>HRMAbsenceCode</c> table.
    /// </summary>
    /// <param name="_hrmAbsenceCode">
    /// A <c>HRMAbsenceCode</c> record from which to synchronize.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that indicates whether the record should be deleted.
    /// </param>
    private static void doSynchronizeHRMAbsenceCode(HRMAbsenceCode _hrmAbsenceCode, boolean _delete = false)
    {
        JmgJobTable     jmgJobTable;

        ttsbegin;

        jmgJobTable = JmgJobTable::find(_hrmAbsenceCode.JmgJobId, true);

        if (_hrmAbsenceCode.JmgJobId                &&
        !_delete                                &&
        _hrmAbsenceCode.JmgSignIn == NoYes::Yes)
        {
            jmgJobTable.JobId       = _hrmAbsenceCode.JmgJobId;
            jmgJobTable.Type        = JmgJobTableType::HRMAbsenceCode;
            jmgJobTable.ModuleRefId = _hrmAbsenceCode.HrmAbsenceCodeGroupId;
            jmgJobTable.OprActId    = _hrmAbsenceCode.HrmAbsenceCodeId;
            jmgJobTable.Description = _hrmAbsenceCode.Description;
            jmgJobTable.write();
        }
        else
        {
            jmgJobTable.delete();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeHRMAbsenceCodeGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes jobs from the <c>HRMAbsenceCodeGroup</c> table.
    /// </summary>
    /// <param name="_hrmAbsenceCodeGroup">
    /// A <c>HRMAbsenceCodeGroup</c> record to synchronize from.
    /// </param>
    /// <param name="_delete">
    ///  A Boolean value that indicates whether a record should be deleted.
    /// </param>
    public static void synchronizeHRMAbsenceCodeGroup(HRMAbsenceCodeGroup _hrmAbsenceCodeGroup, boolean _delete = false)
    {
        if (JmgParameters::find().JobTableSynchronizationMode == JmgJobTableSynchronizationMode::Offline)
        {
            return;
        }

        JmgJobTable::doSynchronizeHRMAbsenceCodeGroup(_hrmAbsenceCodeGroup, _delete);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSynchronizeHRMAbsenceCodeGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains actual logic to synchronize jobs from the <c>HRMAbsenceCodeGroup</c> table.
    /// </summary>
    /// <param name="_hrmAbsenceCodeGroup">
    /// A <c>HRMAbsenceCodeGroup</c> record to synchronize from.
    /// </param>
    /// <param name="_delete">
    ///  A Boolean value that indicates whether a record should be deleted.
    /// </param>
    private static void doSynchronizeHRMAbsenceCodeGroup(HRMAbsenceCodeGroup _hrmAbsenceCodeGroup, boolean _delete = false)
    {
        JmgJobTable     jmgJobTable;

        ttsbegin;

        jmgJobTable = JmgJobTable::find(_hrmAbsenceCodeGroup.JmgJobId, true);

        if (_hrmAbsenceCodeGroup.JmgJobId           &&
        !_delete                                &&
        _hrmAbsenceCodeGroup.JmgSignIn == NoYes::Yes)
        {
            jmgJobTable.JobId       = _hrmAbsenceCodeGroup.JmgJobId;
            jmgJobTable.Type        = JmgJobTableType::HRMAbsenceCodeGroup;
            jmgJobTable.ModuleRefId = _hrmAbsenceCodeGroup.HrmAbsenceCodeGroupId;
            jmgJobTable.Description = _hrmAbsenceCodeGroup.Description;
            jmgJobTable.write();
        }
        else
        {
            jmgJobTable.delete();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeJmgIpcActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes jobs from the <c>JmgIpcActivity</c> table.
    /// </summary>
    /// <param name="_jmgIpcActivity">
    /// A <c>JmgIpcActivity</c> record to synchronize from.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that determines whether record should be deleted.
    /// </param>
    public static void synchronizeJmgIpcActivity(JmgIpcActivity _jmgIpcActivity, boolean _delete = false)
    {
        if (JmgParameters::find().JobTableSynchronizationMode == JmgJobTableSynchronizationMode::Offline)
        {
            return;
        }
        JmgJobTable::doSynchronizeJmgIpcActivity(_jmgIpcActivity, _delete);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSynchronizeJmgIpcActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains actual logic to synchronize jobs from the <c>JmgIpcActivity</c> table.
    /// </summary>
    /// <param name="_jmgIpcActivity">
    /// A <c>JmgIpcActivity</c> record to synchronize from.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that determines whether record should be deleted.
    /// </param>
    private static void doSynchronizeJmgIpcActivity(JmgIpcActivity _jmgIpcActivity, boolean _delete = false)
    {
        JmgJobTable     jmgJobTable;

        ttsbegin;

        jmgJobTable = JmgJobTable::find(_jmgIpcActivity.JobId, true);

        if (_jmgIpcActivity.JobId                   &&
        !_delete                                &&
        _jmgIpcActivity.SignIn  == NoYes::Yes   &&
        _jmgIpcActivity.Type    != JmgStampTypeEnum::Error &&
        _jmgIpcActivity.SignInOut != JmgSignInOut::SysIndirect)
        {
            jmgJobTable.JobId       = _jmgIpcActivity.JobId;
            switch (_jmgIpcActivity.Type)
            {
                case JmgStampTypeEnum::Break:
                    jmgJobTable.Type    = JmgJobTableType::SFCBreak;
                    break;
                case JmgStampTypeEnum::EventCode:
                    jmgJobTable.Type    = JmgJobTableType::SFCEventCode;
                    break;
                case JmgStampTypeEnum::OnCall:
                    jmgJobTable.Type    = JmgJobTableType::SFCOnCall;
                    break;
                default:
                switch (_jmgIpcActivity.SignInOut)
                    {
                        case JmgSignInOut::SignIn:
                            jmgJobTable.Type    = JmgJobTableType::SFCClockIn;
                            break;
                        case JmgSignInOut::SignOut:
                            jmgJobTable.Type    = JmgJobTableType::SFCClockOut;
                            break;
                        case JmgSignInOut::StartTeam:
                            jmgJobTable.Type    = JmgJobTableType::SFCStartTeam;
                            break;
                        case JmgSignInOut::StopTeam:
                            jmgJobTable.Type    = JmgJobTableType::SFCStopTeam;
                            break;
                        case JmgSignInOut::StopBreak:
                            jmgJobTable.Type    = JmgJobTableType::SFCBreak;
                            break;
                        default:
                            jmgJobTable.Type        = JmgJobTableType::SFCActivity;
                            break;
                    }
                    break;
            }
            jmgJobTable.ModuleRefId = _jmgIpcActivity.Category;
            jmgJobTable.OprActId    = _jmgIpcActivity.Activity;
            jmgJobTable.Description = _jmgIpcActivity.Description;
            jmgJobTable.write();
        }
        else
        {
            jmgJobTable.delete();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes jobs from the <c>ProdRoute</c> table.
    /// </summary>
    /// <param name="_prodRoute">
    /// A <c>ProdRoute</c> record from which to synchronize.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that indicates whether the record should be deleted.
    /// </param>
    public static void synchronizeProdRoute(ProdRoute _prodRoute, boolean _delete = false)
    {
        if (JmgJobTable::mustNotSynchronizeProdRoute(_prodRoute.prodTable()))
        {
            return;
        }

        JmgJobTable::doSynchronizeProdRoute(_prodRoute, _delete);   
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSynchronizeProdRoute</Name>
				<Source><![CDATA[
    private static void doSynchronizeProdRoute(ProdRoute _prodRoute, boolean _delete = false)
    {
        JmgJobTable     jmgJobTableSetup;
        JmgJobTable     jmgJobTableProcess;
        ProdTable       prodTable;

        ttsbegin;

        jmgJobTableSetup    = JmgJobTable::find(_prodRoute.JobIdSetup, true);
        jmgJobTableProcess  = JmgJobTable::find(_prodRoute.JobIdProcess, true);

        prodTable           = _prodRoute.prodTable();

        if (_delete
            || prodTable.status().isBefore(ProdStatus::Released)
            || prodTable.status().isAfter(ProdStatus::ReportedFinished))
        {
            jmgJobTableSetup.delete();
            jmgJobTableProcess.delete();
        }
        else
        {
            // Sync setup
            if (_prodRoute.primary().SetupTime != 0         &&
            _prodRoute.JobIdSetup                       &&
            JmgProdParametersDim::find(_prodRoute.prodTable().inventDim().InventSiteId).AllowProdSetup == NoYes::Yes)
            {
                JmgJobTable::synchronizeProdRouteSetup(jmgJobTableSetup, _prodRoute);
            }
            else
            {
                jmgJobTableSetup.delete();
            }

            // Sync process
            if (_prodRoute.primary().ProcessTime != 0       &&
            _prodRoute.JobIdProcess                     &&
            JmgProdParametersDim::find(_prodRoute.prodTable().inventDim().InventSiteId).AllowProdProcess == NoYes::Yes)
            {
                JmgJobTable::synchronizeProdRouteProcess(jmgJobTableProcess, _prodRoute);
            }
            else
            {
                jmgJobTableProcess.delete();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeProdRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes the jobs in the <c>ProdRouteJob</c> table.
    /// </summary>
    /// <param name="_prodRouteJob">
    /// The <c>ProdRouteJob</c> record from which to synchronize.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that indicates whether the record should be deleted.
    /// </param>
    /// <returns>
    /// true if the job is synchronized; otherwise, false .
    /// </returns>
    public static boolean synchronizeProdRouteJob(ProdRouteJob _prodRouteJob, boolean _delete = false)
    {
        if (JmgJobTable::mustNotSynchronizeProdRouteJob(_prodRouteJob.prodTable()))
        {
            return true;
        }

        return JmgJobTable::doSynchronizeProdRouteJob(_prodRouteJob, _delete);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSynchronizeProdRouteJob</Name>
				<Source><![CDATA[
    private static boolean doSynchronizeProdRouteJob(ProdRouteJob _prodRouteJob, boolean _delete = false)
    {
        JmgJobTable jmgJobTable = JmgJobTable::find(_prodRouteJob.JobId, true);

        // if job has any related transaction then we should cancel job synchronization
        if (JmgJobTable::jobHasTransactions(jmgJobTable)
            && _prodRouteJob.JobStatus != ProdJobStatus::Completed
            && jmgJobTable.jobStatus() == JmgJobStatus::InProgress)
        {
            return false;
        }
        WrkCtrResourceGroup wrkCtrResourceGroup = WrkCtrTable::resourceGroup(_prodRouteJob.WrkCtrId, _prodRouteJob.FromDate, _prodRouteJob.ToDate);
        JmgProdParametersDim jmgProdParametersDim = JmgProdParametersDim::find(wrkCtrResourceGroup.SiteId);
        ProdTable prodTable = _prodRouteJob.prodTable();

        ttsbegin;
        if (_delete                                                         ||
            !_prodRouteJob.JobId                                            ||
            (_prodRouteJob.SchedCancelled                                   &&
            _prodRouteJob.JobType != RouteJobType::Process                  &&
            _prodRouteJob.JobFinished == NoYes::Yes)                        ||
            prodTable.status().isBefore(ProdStatus::Released)             ||
            prodTable.status().isAfter(ProdStatus::ReportedFinished)  ||
            !jmgProdParametersDim.allowJobType(_prodRouteJob.JobType))
        {
            jmgJobTable.delete();
        }
        else
        {
            jmgJobTable.ItemId             = prodTable.ItemId;
            jmgJobTable.initFromProdRouteJob(_prodRouteJob);
            jmgJobTable.ResourceGroup      = wrkCtrResourceGroup.RecId;
            jmgJobTable.InventSiteId       = wrkCtrResourceGroup.SiteId;
            jmgJobTable.OriginalResource   = jmgJobTable.WrkCtrId;
            JmgJobTable::setPriorityResource(jmgJobTable);

            jmgJobTable.write();
        }
        ttscommit;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromProdRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>JmgJobTable</c> record from the <c>ProdRouteJob</c> record.
    /// </summary>
    /// <param name="_prodRouteJob">
    /// A record from which to update.
    /// </param>
    public void initFromProdRouteJob(ProdRouteJob _prodRouteJob)
    {
        this.JobId              = _prodRouteJob.JobId;
        this.Type               = JmgJobTable::translateProductionType(_prodRouteJob.JobType);
        this.ModuleRefId        = _prodRouteJob.ProdId;
        this.OprActId           = _prodRouteJob.prodRoute().OprId;
        this.FromDate           = _prodRouteJob.FromDate;
        this.FromTime           = _prodRouteJob.FromTime;
        this.ToDate             = _prodRouteJob.ToDate;
        this.ToTime             = _prodRouteJob.ToTime;
        this.WrkCtrId           = _prodRouteJob.WrkCtrId;
        this.OprNum             = _prodRouteJob.OprNum;
        this.Priority           = _prodRouteJob.OprPriority;
        this.Description        = RouteOprTable::find(_prodRouteJob.prodRoute().OprId).Name;

        if (_prodRouteJob.JobType == RouteJobType::Process)
        {
            this.CalcQty        = _prodRouteJob.prodRoute().CalcQty;
            this.PdsCWCalcQty   = _prodRouteJob.prodRoute().pdsCWCalcQty();
        }

        this.setReportedFinished(_prodRouteJob.JobFinished);
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeProdRouteProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes a specified <c>JmgJobTable</c> record from its corresponding <c>ProdRoute</c> process
    /// record.
    /// </summary>
    /// <param name="_jmgJobTable">
    /// The record to update.
    /// </param>
    /// <param name="_prodRoute">
    /// The record from which to update.
    /// </param>
    private static void synchronizeProdRouteProcess(JmgJobTable _jmgJobTable, ProdRoute _prodRoute)
    {
        _jmgJobTable.Type = JmgJobTableType::ProdProcess;
        _jmgJobTable.initFromProdRoute(_prodRoute);

        WrkCtrCapRes wrkCtrCapRes;

        select minof(TransDate)
        from  wrkCtrCapRes
        where wrkCtrCapRes.LoadType                 != WrkCtrCapacityType::Deletemarked     &&
              wrkCtrCapRes.RefId                    == _prodRoute.ProdId                    &&
              wrkCtrCapRes.RefType                  == WrkCtrCapRefType::Production         &&
              wrkCtrCapRes.JobType                  == RouteJobType::Process                &&
              wrkCtrCapRes.OprNum                   == _prodRoute.OprNum                    &&
              wrkCtrCapRes.OprPriority              == _prodRoute.OprPriority               &&
              wrkCtrCapRes.PlanVersion == 0;

        if (wrkCtrCapRes.TransDate)
        {
            _jmgJobTable.FromDate = wrkCtrCapRes.TransDate;

            select maxof(TransDate), maxof(WrkCtrId)
            from  wrkCtrCapRes
            where wrkCtrCapRes.LoadType                 != WrkCtrCapacityType::Deletemarked     &&
                  wrkCtrCapRes.RefId                    == _prodRoute.ProdId                    &&
                  wrkCtrCapRes.RefType                  == WrkCtrCapRefType::Production         &&
                  wrkCtrCapRes.JobType                  == RouteJobType::Process                &&
                  wrkCtrCapRes.OprNum                   == _prodRoute.OprNum                    &&
                  wrkCtrCapRes.OprPriority              == _prodRoute.OprPriority               &&
                  wrkCtrCapRes.PlanVersion == 0;

            _jmgJobTable.ToDate   = wrkCtrCapRes.TransDate;
            _jmgJobTable.WrkCtrId = wrkCtrCapRes.WrkCtrId;
        }

        _jmgJobTable.FromTime     = 0;
        _jmgJobTable.ToTime       = 0;

        WrkCtrResourceGroup wrkCtrResourceGroup = WrkCtrTable::resourceGroup(_jmgJobTable.WrkCtrId,_jmgJobTable.FromDate,_jmgJobTable.ToDate);

        _jmgJobTable.ResourceGroup      = wrkCtrResourceGroup.RecId;
        _jmgJobTable.InventSiteId       = wrkCtrResourceGroup.SiteId;
        _jmgJobTable.OriginalResource   = _jmgJobTable.WrkCtrId;

        JmgJobTable::setPriorityResource(_jmgJobTable);

        _jmgJobTable.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeProdRouteSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes a given <c>JmgJobTable</c> record from its corresponding <c>ProdRoute</c> setup record.
    /// </summary>
    /// <param name="_jmgJobTable">
    /// A record to update.
    /// </param>
    /// <param name="_prodRoute">
    /// A record from which to update.
    /// </param>
    private static void synchronizeProdRouteSetup(JmgJobTable _jmgJobTable, ProdRoute _prodRoute)
    {
        _jmgJobTable.Type = JmgJobTableType::ProdSetup;
        _jmgJobTable.initFromProdRoute(_prodRoute);

        WrkCtrCapRes wrkCtrCapRes;

        select minof(TransDate)
        from  wrkCtrCapRes
        where wrkCtrCapRes.LoadType                 != WrkCtrCapacityType::Deletemarked     &&
              wrkCtrCapRes.RefId                    == _prodRoute.ProdId                    &&
              wrkCtrCapRes.RefType                  == WrkCtrCapRefType::Production         &&
              wrkCtrCapRes.JobType                  == RouteJobType::Setup                  &&
              wrkCtrCapRes.OprNum                   == _prodRoute.OprNum                    &&
              wrkCtrCapRes.OprPriority              == _prodRoute.OprPriority               &&
              wrkCtrCapRes.PlanVersion == 0;

        if (wrkCtrCapRes.TransDate)
        {
            _jmgJobTable.FromDate = wrkCtrCapRes.TransDate;
 
            select maxof(TransDate), maxof(WrkCtrId)
            from  wrkCtrCapRes
            where wrkCtrCapRes.LoadType                 != WrkCtrCapacityType::Deletemarked     &&
                  wrkCtrCapRes.RefId                    == _prodRoute.ProdId                    &&
                  wrkCtrCapRes.RefType                  == WrkCtrCapRefType::Production         &&
                  wrkCtrCapRes.JobType                  == RouteJobType::Setup                  &&
                  wrkCtrCapRes.OprNum                   == _prodRoute.OprNum                    &&
                  wrkCtrCapRes.OprPriority              == _prodRoute.OprPriority               &&
                  wrkCtrCapRes.PlanVersion == 0;

            _jmgJobTable.ToDate   = wrkCtrCapRes.TransDate;
            _jmgJobTable.WrkCtrId = wrkCtrCapRes.WrkCtrId;
        }

        _jmgJobTable.FromTime     = 0;
        _jmgJobTable.ToTime       = 0;

        WrkCtrResourceGroup wrkCtrResourceGroup = WrkCtrTable::resourceGroup(_jmgJobTable.WrkCtrId,_jmgJobTable.FromDate,_jmgJobTable.ToDate);

        _jmgJobTable.ResourceGroup    = wrkCtrResourceGroup.RecId;
        _jmgJobTable.InventSiteId     = wrkCtrResourceGroup.SiteId;
        _jmgJobTable.OriginalResource = _jmgJobTable.WrkCtrId;

        JmgJobTable::setPriorityResource(_jmgJobTable);

        _jmgJobTable.write(); 
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>JmgJobTable</c> record from the <c>ProdRoute</c> record.
    /// </summary>
    /// <param name="_prodRoute">
    /// A record from which to update.
    /// </param>
    public void initFromProdRoute(ProdRoute _prodRoute)
    {
        if (this.Type == JmgJobTableType::ProdProcess)
        {
            this.JobId        = _prodRoute.JobIdProcess;
            this.CalcQty      = _prodRoute.CalcQty;
            this.PdsCWCalcQty = _prodRoute.pdsCWCalcQty();
        } 
        else if (this.Type == JmgJobTableType::ProdSetup)
        {
            this.JobId        = _prodRoute.JobIdSetup;
        }

        this.ModuleRefId      = _prodRoute.ProdId;
        this.OprActId         = _prodRoute.OprId;
        this.OprNum           = _prodRoute.OprNum;
        this.Priority         = _prodRoute.OprPriority;
        this.Description      = RouteOprTable::find(_prodRoute.OprId).Name;
        this.ItemId           = _prodRoute.prodTable().ItemId;

        this.setReportedFinished(_prodRoute.OprFinished);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriorityResource</Name>
				<Source><![CDATA[
    private static void setPriorityResource(JmgJobTable _jmgJobTable)
    {
        if (!_jmgJobTable.PriorityResource)
        {
            _jmgJobTable.PriorityResource   = maxInt();
            _jmgJobTable.Locked             = NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeProdTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes jobs from the <c>ProdTable</c> table.
    /// </summary>
    /// <param name="_prodTable">
    /// A <c>ProdTable</c> record from which to synchronize.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that indicates whether the record should be deleted.
    /// </param>
    public static void synchronizeProdTable(ProdTable _prodTable, boolean _delete = false)
    {
        if (JmgJobTable::mustNotSynchronizeProdTable(_prodTable))
        {
            return;
        }

        JmgJobTable::doSynchronizeProdTable(_prodTable, _delete);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSynchronizeProdTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post synchronizes jobs from the <c>ProdTable</c> table for manufacturing execution workload.
    /// </summary>
    /// <param name="_prodTable">
    /// A <c>ProdTable</c> record from which to synchronize.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that indicates whether the record should be deleted.
    /// </param>
    internal static void postSynchronizeProdTable(ProdTable _prodTable, boolean _delete = false)
    {
        if (JmgParameters::find().JobTableSynchronizationMode == JmgJobTableSynchronizationMode::Offline)
        {
            return;
        }

        JmgJobTable::doSynchronizeProdTable(_prodTable, _delete);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSynchronizeProdTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains actual logic to synchronize jobs from the <c>ProdTable</c> table.
    /// </summary>
    /// <param name="_prodTable">
    /// A <c>ProdTable</c> record from which to synchronize.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that indicates whether the record should be deleted.
    /// </param>
    private static void doSynchronizeProdTable(ProdTable _prodTable, boolean _delete = false)
    {
        JmgProdParameters jmgProdParameters;
        ProdRoute           prodRoute;
        ProdRouteJob        prodRouteJob;

        ttsbegin;

        jmgProdParameters = JmgProdParameters::find();

        switch (jmgProdParameters.StampLevel)
        {
            case JmgStampLevel::Route:
            while select prodRoute
                where prodRoute.ProdId == _prodTable.ProdId
                {
                    JmgJobTable::doSynchronizeProdRoute(prodRoute, _delete ||
                                                  _prodTable.status().isBefore(ProdStatus::Released) ||
                                                  _prodTable.status().isAfter(ProdStatus::ReportedFinished));
                }
                break;

            case JmgStampLevel::Job:
            while select prodRouteJob
                where prodRouteJob.ProdId == _prodTable.ProdId
                {
                    JmgJobTable::doSynchronizeProdRouteJob(prodRouteJob, _delete ||
                                                     _prodTable.status().isBefore(ProdStatus::Released) ||
                                                     _prodTable.status().isAfter(ProdStatus::ReportedFinished));
                }
                break;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeProjActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes jobs from the <c>ProjActivity</c> table.
    /// </summary>
    /// <param name="_projActivity">
    /// A <c>ProjActivity</c> record to synchronize from.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that indicates whether record should be deleted.
    /// </param>
    public static void synchronizeProjActivity(ProjActivity _projActivity, boolean _delete = false)
    {
        JmgJobTable     jmgJobTable;
        JmgParameters   jmgParameters;
        ProjTable       projTable;
        smmActivities   smmActivities;

        jmgParameters = JmgParameters::find();

        if (jmgParameters.JobTableSynchronizationMode   == JmgJobTableSynchronizationMode::Offline)
        {
            return;
        }

        ttsbegin;

        jmgJobTable     = JmgJobTable::find(_projActivity.JobId, true);
        smmActivities   = smmActivities::find(_projActivity.ActivityNumber);
        projTable = HierarchyTreeTable_Extension::findAssociation(smmActivities, tableNum(ProjTable)) as ProjTable;

        if (_projActivity.JobId                                 &&
            !_delete                                            &&
            ProjStatusTypeRule::exist(projTable.Status, projTable.Type, ProjStatusRule::CreateJournal))
        {
            jmgJobTable.JobId       = _projActivity.JobId;
            jmgJobTable.Type        = JmgJobTableType::ProjActivity;
            jmgJobTable.ModuleRefId = projTable.ProjId;
            jmgJobTable.OprActId    = _projActivity.ActivityNumber;
            if (_projActivity.Txt)
            {
                jmgJobTable.Description = _projActivity.Txt;
            }
            else
            {
                jmgJobTable.Description = smmActivities.Purpose;
            }
            jmgJobTable.FromDate    = smmActivities.startDate();
            jmgJobTable.FromTime    = smmActivities.startTime();
            jmgJobTable.ReportedFinished    = smmActivities.Closed;
            jmgJobTable.write();
        }
        else
        {
            jmgJobTable.delete();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeProjBudgetEmpl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes jobs from the <c>ProjForecastEmpl</c> table.
    /// </summary>
    /// <param name="_projForecastEmpl">
    /// A <c>ProjForecastEmpl</c> record from which to synchronize.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that indicates whether record should be deleted.
    /// </param>
    public static void synchronizeProjBudgetEmpl(ProjForecastEmpl _projForecastEmpl, boolean _delete = false)
    {
        JmgJobTable         jmgJobTable;
        JmgParameters       jmgParameters;
        WrkCtrResourceGroup wrkCtrResourceGroup;

        jmgParameters = JmgParameters::find();

        if (jmgParameters.JobTableSynchronizationMode   == JmgJobTableSynchronizationMode::Offline)
        {
            return;
        }

        ttsbegin;

        jmgJobTable = JmgJobTable::find(_projForecastEmpl.JobId, true);

        if (_projForecastEmpl.JobId                           &&
        !_delete                                        &&
        _projForecastEmpl.Active  == NoYes::Yes           &&
        ProjTable::find(_projForecastEmpl.ProjId).Status  == ProjStatus::InProcess)
        {
            jmgJobTable.JobId           = _projForecastEmpl.JobId;
            jmgJobTable.Type            = JmgJobTableType::ProjBudget;
            jmgJobTable.ModuleRefId     = _projForecastEmpl.ProjId;
            jmgJobTable.OprActId        = _projForecastEmpl.ActivityNumber;
            jmgJobTable.FromDate        = _projForecastEmpl.SchedFromDate;
            jmgJobTable.FromTime        = _projForecastEmpl.SchedFromTime;
            jmgJobTable.ToDate          = _projForecastEmpl.SchedToDate;
            jmgJobTable.ToTime          = _projForecastEmpl.SchedToTime;
            jmgJobTable.WrkCtrId        = _projForecastEmpl.SchedWrkCtrId;
            jmgJobTable.Description     = _projForecastEmpl.Txt;
            jmgJobTable.Worker          = ResourceFacade::getWorker(_projForecastEmpl.Resource);

            wrkCtrResourceGroup         = WrkCtrTable::resourceGroup(_projForecastEmpl.SchedWrkCtrId, _projForecastEmpl.SchedFromDate, _projForecastEmpl.SchedToDate);

            jmgJobTable.ResourceGroup   = wrkCtrResourceGroup.RecId;
            jmgJobTable.InventSiteId    = wrkCtrResourceGroup.SiteId;
            jmgJobTable.write();
        }
        else
        {
            jmgJobTable.delete();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeProjTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes jobs from the <c>ProjTable</c> table.
    /// </summary>
    /// <param name="_projTable">
    /// A <c>ProjTable</c> record from which to synchronize.
    /// </param>
    /// <param name="_delete">
    /// A Boolean value that indicates whether a record should be deleted.
    /// </param>
    public static void synchronizeProjTable(ProjTable _projTable, boolean _delete = false)
    {
        JmgJobTable     jmgJobTable;
        JmgParameters   jmgParameters;
        ProjActivity    projActivity;
        ProjForecastEmpl projForecastEmpl;

        // hierarchy
        Query                   query   = new Query();
        QueryRun                queryRun;
        container               con;

        jmgParameters = JmgParameters::find();

        if (jmgParameters.JobTableSynchronizationMode   == JmgJobTableSynchronizationMode::Offline)
        {
            return;
        }

        ttsbegin;

        if (_projTable.JobId &&
            !_delete &&
            ProjStatusTypeRule::exist(_projTable.Status, _projTable.Type, ProjStatusRule::CreateJournal)    &&
            _projTable.Header   == NoYes::No)
        {
            jmgJobTable             = JmgJobTable::find(_projTable.JobId, true);
            jmgJobTable.JobId       = _projTable.JobId;
            jmgJobTable.Type        = JmgJobTableType::ProjProject;
            jmgJobTable.ModuleRefId = _projTable.ProjId;
            jmgJobTable.FromDate    = _projTable.StartDate;
            jmgJobTable.ToDate      = _projTable.EndDate;
            jmgJobTable.Description = _projTable.Name;
            jmgJobTable.write();

            con = ProjActivity::queryActivities(tableNum(ProjTable), _projTable.RecId);
            query = new Query(con);
            queryRun = new QueryRun(query);

            while (queryRun.next())
            {
                projActivity = queryRun.get(tableNum(ProjActivity)) as ProjActivity;
                JmgJobTable::synchronizeProjActivity(projActivity, _delete);
            }

            while select projForecastEmpl
                where projForecastEmpl.ProjId == _projTable.ProjId
            {
                JmgJobTable::synchronizeProjBudgetEmpl(projForecastEmpl, _delete);
            }
        }
        else
        {
            delete_from jmgJobTable
                where jmgJobTable.ModuleRefId == _projTable.ProjId;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>translateProductionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Translates the <c>RouteJobType</c> enumeration into the <c>JmgJobTableType</c> enumeration.
    /// </summary>
    /// <param name="_routeJobType">
    /// The <c>RouteJobType</c> enumeration value from which to translate.
    /// </param>
    /// <returns>
    /// A <c>JmgJobTableType</c> enumeration value translated from the <c>RouteJobType</c> enumeration.
    /// </returns>
    public static JmgJobTableType translateProductionType(RouteJobType _routeJobType)
    {
        JmgJobTableType jobTableType;

        switch (_routeJobType)
        {
            case RouteJobType::QueueBefore:
                jobTableType = JmgJobTableType::ProdQueueBefore;
                break;
            case RouteJobType::Setup:
                jobTableType = JmgJobTableType::ProdSetup;
                break;
            case RouteJobType::Process:
                jobTableType = JmgJobTableType::ProdProcess;
                break;
            case RouteJobType::Overlap:
                jobTableType = JmgJobTableType::ProdOverlap;
                break;
            case RouteJobType::Transport:
                jobTableType = JmgJobTableType::ProdTransport;
                break;
            case RouteJobType::QueueAfter:
                jobTableType = JmgJobTableType::ProdQueueAfter;
                break;
        }

        return jobTableType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateJmgJobDocuRefTable</Name>
				<Source><![CDATA[
    private boolean mustUpdateJmgJobDocuRefTable()
    {
        if (this.isTmp())
        {
            return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJmgJobDocuRefTable</Name>
				<Source><![CDATA[
    private void updateJmgJobDocuRefTable(boolean _justDelete = false)
    {
        if (this.mustUpdateJmgJobDocuRefTable())
        {
            if (_justDelete)
            {
                JmgJobTable::deleteDocumentRefTable(this.JobId);
            }
            else
            {
                JmgJobTable::updateDocumentRefTable(this.JobId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteDocumentRefTable</Name>
				<Source><![CDATA[
    private static void deleteDocumentRefTable(JmgJobId _jmgJobId)
    {
        JmgJobDocuRef docRef;

        ttsbegin;
        delete_from docRef where docRef.JobId == _jmgJobId;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentRefTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>JmgJobDocuRef</c> table to contain references between tables that are related to the
    /// <c>JmgJobTable</c> table.
    /// </summary>
    /// <param name="_jmgJobId">
    /// A <c>JmgJobId</c> type of the job to update the references to.
    /// </param>
    /// <param name="_justDelete">
    /// A Boolean value, that determines whether all the references to the job ID should be deleted in the
    /// <c>JmgJobDocuRef</c> table.
    /// </param>
    public static void updateDocumentRefTable(JmgJobId _jmgJobId, boolean _justDelete = false)
    {
        JmgJobDocuRef   docRef;

        if (_justDelete)
        {
            JmgJobTable::deleteDocumentRefTable(_jmgJobId);
            return;
        }

        var jmgJobTable = JmgJobTable::find(_jmgJobId);

        if (!jmgJobTable)
        {
            return;
        }

        JmgJobDocuRefView docRefView;

        ttsbegin;

        delete_from docRef 
        where docRef.JobId == jmgJobTable.JobId
        notexists join docRefView
            where docRefView.JobId == docRef.JobId
                && docRefView.RefTableId == docRef.RefTableId
                && docRefView.RefRecId == docRef.RefRecId;

        insert_recordset docRef (JobId, RefTableId, RefRecId)
        select JobId, RefTableId, RefRecId
        from docRefView 
        where docRefView.JobId == jmgJobTable.JobId
        notexists join docRef
            where docRef.JobId == docRefView.JobId
                && docRef.RefTableId == docRefView.RefTableId
                && docRef.RefRecId == docRefView.RefRecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReportedFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reports a given job record as finished.
    /// </summary>
    /// <param name="_jmgJobId">
    /// The job ID of the record to update.
    /// </param>
    /// <param name="_reportedFinished">
    /// The value to update the record.
    /// </param>
    public static void updateReportedFinished(JmgJobId _jmgJobId, NoYes _reportedFinished)
    {
        JmgJobTable jmgJobTable;

        ttsbegin;

        jmgJobTable = JmgJobTable::find(_jmgJobId, true);

        if (jmgJobTable)
        {
            jmgJobTable.setReportedFinished(_reportedFinished);
            jmgJobTable.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasAttachments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the the <c>JmgJobDocuRef</c> record has attachments.
    /// </summary>
    /// <returns>
    /// True if the <c>JmgJobDocuRef</c> record has attachments, otherwise false.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public boolean hasAttachments()
    {
        JmgJobDocuRef jmgJobDocuRef;
        DocuRef docuRef;

        select firstonly jmgJobDocuRef
            where jmgJobDocuRef.JobId == this.JobId
        exists join docuRef
            where docuRef.RefCompanyId  == jmgJobDocuRef.DataAreaId
               && docuRef.RefTableId    == jmgJobDocuRef.RefTableId
               && docuRef.RefRecId      == jmgJobDocuRef.RefRecId;

        return jmgJobDocuRef.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasBOMLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines if an operation has any BOM lines.
    /// </summary>
    /// <returns>
    /// true if the operation has any BOM lines; otherwise, false.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal boolean hasBOMLines()
    {
        boolean ret;

        ProdTable prodTable = ProdTable::find(this.ModuleRefId);
        
        if (prodTable
            && (JmgJobTableAllowEmptyProdBomInExistsBomLinesFlight::instance().isEnabled() || prodTable.BOMId))
        {
            ret = ProdBOM::findOprNum(prodTable.ProdId, this.OprNum).RecId;
        }
            
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workerHasPermissionToAttachments</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates if the the <c>JmgJobDocuRef</c> record has attachments and worker has permissions to those.
    /// </summary>
    /// <param name = "_workerId">
    ///     The workerId for which the validation is needed.
    /// </param>
    /// <returns>
    ///     True if the <c>JmgJobDocuRef</c> record has attachments, otherwise false.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal boolean workerHasPermissionToAttachments(JmgWorkerRecId _workerId)
    {
        JmgJobDocuRef          jmgJobDocuRef;
        DocuRef                docuRef;
        JmgDocumentGroupType   docType;
        JmgDocumentGroupMember docMember;

        select firstonly RecId from jmgJobDocuRef
            where jmgJobDocuRef.JobId == this.JobId
        exists join docuRef
            where jmgJobDocuRef.dataAreaId  == docuRef.RefCompanyId
               && jmgJobDocuRef.RefTableId  == docuRef.RefTableId
               && jmgJobDocuRef.RefRecId    == docuRef.RefRecId
        exists join DocumentGroup, DocuType from docType
            where docType.DocuType == docuRef.TypeId
        exists join docMember
            where docMember.DocumentGroup == docType.DocumentGroup
               && docMember.Worker        == _workerId;

        return jmgJobDocuRef.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>quantityRequestedLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a string representing the requested quantity of the job
    /// </summary>
    /// <param name = "_job">The job for which requested quantity is required</param>
    /// <returns>String representation of the requested quantity</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str quantityRequestedLabel(JmgJobTable _job)
    {
        ProdTable prodTable = ProdTable::find(_job.ModuleRefId);
        return strFmt("@SCM:JmgJobTableCalcQtyProdTableInventUnitId", _job.CalcQty, prodTable.inventUnitId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>quantityStartedLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a string representing the started quantity of the job
    /// </summary>
    /// <param name = "_job">The job for which started quantity is required</param>
    /// <returns>String representation of the started quantity</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str quantityStartedLabel(JmgJobTable _job)
    {
        return strFmt("@SCM:JmgJobTableStartedQuantityCalcQty", _job.startedQuantity());
    }

]]></Source>
			</Method>
			<Method>
				<Name>quantityProducedLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a string representing the good quantity produced by the job
    /// </summary>
    /// <param name = "_job">The job for which good quantity is required</param>
    /// <returns>String representation of the good quantity</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str quantityProducedLabel(JmgJobTable _job)
    {
        return strFmt("@SCM:JmgJobTableGoodQuantityCalcQty", _job.goodQuantity());
    }

]]></Source>
			</Method>
			<Method>
				<Name>productionIdentificationLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a string representing the production order Id of the job
    /// </summary>
    /// <param name = "_job">The job for which production order Id is required</param>
    /// <returns>String representation of the production order Id</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str productionIdentificationLabel(JmgJobTable _job)
    {
        return strFmt("@SCM:JmgJobTableModuleRefId", _job.ModuleRefId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>productIdentificationLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the product name of the production order this job is part of
    /// </summary>
    /// <returns>ItemName referenced by the job</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display ItemNameDisplay productIdentificationLabel()
    {
        return InventTable::find(this.ItemId).itemName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>operationIdentificationLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a string representing the operation the job belongs to
    /// </summary>
    /// <param name = "_job">The job for which the operation information is required</param>
    /// <returns>String representation of the operation the job belongs to</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str operationIdentificationLabel(JmgJobTable _job)
    {
        str operationPriority = _job.isPrimaryOperation() ? "@SYS80168" : "@SYS38515";
        return strFmt("@SCM:JmgJobTableOprNumOprActId", operationPriority, _job.OprNum, _job.OprActId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>productVariantNameLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a string representing the item variant that the job is producing
    /// </summary>
    /// <param name = "_job">The job for which the item variant information is required</param>
    /// <returns>String representation of the operation the job belongs to</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str productVariantNameLabel(JmgJobTable _job)
    {
        ProdTable prodTable = ProdTable::find(_job.ModuleRefId);
        EcoResDistinctProductVariant productVariant = EcoResDistinctProductVariant::find(InventDimCombination::findByInventDim(prodTable.ItemId, prodTable.inventDim()).DistinctProductVariant);
        return strFmt("@SCM:ProdTableItemIdEcoResDistinctProductVariant", this.productIdentificationLabel(), EcoResDistinctProductVariant::productDescriptionBasedOnDimValues(productVariant));
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentOperationStatusLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the status of the job
    /// </summary>
    /// <param name = "_job">The job for which the status information is required</param>
    /// <returns>Status of the job</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str currentOperationStatusLabel(JmgJobTable _job)
    {
        DictEnum dictEnum = new DictEnum(enumNum(JmgJobStatus));
        return dictEnum.index2Label(_job.jobStatus());
    }

]]></Source>
			</Method>
			<Method>
				<Name>prevOperationStatusLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the status of the previous operation
    /// </summary>
    /// <param name = "_job">The job for which the status information of previous operation is required</param>
    /// <returns>Status of the previous operation</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str prevOperationStatusLabel(JmgJobTable _job)
    {
        DictEnum dictEnum = new DictEnum(enumNum(JmgJobStatus));
        return strFmt("@SCM:PreviousJobStatusJmgJobTablePrevOperationQtyGood", dictEnum.index2Label(_job.prevJobStatus()), _job.prevOperationQtyGood());
    }

]]></Source>
			</Method>
			<Method>
				<Name>workersRunningJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the worker(s) working on the job
    /// </summary>
    /// <param name = "_job">The job for which the worker information is required</param>
    /// <returns>Comma-separated list of names of worker(s) working on the job</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str workersRunningJob(JmgJobTable _job)
    {
        return strFmt("@SCM:JmgWorkersInProgress",  _job.emplWorkingByName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>startedDateTimeLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a string representing the date and time of the earliest stamping made on the job
    /// </summary>
    /// <param name = "_job">The job for which the date and time information is required</param>
    /// <returns>String representing the date and time of the job</returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display str startedDateTimeLabel(JmgJobTable _job)
    {
        return strFmt("@SCM:JobStartedDateTimeLabel",  _job.fromDateTime());
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduledFromDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the scheduled start date and time of the job as a single value
    /// </summary>
    /// <param name = "_job">The job for which the scheduled start date and time information is required</param>
    /// <returns>Scheduled start date and time of the job</returns>
    /// <remarks>
    /// The user time zone offset is removed from datetime returned, to compensate for the offset added during display
    /// </remarks>
    [SysClientCacheDataMethodAttribute(true)]
    public display JmgDateTime scheduledFromDateTime(JmgJobTable _job)
    {
        return DateTimeUtil::newDateTime(_job.FromDate, _job.FromTime, DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduledToDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the scheduled end date and time of the job as a single value
    /// </summary>
    /// <param name = "_job">The job for which the scheduled end date and time information is required</param>
    /// <returns>Scheduled end date and time of the job</returns>
    /// <remarks>
    /// The user time zone offset is removed from datetime returned, to compensate for the offset added during display
    /// </remarks>
    [SysClientCacheDataMethodAttribute(true)]
    public display JmgDateTime scheduledToDateTime(JmgJobTable _job)
    {
        return DateTimeUtil::newDateTime(_job.ToDate, _job.ToTime, DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>toDateTimeString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the To date and time for selected job.
    /// </summary>
    /// <param name = "_job">The job for which information is required.</param>
    /// <returns>
    /// String conversion of To Date time in user preferred format.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display str toDateTimeString(JmgJobTable _job)
    {
        return strUpr(strFmt("@SYS82282", DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::newDateTime(_job.ToDate, _job.ToTime), DateTimeUtil::getUserPreferredTimeZone())));
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromDateTimeString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the From date and time for selected job.
    /// </summary>
    /// <param name = "_job">The job for which information is required.</param>
    /// <returns>
    /// String conversion of From Date time in user preferred format.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display str fromDateTimeString(JmgJobTable _job)
    {
        return strUpr(strFmt("@SYS82282", DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::newDateTime(_job.FromDate, _job.FromTime), DateTimeUtil::getUserPreferredTimeZone())));
    }

]]></Source>
			</Method>
			<Method>
				<Name>productInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the information on product for the selected job.
    /// </summary>
    /// <param name = "_job">The job for which information is required.</param>
    /// <returns>
    /// Product Number and product name separated with hyphen.
    /// It also includes variant information if any for both number and name.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display str productInformation(JmgJobTable _job)
    {
        ProdTable prodTable = ProdTable::find(_job.ModuleRefId);
        return strFmt("@SCM:TwoLinesText", prodTable.productNumber(), this.productIdentificationLabel());
    }

]]></Source>
			</Method>
			<Method>
				<Name>productInformationOneLine</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(true)]
    internal display str productInformationOneLine(JmgJobTable _job)
    {
        ProdTable prodTable = ProdTable::find(_job.ModuleRefId);
        return strFmt("@SYS76498", prodTable.productNumber(), this.productIdentificationLabel());
    }

]]></Source>
			</Method>
			<Method>
				<Name>projectNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the information on project Id for the selected job.
    /// </summary>
    /// <param name = "_jmgJobTable">The job for which information is required.</param>
    /// <returns>
    /// The Project Id of the production order.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display ProjId projectNumber(JmgJobTable _jmgJobTable)
    {
        ProdTable prodTable = ProdTable::find(_jmgJobTable.ModuleRefId);
        return prodTable.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>previousOperationInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the information on previous operation which was before selected job.
    /// </summary>
    /// <param name = "_job">The job for which information is required.</param>
    /// <returns>
    /// Operation Name concatenated with the quantity produced and status.
    /// Example: Assembly, 10.00 Produced, Completed
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display str previousOperationInformation(JmgJobTable _job)
    {
        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            ProdRoute       previousOperation;
            previousOperation.recordLevelSecurity(true);

            select firstonly previousOperation
            where previousOperation.ProdId      == this.ModuleRefId     &&
                  previousOperation.OprNumNext  == this.OprNum          &&
                  previousOperation.OprPriority == this.Priority;

            JmgQtyGood goodQuantity = 0;

            if (previousOperation)
            {
                if (PdsCatchWeight::cwUnitId(_job.ItemId))
                {
                    goodQuantity = previousOperation.pdsCWQtyGood();
                }
                else
                {
                    goodQuantity = JmgJobStatusFactory::buildJmgJobStatusInstance().calculateGoodQtyPerProdRoute(previousOperation);
                }
            }
            JmgJobStatus jobStatus = _job.prevJobStatus();
            DictEnum dictEnum = new DictEnum(enumNum(JmgJobStatus));

            if (goodQuantity || JmgJobStatus::NotAvailable != jobStatus)
            {
                return strFmt("@SCM:JmgJobTablePreviousOperationInformationFormat", previousOperation.OprId, goodQuantity, dictEnum.index2Label(jobStatus));
            }
        }

        return "@SYS80253";
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeWorkersInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the names of the employees that are currently working on the selected job.
    /// </summary>
    /// <returns>
    /// First employee name concatenated with the number of other employees also working on this job.
    /// Example: Jane Doe (+3)
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display str activeWorkersInformation()
    {
        DirPartyTable           party;
        JmgTermReg              jmgTermReg;
        HcmWorker               hcmWorker;
        str                     tmpStr;

        jmgTermReg.recordLevelSecurity(true);

        int numberOfActiveWorkers = 0;
        if (this)
        {
            while select Name from party
            exists join hcmWorker
                where hcmWorker.Person==party.RecId
            exists join JobActive, JobId, Worker from jmgTermReg
                where jmgTermReg.JobActive          == NoYes::Yes  &&
                      jmgTermReg.JobId              == this.JobId  &&
                      hcmWorker.RecId               == jmgTermReg.Worker
            {
                if (!numberOfActiveWorkers)
                {
                    tmpStr  = party.Name;
                }
                numberOfActiveWorkers++;
            }
        }
        return numberOfActiveWorkers > 1 ? strFmt("@SCM:JmgJobTableActiveWorkersInformationFormat", tmpStr, numberOfActiveWorkers - 1) : tmpStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resource for the selected job.
    /// </summary>
    /// <returns>
    /// Resource id and resource name concatenated with a hyphen.
    /// Example: 1234 - John Doe
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display str resourceInformation()
    {
        return strFmt("@SYS53184", this.WrkCtrId, WrkCtrTable::find(this.WrkCtrId).Name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProgressPercentage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the percentage of the progress made on the job.
    /// </summary>
    /// <returns>
    /// Rounded integer value.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display int getProgressPercentage()
    {
        int percentage = 0;

        if (this.isProductionType() && this.canHaveStartQuantity())
        {
            if (JmgIncreaseRemainQtyWithErrorQtyFlight::instance().isEnabled())
            {
                ProdTable prodTable = ProdTable::find(this.ModuleRefId);
                boolean isCWItem = PdsGlobal::pdsIsCWItem(this.ItemId);
                if (!prodTable.prodParametersDim().IncreaseRemainQtyWithErrorQty)
                {
                    if (isCWItem)
                    {
                        percentage = decRound((this.pdsCWGoodQuantity() + this.pdsCWBadQuantity()) * 100 / max(this.PdsCWCalcQty, this.pdsCWStartedQuantity(), 1), 0);
                    }
                    else
                    {
                        percentage = decRound((this.goodQuantity() + this.badQuantity()) * 100 / max(this.CalcQty, this.startedQuantity(), 1), 0);
                    }
                }
                else
                {
                    if (isCWItem)
                    {
                        percentage = decRound((this.pdsCWGoodQuantity()) * 100 / max(this.PdsCWCalcQty, this.pdsCWStartedQuantity(), 1), 0);
                    }
                    else
                    {
                        percentage = decRound((this.goodQuantity()) * 100 / max(this.CalcQty, this.startedQuantity(), 1), 0);
                    }
                }
            }
            else
            {
                if (PdsGlobal::pdsIsCWItem(this.ItemId))
                {
                    percentage = decRound((this.pdsCWGoodQuantity() + this.pdsCWBadQuantity()) * 100 / max(this.PdsCWCalcQty, this.pdsCWStartedQuantity(), 1), 0);
                }
                else
                {
                    percentage = decRound((this.goodQuantity() + this.badQuantity()) * 100 / max(this.CalcQty, this.startedQuantity(), 1), 0);
                }
            }

            return max(0, min(percentage, 100));
        }

        return percentage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainingPositiveQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the remaining quantity of the production job or zero if the value is negative.
    /// </summary>
    /// <returns>
    /// The remaining quantity of the job.
    /// </returns>
    /// <remarks>
    /// The scrap quantity on the jobs is included in the calculation of the remaining quantity for the order.
    /// In case if the scrap quantity shouldn't be included, use the <c>remainingQuantity</c> method.
    /// </remarks>
    [SysClientCacheDataMethodAttribute(true)]
    public display JmgQtyRemaining remainingPositiveQty()
    {
        if (this.canHaveStartQuantity())
        {
            JmgQtyRemaining remainingQuantity = max(this.CalcQty, this.startedQuantity(), 1) - this.goodQuantity();

            if (JmgIncreaseRemainQtyWithErrorQtyFlight::instance().isEnabled())
            {
                ProdTable prodTable = ProdTable::find(this.ModuleRefId);
                if (!prodTable.prodParametersDim().IncreaseRemainQtyWithErrorQty)
                {
                    remainingQuantity = remainingQuantity - this.errorQtyAtAndBeforeOpr();
                }
            }
            else
            {
                remainingQuantity = remainingQuantity - this.errorQtyAtAndBeforeOpr();
            }

            return max(0, remainingQuantity);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWRemainingPositiveQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the remaining catch weight quantity of the production job or zero if the value is negative.
    /// </summary>
    /// <returns>
    /// The remaining catch weight quantity of the job.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display PdsCWRemainQty pdsCWRemainingPositiveQty()
    {
        if (this.canHaveStartQuantity() && PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            PdsCWRemainQty remainingQuantity = max(this.PdsCWCalcQty, this.pdsCWStartedQuantity(), 1) - this.pdsCWGoodQuantity() - this.pdsCWErrorQtyAtAndBeforeOpr();
            return max(0, remainingQuantity);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the unit for the item.
    /// </summary>
    /// <returns>
    /// The unit for the item.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display UnitOfMeasureSymbol unitId()
    {
        return InventTableModule::find(this.ItemId, ModuleInventPurchSales::Invent).UnitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWUnitId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight unit for the item.
    /// </summary>
    /// <returns>
    /// The catch weight unit for the item.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true), Hookable(false)]
    internal display PdsCWUnitId pdsCWUnitId()
    {
        return PdsCatchWeight::cwUnitId(this.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>highPriorityImage</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(true)]
    public display container highPriorityImage(JmgJobTable _jmgJobTable)
    {
        if (_jmgJobTable.Locked)
        {
           ImageReference imgRef = ImageReference::constructForSymbol(ImageReferenceSymbol::HighPriority, "@SYS309670");
           return imgRef.pack();
        }

        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpModuleRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the right form according to type and moduleRefId fields.
    /// </summary>
    /// <param name = "_buffer">
    /// The JmgJobTable buffer.
    /// </param>
    [Hookable(false)]
    internal static void jumpModuleRef(JmgJobTable _buffer)
    {        
        if (_buffer.isProductionType())
        {
            if (JmgProdParameters::find().StampLevel == JmgStampLevel::Job)
            {
                ProdRouteJob prodRouteJob = ProdRouteJob::findJobId(_buffer.JobId);
                _buffer.openForm(menuitemdisplaystr(ProdRouteJob), prodRouteJob, MenuItemType::Display);
            }
            else
            {
                ProdTable prodTable = ProdTable::find(_buffer.ModuleRefId);
                _buffer.openForm(menuitemdisplaystr(ProdTableDetails), prodTable, MenuItemType::Display, prodTable.ProdId);
                }
        }
        else
        {
            ProjTable projTable;

            switch(_buffer.Type)
            {
                case JmgJobTableType::HRMAbsenceCode:
                    HRMAbsenceCode absenceCode = HRMAbsenceCode::findByJobId(_buffer.JobId);
                    _buffer.openForm(menuitemdisplaystr(HRMAbsenceCode), absenceCode, MenuItemType::Display);
                    return;
                case JmgJobTableType::HRMAbsenceCodeGroup:
                    HRMAbsenceCodeGroup absenceCodeGroup = HRMAbsenceCodeGroup::find(_buffer.ModuleRefId);
                    _buffer.openForm(menuitemdisplaystr(HRMAbsenceCodeGroup), absenceCodeGroup, MenuItemType::Display);
                    return;
                case JmgJobTableType::ProjActivity:
                    ProjActivity projActivity = ProjActivity::findJobId(_buffer.JobId);
                    projTable = HierarchyTreeTable_Extension::findAssociation(smmActivities::find(projActivity.ActivityNumber), tablenum(ProjTable));
                    if (!projTable)
                    {
                        projTable = ProjTable::find(_buffer.ModuleRefId);
                    }
                    _buffer.openForm(menuitemdisplaystr(ProjTable), projTable, MenuItemType::Display);
                    return;
                case JmgJobTableType::ProjBudget:
                    ProjForecastEmpl projForecastEmpl = ProjForecastEmpl::findJobId(_buffer.JobId);
                    projTable       = projForecastEmpl.projTable();
                    if (!projTable)
                    {
                        projTable = ProjTable::findJobId(_buffer.JobId);
                    }
                    _buffer.openForm(menuitemdisplaystr(ProjTable), projTable, MenuItemType::Display);
                    return;
                case JmgJobTableType::ProjProject:
                    projTable = ProjTable::find(_buffer.ModuleRefId);
                    if (!projTable)
                    {
                        projTable = ProjTable::findJobId(_buffer.JobId);
                    }
                    _buffer.openForm(menuitemdisplaystr(ProjTable), projTable, MenuItemType::Display);
                    return;
                default:
                    // sfc
                    JmgIpcActivity jmgIpcActivity = JmgIpcActivity::findJobId(_buffer.JobId);
                    _buffer.openForm(menuitemdisplaystr(JmgIpcActivity), jmgIpcActivity, MenuItemType::Display);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>openForm</Name>
				<Source><![CDATA[
    private void openForm(str _menuItem, Common _record, MenuItemType _menuItemType, str _lookupValue = '')
    {
        if (_record)
        {
            Args args = new Args();

            args.record(_record);
            args.lookupRecord(_record);
            args.lookupValue(_lookupValue);
            args.copyCallerQuery(CopyCallerQuery::No);

            MenuFunction menuFunction = new MenuFunction(_menuItem, _menuItemType);

            menuFunction.run(args);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>JmgRegistrationEmployees</ConfigurationKey>
	<DeveloperDocumentation>@SYS317259</DeveloperDocumentation>
	<FormRef>JmgJobTableModuleRef</FormRef>
	<Label>@SYS39787</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>JobId</TitleField1>
	<TitleField2>Description</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>JobIdIndex</ClusteredIndex>
	<CreateRecIdIndex>No</CreateRecIdIndex>
	<Modules>ProductionControl</Modules>
	<PrimaryIndex>JobIdIndex</PrimaryIndex>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JobId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Type</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ModuleRefId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OprActId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FromDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FromTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ToTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ToDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReportedFinished</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Employee</Name>
			<Label>@SYS80745</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Worker</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JobId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Type</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Description</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>MES</Name>
			<Label>@SYS190628</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OriginalResource</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PriorityResource</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Locked</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Production</Name>
			<Label>@SYS4398</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OprNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Priority</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CalcQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWCalcQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reference</Name>
			<Label>@SYS15217</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ModuleRefId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OprActId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReportedFinished</Name>
			<Label>@SYS9576</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReportedFinished</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ResourceJobsInfo</Name>
			<Label>@SYS101237</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OprNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>fromDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>toDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>previousOperation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>prevOperationQtyGood</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TimeInterval</Name>
			<Label>@SYS81421</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FromDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FromTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ToDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ToTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WrkCtr</Name>
			<Label>@SYS10597</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventSiteId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WrkCtrId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ResourceGroup</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CalcQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RouteOprQtyToOpr</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Description</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgDescription</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>FromDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgDate</ExtendedDataType>
			<Label>@SYS24050</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldTime">
			<Name>FromTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgTime</ExtendedDataType>
			<HelpText>@SCM:FromTimeJmgJobTableHelpText</HelpText>
			<Label>@SYS69946</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventSiteId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventSiteId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>JobId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgJobId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Locked</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgJobLocked</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ModuleRefId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgModuleRefId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OprActId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgOprActId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>OprNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>OprNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OriginalResource</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>WrkCtrId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PdsCWCalcQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsCWCalcQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Priority</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>RouteOprPriority</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>PriorityResource</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgJobPriority</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReportedFinished</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS9576</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ResourceGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ToDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgDate</ExtendedDataType>
			<Label>@SYS35904</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldTime">
			<Name>ToTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>JmgTime</ExtendedDataType>
			<HelpText>@SCM:ToTimeJmgJobTableHelpText</HelpText>
			<Label>@SYS38490</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Type</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>JmgJobTableType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Worker</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>JmgWorkerRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WrkCtrId</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>WrkCtrIdBase</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>HcmWorkerIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>Worker</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>JobIdIndex</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>JobId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>WrkCtrIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>WrkCtrId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ModuleRefIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ModuleRefId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ReportedFinishedFromDateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>ReportedFinished</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>FromDate</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>HcmWorker</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>HcmWorker_JmgJobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Worker</Name>
					<Field>Worker</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>HRMAbsenceCodeGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HRMAbsenceCodeGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>AbsenceGroup</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>hrmAbsenceCodeGroupId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::HRMAbsenceCode</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventSite</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventSite</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventSiteId</Name>
					<Field>InventSiteId</Field>
					<RelatedField>SiteId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>SiteIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ItemIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>JmgJobTable</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>JmgJobTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Link</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>JmgIpcCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>JmgIpcCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>IndirectActivity</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>Category</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>JmgTermReg_Active</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>JmgTermReg</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ActiveJobs</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>JobActive_Extern</Name>
					<RelatedField>JobActive</RelatedField>
					<Value>1</Value>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>OriginalResourceWrkCtrTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WrkCtrTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OriginalResourceWrkCtrTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JmgJobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OriginalResource</Name>
					<Field>OriginalResource</Field>
					<RelatedField>WrkCtrId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>IsIndividualResource_Extern</Name>
					<RelatedField>IsIndividualResource</RelatedField>
					<Value>1</Value>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>WrkCtrIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdRoute_process</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>ProdRoute</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>ProcessProdRoute</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdProcess</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobIdProcess</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdRoute_setup</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>ProdRoute</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>SetupProdRoute</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdSetup</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobIdSetup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdRouteJob</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>ProdRouteJob</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>ProdRouteJobQueueBefore</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdQueueBefore</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdRouteJob_Overlap</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>ProdRouteJob</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>ProdRouteJobOverlap</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdOverlap</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdRouteJob_Process</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>ProdRouteJob</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>ProdRouteJobProcess</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdProcess</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdRouteJob_QueueAfter</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>ProdRouteJob</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>ProdRouteJobQueueAfter</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdQueueAfter</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdRouteJob_Setup</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>ProdRouteJob</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>ProdRouteJobSetup</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdSetup</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdRouteJob_Transport</Name>
			<Cardinality>ExactlyOne</Cardinality>
			<RelatedTable>ProdRouteJob</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>ProdRouteJobTransport</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdTransport</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JobId</Name>
					<Field>JobId</Field>
					<RelatedField>JobId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProductionJob</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTable_Overlap</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProductionOverlap</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdOverlap</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTable_process</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProductionProcess</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdProcess</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTable_QueueAfter</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProductionQueueAfter</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdQueueAfter</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTable_queueBefore</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProductionQueueBefore</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdQueueBefore</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTable_setup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProductionSetup</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdSetup</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTable_Transport</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProductionTransport</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProdTransport</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Projects</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProjProject</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjTable_Activity</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjectActivity</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProjActivity</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjTable_Budget</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjectBudget</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JobTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>Type</Name>
					<Field>Type</Field>
					<ValueStr>JmgJobTableType::ProjBudget</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ModuleRefId</Name>
					<Field>ModuleRefId</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ResourceGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WrkCtrResourceGroup</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ResourceGroup</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>Job</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ResourceGroup</Name>
					<Field>ResourceGroup</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>Route</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Route</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OprNum</Name>
					<Field>OprNum</Field>
					<RelatedField>OprNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WrkCtrTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WrkCtrTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WrkCtrId</Name>
					<SourceEDT>WrkCtrIdBase</SourceEDT>
					<Field>WrkCtrId</Field>
					<RelatedField>WrkCtrId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>WrkCtrIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>