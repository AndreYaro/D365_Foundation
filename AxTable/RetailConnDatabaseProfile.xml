<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailConnDatabaseProfile</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;

public class RetailConnDatabaseProfile extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>buildCustomConnectionString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build a custom connection string for retail
    /// scheduler database profile given user-defined input.
    /// </summary>
    /// <param name = "_serverName">The target server name.</param>
    /// <param name = "_databaseName">The target database name.</param>
    /// <param name = "_userName">The target user who has access to this server database.</param>
    /// <param name = "_userPassword">Password for the target user.</param>
    /// <param name = "_trustServerCertificate">String specifying trustServerCertificate parameter setting. Intended values True/ False.</param>
    /// <returns>Connection string generated from the provided parameters.</returns>
    public static str buildCustomConnectionString(str _serverName, str _databaseName, str _userName, str _userPassword, str _trustServerCertificate)
    {
        #RetailCDX

        str generatedConnectionString;
        
        if ( System.String::IsNullOrWhiteSpace(_trustServerCertificate))
        {
            _trustServerCertificate = 'False';
        }

        try
        {
            // Ensure the trustServerCertificate string is a valid boolean-like string.
            System.Boolean::Parse(_trustServerCertificate);
        }
        catch
        {
            // In case trustServerCertificate fails validation we set it to false as per requirements of a production system.
            _trustServerCertificate = 'False';
        }

        if (_userName == '' && _userPassword == '' && _serverName != '' && _databaseName != '' && _trustServerCertificate != '')
        {
            // Only change the behavior of the method if userName and userPassword are empty and everything else isn't.
            generatedConnectionString = strFmt(#WindowsAuthConnectionStringPattern, _serverName, _databaseName, _trustServerCertificate);
        }
        else
        {
            generatedConnectionString = strFmt(#SqlAuthConnectionStringPattern, _serverName, _databaseName, _userName, _userPassword, _trustServerCertificate);
        }

        return generatedConnectionString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildConnectionString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build connection string for retail scheduler database profile.
    /// </summary>
    /// <param name="_schemaType">
    /// Connection channel schema type.
    /// </param>
    /// <returns>
    /// Connection string.
    /// </returns>
    public str buildConnectionString(RetailConnChannelSchemaTypeEnum _schemaType)
    {
        // IMPORTANT: when putting the patterns in a macro, the call to strfmt doe NOT work!
        // Hence these hard coded values!
        // typical example: 'Locationid=0001;Provider=SQLNCLI10;Initial Catalog=AxRetailPOS;Data Source=ServerName\Instance;Integrated Security=SSPI;Persist Security Info=false;Pooling=false;Encrypt=YES;|AX6Retail_SQL|none;'

        str result;
        str encryptValue = '';
        str pattern;
        str encrypt = 'Encrypt=YES;';

        if (this.Encrypt == NoYes::Yes)
        {
            encryptValue = encrypt;
        }

        switch (_schemaType)
        {
            case RetailConnChannelSchemaTypeEnum::AX5POS:
                pattern = 'Provider=SQLNCLI10;Initial Catalog=%2;Data Source=%1;Integrated Security=SSPI;Persist Security Info=false;Pooling=false;%3|ms|none';
                break;

            case RetailConnChannelSchemaTypeEnum::AX61POS:
            case RetailConnChannelSchemaTypeEnum::AX62POS:
            case RetailConnChannelSchemaTypeEnum::AX62OnlineChannel:
            case RetailConnChannelSchemaTypeEnum::AX63RetailServer:
            case RetailConnChannelSchemaTypeEnum::AX63:
                pattern = 'Application Name=Commerce Data Exchange Synch Service;Data Source=%1;Initial Catalog=%2;Integrated Security=SSPI;TrustServerCertificate=True;%3|AX6Retail_SQL|1';
                break;
        }

        result = strFmt(pattern, this.Server, this.Database, encryptValue);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in <c>RetailConnDatabaseProfile</c> tables.
    /// </summary>
    public void insert()
    {
        Global::handleEncryptedTablePreInsert(this);
        this.hashPassword();

        ttsbegin;

        this.setDefaultRSSUPackage();
        super();

        ttscommit;
        Global::handleEncryptedTablePostInsert(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// updates the record in <c>RetailConnDatabaseProfile</c> tables.
    /// </summary>
    /// <remarks>
    /// updates the connection details for the connection profile from the database connection profile.
    /// </remarks>
    public void update()
    {
        RetailCDXDataStoreChannel dataStoreChannel;

        Global::handleEncryptedTablePreUpdate(this);
        this.hashPassword();        

        ttsbegin;

        // When data group is assigned or changed,
        //   update channel - data store association record so that it can be captured by change tracking
        if (this.DataGroup != this.orig().DataGroup)
        {
            while select forupdate dataStoreChannel
                where dataStoreChannel.DatabaseProfile == this.RecId
            {
                dataStoreChannel.DataGroupModifiedDateTime = DateTimeUtil::utcNow();
                dataStoreChannel.update();
            }
        }

        super();

        ttscommit;
        Global::handleEncryptedTablePostUpdate(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataWritingBatchJobStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Data writing batch job status.
    /// </summary>
    /// <returns>Batch job status value.</returns>
    public display str dataWritingBatchJobStatus()
    {
        BatchJob batchJob;

        if (!this.DataWritingBatchJob)
        {
            return "@Retail:CdxBatchJobStatusNotAvailable";
        }

        select firstonly Status from batchJob where batchJob.RecId == this.DataWritingBatchJob;

        if (batchJob)
        {
            SysDictEnum dictEnum = new SysDictEnum(enumNum(BatchStatus));
            return dictEnum.index2Label(batchJob.Status);
        }
        else
        {
            return "@Retail:CdxBatchJobStatusNotAvailable";
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>connectionStringEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets connection string encrypted or decrypted value.
    /// </summary>
    /// <param name = "_set">Indicates if to set the connection string or not.</param>
    /// <param name = "_value">Connection string value.</param>
    /// <returns>Decrypted connection string.</returns>
    public edit str connectionStringEdit(boolean _set, str _value)
    {
        return Global::editEncryptedStringField(this, _value, fieldNum(RetailConnDatabaseProfile, ConnectionString), _set);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSchemaType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets schema type from data group.
    /// </summary>
    /// <returns>The schema type.</returns>
    public RetailConnChannelSchemaType getSchemaType()
    {
        RetailCDXDataGroup retailCDXDataGroup;
        RetailConnChannelSchema retailConnChannelSchema;

        select firstOnly RecId, SchemaType from retailConnChannelSchema
            exists join retailCDXDataGroup
                where retailConnChannelSchema.RecId == retailCDXDataGroup.ChannelSchema
                    && retailCDXDataGroup.RecId == this.DataGroup;

        return retailConnChannelSchema.SchemaType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFriendlyName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the database friendly name in case it is a scale unit database
    /// </summary>
    public display RetailScaleUnitName getFriendlyName()
    {
        RetailScaleUnitConfiguration    configuration;
        RetailScaleUnit                 scaleUnit;
        RetailScaleUnitName             name;

        name = this.Name;

        select scaleUnit
            exists join configuration
                where   configuration.RetailScaleUnit   == scaleUnit.RecId
                    &&  configuration.RefTableId        == tableNum(RetailConnDatabaseProfile)
                    &&  configuration.RefRecId          == this.RecId;

        if (scaleUnit)
        {
            name = scaleUnit.Name;
        }

        return name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>duplicateDRMDatabaseProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Duplicates the database profile using a dialog box.
    /// </summary>
    /// <param name="profileName">
    /// A unique name for the database profile.
    /// </param>
    /// <returns>
    /// An instance of the <c>RetailConnDatabaseProfile</c> table.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// A database profile does not exist.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The duplication process failed.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflictNotRecovered">
    /// A standard update conflict.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflict">
    /// A standard update conflict.
    /// </exception>
    public static RetailConnDatabaseProfile duplicateDRMDatabaseProfile(RetailConnProfileName profileName)
    {
        #OCCRetryCount
        RetailConnDatabaseProfile  databaseProfile;
        Counter             retryCount;
        Dialog              dialog;
        DialogField         dialogProfileName;
        ;

        dialog = new Dialog("@RET678");

        dialogProfileName = dialog.addField(extendedtypestr(RetailConnProfileName),"@RET684");

        if (profileName)
        {
            if (dialog.run())
            {
                if (RetailConnDatabaseProfile::find(dialogProfileName.value()).RecId)
                {
                    throw error(strfmt("@RET685",dialogProfileName.value()));
                }
            }
            else
            {
                return RetailConnDatabaseProfile::find(profileName);
            }

            try
            {
                ttsbegin;

                select firstonly forupdate databaseProfile
                where databaseProfile.Name == profileName;

                databaseProfile.Name = dialogProfileName.value();
                databaseProfile.insert();

                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if (retryCount <= 10)
                    retry;

                ttsabort;

                databaseProfile = RetailConnDatabaseProfile::find(profileName);
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        retry;
                    }
                }
                else
                {
                    throw Exception::UpdateConflict;
                }
            }
            catch
            {
                throw error("@RET433");
            }
        }

        return databaseProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specified record in the <c>RetailConnDatabaseProfile</c> table.
    /// </summary>
    /// <param name="_name">
    /// A name for the database profile.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>RetailConnDatabaseProfile</c> table; otherwise, an empty record.
    /// </returns>
    public static RetailConnDatabaseProfile find(RetailConnProfileName _name, boolean _forUpdate = false)
    {
        RetailConnDatabaseProfile profile;

        if (_name)
        {
            profile.selectForUpdate(_forUpdate);

            select profile
                index hint NameIdx
                where profile.Name == _name;
        }

        return profile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a specified record in the <c>RetailConnDatabaseProfile</c> table by its record Id.
    /// </summary>
    /// <param name="_recId">
    /// The record Id.GetDistinctDataGroupRecIds
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>RetailConnDatabaseProfile</c> table; otherwise, an empty record.
    /// </returns>
    public static RetailConnDatabaseProfile findByRecId(RecId _recId, boolean _forUpdate = false)
    {
        RetailConnDatabaseProfile profile;

        profile.selectForUpdate(_forUpdate);

        select profile where profile.RecId == _recId;

        return profile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>localContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a series of string value.
    /// </summary>
    /// <returns>
    /// The string value.
    /// </returns>
    private static str localContext()
    {
        return '17642993C9FE4AAE9C4098C5CEF3A7770437F2F490644E08A4682C0BF1447DDC';
    }

]]></Source>
			</Method>
			<Method>
				<Name>maskedPasswordValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the masked password.
    /// </summary>
    /// <returns>
    /// The masked password.
    /// </returns>
    private static str maskedPasswordValue()
    {
        // part of a GUID, hopefully that is no one's password!
        return '0758441cBD8C3CE1';
    }

]]></Source>
			</Method>
			<Method>
				<Name>hashPassword</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create password hash.
    /// </summary>
    private void hashPassword()
    {
        str password;
        password = this.Password;
        this.Password = RetailConnDatabaseProfile::maskedPasswordValue();

        if (this.UserName && isConfigurationkeyEnabled(configurationKeyNum(RetailCDXBackwardCompatibility)))
        {
            // only hash password when username/password are changed
            if (password != this.Password || this.UserName != this.orig().UserName)
            {
                this.DataStoreData = RetailData::HashLegacy2012(password, RetailSharedParameters::find(false).StaffPasswordHash, this.UserName, RetailConnDatabaseProfile::localContext());
            }
        }
        else
        {
            // if user name is changed to be empty, also empty the password
            this.Password = '';
            this.DataStoreData = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultRSSUPackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the default RSSU package on the current record.
    /// </summary>
    private void setDefaultRSSUPackage()
    {
        RetailSelfServiceDefaultPackages defaultPackage = RetailSelfServiceDefaultPackages::findDefaultPackage(
            tableNum(RetailSelfServiceDefaultPackages), PackageType::RetailStoreScaleUnit);

        // Assign default RSSU package only if current row is RSSU package type.
        if (defaultPackage.MergedSelfServicePackageReference && !this.MergedSelfServicePackageReference
            && RetailDeploymentUtility::isStoreSystemSupported(this))
        {
            this.MergedSelfServicePackageReference = defaultPackage.MergedSelfServicePackageReference;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDataWritingBatchStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Issues warning message when the data writing batch is in withold or cancelled state.
    /// </summary>
    internal static void checkDataWritingBatchStatus()
    {
        RetailConnDatabaseProfile dataStore;
        RetailCDXScheduleDataGroup activeScheduleDataGroup;
        RetailConnSchedule schedule;
        RetailScaleUnit scaleUnit;
        BatchJob batchJob;
        #RetailCDX;

        select firstOnly RecId from scaleUnit;

        while select Name, DataStoreType, DataGroup, ConnectionString, RecId from dataStore
           where dataStore.DataStoreType == RetailCDXDataStoreType::ChannelDatabase
           join Caption, Status from batchJob
           where batchJob.RecId == dataStore.DataWritingBatchJob &&
            (batchJob.Status == BatchStatus::Hold || batchJob.Status == BatchStatus::Canceled)
        {
            select firstOnly RecId from activeScheduleDataGroup
                where activeScheduleDataGroup.DataGroup == dataStore.DataGroup
                exists join schedule
                where schedule.RecId == activeScheduleDataGroup.Schedule &&
                schedule.Active == NoYes::Yes;

            // check data writing batch job only for active channel DBs with a connection string
            if (dataStore.ConnectionString != '' && activeScheduleDataGroup.RecId)
            {
                // if this is the "Default" database and there is a scale unit, then suppress the message
                if (dataStore.Name == #RetailConnDatabaseProfile_DefaultDBName && scaleUnit.RecId)
                {
                    continue;
                }

                warning (strFmt("@Retail:DataWritingBatchJobStatusWarning", batchJob.Caption, batchJob.RecId, dataStore.Name, enum2Str(batchJob.Status), enum2Str(BatchStatus::Waiting)));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByTerminalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the offline data store used by the specified terminal.
    /// </summary>
    /// <param name = "_terminalId">Terminal Id.</param>
    /// <param name = "_forUpdate">A Boolean value that indicates whether to read the record for update or not.</param>
    /// <returns>Data store.</returns>
    internal static RetailConnDatabaseProfile findByTerminalId(str _terminalId, boolean _forUpdate = false)
    {
        RetailTerminalTable terminal;
        RetailConnDatabaseProfile dbProfile;

        dbProfile.selectForUpdate(_forUpdate);

        select firstonly dbProfile join terminal
            where dbProfile.RecId == terminal.OfflineDatabaseProfile
            && terminal.terminalId == _terminalId;

        return dbProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBlockingDownloadSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets any download session record, for the specified datastore and job Id, that could block processing of
    /// subsequent download sessions from dependent jobs when the 'Sequential download session processing' feature is enabled.
    /// </summary>
    /// <param name = "_dataStoreRecId">The datastore record Id.</param>
    /// <param name = "_jobId">The job Id.</param>
    /// <returns>The download session record that blocks further processing of subsequent sessions from the current job or from its dependent jobs.</returns>
    internal static RetailCDXDownloadSession getBlockingDownloadSession(RefRecId _dataStoreRecId, RetailConnJobId _jobId)
    {
        RetailCDXDownloadSession downloadSession;
        RetailCDXDownloadSessionDataStore downloadSessionDataStore;

        select firstonly Session, JobID from downloadSession
            where downloadSession.JobID == _jobId
         join downloadSessionDataStore
            where downloadSessionDataStore.Session   == downloadSession.RecId
               && downloadSessionDataStore.DataStore == _dataStoreRecId
               && downloadSessionDataStore.Status    == RetailCDXDownloadSessionStatus::Suspended;

        return downloadSession;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDataStoreSynchronizationPaused</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if data synchronization to and from the current datastore is paused or not.
    /// </summary>
    /// <returns>True if data synchronization is paused; false otherwise.</returns>
    internal boolean isDataStoreSynchronizationPaused()
    {
        boolean isDataStoreSynchronizationPaused = this.PauseDataSync;

        // if not paused on datastore level check if the datastore is offline datastore
        // and if the data sync to the target is paused on offline profile level.
        if (!isDataStoreSynchronizationPaused)
        {
            isDataStoreSynchronizationPaused = this.DataStoreType == RetailCDXDataStoreType::OfflineDatabase &&  !RetailTerminalTable::shouldSynchronizeOfflineDataStore(this.Name);
        }

        return isDataStoreSynchronizationPaused;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isActivatedOrWasActivated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a device was activated or is currently activated
    /// </summary>
    /// <returns>True if the data store is activated or was activated; otherwise, false.</returns>
    internal boolean isActivatedOrWasActivated()
    {
        RetailTerminalTable retailTerminalTable;
        RetailDevice retailDevice;
        boolean isActivatedOrWasActivated = false;

        select firstonly retailDevice
            join retailTerminalTable
                where retailDevice.Terminal == retailTerminalTable.terminalId
                && retailTerminalTable.OfflineDatabaseProfile == this.RecId;

        // If the device was Activated or if the device is Activated, treat it as Activated.
        if (retailDevice && (retailDevice.ActivationStatus == RetailDeviceActivationStatusBase::Activated | (retailDevice.DeactivatedDateTime != DateTimeUtil::minValue())))
        {
            isActivatedOrWasActivated = true;
        }

        return isActivatedOrWasActivated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasAnyDownloadSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if there is session data available for a specific data store.
    /// </summary>
    /// <returns>True if session data is found, otherwise, false.</returns>
    internal boolean hasAnyDownloadSession()
    {
        RetailCDXDownloadSessionDataStore retailCDXDownloadSessionDataStore;
        boolean isAnyDownloadSession = false;

        select firstonly retailCDXDownloadSessionDataStore 
            where this.RecId == retailCDXDownloadSessionDataStore.DataStore;

        if (retailCDXDownloadSessionDataStore)
        {
            isAnyDownloadSession = true;
        }

        return isAnyDownloadSession;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistinctDataGroupRecIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get distinct data group RecIds based on provided list of data store names.
    /// </summary>
    /// <param name = "dataStoreNames">The list of data store names.</param>
    /// <returns>The <c>RetailTmpRecId</c> temp table buffer contains the distinct data group RecIds.</returns>
    internal static RetailTmpRecId getDistinctDataGroupRecIds(List dataStoreNames)
    {
        RetailTempName tempDataStoreNames;
        ListIterator iterator = new ListIterator(dataStoreNames);

        while (iterator.more())
        {
            tempDataStoreNames.Name = iterator.value();
            tempDataStoreNames.insert();
            
            iterator.next();
        }

        RetailTmpRecId tempDataGroupRecIds;
        RetailCDXDataGroup retailCdxDataGroup;
        RetailConnDatabaseProfile retailConnDatabaseProfile;

        while select RecId from retailCDXDataGroup
            join retailConnDatabaseProfile
            group by retailCDXDataGroup.RecId
            where retailCDXDataGroup.RecId == retailConnDatabaseProfile.DataGroup
            join tempDataStoreNames
            where retailConnDatabaseProfile.Name == tempDataStoreNames.Name
        {
            tempDataGroupRecIds.ReferenceRecId = RetailCDXDataGroup.RecId;
            tempDataGroupRecIds.insert();
        }

        return tempDataGroupRecIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUsingAxHostedCdxForUploadSessionPackageGeneration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a flag indicating if the datastore is using a CDX client which is hosted in AX to retrieve and generate upload session package from
    /// the channel database.
    /// </summary>
    /// <returns>True if the datastore is using Cdx that is hosted in AX; false otherwise.</returns>
    internal boolean isUsingAxHostedCdxForUploadSessionPackageGeneration()
    {
        // If data store connection string exists, it is the CDX hosted in AX, so we create the package generation task
        return !System.String::IsNullOrWhiteSpace(this.ConnectionString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInsideStoreHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check the store hours range is inside store hour.
    /// </summary>
    /// <param name = "databaseProfileRecId">Get RecId from RefRecId.</param>
    /// <param name = "_currentUtcDateTime">Get the current UTC date/time.</param>
    /// <returns>True if the given UTC date and time is within Store hours range; otherwise, false.</returns>
    internal static boolean isInsideStoreHours(RefRecId databaseProfileRecId, utcdatetime _currentUtcDateTime = DateTimeUtil::getSystemDateTime())
    {
        RetailStoreHoursTemplate   retailStoreHoursTemplate;
        RetailStoreHoursRange      retailStoreHoursRange;
        RetailStoreHoursChannel    retailStoreHoursChannel;
        RetailStoreTable           retailStoreTable;
        RetailCDXDataStoreChannel  retailCDXDataStoreChannel;
        boolean                    insideStoreHours;

        while select crosscompany retailStoreHoursRange
            join retailStoreHoursTemplate
                where  retailStoreHoursTemplate.Id == retailStoreHoursRange.StoreHoursTemplateId
                    && retailStoreHoursTemplate.DataAreaId == retailStoreHoursRange.DataAreaId
            join OMInternalOrganizationId from retailStoreHoursChannel
                where retailStoreHoursChannel.StoreHoursTemplateId == retailStoreHoursTemplate.Id
                    && retailStoreHoursChannel.DataAreaId == retailStoreHoursTemplate.DataAreaId
            join ChannelTimeZone from retailStoreTable
                where retailStoreTable.OMOperatingUnitID == retailStoreHoursChannel.OMInternalOrganizationId
            join retailCDXDataStoreChannel
                where retailCDXDataStoreChannel.Channel == retailStoreTable.RecId
                    && retailCDXDataStoreChannel.DatabaseProfile == databaseProfileRecId
        {
            // Verify if the local date/time is within any of the store hours range
            boolean isStoreOpen = RetailStoreHoursRange::isInsideStoreHourRange(_currentUtcDateTime, retailStoreHoursRange, retailStoreTable.ChannelTimeZone);

            if (isStoreOpen)
            {
                insideStoreHours = true;
                break;
            }
        }

        return insideStoreHours;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>Retail</ConfigurationKey>
	<DeveloperDocumentation>@RET260593</DeveloperDocumentation>
	<FormRef>RetailCDXDataStore</FormRef>
	<Label>@RET606</Label>
	<TableGroup>Main</TableGroup>
	<TitleField1>Server</TitleField1>
	<TitleField2>Name</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<ClusteredIndex>RecId</ClusteredIndex>
	<CreatedDateTime>Yes</CreatedDateTime>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>ChannelManagement</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<ReplacementKey>NameIdx</ReplacementKey>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>DeleteAction1</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>RetailConnDatabaseProfile</Relation>
			<Table>RetailCDXDataStoreHeartbeatLog</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Server</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@RET607</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Encrypt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UserName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Password</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Version</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Database</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Server</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Name</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StoreConnectRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SchedulerInterval</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DataStoreData</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ConnectionString</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DataWritingBatchJob</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CDXSetting</Name>
			<Label>@REX1287</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DataGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Password</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Environment</Name>
			<Label>@RET4160324</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReplicateToAX</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReplicateFromAX</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>General</Name>
			<Fields />
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Database</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailConnProfileDatabaseName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DataGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailCDXDataGroupRefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DataStoreData</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailCDXDataStoreData</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Encrypt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailConnProfileEncrypt</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Name</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailConnProfileName</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Password</Name>
			<AssetClassification>Access Control Data</AssetClassification>
			<ExtendedDataType>Password</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Provisioned</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReplicateFromAX</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReplicateFromAX</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReplicateToAX</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReplicateToAX</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SchedulerInterval</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Server</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailConnProfileServer</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>StoreConnectRecId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>UserName</Name>
			<AssetClassification>End User Identifiable Information (EUII)</AssetClassification>
			<ExtendedDataType>RetailCDXDataStoreUserName</ExtendedDataType>
			<Label>@Retail:Username</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Version</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RetailConnProfileDatabaseVersion</ExtendedDataType>
			<EnumType>RetailConnProfileDatabaseVersionEnum</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ConnectionString</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EncryptedString</ExtendedDataType>
			<Label>@RET92</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DataStoreType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>RetailCDXDataStoreType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DataWritingBatchJob</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS114515</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SelfServicePackage</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@Retail:RetailStoreScaleUnitLabel</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrentVersion</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrentVersion</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>StoreSystemSyncStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<StringSize>50</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>MergedSelfServicePackageReference</Name>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@RetailSelfServiceInstaller:MergedPackageReference</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PauseDataSync</Name>
			<ExtendedDataType>RetailCDXPauseDataStoreSync</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AllowUploadDuringSyncPause</Name>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@Retail:CDXAllowUploadsDuringPause</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>NameIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>Name</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>StoreConnectIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>StoreConnectRecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ModifiedDateTimeIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>modifiedDateTime</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation>
			<Name>RetailCDXDataGroup</Name>
			<Cardinality>ZeroOne</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>RetailCDXDataGroup</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Composition</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DataGroup</Name>
					<Field>DataGroup</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>RetailCDXSchedulerInterval</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>RetailCDXSchedulerInterval</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SchedulerInterval</Name>
					<Field>SchedulerInterval</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>StoreConnectRelation</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RetailConnStoreConnectProfile</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>StoreConnectRecId</Name>
					<Field>StoreConnectRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>RetailTerminalTable</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>RetailTerminalTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>OfflineDatabaseProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BatchJob</Name>
			<RelatedTable>BatchJob</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DataWritingBatchJob</Name>
					<Field>DataWritingBatchJob</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SelfServicePackageInfo</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RetailSelfServicePackageInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SelfServicePackage</Name>
					<Field>SelfServicePackage</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>RetailSelfServiceMergedPackages</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RetailSelfServiceMergedPackages</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MergedSelfServicePackageReference</Name>
					<Field>MergedSelfServicePackageReference</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>