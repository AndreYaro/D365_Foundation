<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventQualityOrderTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class InventQualityOrderTable extends common
{   
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowQuarantineUponFailure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value indicating whether it is allowed to quarantine goods upon failure of the quality order.
    /// </summary>
    /// <returns>
    /// true if it is allowed to quarantine goods upon failure; otherwise, false.
    /// </returns>
    public boolean allowQuarantineUponFailure()
    {
        return !WHSInventEnabled::exist(this.ItemId) || !this.inventDim().inventLocation().whsEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowUpdateInventoryStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value indicating whether inventory status update is allowed upon validation of the quality order.
    /// </summary>
    /// <returns>
    /// true if inventory status update is allowed; otherwise, false.
    /// </returns>
    public boolean allowUpdateInventoryStatus()
    {
        return WHSInventEnabled::exist(this.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchDispositionCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the batch disposition code for the batch associated with this quality order.
    /// </summary>
    /// <returns>
    ///    The batch disposition code.
    /// </returns>
    display public PdsDispositionCode batchDispositionCode()
    {
        return this.inventBatch().PdsDispositionCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the quantity that is specified is valid.
    /// </summary>
    /// <param name="_inventDimId">
    /// The set of inventory dimensions to validate for inventory quality orders.
    /// </param>
    /// <returns>
    /// true if the quantity is valid; otherwise, false.
    /// </returns>
    [SysObsolete('Use the InventQualityOrderTableValidator class instead', false, 31\01\2016)]
    public boolean checkQty(InventDimId _inventDimId)
    {
        InventQualityOrderTableValidator validator = InventQualityOrderTableValidator::newFromQualityOrderTable(this);
        return validator.checkQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearReferenceFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears all reference fields.
    /// </summary>
    public void clearReferenceFields()
    {
        this.InventRefId = '';
        this.InventRefTransId = '';
        this.OprNum = 0;
        this.RouteOprId = '';
        this.WrkCtrId = '';
        this.RouteId = '';
        this.ItemId = '';
        this.ItemName = '';
        this.AccountRelation = '';
        this.Qty = 0;
        this.PdsCWQty = 0;
        this.InventDimId = InventDim::inventDimIdBlank();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveQualityOrderAtStatusLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves the quality order at the inventory status level.
    /// </summary>
    [Hookable(false)]
    internal void reserveQualityOrderAtStatusLevel()
    {
        ttsbegin;

        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        
        Debug::assert(this.InventTransId != '');
        
        while select forUpdate inventTrans
            exists join inventTransOrigin
            where inventTransOrigin.RecId           == inventTrans.InventTransOrigin
                && inventTransOrigin.InventTransId  == this.InventTransId
        {
            InventDim inventDim = inventTrans.inventDim();
            inventDim.clearLocationAndBelowDim(inventTrans.ItemId);
            inventDim = InventDim::findOrCreate(inventDim);
            
            inventTrans.inventDimId = inventDim.inventDimId;
            
            inventTrans.update();
            
            // Need to reserve this physically if it hasn't been yet or couldn't be before.
            if (inventTrans.StatusIssue > StatusIssue::ReservPhysical)
            {
                WHSInvent::reserveInventory(this, inventDim.inventDimId, inventTrans.Qty);
            }
        }
        
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>CompanyInfo</c> record associated with the current record.
    /// </summary>
    /// <returns>
    /// The <c>CompanyInfo</c> record.
    /// </returns>
    public CompanyInfo companyInfo()
    {
        return CompanyInfo::findDataArea(this.company());
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </summary>
    /// <param name="_defaultDimension">
    /// A dimension set to apply to the <c>defaultDimension</c> field on this table.
    /// </param>
    /// <param name="_dimensionCopy">
    /// A <c>dimensionCopy</c> object that was initialized with the current buffer; optional.
    /// </param>
    /// <returns>
    /// A dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are not overwritten.
    /// </remarks>
    public DimensionDefault copyDimension(
        DimensionDefault _defaultDimension,
        DimensionCopy    _dimensionCopy = DimensionCopy::newFromTable(this,
                                                                      this.companyInfo().RecId
                                                                      )
        )
    {
        return _dimensionCopy.copy(_defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDocumentsToLinesFromTestGroupMembers</Name>
				<Source><![CDATA[
    private void copyDocumentsToLinesFromTestGroupMembers()
    {
        InventQualityOrderLine          inventQualityOrderLine;
        InventTestGroupMember           inventTestGroupMember;
        DocuRef                         docuRef;

        utcdatetime                     currentTime = DateTimeUtil::getSystemDateTime();

        // copy documents from the test group member with the same sequence number as the line (it is safe to assume
        // that sequence numbers will match when the quality order is created from a test group)
        while select inventQualityOrderLine
            join inventTestGroupMember
                where  inventTestGroupMember.TestGroupId       == this.TestGroupId
                    && inventQualityOrderLine.QualityOrderId   == this.QualityOrderId
                    && inventQualityOrderLine.TestId           == inventTestGroupMember.TestId
                    && inventQualityOrderLine.TestSequence     == inventTestGroupMember.TestSequence
                    && inventTestGroupMember.ValidFromDateTime <= currentTime
                    && inventTestGroupMember.ValidToDateTime   >  currentTime
            exists join docuRef
                where  inventTestGroupMember.RecId      == docuRef.RefRecId
                    && inventTestGroupMember.TableId    == docuRef.RefTableId
                    && inventTestGroupMember.DataAreaId == docuRef.RefCompanyId
        {
            Docu::clone(inventTestGroupMember, inventQualityOrderLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDocumentsToLinesFromTests</Name>
				<Source><![CDATA[
    private void copyDocumentsToLinesFromTests()
    {
        InventQualityOrderLine          inventQualityOrderLine;
        InventTestTable                 inventTestTable;
        DocuRef                         docuRef;

        while select inventQualityOrderLine
            where inventQualityOrderLine.QualityOrderId == this.QualityOrderId
            join inventTestTable
                where inventQualityOrderLine.TestId == inventTestTable.TestId
            exists join docuRef
                where  inventTestTable.RecId        == docuRef.RefRecId
                    && inventTestTable.TableId      == docuRef.RefTableId
                    && inventTestTable.DataAreaId   == docuRef.RefCompanyId
        {
            Docu::clone(inventTestTable, inventQualityOrderLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventQualityOrderLinesFromTestGroupMember</Name>
				<Source><![CDATA[
    [Hookable]
    protected void createInventQualityOrderLinesFromTestGroupMember(utcdatetime _currentTime)
    {
        InventQualityOrderLine          inventQualityOrderLine;
        InventTestGroupMember           inventTestGroupMember;
        InventQualityOrderId            inventQualityOrderId            = this.QualityOrderId;
        InventTestOutcomeStatus         inventTestOutcomeStatusDefault  = InventTestOutcomeStatus::Fail;
        NoYes                           includeResultsDefault           = NoYes::Yes;

        inventQualityOrderLine.skipDataMethods(true);

        using (var context = InventQualityOrderLineSkipLineResultsCreationFlight::instance().isEnabled() ? InventQualityOrderLineSkipLineResultsCreationContext::construct(): null)
        {
            insert_recordset inventQualityOrderLine
                (   QualityOrderId, TestSequence, TestId, TestResult,
                    StandardValue, LowerLimit, UpperLimit, UpperTolerance, LowerTolerance,
                    VariableId, VariableOutcomeIdStandard, CertificateOfAnalysisReport, ActionOnFailure,
                    TestInstrumentId, TestUnitId, IncludeResults, AcceptableQualityLevel,
                    PdsBatchAttribId, PdsUpdateBatchAttributes
                )
                select  inventQualityOrderId, TestSequence, TestId, inventTestOutcomeStatusDefault,
                    StandardValue, LowerLimit, UpperLimit, UpperTolerance, LowerTolerance,
                    VariableId, VariableOutcomeIdStandard, CertificateOfAnalysis, ActionOnFailure,
                    TestInstrumentId, TestUnitId, includeResultsDefault, AcceptableQualityLevel,
                    PdsBatchAttribId, PdsUpdateBatchAttributes
                from inventTestGroupMember
                    where       inventTestGroupMember.TestGroupId       == this.TestGroupId
                            &&  inventTestGroupMember.ValidFromDateTime <= _currentTime
                            &&  inventTestGroupMember.ValidToDateTime   >  _currentTime;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventQualityOrderLinesFromTestGroupMemberWithConnection</Name>
				<Source><![CDATA[
    [Hookable,SysObsolete('', false, 30\06\2020)]
    protected void createInventQualityOrderLinesFromTestGroupMemberWithConnection(utcdatetime _currentTime, UserConnection _conn = null)
    {
        InventQualityOrderLine          inventQualityOrderLine;
        InventTestGroupMember           inventTestGroupMember;
        InventQualityOrderId            inventQualityOrderId            = this.QualityOrderId;
        InventTestOutcomeStatus         inventTestOutcomeStatusDefault  = InventTestOutcomeStatus::Fail;
        NoYes                           includeResultsDefault           = NoYes::Yes;

        inventQualityOrderLine.skipDataMethods(true);
        if (_conn)
        {
            inventQualityOrderLine.setConnection(_conn);
        }

        insert_recordset inventQualityOrderLine
            (   QualityOrderId, TestSequence, TestId, TestResult,
                StandardValue, LowerLimit, UpperLimit, UpperTolerance, LowerTolerance,
                VariableId, VariableOutcomeIdStandard, CertificateOfAnalysisReport, ActionOnFailure,
                TestInstrumentId, TestUnitId, IncludeResults, AcceptableQualityLevel,
                PdsBatchAttribId, PdsUpdateBatchAttributes
            )
            select  inventQualityOrderId, TestSequence, TestId, inventTestOutcomeStatusDefault,
                StandardValue, LowerLimit, UpperLimit, UpperTolerance, LowerTolerance,
                VariableId, VariableOutcomeIdStandard, CertificateOfAnalysis, ActionOnFailure,
                TestInstrumentId, TestUnitId, includeResultsDefault, AcceptableQualityLevel,
                PdsBatchAttribId, PdsUpdateBatchAttributes
            from inventTestGroupMember
                where       inventTestGroupMember.TestGroupId       == this.TestGroupId
                        &&  inventTestGroupMember.ValidFromDateTime <= _currentTime
                        &&  inventTestGroupMember.ValidToDateTime   >  _currentTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventQualityOrderLineResultsFromTestGroupMember</Name>
				<Source><![CDATA[
    [Hookable]
    protected void createInventQualityOrderLineResultsFromTestGroupMember(utcdatetime _currentTime)
    {
        InventQualityOrderLineResults   inventQualityOrderLineResults;
        InventTestGroupMember           inventTestGroupMember;
        InventQualityOrderId            inventQualityOrderId            = this.QualityOrderId;
        InventTestOutcomeStatus         inventTestOutcomeStatusDefault  = InventTestOutcomeStatus::Fail;
        NoYes                           includeResultsDefault           = NoYes::Yes;
        LineNum                         lineNumDefault                  = 1;
        InventQty                       testResultQuantityDefault       = this.initializeTestResultQuantityDefault();
        PdsCWInventQty                  pdsCWTestResultQuantityDefault  = this.initializePdsCWTestResultQuantityDefault();

        inventQualityOrderLineResults.skipDataMethods(true);

        insert_recordset inventQualityOrderLineResults
            (   QualityOrderId, TestSequence, TestId, TestResult,
                TestResultValueOutcome, IncludeResults, TestResultQuantity, LineNum, PdsCWTestResultQuantity
            )
            select  inventQualityOrderId, TestSequence, TestId, inventTestOutcomeStatusDefault,
                    VariableOutcomeIdStandard, includeResultsDefault, testResultQuantityDefault, lineNumDefault, pdsCWTestResultQuantityDefault
            from inventTestGroupMember
                    where       inventTestGroupMember.TestGroupId       == this.TestGroupId
                            &&  inventTestGroupMember.ValidFromDateTime <= _currentTime
                            &&  inventTestGroupMember.ValidToDateTime   >  _currentTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventQualityOrderLineResultsFromTestGroupMemberWithConnection</Name>
				<Source><![CDATA[
    [Hookable,SysObsolete('', false, 30\06\2020)]
    protected void createInventQualityOrderLineResultsFromTestGroupMemberWithConnection(utcdatetime _currentTime, UserConnection _conn = null)
    {
        InventQualityOrderLineResults   inventQualityOrderLineResults;
        InventTestGroupMember           inventTestGroupMember;
        InventQualityOrderId            inventQualityOrderId            = this.QualityOrderId;
        InventTestOutcomeStatus         inventTestOutcomeStatusDefault  = InventTestOutcomeStatus::Fail;
        NoYes                           includeResultsDefault           = NoYes::Yes;
        LineNum                         lineNumDefault                  = 1;
        InventQty                       testResultQuantityDefault       = this.initializeTestResultQuantityDefault();
        PdsCWInventQty                  pdsCWTestResultQuantityDefault  = this.initializePdsCWTestResultQuantityDefault();

        inventQualityOrderLineResults.skipDataMethods(true);
        if (_conn)
        {
            inventQualityOrderLineResults.setConnection(_conn);
        }

        insert_recordset inventQualityOrderLineResults
            (   QualityOrderId, TestSequence, TestId, TestResult,
                TestResultValueOutcome, IncludeResults, TestResultQuantity, LineNum, PdsCWTestResultQuantity
            )
            select  inventQualityOrderId, TestSequence, TestId, inventTestOutcomeStatusDefault,
                    VariableOutcomeIdStandard, includeResultsDefault, testResultQuantityDefault, lineNumDefault, pdsCWTestResultQuantityDefault
            from inventTestGroupMember
                    where       inventTestGroupMember.TestGroupId       == this.TestGroupId
                            &&  inventTestGroupMember.ValidFromDateTime <= _currentTime
                            &&  inventTestGroupMember.ValidToDateTime   >  _currentTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTestResultQuantityDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventQty</c> value for the test result default quantity.
    /// </summary>
    /// <returns>The default <c>InventQty</c> value.</returns>
    protected InventQty initializeTestResultQuantityDefault()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePdsCWTestResultQuantityDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PdsCWInventQty</c> value for the catch-weight test result default quantity.
    /// </summary>
    /// <returns>The default <c>PdsCWInventQty</c> value.</returns>
    protected PdsCWInventQty initializePdsCWTestResultQuantityDefault()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventQualityOrderLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates default quality order lines based on the specified test group.
    /// </summary>
    /// <remarks>
    /// This method bypasses the insert method on the <c>InventQualityOrderLine</c> and
    /// <c>InventQualityOrderLineResults</c> classes.
    /// </remarks>
    public void createInventQualityOrderLines()
    {
        if (this.TestGroupId)
        {
            utcdatetime currentTime = DateTimeUtil::getSystemDateTime();
            this.createInventQualityOrderLinesFromTestGroupMember(currentTime);
            this.createInventQualityOrderLineResultsFromTestGroupMember(currentTime);
            this.copyDocumentsToLinesFromTests();
            this.copyDocumentsToLinesFromTestGroupMembers();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventQualityOrderLinesWithConnection</Name>
				<Source><![CDATA[
    [SysObsolete('', false, 30\06\2020)]
    public void createInventQualityOrderLinesWithConnection(UserConnection _conn = null)
    {
        if (this.TestGroupId)
        {
            utcdatetime currentTime = DateTimeUtil::getSystemDateTime();
            this.createInventQualityOrderLinesFromTestGroupMemberWithConnection(currentTime, _conn);
            this.createInventQualityOrderLineResultsFromTestGroupMemberWithConnection(currentTime, _conn);
            this.copyDocumentsToLinesFromTests();
            this.copyDocumentsToLinesFromTestGroupMembers();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Overrides the standard delete method.
    /// </summary>
    /// <exception cref="Exception::Error">
    ///    Quality orders with destructive test cannot be deleted once transactions have been posted.
    /// </exception>
    public void delete()
    {
        if (this.TestDestructive && this.OrderStatus != InventTestOrderStatus::Open)
        {
            throw error("@SYS113835");
        }

        InventStatusBlockingHelper statusBlockingHelper = InventStatusBlockingHelper::construct(InventMovement::construct(this));

        if (#PdsShelfEnabled && this.inventBatchId() && this.PdsUpdateBatchDisp)
        {
            PdsUpdateDispositionStatus_Quality::newDeleteQuality(this).runOperation();
        }

        ttsbegin;

        this.deleteQualityOrderInventory();

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() &&
            (this.ReferenceType == InventTestReferenceType::Purch
            || this.ReferenceType == InventTestReferenceType::Sales))

        {
            TaxEngineQualityOrderTableHeader::deleteByQualityOrderTable(this);
        }
        // </GTE>

        // Update or delete related inventory blocking
        if (InventBlockingQualityOrder::findByQualityOrderId(this.QualityOrderId).RecId != 0)
        {
            using (var relatedInfo = InventBlockingRelatedTransactionInfoSingleton::instance().init(this))
            {
                InventBlockingQualityOrderSync inventBlockingQualityOrderSync = InventBlockingQualityOrderSync::construct();
                inventBlockingQualityOrderSync.onQualityOrderBlockingRequestDelete(this);
            }
        }

        statusBlockingHelper.preDelete();

        super();

        if (this.InventTransId)
        {
            InventUpd_DeleteMovement::newMovement(InventMovement::construct(this)).updateNow();
        }

        statusBlockingHelper.postDelete();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteQualityOrderInventory</Name>
				<Source><![CDATA[
    private void deleteQualityOrderInventory()
    {
        WHSQualityOrderInventory qualityOrderInventory;

        if (!FormDataUtil::isFormDataSource(this))
        {
            while select qualityOrderInventory
                where qualityOrderInventory.QualityOrderId == this.QualityOrderId
            {
                if (!qualityOrderInventory.validateDelete())
                {
                    throw error(strFmt("@WAX:WHSQualityOrderCannotBeDeletedWarning", this.QualityOrderId));
                }
            }
        }
               
        delete_from qualityOrderInventory
            where qualityOrderInventory.QualityOrderId == this.QualityOrderId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitOfMeasurePrecisionFromReference</Name>
				<Source><![CDATA[
    private UnitOfMeasureDecimalPrecision getUnitOfMeasurePrecisionFromReference(InventTestReferenceType _refType = this.ReferenceType)
    {
        boolean         isCWItem;
        PurchLine       purchLine;
        SalesLine       salesLine;
        UnitOfMeasure   unitOfMeasure;

        isCWItem = PdsGlobal::pdsIsCWItem(this.ItemId);

        switch (_refType)
        {
            case InventTestReferenceType::Purch:
                purchLine = PurchLine::findInventTransId(this.InventRefTransId);
                unitOfMeasure = isCWItem ?
                                UnitOfMeasure::findBySymbol(purchLine.pdsCWUnitId()) :
                                UnitOfMeasure::findBySymbol(purchLine.PurchUnit);
                break;

            case InventTestReferenceType::Sales:
                salesLine = SalesLine::findInventTransId(this.InventRefTransId);
                unitOfMeasure = isCWItem ?
                                UnitOfMeasure::findBySymbol(salesLine.pdsCWUnitId()) :
                                UnitOfMeasure::findBySymbol(salesLine.SalesUnit);
                break;

            default:
                unitOfMeasure = isCWItem ?
                                UnitOfMeasure::findBySymbol(PdsCatchWeight::cwUnitId(this.ItemId)) :
                                UnitOfMeasure::findBySymbol(InventTableModule::find(this.ItemId, ModuleInventPurchSales::Invent).UnitId);
        }

        return unitOfMeasure.DecimalPrecision;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAccountRelation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears an account relation if the reference type does not support it.
    /// </summary>
    public void initAccountRelation()
    {
        if (this.shouldClearAccountRelation())
        {
            this.AccountRelation = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldClearAccountRelation</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal boolean shouldClearAccountRelation()
    {
        return this.ReferenceType != InventTestReferenceType::Purch
            && this.ReferenceType != InventTestReferenceType::Sales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBlockingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>BlockingQty</c> field based on the reference document quantity.
    /// </summary>
    /// <param name="_referenceType">
    /// An instance of the <c>InventQualityReferenceType</c> class for the reference document; optional.
    /// </param>
    public void initBlockingQty(InventQualityReferenceType _referenceType = InventQualityReferenceType::newFromQualityOrder(this))
    {
        InventQty                       refQty;
        PdsCWInventQty                  cwRefQty;

        if (!_referenceType.supportsInventoryBlocking())
        {
            this.BlockingQty = 0;
            this.PdsCWBlockingQty = 0;
            return;
        }

        if (this.CompleteBlocking && !this.InventRefTransId)
        {
            this.CompleteBlocking = NoYes::No;
        }

        if (this.CompleteBlocking)
        {
            if (PdsGlobal::pdsIsCWItem(this.ItemId))
            {
                this.PdsCWBlockingQty   = _referenceType.pdsCWInventRefQty();
                this.BlockingQty        = PdsCatchWeight::minInventQty(this.ItemId, cwRefQty);
            }
            else
            {
                refQty                  = _referenceType.inventRefQty();
                this.BlockingQty        = refQty;
            }
        }
        else
        {
            if (PdsGlobal::pdsIsCWItem(this.ItemId))
            {
                this.PdsCWBlockingQty   = this.PdsCWQty;
                this.BlockingQty        = PdsCatchWeight::minInventQty(this.ItemId, this.PdsCWQty);
            }
            else
            {
                this.BlockingQty = this.Qty;
            }
        }
        if (this.TestDestructive)
        { // Don't block the quantity being destroyed
            this.BlockingQty -= this.Qty;
            this.PdsCWBlockingQty -= this.PdsCWQty;
        }
        this.BlockingQty      = max(0, this.BlockingQty);       // Don't allow blocking of negative quanties
        this.PdsCWBlockingQty = max(0, this.PdsCWBlockingQty);  // Don't allow blocking of negative quanties
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCompleteBlockingFromItemSampling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>CompleteBlocking</c> field based on item sampling.
    /// </summary>
    /// <param name="inventItemSampling">
    /// An <c>InventItemSampling</c> table.
    /// </param>
    public void initCompleteBlockingFromItemSampling(InventItemSampling inventItemSampling = InventItemSampling::find(this.ItemSamplingId))
    {
        this.CompleteBlocking   = inventItemSampling.CompleteBlocking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventQualityOrderTable</c> record based on a specified table buffer that has
    /// relevant quality order specification.
    /// </summary>
    /// <param name="_buffer">
    /// The relevant table buffer.
    /// </param>
    public void initFromBuffer(Common _buffer)
    {
        switch (_buffer.TableId)
        {
            case tableNum(InventTable):
                this.ItemId = _buffer.(fieldNum(InventTable, ItemId));
                this.initFromReference();
                break;

            case tableNum(InventBatch):
                this.initFromInventBatch(_buffer as InventBatch);
                break;

            case tableNum(InventNonConformanceTable):
                this.initFromReference(InventQualityReferenceType::newFromInventNonConformanceTable(_buffer), false);
                break;

            case tableNum(InventQualityOrderTable):
                this.initFromReference();
                break;

            case tableNum(PurchTable):
                this.initFromPurchTable(_buffer as PurchTable);
                break;

            case tableNum(SalesTable):
                this.initFromSalesTable(_buffer as SalesTable);
                break;

            default:
                this.initFromReference(InventQualityReferenceType::newFromBuffer(_buffer));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLocationIdFromReferenceTypeExtensionAssigning</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for getting the warehouse for the specified <c>InventTestReferenceType</c> enum.
    /// </summary>
    /// <param name = "_referenceType">The <c>InventTestReferenceType</c> to get the warehouse for.</param>
    /// <param name = "_inventDimId">An <c>InventDimId</c> value on the current quality order record to use for getting the warehouse.</param>
    /// <param name = "_inventTable">An <c>InventTable</c> record to use for getting the warehouse.</param>
    /// <param name = "_inventDim">An <c>InventDim</c> record to use for getting the warehouse.</param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the result.</param>
    delegate void inventLocationIdFromReferenceTypeExtensionAssigning(InventTestReferenceType   _referenceType, 
                                                                      InventDimId               _inventDimId, 
                                                                      InventTable               _inventTable, 
                                                                      InventDim                 _inventDim, 
                                                                      EventHandlerResult        _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventLocationIdFromReferenceType</Name>
				<Source><![CDATA[
    private InventLocationId getInventLocationIdFromReferenceType(InventTable _inventTable, InventDim _inventDim)
    {
        switch (this.ReferenceType)
        {
            case InventTestReferenceType::Sales:
                return _inventTable.salesInventLocationId(_inventDim.InventLocationId, this.InventDimId);

            case InventTestReferenceType::Purch:
                return _inventTable.purchInventLocationId(_inventDim.InventLocationId, this.InventDimId);

            default:
                EventHandlerResult eventHandlerResult = EventHandlerResult::newSingleResponse();
                this.inventLocationIdFromReferenceTypeExtensionAssigning(this.ReferenceType, this.InventDimId, _inventTable, _inventDim, eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }

                return _inventTable.inventLocationId(_inventDim.InventLocationId, this.InventDimId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventQualityOrderTable</c> record from an <c>InventBatch</c> record.
    /// </summary>
    /// <param name="_inventBatch">
    /// The inventory batch from which to initialize.
    /// </param>
    public void initFromInventBatch(InventBatch _inventBatch)
    {
        InventDim                   inventDim           = this.inventDim();
        InventTable                 inventTable         = InventTable::find(_inventBatch.ItemId);
        InventDimOnHand_Physical    inventDimOnHand_Physical = _inventBatch.inventOnhandPhysicalDetailed();
        SetEnumerator               enumerator;
        InventDimOnHandMember       inventDimOnHandMember;
        InventDim                   inventDimOnHand;
        InventDim                   inventDimOnHandCurrent;
        boolean                     firstOnHand = true;

        this.ItemId                 = _inventBatch.ItemId;
        this.ItemName               = inventTable.defaultProductName();

        if (inventDimOnHand_Physical.elements() == 0)
        {
            inventDim.InventLocationId = this.getInventLocationIdFromReferenceType(inventTable, inventDim);
            
            if (inventDim.InventLocationId)
            {
                inventDim.initFromInventLocation(inventDim.inventLocation());
            }

            inventTable.initNonSpecifiedStandardProductDims(inventDim);
        }
        else
        if (inventDimOnHand_Physical.elements() == 1)
        {
            inventDimOnHandMember = inventDimOnHand_Physical.firstElement();
            inventDim.data(InventDim::find(inventDimOnHandMember.parmInventDimId()));
            this.Qty = inventDimOnHandMember.parmInventQty();
            this.PdsCWQty = inventDimOnHandMember.pdsCWParmInventQty();
        }
        else
        {
            this.Qty = 0;
            this.PdsCWQty = 0;
            enumerator = inventDimOnHand_Physical.getEnumerator();
            while (enumerator.moveNext())
            {
                inventDimOnHandMember = enumerator.current();
                if (inventDimOnHandMember.parmInventQty() != 0
                 || inventDimOnHandMember.pdsCWParmInventQty() != 0
                    )
                {
                    inventDimOnHandCurrent = InventDim::find(inventDimOnHandMember.parmInventDimId());
                    if (firstOnHand)
                    {
                        inventDimOnHand.data(inventDimOnHandCurrent);
                        firstOnHand = false;
                    }
                    else
                    {
                        inventDimOnHandCurrent.commonDenominatorUsedDim(InventDimGroupSetup::newInventTable(inventTable), inventDimOnHand);
                    }
                    this.Qty += inventDimOnHandMember.parmInventQty();
                    this.PdsCWQty += inventDimOnHandMember.pdsCWParmInventQty();
                }
            }
            inventDim.data(inventDimOnHand);
        }

        inventDim.InventBatchId     = _inventBatch.InventBatchId;
        this.InventDimId            = InventDim::findOrCreate(inventDim).InventDimId;
        this.DefaultDimension       = this.mergeDimension(inventTable.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventTestAssociationTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>InventQualityOrderTable</c> record from a test association.
    /// </summary>
    /// <param name="_inventTestAssociationTable">
    ///    The test association from which to initialize.
    /// </param>
    public void initFromInventTestAssociationTable(InventTestAssociationTable _inventTestAssociationTable)
    {
        this.TestGroupId            = _inventTestAssociationTable.TestGroupId;
        this.AcceptableQualityLevel = _inventTestAssociationTable.AcceptableQualityLevel;
        this.ItemSamplingId         = _inventTestAssociationTable.ItemSamplingId;
        this.QuarantineOnFailure    = this.allowQuarantineUponFailure() && _inventTestAssociationTable.QuarantineOnFailure;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>InventQualityOrderTable</c> record from a work line.
    /// </summary>
    /// <param name="_workLine">
    ///    The work line from which to initialize.
    /// </param>
    public void initFromWorkLine(WHSWorkLine _workLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventTestGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>InventQualityOrderTable</c> record from the specified test group.
    /// </summary>
    public void initFromInventTestGroup()
    {
        InventTestGroup     inventTestGroup = InventTestGroup::find(this.TestGroupId);
        if (inventTestGroup)
        {
            if (!this.AcceptableQualityLevel)
            {
                this.AcceptableQualityLevel = inventTestGroup.AcceptableQualityLevel;
            }

            if (!this.TestDestructive)
            {
                this.TestDestructive = inventTestGroup.TestDestructive;
            }

            if (!this.ItemSamplingId)
            {
                this.ItemSamplingId = inventTestGroup.ItemSamplingId;
            }

            if (#PdsShelfEnabled)
            {
                this.PdsPassQualityDispositionCode
                    = inventTestGroup.PdsPassQualityDispositionCode;

                this.PdsFailedQualityDispositionCode
                    = inventTestGroup.PdsFailedQualityDispositionCode;

                this.PdsUpdateBatchDisp = inventTestGroup.PdsUpdateBatchDisp;
            }

            if (this.allowUpdateInventoryStatus())
            {
                this.UpdateInventStatus     = inventTestGroup.UpdateInventStatus;
                this.FailedInventStatusId   = inventTestGroup.FailedInventStatusId;
                this.PassedInventStatusId   = inventTestGroup.PassedInventStatusId;
            }
            else
            {
                this.UpdateInventStatus     = false;
                this.FailedInventStatusId   = '';
                this.PassedInventStatusId   = '';
            }

            this.PdsUpdateInvBatchAttributes = inventTestGroup.PdsUpdateBatchAttributes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventQualityOrderTable</c> record from an <c>PurchTable</c> record.
    /// </summary>
    /// <param name="_purchTable">
    /// The purchase order from which to initialize.
    /// </param>
    public void initFromPurchTable(PurchTable _purchTable)
    {
        this.ReferenceType = InventTestReferenceType::Purch;
        this.InventRefId = _purchTable.PurchId;
        this.initFromReference();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldNotSetInventRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the invent reference should not be set.
    /// </summary>
    /// <param name = "_inventTestReferenceType">
    /// The <c>InventTestReferenceType</c> value.
    /// </param>
    /// <returns>
    /// true, if the invent reference should not be set; otherwise, false.
    /// </returns>
    protected boolean shouldNotSetInventRef(InventTestReferenceType _inventTestReferenceType)
    {
        return ((_inventTestReferenceType == InventTestReferenceType::Purch
                 || _inventTestReferenceType == InventTestReferenceType::Sales
                 || _inventTestReferenceType == InventTestReferenceType::PmfProdCoBy)
                && (!this.InventRefId || !this.InventRefTransId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldNotSetRouteRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the route reference should not be set.
    /// </summary>
    /// <param name = "_inventTestReferenceType">
    /// The <c>InventTestReferenceType</c> value.
    /// </param>
    /// <returns>
    /// true, if the route reference should not be set; otherwise, false.
    /// </returns>
    protected boolean shouldNotSetRouteRef(InventTestReferenceType _inventTestReferenceType)
    {
        return ((_inventTestReferenceType == InventTestReferenceType::RouteOpr)
                && (!this.InventRefId
                    || this.OprNum == minInt()
                    || !this.RouteOprId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAccountRelation</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal str findAccountRelation()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventQualityOrderTable</c> record based a specified reference document table
    /// buffer.
    /// </summary>
    /// <param name="_referenceType">
    /// A <c>InventQualityReferenceType</c> reference document.
    /// </param>
    /// <param name="_mergeReferenceDimension">
    /// A Boolean value that indicates whether to merge the reference dimension; otherwise, copy.
    /// </param>
    public void initFromReference(
        InventQualityReferenceType  _referenceType              = null,
        boolean                     _mergeReferenceDimension    = true)
    {
        InventQualityReferenceType  referenceType   = _referenceType;
        InventTestReferenceType     inventTestReferenceType;
        InventTable                 inventTable;
        ItemId                      itemId;
        boolean                     setInventRef = true;
        boolean                     setRouteRef   = true;

        if (!referenceType)
        {
            referenceType = InventQualityReferenceType::newFromQualityOrder(this);
            inventTestReferenceType = referenceType.referenceType();

            if (this.shouldNotSetInventRef(inventTestReferenceType))
            {
                setInventRef = false;
            }
            if (this.shouldNotSetRouteRef(inventTestReferenceType))
            {
                setRouteRef = false;
            }
        }
        else
        {
            inventTestReferenceType = referenceType.referenceType();
        }

        itemId                      = referenceType.itemId();
        this.ReferenceType          = inventTestReferenceType;
        if (setInventRef && setRouteRef)
        {
            this.InventRefId        = referenceType.inventRefId();
            this.InventRefTransId   = referenceType.inventTransId();
        }
        this.AccountRelation        = referenceType.accountRelation();
        if (!this.AccountRelation && this.InventRefId)
        { // Could potentially set the account relation based on the sales ID or purchase ID alone
            switch (this.ReferenceType)
            {
                case InventTestReferenceType::Purch:
                    this.AccountRelation = PurchTable::find(this.InventRefId).OrderAccount;
                    break;
                case InventTestReferenceType::Sales:
                    this.AccountRelation = SalesTable::find(this.InventRefId).CustAccount;
                    break;
                default:
                    this.AccountRelation = this.findAccountRelation();
                    break;
            }
        }
        this.RouteId                = referenceType.routeId();
        if (setRouteRef)
        {
            if (referenceType.oprNum() != minInt())
            {
                this.OprNum             =  referenceType.oprNum();
            }
            this.RouteOprId             = referenceType.routeOprId();
            this.WrkCtrId               = referenceType.routeWrkCtrId();
        }

        if (!itemId)
        {
            if (this.ItemId)
            {
                itemId              = this.ItemId;
            }
            else
            {
                this.InventDimId    = InventDim::inventDimIdBlank();
                return;
            }
        }

        inventTable                 = InventTable::find(itemId);
        this.ItemId                 = itemId;
        this.ItemName               = inventTable.defaultProductName();

        this.InventDimId            = referenceType.initProductDimensions();
        this.inventDimModified(referenceType);

        this.DefaultDimension       = this.mergeDimension(inventTable.DefaultDimension);

        if (referenceType.defaultDimension())
        {
            this.DefaultDimension   = _mergeReferenceDimension ?
                                      this.mergeDimension(referenceType.defaultDimension()) :
                                      this.copyDimension(referenceType.defaultDimension());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes  quality order inventory dimension specific data.
    /// </summary>
    /// <param name = "_referenceType">The reference type instance of the quality order.</param>
    public void inventDimModified(InventQualityReferenceType _referenceType = null)
    {
        if (!_referenceType)
        {
            _referenceType = InventQualityReferenceType::newFromQualityOrder(this);
            _referenceType.setInventDimId(this.InventDimId);
        }

        this.InventDimId = _referenceType.defaultInventDimId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventQualityOrderTable</c> record from an <c>SalesTable</c> record.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order from which to initialize.
    /// </param>
    public void initFromSalesTable(SalesTable _salesTable)
    {
        this.ReferenceType = InventTestReferenceType::Sales;
        this.InventRefId = _salesTable.SalesId;
        this.initFromReference();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQtyByFindingAssoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>Qty</c> field based on a relevant quality association.
    /// </summary>
    public void initQtyByFindingAssoc()
    {
        InventQualityMgmtOrderInitializer::initializeQtyByFindingAssociation(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQtyFromAssociation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialized the <c>Qty</c> field based on a quality association.
    /// </summary>
    /// <param name="_inventTestAssociationTable">
    /// An <c>InventTestAssociationTable</c> association.
    /// </param>
    /// <param name="_referenceQty">
    /// An <c>InventQty</c> reference quantity.
    /// </param>
    /// <param name="_cwReferenceQty">
    /// A <c>PdsCWInventQty</c> reference quantity.
    /// </param>
    public void initQtyFromAssociation(
        InventTestAssociationTable  _inventTestAssociationTable = null,
        InventQty                   _referenceQty               = InventQualityReferenceType::newFromQualityOrder(this).inventRefQty(),
        PdsCWInventQty              _cwReferenceQty = InventQualityReferenceType::newFromQualityOrder(this).pdsCWInventRefQty()
        )
    {
        InventItemSampling inventItemSampling = this.findInventItemSampleByAssociation(_inventTestAssociationTable);

        this.initQtyFromItemSampling(inventItemSampling, _referenceQty, _cwReferenceQty);
        
        // Subtract any amount that has already been tracked for item sampling for the inventDim
        if (InventQualityReferenceType::newFromQualityOrder(this).isItemAndWarehouseQualityManagementProcessEnabled() 
            && !inventItemSampling.CreatePerUpdatedQuantity)
        {
            this.Qty -= WHSItemSamplingTracking::calculateQuantityAlreadySampled(InventQualityReferenceType::newFromQualityOrder(this), _inventTestAssociationTable.RecId, this.InventDimId);
                
            if (this.Qty < 0)
            {
                this.Qty = 0;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInventItemSampleByAssociation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the relevant <c>InventItemSampling</c> record based upon the provided <c>InventTestAssociationTable</c> record.
    /// Otherwise, finds the relevant <c>InventItemSampling</c> record based upon the related TestGroupId.
    /// </summary>
    /// <param name = "_inventTestAssociationTable">The relevant <c>InventTestAssociationTable</c> record.</param>
    /// <returns>The found <c>InventItemSampling</c> record.</returns>
    protected InventItemSampling findInventItemSampleByAssociation(InventTestAssociationTable  _inventTestAssociationTable)
    {
        InventItemSampling inventItemSampling;

        if (_inventTestAssociationTable)
        {
            inventItemSampling = InventItemSampling::find(_inventTestAssociationTable.ItemSamplingId);
        }
        else
        {
            inventItemSampling = InventItemSampling::find(InventTestGroup::find(this.TestGroupId).ItemSamplingId);
        }

        return inventItemSampling;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQtyFromItemSampling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>Qty</c> field by using a quality association.
    /// </summary>
    /// <param name="inventItemSampling">
    /// An <c>InventItemSampling</c> sampling.
    /// </param>
    /// <param name="referenceQty">
    /// An <c>InventQty</c> reference quantity.
    /// </param>
    /// <param name="_cwReferenceQty">
    /// A <c>PdsCWInventQty</c> reference quantity.
    /// </param>
    public void initQtyFromItemSampling(
        InventItemSampling  inventItemSampling,
        InventQty           referenceQty = InventQualityReferenceType::newFromQualityOrder(this).inventRefQty(),
        PdsCWInventQty      _cwReferenceQty = InventQualityReferenceType::newFromQualityOrder(this).pdsCWInventRefQty()
        )
    {
        InventQty          qty;
        UnitOfMeasureDecimalPrecision   decimalPrecision;
        PdsCWInventQty     cwQty;

        if (PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            referenceQty = _cwReferenceQty;
        }

        if (inventItemSampling.TestQtySpecification == InventTestQtySpecification::FixedQty &&
            referenceQty > inventItemSampling.ItemSamplingValue)
        {
            qty = inventItemSampling.ItemSamplingValue;
        }
        else if (inventItemSampling.TestQtySpecification == InventTestQtySpecification::Percent)
        {
            decimalPrecision = this.getUnitOfMeasurePrecisionFromReference(InventTestReferenceType::Inventory);
            qty = Global::roundUpDec(inventItemSampling.ItemSamplingValue * referenceQty / 100, decimalPrecision);
        }
        else
        {
            qty = referenceQty;
        }

        if (PdsGlobal::pdsIsCWItem(this.ItemId))
        {
            cwQty = qty;
            qty = PdsCatchWeight::minInventQty(this.ItemId, cwQty);
        }
        this.PdsCWQty = cwQty;

        this.Qty = qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides the standard insert method.
    /// </summary>
    /// <param name="_dropEstimated">
    /// A <c>NoYes</c> enumeration value that indicates whether related inventory transactions should be
    /// updated; optional.
    /// </param>
    /// <param name="_updateReservation">
    /// A <c>NoYes</c> enumeration value that indicates whether items should be reserved; optional.
    /// </param>
    /// <param name="_inventQualityOrderTableValidator">
    /// An <c>InventQualityOrderTableValidator</c> instance to be used for validating the quality order fields; optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// A new quality order cannot be created for the specified reference.
    /// </exception>
    public void insert(
        NoYes                           _dropEstimated                      = NoYes::No,
        NoYes                           _updateReservation                  = NoYes::Yes,
        InventQualityOrderTableValidator _inventQualityOrderTableValidator  = null)
    {
        InventUpd_Estimated                     estimated;
        InventDim                               inventDim;
        InventBlockingQualityOrderSync          inventBlockingQualityOrderSync;
        InventStatusBlockingHelper              statusBlockingHelper;
        InventQualityOrderTableValidator        inventQualityOrderTableValidator = _inventQualityOrderTableValidator;

        if (!inventQualityOrderTableValidator)
        {
            inventQualityOrderTableValidator = InventQualityOrderTableValidator::newFromQualityOrderTable(this);
        }
        if (!inventQualityOrderTableValidator.checkCanCreate())
        {
            throw error("@SYS114385");
        }

        if (#PmfEnabled
            && !InventTable::pmfCheckAllowQuality(this.ItemId))
        {
            throw error("@PRO1980");
        }

        statusBlockingHelper = InventStatusBlockingHelper::construct(InventMovement::construct(this));

        ttsbegin;

        if (! _dropEstimated)
        {
            statusBlockingHelper.preInsert();

            if (this.TestDestructive && !this.InventTransId)
            {
                this.InventTransId = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
            }

            if (this.InventTransId)
            {
                using (InventDestructiveQualityOrderUpdateMarkingContext markingContext = InventDestructiveQualityOrderUpdateMarkingContext::construct())
                {
                    if (this.TestDestructive
                        && this.CompleteBlocking == NoYes::No)
                    {
                        InventQualityOrderPhysicalVoucherContext context = InventQualityOrderPhysicalVoucherContext::current();
                        if (context && context.parmPackingSlipId())
                        {
                            markingContext.parmPackingSlipId(context.parmPackingSlipId());
                        }
                    }

                    estimated = InventUpd_Estimated::newInventMovement(InventMovement::construct(this));
                    estimated.updateNow();
                }
            }
        }

        super();

        if (estimated)
        {
            estimated.updateOwnerRelationship();
        }

        if (_updateReservation)
        {
            if (estimated)
            {
                estimated.updateReservation();
            }
        }

        if (this.InventDimId)
        {
            inventDim = this.inventDim();
        }

        this.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;
        this.inventDim().modifiedInventSiteFromParent(this);

        // Create or update related inventory blocking
        if (this.BlockingQty > 0)
        {
            inventBlockingQualityOrderSync = InventBlockingQualityOrderSync::construct();
            inventBlockingQualityOrderSync.onQualityOrderBlockingRequestCreate(this);
        }

        this.createInventQualityOrderLines();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWithConnection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides the insert method with UserConnection.
    /// </summary>
    /// <param name="_dropEstimated">
    /// A <c>NoYes</c> enumeration value that indicates whether related inventory transactions should be
    /// updated; optional.
    /// </param>
    /// <param name="_updateReservation">
    /// A <c>NoYes</c> enumeration value that indicates whether items should be reserved; optional.
    /// </param>
    /// <param name="_inventQualityOrderTableValidator">
    /// An <c>InventQualityOrderTableValidator</c> instance to be used for validating the quality order fields; optional.
    /// </param>
    /// <param name="_conn">
    /// A <c>UserConnection</c> to be used for quality order insertion in a separate ttscope; optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// A new quality order cannot be created for the specified reference.
    /// </exception>
    [SysObsolete('', false, 30\06\2020)]
    public void insertWithConnection(
        NoYes                           _dropEstimated                      = NoYes::No,
        NoYes                           _updateReservation                  = NoYes::Yes,
        InventQualityOrderTableValidator _inventQualityOrderTableValidator  = null,
        UserConnection                   _conn = null)
    {
        InventUpd_Estimated                     estimated;
        InventDim                               inventDim;
        InventBlockingQualityOrderSync          inventBlockingQualityOrderSync;
        InventStatusBlockingHelper              statusBlockingHelper;
        InventQualityOrderTableValidator        inventQualityOrderTableValidator = _inventQualityOrderTableValidator;

        if (!inventQualityOrderTableValidator)
        {
            inventQualityOrderTableValidator = InventQualityOrderTableValidator::newFromQualityOrderTable(this);
        }
        if (!inventQualityOrderTableValidator.checkCanCreate())
        {
            throw error("@SYS114385");
        }

        if (#PmfEnabled
            && !InventTable::pmfCheckAllowQuality(this.ItemId))
        {
            throw error("@PRO1980");
        }

        statusBlockingHelper = InventStatusBlockingHelper::construct(InventMovement::construct(this));

        ttsbegin;

        if (! _dropEstimated)
        {
            statusBlockingHelper.preInsert();

            if (this.TestDestructive && !this.InventTransId)
            {
                this.InventTransId = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
            }

            if (this.InventTransId)
            {
                estimated = InventUpd_Estimated::newInventMovement(InventMovement::construct(this));
                estimated.updateNow();
            }
        }

        this.doInsert();

        if (estimated)
        {
            estimated.updateOwnerRelationship();
        }

        if (_updateReservation)
        {
            if (estimated)
            {
                estimated.updateReservation();
            }
        }

        if (this.InventDimId)
        {
            inventDim = this.inventDim();
        }

        this.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;
        this.inventDim().modifiedInventSiteFromParent(this);

        // Create or update related inventory blocking
        if (this.BlockingQty > 0)
        {
            inventBlockingQualityOrderSync = InventBlockingQualityOrderSync::construct();
            inventBlockingQualityOrderSync.onQualityOrderBlockingRequestCreate(this);
        }

        this.createInventQualityOrderLinesWithConnection(_conn);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertFromForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in the <c>InventQualityOrderTable</c> table and makes sure that the related
    /// <c>InventDim</c> record exists.
    /// </summary>
    /// <param name="_inventDim">
    /// The related <c>InventDim</c> record.
    /// </param>
    /// <returns>
    /// The <c>InventDimId</c> of the related <c>InventDim</c> record.
    /// </returns>
    public InventDimId insertFromForm(InventDim   _inventDim)
    {
        ttsbegin;

        this.InventDimId = InventDim::findOrCreate(_inventDim).InventDimId;
        this.inventDim().modifiedInventSiteFromParent(this);

        this.initFromInventTestGroup();
        this.initCompleteBlockingFromItemSampling();
        this.initBlockingQty();

        using (InventChangeBlockingQtyOnDestructiveTestContext destructiveContext = InventUpdateBlockingQtyOnDestructiveTestFlight::instance().isEnabled()
            ? InventChangeBlockingQtyOnDestructiveTestContext::construct() : null)
        {
            if (destructiveContext
                && this.TestDestructive
                && (this.ReferenceType == InventTestReferenceType::Purch
                    || this.ReferenceType == InventTestReferenceType::Production
                    || this.ReferenceType == InventTestReferenceType::RouteOpr
                    || this.ReferenceType == InventTestReferenceType::PmfProdCoBy))
            {
                destructiveContext.parmSkipDeductDestructiveQty(true);
            }

            this.insert();
        }

        ttscommit;

        return this.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventBatch</Name>
				<Source><![CDATA[
    public InventBatch inventBatch()
    {
        return InventBatch::find(this.inventBatchId(), this.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventBatchId</Name>
				<Source><![CDATA[
    public InventBatchId inventBatchId()
    {
        return InventDim::find(this.InventDimId, false).InventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the related <c>InventDim</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>InventDim</c> table; otherwise, an empty record.
    /// </returns>
    public InventDim inventDim(boolean  _forUpdate = false)
    {
        return InventDim::find(this.InventDimId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimForBlocking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns inventory dimensions for this quality order's inventory blocking.
    /// </summary>
    /// <returns>
    /// <c>InventDim</c> buffer.
    /// </returns>
    /// <remarks>
    /// <c>InventDim</c> record will be created if it does not exist.
    /// </remarks>
    public InventDim inventDimForBlocking()
    {
        InventDim   inventDimForBlocking;

        if (this.whsIsForWorkGeneratingProcess())
        {
            // We do not want to automatically block anything on location and below in advanced warehousing, since
            // those dimensions are utilized by work
            inventDimForBlocking = this.inventDim();
            inventDimForBlocking.clearLocationAndBelowDim(this.ItemId);
            inventDimForBlocking = InventDim::findOrCreate(inventDimForBlocking);
        }
        else
        {
            inventDimForBlocking = this.inventDim();
        }

        return inventDimForBlocking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventNonConformanceID</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the ID of nonconformance from which this quality order was created.
    /// </summary>
    /// <returns>
    ///    The ID of the originating nonconformance.
    /// </returns>
    /// <remarks>
    ///    An empty string is returned if the quality order was not created from a nonconformance.
    /// </remarks>
    display public InventNonConformanceID inventNonConformanceID()
    {
        return InventQualityOrderTableOrigin::find(this.QualityOrderId).InventNonConformanceID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the related <c>InventTable</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>InventTable</c> table; otherwise, an empty record.
    /// </returns>
    public InventTable inventTable(boolean  _forUpdate = false)
    {
        return InventTable::find(this.ItemId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAssociatedToProcessingWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current quality order was created by a wave that is still processing.
    /// </summary>
    /// <returns>
    /// true, if it is associated to a processing wave; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The wave may actually be still processing or errored without being cleaned up.
    /// </remarks>
    public boolean isAssociatedToProcessingWave()
    {
        WHSWaveCreatedQualityOrder  waveCreatedQualityOrder;

        select firstOnly RecId from waveCreatedQualityOrder
            where waveCreatedQualityOrder.InventQualityOrderId == this.QualityOrderId;

        return waveCreatedQualityOrder.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupPurchaseOrderId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a lookup for selecting a purchase order.
    /// </summary>
    /// <param name="_lookupCtrl">
    /// The control that the user initiates the lookup from.
    /// </param>
    public void lookupPurchaseOrderId(FormStringControl _lookupCtrl)
    {
        Query                   query;
        QueryBuildDataSource    queryBuildDataSourceLine;
        QueryBuildDataSource    queryBuildDataSourceTable;
        SysTableLookup          sysTableLookup  = SysTableLookup::newParameters(tableNum(PurchLine), _lookupCtrl);

        query = new Query();
        queryBuildDataSourceLine = query.addDataSource(tableNum(PurchLine));

        queryBuildDataSourceLine.addRange(fieldNum(PurchLine, isDeleted)).value(queryValue(NoYes::No));

        queryBuildDataSourceTable = queryBuildDataSourceLine.addDataSource(tableNum(PurchTable));
        queryBuildDataSourceTable.relations(true);
        queryBuildDataSourceTable.joinMode(JoinMode::ExistsJoin);

        if (this.AccountRelation)
        {
            queryBuildDataSourceTable.addRange(fieldNum(PurchTable, OrderAccount)).value(queryValue(this.AccountRelation));
        }
        sysTableLookup.parmQuery(query);

        sysTableLookup.addLookupfield(fieldNum(PurchLine, PurchId), true);
        sysTableLookup.addLookupfield(fieldNum(PurchLine, LineNumber));
        sysTableLookup.addLookupfield(fieldNum(PurchLine, ItemId));
        sysTableLookup.addLookupfield(fieldNum(PurchLine, InventTransId));
        sysTableLookup.addLookupfield(fieldNum(PurchLine, PurchStatus));
        sysTableLookup.addLookupfield(fieldNum(PurchLine, QtyOrdered));

        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupPurchaseOrderTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a lookup for selecting an undeleted purchase line.
    /// </summary>
    /// <param name="_lookupCtrl">
    /// The control that the user initiates the lookup from.
    /// </param>
    public void lookupPurchaseOrderTransId(FormStringControl _lookupCtrl)
    {
        Args   args = new Args();
        Object formRun;

        args.name(formStr(InventTransIdPurchLineLookup));
        args.caller(_lookupCtrl);
        args.record(this);

        formRun = classfactory.formRunClass(args);
        formRun.parmPurchId(this.InventRefId);
        formRun.init();

        _lookupCtrl.performFormLookup(formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupSalesOrderId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a lookup for selecting a sales order.
    /// </summary>
    /// <param name="_lookupCtrl">
    /// The control that the user initiates the lookup from.
    /// </param>
    public void lookupSalesOrderId(FormStringControl _lookupCtrl)
    {
        Query                   query;
        QueryBuildDataSource    queryBuildDataSourceLine;
        QueryBuildDataSource    queryBuildDataSourceTable;
        SysTableLookup          sysTableLookup  = SysTableLookup::newParameters(tableNum(SalesLine), _lookupCtrl);

        query = new Query();
        queryBuildDataSourceLine = query.addDataSource(tableNum(SalesLine));

        queryBuildDataSourceTable = queryBuildDataSourceLine.addDataSource(tableNum(SalesTable));
        queryBuildDataSourceTable.relations(true);
        queryBuildDataSourceTable.joinMode(JoinMode::ExistsJoin);
        if (this.AccountRelation)
        {
            queryBuildDataSourceTable.addRange(fieldNum(SalesTable, CustAccount)).value(queryValue(this.AccountRelation));
        }
        sysTableLookup.parmQuery(query);

        sysTableLookup.addLookupfield(fieldNum(SalesLine, SalesId), true);
        sysTableLookup.addLookupfield(fieldNum(SalesLine, LineNum));
        sysTableLookup.addLookupfield(fieldNum(SalesLine, ItemId));
        sysTableLookup.addLookupfield(fieldNum(SalesLine, InventTransId));
        sysTableLookup.addLookupfield(fieldNum(SalesLine, SalesStatus));
        sysTableLookup.addLookupfield(fieldNum(SalesLine, QtyOrdered));

        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayAccountRelationBeEditable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether quality order account information should be editable.
    /// </summary>
    /// <returns>
    ///    true if the account information should be editable; otherwise, false.
    /// </returns>
    public boolean mayAccountRelationBeEditable()
    {
        if (this.ReferenceType == InventTestReferenceType::Purch
         || this.ReferenceType == InventTestReferenceType::Sales)
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a dimension set that holds the merged combination of the current <c>defaultDimension</c>
    /// field on this table and the specified dimension set.
    /// </summary>
    /// <param name="_primaryDefaultDimension">
    /// The first dimension set to merge with the current <c>defaultDimension</c> field on this table.
    /// </param>
    /// <param name="_secondaryDefaultDimension">
    /// The second dimension set that should be merged with the current <c>defaultDimension</c> field on
    /// this table; optional.
    /// </param>
    /// <param name="_dimensionMerge">
    /// A <c>dimensionMerge</c> object that was initialized with the current buffer; optional.
    /// </param>
    /// <returns>
    /// A dimension set that holds the merged combination of the current <c>defaultDimension</c> field on
    /// this table and the specified dimension set.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are not overwritten when they are merged.
    /// </remarks>

    public DimensionDefault mergeDimension(
        DimensionDefault _primaryDefaultDimension,
        DimensionDefault _secondaryDefaultDimension = 0,
        DimensionMerge   _dimensionMerge = DimensionMerge::newFromTable(this,
                                                                        this.companyInfo().RecId
                                                                        )
        )
    {
        return _dimensionMerge.merge(_primaryDefaultDimension, _secondaryDefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(InventQualityOrderTable, ItemId):
                this.initFromReference();
                this.Qty = InventTable::applyRoundingToInventQty(this.Qty, this.ItemId);
                break;
            case fieldNum(InventQualityOrderTable, TestGroupId):
                this.initQtyByFindingAssoc();
                break;
            case fieldNum(InventQualityOrderTable, ReferenceType):
                this.clearReferenceFields();
                this.initAccountRelation();
                break;
            case fieldNum(InventQualityOrderTable, InventRefTransId)
                ,fieldNum(InventQualityOrderTable, WrkCtrId)
                ,fieldNum(InventQualityOrderTable, RouteOprId)
                ,fieldNum(InventQualityOrderTable, OprNum)
                ,fieldNum(InventQualityOrderTable, InventRefId):
                this.initAccountRelation();
                this.initFromReference();
                break;
            case fieldNum(InventQualityOrderTable, PdsUpdateInvBatchAttributes):
                if (#PdsBatchAttribEnabled)
                {
                    info("@PDS1026");
                }
                break;
            case fieldNum(InventQualityOrderTable, Qty):
                this.Qty = InventTable::applyRoundingToInventQty(this.Qty, this.ItemId);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReferenceTotalDestructiveQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the catch weight quantity referenced by other quality orders for the same reference as this quality order.
    /// </summary>
    /// <returns>
    /// The calculated catch weight quantity.
    /// </returns>
    public PdsCWInventQty pdsCWReferenceTotalDestructiveQty()
    {
        InventQualityOrderTable   inventQualityOrderTable;
        InventTestDiscriminatingInventDims  discriminatingInventoryDim;

        discriminatingInventoryDim = InventItemSampling::find(this.ItemSamplingId).DiscriminatingInventoryDimensions;

        select sum(PdsCWQty) from inventQualityOrderTable
            where inventQualityOrderTable.InventRefId == this.InventRefId
            &&    inventQualityOrderTable.InventRefTransId == this.InventRefTransId
            &&    inventQualityOrderTable.OprNum == this.OprNum
            &&    inventQualityOrderTable.RouteOprId == this.RouteOprId
            &&    inventQualityOrderTable.ReferenceType == this.ReferenceType
            &&    inventQualityOrderTable.WrkCtrId == this.WrkCtrId
            &&    inventQualityOrderTable.RecId != this.RecId
            &&    inventQualityOrderTable.TestDestructive == true
            &&    (!discriminatingInventoryDim || inventQualityOrderTable.InventDimId == this.InventDimId);

        return inventQualityOrderTable.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsReferenceTotalDestructiveQtyPair</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity referenced by other quality orders for the same reference as this quality
    /// order.
    /// </summary>
    /// <returns>
    /// A container that contains two real values that represent the remaining test quantity in inventory
    /// unit and catch weight unit.
    /// </returns>
    public container pdsReferenceTotalDestructiveQtyPair()
    {
        InventQualityOrderTable   inventQualityOrderTable;

        select sum(PdsCWQty), sum(Qty) from inventQualityOrderTable
            where   inventQualityOrderTable.InventRefId == this.InventRefId
            &&      inventQualityOrderTable.InventRefTransId == this.InventRefTransId
            &&      inventQualityOrderTable.OprNum == this.OprNum
            &&      inventQualityOrderTable.RouteOprId == this.RouteOprId
            &&      inventQualityOrderTable.ReferenceType == this.ReferenceType
            &&      inventQualityOrderTable.WrkCtrId == this.WrkCtrId
            &&      inventQualityOrderTable.RecId != this.RecId
            &&      inventQualityOrderTable.TestDestructive == true;

        return [inventQualityOrderTable.Qty, inventQualityOrderTable.PdsCWQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsValidateBatchAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates all quality order lines that are needed to be checked for batch attributes update.
    /// </summary>
    /// <param name="_inventBatchId">
    /// The inventory batch selected.
    /// </param>
    /// <param name="_acceptError">
    /// A Boolean value that indicates whether to display a warning message for an incorrect batch
    /// attribute validation.
    /// </param>
    /// <param name="_updateRelatedBatches">
    /// A Boolean value that indicates whether related inventory batches also have to be updated with the
    /// batch attribute value.
    /// </param>
    /// <returns>
    /// true if the quality order lines are needed to be checked for batch attribute update; otherwise,
    /// false .
    /// </returns>
    public boolean pdsValidateBatchAttributes(
        InventBatchId   _inventBatchId  = '',
        boolean         _acceptError    = false,
        boolean         _updateRelatedBatches = true)
    {
        PdsBatchAttributes      batchAttributes;
        InventQualityOrderLine  orderLine;
        InventBatchId           inventBatchId;
        boolean                 ret = true;

        setPrefix("@PDS1203");

        inventBatchId = _inventBatchId
            ? _inventBatchId
            : this.inventBatchId();

        while select orderLine
            where  orderLine.QualityOrderId == this.QualityOrderId
                && orderLine.PdsBatchAttribId
                && orderLine.PdsUpdateBatchAttributes == NoYes::Yes
        {
            batchAttributes = PdsBatchAttributes::insertDefaultAttributes(
                this.ItemId,
                inventBatchId,
                orderLine.PdsBatchAttribId);

            if (!batchAttributes)
            {
                warning(strFmt(
                    "@PDS1033",
                    this.ItemId,
                    inventBatchId));

                ret = false;
            }
            else
            {
                ret = orderLine.pdsValidateBatchAttributesValue(
                    inventBatchId,
                    _acceptError);

                if (ret)
                {
                    if (orderLine.PdsAttribValue && inventBatchId)
                    {
                        orderLine.pdsUpdateAttributeValue(
                            inventBatchId,
                            batchAttributes);
                    }
                    else
                    {
                        ret = checkFailed(strFmt(
                            "@PDS1201",
                            inventBatchId,
                            orderLine.PdsBatchAttribId,
                            orderLine.PdsAttribValue));
                    }
                }

                if (    ret
                    && _updateRelatedBatches
                    && (this.ReferenceType  == InventTestReferenceType::Purch
                    ||  this.ReferenceType  == InventTestReferenceType::Production))
                {
                    orderLine.pdsValidateRelatedBatchAttributes();
                }

                if (!_acceptError && !ret)
                {
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>referenceTotalDestructiveQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity referenced by other quality orders for the same reference as this quality order.
    /// </summary>
    /// <returns>
    /// The calculated quantity.
    /// </returns>
    public Qty referenceTotalDestructiveQty()
    {
        InventQualityOrderTable   inventQualityOrderTable;
        InventTestDiscriminatingInventDims  discriminatingInventoryDim;

        discriminatingInventoryDim = InventItemSampling::find(this.ItemSamplingId).DiscriminatingInventoryDimensions;

        select  sum(Qty) from inventQualityOrderTable
                where   inventQualityOrderTable.InventRefId == this.InventRefId &&
                        inventQualityOrderTable.InventRefTransId == this.InventRefTransId &&
                        inventQualityOrderTable.OprNum == this.OprNum &&
                        inventQualityOrderTable.RouteOprId == this.RouteOprId &&
                        inventQualityOrderTable.ReferenceType == this.ReferenceType &&
                        inventQualityOrderTable.WrkCtrId == this.WrkCtrId &&
                        inventQualityOrderTable.RecId != this.RecId &&
                        inventQualityOrderTable.TestDestructive == true &&
    	             (!discriminatingInventoryDim ||
                        inventQualityOrderTable.InventDimId == this.InventDimId);

        return inventQualityOrderTable.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTestResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the test result based on the results for the individual lines.
    /// </summary>
    public void setTestResult()
    {
        RecIdCount countInclude = this.includedTestLinesCount();

        RecIdCount countFailure = this.failingIncludedTestLinesCount();

        if (countInclude && countFailure)
        {
            if (this.AcceptableQualityLevel &&
               (100 - (100 * countFailure / countInclude)) < this.AcceptableQualityLevel)
            {
                this.OrderStatus = InventTestOrderStatus::Fail;
            }
            else
            {
                this.OrderStatus = InventTestOrderStatus::Pass;
            }
        }
        else if (countInclude)
        {
            this.OrderStatus = InventTestOrderStatus::Pass;
        }
        else
        {
            this.OrderStatus = InventTestOrderStatus::Fail;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>includedTestLinesCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the count of included test lines in this quality order.
    /// </summary>
    /// <returns>The count of included test lines in this quality order.</returns>
    protected RecIdCount includedTestLinesCount()
    {
        Query query = this.buildIncludedQulaityOrderTestLinesQuery();
        QueryRun queryRun = new QueryRun(query);
        return SysQuery::countTotal(queryRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>failingIncludedTestLinesCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the count of failing test lines included in this quality order.
    /// </summary>
    /// <returns>The count of failing test lines included in this quality order.</returns>
    protected RecIdCount failingIncludedTestLinesCount()
    {
        Query query = this.buildFailingIncludedQulaityOrderTestLinesQuery();
        QueryRun queryRun = new QueryRun(query);
        return SysQuery::countTotal(queryRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildIncludedQulaityOrderTestLinesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query to find the included test lines in this quality order.
    /// </summary>
    /// <returns>The query to find the included test lines in this quality order.</returns>
    protected Query buildIncludedQulaityOrderTestLinesQuery()
    {
        Query query = new Query();

        QueryBuildDataSource qbdsQualityOrderLine = query.addDataSource(tableNum(InventQualityOrderLine));
        
        qbdsQualityOrderLine.fields().clearFieldList();
        qbdsQualityOrderLine.fields().addField(fieldNum(InventQualityOrderLine, RecId));

        qbdsQualityOrderLine.addRange(fieldNum(InventQualityOrderLine, QualityOrderId)).value(queryValue(this.QualityOrderId));
        qbdsQualityOrderLine.addRange(fieldNum(InventQualityOrderLine, IncludeResults)).value(queryValue(NoYes::Yes));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFailingIncludedQulaityOrderTestLinesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query to find the failing test lines included in this quality order.
    /// </summary>
    /// <returns>The query to find the failing test lines included in this quality order.</returns>
    protected Query buildFailingIncludedQulaityOrderTestLinesQuery()
    {
        Query query = this.buildIncludedQulaityOrderTestLinesQuery();

        QueryBuildDataSource qbdsQualityOrderLine = query.dataSourceTable(tableNum(InventQualityOrderLine));
        
        qbdsQualityOrderLine.addRange(fieldNum(InventQualityOrderLine, TestResult)).value(queryValue(InventTestOutcomeStatus::Fail));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>statusDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>InventTestOrderStatusDisplay</c> value that corresponds to the status of the order.
    /// </summary>
    /// <returns>
    /// A status display of the <c>InventTestOrderStatusDisplay</c> value.
    /// </returns>
    public InventTestOrderStatusDisplay statusDisplay()
    {
        if (!InventParameters::find().UseQualityManagement ||
            !hasFieldAccess(tableNum(InventQualityOrderTable),
                            fieldNum(InventQualityOrderTable, OrderStatus),
                            AccessType::View))
            return InventTestOrderStatusDisplay::None;

        return InventQualityOrderTable::orderStatus2OrderStatusDisplay(this.OrderStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Overrides the standard update method.
    /// </summary>
    /// <param name="_dropEstimated">
    ///    A <c>NoYes</c> enumeration value that determines whether the related inventory transactions should
    ///    be updated; optional.
    /// </param>
    /// <param name="_updateReservation">
    ///    A <c>NoYes</c> enumeration value that determines whether the items should be reserved; optional.
    /// </param>
    public void update(
        NoYes   _dropEstimated      = NoYes::No,
        NoYes   _updateReservation  = NoYes::Yes)
    { 
        if (InventQualityOrderValidateProcessingUpdateContext::isInInventQualityOrderUpdateRecordScope())
        {
            super();
            return;
		}

        InventUpd_Estimated             estimated;
        boolean                         inventoryUpdateNeeded;
        boolean                         inventBlockingUpdateNeeded;
        InventBlockingQualityOrderSync  inventBlockingQualityOrderSync;
        InventQualityOrderTable         orig = this.orig();
        InventQty                       oldBlockingQty  = orig.BlockingQty;
        PdsCWInventQty                  oldBlockingCWQty = orig.PdsCWBlockingQty;
        InventStatusBlockingHelper      statusBlockingHelper;

        ttsbegin;

        inventoryUpdateNeeded = this.TestDestructive    != orig.TestDestructive
                                || this.Qty             != orig.Qty
                                || this.PdsCWQty        != orig.PdsCWQty
                                || this.InventDimId     != orig.InventDimId;

        inventBlockingUpdateNeeded = inventoryUpdateNeeded && InventQualityReferenceType::newFromQualityOrder(this).supportsInventoryBlocking();

        if (inventBlockingUpdateNeeded)
        {
            // Update BlockingQuantity field value with quality order quantity value if blocking is not complete
            if (this.Qty != orig.Qty && this.CompleteBlocking == NoYes::No)
            {
                this.BlockingQty = this.Qty;
            }
            if (this.PdsCWQty != orig.PdsCWQty && this.CompleteBlocking == NoYes::No)
            {
                this.PdsCWBlockingQty = this.PdsCWQty;
            }
            if (this.TestDestructive && this.CompleteBlocking == NoYes::No)
            {
                this.BlockingQty = 0;
                this.PdsCWBlockingQty = 0;
            }
            else if (orig.TestDestructive // TestDestructive has been disabled - so blocking might be needed again.
                 && !(this.TestDestructive && this.CompleteBlocking == NoYes::Yes  && this.BlockingQty > 0)) // Don't change as this means blocking quantity is controlled elsewhere - like per updated quantity
            {
                this.initBlockingQty();
            }

            inventBlockingQualityOrderSync = InventBlockingQualityOrderSync::construct();

            if (this.InventDimId != orig.InventDimId)
            {
                using (var relatedInfo = InventBlockingRelatedTransactionInfoSingleton::instance().init(this))
                {
                    inventBlockingQualityOrderSync.onQualityOrderBlockingRequestDelete(this); // Remove old blocking so it can be recreated later
                    oldBlockingQty = 0;
                }
            }
            else if (oldBlockingQty > this.BlockingQty)
            {
                if (this.BlockingQty == 0)
                {
                    using (var relatedInfo = InventBlockingRelatedTransactionInfoSingleton::instance().init(this))
                    {
                        inventBlockingQualityOrderSync.onQualityOrderBlockingRequestDelete(this); // Nothing blocked any more
                    }
                }
                else
                {
                    inventBlockingQualityOrderSync.onQualityOrderBlockingQtyReduce(this);   // Reduce blocked quantity
                }
            }
        }

        statusBlockingHelper = InventStatusBlockingHelper::construct(InventMovement::construct(this));

        statusBlockingHelper.preUpdate();

        if (this.TestDestructive && !this.InventTransId)
        {
            this.InventTransId = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
        }

        if (! _dropEstimated && this.InventTransId)
        {
            estimated = InventUpd_Estimated::newInventMovement(InventMovement::construct(this));
            estimated.updateNow();
        }

        super();

        if (inventBlockingUpdateNeeded && this.BlockingQty > 0)
        {
            // Update related inventory blocking
            inventBlockingQualityOrderSync = InventBlockingQualityOrderSync::construct();   // make new instance as cached values might be outdated.
            if (oldBlockingQty == 0)
            {
                inventBlockingQualityOrderSync.onQualityOrderBlockingRequestCreate(this);
            }
            else
            {
                inventBlockingQualityOrderSync.onQualityOrderBlockingQtyIncrease(this);
            }
        }

        statusBlockingHelper.postUpdate();

        if (_updateReservation)
        {
            if (estimated)
            {
                estimated.updateReservation();
            }
        }

        if (orig.PdsUpdateBatchDisp &&
            !this.PdsUpdateBatchDisp &&
            this.inventBatchId() &&
            !PdsUpdateDispositionStatus_Quality::newQuality(this).checkOpenQualityOrder())
        {
            warning(strfmt("@SCM:LastQualityOrderNoBatchDispositionUpdate", this.ItemId, this.inventBatchId()));
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::IsCompanyEnabled() && this.taxRecalculationNeeded(orig))
        {
            this.markCurrentTaxDocumentTaxStatusDirty();
        }
        // </GTE>
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean ret;
        // <GIN>
        #ISOCountryRegionCodes
        // </GIN>

        ret = super(_fieldIdToCheck);

        switch (_fieldIdToCheck)
        {
            case fieldNum(InventQualityOrderTable, AcceptableQualityLevel):
                ret = ret && checkPercentage(this.AcceptableQualityLevel);
                break;

            case fieldNum(InventQualityOrderTable, TestDestructive):
                if (this.RecId
                 && this.ReferenceType == InventTestReferenceType::Sales
                 && SalesLine::findInventTransId(this.InventRefTransId).SalesStatus == SalesStatus::Invoiced)
                {
                    ret = checkFailed("@SYS113822");
                }
                else if (this.RecId
                      && this.ReferenceType == InventTestReferenceType::Purch
                      && (PurchLine::findInventTransId(this.InventRefTransId).isOpenOrder()
                      ||  PurchLine::findInventTransId(this.InventRefTransId).isCanceled()))
                    {
                        ret = checkFailed("@SYS113832");
                    }
                else if (this.RecId
                      && this.ReferenceType == InventTestReferenceType::Quarantine)
                {
                    ret = checkFailed("@SYS113837");
                }
                break;

            case fieldNum(InventQualityOrderTable, ItemId):
                if (!InventTable::find(this.ItemId).isStocked())
                {
                    ret = checkFailed("@SYS190617");
                }
                break;

            // <GIN>
            case fieldNum(InventQualityOrderTable, ApplyIndiaTaxes_IN):
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                {
                    switch (this.ApplyIndiaTaxes_IN)
                    {
                        case ApplyIndiaTaxes_IN::VAT:
                            if (!TaxParameters::find().vat_in)
                            {
                                ret = checkFailed(strFmt("@GLS5131", this.ApplyIndiaTaxes_IN));
                            }
                            break;

                        case ApplyIndiaTaxes_IN::Excise:
                            if (!TaxParameters::find().Excise_IN)
                            {
                                ret = checkFailed(strFmt("@GLS5131", this.ApplyIndiaTaxes_IN));
                            }
                            break;

                        case ApplyIndiaTaxes_IN::Both:
                            if (!TaxParameters::find().vat_in || !TaxParameters::find().Excise_IN)
                            {
                                ret = checkFailed("@GLS60829");
                            }
                            break;
                    }
                }
                break;
            // </GIN>
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;

        ret = super();

        if (!InventParameters::find().UseQualityManagement)
        {
            ret = checkFailed("@SYS114218");
        }

        if (ret
            && InventTable::isItemCatchWeightAndWarehouseProcessEnabled(this.ItemId)
            && this.UpdateInventStatus == NoYes::Yes
            && !WHSInventTable::ensureInventoryStatusChangedAllowedForItem(this.ItemId))
        {
            ret = false;
        }

        if (ret
            && #PmfEnabled
            && !InventTable::pmfCheckAllowQuality(this.ItemId))
        {
            ret = checkFailed("@PRO1980");
        }

        if (ret
            && #PdsShelfEnabled
            && (this.PdsPassQualityDispositionCode
                || this.PdsFailedQualityDispositionCode)
            && (!this.PdsPassQualityDispositionCode
                || !this.PdsFailedQualityDispositionCode))
        {
            warning("@PDS1162");
        }

        if (ret && this.RecId
            && !InventQualityOrderTableValidator::newFromQualityOrderTable(this).checkQty())
        {
            ret = false;
        }

        if (this.UpdateInventStatus && !(this.FailedInventStatusId || this.PassedInventStatusId))
        {
            ret = checkFailed(strFmt("@SYS50087",
                fieldPName(InventQualityOrderTable, FailedInventStatusId),
                fieldPName(InventQualityOrderTable, PassedInventStatusId)));
        }

        if (this.isAssociatedToProcessingWave())
        {
            ret = checkFailed(strFmt("@WAX:QualityOrderTiedToErroredWaveError", this.QualityOrderId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsIsForWorkGeneratingProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if this quality order is for a WHS process which can generate work.
    /// </summary>
    /// <returns>
    /// true if the quality order is for a process which can generate work; otherwise, false.
    /// </returns>
    public boolean whsIsForWorkGeneratingProcess()
    {
        boolean ret = true;

        ret = ret && WHSInventEnabled::exist(this.ItemId);
        ret = ret && this.inventDim().inventLocation().whsEnabled;
        ret = ret && WHSInvent::canInventTransTypeHaveWork(InventQualityOrderTable::referenceType2TransType(this.ReferenceType));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNoOpenQualityOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks that there are no quality orders open that are relevant to a table buffer with some
    /// information relevant to quality orders.
    /// </summary>
    /// <param name="_common">
    /// A <c>Common</c> buffer.
    /// </param>
    /// <returns>
    /// true if there are no open quality orders; otherwise, false.
    /// </returns>
    public static boolean checkNoOpenQualityOrders(Common _common)
    {
        boolean ok = true;

        if (InventQualityOrderTable::referenceDocumentStatusDisplay(_common) == InventTestOrderStatusDisplay::Open)
        {
            ok = checkFailed("@SYS113800");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified record in the <c>InventQualityOrderTable</c> table exists.
    /// </summary>
    /// <param name="_qualityOrderId">
    ///    The quality order ID of the record to find.
    /// </param>
    /// <returns>
    ///    true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean exist(InventQualityOrderId _qualityOrderId)
    {
        return _qualityOrderId &&
            (select   firstonly  inventQualityOrderTable
             where  inventQualityOrderTable.QualityOrderId == _qualityOrderId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsForReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether any record for a specific reference exists in the <c>InventQualityOrderTable</c> table.
    /// </summary>
    /// <param name="_referenceType">
    ///    The reference type for which to check record existance.
    /// </param>
    /// <param name="_referenceId">
    ///    The reference id for which to check record existance.
    /// </param>
    /// <returns>
    ///    true if a record exists; otherwise, false.
    /// </returns>
    internal static boolean existsForReference(InventTestReferenceType _referenceType, InventRefId _referenceId)
    {
        InventQualityOrderTable inventQualityOrderTable;

        select firstonly RecId from inventQualityOrderTable
        where inventQualityOrderTable.InventRefId    == _referenceId
            && inventQualityOrderTable.ReferenceType == _referenceType;

        return inventQualityOrderTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>InventQualityOrderTable</c> table.
    /// </summary>
    /// <param name="_qualityOrderId">
    ///    The quality order ID of the record to find.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    ///    A record in the <c>InventQualityOrderTable</c> table; otherwise, an empty record.
    /// </returns>
    public static InventQualityOrderTable find(
        InventQualityOrderId    _qualityOrderId,
        boolean                 _forUpdate      = false)
    {
        InventQualityOrderTable inventQualityOrderTable;

        inventQualityOrderTable.selectForUpdate(_forUpdate);

        if (_qualityOrderId)
        {
            select firstonly    inventQualityOrderTable
            where   inventQualityOrderTable.QualityOrderId == _qualityOrderId;
        }

        return inventQualityOrderTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryLastClosedQualityOrderForAssociation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query to find a quality order that matches the specified parameters and that was closed last.
    /// </summary>
    /// <param name="_associationTable">
    /// The required <c>InventTestAssociationTable</c> record to match.
    /// </param>
    /// <param name="_inventRefId">
    /// The required <c>InventRefID</c> field for the quality order.
    /// </param>
    /// <param name="_inventTransId">
    /// The required <c>InventTransID</c> field for the quality order.
    /// </param>
    /// <param name="_itemId">
    /// The required item for the quality order.
    /// </param>
    /// <param name="_referenceType">
    /// The required reference type for the quality order.
    /// </param>
    /// <param name="_routeOprId">
    /// The required route operation for the quality order.
    /// </param>
    /// <param name="_oprNum">
    /// The required <c>OprNum</c> field for the quality order.
    /// </param>
    /// <returns>
    /// An <c>Query</c> object.
    /// </returns>
    protected static Query buildQueryLastClosedQualityOrderForAssociation(
        InventTestAssociationTable  _associationTable,
        InventRefId                 _inventRefId,
        InventTransId               _inventTransId,
        ItemId                      _itemId,
        InventTestReferenceType     _referenceType,
        RouteOprId                  _routeOprId,
        OprNum                      _oprNum)
    {
        Query query = new Query();

        QueryBuildDataSource qbdsOrderTable = query.addDataSource(tableNum(InventQualityOrderTable));

        qbdsOrderTable.firstOnly(true);

        qbdsOrderTable.addOrderByField(fieldNum(InventQualityOrderTable, ValidatedDateTime), SortOrder::Descending);

        qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, ReferenceType)).value(queryValue(_referenceType));
        qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, ItemId)).value(queryValue(_itemId));
        qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, OrderStatus)).value('!' + queryValue(InventTestOrderStatus::Open));
        qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, TestGroupId)).value(queryValue(_associationTable.TestGroupId));
        
        if(_inventTransId)
        {
            qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, InventRefTransId)).value(queryValue(_inventTransId));
        }
        if(_inventRefId)
        {
            qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, InventRefId)).value(queryValue(_inventRefId));
        }
        if(_routeOprId)
        {
            qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, RouteOprId)).value(queryValue(_routeOprId));
        }
        if(_oprNum != minInt())
        {
            qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, OprNum)).value(queryValue(_oprNum));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastClosedQualityOrderForAssociation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a quality order that matches the specified parameters and that was closed last.
    /// </summary>
    /// <param name="_associationTable">
    /// The required <c>InventTestAssociationTable</c> record to match.
    /// </param>
    /// <param name="_inventRefId">
    /// The required <c>InventRefID</c> field for the quality order.
    /// </param>
    /// <param name="_inventTransId">
    /// The required <c>InventTransID</c> field for the quality order.
    /// </param>
    /// <param name="_itemId">
    /// The required item for the quality order.
    /// </param>
    /// <param name="_referenceType">
    /// The required reference type for the quality order.
    /// </param>
    /// <param name="_routeOprId">
    /// The required route operation for the quality order.
    /// </param>
    /// <param name="_oprNum">
    /// The required <c>OprNum</c> field for the quality order.
    /// </param>
    /// <returns>
    /// An <c>InventQualityOrderTable</c> record; otherwise, an empty record.
    /// </returns>
    public static InventQualityOrderTable findLastClosedQualityOrderForAssociation(
        InventTestAssociationTable  _associationTable,
        InventRefId                 _inventRefId,
        InventTransId               _inventTransId,
        ItemId                      _itemId,
        InventTestReferenceType     _referenceType,
        RouteOprId                  _routeOprId       = '',
        OprNum                      _oprNum           = minInt())
    {
        Query query = InventQualityOrderTable::buildQueryLastClosedQualityOrderForAssociation(_associationTable, _inventRefId, _inventTransId, _itemId, _referenceType, _routeOprId, _oprNum);

        QueryRun queryRun = new QueryRun(query);

        if (queryRun.next())
        {
            return queryRun.get(tableNum(InventQualityOrderTable));
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastClosedQualityOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a quality order that matches the specified parameters and that was closed last.
    /// </summary>
    /// <param name="_testGroupId">
    /// The required test group for the quality order.
    /// </param>
    /// <param name="_inventRefId">
    /// The required <c>InventRefID</c> field for the quality order.
    /// </param>
    /// <param name="_inventTransId">
    /// The required <c>InventTransID</c> field for the quality order.
    /// </param>
    /// <param name="_itemId">
    /// The required item for the quality order.
    /// </param>
    /// <param name="_referenceType">
    /// The required reference type for the quality order.
    /// </param>
    /// <param name="_routeOprId">
    /// The required route operation for the quality order; optional.
    /// </param>
    /// <param name="_oprNum">
    /// The required <c>OprNum</c> field for the quality order; optional.
    /// </param>
    /// <returns>
    /// An <c>InventQualityOrderTable</c> record; otherwise, an empty record.
    /// </returns>
    [SysObsolete("Use findLastClosedQualityOrderForAssociation instead.", false, 31\03\2018)]
    public static InventQualityOrderTable findLastClosedQualityOrder(
        InventTestGroupId           _testGroupId,
        InventRefId                 _inventRefId,
        InventTransId               _inventTransId,
        ItemId                      _itemId,
        InventTestReferenceType     _referenceType,
        RouteOprId                  _routeOprId         = '',
        OprNum                      _oprNum             = minInt())
    {
        InventQualityOrderTable     orderTable;

        select firstonly orderTable
            order by ValidatedDateTime desc
            where   orderTable.ReferenceType        == _referenceType
                 && (orderTable.InventRefTransId    == _inventTransId   || !_inventTransId)
                 && (orderTable.InventRefId         == _inventRefId     || !_inventRefId)
                 && (orderTable.RouteOprId          == _routeOprId      || !_routeOprId)
                 && (orderTable.OprNum              == _oprNum          || (_oprNum == minInt()))
                 && orderTable.ItemId               == _itemId
                 && orderTable.OrderStatus          != InventTestOrderStatus::Open
                 && orderTable.TestGroupId          == _testGroupId;

        return orderTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastQualityOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a quality order that matches the parameters and that is ordered by status.
    /// </summary>
    /// <param name="_referenceType">
    /// The required reference type for the quality order.
    /// </param>
    /// <param name="_inventRefId">
    /// The required <c>InventRefID</c> field for the quality order; optional.
    /// </param>
    /// <param name="_inventTransId">
    /// The required <c>InventTransID</c> field for the quality order; optional.
    /// </param>
    /// <param name="_itemId">
    /// The required item for the quality order; optional.
    /// </param>
    /// <param name="_routeOprId">
    /// The required route operation for the quality order; optional.
    /// </param>
    /// <param name="_oprNum">
    /// The required <c>OprNum</c> field for the quality order; optional.
    /// </param>
    /// <param name="_includeRoutes">
    /// A Boolean that controls whether quality orders on related routes are included; optional.
    /// </param>
    /// <returns>
    /// An <c>InventQualityOrderTable</c> record; otherwise, an empty record.
    /// </returns>
    public static InventQualityOrderTable findLastQualityOrder(
        InventTestReferenceType    _referenceType,
        InventRefId                _inventRefId      = '',
        InventTransId              _inventTransId    = '',
        ItemId                     _itemId           = '',
        RouteOprId                 _routeOprId       = '',
        OprNum                     _oprNum           = minInt(),
        boolean                    _includeRoutes    = false)
    {
        InventQualityOrderTable     orderTable;

        select firstonly orderTable
            order by OrderStatus
            where   (orderTable.ReferenceType       == _referenceType    ||
                    (orderTable.ReferenceType       == InventTestReferenceType::RouteOpr && _includeRoutes))
                 && (orderTable.InventRefTransId    == _inventTransId    || !_inventTransId)
                 && (orderTable.InventRefId         == _inventRefId      || !_inventRefId)
                 && (orderTable.RouteOprId          == _routeOprId       || !_routeOprId)
                 && (orderTable.OprNum              == _oprNum           || (_oprNum == minInt()))
                 && (orderTable.ItemId              == _itemId           || !_itemId);

        return orderTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryOpenQualityOrderForAssociation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object to find a quality order that matches the parameters and is still open.
    /// </summary>
    /// <param name="_associationTable">
    /// The required <c>InventTestAssociationTable</c> record to match.
    /// </param>
    /// <param name="_inventRefId">
    /// The required <c>InventRefID</c> field for the quality order.
    /// </param>
    /// <param name="_inventTransId">
    /// The required <c>InventTransID</c> field for the quality order.
    /// </param>
    /// <param name="_itemId">
    /// The required item for the quality order.
    /// </param>
    /// <param name="_referenceType">
    /// The required reference type for the quality order.
    /// </param>
    /// <param name="_routeOprId">
    /// The required route operation for the quality order.
    /// </param>
    /// <param name="_oprNum">
    /// The required operation num for the quality order.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to select found record for update.
    /// </param>
    /// <returns>
    /// An <c>Query</c> object.
    /// </returns>
    protected static Query buildQueryOpenQualityOrderForAssociation(
        InventTestAssociationTable  _associationTable,
        InventRefId                 _inventRefId,
        InventTransId               _inventTransId,
        ItemId                      _itemId,
        InventTestReferenceType     _referenceType,
        RouteOprId                  _routeOprId,
        OprNum                      _oprNum,
        boolean                     _forUpdate)
    {
        Query query = new Query();

        QueryBuildDataSource qbdsOrderTable = query.addDataSource(tableNum(InventQualityOrderTable));
        qbdsOrderTable.update(_forUpdate);

        qbdsOrderTable.firstOnly(true);

        qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, ReferenceType)).value(queryValue(_referenceType));
        qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, ItemId)).value(queryValue(_itemId));
        qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, OrderStatus)).value(queryValue(InventTestOrderStatus::Open));
        qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, TestGroupId)).value(queryValue(_associationTable.TestGroupId));
        
        if(_inventTransId)
        {
            qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, InventRefTransId)).value(queryValue(_inventTransId));
        }
        if(_inventRefId)
        {
            qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, InventRefId)).value(queryValue(_inventRefId));
        }
        if(_routeOprId)
        {
            qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, RouteOprId)).value(queryValue(_routeOprId));
        }
        if(_oprNum != minInt())
        {
            qbdsOrderTable.addRange(fieldNum(InventQualityOrderTable, OprNum)).value(queryValue(_oprNum));
        }
        
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOpenQualityOrderForAssociation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a quality order that matches the parameters and that is still open.
    /// </summary>
    /// <param name="_associationTable">
    /// The required <c>InventTestAssociationTable</c> record to match.
    /// </param>
    /// <param name="_inventRefId">
    /// The required <c>InventRefID</c> field for the quality order.
    /// </param>
    /// <param name="_inventTransId">
    /// The required <c>InventTransID</c> field for the quality order.
    /// </param>
    /// <param name="_itemId">
    /// The required item for the quality order.
    /// </param>
    /// <param name="_referenceType">
    /// The required reference type for the quality order.
    /// </param>
    /// <param name="_routeOprId">
    /// The required route operation for the quality order.
    /// </param>
    /// <param name="_oprNum">
    /// The required operation num for the quality order.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to select found record for update.
    /// </param>
    /// <returns>
    /// An <c>InventQualityOrderTable</c> record; otherwise, an empty record.
    /// </returns>
    public static InventQualityOrderTable findOpenQualityOrderForAssociation(
        InventTestAssociationTable  _associationTable,
        InventRefId                 _inventRefId,
        InventTransId               _inventTransId,
        ItemId                      _itemId,
        InventTestReferenceType     _referenceType,
        RouteOprId                  _routeOprId       = '',
        OprNum                      _oprNum           = minInt(),
        boolean                     _forUpdate       = false)
    {
        Query query = InventQualityOrderTable::buildQueryOpenQualityOrderForAssociation(_associationTable, _inventRefId, _inventTransId, _itemId, _referenceType, _routeOprId, _oprNum, _forUpdate);

        QueryRun queryRun = new QueryRun(query);

        if (queryRun.next())
        {
            return queryRun.get(tableNum(InventQualityOrderTable));
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findQualityOrderForAssociationByItemSampling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a quality order that matches the parameters and that is still open.
    /// </summary>
    /// <param name="_associationTable">
    /// The required <c>InventTestAssociationTable</c> record to match.
    /// </param>
    /// <param name="_inventDimParm">
    /// The required <c>InventDimParm</c> record to match.
    /// </param>
    /// <param name="_inventDimParmLine">
    /// The required <c>InventDim</c> record to match.
    /// </param>
    /// <param name="_inventRefId">
    /// The required <c>InventRefID</c> field for the quality order.
    /// </param>
    /// <param name="_inventTransId">
    /// The required <c>InventTransID</c> field for the quality order.
    /// </param>
    /// <param name="_itemId">
    /// The required item for the quality order.
    /// </param>
    /// <param name="_referenceType">
    /// The required reference type for the quality order.
    /// </param>
    /// <param name="_routeOprId">
    /// The required route operation for the quality order.
    /// </param>
    /// <param name="_oprNum">
    /// The required operation num for the quality order.
    /// </param>
    /// <returns>
    /// An <c>InventQualityOrderTable</c> record; otherwise, an empty record.
    /// </returns>
    internal static InventQualityOrderTable findQualityOrderForAssociationByItemSampling(
        InventTestAssociationTable  _associationTable,
        InventDimParm               _inventDimParm,
        InventDim                   _inventDimParmLine,
        InventRefId                 _inventRefId,
        InventTransId               _inventTransId,
        ItemId                      _itemId,
        InventTestReferenceType     _referenceType,
        RouteOprId                  _routeOprId       = '',
        OprNum                      _oprNum           = minInt())
    {
        InventQualityOrderTable inventQualityOrderTable;
        InventDim inventDim;

        select firstonly inventQualityOrderTable
            where inventQualityOrderTable.ReferenceType == _referenceType
                && inventQualityOrderTable.ItemId  == _itemId
                && inventQualityOrderTable.TestGroupId == _associationTable.TestGroupId
                && (inventQualityOrderTable.InventRefTransId == _inventTransId || !_inventTransId)
                && (inventQualityOrderTable.InventRefId == _inventRefId || !_inventRefId)
                && (inventQualityOrderTable.RouteOprId == _routeOprId || !_routeOprId)
                && (inventQualityOrderTable.OprNum == _oprNum || _oprNum == minInt())
            #inventDimExistsJoin(inventQualityOrderTable.inventDimId, inventDim, _inventDimParmLine, _inventDimParm);

        return inventQualityOrderTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOpenQualityOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a quality order that matches the parameters and that is still open.
    /// </summary>
    /// <param name="_testGroupId">
    /// The required test group for the quality order.
    /// </param>
    /// <param name="_inventRefId">
    /// The required <c>InventRefID</c> field for the quality order.
    /// </param>
    /// <param name="_inventTransId">
    /// The required <c>InventTransID</c> field for the quality order.
    /// </param>
    /// <param name="_itemId">
    /// The required item for the quality order.
    /// </param>
    /// <param name="_referenceType">
    /// The required reference type for the quality order.
    /// </param>
    /// <param name="_routeOprId">
    /// The required route operation for the quality order; optional.
    /// </param>
    /// <param name="_oprNum">
    /// The required operation num for the quality order; optional
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to select found record for update; optional.
    /// </param>
    /// <returns>
    /// An <c>InventQualityOrderTable</c> record; otherwise, an empty record.
    /// </returns>
    [SysObsolete("Use findOpenQualityOrderForAssociation instead.", false, 31\03\2018)]
    public static InventQualityOrderTable findOpenQualityOrder(
        InventTestGroupId           _testGroupId,
        InventRefId                 _inventRefId,
        InventTransId               _inventTransId,
        ItemId                      _itemId,
        InventTestReferenceType     _referenceType,
        RouteOprId                  _routeOprId       = '',
        OprNum                      _oprNum           = minInt(),
        boolean                     _forUpdate       = false)
    {
        InventQualityOrderTable     orderTable;

        orderTable.selectForUpdate(_forUpdate);

        select orderTable
            where   orderTable.ReferenceType        == _referenceType
                 && (orderTable.InventRefTransId    == _inventTransId   || !_inventTransId)
                 && (orderTable.InventRefId         == _inventRefId     || !_inventRefId)
                 && (orderTable.RouteOprId          == _routeOprId      || !_routeOprId)
                 && (orderTable.OprNum              == _oprNum          || (_oprNum == minInt()))
                 && orderTable.ItemId               == _itemId
                 && orderTable.OrderStatus          == InventTestOrderStatus::Open
                 && orderTable.TestGroupId          == _testGroupId;

        return orderTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSalesPurchRefTransId_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in <c>InventQualityOrderTable</c> table.
    /// </summary>
    /// <param name="_inventRefTransId">
    /// The inventory reference transaction ID of the <c>InventQualityOrderTable</c> record.
    /// </param>
    /// <param name="_referenceType">
    /// The reference type of the <c>InventQualityOrderTable</c> record.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>InventQualityOrderTable</c> table; otherwise, an empty record.
    /// </returns>
    public static InventQualityOrderTable findSalesPurchRefTransId_IN(
        InventRefTransId        _inventRefTransId,
        InventTestReferenceType _referenceType,
        boolean                 _forUpdate = false)
    {
        InventQualityOrderTable inventQualityOrderTable;

        if (_inventRefTransId
            && (_referenceType == InventTestReferenceType::Sales
            ||  _referenceType == InventTestReferenceType::Purch))
        {
            inventQualityOrderTable.selectForUpdate(_forUpdate);

            select firstonly inventQualityOrderTable
                where inventQualityOrderTable.InventRefTransId == _inventRefTransId
                   && inventQualityOrderTable.ReferenceType    == _referenceType;
        }

        return inventQualityOrderTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupProductionforRouteOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a lookup dialog box for selecting a production related to a production route.
    /// </summary>
    /// <param name="_lookupCtrl">
    /// The control that the user initiates the lookup from.
    /// </param>
    static public void lookupProductionforRouteOperation(FormStringControl _lookupCtrl)
    {
        Query                   query;
        QueryBuildDataSource    queryBuildDataSourceProd;
        QueryBuildDataSource    queryBuildDataSourceRoute;
        ProdLookup              prodLookup;

        query = new Query();
        queryBuildDataSourceProd = query.addDataSource(tableNum(ProdTable));
        queryBuildDataSourceProd.addRange(fieldNum(ProdTable, ProdStatus)); // Needed by ProdLookup

        // only show productions with a route
        queryBuildDataSourceRoute = queryBuildDataSourceProd.addDataSource(tableNum(ProdRoute));
        queryBuildDataSourceRoute.relations(true);
        queryBuildDataSourceRoute.joinMode(JoinMode::ExistsJoin);

        prodLookup = new ProdLookup(_lookupCtrl, query);
        prodLookup.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>openDestructiveTestOrderExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether open destructive quality orders exist for a specified reference.
    /// </summary>
    /// <param name="_referenceType">
    ///    The type of the reference.
    /// </param>
    /// <param name="_inventRefId">
    ///    The actual reference ID.
    /// </param>
    /// <param name="_inventTransId">
    ///    The inventory transaction ID for the reference; optional.
    /// </param>
    /// <returns>
    ///    true if an open destructive quality order exists; otherwise, false.
    /// </returns>
    static public boolean openDestructiveTestOrderExists(
        InventTestReferenceType _referenceType,
        InventRefId             _inventRefId,
        InventTransId           _inventTransId = '')
    {
        InventQualityOrderTable inventQualityOrderTable;

        select firstonly RecId from inventQualityOrderTable
            where   inventQualityOrderTable.ReferenceType       == _referenceType
                 && inventQualityOrderTable.InventRefId         == _inventRefId
                 && (inventQualityOrderTable.InventRefTransId   == _inventTransId || !_inventTransId)
                 && inventQualityOrderTable.TestDestructive     == NoYes::Yes
                 && inventQualityOrderTable.OrderStatus         == InventTestOrderStatus::Open;

        return inventQualityOrderTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openProductionQualityOrderExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether open quality orders that are related to a specified production order exist.
    /// </summary>
    /// <param name="_prodId">
    ///    The ID of the production order.
    /// </param>
    /// <returns>
    ///    true if open quality orders exist; otherwise, false.
    /// </returns>
    static public boolean openProductionQualityOrderExists(ProdId _prodId)
    {
        InventQualityOrderTable inventQualityOrderTable;

        select firstonly RecId from inventQualityOrderTable
            where  (inventQualityOrderTable.ReferenceType       == InventTestReferenceType::Production
                 || inventQualityOrderTable.ReferenceType       == InventTestReferenceType::RouteOpr)
                 && inventQualityOrderTable.InventRefId         == _prodId
                 && inventQualityOrderTable.OrderStatus         == InventTestOrderStatus::Open;

        return inventQualityOrderTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderStatus2OrderStatusDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the <c>InventTestOrderStatus</c> type to the <c>InventTestOrderStatusDisplay</c> type.
    /// </summary>
    /// <param name="_orderStatus">
    /// The <c>InventTestOrderStatus</c> value to convert.
    /// </param>
    /// <returns>
    /// The corresponding <c>InventTestOrderStatusDisplay</c> type.
    /// </returns>
    public static InventTestOrderStatusDisplay orderStatus2OrderStatusDisplay(InventTestOrderStatus _orderStatus)
    {
        if (_orderStatus == InventTestOrderStatus::Open)
        {
            return InventTestOrderStatusDisplay::Open;
        }
        return InventTestOrderStatusDisplay::Closed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>referenceDocumentStatusDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>InventTestOrderStatusDisplay</c> value that is most pressing among quality orders that
    /// match a reference document.
    /// </summary>
    /// <param name="_buffer">
    /// A <c>Common</c> buffer that stores a reference document.
    /// </param>
    /// <returns>
    /// An <c>InventTestOrderStatusDisplay</c> status display.
    /// </returns>
    public static InventTestOrderStatusDisplay referenceDocumentStatusDisplay(Common _buffer)
    {
        InventQualityReferenceType referenceType = InventQualityReferenceType::newFromBuffer(_buffer);
        InventQualityOrderTable    orderTable = InventQualityOrderTable::findLastQualityOrder(
            referenceType.referenceType(),
            referenceType.inventRefId(),
            referenceType.inventTransId(),
            referenceType.itemId(),
            referenceType.routeOprId(),
            referenceType.oprNum(),
            referenceType.referenceType() == InventTestReferenceType::Production);

        return orderTable ? orderTable.statusDisplay() : InventTestOrderStatusDisplay::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTestReferenceType2InventTransTypeExtensionConverting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for conversion of <c>InventTestReferenceType</c> to <c>InventTransType</c>.
    /// </summary>
    /// <param name = "_referenceType">The <c>InventTestReferenceType</c> to convert.</param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the conversion result.</param>
    static delegate void inventTestReferenceType2InventTransTypeExtensionConverting(InventTestReferenceType _referenceType, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>referenceType2TransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts an <c>InventTestReferenceType</c> enumeration value to an <c>InventTransType</c>
    /// enumeration value.
    /// </summary>
    /// <param name="_referenceType">
    /// The <c>InventTestReferenceType</c> enumeration that will be converted.
    /// </param>
    /// <returns>
    /// An <c>InventTransType</c> enumeration that corresponds to the specified
    /// <c>InventTestReferenceType</c> enumeration type.
    /// </returns>
    public static InventTransType referenceType2TransType(InventTestReferenceType _referenceType)
    {
        switch (_referenceType)
        {
            case InventTestReferenceType::RouteOpr
                ,InventTestReferenceType::Production:
                return InventTransType::Production;
            case InventTestReferenceType::PmfProdCoBy:
                return InventTransType::PmfProdCoBy;
            case InventTestReferenceType::Purch:
                return InventTransType::Purch;
            case InventTestReferenceType::Quarantine
                ,InventTestReferenceType::Inventory:
                return InventTransType::QuarantineOrder;
            case InventTestReferenceType::Sales:
                return InventTransType::Sales;
            default:
                var eventHandlerResult = EventHandlerResult::newSingleResponse();
                InventQualityOrderTable::inventTestReferenceType2InventTransTypeExtensionConverting(_referenceType, eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }

                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowUpdateBatchDisposition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether allow to update disposition status.
    /// </summary>
    /// <returns>
    /// Return true to allow to update disposition status, otherwise false.
    /// </returns>
    public boolean allowUpdateBatchDisposition()
    {
        return this.inventBatchId()
            && this.PdsUpdateBatchDisp == NoYes::Yes
            && (this.PdsFailedQualityDispositionCode != ''
                || this.PdsPassQualityDispositionCode != '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateQuarantineOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether quarantine order should be created in quality order validation.
    /// </summary>
    /// <returns>
    ///    true if quarantine order should be created; otherwise, false.
    /// </returns>
    public boolean mustCreateQuarantineOrder()
    {
        return this.QuarantineOnFailure == NoYes::Yes && this.OrderStatus == InventTestOrderStatus::Fail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQualityOrderLineTestResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates test results of all quality order lines associated with this quality order.
    /// </summary>
    public void updateQualityOrderLineTestResult()
    {
        InventQualityOrderLine  inventQualityOrderLine;

        ttsBegin;
        while select forUpdate inventQualityOrderLine
            where inventQualityOrderLine.QualityOrderId == this.QualityOrderId
        {
            inventQualityOrderLine.setTestResult();
            inventQualityOrderLine.write();
        }
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markCurrentTaxDocumentTaxStatusDirty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark current tax status of <c> InventQualityOrderTable </c> to dirty
    /// </summary>
    // <GTE>
    private void markCurrentTaxDocumentTaxStatusDirty()
    {
        TaxableDocumentDescriptor   descriptor      = TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(this);
        ITaxableDocument            taxableDocument = TaxableDocumentObject::construct(descriptor);

        TaxBusinessService::markTaxDocumentTaxStatus(taxableDocument, TaxDocumentCalculationLevel::Dirty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxRecalculationNeeded</Name>
				<Source><![CDATA[
    // </GTE>

    /// <summary>
    /// Determines whether a change to the <c>InventQualityOrderTable</c> table will update the Tax
    /// </summary>
    /// <param name="_origTransactionTable">
    /// The <c>InventQualityOrderTable</c> record.
    /// </param>
    /// <returns>True if current line tax should be recalculated, otherwise false </returns>
    private boolean taxRecalculationNeeded(Common _origTransactionTable = null)
    {
        InventQualityOrderTable   inventQualityOrderTable_Orig;
        boolean                   updateNeeded;

        if (_origTransactionTable)
        {
            inventQualityOrderTable_Orig = _origTransactionTable as InventQualityOrderTable;
        }
        else
        {
            inventQualityOrderTable_Orig = this.orig();
        }

        updateNeeded = (this.Qty != inventQualityOrderTable_Orig.Qty);

        return updateNeeded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsQualityOrderInventory</Name>
				<Source><![CDATA[
    private boolean existsQualityOrderInventory()
    {
        WHSQualityOrderInventory qualityOrderInventory;

        select firstonly RecId from qualityOrderInventory
            where qualityOrderInventory.QualityOrderId == this.QualityOrderId;

        return qualityOrderInventory.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean ret = super();
        WHSWorkTable workTable;

        // When removing the toggle, change the code to invoke WHSWorkTable::existsActiveWorkByQualityOrder() method.
        select firstonly RecId from workTable
            where workTable.InventQualityOrderId == this.QualityOrderId
                && workTable.WorkStatus != WHSWorkStatus::Cancelled
                && workTable.WorkStatus != WHSWorkStatus::Closed;

        if (workTable.RecId)
        {
            ret = checkFailed(strFmt("@WAX:WHSQualityOrderCannotBeDeletedWarning", this.QualityOrderId));
        }
    
        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>InventQualityManagement</ConfigurationKey>
	<DeveloperDocumentation>@SYS124049</DeveloperDocumentation>
	<Label>@SYS113839</Label>
	<SingularLabel>@SYS113617</SingularLabel>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>QualityOrderId</TitleField1>
	<TitleField2>ItemName</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>QualityOrderIdIdx</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<CreatedTransactionId>Yes</CreatedTransactionId>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<ModifiedTransactionId>Yes</ModifiedTransactionId>
	<Modules>Inventory</Modules>
	<PrimaryIndex>QualityOrderIdIdx</PrimaryIndex>
	<ReplacementKey>QualityOrderIdIdx</ReplacementKey>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>InventQualityOrderLine</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>InventQualityOrderLine</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>QualityOrderId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReferenceType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventRefId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventRefTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidatedByWorker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidatedDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RouteOprId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OprNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WrkCtrId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AcceptableQualityLevel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestDestructive</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemSamplingId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>QualityOrderId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>QualityOrderId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CaseMoreInformation</Name>
			<Label>@SYS314356</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>QualityOrderId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReferenceType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimension</Name>
			<Label>@SYS5951</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS53631</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>QualityOrderId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>IdentificationCreate</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>QualityOrderId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>InventStatus</Name>
			<Label>@WAX355</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>UpdateInventStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FailedInventStatusId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PassedInventStatusId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>NonConformanceRef</Name>
			<Label>@SYS113831</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>inventNonConformanceID</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@SYS9039</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>QualityOrderId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OrderStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PdsBatchAttribMgmt</Name>
			<Label>@PDS1025</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PdsUpdateInvBatchAttributes</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PdsDispositionCode</Name>
			<Label>@PDS1164</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PdsUpdateBatchDisp</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsFailedQualityDispositionCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsPassQualityDispositionCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>References</Name>
			<Label>@SYS14018</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReferenceType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventRefId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventRefTransId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OprNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RouteOprId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>WrkCtrId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RouteId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Relations</Name>
			<Label>@SYS80613</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountRelation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestGroupId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Sampling</Name>
			<Label>@SYS62577</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemSamplingId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Specifications</Name>
			<Label>@SYS17781</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AcceptableQualityLevel</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TestDestructive</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QuarantineOnFailure</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ApplyIndiaTaxes_IN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Status</Name>
			<Label>@SYS36398</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OrderStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidatedByWorker</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidatedDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>System</Name>
			<Label>@SYS4278</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventDimId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ValidatedDate_IN</Name>
			<Label>@GLS60821</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ValidateDate_IN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AcceptableQualityLevel</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventAcceptableQualityLevel</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountRelation</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTestAccountRelation</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ApplyIndiaTaxes_IN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>ApplyIndiaTaxes_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>BlockingQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventQty</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CompleteBlocking</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventBlockingComplete</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventSiteLinkedDimensionValueSet</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>FailedInventStatusId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTestFailedInventStatusId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<StringSize>20</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventRefId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventRefId</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventRefTransId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventRefTransId</ExtendedDataType>
			<StringSize>20</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventTransId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<StringSize>20</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemIdInventoried</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
			<StringSize>20</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemName</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemName</ExtendedDataType>
			<StringSize>60</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemSamplingId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventItemSamplingId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>OprNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>OprNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OrderStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>InventTestOrderStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PassedInventStatusId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTestPassedInventStatusId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PdsCWBlockingQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsCWInventBlockingQty</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PdsCWQty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsCWInventQualityOrderQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PdsFailedQualityDispositionCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsFailedQualityDispositionCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PdsPassQualityDispositionCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsPassQualityDispositionCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PdsUpdateBatchDisp</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsUpdateBatchDisp</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PdsUpdateInvBatchAttributes</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsUpdateInvBatchAttributes</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Qty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventQualityOrderQty</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>QualityOrderId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventQualityOrderId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
			<StringSize>15</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>QuarantineOnFailure</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTestQuarantineOnFailure</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReferenceType</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>InventTestReferenceType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RouteId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RouteId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<StringSize>20</StringSize>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RouteOprId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RouteOprId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TestDestructive</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTestDestructive</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TestGroupId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTestGroupId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UpdateInventStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTestUpdateInventStatus</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ValidateDate_IN</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@GLS60821</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ValidatedByWorker</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>HcmWorkerRecId</ExtendedDataType>
			<Label>@SYS113827</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ValidatedDateTime</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDateTime</ExtendedDataType>
			<Label>@SYS113829</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>WrkCtrId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>WrkCtrIdBase</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>QualityOrderIdIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>QualityOrderId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventDimIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ItemReferenceTypeIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ReferenceType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventRefId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>OrderStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TestGroupId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>RefIdTypeRefTransIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventRefId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ReferenceType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventRefTransId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventTransIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>DimensionDefaultMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>DefaultDimension</MapField>
					<MapFieldTo>DefaultDimension</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalLineExtension_IN</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>AssessableValue</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>AssessableValueAccountingCurrency</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CompanyLocation</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CreditNoteDate</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CustomsMaxRetailPrice</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CustomsTariffCodeTable</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DirectSettlement</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DSA</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExciseRecordType</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExciseTariffCodes</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExciseType</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>MaximumRetailPrice</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesTaxFormTypes</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ServiceCodeRefRecId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAsPerOriginalInvoice</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxInformation</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxWithholdTCSGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxWithholdTDSGroup</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalLine</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryLocation</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryState</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventDimId</MapField>
					<MapFieldTo>InventDimId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventTransId</MapField>
					<MapFieldTo>InventTransId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemId</MapField>
					<MapFieldTo>ItemId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineNum</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchQty</MapField>
					<MapFieldTo>Qty</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchUnit</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceId</MapField>
					<MapFieldTo>QualityOrderId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>TableId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxItemGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TransDate</MapField>
					<MapFieldTo>ValidateDate_IN</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalTable</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>InclTax</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Posted</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>TableId</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation>
			<Name>CustTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123523</EntityRelationshipRole>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::Sales</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DefaultDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>DefaultDimension_InventQualityOrderTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>FailedInventStatus</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSInventStatus</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>FailedInventStatus</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FailedInventStatusId</Name>
					<SourceEDT>InventTestFailedInventStatusId</SourceEDT>
					<Field>FailedInventStatusId</Field>
					<RelatedField>InventStatusId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventStatusIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>HcmWorker</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>HcmWorker_InventQualityOrderTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ValidatedByWorker</Name>
					<Field>ValidatedByWorker</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimId</Name>
					<Field>InventDimId</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventItemSampling</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventItemSampling</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemSamplingId</Name>
					<Field>ItemSamplingId</Field>
					<RelatedField>InventItemSamplingId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventItemSamplingIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventQuarantineOrder</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123857</EntityRelationshipRole>
			<RelatedTable>InventQuarantineOrder</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::Quarantine</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefId</Name>
					<Field>InventRefId</Field>
					<RelatedField>QuarantineId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ItemIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTestGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTestGroup</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TestGroupId</Name>
					<Field>TestGroupId</Field>
					<RelatedField>TestGroupId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TestGroupIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOrigin</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransId</Name>
					<Field>InventTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventTransIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PassedInventStatus</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>WHSInventStatus</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PassedInventStatus</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PassedInventStatusId</Name>
					<SourceEDT>InventTestPassedInventStatusId</SourceEDT>
					<Field>PassedInventStatusId</Field>
					<RelatedField>InventStatusId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>InventStatusIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PdsFailedDispositionCode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PdsDispositionMaster</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PdsFailedDispositionCode</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>InventQualityOrderTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PdsFailedQualityDispositionCode</Name>
					<Field>PdsFailedQualityDispositionCode</Field>
					<RelatedField>DispositionCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PdsPassDispositionCode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PdsDispositionMaster</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PdsPassDispositionCode</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>InventQualityOrderTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PdsPassQualityDispositionCode</Name>
					<Field>PdsPassQualityDispositionCode</Field>
					<RelatedField>DispositionCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PmfProdCoBy</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@PRO2391</EntityRelationshipRole>
			<RelatedTable>PmfProdCoBy</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::PmfProdCoBy</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefId</Name>
					<Field>InventRefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefTransId</Name>
					<Field>InventRefTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdRoute</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124050</EntityRelationshipRole>
			<RelatedTable>ProdRoute</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProdRoute</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>InventQualityOrderTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::RouteOpr</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefId</Name>
					<Field>InventRefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OprNum</Name>
					<Field>OprNum</Field>
					<RelatedField>OprNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RouteOprId</Name>
					<Field>RouteOprId</Field>
					<RelatedField>OprId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123840</EntityRelationshipRole>
			<RelatedTable>ProdTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::Production</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefId</Name>
					<Field>InventRefId</Field>
					<RelatedField>ProdId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PurchLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123841</EntityRelationshipRole>
			<RelatedTable>PurchLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::Purch</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefId</Name>
					<Field>InventRefId</Field>
					<RelatedField>PurchId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefTransId</Name>
					<Field>InventRefTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PurchParmLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123866</EntityRelationshipRole>
			<RelatedTable>PurchParmLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefTransId</Name>
					<Field>InventRefTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefId</Name>
					<Field>InventRefId</Field>
					<RelatedField>OrigPurchId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::Purch</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PurchTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123518</EntityRelationshipRole>
			<RelatedTable>PurchTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::Purch</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>OrderAccount</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefId</Name>
					<Field>InventRefId</Field>
					<RelatedField>PurchId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RouteOprTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RouteOprTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RouteOprId</Name>
					<Field>RouteOprId</Field>
					<RelatedField>OprId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>OprIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RouteTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RouteTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RouteId</Name>
					<Field>RouteId</Field>
					<RelatedField>RouteId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>NumIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesLine</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123843</EntityRelationshipRole>
			<RelatedTable>SalesLine</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::Sales</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefId</Name>
					<Field>InventRefId</Field>
					<RelatedField>SalesId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefTransId</Name>
					<Field>InventRefTransId</Field>
					<RelatedField>InventTransId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>SalesTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123519</EntityRelationshipRole>
			<RelatedTable>SalesTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::Sales</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>CustAccount</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventRefId</Name>
					<Field>InventRefId</Field>
					<RelatedField>SalesId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123524</EntityRelationshipRole>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>ReferenceType</Name>
					<Field>ReferenceType</Field>
					<ValueStr>InventTestReferenceType::Purch</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountRelation</Name>
					<Field>AccountRelation</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>WrkCtrTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WrkCtrTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>WrkCtrId</Name>
					<Field>WrkCtrId</Field>
					<RelatedField>WrkCtrId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>WrkCtrIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxEngineQualityOrderTableHeader</Name>
			<Cardinality>OneMore</Cardinality>
			<RelatedTable>TaxEngineQualityOrderTableHeader</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>QualityOrderId</Name>
					<Field>QualityOrderId</Field>
					<RelatedField>QualityOrderId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>