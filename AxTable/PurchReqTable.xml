<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchReqTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class PurchReqTable extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>areLinesPartiallyDistributed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether any lines that are partially distributed exist.
    /// </summary>
    /// <returns>
    /// true if there are partially distributed lines; otherwise false.
    /// </returns>
    /// <remarks>
    /// A line can be either not distributed, partially distributed, or fully distributed.This method will
    /// return true if any lines that have distributions that are not fully distributed.
    /// </remarks>
    public boolean areLinesPartiallyDistributed()
    {
        PurchReqLine    purchReqLine;
        boolean         ret;

        while select purchReqLine where purchReqLine.PurchReqTable == this.RecId
        {
            if (purchReqLine.doDistributionsExist())
            {
                ret = ret || !purchReqLine.isFullyDistributed();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditProjectFieldsOnLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the project fields can be edited on requisition lines.
    /// </summary>
    /// <returns>
    /// true if the project fields can be edited on the requisition lines; otherwise, false.
    /// </returns>
    public boolean canEditProjectFieldsOnLine()
    {
        return this.isConsumption();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRecordBudgetFundReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the budget fund reservation can be recorded for a purchase requisition.
    /// </summary>
    /// <returns>
    /// true if the recording is possible; otherwise, false.
    /// </returns>
    public boolean canRecordBudgetFundReservation()
    {
        using (SysInstrumentationActivityContext activityContext = PurchReqTable::instrumentationLogger().requisition().canRecordBudgetFundReservation(this))
        {
            if (!this.isConsumption())
            {
                return false;
            }

            if (this.canRecordPreEncumbrance())
            {
                return true;
            }
            //Check if budget should be reserved
            if (this.RequisitionStatus == PurchReqRequisitionStatus::Approved)
            {
                if (this.notPostedLineExists())
                {
                    return true;
                }
            }
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRecordPreEncumbrance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the pre encumbrance can be recorded for a purchase requisition.
    /// </summary>
    /// <returns>
    /// true if the recording is possible; otherwise, false.
    /// </returns>
    public boolean canRecordPreEncumbrance()
    {
        LedgerParameters    ledgerParameters;
        PurchReqLine        purchReqLine;
        CompanyInfo         companyInfo;

        PurchReqInstrumentationLogger purchReqInstrumentationLogger = PurchReqTable::instrumentationLogger();

        using (SysInstrumentationActivityContext activityContext = purchReqInstrumentationLogger.requisition().canRecordPreEncumbrance(this))
        {
            if (this.RequisitionStatus == PurchReqRequisitionStatus::Approved
                && this.isConsumption())
            {
                using (SysInstrumentationActivityContext activityContextLine = purchReqInstrumentationLogger.requisition().canRecordPreEncumbranceLine(this))
                {
                    select firstOnly crossCompany count(RecId)  from purchReqLine
                        where purchReqLine.PurchReqTable                == this.RecId
                              &&  purchReqLine.RequisitionStatus        == PurchReqRequisitionStatus::Approved
                              &&  purchReqLine.IsPreEncumbranceRequired == UnknownNoYes::Unknown
                        exists join companyInfo
                            where companyInfo.RecId == purchReqLine.BuyingLegalEntity
                        exists join ledgerParameters 
                            where ledgerParameters.dataAreaId == companyInfo.DataArea
                               && LedgerParameters.IsPreEncumbranceProcessEnabled == NoYes::Yes;

                    activityContextLine.addCustomProperty('NumberOfLines', int2Str(purchReqLine.RecId));

                    if (!purchReqLine.RecId
                        && PurchReqPurchaseOrderGenerationLoggerFlight::instance().isEnabled())
                    {
                        PurchReqLine pruchReqLineLocal;

                        while select pruchReqLineLocal
                            where purchReqLine.PurchReqTable == this.RecId
                        {
                            using (SysInstrumentationActivityContext activityContextLineDetail = purchReqInstrumentationLogger.requisition().canRecordPreEncumbranceLineDetail(pruchReqLineLocal))
                            {
                                LedgerParameters ledgerParametersLocal;
                                CompanyInfo companyInfoLocal;

                                select firstonly ledgerParametersLocal
                                    exists join companyInfo
                                    where companyInfo.RecId == purchReqLine.BuyingLegalEntity
                                        && ledgerParameters.dataAreaId == companyInfo.DataArea;

                                activityContextLineDetail
                                    .addCustomProperty(tableStr(LedgerParameters), int642Str(ledgerParametersLocal.RecId))
                                    .addCustomProperty('IsPreEncumbranceProcessEnabled', int2Str(ledgerParametersLocal.IsPreEncumbranceProcessEnabled));
                            }
                        }
                    }

                    return purchReqLine.RecId;
                }
            }

            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canResetToDraftStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the purchase requisition can be reset to draft state.
    /// </summary>
    /// <returns>
    /// true if the status of the purchase requisition can be reset to draft; otherwise, false.
    /// </returns>
    public boolean canResetToDraftStatus()
    {
        if (this.RequisitionStatus == PurchReqRequisitionStatus::Approved)
        {
            if (PurchReqLineProcessingError::existAccountingError(this.RecId))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSubmit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a purchase requisition can be submitted to the workflow by the current user.
    /// </summary>
    /// <returns>
    /// true if a purchase requisition can be submitted to the workflow by the current user; otherwise,
    /// false.
    /// </returns>
    public boolean canSubmit()
    {
        PurchReqLine    purchReqLine;

        if (this.RequisitionStatus != PurchReqRequisitionStatus::Draft)
        {
            return false;
        }

        if (this.Originator != HcmWorkerLookup::currentWorker())
        {
            return false;
        }

        select firstonly RecId from purchReqLine where purchReqLine.PurchReqTable == this.RecId;

        if (!purchReqLine)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSubmitToWorkflow</Name>
				<Source><![CDATA[
    public boolean canSubmitToWorkflow(str _workflowType = '')
    {
        boolean ret;

        if (_workflowType == workFlowTypeStr(PurchReqReview))
        {
            ret = this.canSubmit();
        }
        else
        {
            ret = super(_workflowType);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTransferBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the budget can be transferred to another dimension value.
    /// </summary>
    /// <returns>
    /// true if the can be transferred; otherwise, false.
    /// </returns>
    public boolean canTransferBudget()
    {
        return this.isConsumption();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a record in the <c>PurchReqTable</c> table can be deleted.
    /// </summary>
    /// <param name="_throwInfo">
    /// A Boolean value that determines whether to display an Infolog message if the record cannot be
    /// deleted.
    /// </param>
    /// <returns>
    /// true if the record can be deleted; otherwise false.
    /// </returns>
    public boolean checkDelete(boolean _throwInfo)
    {
        boolean ret = true;

        if (this.RequisitionStatus == PurchReqRequisitionStatus::Draft)
        {
            if (this.Originator != HcmWorkerLookup::currentWorker() && !Global::isSystemAdministrator())
            {
                if (_throwInfo)
                {
                    ret = checkFailed(strFmt("@SYS339001", this.PurchReqId));
                }
                else
                {
                    ret = false;
                }
            }
        }
        else
        {
            if (_throwInfo)
            {
                ret = checkFailed(strFmt("@SYS333807", this.PurchReqId));
            }
            else
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdate</Name>
				<Source><![CDATA[
    public boolean checkUpdate()
    {
        boolean         ret = false;

        if (this.isInferredDraft())
        {
            ret = this.isPreparerCurrentWorker();
        }
        else if (this.RequisitionStatus == PurchReqRequisitionStatus::InReview)
        {
            ret = WorkflowWorkItem::isUserTaskOwner(this);

            if (!ret)
            {
                ret = WorkflowWorkItem::isUserApprovalOwner(this);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPreparerCurrentWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if current worker is also the preparer on the purchase requisition.
    /// </summary>
    /// <returns>true if current worker is the preparer; otherwise, false.</returns>
    private boolean isPreparerCurrentWorker()
    {
        return this.Originator == HcmWorkerLookup::currentWorker();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearProcessingErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears all purchase requisition line processing errors in the <c>PurchReqLineProcessingError</c> table.
    /// </summary>
    void clearProcessingErrors()
    {
        PurchReqLine                purchReqLine;
        PurchReqTable               purchReqTable;
        PurchReqLineProcessingError purchReqLineProcessingError;

        delete_from purchReqLineProcessingError
            exists join RecId from purchReqLine where purchReqLine.RecId == purchReqLineProcessingError.PurchReqLine
            join RecId from purchReqTable where purchReqTable.RecId == purchReqLine.PurchReqTable && purchReqTable.RecId == this.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createdByName</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(false)]
    public display Name createdByName()
    {
        return this.getPartyName(this.CreatedBy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createdDate</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(false)]
    public display DateDisplay createdDate()
    {
        return strFmt("%1",datetime2str(DateTimeUtil::applyTimeZoneOffset(this.CreatedDateTime, DateTimeUtil::getUserPreferredTimeZone()),DateFlags::FormatAll));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSourceDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the associated <c>SourceDocumentHeader</c> record.
    /// </summary>
    public void createSourceDocumentHeader()
    {
        SourceDocumentProcessorFacade::submitSourceDocumentImplementation(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCodeMST</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(false)]
    public display CurrencyCode currencyCodeMST()
    {
        return Ledger::accountingCurrency(CompanyInfo::current());
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the history exists for a record and deletes the necessary records.
    /// </summary>
    public void delete()
    {
        PurchReqTableInstrumentationActivities requisitionActivities = PurchReqTable::instrumentationLogger().requisition();
        
        using (var activityContext = requisitionActivities.delete(this))
        {
            PurchReqExternalSource  purchReqExternalSource;
            boolean                 ret = true;
            //<GIN>
            #ISOCountryRegionCodes
            //</GIN>

            ttsbegin;
            //delete any existing record in PurchReqExternalsource table
            delete_from purchReqExternalSource where purchReqExternalSource.PurchReqTable == this.RecId;

            if (TaxIntegrationUtils::isTransitDocumentEnabled())
            {
                this.TransitDocumentTransactionMap_IN::deleteTransitDocumentsForHeader();
            }

            requisitionActivities.logRequisition(activityContext, this);
        
            super();

            this.deleteSourceDocumentHeader();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSourceDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the associated <c>SourceDocumentHeader</c> record.
    /// </summary>
    public void deleteSourceDocumentHeader()
    {
        SourceDocumentHeader    sourceDocumentHeader;

        // delete any existing source document header record
        delete_from sourceDocumentHeader
        where sourceDocumentHeader.RecId == this.SourceDocumentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPurchReqProcessingResult</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays relevant icon for the purchase requisition based on status of line(s) on the requisition.
    /// </summary>
    /// <returns>
    ///     Container with the appropriate icon.
    /// </returns>
    [SysClientCacheDataMethodAttribute(false)]
    public display container displayPurchReqProcessingResult()
    {
        ImageReference                  imageReference;
        container                       imageContainer;

        PurchReqLineProcessingError     purchReqLineProcessingError;
        PurchReqLine                    purchReqLine;

        select firstonly RecId from purchReqLineProcessingError
            where     purchReqLineProcessingError.Type != PurchReqLineProcessingErrorType::BudgetWarning
            join purchReqLine where purchReqLine.RecId == purchReqLineProcessingError.PurchReqLine
                         && purchReqLine.PurchReqTable == this.RecId;

        if (purchReqLineProcessingError)
        {
            imageReference = ImageReference::constructForSymbol(ImageReferenceSymbol::Error);
        }
        else
        {
            select firstonly RecId from purchReqLineProcessingError
                where purchReqLineProcessingError.Type == PurchReqLineProcessingErrorType::BudgetWarning
                exists join purchReqLine where purchReqLine.RecId == purchReqLineProcessingError.PurchReqLine
                    && purchReqLine.PurchReqTable == this.RecId;

            if (purchReqLineProcessingError)
            {
                imageReference = ImageReference::constructForSymbol(ImageReferenceSymbol::Warning);
            }
            else if (this.RequisitionStatus == PurchReqRequisitionStatus::Approved || this.RequisitionStatus == PurchReqRequisitionStatus::Closed)
            {
                if (!this.notPostedLineExists())
                {
                    imageReference = ImageReference::constructForSymbol(ImageReferenceSymbol::Accept);
                }
            }
        }

        if (imageReference)
        {
            imageContainer = imageReference.pack();
        }

        return imageContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existFirmedLineForClosedLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there is any firmed order lines for requisition lines for the requisition.
    /// </summary>
    /// <returns>
    /// true if relations to firmed order lines exist; otherwise, false.
    /// </returns>
    public boolean existFirmedLineForClosedLine()
    {
        PurchReqLine                    purchReqLine;
        RequisitionLineFirmedOrderLine  requisitionLineFirmedOrderLine;

        select firstonly RecId from purchReqLine
            where purchReqLine.PurchReqTable == this.RecId
                && purchReqLine.RequisitionStatus == PurchReqRequisitionStatus::Closed
            exists join requisitionLineFirmedOrderLine
                where requisitionLineFirmedOrderLine.RequisitionLine == purchReqLine.RecId;

        return purchReqLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existPurchLine</Name>
				<Source><![CDATA[
    public boolean existPurchLine()
    {
        return (select RecId from purchReqLine where purchReqLine.PurchReqTable == this.RecId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existActiveByOriginator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there are any active purchase requisitions for specific originator.
    /// </summary>
    /// <param name="_originator">The reference originator of the <c>HcmWorker</c> record.</param>
    /// <returns>true if active purchase requisitions exist; otherwise, false.</returns>
    public static boolean existActiveByOriginator(PurchReqPreparerRefRecId _originator)
    {
        return (select firstonly RecId from PurchReqTable 
                    where PurchReqTable.Originator == _originator
                        && PurchReqTable.RequisitionStatus != PurchReqRequisitionStatus::Cancelled
                        && PurchReqTable.RequisitionStatus != PurchReqRequisitionStatus::Closed).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceCreate</Name>
				<Source><![CDATA[
    public void formMethodDataSourceCreate(FormRun _element, Object _purchReqtable_ds) //second parm must be of type object!
    {
        this.numberSeqFormHandlerPurchReqId(_element, _purchReqtable_ds).formMethodDataSourceCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceValidateWrite</Name>
				<Source><![CDATA[
    public boolean formMethodDataSourceValidateWrite(FormRun _element, Object _purchTable_ds)//Second parm must be Object
    {
        boolean ret = true;

        if (!this.numberSeqFormHandlerPurchReqId(_element, _purchTable_ds).formMethodDataSourceValidateWrite())
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceWrite</Name>
				<Source><![CDATA[
    public void formMethodDataSourceWrite(FormRun _element, Object _purchReqTable_ds)//Second parm must be object
    {
        this.numberSeqFormHandlerPurchReqId(_element, _purchReqTable_ds).formMethodDataSourceWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetCheckResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the <c>BudgetCheckResult</c> value for the given <c>PurchReqTable</c> record.
    /// </summary>
    /// <returns>
    /// A <c>BudgetCheckResult</c> value.
    /// </returns>
    public BudgetCheckResult getBudgetCheckResult()
    {
        BudgetSourceSourceDocumentHeader budgetSourceSourceDocumentHeader;

        budgetSourceSourceDocumentHeader = BudgetSourceSourceDocumentHeader::newBudgetSourceSourceDocumentHeader(this.SourceDocumentHeader);

        BudgetCheckResult checkResult = budgetSourceSourceDocumentHeader.getHeaderBudgetCheckResult(0, false);

        return checkResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPartyName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the name of the logged in user.
    /// </summary>
    /// <param name="_userId">
    /// The reference user of the <c>DirPersonUser</c> record.
    /// </param>
    /// <returns>
    /// The name of the user.
    /// </returns>

    public Name getPartyName(UserId _userId)
    {
        DirPartyTable   partyTable;
        HcmWorker       worker;
        Name            name;
        DirPersonUser   dirPersonUser;
        UserInfo        userInfo;

        if (_userId)
        {
            dirPersonUser = DirPersonUser::find(_userId);

            if (dirPersonUser.RecId)
            {
                partyTable = DirPartyTable::findRec(dirPersonUser.PersonParty);
                worker = HcmWorker::findByPerson(partyTable.RecId);

                name = partyTable.Name + ' (' + worker.PersonnelNumber + ') ';
            }
            else
            {
                select firstonly Name from userInfo where userInfo.Id == _userId;
                name = userInfo.Name + ' (' + _userId + ') ';
            }
        }
        return name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPurchReqTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PurchReqTable</c> record from the <c>PurchReqTable</c> record.
    /// </summary>
    /// <param name="_purchReqTable">
    /// The <c>PurchReqTable</c> record from which the values are to be initialized.
    /// </param>

    public void initFromPurchReqTable(PurchReqTable _purchReqTable)
    {
        this.PurchReqName               = _purchReqTable.PurchReqName;
        this.PurchReqType               = _purchReqTable.PurchReqType;
        this.RequiredDate               = _purchReqTable.RequiredDate;
        this.BusinessJustification      = _purchReqTable.BusinessJustification;
        this.RequisitionPurpose         = _purchReqTable.RequisitionPurpose;
        this.CompanyInfoDefault         = _purchReqTable.CompanyInfoDefault;
        this.ProjId                     = _purchReqTable.ProjId;
        this.ProjIdDataArea             = _purchReqTable.ProjIdDataArea;
        this.initTransDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRequisitionPurpose</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates the requisition purpose for the requisition.
    /// </summary>
    public void initRequisitionPurpose()
    {
        if (!this.ProjId)
        {
            this.RequisitionPurpose = RequisitionPurposeRule::findForCurrentCompany().DefaultRequisitionPurpose;
        }

        // TransDate might have a date assigned.
        if (!this.isConsumption())
        {
            this.TransDate = dateNull();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies default values to a transaction date field.
    /// </summary>
    public void initTransDate()
    {
        int64                       orgArray[];

        if (this.isConsumption())
        {
            orgArray[1] = CompanyInfo::findDataArea(curext()).RecId;

            if (PurchReqControlRule::findPurchReqControlRuleParameters(orgArray).IsReqDateTransDate)
            {
                this.TransDate = this.RequiredDate;
            }
            else
            {
                this.TransDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::getSystemDateTime(), DateTimeUtil::getUserPreferredTimeZone()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        super();

        this.Originator         = HcmWorkerLookup::currentWorker();

        this.RequisitionStatus  = PurchReqRequisitionStatus::Draft;

        this.RequiredDate       = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        if (this.isConsumption())
        {
            this.initTransDate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        PurchReqTableInstrumentationActivities requisitionActivities = PurchReqTable::instrumentationLogger().requisition();
        
        using (var activityContext = requisitionActivities.insert(this))
        {
            PurchReqBusJustification businessJustification;

            this.createSourceDocumentHeader();

            requisitionActivities.logRequisition(activityContext, this);

            super();

            ttsbegin;

            businessJustification.RefRecId    = this.RecId;
            businessJustification.RefTableId  = this.TableId;
            businessJustification.insert();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the purpose of the requisition is <c>RequisitionPurpose::Consumption</c>.
    /// </summary>
    /// <returns>
    /// true if the purpose of the requisition is <c>RequisitionPurpose::Consumption</c>; otherwise false.
    /// </returns>
    public boolean isConsumption()
    {
        return this.RequisitionPurpose == RequisitionPurpose::Consumption;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInferredDraft</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the record is to be treated as if it were in draft status.
    /// </summary>
    /// <returns>
    /// true if status is draft or rejected; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If a record is in rejected status, then at the time of resubmission, the workflow will start from
    /// scratch.
    /// </remarks>
    public boolean isInferredDraft()
    {
        if (this.RequisitionStatus == PurchReqRequisitionStatus::Draft)
        {
            return true;
        }

        if (this.RequisitionStatus == PurchReqRequisitionStatus::Rejected)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasBuyingLegalEntityWithBudgetControlEnabledForPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if for any of the purchase requisition lines,
    /// the buying legal entity has budget control enabled for purchase orders
    /// </summary>
    /// <returns>True, if for any of the purchase requisition lines,
    /// the buying legal entity has budget control enabled and active for purchase orders; false otherwise</returns>
    public boolean hasBuyingLegalEntityWithBudgetControlEnabledForPurchaseOrder()
    {
        using (SysInstrumentationActivityContext activityContext = PurchReqTable::instrumentationLogger().requisition().hasBuyingLegalEntityWithBudget(this))
        {
            boolean budgetControlConfigured = BudgetControlConfiguration::isControlConfigured();

            activityContext.addCustomProperty('BudgetControlConfigured', int2Str(budgetControlConfigured));

            if (!budgetControlConfigured)
            {
                return false;
            }

            PurchReqLine purchReqLine;
            boolean isLedgerBudgetControlEnabledForAnyLine;

            while select BuyingLegalEntity from purchReqLine
                group by BuyingLegalEntity
                    where purchReqLine.PurchReqTable == this.RecId
            {
                using (SysInstrumentationActivityContext activityContextBuyingLegalEntity = PurchReqTable::instrumentationLogger().requisition().buyingLegalEntity(this, purchReqLine.BuyingLegalEntity))
                {
                    Ledger ledger = Ledger::findByLegalEntity(purchReqLine.BuyingLegalEntity);

                    boolean isLedgerBudgetControlEnabledForPurchaseOrder  = ledger.IsBudgetControlEnabled
                        && BudgetControlConfiguration::isSourceIntegratorEnabled(ledger.RecId, BudgetControlSourceIntegrator::PurchaseOrder);

                    activityContextBuyingLegalEntity
                        .addCustomProperty(tableStr(Ledger), int642Str(ledger.RecId))
                        .addCustomProperty('BudgetControlEnabledLedger', int2Str(ledger.IsBudgetControlEnabled))
                        .addCustomProperty('BudgetControlEnabledHeader', int2Str(isLedgerBudgetControlEnabledForPurchaseOrder));

                    if (isLedgerBudgetControlEnabledForPurchaseOrder)
                    {
                        isLedgerBudgetControlEnabledForAnyLine = true;
                        break;
                    }
                }
            }

            activityContext.addCustomProperty('LedgerBudgetControlEnabled', int2Str(isLedgerBudgetControlEnabledForAnyLine));

            return isLedgerBudgetControlEnabledForAnyLine;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLinesFullyDistributed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether all lines on a purchase requisition are fully distributed.
    /// </summary>
    /// <returns>
    /// true if the lines are fully distributed; otherwise false.
    /// </returns>
    public boolean isLinesFullyDistributed()
    {
        PurchReqLine    purchReqLine;
        boolean         ret             = true;

        while select purchReqLine where purchReqLine.PurchReqTable == this.RecId
        {
            ret = ret && purchReqLine.isFullyDistributed();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRFQCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the RFQ against the purchase requisition is created.
    /// </summary>
    /// <returns>
    /// True if the RFQ is created; otherwise false.
    /// </returns>
    public boolean isRFQCreated()
    {
        PurchReqLine purchReqLine;

        select firstOnly RecId from purchReqLine
            where purchReqLine.PurchReqTable    == this.RecId
                && purchReqLine.PurchRFQCaseId  != '';

        return (purchReqLine.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUserApprovalOwner</Name>
				<Source><![CDATA[
    boolean isUserApprovalOwner()
    {
        WorkflowWorkItemTable   workflowWorkItemTable;
        WorkflowElementTable    workflowElementTable;

        select firstonly ElementId from workflowWorkItemTable
                    where   workflowWorkItemTable.RefTableId == this.TableId &&
                            workflowWorkItemTable.RefRecId   == this.RecId &&
                            workflowWorkItemTable.UserId     == curUserId() &&
                            workflowWorkItemTable.Status     == WorkflowWorkItemStatus::Pending
                join ElementId, ElementType from workflowElementTable
                    where   workflowElementTable.ElementId   == workflowWorkItemTable.ElementId &&
                            workflowElementTable.ElementType == WorkflowElementType::Approval;

        return workflowWorkItemTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUserTaskOwner</Name>
				<Source><![CDATA[
    boolean isUserTaskOwner()
    {
        WorkflowWorkItemTable   workflowWorkItemTable;
        WorkflowElementTable    workflowElementTable;

        select firstonly ElementId from workflowWorkItemTable
                    where   workflowWorkItemTable.RefTableId == this.TableId &&
                            workflowWorkItemTable.RefRecId   == this.RecId &&
                            workflowWorkItemTable.UserId     == curUserId() &&
                            workflowWorkItemTable.Status     == WorkflowWorkItemStatus::Pending
                join ElementId, ElementType from workflowElementTable
                    where   workflowElementTable.ElementId   == workflowWorkItemTable.ElementId &&
                            workflowElementTable.ElementType == WorkflowElementType::Task;

        return workflowWorkItemTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkflowOnPurchReqTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the workflow is on the <c>PurchReqTable</c> record.
    /// </summary>
    /// <returns>
    /// A Boolean value that indicates whether the workflow is on <c>PurchReqTable</c> record.
    /// </returns>
    /// <exception cref="M:exception::error">
    /// The <c>isWorkflowOnPurchReqTable</c> function has been incorrectly called.
    /// </exception>

    public boolean isWorkflowOnPurchReqTable()
    {
        PurchReqLine            purchReqLine;

        if (!this.RecId)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        select firstonly RecId from purchReqLine where
                purchReqLine.PurchReqTable == this.RecId;

        if (SysWorkflowTable::existContextRecId(purchReqLine.TableId, purchReqLine.RecId))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logBudgetErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Logs any errors from the budget framework in the <c>PurchReqLineProcessingError</c> table.
    /// </summary>
    public void logBudgetErrors()
    {
        PurchReqLine                        purchReqLine;
        BudgetSource                        budgetSource;
        BudgetCheckResultErrorWarningDetail budgetCheckResultErrorWarningDetail;
        PurchReqLineProcessingError         purchReqLineProcessingError;

        PurchReqLineProcessingErrorType     purchReqLineProcessingErrorType;

        // Remove any existing errors
        delete_from purchReqLineProcessingError where
            purchReqLineProcessingError.Type    == PurchReqLineProcessingErrorType::BudgetError     ||
            purchReqLineProcessingError.Type    == PurchReqLineProcessingErrorType::BudgetWarning
            exists join purchReqLine where
                purchReqLine.PurchReqTable      == this.RecId &&
                purchReqLine.RecId              == purchReqLineProcessingError.PurchReqLine;

        //Log any new errors
        while select RecId from purchReqLine where
            purchReqLine.PurchReqTable == this.RecId
            join * from budgetSource where
                budgetSource.SourceDocumentLine == purchReqLine.SourceDocumentLine
            outer join * from budgetCheckResultErrorWarningDetail where
                budgetCheckResultErrorWarningDetail.BudgetSource == budgetSource.RecId
        {
            switch (budgetSource.CheckResult)
            {
                case BudgetCheckResult::Failed :
                    purchReqLineProcessingErrorType = PurchReqLineProcessingErrorType::BudgetError;
                    break;
                case BudgetCheckResult::PassedWithWarnings :
                    purchReqLineProcessingErrorType = PurchReqLineProcessingErrorType::BudgetWarning;
                    break;
                default:
                    continue;
            }
            if (budgetCheckResultErrorWarningDetail)
            {
                PurchReqLineProcessingError::logProcessingError(purchReqLine.RecId, purchReqLineProcessingErrorType, strFmt('%1', budgetCheckResultErrorWarningDetail.displayBudgetCheckResultErrorWarning()));
            }
            else
            {
                PurchReqLineProcessingError::logProcessingError (purchReqLine.RecId, PurchReqLineProcessingErrorType::BudgetError, strFmt('%1', budgetSource.CheckResultErrorWarning));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logPreEncumbranceErrors</Name>
				<Source><![CDATA[
    public void logPreEncumbranceErrors()
    {
        #define.MaxParameters(15)

        SourceDocumentLineSubledgerJourErrorLog sourceDocumentLineErrorLog;
        SourceDocumentLine                      sourceDocumentLine;
        SubledgerJournalErrorLog                subledgerJournalErrorLog;
        PurchReqLine                            purchReqLine;

        str                                     parameters[#MaxParameters];
        int                                     i;
        anytype                                 parameter;

        str                                     errorDescription;

        // Get message from the log down to the input line
        while select crossCompany RecId from sourceDocumentLineErrorLog
            join RecId from sourceDocumentLine where
                sourceDocumentLine.RecId                == sourceDocumentLineErrorLog.SourceDocumentLine &&
                sourceDocumentLine.SourceDocumentHeader == this.SourceDocumentHeader
            join * from subledgerJournalErrorLog where
                subledgerJournalErrorLog.RecId == sourceDocumentLineErrorLog.SubledgerJournalErrorLog
            join RecId from purchReqLine where
                purchReqLine.SourceDocumentLine == sourceDocumentLine.RecId
        {
            errorDescription = SysLabel::labelId2String(subledgerJournalErrorLog.LabelId);

            for (i = 1; i <= #MaxParameters; i++)
            {
                // should not have type of enum, it should be a string id for the enum value
                Debug::assert(typeOf(conPeek(subledgerJournalErrorLog.Parameters, i)) != Types::Enum);

                if (typeOf(conPeek(subledgerJournalErrorLog.Parameters, i)) == Types::String)
                {
                    parameter = conPeek(subledgerJournalErrorLog.Parameters, i);
                    // enum values are stored as string ids (e.g. @SYSxxxxx)
                    // they need to be converted to text
                    if (SysLabel::isLabelId(parameter))
                    {
                        parameter = SysLabel::labelId2String(parameter);
                    }
                    parameters[i] = strFmt('%1', parameter);
                }
                else
                {
                    parameters[i] = strFmt('%1', conPeek(subledgerJournalErrorLog.Parameters, i));
                }
            }

            errorDescription = strFmt(errorDescription,
                                    parameters[1],
                                    parameters[2],
                                    parameters[3],
                                    parameters[4],
                                    parameters[5],
                                    parameters[6],
                                    parameters[7],
                                    parameters[8],
                                    parameters[9],
                                    parameters[10],
                                    parameters[11],
                                    parameters[12],
                                    parameters[13],
                                    parameters[14],
                                    parameters[15]
                                );

            PurchReqPreEncumber::logProcessingError(this.RecId, purchReqLine.RecId, errorDescription);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedByName</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(true)]
    public display Name modifiedByName()
    {
        return this.getPartyName(this.ModifiedBy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedDate</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(true)]
    public display DateDisplay modifiedDate()
    {
        return strFmt("%1",datetime2str(DateTimeUtil::applyTimeZoneOffset(this.ModifiedDateTime, DateTimeUtil::getUserPreferredTimeZone()),DateFlags::FormatAll));
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldValue</Name>
				<Source><![CDATA[
    public void modifiedFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        super(_fieldName, _arrayIndex);

        this.setDataAreaForModifiedField(fieldName2id(this.TableId, _fieldName));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtension</Name>
				<Source><![CDATA[
    public TableExtension getExtension()
    {
        return SysTableExtension::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultingDependencies</Name>
				<Source><![CDATA[
    public container getDefaultingDependencies()
    {
        // [field that needs defaulting, [fields that affect the default value]]
            
        return [
            [fieldNum(PurchReqTable, ProjId), [fieldNum(PurchReqTable, CompanyInfoDefault)]],
            [fieldNum(PurchReqTable, TransDate), [fieldNum(PurchReqTable, RequiredDate)]],
            [fieldNum(PurchReqTable, HoldExplanation), [fieldNum(PurchReqTable, OnHold)]],
            [fieldNum(PurchReqTable, ProjIdDataArea), [fieldNum(PurchReqTable, ProjId)]]
        ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    public void defaultField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(PurchReqTable, ProjId) :
                this.defaultProjId();
                break;

            case fieldNum(PurchReqTable, TransDate):
                this.defaultTransDate();
                break;

            case fieldNum(PurchReqTable, HoldExplanation):
                this.defaultHoldExplanation();
                break;

            case fieldNum(PurchReqTable, ProjIdDataArea):
                this.setDataAreaForModifiedField(FieldNum(PurchReqTable, ProjId));
                break;

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultProjId</Name>
				<Source><![CDATA[
    private void defaultProjId()
    {
        if (this.CompanyInfoDefault != this.orig().CompanyInfoDefault)
        {
            this.ProjId = '';
            this.setDataAreaForModifiedField(fieldNum(PurchReqTable, ProjId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultTransDate</Name>
				<Source><![CDATA[
    private void defaultTransDate()
    {
        int64 orgArray[];

        orgArray[1] = CompanyInfo::findDataArea(curext()).RecId;
        
        if (PurchReqControlRule::findPurchReqControlRuleParameters(orgArray).IsReqDateTransDate)
        {
            this.TransDate = this.RequiredDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultHoldExplanation</Name>
				<Source><![CDATA[
    private void defaultHoldExplanation()
    {
        if (this.OnHold != this.orig().OnHold)
        {
            this.HoldExplanation = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mostRecentComment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the last comment added to the task assigned to the <c>PurchReqTable</c> record.
    /// </summary>
    /// <returns>
    ///    A string that contains the most recent comment added to the task for the <c>PurchReqTable</c>
    ///    record.
    /// </returns>
    [SysClientCacheDataMethodAttribute(false)]
    public display PurchReqMostRecentComment mostRecentComment()
    {
        WorkflowTrackingCommentTable    workflowTrackingCommentTable;
        WorkflowWorkItemTable           workflowWorkItemTable;
        WorkflowTrackingTable           workflowTrackingTable;
        PurchReqMostRecentComment       comment;
        Name                            name;

        select firstonly workflowWorkItemTable
                    order by CreatedDateTime desc
                    where   workflowWorkItemTable.RefTableId == this.TableId &&
                            workflowWorkItemTable.RefRecId   == this.RecId &&
                            workflowWorkItemTable.Status     == WorkflowWorkItemStatus::Completed;

        workflowTrackingTable        = Workflow::findLastTrackingRecordForWorkItem(workflowWorkItemTable);
        workflowTrackingCommentTable = WorkflowTrackingCommentTable::findTrackingId(workflowTrackingTable.TrackingId);

        name = this.getPartyName(workflowTrackingTable.User) + ' : ';

        comment = strFmt("%1",datetime2str(DateTimeUtil::applyTimeZoneOffset(workflowTrackingCommentTable.CreatedDateTime, DateTimeUtil::getUserPreferredTimeZone()), DateFlags::FormatAll)) + ' ';
        comment += name;
        comment += workflowTrackingCommentTable.Comment;
        return comment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>notPostedLineExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether any lines are not confirmed or finalized.
    /// </summary>
    /// <returns>
    /// true if any lines are found that are not confirmed or finalized; otherwise, false.
    /// </returns>
    public boolean notPostedLineExists()
    {
        using (SysInstrumentationActivityContext activityContext = PurchReqTable::instrumentationLogger().requisition().notPostedLineExists(this))
        {
            PurchReqLine                        purchReqLine;
            SourceDocumentLine                  sourceDocumentLine;

            select RecId from sourceDocumentLine where
                sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Completed &&
                sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Finalized
                exists join purchReqLine where
                    purchReqLine.PurchReqTable      == this.RecId &&
                    sourceDocumentLine.RecId        == purchReqLine.SourceDocumentLine;

            activityContext.addCustomProperty(tableStr(SourceDocumentLine), int642Str(sourceDocumentLine.RecId));

            return sourceDocumentLine.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSeqFormHandlerPurchReqId</Name>
				<Source><![CDATA[
    public NumberSeqFormHandler numberSeqFormHandlerPurchReqId(FormRun _element, FormDataSource _purchReqTable_ds)
    {
        NumberSeqFormHandler numberSeqFormHandlerPurchReqId;

        numberSeqFormHandlerPurchReqId = NumberSeqFormHandler::newForm(PurchParameters::numRefPurchReqId().NumberSequenceId,
                                                                       _element,
                                                                       _purchReqTable_ds,
                                                                       fieldNum(PurchReqTable, PurchReqId)
                                                                       );

        return numberSeqFormHandlerPurchReqId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>originatorName</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(false)]
    public display PurchReqPreparerName originatorName()
    {
        Name    name;

        if (this.Originator)
        {
            name = HcmWorker::find(this.Originator).name();
        }

        return name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocHeaderTypeEnumName</Name>
				<Source><![CDATA[
    public EnumName parmSourceDocHeaderTypeEnumName()
    {
        return enumStr(SourceDocument_ProductRequisition);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocHeaderTypeEnumValue</Name>
				<Source><![CDATA[
    public SourceDocumentTypeEnumValue parmSourceDocHeaderTypeEnumValue()
    {
        return SourceDocument_ProductRequisition::PurchaseRequisition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performBudgetCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a budget check for the document.
    /// </summary>
    public void performBudgetCheck()
    {
        PurchReqInstrumentationLogger purchReqInstrumentationLogger = PurchReqTable::instrumentationLogger();

        using (var activityContext = purchReqInstrumentationLogger.requisition().performBudgetCheck(this))
        {
            if (!this.isConsumption())
            {
                return;
            }

            var PurchReqProcessState = PurchReqProcessState::instance();
            try
            {
                PurchReqProcessState.parmIsHeaderPerformBudgetCheckInProcess(true);

                using (var activityContextTotals = purchReqInstrumentationLogger.requisition().totals(this))
                {
                    // Make sure tax has been calculated before budget check.
                    PurchtotalsForm totalsForm =  PurchtotalsForm::newPurchTotalsForm(this);
                    totalsForm.calctotals();
                }

                if (PublicSectorUtils::isBudgetReservationEnabled())
                {
                    this.checkBudgetReservationBalance();
                }

                using (var activityContextSourceDocument = purchReqInstrumentationLogger.requisition().submitSourceDocument(this))
                {
                    SourceDocumentProcessorFacade::submitOnDemandSourceDocumentImpl(this);
                }

                using (var activityContextCheck = purchReqInstrumentationLogger.requisition().checkProjectBudgetForPurchReq(this))
                {
                    ProjectCommitmentFacade::checkProjectBudgetForPurchReq(this);
                }

                this.logBudgetErrors();
            }
            finally
            {
                PurchReqProcessState.parmIsHeaderPerformBudgetCheckInProcess(false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchReqLineCountLines</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(true)]
    public display PurchLineCount purchReqLineCountLines()
    {
        PurchReqLine purchReqLine;

        // Find number of lines on the purchase requisition
        select count(RecId) from purchReqLine where purchReqLine.PurchReqTable == this.RecId;

        return purchReqLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchSourceId</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(false)]
    public display PurchReqExternalSourceID purchSourceId()
    {
        return PurchReqExternalSource::findByPurchReq(this.RecId).ExternalSourceID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchSourceName</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(false)]
    public display PurchReqExternalSourceName purchSourceName()
    {
        return PurchReqExternalSource::findByPurchReq(this.RecId).ExternalSourceName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryPurchReqLine</Name>
				<Source><![CDATA[
    public Query queryPurchReqLine(boolean _update = false)
    {
        DictRelation    dictRelation;
        DictField       externdictField;
        DictField       dictField;
        Counter         c;
        Query           query = new Query();

        query.addDataSource(tableNum(PurchReqLine));

        dictRelation = new DictRelation(tableNum(PurchReqLine));
        dictRelation.loadTableRelation(this.TableId);

        if (dictRelation.lines())
        {
            for (c = 1; c <= dictRelation.lines(); c++)
            {
                externdictField = new DictField(this.TableId, dictRelation.lineExternTableValue(c));

                dictField = new DictField(tableNum(PurchReqLine), dictRelation.lineTableValue(c));

                query.dataSourceTable(tableNum(PurchReqLine)).addRange(dictField.id()).value(queryValue(this.(externdictField.id())));
            }
        }

        query.dataSourceTable(tableNum(PurchReqLine)).update(_update);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordBudgetFundReservation</Name>
				<Source><![CDATA[
    public void recordBudgetFundReservation()
    {
        using (var activityContextSourceDocument = PurchReqTable::instrumentationLogger().requisition().recordBudgetFundReservation(this))
        {
            PurchReqPreEncumber             purchReqPreEncumber;

            // Clear the existing processing errors before attempting to reserve budget funds.
            PurchReqLineProcessingError::deleteAllAccountingErrors(this.RecId);

            purchReqPreEncumber = PurchReqPreEncumber::construct();
            purchReqPreEncumber.parmPurchReqTable(this);
            purchReqPreEncumber.parmProcessingState(PurchReqProcessingState::Record);
            purchReqPreEncumber.parmShowResult(true);
            purchReqPreEncumber.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>requiredAction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the required action for the task assigned to the <c>PurchReqTable</c> record
    /// </summary>
    /// <returns>
    ///    A string that contains the required action.
    /// </returns>
    [SysClientCacheDataMethodAttribute(false)]
    public display PurchReqRequiredAction requiredAction()
    {
        WorkflowWorkItemTable   workflowWorkItemTable;
        PurchReqRequiredAction  text;

        select firstonly RecId from workflowWorkItemTable
                    where   workflowWorkItemTable.RefTableId == this.TableId &&
                            workflowWorkItemTable.RefRecId   == this.RecId &&
                            workflowWorkItemTable.UserId     == curUserId() &&
                            workflowWorkItemTable.Status     == WorkflowWorkItemStatus::Pending;

        if (workflowWorkItemTable.RecId)
        {
            switch (this.RequisitionStatus)
            {
                case PurchReqRequisitionStatus::InReview : text = "@SYS109902";
                    break;
                default :
            }
        }

        return text;
    }

]]></Source>
			</Method>
			<Method>
				<Name>requiredActionDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the due date for the required action on the <c>PurchReqTable</c> record
    /// </summary>
    /// <returns>
    ///    A string that contains the due date for the required action.
    /// </returns>
    [SysClientCacheDataMethodAttribute(false)]
    public display PurchReqRequiredActionDueDateStr requiredActionDueDate()
    {
        WorkflowWorkItemTable               workflowWorkItemTable;
        PurchReqRequiredActionDueDateStr    dueDateStr;

        select firstonly DueDateTime from workflowWorkItemTable
                    where   workflowWorkItemTable.RefTableId == this.TableId &&
                            workflowWorkItemTable.RefRecId   == this.RecId &&
                            workflowWorkItemTable.UserId     == curUserId() &&
                            workflowWorkItemTable.Status     == WorkflowWorkItemStatus::Pending;

        if (workflowWorkItemTable.DueDateTime != DateTimeUtil::minValue())
        {
            dueDateStr = strFmt("%1",datetime2str(DateTimeUtil::applyTimeZoneOffset(workflowWorkItemTable.DueDateTime, DateTimeUtil::getUserPreferredTimeZone()),DateFlags::FormatAll));
        }

        return dueDateStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDataAreaForModifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of the <c>DataArea</c> field if a corresponding field value is modified.
    /// </summary>
    /// <param name="_fieldId">
    ///    The field number in the <c>PurchReqTable</c> table.
    /// </param>
    public void setDataAreaForModifiedField(FieldId _fieldId)
    {
        switch (_fieldId)
        {
            case fieldNum(PurchReqTable, ProjId):
                if (!this.isFormDataSource() && this.CompanyInfoDefault && this.ProjId)
                {
                    this.ProjIdDataArea = CompanyInfo::findRecId(this.CompanyInfoDefault).DataArea;
                }
                else
                {
                    this.ProjIdDataArea = this.ProjId  ? getCompany(tableNum(ProjTable)): "";
                }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLineSequence</Name>
				<Source><![CDATA[
    public void setLineSequence(SequenceNumber _sequenceNumber)
    {
        PurchReqLine purchReqLine;
        int          counter = _sequenceNumber - 1;

        if (this.RequisitionStatus == PurchReqRequisitionStatus::Draft)
        {
            ttsbegin;

            while select forupdate  purchReqLine order by SequenceNumber where
                purchReqLine.PurchReqTable  == this.RecId &&
                purchReqLine.SequenceNumber >  counter
            {
                // if for e.g. line number 3 is deleted then counter is set 2 hence we need to update with counter +1
                purchReqLine.SequenceNumber = counter + 1;
                purchReqLine.LineNum        = counter + 1;

                purchReqLine.doUpdate();

                counter ++;
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>submittedByName</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(false)]
    public display Name submittedByName()
    {
        return this.getPartyName(this.SubmittedBy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>submittedDate</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(false)]
    public display DateDisplay submittedDate()
    {
        return strFmt("%1",datetime2str(DateTimeUtil::applyTimeZoneOffset(this.SubmittedDateTime, DateTimeUtil::getUserPreferredTimeZone()),DateFlags::FormatAll));
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmountMST</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute(true)]
    public display PurchReqTotalAmountMST totalAmountMST()
    {
        PurchReqLine    purchReqLine;
        dataAreaId      lineDataAreaId;
        PurchReqTotals  totals;
        AmountCur       totalAmount          = 0;
        CurrencyCode    currencyCode         = this.currencyCodeMST();

        if (this.isConsumption())
        {
            while select BuyingLegalEntity from purchReqLine group by BuyingLegalEntity where purchReqLine.PurchReqTable == this.RecId
            {
                lineDataAreaId = CompanyInfo::findRecId(purchReqLine.BuyingLegalEntity).DataArea;

                changecompany(lineDataAreaId)
                {
                    if (Currency::find(currencyCode))
                    {
                        totals = PurchReqTotals::construct(this);
                        totals.setCurrencyCode(currencyCode);
                        totals.calc();
                        totalAmount += totals.totalAmount();
                    }
                    else
                    {
                        warning(strFmt("@SYS117888", currencyCode));
                    }
                }
            }
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmountMSTStr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the totals for the <c>PurchReqTable</c> record in company currency.
    /// </summary>
    /// <returns>
    /// A string that contains total and currency code for the <c>PurchReqTable</c> record.
    /// </returns>
    [SysClientCacheDataMethodAttribute(false)]
    //Note: cache update is set to false since this method is only being used for workflow preview.
    public display PurchReqTotalAmountMSTStr totalAmountMSTStr()
    {
        return strFmt("@SCM:PurchReqCurrencyCodeAndAmount",this.totalAmountMST(),this.currencyCodeMST());
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        PurchReqTableInstrumentationActivities requisitionActivities = PurchReqTable::instrumentationLogger().requisition();
        
        using (var activityContext = requisitionActivities.update(this))
        {
            this.IsModified = NoYes::Yes;

            requisitionActivities.logRequisition(activityContext, this);

            super();

            if (TaxSolutionScopeIntegrationUtil::IsCompanyEnabled())
            {
                this.markCurrentTaxDocumentTaxStatusDirty();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalAmountOfPurchReqInReviewForBudgetReservationLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the total amount from the purchase requisition lines which are in workflow review state.
    /// </summary>
    /// <param name = "_purchReqLine">
    /// Purchase requisition line record.
    /// </param>
    /// <returns>
    /// total amount of purchase requisition lines.
    /// </returns>
    private static Amount getTotalAmountOfPurchReqInReviewForBudgetReservationLine(PurchReqLine _purchReqLine)
    {
        PurchReqLine localPurchReqLine;

        select sum(LineAmount) from localPurchReqLine
            where localPurchReqLine.BudgetReservationLine_PSN == _purchReqLine.BudgetReservationLine_PSN
                && localPurchReqLine.RequisitionStatus == PurchReqRequisitionStatus::InReview
                && localPurchReqLine.PurchReqTable != _purchReqLine.PurchReqTable;

        return localPurchReqLine.LineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDefaultsOnInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether legal entity specific default values have been provided correctly.
    /// </summary>
    /// <param name="_leDefaultsRequired">
    /// A Boolean value that indicates whether legal entity default values are required.
    /// </param>
    /// <returns>
    /// true if legal entity specific default values have been provided correctly; otherwise, false.
    /// </returns>
    public boolean validateDefaultsOnInsert(boolean _leDefaultsRequired)
    {
        boolean ret = true;

        if (_leDefaultsRequired)
        {
            if (!this.CompanyInfoDefault)
            {
                ret = checkFailed(strFmt("@SYS304394", fieldId2pname(tableNum(PurchReqTable), fieldNum(PurchReqTable, CompanyInfoDefault))));
            }

            if (!this.ProjId)
            {
                ret = checkFailed(strFmt("@SYS304394", fieldId2pname(tableNum(PurchReqTable), fieldNum(PurchReqTable, ProjId))));
            }
        }

        if (!this.PurchReqName)
        {
            ret = checkFailed(strFmt("@SYS304394", fieldId2pname(tableNum(PurchReqTable), fieldNum(PurchReqTable, PurchReqName))));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            ret = this.checkDelete(true);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(FieldId _fieldIdToCheck)
    {
        boolean         ret;

        ret = super(_fieldIdToCheck);

        if (ret)
        {
            switch (_fieldIdToCheck)
            {
                case fieldNum(PurchReqTable, RequiredDate)  :
                    if (this.RequiredDate < DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
                    {
                        // Required date must not be before today's date
                        ret = checkFailed("@SYS112276");
                    }

                    break;

                case fieldNum(PurchReqTable, ProjId):
                    if (this.ProjId)
                    {
                        ret = this.validateProjId();
                    }
                    break;

                case fieldNum(PurchReqTable, RequisitionPurpose):
                    RequisitionPurposeRule requisitionPurposeRule = RequisitionPurposeRule::findForCurrentCompany();
                    if (!requisitionPurposeRule.AllowManualPurposeOverRide)
                    {
                        if (requisitionPurposeRule.DefaultRequisitionPurpose != this.RequisitionPurpose)
                        {
                            ret = checkFailed(strFmt("@SCM:RequisitionPurposeNotAllowed", this.RequisitionPurpose));
                        }
                    }
                    break;

                case fieldNum(PurchReqTable, TransDate):
                    ret = PurchReqTable::validateBudgetReservation_PSN(this);
                    break;

                default :
                    break;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates field ProjId.
    /// </summary>
    /// <returns>true if validation passes; otherwise, false.</returns>
    public boolean validateProjId()
    {
        if (!this.CompanyInfoDefault)
        {
            // Please select buying legal entity first
            return checkFailed("@SYS342435");
        }
        else
        {
            return ProjTable::find(this.ProjId).status().validateWritePurchReqTable();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the Accounting date is not empty on the associated <c>PurchReqLine</c> records.
    /// </summary>
    public void validateAccountingDate()
    {
        PurchReqLine purchReqLine;

        if (this.RequisitionPurpose == RequisitionPurpose::Consumption)
        {
            select firstonly RecId from purchReqLine
            where purchReqLine.PurchReqTable == this.RecId
               && purchReqLine.TransDate  == dateNull();

            if (purchReqLine.RecId)
            {
                throw error ("@SCM:AccountingDateIsMissingOnOneOrMorePurchaseRequisitionLines");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        // The SourceDocumentHeader field is mandatory and needs to be created prior to validation if not already existed.
        this.createSourceDocumentHeader();

        return super() 
            && this.validateCoexistenceOfProjectAndBuyingLegalEntity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCoexistenceOfProjectAndBuyingLegalEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the coexistence of the Project Id and Buying legal entity fields, if any of the fields are set.
    /// </summary>
    /// <returns>true if validation passes; otherwise, false.</returns>
    /// <remarks>
    /// Project fields can only be set on record creation. Project id and Buying legal entity both need to be specified.
    /// </remarks>
    public boolean validateCoexistenceOfProjectAndBuyingLegalEntity()
    {
        boolean ok = true;

        if (   this.isFieldSet(fieldNum(PurchReqTable, ProjId))
            || this.isFieldSet(fieldNum(PurchReqTable, CompanyInfoDefault)))
        {
            if (!this.CompanyInfoDefault && this.ProjId)
            {
                ok = checkFailed(strFmt("@SCM:Field1RequiresField2ToAlsoBeSet", fieldStr(PurchReqTable, ProjId), fieldStr(PurchReqTable, CompanyInfoDefault)));
            }
            else if (!this.ProjId && this.CompanyInfoDefault)
            {
                ok = checkFailed(strFmt("@SCM:Field1RequiresField2ToAlsoBeSet", fieldStr(PurchReqTable, CompanyInfoDefault), fieldStr(PurchReqTable, ProjId)));
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a category hierarchy.
    /// </summary>
    /// <param name="_isConsumption">
    /// A Boolean indicating if the category hierarchy should be found for a requisition/ requisition line of type consumption.
    /// </param>
    /// <param name="_legalEntity">
    /// The <c>RecId</c> for the legal entity to find the category hierarchy for.
    /// </param>
    /// <returns>
    /// A category hierarchy.
    /// </returns>
    public static EcoResCategoryHierarchy categoryHierarchy(boolean     _isConsumption,
                                                            RefRecId    _legalEntity)
    {
        EcoResCategoryHierarchyRole hierarchyRole;
        EcoResCategoryHierarchy     hierarchy;

        if (!_isConsumption)
        {
            hierarchy = EcoResCategoryHierarchy::find(RequisitionReplenishCatAccessPolicyRule::findForLegalEntity(_legalEntity).EcoResCategoryHierarchy);
        }

        if (!hierarchy.RecId)
        {
            hierarchyRole = EcoResCategoryHierarchyRole::getHierarchiesByRole(EcoResCategoryNamedHierarchyRole::Procurement);
            hierarchy     = EcoResCategoryHierarchy::find(hierarchyRole.CategoryHierarchy);
        }
        return hierarchy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAccountingDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>AccountingDistribution</c> table records for the purchase requisition.
    /// </summary>
    /// <param name="_purchReqTableRecId">
    /// The reference ID of the <c>PurchReqTable</c> record.
    /// </param>
    static public void createAccountingDistributions(RecId _purchReqTableRecId)
    {
        PurchReqTable                   purchReqTable;

        purchReqTable   = PurchReqTable::find(_purchReqTableRecId);

        SourceDocumentProcessorFacade::submitSourceDocumentLinesForHeader(purchReqTable, SourceDocumentLineAccountingStatus::FullyDistributed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>earliestOpenVendActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the earliest <c>CreatedDateTime</c> value for a vendor.
    /// </summary>
    /// <param name="_accountNum">
    /// The account number of the vendor.
    /// </param>
    /// <param name="_dataArea">
    /// The legal entity context of the vendor.
    /// </param>
    /// <returns>
    /// Returns a <c>DateTime</c> value that contains the earliest <c>createdDateTime</c> value of the open
    /// transaction for a vendor.
    /// </returns>
    public static TransDateTime earliestOpenVendActivity(VendAccount _accountNum, DataAreaId _dataArea)
    {
        PurchReqTable   purchReqTable;
        PurchReqLine    purchReqLine;

        select firstonly CreatedDateTime from purchReqTable
               order by purchReqTable.CreatedDateTime desc
            exists join purchReqLine where purchReqLine.PurchReqTable       == purchReqTable.RecId   &&
                                           purchReqLine.VendAccount         == _accountNum           &&
                                           purchReqLine.VendAccountDataArea == _dataArea             &&
                                           (purchReqTable.RequisitionStatus  == PurchReqRequisitionStatus::InReview ||
                                           purchReqTable.RequisitionStatus  == PurchReqRequisitionStatus::Approved);

        return purchReqTable.CreatedDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluateHeaderStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluates and returns the status to be updated on the header.
    /// </summary>
    /// <param name="_purchReqTableRecId">
    /// The reference record ID of the <c>PurchReqTable</c> record.
    /// </param>
    /// <param name="_desiredStatus">
    /// The desired status of the <c>PurchReqTable</c> record.
    /// </param>
    /// <returns>
    /// The status to be updated.
    /// </returns>
    public static PurchReqRequisitionStatus evaluateHeaderStatus(RecId                     _purchReqTableRecId,
                                                                 PurchReqRequisitionStatus _desiredStatus)
    {
        // If all the requision lines are rejected, then return Rejected; otherwise return the original status.
        if (_desiredStatus == PurchReqRequisitionStatus::Rejected)
        {
            if (PurchReqTable::hasAllLinesWithStatus(_purchReqTableRecId, PurchReqRequisitionStatus::Rejected))
            {
                return PurchReqRequisitionStatus::Rejected;
            }
            else
            {
                return  PurchReqTable::find(_purchReqTableRecId).RequisitionStatus;
            }
        }
        else if (PurchReqLine::existsStatus(_purchReqTableRecId, PurchReqRequisitionStatus::Approved))
        {
            return PurchReqRequisitionStatus::Approved;
        }
        else if (_desiredStatus == PurchReqRequisitionStatus::Cancelled)
        {
            PurchReqLine purchReqLineClosed = PurchReqLine::findAnyClosedLineByHeaderRecId(_purchReqTableRecId);

            if (purchReqLineClosed.RecId && purchReqLineClosed.RequisitionPurpose == RequisitionPurpose::Consumption)
            {
                return PurchReqRequisitionStatus::Closed;
            }
            else
            {
                return PurchReqRequisitionStatus::Cancelled;
            }
        }
        else if (_desiredStatus == PurchReqRequisitionStatus::Closed
                 || (PublicSectorUtils::isBudgetReservationEnabled()
                    && _desiredStatus == PurchReqRequisitionStatus::ReferencedByBudgetReservation_PSN))
        {
            return PurchReqRequisitionStatus::Closed;
        }

        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    static boolean exist(PurchReqId _purchReqId)
    {
        return (select firstonly RecId from purchReqTable where purchReqTable.PurchReqId == _purchReqId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existPurchReqLineStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there is a <c>purchReqLine</c> record with the given status in the
    /// <c>PurchReqLine</c> table.
    /// </summary>
    /// <param name="_purchReqTableRecId">
    /// The record ID of the <c>PurchReqTable</c> table.
    /// </param>
    /// <param name="_purchReqLineRequisitionStatus">
    /// The requisition status of the <c>PurchReqLine</c> record.
    /// </param>
    /// <returns>
    /// true if the record is found; otherwise, false.
    /// </returns>
    static boolean existPurchReqLineStatus(RecId  _purchReqTableRecId, PurchReqRequisitionStatus _purchReqLineRequisitionStatus)
    {
        PurchReqLine    purchReqLine;

        select firstonly RecId from purchReqLine 
            where purchReqLine.PurchReqTable == _purchReqTableRecId 
                && (purchReqLine.RequisitionStatus == _purchReqLineRequisitionStatus
                || purchReqLine.RequisitionStatus   == PurchReqRequisitionStatus::ReferencedByBudgetReservation_PSN);
        if (purchReqLine.RecId)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasAllLinesWithStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether all <c>purchReqLine</c> records in the
    /// <c>PurchReqLine</c> table are with the given status.
    /// </summary>
    /// <param name="_purchReqTableRecId">
    /// The record ID of the <c>PurchReqTable</c> table.
    /// </param>
    /// <param name="_purchReqLineRequisitionStatus">
    /// The requisition status of the <c>PurchReqLine</c> record.
    /// </param>
    /// <returns>
    /// true if all records are with a given status; otherwise, false. Also, evaluates to true when there are no records present at all.
    /// </returns>
    static boolean hasAllLinesWithStatus(RecId  _purchReqTableRecId, PurchReqRequisitionStatus _purchReqLineRequisitionStatus)
    {
        PurchReqLine    purchReqLine;

        select firstonly RecId from purchReqLine
            where purchReqLine.PurchReqTable == _purchReqTableRecId
            && purchReqLine.RequisitionStatus != _purchReqLineRequisitionStatus;

        return !purchReqLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    public static PurchReqTable find(anytype         _purchReqTableRecId,
                                     boolean          _forUpdate = false,
                                     ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto )
    {
        PurchReqTable purchReqTable;

        if (_forUpdate)
        {
            purchReqTable.selectForUpdate(_forUpdate);

            if (_concurrencyModel != ConcurrencyModel::Auto)
            {
                purchReqTable.concurrencyModel(_concurrencyModel);
            }
        }

        purchReqTable.selectLocked(_forUpdate);

        select firstonly purchReqTable where purchReqTable.RecId == _purchReqTableRecId;

        return purchReqTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBySourceDocumentHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>PurchReqTable</c> record.
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    /// A <c>SourceDocumentHeader</c> record ID.
    /// </param>
    /// <returns>
    /// A <c>PurchReqTable</c> record.
    /// </returns>
    public static PurchReqTable findBySourceDocumentHeader(RefRecId _sourceDocumentHeader)
    {
        PurchReqTable     purchReqTable;

        select firstonly purchReqTable
            where purchReqTable.SourceDocumentHeader == _sourceDocumentHeader;

        return purchReqTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPurchReqId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>PurchReqTable</c> table.
    /// </summary>
    /// <param name="_purchReqId">
    /// The record ID of the <c>PurchReqTable</c> record.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to use when it reads the record; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>PurchReqTable</c> table; otherwise, an empty record.
    /// </returns>
    static PurchReqTable findPurchReqId(PurchReqId       _purchReqId,
                                        boolean          _forUpdate        = false,
                                        ConcurrencyModel _concurrencyModel = ConcurrencyModel::Auto)
    {
        PurchReqTable  purchReqTable;

        if (_purchReqId)
        {
            if (_forUpdate)
            {
                purchReqTable.selectForUpdate(_forUpdate);

                if (_concurrencyModel != ConcurrencyModel::Auto)
                {
                    purchReqTable.concurrencyModel(_concurrencyModel);
                }
            }
            purchReqTable.selectLocked(_forUpdate);

            select firstonly purchReqTable where purchReqTable.PurchReqId == _purchReqId;
        }

        return purchReqTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEPFilterCondition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a filter that will be used on grids in enterprise portal.
    /// </summary>
    /// <param name="_purchReqTableFilterType">
    /// The type that controls which filter to build.
    /// </param>
    /// <param name="_delimiter">
    /// The delimiter that is used to separate the filter conditions.
    /// </param>
    /// <returns>
    /// A string that contains the filter for the <c>purchReqTable</c> table.
    /// </returns>
    static str getEPFilterCondition(PurchReqTableFilterType _purchReqTableFilterType,
                                    str                     _delimiter)
    {
        PurchReqTableFilter purchReqTableFilter = PurchReqTableFilter::newEPFilter(_purchReqTableFilterType, _delimiter);
        return purchReqTableFilter.getEPFilterCondition();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchReqId</Name>
				<Source><![CDATA[
    public static PurchReqId getPurchReqId(RefRecId _purchReqTableRecId)
    {
        PurchReqTable  purchReqTable;

        select firstonly PurchReqId from purchReqTable where purchReqTable.RecId == _purchReqTableRecId;

        return purchReqTable.PurchReqId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchReqIdNumberSequenceManual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the number sequence that is used for the purchase requisition ID is manual.
    /// </summary>
    /// <returns>
    /// true if either the number sequence does not exist or it is manual; otherwise, false.
    /// </returns>
    public static boolean isPurchReqIdNumberSequenceManual()
    {
        NumberSequenceReference  numberSeqReference;
        NumberSequenceTable      numberSequenceTable;
        numberSeqReference = NumberSeqReference::findReference(extendedTypeNum(PurchReqId));
        if (numberSeqReference)
        {
            numberSequenceTable = NumberSequenceTable::find(numberSeqReference.NumberSequenceId);

            if (numberSequenceTable)
            {
                return numberSequenceTable.numAllowEdit();
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numRefPurchReqId</Name>
				<Source><![CDATA[
    public static NumberSequenceReference numRefPurchReqId()
    {
        NumberSeqScope  numSeqScope;
        container       parameters;

        numSeqScope = NumberSeqScope::construct(parameters);
        return NumberSeqReference::findReference(extendedTypeNum(PurchReqId),numSeqScope);
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwIfRFQPending</Name>
				<Source><![CDATA[
    /// <summary>
    /// Throws an error if the request for quote is pending.
    /// </summary>
    /// <param name="_isPurchReqTable">
    /// Indicates whether the function is being called for <c>PurchReqTable</c> record.
    /// </param>
    /// <param name="_recId">
    /// The record ID reference of the record.
    /// </param>
    public static void throwIfRFQPending(boolean _isPurchReqTable, RecId _recId)
    {
        PurchReqLine        purchReqLine;

        while select purchReqLine where ( _isPurchReqTable && purchReqLine.PurchReqTable == _recId) ||
                                        (!_isPurchReqTable && purchReqLine.RecId         == _recId)
        {
            changecompany(purchReqLine.buyingLegalEntity2DataArea())
            {
                if (purchReqLine.isRFQPending())
                {
                    throw error("@SYS319805");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>workflowContextDataAreaId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>dataAreaId</c> context to use for the execution of workflow.
    /// </summary>
    /// <param name="_tableId">
    /// The table ID of the record.
    /// </param>
    /// <param name="_recId">
    /// The record ID of the record.
    /// </param>
    /// <returns>
    /// The <c>dataAreaId</c> context to use for the execution of workflow.
    /// </returns>
    public static DataAreaId workflowContextDataAreaId(TableId _tableId, RecId _recId)
    {
        PurchReqTable       purchReqTable;
        PurchReqLine        purchReqLine;
        DataAreaId          ret;

        if (_tableId == tableNum(PurchReqLine))
        {
            purchReqLine    = PurchReqLine::find(_recId);
            ret             = purchReqLine.buyingLegalEntity2DataArea();
        }
        else if (_tableId == tableNum(PurchReqTable))
        {
            select firstonly BuyingLegalEntity from purchReqLine order by LineNum asc where purchReqLine.PurchReqTable == _recId;
            ret             = purchReqLine.buyingLegalEntity2DataArea();

            if (!ret)
            {
                select firstonly CompanyInfoDefault from purchReqTable where purchReqTable.RecId == _recId;
                ret = CompanyInfo::findRecId(purchReqTable.CompanyInfoDefault).DataArea;

                if (!ret)
                {
                    ret = CompanyInfo::find().DataArea;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markCurrentTaxDocumentTaxStatusDirty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark current tax status of <c> PurchReqTable </c> to dirty.
    /// </summary>
    private void markCurrentTaxDocumentTaxStatusDirty()
    {
        TaxableDocumentDescriptor descriptor = TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(this);
        ITaxableDocument taxableDocument = TaxableDocumentObject::construct(descriptor);
        TaxBusinessService::markTaxDocumentTaxStatus(taxableDocument, TaxDocumentCalculationLevel::Dirty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBudgetReservationBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the balance of budget reservation for each puchase requisition line on this puchase requisition.
    /// </summary>
    public void checkBudgetReservationBalance()
    {
        PurchReqLine purchReqLine;

        PurchReqInstrumentationLogger purchReqInstrumentationLogger = PurchReqTable::instrumentationLogger();

        while select BudgetReservationLine_PSN, PurchReqTable
        from purchReqLine
        where
            (purchReqLine.PurchReqTable == this.RecId && purchReqLine.BudgetReservationLine_PSN != 0)
        {
            using (var activityContextWorkflow = purchReqInstrumentationLogger.requisition().checkBudgetReservationBalanceWorkflow(purchReqLine))
            {
                AmountCur availableBalance = BudgetReservationCalculateBalance_PSN::getBudgetReservationLineTotalBalance(purchReqLine.BudgetReservationLine_PSN, this.SourceDocumentHeader);
                Amount inReviewAmount = PurchReqTable::getTotalAmountOfPurchReqInReviewForBudgetReservationLine(purchReqLine);

                if ((availableBalance - inReviewAmount) < 0)
                {
                    BudgetReservationHeader_PSN  budgetReservationHeaderLocal;
                    BudgetReservationLine_PSN    budgetReservationLineLocal;

                    select firstonly BudgetReservationHeader_PSN from budgetReservationLineLocal
                                where budgetReservationLineLocal.RecId == purchReqLine.BudgetReservationLine_PSN
                            join RecId, DocumentNumber from budgetReservationHeaderLocal
                                where budgetReservationHeaderLocal.RecId == budgetReservationLineLocal.BudgetReservationHeader_PSN;

                    throw error(strFmt("@Budgeting_BudgetReservationPS:BudgetReservationClassAmountExceedsBalanceInfolog", budgetReservationHeaderLocal.DocumentNumber));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetReservation_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validations on the <c>BudgetReservationLine_PSN</c> field of each <c>PurchReqLine</c> line record associated
    /// with the specified <c>PurchReqTable</c> record.
    /// </summary>
    /// <param name="_purchReqTable">
    /// The <c>PurchReqTable</c> record associated with the <c>PurchReqLine</c> records to be validated.
    /// </param>
    /// <returns>
    /// true if all validations pass or the budget reservation feature is disabled; otherwise, false.
    /// </returns>
    private static boolean validateBudgetReservation_PSN(PurchReqTable _purchReqTable)
    {
        PurchReqLine              purchReqLine;
        BudgetReservationLine_PSN budgetReservationLine;
        boolean                   isValid = true;

        if (PublicSectorUtils::isBudgetReservationEnabled())
        {
            while select BudgetReservationHeader_PSN from budgetReservationLine
            exists join purchReqLine
                group by budgetReservationLine.BudgetReservationHeader_PSN
            where purchReqLine.PurchReqTable == _purchReqTable.RecId
                && purchReqLine.BudgetReservationLine_PSN == budgetReservationLine.RecId
                && purchReqLine.BudgetReservationLine_PSN != 0
            {
                isValid = isValid && BudgetReservation_PSN::validateBudgetReservationToBeRelieved(
                    _purchReqTable.TransDate,
                    budgetReservationLine.BudgetReservationHeader_PSN,
                    BudgetReservationRelievingDocument_PSN::PurchaseRequisition,
                    "@Budgeting_BudgetReservationPS:PRAccountingDateNotInFiscalYearError",
                    "@Budgeting_BudgetReservationPS:PRAccountingDateNotWithinGBRDatesError");
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAcceptedForWorkItemAssignedToMyQueues</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays whether the workflow work item is claimed for the purchase requisition which assigned to my queues.
    /// </summary>
    /// <returns>
    ///     A boolean value to show the workflow work item has been claimed or not.
    /// </returns>
    [SysClientCacheDataMethodAttribute(true)]
    public display WorkflowWorkItemClaimed isAcceptedForWorkItemAssignedToMyQueues()
    {
        WorkflowQueueDocumentCommonFields   workflowQueueDocumentCommonFields;
        WorkflowWorkItemTable               workflowWorkItemTable;

        if (PurchReqWorkflowWorkItemClaimedFlight::instance().isEnabled())
        {
            WorkflowWorkItemQueue workflowWorkItemQueue;
            WorkflowWorkItemQueueAssignee workflowWorkItemQueueAssignee;

            //Looking for non-claimed pending work item, that is assigned to current user
            select RecId from workflowQueueDocumentCommonFields
                where (workflowQueueDocumentCommonFields.RefRecId == this.RecId || workflowQueueDocumentCommonFields.ParentRefRecId == this.RecId)
                &&  (workflowQueueDocumentCommonFields.RefTableId == this.TableId || workflowQueueDocumentCommonFields.ParentRefTableId == this.TableId)
                exists join workflowWorkItemTable
                    where  workflowQueueDocumentCommonFields.WorkflowWorkitem == workflowWorkItemTable.RecId
                    && workflowWorkItemTable.Status == WorkflowWorkItemStatus::Pending
                    && workflowWorkItemTable.IsClaimed == false
                exists join workflowWorkItemQueue
                    where workflowWorkItemTable.Queue == workflowWorkItemQueue.RecId
                exists join workflowWorkItemQueueAssignee
                    where workflowWorkItemQueue.RecId == workflowWorkItemQueueAssignee.WorkitemQueue
                    && workflowWorkItemQueueAssignee.User == curUserId();
            
            return workflowQueueDocumentCommonFields.RecId ? false : true;
        }
        else
        {
            select firstonly IsClaimed from workflowWorkItemTable
                exists join workflowQueueDocumentCommonFields
                where workflowQueueDocumentCommonFields.WorkflowWorkitem == workflowWorkItemTable.RecId
                    && ((workflowQueueDocumentCommonFields.RefRecId == this.RecId || workflowQueueDocumentCommonFields.ParentRefRecId == this.RecId)
                    &&  (workflowQueueDocumentCommonFields.RefTableId == this.TableId || workflowQueueDocumentCommonFields.ParentRefTableId == this.TableId));
        }

        return workflowWorkItemTable.IsClaimed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    private static PurchReqInstrumentationLogger instrumentationLogger()
    {
        return PurchReqInstrumentationLogger::createLogger(tableStr(PurchReqTable));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>PurchReq</ConfigurationKey>
	<DeveloperDocumentation>@SYS124556</DeveloperDocumentation>
	<FormRef>PurchReqTable</FormRef>
	<Label>@SYS109808</Label>
	<SingularLabel>@SYS94925</SingularLabel>
	<TableGroup>WorksheetHeader</TableGroup>
	<TitleField1>PurchReqId</TitleField1>
	<TitleField2>PurchReqName</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<ClusteredIndex>RecId</ClusteredIndex>
	<CreatedBy>Yes</CreatedBy>
	<CreatedDateTime>Yes</CreatedDateTime>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedBy>Yes</ModifiedBy>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>ProcurementAndSourcing</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<ReplacementKey>PurchReqIdx</ReplacementKey>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>PurchReqBusJustification</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>PurchReqBusJustification</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>PurchReqLine</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>PurchReqLine</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Originator</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RequisitionStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchReqId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PurchReqType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PurchReqName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RequiredDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchReqId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AddressLookup</Name>
			<Label>@SYS88672</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchReqId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PurchReqName</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Administration</Name>
			<Label>@SYS9853</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PurchReqName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>createdDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>createdBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SubmittedDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SubmittedBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>modifiedDateTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CompanyInfoDefault</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Attention</Name>
			<Label>@SYS1593</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BusinessJustification</Name>
			<Label>@SYS135099</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BusinessJustification</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Date</Name>
			<Label>@SYS7402</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RequiredDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Details</Name>
			<Label>@SYS112222</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>totalAmountMST</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>HeaderToLineUpdate</Name>
			<Label>@SYS62436</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RequiredDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BusinessJustification</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>HoldPurchaseRequisition</Name>
			<Label>@EPR4460079</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OnHold</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>HoldExplanation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS36186</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchReqId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PurchReqName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PurchReqType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Project</Name>
			<Label>@SYS4534</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Purpose</Name>
			<Label>@GLS160310</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RequisitionPurpose</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Requisitioner</Name>
			<Label>@SYS305887</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Originator</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SourceDocumentHeader</Name>
			<Label>@SYS314386</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SourceDocumentHeader</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Status</Name>
			<Label>@SYS80127</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RequisitionStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Submitted</Name>
			<Label>@SYS109896</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SubmittedBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SubmittedDateTime</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>System</Name>
			<Label>@SYS4278</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IsModified</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Type</Name>
			<Label>@SYS1201</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchReqType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WorkflowPreview</Name>
			<Label>@SYS116253</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchReqId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PurchReqName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>originatorName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BusinessJustification</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>totalAmountMSTStr</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RequisitionStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>requiredAction</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>requiredActionDueDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>mostRecentComment</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WorkflowResubmit</Name>
			<Label>@SYS329541</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IsWorkflowToBeResubmitted</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BusinessJustification</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BusinessJustificationRefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CompanyInfoDefault</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Label>@SYS342437</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>HoldExplanation</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchReqHoldExplanation</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsModified</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VersioningIsModified</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IsWorkflowToBeResubmitted</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SYS329538</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OnHold</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchReqHoldStatus</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Originator</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchReqPreparerRefRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjIdDataArea</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>DataAreaId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PurchReqId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchReqId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PurchReqName</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchReqName</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PurchReqType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PurchReqType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>RequiredDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchReqRequiredDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RequisitionPurpose</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>RequisitionPurpose</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RequisitionStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>PurchReqRequisitionStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SourceDocumentHeader</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS314386</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>SubmittedBy</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>PurchReqSubmittedBy</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>SubmittedDateTime</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchReqSubmittedDateTime</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>TransDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchReqAccountingDate</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>PurchReqIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>PurchReqId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ProjTableIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>SourceDocumentHeaderIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>SourceDocumentHeader</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SourceDocumentHeaderImplementation</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>SourceDocumentHeader</MapField>
					<MapFieldTo>SourceDocumentHeader</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalTable</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>Posted</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>TableId</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CompanyInfoDefault</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CompanyInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CompanyInfoDefault</Name>
					<Field>CompanyInfoDefault</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Originator</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>HcmWorker_PurchReqTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Originator</Name>
					<Field>Originator</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProjTable_PurchReqTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjIdDataArea</Name>
					<Field>ProjIdDataArea</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjId</Name>
					<Field>ProjId</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ProjectIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PurchReqBusinessJustificationCodes</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>PurchReqBusinessJustificationCodes</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PurchReqBusinessJustificationCodes</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>PurchReqBusinessJustificationCodes_PurchReqTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BusinessJustification</Name>
					<Field>BusinessJustification</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SourceDocumentHeader</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>SourceDocumentHeader</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>SourceDocumentHeader</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>SourceDocumentHeader_PurchReqTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SourceDocumentHeader</Name>
					<Field>SourceDocumentHeader</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>SubmittedBy</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UserInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>SubmittedBy</Name>
					<SourceEDT>PurchReqSubmittedBy</SourceEDT>
					<Field>SubmittedBy</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PurchReqId</Name>
			<RelatedTable>PurchReqTable</RelatedTable>
			<RelationshipType>Link</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PurchReqId</Name>
					<SourceEDT>PurchReqId</SourceEDT>
					<Field>PurchReqId</Field>
					<RelatedField>PurchReqId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>