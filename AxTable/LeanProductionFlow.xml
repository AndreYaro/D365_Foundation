<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LeanProductionFlow</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class LeanProductionFlow extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>actualCycleTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the calculated current actual cycle time of the production flow version.
    /// </summary>
    /// <returns>
    /// The actual cycle time.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public display LeanProdFlowActualCycleTime actualCycleTime()
    {
        #TimeConstants

        WorkCalendarTable       workCalendarTable;
        Plan                    plan;
        Set                     setActivities;
        CalendarId              calendarId;
        InventQty               qtyProducedInCycleTimePeriod;
        Seconds                 workingTimeInPeriod;
        real                    cycleTimeSeconds;
        real                    cycleTimeHours;
        real                    actualCycleTimeSeconds;
        real                    actualCycleTimeTaktUnit;
        TransDateTime           fromDateTime;
        TransDateTime           toDateTime   = DateTimeUtil::getSystemDateTime();
        StandardWorkDayHours    standardWorkDayHours;

        if (this.RecId)
        {
            plan = this.plan();
            if (   plan
                && plan.Status == PlanStatus::Active)
            {
                calendarId                   = this.endLeanProductionFlowCalendar(toDateTime);
                workCalendarTable            = WorkCalendarTable::find(calendarId);
                standardWorkDayHours         = workCalendarTable.StandardWorkDayHours;

                cycleTimeHours               = this.PeriodForActualCycleTime * standardWorkDayHours;
                cycleTimeSeconds             = cycleTimeHours * #secondsPerHour;

                fromDateTime                 = DateTimeUtil::addSeconds(toDateTime, -any2int(cycleTimeSeconds));
                fromDateTime                 = max(fromDateTime,plan.ValidFrom);

                if (plan.ValidTo != DateTimeUtil::minValue())
                {
                    toDateTime = min(toDateTime,plan.ValidTo);
                }
                else
                {
                    toDateTime = toDateTime;
                }

                setActivities                = Set::create(this.endLeanProductionFlowActivities(fromDateTime));
                qtyProducedInCycleTimePeriod = this.qtyProducedInCycleTimePeriod(fromDateTime,toDateTime,setActivities);
                workingTimeInPeriod          = this.workingTimeInCycleTimePeriod(fromDateTime,toDateTime,setActivities);
            }
        }

        actualCycleTimeTaktUnit = realMax();

        if (qtyProducedInCycleTimePeriod)
        {
            actualCycleTimeSeconds = workingTimeInPeriod / qtyProducedInCycleTimePeriod;
            if (this.TaktUnitOfMeasure != 0)
            {
                actualCycleTimeTaktUnit = UnitOfMeasureConverter::convert(actualCycleTimeSeconds,
                                                                          ProdTimeUnitOfMeasure::unitOfMeasureByType(ProdTimeUnitType::Seconds),
                                                                          this.TaktUnitOfMeasure,
                                                                          NoYes::No,
                                                                          0,
                                                                          NoYes::No);
            }
        }

        return actualCycleTimeTaktUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actualCycleTimeForPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the calculated actual cycle time of the production flow version for a specific period.
    /// </summary>
    /// <param name="_fromDateTime">
    ///    A start date and time for a period for which to calculate the actual cycle time.
    /// </param>
    /// <param name="_toDateTime">
    ///    A end date and time for a period for which to calculate the actual cycle time for.
    /// </param>
    /// <param name="_setEndActivities">
    ///    A set that holds the end activities of a production flow; optional.
    /// </param>
    /// <param name="_inventQty">
    ///    A quantity that represents the quantity produced in the period; optional.
    /// </param>
    /// <param name="_seconds">
    ///    The duration of the period in seconds; optional.
    /// </param>
    /// <returns>
    ///    The actual cycle time for the specified period.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Seconds actualCycleTimeForPeriod(
        TransDateTime _fromDateTime,
        TransDateTime _toDateTime,
        Set           _setEndActivities = null,
        InventQty     _inventQty = this.qtyProducedInCycleTimePeriod(_fromDateTime,_toDateTime,_setEndActivities),
        Seconds       _seconds   = this.workingTimeInCycleTimePeriod(_fromDateTime,_toDateTime,_setEndActivities))
    {
        Seconds     actualTaktInPeriod;

        if (   this.RecId
            && _fromDateTime <= _toDateTime
            && _seconds
            && _inventQty)
        {
            actualTaktInPeriod  = any2int(_seconds / _inventQty);
        }

        return actualTaktInPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustPrecision</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the precision of the value fields from the configuration of the specified units of measure.
    /// </summary>
    private void adjustPrecision()
    {
        UnitOfMeasureDecimalPrecision taktPrecision = UnitOfMeasure::unitOfMeasureDecimalPrecision(this.TaktUnitOfMeasure);

        // adjust precision for quantity value
        this.QuantityPerCycle = decRound(this.QuantityPerCycle, UnitOfMeasure::unitOfMeasureDecimalPrecision(this.QuantityPerCycleUnitOfMeasure));

        // adjust precision for takt values
        this.MaximumTakt = decRound(this.MaximumTakt, taktPrecision);
        this.MinimumTakt = decRound(this.MinimumTakt, taktPrecision);
        this.AverageTakt = decRound(this.AverageTakt, taktPrecision);
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLeanProductionFlowActivities</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves production flow activities that mark the end of a production flow.
    /// </summary>
    /// <param name="_transDateTime">
    ///    A date and time value that is used to check the validity of plans.
    /// </param>
    /// <param name="_plan">
    ///    A specific <c>Plan</c> table for which to find end activities; optional.
    /// </param>
    /// <returns>
    ///    A container of record IDs of <c>LeanProductionFlow</c> records.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public container endLeanProductionFlowActivities(
        TransDateTime _transDateTime,
        Plan          _plan = null)
    {
        Plan                                plan;
        Plan                                dependentPlan;
        PlanActivity                        planActivity;
        PlanActivity                        dependentPlanActivity;
        PlanPlanActivity                    planPlanActivity;
        PlanPlanActivity                    dependentPlanPlanActivity;
        PlanActivityRelationship            planActivityRelationship;
        LeanProductionFlowActivity          leanProductionFlowActivity;
        LeanProductionFlow                  leanProductionFlow;
        Set                                 setResult = new Set(Types::Int64);
        container                           result = conNull();

        while select RecId from leanProductionFlowActivity
            exists join planActivity
                where planActivity.RecId == leanProductionFlowActivity.PlanActivity
                   && (planActivity.PlanActivityType == PlanActivityType::Process
                   ||  planActivity.PlanActivityType == PlanActivityType::Transfer)
            exists join planPlanActivity
                where planPlanActivity.PlanActivity  == planActivity.RecId
                   && (planPlanActivity.Plan         == _plan.RecId
                   ||  !_plan.RecId)
            exists join PlanReference from plan
                where plan.RecId      == planPlanActivity.Plan
                   && plan.ValidFrom  <= _transDateTime
                   && (plan.ValidTo   >= _transDateTime
                   ||  !plan.ValidTo)
                   && (plan.Status    == PlanStatus::Active
                   ||  plan.RecId     == _plan.RecId)
            exists join leanProductionFlow
                where leanProductionFlow.Plan  == plan.RecId
                   && leanProductionFlow.RecId == this.RecId
            notexists join planActivityRelationship
                where planActivityRelationship.IndependentPlanActivity == planActivity.RecId
                exists join dependentPlanPlanActivity
                    where dependentPlanPlanActivity.PlanActivity == planActivityRelationship.DependentPlanActivity
                exists join dependentPlanActivity
                    where dependentPlanActivity.RecId == dependentPlanPlanActivity.PlanActivity
                       && (dependentPlanActivity.PlanActivityType == PlanActivityType::Process
                       ||  dependentPlanActivity.PlanActivityType == PlanActivityType::Transfer)
                exists join dependentPlan
                    where dependentPlan.RecId         == dependentPlanPlanActivity.Plan
                       && dependentPlan.ValidFrom     <= _transDateTime
                       && (dependentPlan.ValidTo      >= _transDateTime
                       ||  !dependentPlan.ValidTo)
                       && (dependentPlan.Status       == PlanStatus::Active
                       ||  dependentPlan.RecId        == plan.RecId)
                       && dependentPlan.PlanReference == plan.PlanReference
        {
            setResult.add(leanProductionFlowActivity.RecId);
        }

        return setResult.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLeanProductionFlowCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the calendar with the most recent working time that is recorded by the activities at the end
    ///    of a production flow.
    /// </summary>
    /// <param name="_transDateTime">
    ///    A start reference date for which the most recent calendar is searched.
    /// </param>
    /// <returns>
    ///    The calendar with the most recent time of work.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public CalendarId endLeanProductionFlowCalendar(TransDateTime _transDateTime)
    {
        CalendarId                  calendarId;

        LeanProductionFlowActivity  leanProductionFlowActivity;
        PlanActivity                planActivity;
        WrkCtrResourceGroup         wrkCtrResourceGroup;
        WrkCtrResourceCalendar      wrkCtrResourceCalendar;
        utcdatetime                 activityMostRecentWorkingDateTime;
        utcdatetime                 allActivitiesMostRecentWorkingDateTime = DateTimeUtil::minValue();

        TransDate                   transDate         = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(_transDateTime,DateTimeUtil::getCompanyTimeZone()));
        WorkCalendarSched           workCalendarSched = new WorkCalendarSched();

        SetEnumerator               se;
        Set                         setActivities;
        Set                         set = new Set(Types::Int64);

        setActivities = Set::create(this.endLeanProductionFlowActivities(_transDateTime));

        se = setActivities.getEnumerator();

        while (se.moveNext())
        {
            leanProductionFlowActivity  = LeanProductionFlowActivity::find(se.current());
            planActivity                = leanProductionFlowActivity.planActivity();
            wrkCtrResourceGroup         = planActivity.wrkCtrResourceGroup();

            // Count each resource group just once in case of duplicates
            if (    wrkCtrResourceGroup
                && !set.in(wrkCtrResourceGroup.RecId))
            {
                set.add(wrkCtrResourceGroup.RecId);

                wrkCtrResourceCalendar = WrkCtrResourceCalendar::findActiveForResource(wrkCtrResourceGroup.WrkCtrId, transDate);
                activityMostRecentWorkingDateTime = workCalendarSched.schedTimeUTC(SchedDirection::Backward,_transDateTime,1,true,wrkCtrResourceCalendar.CalendarId);

                if (activityMostRecentWorkingDateTime > allActivitiesMostRecentWorkingDateTime)
                {
                    allActivitiesMostRecentWorkingDateTime = activityMostRecentWorkingDateTime;
                    calendarId                             = wrkCtrResourceCalendar.CalendarId;
                }
            }
        }

        return calendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromLeanProductionFlow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current record from a given <c>LeanProductionFlow</c> record.
    /// </summary>
    /// <param name="_leanProductionFlow">
    /// A <c>LeanProductionFlow</c> record from which to initialize.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void initFromLeanProductionFlow(LeanProductionFlow _leanProductionFlow)
    {
        this.MinimumTakt                   = _leanProductionFlow.MinimumTakt;
        this.AverageTakt                   = _leanProductionFlow.AverageTakt;
        this.MaximumTakt                   = _leanProductionFlow.MaximumTakt;
        this.TaktUnitOfMeasure             = _leanProductionFlow.TaktUnitOfMeasure;
        this.PeriodForActualCycleTime      = _leanProductionFlow.PeriodForActualCycleTime;
        this.QuantityPerCycle              = _leanProductionFlow.QuantityPerCycle;
        this.QuantityPerCycleUnitOfMeasure = _leanProductionFlow.QuantityPerCycleUnitOfMeasure;
        this.ProductionFlowReference       = _leanProductionFlow.ProductionFlowReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromLeanProductionFlowReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current record from a given <c>LeanProductionFlowReference</c> record.
    /// </summary>
    /// <param name="_leanProductionFlowReference">
    /// A <c>LeanProductionFlowReference</c> record from which to initialize.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void initFromLeanProductionFlowReference(LeanProductionFlowReference _leanProductionFlowReference)
    {
        this.ProductionFlowReference = _leanProductionFlowReference.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the record buffer.
    /// </summary>
    public void initValue()
    {
        #define.minimumTakt(1.0)
        #define.targetTakt(1.0)
        #define.periodForActualTakt(1)
        #define.quantityPerCycle(1.0)
        ProdParameters  prodParameters = ProdParameters::find();

        super();
        this.MinimumTakt                   = #minimumTakt;
        this.AverageTakt                   = #targetTakt;
        this.MaximumTakt                   = this.AverageTakt * 2;
        this.PeriodForActualCycleTime      = #periodForActualTakt;
        this.QuantityPerCycle              = #quantityPerCycle;
        this.TaktUnitOfMeasure             = prodParameters.ProductionFlowDefaultTimeUnit;
        this.QuantityPerCycleUnitOfMeasure = prodParameters.ProductionFlowDefaultQuantityUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        // make sure the values we store are consistent with the UoM settings
        this.adjustPrecision();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>legalEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the legal entity that is related to the current record.
    /// </summary>
    /// <returns>
    /// A <c>LegalEntity</c> type value.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public LegalEntity legalEntity()
    {
        return this.planReference().LegalEntity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(fieldId _fieldId)
    {
        switch (_fieldId)
        {
            case fieldNum(LeanProductionFlow, QuantityPerCycleUnitOfMeasure):
                // fall through
            case fieldNum(LeanProductionFlow, TaktUnitOfMeasure):
                // adjust precision of value fields depending on selected UoMs
                this.adjustPrecision();
                // fall through
            default:
                super(_fieldId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>plan</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>Plan</c> parent record for the current buffer.
    /// </summary>
    /// <returns>
    ///    A <c>Plan</c> record buffer.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Plan plan()
    {
        return Plan::find(this.Plan);
    }

]]></Source>
			</Method>
			<Method>
				<Name>planReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>PlanReference</c> record related to the kanban rule.
    /// </summary>
    /// <returns>
    ///    A <c>PlanReference</c> record buffer.
    /// </returns>
    /// <remarks>
    ///    The last activity in a kanban flow is always related to owner plan reference.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public PlanReference planReference()
    {
        PlanReference   planReference;
        Plan            plan;

        if (this.Plan)
        {
            select firstonly planReference
                exists join plan
                    where plan.PlanReference == planReference.RecId
                       && plan.RecId         == this.Plan;
        }

        return planReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyProducedInCycleTimePeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the quantity produced for the production flow.
    /// </summary>
    /// <param name="_fromDateTime">
    ///    The start date and time of the period for which to find quantity produced.
    /// </param>
    /// <param name="_toDateTime">
    ///    The end date and time of the period for which to find quantity produced.
    /// </param>
    /// <param name="_setActivities">
    ///    A set object that holds the end activities of a production flow.
    /// </param>
    /// <returns>
    ///    The quantity produced.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public InventQty qtyProducedInCycleTimePeriod(
        TransDateTime _fromDateTime,
        TransDateTime _toDateTime,
        Set           _setActivities)
    {
        Kanban                      kanban;
        KanbanJob                   kanbanJob;
        KanbanRule                  kanbanRule;
        KanbanFlow                  kanbanFlow;
        LeanProductionFlowReference leanProductionFlowReference;
        PlanReference               planReference;
        PlanPlanActivity            planPlanActivity;
        PlanActivity                planActivity;
        InventQty                   inventQty;

        if (   _fromDateTime <= _toDateTime
            && _setActivities
            && _setActivities.elements())
        {
            while select sum(QuantityReceived) from kanban
                where kanban.Status >= LeanKanbanStatus::Received
                join LeanProductionFlowActivity from kanbanJob
                    group by LeanProductionFlowActivity
                    where kanbanJob.RecId              == kanban.CurrentJob
                       && kanbanJob.ActualEndDateTime  >= _fromDateTime
                       && (kanbanJob.ActualEndDateTime <= _toDateTime
                       ||  !_toDateTime)
               exists join kanbanRule
                    where kanbanRule.RecId == kanban.KanbanRule
                exists join kanbanFlow
                    where kanbanFlow.RecId == kanbanRule.KanbanFlow
                exists join planPlanActivity
                    where planPlanActivity.RecId == kanbanFlow.LastPlanPlanActivity
                exists join planActivity
                    where planActivity.RecId == planPlanActivity.PlanActivity
                exists join planReference
                    where planReference.RecId == planActivity.PlanReference
                exists join leanProductionFlowReference
                    where leanProductionFlowReference.PlanReference == planReference.RecId
                       && leanProductionFlowReference.RecId         == this.ProductionFlowReference
            {
                if (_setActivities.in(kanbanJob.LeanProductionFlowActivity))
                {
                    inventQty += kanban.QuantityReceived;
                }
            }
        }

        return inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startLeanProductionFlowActivities</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the production flow activities that mark the start of a production flow.
    /// </summary>
    /// <param name="_transDateTime">
    ///    A date and time value that is used to check the validity of plans.
    /// </param>
    /// <param name="_plan">
    ///    A specific <c>Plan</c> record for which to find end activities; optional.
    /// </param>
    /// <returns>
    ///    A set of record IDs of the <c>LeanProductionFlow</c> records.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Set startLeanProductionFlowActivities(
        TransDateTime _transDateTime,
        Plan          _plan = null)
    {
        Plan                                plan;
        Plan                                independentPlan;
        PlanActivity                        planActivity;
        PlanActivity                        independentPlanActivity;
        PlanPlanActivity                    planPlanActivity;
        PlanPlanActivity                    independentPlanPlanActivity;
        PlanActivityRelationship            planActivityRelationship;
        LeanProductionFlowActivity          leanProductionFlowActivity;
        LeanProductionFlow                  leanProductionFlow;
        Set                                 setResult = new Set(Types::Int64);

        while select RecId from leanProductionFlowActivity
            exists join planActivity
                where planActivity.RecId == leanProductionFlowActivity.PlanActivity
                   && (planActivity.PlanActivityType == PlanActivityType::Process
                   ||  planActivity.PlanActivityType == PlanActivityType::Transfer)
            exists join planPlanActivity
                where planPlanActivity.PlanActivity  == planActivity.RecId
                   && (planPlanActivity.Plan         == _plan.RecId
                   ||  !_plan.RecId)
            exists join PlanReference from plan
                where plan.RecId      == planPlanActivity.Plan
                   && plan.ValidFrom  <= _transDateTime
                   && (plan.ValidTo   >= _transDateTime
                   ||  !plan.ValidTo)
                   && (plan.Status    == PlanStatus::Active
                   ||  plan.RecId     == _plan.RecId)
            exists join leanProductionFlow
                where leanProductionFlow.Plan  == plan.RecId
                   && leanProductionFlow.RecId == this.RecId
            notexists join planActivityRelationship
                where planActivityRelationship.DependentPlanActivity == planActivity.RecId
                exists join independentPlanPlanActivity
                    where independentPlanPlanActivity.PlanActivity == planActivityRelationship.IndependentPlanActivity
                exists join independentPlanActivity
                    where independentPlanActivity.RecId             == independentPlanPlanActivity.PlanActivity
                       && (independentPlanActivity.PlanActivityType == PlanActivityType::Process
                       ||  independentPlanActivity.PlanActivityType == PlanActivityType::Transfer)
                exists join independentPlan
                    where independentPlan.RecId         == independentPlanPlanActivity.Plan
                       && independentPlan.ValidFrom     <= _transDateTime
                       && (independentPlan.ValidTo      >= _transDateTime
                       ||  !independentPlan.ValidTo)
                       && (independentPlan.Status       == PlanStatus::Active
                       ||  independentPlan.RecId        == plan.RecId)
                       && independentPlan.PlanReference == plan.PlanReference
        {
            setResult.add(leanProductionFlowActivity.RecId);
        }

        return setResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        // make sure the values we store are consistent with the UoM settings
        this.adjustPrecision();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(fieldId _fieldIdToCheck)
    {
        boolean ret;

        ret = super(_fieldIdToCheck);

        if (ret)
        {
            switch (_fieldIdToCheck)
            {
                case fieldNum(LeanProductionFlow, TaktUnitOfMeasure):
                    ret = ret && UnitOfMeasure::isUnitOfClass(this.TaktUnitOfMeasure, UnitOfMeasureClass::Time);
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;

        ret = super();

        if (this.MinimumTakt > this.AverageTakt)
        {
            // Minimum takt must be lower than target takt
            ret = ret && checkFailed("@SYS132285");
        }

        if (this.MaximumTakt < this.AverageTakt)
        {
            // Maximum takt must be higher than target takt
            ret = ret && checkFailed("@SYS132286");
        }

        if (this.MaximumTakt < this.MinimumTakt)
        {
            // Maximum takt must be higher than minimum takt
            ret = ret && checkFailed("@SYS300916");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workingTimeInCycleTimePeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the working time of a period.
    /// </summary>
    /// <param name="_fromDateTime">
    ///    A start date and time used to calculate the working time.
    /// </param>
    /// <param name="_toDateTime">
    ///    A end date and time used to calculate the working time.
    /// </param>
    /// <param name="_setActivities">
    ///    A set that holds the end activities of a production flow.
    /// </param>
    /// <returns>
    ///    The working time of the takt period in seconds.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Seconds workingTimeInCycleTimePeriod(
        TransDateTime _fromDateTime,
        TransDateTime _toDateTime,
        Set           _setActivities)
    {
        #TimeConstants
        WrkCtrResourceGroup         wrkCtrResourceGroup;
        WrkCtrResourceCalendar      wrkCtrResourceCalendar;
        LeanProductionFlowActivity  leanProductionFlowActivity;
        PlanActivity                planActivity;
        SetEnumerator               se;
        TransDateTime               fromDateTime;
        TransDateTime               toDateTime;
        TransDate                   fromDate;
        TransDate                   toDate;
        TransDateTime               transDateTime   = _fromDateTime;
        Timezone                    companyTimeZone = DateTimeUtil::getCompanyTimeZone();
        Set                         set             = new Set(Types::Int64);
        Seconds                     seconds;
        boolean                     done;

        if (   _fromDateTime <= _toDateTime
            && _fromDateTime != DateTimeUtil::minValue()
            && _toDateTime   != DateTimeUtil::minValue()
            && _toDateTime   != DateTimeUtil::maxValue()
            && _setActivities
            && _setActivities.elements())
        {
            se = _setActivities.getEnumerator();

            while (se.moveNext())
            {
                leanProductionFlowActivity  = LeanProductionFlowActivity::find(se.current());
                planActivity                = leanProductionFlowActivity.planActivity();
                wrkCtrResourceGroup         = planActivity.wrkCtrResourceGroup();

                //count each resource group just once in case of duplicates
                if (   !wrkCtrResourceGroup
                    || !set.in(wrkCtrResourceGroup.RecId))
                {
                    if (wrkCtrResourceGroup)
                    {
                        set.add(wrkCtrResourceGroup.RecId);
                    }

                    fromDateTime                = _fromDateTime;                                                            //UTC
                    fromDate                    = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(
                                                                     _fromDateTime,companyTimeZone));                       //company timezone
                    toDateTime                  = DateTimeUtil::minValue();
                    toDate                      = dateNull();
                    done                        = false;

                    while (!done)
                    {
                        //find current calendar
                        fromDate = toDate ? toDate : fromDate;                                                            //company time zone
                        wrkCtrResourceCalendar = WrkCtrResourceCalendar::findActiveForResource(wrkCtrResourceGroup.WrkCtrId,
                                                                                               fromDate);
                        if (!wrkCtrResourceCalendar)
                        {
                            fromDateTime  = toDateTime ? toDateTime : _fromDateTime;
                            toDateTime    = min(_toDateTime,DateTimeUtil::addDays(fromDateTime,1));
                            seconds      += int642int(DateTimeUtil::getDifference(toDateTime,fromDateTime));
                        }
                        else
                        {
                            fromDateTime = toDate
                                            ? DateTimeUtil::removeTimeZoneOffset(DateTimeUtil::newDateTime(fromDate,0),companyTimeZone)
                                            : _fromDateTime;

                            if (wrkCtrResourceCalendar.ValidTo && wrkCtrResourceCalendar.ValidTo != dateMax())
                            {
                                toDateTime = min(DateTimeUtil::removeTimeZoneOffset(DateTimeUtil::newDateTime(
                                                                                     wrkCtrResourceCalendar.ValidTo,
                                                                                     #secondsPerDay),
                                                                                     companyTimeZone),
                                                                                     _toDateTime);
                            }
                            else
                            {
                                toDateTime = _toDateTime;
                            }

                            //expects UTC
                            seconds += LeanWorkCellScheduleCapacity::capacitySecondsServer(wrkCtrResourceCalendar.CalendarId,
                                                                                fromDateTime,
                                                                                toDateTime);
                        }

                        toDate  = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(toDateTime,companyTimeZone));        //company timezone

                        done = toDateTime >= _toDateTime;
                    }
                }
            }
        }

        return seconds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewVersion</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new version of a production flow in the <c>Plan</c> table.
    /// </summary>
    /// <param name="_planReference">
    ///    The record ID of the production flow version
    /// </param>
    /// <param name="_planToCopyFrom">
    ///    The record ID of the plan from which to copy.
    /// </param>
    /// <param name="_validFrom">
    ///    The date the production flow version is valid from.
    /// </param>
    /// <param name="_validTo">
    ///    The date the production flow version is valid to.
    /// </param>
    /// <param name="_duplicateKanbanRules">
    ///    A Boolean value that indicates whether the associated kanban rules should be copied to the new
    ///    version.
    /// </param>
    /// <returns>
    ///    The record created in the <c>Plan</c> table.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    static Plan createNewVersion(
        RefRecId              _planReference,
        RefRecId              _planToCopyFrom,
        PlanValidFromDateTime _validFrom,
        PlanValidToDateTime   _validTo,
        NoYes                 _duplicateKanbanRules)
    {
        Plan                            newPlan;
        LeanProductionFlow              newLeanProductionFlow;
        LeanProductionFlow              leanProductionFlow;
        LeanProductionFlowReference     leanProductionFlowReference;
        Map                             changes = new Map(Types::Int64, Types::Int64);

        ttsbegin;
        // create a new version for the plan
        newPlan = Plan::createNewVersion(_planReference, _planToCopyFrom, _validFrom, _validTo, _duplicateKanbanRules);

        if (newPlan.RecId)
        {
            // create the production flow record
            newLeanProductionFlow.initValue();
            leanProductionFlow = LeanProductionFlow::findPlan(_planToCopyFrom);
            if (leanProductionFlow)
            {
                newLeanProductionFlow.initFromLeanProductionFlow(leanProductionFlow);
            }
            else
            {
                leanProductionFlowReference = LeanProductionFlowReference::findPlanReference(_planReference);
                newLeanProductionFlow.initFromLeanProductionFlowReference(leanProductionFlowReference);
            }
            newLeanProductionFlow.Plan = newPlan.RecId;
            newLeanProductionFlow.insert();

            // handle the case when the new plan is based on an existing one ->
            // in this case we need to duplicate a few entries
            if (_planToCopyFrom != 0)
            {
                // duplicate planPlanActivities
                changes = PlanPlanActivity::duplicateForNewPlan(_planToCopyFrom, newPlan.RecId);

                // duplicate the activity relation assignments to the new plan
                LeanProdFlowPlanActivityRelation::duplicateForNewProductionFlow(LeanProductionFlow::findPlan(_planToCopyFrom).RecId, newLeanProductionFlow.RecId);

                if (_duplicateKanbanRules)
                {
                    LeanRulesEngine::onPlanDuplication(Plan::find(_planToCopyFrom), newPlan, changes);
                }
            }
        }
        ttscommit;

        return newPlan;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified record occurs in the <c>LeanProductionFlow</c> table.
    /// </summary>
    /// <param name="_refRecId">
    ///    The record ID of the <c>LeanProductionFlow</c> record to check for existence.
    /// </param>
    /// <returns>
    ///    true if the specified record exists; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean exist(LeanProductionFlowRefRecId _refRecId)
    {
        return _refRecId &&
               (select firstonly RecId from leanProductionFlow
                    where leanProductionFlow.RecId == _refRecId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>LeanProductionFlow</c> table.
    /// </summary>
    /// <param name="_refRecId">
    /// The record ID of the <c>LeanProductionFlow</c> table to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>LeanProductionFlow</c> table; otherwise, an empty record.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static LeanProductionFlow find(
        LeanProductionFlowRefRecId _refRecId,
        boolean                    _forUpdate = false)
    {
        LeanProductionFlow  leanProductionFlow;

        if (_refRecId)
        {
            leanProductionFlow.selectForUpdate(_forUpdate);

            select firstonly leanProductionFlow
                where leanProductionFlow.RecId == _refRecId;
        }

        return leanProductionFlow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the active production flow for a specified plan reference.
    /// </summary>
    /// <param name="_planReference">
    ///    The record ID of the plan reference.
    /// </param>
    /// <param name="_dateTime">
    ///    The date and time for which the active version should be found.
    /// </param>
    /// <returns>
    ///    A record in the <c>LeanProductionFlow</c> table; otherwise, an empty record.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static LeanProductionFlow findActive(
        PlanReferenceRefRecId _planReference,
        utcdatetime           _dateTime = DateTimeUtil::getSystemDateTime())
    {
        Plan                plan;
        LeanProductionFlow  leanProductionFlow;

        plan = Plan::findActive(_planReference,_dateTime);

        if (plan)
        {
            leanProductionFlow = LeanProductionFlow::findPlan(plan.RecId);
        }

        return leanProductionFlow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPlan</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>LeanProductionFlow</c> table.
    /// </summary>
    /// <param name="_plan">
    /// The plan of the <c>LeanProductionFlow</c> table to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>LeanProductionFlow</c> table; otherwise, an empty record.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static LeanProductionFlow findPlan(
        PlanRefRecId _plan,
        boolean      _forUpdate = false)
    {
        LeanProductionFlow  leanProductionFlow;

        if (_plan)
        {
            leanProductionFlow.selectForUpdate(_forUpdate);

            select firstonly leanProductionFlow
                where leanProductionFlow.Plan == _plan;
        }

        return leanProductionFlow;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LeanManufacturing</ConfigurationKey>
	<DeveloperDocumentation>@SYS332819</DeveloperDocumentation>
	<FormRef>LeanProductionFlow</FormRef>
	<Label>@SYS132287</Label>
	<SingularLabel>@SYS131795</SingularLabel>
	<TableGroup>Main</TableGroup>
	<TitleField1>Plan</TitleField1>
	<TitleField2>ProductionFlowReference</TitleField2>
	<CacheLookup>Found</CacheLookup>
	<Modules>ProductionControl</Modules>
	<ReplacementKey>PlanReferencePlanIdx</ReplacementKey>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<TableContents>BaseData</TableContents>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>LeanProdFlowPlanActivityRelation</Name>
			<DeleteAction>Restricted</DeleteAction>
			<Relation></Relation>
			<Table>LeanProdFlowPlanActivityRelation</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MaximumTakt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AverageTakt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MinimumTakt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PeriodForActualCycleTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QuantityPerCycle</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Plan</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProductionFlowReference</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CycleTime</Name>
			<Label>@SYS105720</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>QuantityPerCycle</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PeriodForActualCycleTime</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QuantityPerCycleUnitOfMeasure</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ProductionFlow</Name>
			<Label>@SYS131795</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Plan</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProductionFlowReference</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Takt</Name>
			<Label>@SYS136092</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AverageTakt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MinimumTakt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MaximumTakt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RequiredTakt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaktUnitOfMeasure</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AverageTakt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LeanAverageTakt</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>MaximumTakt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LeanMaximumTakt</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>MinimumTakt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LeanMinimumTakt</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PeriodForActualCycleTime</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LeanPeriodForActualCycleTime</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Plan</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PlanRefRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ProductionFlowReference</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LeanProductionFlowReferenceRefRecId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>QuantityPerCycle</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LeanQuantityPerCycle</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>QuantityPerCycleUnitOfMeasure</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>UnitOfMeasureRecId</ExtendedDataType>
			<Label>@SYS310058</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>RequiredTakt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LeanRequiredTakt</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaktUnitOfMeasure</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>UnitOfMeasureRecId</ExtendedDataType>
			<Label>@SYS310057</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>PlanReferencePlanIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>Plan</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ProductionFlowReference</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TaktUnitOfMeasureIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>TaktUnitOfMeasure</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>QuantityUnitOfMeasureIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>QuantityPerCycleUnitOfMeasure</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LeanProductionFlowReference</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LeanProductionFlowReference</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>ProductionFlowReference</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProductionFlow</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProductionFlowReference</Name>
					<Field>ProductionFlowReference</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Plan</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Plan</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>ProductionFlowPlan</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProductionFlow</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Plan</Name>
					<Field>Plan</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>QuantityUnitOfMeasure</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UnitOfMeasure</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>UnitOfMeasure</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>QuantityUnitOfMeasure</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>QuantityPerCycleUnitOfMeasure</Name>
					<Field>QuantityPerCycleUnitOfMeasure</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaktUnitOfMeasure</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>UnitOfMeasure</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>TaktUnitOfMeasure</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>ProductionFlow</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaktUnitOfMeasure</Name>
					<Field>TaktUnitOfMeasure</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>