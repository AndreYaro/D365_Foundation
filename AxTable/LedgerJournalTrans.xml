<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class LedgerJournalTrans extends common
{
    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>skipCheckZeroAmountDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate that is called to allow the check for zero amount to be skipped.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_assetTransType">
    /// The <c>AssetTransTypeJournal</c> enumeration value.
    /// </param>
    /// <param name = "_eventHandlerResult">
    /// The <c>EventHandlerResult</c> instance.
    /// </param>
    delegate void skipCheckZeroAmountDelegate(LedgerJournalTrans _ledgerJournalTrans, AssetTransTypeJournal _assetTransType, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTransFromVoucherDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate that is called inside the <c>deleteTransFromVoucher</c> method immediately before
    /// the <c>LedgerJournalTrans</c> record is deleted.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    delegate void deleteTransFromVoucherDelegate(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountDisplay</Name>
				<Source><![CDATA[
    public display CustVendAC accountDisplay()
    {
        return this.parmAccount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountName</Name>
				<Source><![CDATA[
    public display LedgerJournalAccountName accountName()
    {
        if (this.LedgerDimension)
        {
            if (!this.Company)
            {
                return this.accountNameFind(this.AccountType, this.LedgerDimension, curext());
            }
            else
            {
                return this.accountNameFind(this.AccountType, this.LedgerDimension, this.Company);
            }
        }

        return "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNameFind</Name>
				<Source><![CDATA[
    public LedgerJournalAccountName accountNameFind(
        LedgerJournalACType     _accountType,
        DimensionDynamicAccount _dimensionDynamicAccount,
        SelectableDataArea      _company)
    {
        if (xDataArea::exist(_company))
        {
            changecompany(_company)
            {
                switch (_accountType)
                {
                    case LedgerJournalACType::Ledger :
                        return LedgerDimensionFacade::getMainAccountFromLedgerDimension(_dimensionDynamicAccount).localizedName();
                    case LedgerJournalACType::Cust :
                        return CustTable::find(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).name();
                    case LedgerJournalACType::Vend :
                        return VendTable::find(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).name();
                    case LedgerJournalACType::Bank :
                        return BankAccountTable::find(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).Name;
                    case LedgerJournalACType::Project :
                        return ProjTable::find(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).Name;
                    case LedgerJournalACType::FixedAssets :
                        return AssetTable::find(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).Name;
                    case LedgerJournalACType::FixedAssets_RU :
                        return RAssetTable::find(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).Name;
                    case LedgerJournalACType::Employee_RU :
                        return EmployeeTable_RU::findByEmployeeId(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).employeeName();
                    case LedgerJournalACType::RDeferrals :
                        return RDeferralsTable::find(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).Name;
                    case LedgerJournalACType::RCash :
                        return RCashTable::find(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).Name;
                }
            }
        }
        return "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>LedgerJournalTrans</c> can settle open transactions.
    /// </summary>
    /// <returns>
    /// True if open transactions can be marked for settlement; otherwise, false.
    /// </returns>
    public boolean allowSettlement()
    {
        return !((this.PaymentStatus == CustVendPaymStatus::Sent)
            || (PaymTerm::find(this.Payment).CashLedgerDimension != 0));
    }

]]></Source>
			</Method>
			<Method>
				<Name>amount</Name>
				<Source><![CDATA[
    public display Amount amount()
    {
        return this.AmountCurDebit ? this.AmountCurDebit : -this.AmountCurCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountCur2DebCred</Name>
				<Source><![CDATA[
    public void amountCur2DebCred(
        AmountCur   _amountCur,
        boolean     _correction = false)
    {
        this.AmountCurDebit     = 0;
        this.AmountCurCredit    = 0;

        if (_correction)
        {
            if (_amountCur < 0)
            {
                this.AmountCurDebit = _amountCur;
            }
            else
            {
                this.AmountCurCredit = -_amountCur;
            }
        }
        else
        {
            if (_amountCur < 0)
            {
                this.AmountCurCredit = -_amountCur;
            }
            else
            {
                this.AmountCurDebit = _amountCur;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountCurPDC</Name>
				<Source><![CDATA[
    public display Amount amountCurPDC()
    {
        return this.AmountCurDebit ? this.AmountCurDebit : this.AmountCurCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areAccountsInSingleCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the primary account and offset account
    /// are in a single company.
    /// </summary>
    /// <returns>
    /// true if the primary account and offset account are in a single
    /// company; otherwise, false.
    /// </returns>
    /// <remarks>
    /// When intercompany accounting configuration is not enabled, the
    /// primary account and offset acccount must be in a single company.
    /// </remarks>
    public boolean areAccountsInSingleCompany()
    {
        boolean isTheSame;

        if (!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)))
        {
            isTheSame = true;
        }
        else
        {
            isTheSame = (this.Company == this.OffsetCompany);
        }

        return isTheSame;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheAllowEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the performance validation caches that indicate when the <c>LedgerJournalTrans</c> table
    /// can be edited.
    /// </summary>
    /// <remarks>
    /// We have several scenarios when the database is queried by the
    /// <c>LedgerJournalTrans.checkAllowEdit</c> method to determine whether the current row may be edited.
    /// This method tracks the validation problems for the current row and caches the results. From a
    /// service create operation point of view, we can track these scenarios as the rows are being added.
    /// </remarks>
    public void cacheAllowEdit()
    {
        #macrolib.LedgerAIF
        container cacheKey;
        boolean errorCondition;

        cacheKey = [this.JournalNum, this.Voucher];

        //LedgerJournalTransCanNotBeChangedWhenCheckPrinted check
        errorCondition = false;
        if (this.PaymentStatus != CustVendPaymStatus::None && this.BankChequeNum != "")
        {
            errorCondition = true;
        }
        this.cacheAllowEditUpdate(#LedgerJournalTransCanNotBeChangedWhenCheckPrinted, cacheKey, errorCondition);

        //LedgerJournalTransCanNotBeChangedForPromissoryNote
        errorCondition = false;
        if (this.BankPromissoryNoteNum != "")
        {
            errorCondition = true;
        }
        this.cacheAllowEditUpdate(#LedgerJournalTransCanNotBeChangedForPromissoryNote, cacheKey, errorCondition);

        //LedgerJournalTransCanNotBeDeletedForPromissoryNote
        errorCondition = false;
        if (this.PaymentStatus != CustVendPaymStatus::None && this.BankPromissoryNoteNum  != "")
        {
            errorCondition = true;
        }
        this.cacheAllowEditUpdate(#LedgerJournalTransCanNotBeDeletedForPromissoryNote, cacheKey, errorCondition);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheAllowEditUpdate</Name>
				<Source><![CDATA[
    private void cacheAllowEditUpdate(str _cacheOwner, container _cacheKey, boolean _errorCondition)
    {
        boolean cacheValue;
        SysGlobalCache          cache = classfactory.globalCache();

        // When the cache has not been set, the error condition will be set to true or false.  This cache
        // will be reset to true when the error condiditon exists.  After the error condition has been set,
        // it will not be reset to false until the cache has been flushed. This behavior is intentional because
        // we are tracking validation problems when a set of LedgerJournalLines (for a voucher) have been created
        // from a service.
        if (cache.isSet(_cacheOwner, _cacheKey))
        {
            cacheValue = cache.get(_cacheOwner, _cacheKey);
            if (cacheValue == false  && _errorCondition == true)
            {
                cache.set(_cacheOwner, _cacheKey, _errorCondition);
            }
        }
        else
        {
            cache.set(_cacheOwner, _cacheKey, _errorCondition);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCurrencyCodeAndJournalTypeValid</Name>
				<Source><![CDATA[
    private boolean isCurrencyCodeAndJournalTypeValid(CurrencyCode _currentCompanyAccountingCurrency, CurrencyCode _accountCompanyAccountingCurrency, CurrencyCode _accountCompanyReportingCurrency, LedgerJournalType _journalType)
    {
        boolean currencyCodeAndJournalType;

        if ((_currentCompanyAccountingCurrency == _accountCompanyAccountingCurrency || _currentCompanyAccountingCurrency == _accountCompanyReportingCurrency)
                && (_journalType == LedgerJournalType::Daily
                || _journalType == LedgerJournalType::Approval
                || _journalType == LedgerJournalType::CustPayment
                || _journalType == LedgerJournalType::Payment
                || _journalType == LedgerJournalType::PurchaseLedger
                || _journalType == LedgerJournalType::VendInvoiceRegister))
        {
            currencyCodeAndJournalType = true;
        }

        return currencyCodeAndJournalType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the net MST total amount for a <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_throwExceptions">
    /// Throw exceptions; optional.
    /// </param>
    /// <returns>
    /// An amount in MST currency.
    /// </returns>
    /// <remarks>
    /// For intercompany transactions, currency conversions will use the exchange rate of the current
    /// company for the transaction currency code and transaction date that is indicated on the transaction
    /// regardless of the exchange rate on the transaction.
    /// </remarks>
    public AmountMST calcAmountMST(boolean _throwExceptions = true)
    {
        AmountMST amountMST;
        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            this.exchRateDate_W());

        // Allocations is a special case as the process uses transaction amounts to calculate exchange
        // rate values to balance properly, vs. using the exchange rate to calculate accounting/reporting
        // amounts.
        boolean forceExchangeRate = (this.ledgerJournalTable().JournalType == LedgerJournalType::Allocation);
        boolean isInterCompany = false;
        CurrencyCode currentCompanyAccountingCurrency;
        CurrencyCode accountCompanyAccountingCurrency;
        CurrencyCode accountCompanyReportingCurrency;


        if (!forceExchangeRate && this.isCompanyIntercompany(this.company()))
        {
            isInterCompany = true;
            currentCompanyAccountingCurrency = Ledger::accountingCurrency();

            changecompany (this.Company)
            {
                accountCompanyAccountingCurrency = Ledger::accountingCurrency();
                accountCompanyReportingCurrency = Ledger::reportingCurrency();
            }
        }

        if (isInterCompany)
        {
            LedgerJournalTable ledgerJournalTable = this.ledgerJournalTable();

            if (this.isCurrencyCodeAndJournalTypeValid(currentCompanyAccountingCurrency,
                accountCompanyAccountingCurrency, accountCompanyReportingCurrency, ledgerJournalTable.JournalType))
            {
                if (currentCompanyAccountingCurrency == accountCompanyAccountingCurrency)
                {
                    currencyExchangeHelper.parmExchangeRate1(this.ExchRate);
                    currencyExchangeHelper.parmExchangeRate2(this.ExchRateSecond);
                }
                else
                {
                    currencyExchangeHelper.parmExchangeRate1(this.ReportingCurrencyExchRate);
                    currencyExchangeHelper.parmExchangeRate2(this.ReportingCurrencyExchRateSecondary);
                }
            }

        }
        else
        {
            // The exchange rate fields only apply to the account company and not the company of the
            // transaction, so only use them when there is not an intercompany transaction involved.
            currencyExchangeHelper.parmExchangeRate1(this.ExchRate);
            currencyExchangeHelper.parmExchangeRate2(this.ExchRateSecond);
        }

        // if we are in the service context (non-interactive), we want to log any problems as faults and continue forward
        if (!_throwExceptions)
        {
            currencyExchangeHelper.parmErrorType(AifErrorType::Fault);
        }

        amountMST = currencyExchangeHelper.calculateTransactionToAccounting(this.CurrencyCode, this.AmountCurDebit - this.AmountCurCredit, true);

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBaseAmountMSTIncTaxInCostPrice</Name>
				<Source><![CDATA[
    public AmountMST calcBaseAmountMSTIncTaxInCostPrice(TaxVoucherService taxVoucherService = null)
    {
        AmountMST           amountMST;
        TaxAmount           taxInAmount;
        TaxAmount           taxInCostPriceAmount;
        AmountMST           cashDiscAmount = 0.0;
        TaxCalculation      taxCalculation;

        if (this.TaxGroup || this.TaxCode)
        {
            if (taxVoucherService)
            {
                taxInCostPriceAmount = taxVoucherService.getTransactionalTaxInCostPriceForLine(this);
                if (this.AccountType == LedgerJournalACType::FixedAssets)
                {
                    taxInAmount = taxVoucherService.taxAmountForAssetType(this);
                }
                else
                {
                    taxInAmount = taxVoucherService.getTransactionalTaxAmountForLine(this);
                }
            }
            else
            {
                taxCalculation = LedgerJournalTrans::getTaxInstance(this.JournalNum, this.Voucher, this.Invoice, false, this);

                taxInCostPriceAmount = taxCalculation.totalTaxInCostPrice(this.RecId);
                taxInAmount = taxCalculation.totalTaxAmountSingleLine(this.TableId, this.RecId, false, false);
            }
        }
        //
        //  If the cash discount is to be taken on the invoice
        //  and the cash discount must be applied to the fixed asset
        //  assign the ledgerJournalTrans.cashDiscAmountcheck to
        //  local cashDiscAmount property so it can be used
        //  in the calculation of the net transaction amount.
        //
        if (TaxParameters::canApplyCashDiscOnInvoice_ES()
            && AssetParameters::find().DeductCashDisc)
        {
            cashDiscAmount = this.CashDiscAmount;
        }

        amountMST = (this.AmountCurDebit - this.AmountCurCredit) + taxInCostPriceAmount - taxInAmount - cashDiscAmount;

        // Allocations is a special case as the process uses transaction amounts to calculate exchange
        // rate values to balance properly, vs. using the exchange rate to calculate accounting/reporting
        // amounts.
        boolean forceExchangeRate = (this.ledgerJournalTable().JournalType == LedgerJournalType::Allocation);

        if (forceExchangeRate || !this.isCompanyIntercompany(this.company()))
        {
            return CurrencyExchangeHelper::mstAmount(amountMST, this.CurrencyCode, this.TransDate, Currency::noYes2UnknownNoYes(this.Triangulation), this.ExchRate, this.ExchRateSecond);
        }
        else
        {
            // Need to calculate the MST amount for the dataAreaId company of the transaction
            // using the currency code and the transaction date.
            // The exchange rate fields should not be used because these are for the account company.
            return CurrencyExchangeHelper::mstAmount(amountMST, this.CurrencyCode, this.TransDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCreditMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the MST amount for a <c>LedgerJournalTrans.amountCurCredit</c> value.
    /// </summary>
    /// <param name="_throwExceptions">
    /// Throw exceptions; optional.
    /// </param>
    /// <param name="_ledgerJournalTable">
    /// The corresponding <c>LedgerJournalTable</c> record; optional.
    /// </param>
    /// <returns>
    /// An amount in MST currency.
    /// </returns>
    /// <remarks>
    /// For intercompany transactions, currency conversions will use the exchange rate of the current
    /// company for the transaction currency code and transaction date that is indicated on the transaction
    /// if the transaction currency codes are different in the two companies.
    /// Pass the corresponding <c>LedgerJournalTable</c> record so this method does not have to retrieve it.
    /// </remarks>
    public Amount calcCreditMST(boolean _throwExceptions = true, LedgerJournalTable _ledgerJournalTable = null)
    {
        AmountMST           amountMST;
        LedgerJournalTable  ledgerJournalTable;
        CurrencyCode        currentCompanyAccountingCurrency = '';
        CurrencyCode        accountCompanyAccountingCurrency = '';
        CurrencyCode        accountCompanyReportingCurrency = '';
        boolean             isInterCompany = false;

        CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::current(),
            this.exchRateDate_W());

        // Allocations is a special case as the process uses transaction amounts to calculate exchange
        // rate values to balance properly, vs. using the exchange rate to calculate accounting/reporting
        // amounts.
        boolean forceExchangeRate = (_ledgerJournalTable.JournalType == LedgerJournalType::Allocation);

        if (!forceExchangeRate && this.isCompanyIntercompany(this.company()))
        {
            isInterCompany = true;
            currentCompanyAccountingCurrency = Ledger::accountingCurrency();

            changecompany(this.Company)
            {
                accountCompanyAccountingCurrency = Ledger::accountingCurrency();
                accountCompanyReportingCurrency = Ledger::reportingCurrency();
            }
        }

        if (isInterCompany)
        {
            if (_ledgerJournalTable == null)
            {
                ledgerJournalTable = this.ledgerJournalTable();
            }
            else
            {
                ledgerJournalTable = _ledgerJournalTable;
            }

            if (this.isCurrencyCodeAndJournalTypeValid(currentCompanyAccountingCurrency,
                accountCompanyAccountingCurrency, accountCompanyReportingCurrency, ledgerJournalTable.JournalType))
            {
                if (currentCompanyAccountingCurrency == accountCompanyAccountingCurrency)
                {
                    currencyExchHelper.parmExchangeRate1(this.ExchRate);
                    currencyExchHelper.parmExchangeRate2(this.ExchRateSecond);
                }
                else
                {
                    currencyExchHelper.parmExchangeRate1(this.ReportingCurrencyExchRate);
                    currencyExchHelper.parmExchangeRate2(this.ReportingCurrencyExchRateSecondary);
                }
            }
        }
        else
        {
            currencyExchHelper.parmExchangeRate1(this.ExchRate);
            currencyExchHelper.parmExchangeRate2(this.ExchRateSecond);
        }

        // if we are in the service context (non-interactive), we want to log any problems as faults and continue forward
        if (!_throwExceptions)
        {
            currencyExchHelper.parmErrorType(AifErrorType::Fault);
        }

        amountMST = currencyExchHelper.calculateTransactionToAccounting(this.CurrencyCode, this.AmountCurCredit, true);

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDebitMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the MST amount for a <c>LedgerJournalTrans.amountCurDebit</c> value.
    /// </summary>
    /// <param name="_throwExceptions">
    /// Throw exceptions; optional.
    /// </param>
    /// <param name="_ledgerJournalTable">
    /// The corresponding <c>LedgerJournalTable</c> record; optional.
    /// </param>
    /// <returns>
    /// An amount in MST currency.
    /// </returns>
    /// <remarks>
    /// For intercompany transactions, currency conversions will use the exchange rate of the current
    /// company for the transaction currency code and transaction date that is indicated on the transaction
    /// if the transaction currency codes are different in the two companies.
    /// Pass the corresponding <c>LedgerJournalTable</c> record so this method does not have to retrieve it.
    /// </remarks>
    public Amount calcDebitMST(boolean _throwExceptions = true, LedgerJournalTable _ledgerJournalTable = null)
    {
        AmountMST           amountMST;
        LedgerJournalTable  ledgerJournalTable;
        CurrencyCode        currentCompanyAccountingCurrency = '';
        CurrencyCode        accountCompanyAccountingCurrency = '';
        CurrencyCode        accountCompanyReportingCurrency = '';
        boolean             isInterCompany = false;

        CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::current(),
            this.exchRateDate_W());

        // Allocations is a special case as the process uses transaction amounts to calculate exchange
        // rate values to balance properly, vs. using the exchange rate to calculate accounting/reporting
        // amounts.
        boolean forceExchangeRate = (_ledgerJournalTable.JournalType == LedgerJournalType::Allocation);

        if (!forceExchangeRate && this.isCompanyIntercompany(this.company()))
        {
            isInterCompany = true;
            currentCompanyAccountingCurrency = Ledger::accountingCurrency();

            changecompany(this.Company)
            {
                accountCompanyAccountingCurrency = Ledger::accountingCurrency();
                accountCompanyReportingCurrency = Ledger::reportingCurrency();
            }
        }

        if (isInterCompany)
        {
            if (_ledgerJournalTable == null)
            {
                ledgerJournalTable = this.ledgerJournalTable();
            }
            else
            {
                ledgerJournalTable = _ledgerJournalTable;
            }

            if (this.isCurrencyCodeAndJournalTypeValid(currentCompanyAccountingCurrency,
                accountCompanyAccountingCurrency, accountCompanyReportingCurrency, ledgerJournalTable.JournalType))
            {
                if (currentCompanyAccountingCurrency == accountCompanyAccountingCurrency)
                {
                    currencyExchHelper.parmExchangeRate1(this.ExchRate);
                    currencyExchHelper.parmExchangeRate2(this.ExchRateSecond);
                }
                else
                {
                    currencyExchHelper.parmExchangeRate1(this.ReportingCurrencyExchRate);
                    currencyExchHelper.parmExchangeRate2(this.ReportingCurrencyExchRateSecondary);
                }
            }
        }
        else
        {
            currencyExchHelper.parmExchangeRate1(this.ExchRate);
            currencyExchHelper.parmExchangeRate2(this.ExchRateSecond);
        }

        // if we are in the service context (non-interactive), we want to log any problems as faults and continue forward
        if (!_throwExceptions)
        {
            currencyExchHelper.parmErrorType(AifErrorType::Fault);
        }

        amountMST = currencyExchHelper.calculateTransactionToAccounting(this.CurrencyCode, this.AmountCurDebit, true);

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPaymentFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the payment fee.
    /// </summary>
    public void calcPaymentFee()
    {
        switch (this.AccountType)
        {
            case LedgerJournalACType::Cust :
                CustVendPaymJournalFee::createJournalFeeCust(this);
                break;

            case LedgerJournalACType::Vend :
                CustVendPaymJournalFee::createJournalFeeCust(this);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBankCurrencyAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the bank currency amount.
    /// </summary>
    public void calculateBankCurrencyAmount()
    {
        AmountCur       bankCurrencyamount;
        CurrencyCode    bankCurrencyCode;
        AmountCur       transactionCurrencyAmount;

        transactionCurrencyAmount = this.getBankTransactionCurrencyAmount();

        bankCurrencyCode = BankAccountTable::find(this.parmBankAccount()).CurrencyCode;

        if (this.CurrencyCode == bankCurrencyCode)
        {
            bankCurrencyamount = transactionCurrencyAmount;
        }
        else if (bankCurrencyCode == Ledger::accountingCurrency())
        {
            bankCurrencyamount  = CurrencyExchangeHelper::amountCur2MST(transactionCurrencyAmount, this.CurrencyCode, this.ExchRate, this.TransDate);
        }
        else
        {
            bankCurrencyamount = CurrencyExchangeHelper::curAmount2CurAmount(transactionCurrencyAmount, this.CurrencyCode, bankCurrencyCode, this.TransDate);
        }

        this.BankCurrencyAmount = bankCurrencyamount;
        this.BankCurrency       = bankCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAccountTypeBeTaxed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified account type can be taxed by the tax engine.
    /// </summary>
    /// <param name="_accountType">
    /// The account type to check.
    /// </param>
    /// <returns>
    /// true if the specified account type is being used on the <c>LedgerJournalTrans</c> record and if it
    /// is eligible to be taxed; otherwise, false.
    /// </returns>
    /// <remarks>
    /// A true value does not imply that the account type will be taxed. This only means that it could
    /// potentially be taxed.
    /// </remarks>
    public boolean canAccountTypeBeTaxed(LedgerJournalACType _accountType)
    {
        LedgerJournalTaxDocument ledgerJournalTaxDocument;
        LedgerJournalTaxLine ledgerJournalTaxLine;

        ledgerJournalTaxDocument = LedgerJournalTaxDocument::construct(this.JournalNum, this.Voucher, this.Invoice, this);
        ledgerJournalTaxLine = ledgerJournalTaxDocument.getLineByLedgerJournalTrans(this, ledgerJournalTaxDocument.getTaxOnPrepayment()) as LedgerJournalTaxLine;

        if (this.AccountType == _accountType)
        {
            if (ledgerJournalTaxLine.isPrimaryBeingCalculated())
            {
                return true;
            }
        }

        if (this.OffsetAccountType == _accountType)
        {
            if (ledgerJournalTaxLine.isOffsetBeingCalculated())
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCalculateTDSonPaymentFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether TDS can be calculated on Payment fee record.
    /// </summary>
    /// <returns>
    /// false if the payment fee of type cost otherwise, true.
    /// </returns>
    public boolean canCalculateTDSonPaymentFee()
    {
        CustVendPaymJournalFee custVendPaymJournalFee;
        VendPaymFee            vendPaymFee;

        select firstonly RecId from custVendPaymJournalFee
            where custVendPaymJournalFee.FeeTransRecId == this.RecId
            join RecId  from vendPaymFee
                where vendPaymFee.FeeId == custVendPaymJournalFee.FeeId
                    && vendPaymFee.FeePosting == PaymFeePostingVend::Cost;

        return custVendPaymJournalFee.RecId ? false : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelMandateLogRecord</Name>
				<Source><![CDATA[
    private void cancelMandateLogRecord()
    {
        SpecTrans specTrans;
        CustTransOpen custTransOpen;
        CustTrans custTrans;
        CustDirectDebitMandate custDirectDebitMandate;
        CustDirectDebitMandate custDirectDebitMandateUpdate;
        CustTrans custTransInvoice;
        CustSettlement custSettlementInvoice;
        CustTrans custTransBillOfExchange;

        ttsbegin;

        if (this.DirectDebitMandate)
        {
            changecompany(this.company)
            {
                custDirectDebitMandateUpdate = CustDirectDebitMandate::find(this.DirectDebitMandate, true);
                custDirectDebitMandateUpdate.decreaseUsageCount();
                custDirectDebitMandateUpdate.ExpirationDate = custDirectDebitMandateUpdate.getPreviousExpirationDate();
                custDirectDebitMandateUpdate.update();

                CustDirectDebitMandateLog::cancelRecord(custDirectDebitMandateUpdate.RecId, this.Voucher);
            }
        }

        SpecTransDirectDebitMandate_W specTransDirectDebitMandate;

        while select crosscompany TableId from specTransDirectDebitMandate
            where specTransDirectDebitMandate.SpecCompany == this.DataAreaId
                && specTransDirectDebitMandate.SpecRecId == this.RecId
                && specTransDirectDebitMandate.SpecTableId == this.TableId
                && specTransDirectDebitMandate.BillOfExchangeID == ''
        join RecId from custDirectDebitMandate
            where custDirectDebitMandate.RecId == specTransDirectDebitMandate.DirectDebitMandate
        {
            changecompany(custDirectDebitMandate.company())
            {
                custDirectDebitMandateUpdate = CustDirectDebitMandate::find(custDirectDebitMandate.RecId, true);
                custDirectDebitMandateUpdate.decreaseUsageCount();
                custDirectDebitMandateUpdate.ExpirationDate = custDirectDebitMandateUpdate.getPreviousExpirationDate();
                custDirectDebitMandateUpdate.update();

                CustDirectDebitMandateLog::cancelRecord(custDirectDebitMandateUpdate.RecId, this.Voucher);
            }
        }

        while select crosscompany RecId from custDirectDebitMandate
        join RecId from custTransInvoice
            where custTransInvoice.DirectDebitMandate == custDirectDebitMandate.RecId
        exists join TableId from custSettlementInvoice
            where custSettlementInvoice.OffsetRecid    == custTransInvoice.RecId
        exists join TableId from custTransBillOfExchange
            where custTransBillOfExchange.RecId          == custSettlementInvoice.TransRecId &&
                custTransBillOfExchange.BillOfExchangeID
        exists join TableId from custTrans
            where custTrans.BillOfExchangeID == custTransBillOfExchange.BillOfExchangeID &&
                custTrans.Voucher            == custTransBillOfExchange.Voucher
        exists join TableId from custTransOpen
            where custTransOpen.RefRecId == custTrans.RecId
        exists join TableId from specTrans
            where specTrans.RefRecId == custTransOpen.RecId
                && specTrans.RefTableId  == custTransOpen.TableId
                && specTrans.RefCompany  == custTransOpen.DataAreaId
                && specTrans.SpecCompany == this.company()
                && specTrans.SpecRecId   == this.RecId
                && specTrans.SpecTableId == this.TableId
        {
            changecompany(custTransInvoice.company())
            {
                custDirectDebitMandateUpdate = CustDirectDebitMandate::find(custDirectDebitMandate.RecId, true);
                custDirectDebitMandateUpdate.decreaseUsageCount();
                custDirectDebitMandateUpdate.ExpirationDate = custDirectDebitMandateUpdate.getPreviousExpirationDate();
                custDirectDebitMandateUpdate.update();

                CustDirectDebitMandateLog::cancelRecord(custDirectDebitMandateUpdate.RecId, this.Voucher);
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateBankDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a bank document can be created from the table in current status.
    /// </summary>
    /// <returns>
    /// A bank document can be created from the table in current status.
    /// </returns>
    public boolean canCreateBankDocument()
    {
        if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()))
        {
            BankDocumentBookType documentBookType = this.parmBankDocumentBookType();
            boolean isElectronicPayment = (documentBookType == BankDocumentBookType::CustPayment || documentBookType == BankDocumentBookType::VendPayment) && this.PaymentStatus == CustVendPaymStatus::Sent;
            boolean isBridgingPosting = documentBookType == BankDocumentBookType::BankClearing && BankBridgingTrans::findByBridgedLedgerJournalTransRecId(this.RecId) != null;
            return isElectronicPayment || isBridgingPosting;
        }
        else
        {
            return this.parmBankDocumentBookType() != BankDocumentBookType::None && this.PaymentStatus == CustVendPaymStatus::Sent;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateFixedAssetsSiblingRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a <c>LedgerJournalTrans_Asset</c> sibling record can be created.
    /// </summary>
    /// <returns>
    /// true if the <c>LedgerJournalTrans_Asset</c> sibling should be created; otherwise, false.
    /// </returns>
    public boolean canCreateFixedAssetsSiblingRecord()
    {
        return this.RecId &&
              (this.AccountType == LedgerJournalACType::FixedAssets ||
              (this.OffsetAccountType == LedgerJournalACType::FixedAssets && this.OffsetLedgerDimension));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPrintNonNegotiableCheque</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether non-negotiable checks can be printed against this transaction.
    /// </summary>
    /// <returns>
    /// true if non-negotiable check printing is enabled; otherwise, false.
    /// </returns>
    public boolean canPrintNonNegotiableCheque()
    {
        boolean ret;
        VendPaymModeTable vendPaymModeTable;

        vendPaymModeTable = VendPaymModeTable::find(this.PaymMode);

        if (BankParameters::find().AllowPaymentCopies
            && vendPaymModeTable.AllowPaymentCopies
            && vendPaymModeTable.AccountType == LedgerJournalACType::Bank
            && vendPaymModeTable.PaymentLedgerDimension != 0)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSkipBlockedForManualEntryCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether the current record can skip the
    /// blocked for manual entry check.
    /// </summary>
    /// <returns>
    /// A value that indicates whether the current record can skip the blocked for
    /// manual entry check.
    /// </returns>
    /// <remarks>
    /// This method uses the primary account.
    /// </remarks>
    public boolean canSkipBlockedForManualEntryCheck()
    {
        return this.AccountType != LedgerJournalACType::Ledger
            || (this.Transferred && this.NoEdit); // Approval journals
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountTypesProject</Name>
				<Source><![CDATA[
    private boolean checkAccountTypesProject()
    {
        return ((this.AccountType == LedgerJournalACType::Project) &&
                (this.OffsetAccountType == LedgerJournalACType::Project &&
                 this.OffsetLedgerDimension));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowEdit</Name>
				<Source><![CDATA[
    public boolean checkAllowEdit(boolean _validateDelete = false)
    {
        #macrolib.LedgerAIF
        SysGlobalCache      cache = classfactory.globalCache();
        container           cacheKey;
        boolean             newVoucher;
        LedgerJournalTrans  previousLedgerJournalTrans;
        boolean             ret = true;

        cacheKey = [this.JournalNum, this.Voucher];

        newVoucher = false;
        if (cache.isSet(#LedgerJournalTransPreviousLine, this.JournalNum))
        {
            previousLedgerJournalTrans = cache.get(#LedgerJournalTransPreviousLine, this.JournalNum);
            if (previousLedgerJournalTrans.Voucher != this.Voucher)
            {
                newVoucher = true;
            }
        }

        ret = this.checkAllowEditWhenCheckPrinted(cacheKey, newVoucher);

        if (ret)
        {
            ret = this.checkAllowEditPromissoryNote(cacheKey, newVoucher, _validateDelete);
        }

        if (ret)
        {
            if (this.ledgerJournalTable().Posted)
            {
                ret = checkFailed("@SYS21497");
            }
        }

        if (ret &&
            !FeatureStateProvider::isFeatureEnabled(LedgerJournalSystemBlockedFeatureReverseFlight::instance()) &&
            this.isSystemBlockedByDifferentSession(this.ledgerJournalTable()))
        {
            ret = checkFailed("@GeneralLedger:JournalSystemBlocked");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSystemBlockedByDifferentSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the journal is blocked by system in a different session.
    /// </summary>
    /// <param name = "_journalTable">The journal table.</param>
    /// <returns>
    /// true if the journal is blocked; otherwise, false.
    /// </returns>
    private boolean isSystemBlockedByDifferentSession(JournalTableMap _journalTable)
    {
        JournalBlockLevel journalBlockLevel = JournalTableData::journalBlockLevel(_journalTable);

        return journalBlockLevel == JournalBlockLevel::System && (_journalTable.SessionId != sessionId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowEditPromissoryNote</Name>
				<Source><![CDATA[
    private boolean checkAllowEditPromissoryNote(container _cacheKey, boolean _newVoucher, boolean _validateDelete = false)
    {
        #macrolib.LedgerAIF
        SysGlobalCache              cache = classfactory.globalCache();
        boolean                     errorCondition = false;
        boolean                     ret = true;
        LedgerJournalTrans          ledgerJournalTrans_orig;

        if (!_validateDelete)
        {
            if (cache.isSet(#LedgerJournalTransCanNotBeChangedForPromissoryNote, _cacheKey))
            {
                errorCondition = cache.get(#LedgerJournalTransCanNotBeChangedForPromissoryNote, _cacheKey);
            }
            else
            {
                if (!_newVoucher)
                {
                    select firstonly RecId from ledgerJournalTrans_orig
                    where ledgerJournalTrans_orig.JournalNum == this.JournalNum &&
                          ledgerJournalTrans_orig.Voucher    == this.Voucher    &&
                          ledgerJournalTrans_orig.BankPromissoryNoteNum != '';
                }
                if (ledgerJournalTrans_orig.RecId)
                {
                    errorCondition = true;
                }
            }
        }
        else
        {
            if (cache.isSet(#LedgerJournalTransCanNotBeDeletedForPromissoryNote, _cacheKey))
            {
                errorCondition = cache.get(#LedgerJournalTransCanNotBeDeletedForPromissoryNote, _cacheKey);
            }
            else
            {
                if (!_newVoucher)
                {
                    //To delete a printed line in VendPromissryNoteRedraw, is allowed when CustVendPaymStatus::None
                    select firstonly RecId from ledgerJournalTrans_orig
                    where ledgerJournalTrans_orig.JournalNum == this.JournalNum &&
                          ledgerJournalTrans_orig.Voucher    == this.Voucher    &&
                          ledgerJournalTrans_orig.PaymentStatus != CustVendPaymStatus::None &&
                          ledgerJournalTrans_orig.BankPromissoryNoteNum != '';
                }
                if (ledgerJournalTrans_orig.RecId)
                {
                    errorCondition = true;
                }
            }
        }

        if (errorCondition)
        {
            ret = checkFailed(strFmt("@SYS74147",this.Voucher));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowEditWhenCheckPrinted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the current row may be edited when check is printed.
    /// </summary>
    /// <param name = "_cacheKey">
    /// A container containing the key values like journal number and voucher of journal lines.
    /// </param>
    /// <param name = "_newVoucher">
    /// The boolean value of new voucher exists or not.
    /// </param>
    /// <returns>
    /// Returns true if the current record is valid and ready to be written to the database when check is printed; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean checkAllowEditWhenCheckPrinted(container _cacheKey, boolean _newVoucher)
    {
        #macrolib.LedgerAIF
        SysGlobalCache              cache = classfactory.globalCache();
        boolean                     errorCondition = false;
        boolean                     ret = true;
        LedgerJournalTrans          ledgerJournalTrans_orig;

        #ISOCountryRegionCodes

        if (cache.isSet(#LedgerJournalTransCanNotBeChangedWhenCheckPrinted, _cacheKey))
        {
            errorCondition = cache.get(#LedgerJournalTransCanNotBeChangedWhenCheckPrinted, _cacheKey);
        }
        else
        {
            if (!_newVoucher)
            {
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    ret = this.checkAllowEditPaymentOrder_RU(false);
                    if (! ret)
                    {
                        errorCondition = true;
                    }
                }
                else
                {
                    ledgerJournalTrans_orig.selectLocked(false);

                    select firstonly RecId from ledgerJournalTrans_orig
                    where ledgerJournalTrans_orig.JournalNum    == this.JournalNum &&
                          ledgerJournalTrans_orig.Voucher       == this.Voucher    &&
                          ledgerJournalTrans_orig.PaymentStatus != CustVendPaymStatus::None &&
                          ledgerJournalTrans_orig.BankChequeNum != '';

                    if (ledgerJournalTrans_orig.RecId)
                    {
                        errorCondition = true;
                    }
                }
            }
        }
        if (errorCondition)
        {
            ret = checkFailed(strFmt("@SYS53476",this.Voucher));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowPosting</Name>
				<Source><![CDATA[
    protected boolean checkAllowPosting(
        DimensionDynamicAccount _dimensionDynamicAccount,
        LedgerJournalACType     _ledgerJournalACType,
        SelectableDataArea      _company = curext())
    {
        CompanyId   companyId;
        TableId     tableId;
        FieldId     fieldId;

        #LedgerJournalFaults

        // The following block is needed for the case that intercompany transactions is disabled and someone passes
        // in an empty string. Ideally one would remove the "curext()" defaulting from the paramter list, but this
        // code was added as part of a bug fix, and did not have the scope or need of changing the interface.
        if (!_company)
        {
            companyId = curext();
        }
        else
        {
            companyId = _company;
            if (! xDataArea::exist(companyId))
            {
                // We have to stop processing because the company is invalid.  It is not
                // possible to continue.
                tableId = tableNum(LedgerJournalTrans);
                fieldId = fieldNum(LedgerJournalTrans, Company);
                AifFault::checkFailedLogFault(strFmt("@SYS10666", companyId), #CompanyAccountDoesNotExist);
                throw AifFault::faultList("@SYS98197", #ValidationFailed);
            }
        }

        if (_dimensionDynamicAccount)
        {
            changecompany(companyId)
            {
                switch (_ledgerJournalACType)
                {
                    case LedgerJournalACType::Ledger  :
                        return this.checkAllowPosting_Ledger(_dimensionDynamicAccount);

                    case LedgerJournalACType::Cust    :
                        return this.checkAllowPosting_Cust(_dimensionDynamicAccount);

                    case LedgerJournalACType::Vend    :
                        return this.checkAllowPosting_Vend(_dimensionDynamicAccount);

                    case LedgerJournalACType::Bank    :
                        break;

                    case LedgerJournalACType::Project :
                        return this.checkAllowPosting_Project(_dimensionDynamicAccount);

                    case LedgerJournalACType::FixedAssets :
                        return this.checkAllowPosting_FixedAsset(_dimensionDynamicAccount);

                    case LedgerJournalACType::FixedAssets_RU :
                        return this.checkAllowPosting_FixedAsset_RU(_dimensionDynamicAccount);

                    case LedgerJournalACType::Employee_RU :
                        return this.checkAllowPosting_Employee_RU(_dimensionDynamicAccount);

                    case LedgerJournalACType::RDeferrals :
                        return this.checkAllowPosting_RDeferrals(_dimensionDynamicAccount);

                    case LedgerJournalACType::RCash :
                        return this.checkAllowPosting_RCash(_dimensionDynamicAccount);

                    default :
                        return checkFailed(strFmt("@SYS26719",_ledgerJournalACType));
                }
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkApprovalActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs approval validation on the current record.
    /// </summary>
    /// <returns>
    /// true if validation passes; otherwise, false.
    /// </returns>
    public boolean checkApprovalActive()
    {
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalName   ledgerJournalName;
        #LedgerJournalFaults

        ledgerJournalTable = this.ledgerJournalTable();
        ledgerJournalName = LedgerJournalName::find(ledgerJournalTable.JournalName);

        if (ledgerJournalName.ApproveActive && ledgerJournalTable.ReportedAsReadyBy != '' && ledgerJournalTable.RejectedBy == '')
        {
            if (UserInfoHelp::userInUserGroup(curUserId(), ledgerJournalName.ApproveGroupId))
            {
                return true;
            }
            else
            {
                return AifFault::checkFailedLogFault(strFmt("@SYS117895", ledgerJournalName.JournalName), #NotAuthorizedForJournal);
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBankAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether accounts of type bank are valid.
    /// </summary>
    /// <returns>
    /// true if the bank accounts are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Accounts of type bank are required to be in the current company, other than for a bank transfer.
    /// </remarks>
    public boolean checkBankAccounts()
    {
        boolean isValid = true;

        if (this.Company)
        {
            if (!this.isBankAccountAccountTypeValid())
            {
                isValid = checkFailed("@GLS222364");
            }
        }

        if (isValid && this.OffsetCompany)
        {
            if (!this.isBankAccountOffsetAccountTypeValid())
            {
                isValid = checkFailed("@GLS222364");
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankAccountAccountTypeValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether accounts of type bank are valid.
    /// </summary>
    /// <returns>
    /// true if the bank account are valid; otherwise, false.
    /// </returns>
    protected boolean isBankAccountAccountTypeValid()
    {
        boolean isValid = true;

        if ((this.AccountType == LedgerJournalACType::Bank
            && this.OffsetAccountType != LedgerJournalACType::Bank)
            && (this.Company != curext()))
        {
            isValid = false;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankAccountOffsetAccountTypeValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether offset accounts of type bank are valid.
    /// </summary>
    /// <returns>
    /// true if the offset bank account are valid; otherwise, false.
    /// </returns>
    protected boolean isBankAccountOffsetAccountTypeValid()
    {
        boolean isValid = true;

        if ((this.OffsetAccountType == LedgerJournalACType::Bank
            && this.AccountType != LedgerJournalACType::Bank)
            && (this.OffsetCompany != curext()))
        {
            isValid = false;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the availability of budget funds.
    /// </summary>
    public void checkBudget()
    {
        if (this.RecId != 0)
        {
            // Perform budget check for journal lines.
            BudgetControlAccountingJournalProcessor::submitLedgerJournalVoucherToCheckBudget(
                this.ledgerJournalTable().JournalType,
                this.JournalNum,
                this.company(),
                this.Voucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreditRemainAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the proposed settlements for possible overpayment.
    /// </summary>
    /// <param name="_ledgerPostingMessageCollection">
    /// The posting messages collection; optional.
    /// </param>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is design to be called from the <c>LedgerJournalCheckPost.checkJournal</c> method, not
    /// as validation performed during posting.
    /// </remarks>
    public boolean checkCreditRemainAmountCur(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
        LedgerJournalType ledgerJournalType = this.ledgerJournalTable().JournalType;

        // The validation of the marked transaction balance is not appropriate for the bank reversal, deposit slip cancellation and petty cash journal types.
        if (ledgerJournalType != LedgerJournalType::BankChequeReversal
            && ledgerJournalType != LedgerJournalType::BankDepositPaymCancel
            && (!this.isRCashJournalTypeSupported() || ledgerJournalType != LedgerJournalType::RCash))
        {
            ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId), this.CurrencyCode);
            Amount specAmount = SpecTransManager::getTotalSettleAmountForSpecReference(
                this.company(),
                this.TableId,
                this.RecId,
                this.CurrencyCode,
                this.Company,
                this.TransDate,
                exchangeRateHelper.prepareExchangeRateForStorage(this.crossrate()));

            if ((this.amount() > 0 && specAmount > 0)
                || (this.amount() < 0 && specAmount < 0))
            {
                SysInfoLogStr message = strFmt("@SYS119352", this.Voucher);
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed(message);
                }
                else
                {
                    ok = checkFailed(message);
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRCashJournalTypeSupported</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if RCash journal type is supported by country/region.
    /// </summary>
    /// <returns>
    /// True if RCash journal type is supported by country/region; otherwise, false.
    /// </returns>
    protected boolean isRCashJournalTypeSupported()
    {
        return FeatureStateProvider::isFeatureEnabled(PettyCashFeature::instance()) || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU , #isoPL, #isoCZ, #isoHU, #isoLT, #isoLV, #isoEE]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxCode</Name>
				<Source><![CDATA[
    internal boolean checkTaxCode(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        if (this.TaxCode && !TaxTable::exist(this.TaxCode))
        {
            if (_ledgerPostingMessageCollection)
            {
                return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS21976", this.TaxCode));
            }
            else
            {
                return checkFailed(strFmt("@SYS21976", this.TaxCode));
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCurrency</Name>
				<Source><![CDATA[
    public boolean checkCurrency(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        if (this.CurrencyCode && ! this.ExchRate)
        {
            if (_ledgerPostingMessageCollection)
            {
                return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS20792", this.CurrencyCode));
            }
            else
            {
                return checkFailed(strFmt("@SYS20792", this.CurrencyCode));
            }
        }

        if (this.CurrencyCode && ! Currency::exist(this.CurrencyCode))
        {
            if (_ledgerPostingMessageCollection)
            {
                return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS1458", this.CurrencyCode));
            }
            else
            {
                return checkFailed(strFmt("@SYS1458", this.CurrencyCode));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDataAreaAccessible</Name>
				<Source><![CDATA[
    public boolean checkDataAreaAccessible(SelectableDataArea dataAreaId)
    {
        const str CheckDataAreaAccessible = 'CheckDataAreaAccessible';
        SysGlobalCache cache = classfactory.globalCache();
        boolean isValid;

        if (cache.isSet(CheckDataAreaAccessible, dataAreaId))
        {
            isValid = cache.get(CheckDataAreaAccessible, dataAreaId);

            if (!isValid)
            {
                // Throw the same warnings as if it wasnt stored in the cache
                warning(strfmt("@SYS10666", dataAreaId));
            }
        }
        else
        {
            isValid = xDataArea::checkAccessible(dataAreaId);
            cache.set(CheckDataAreaAccessible, dataAreaId, isValid);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExchRate</Name>
				<Source><![CDATA[
    private boolean checkExchRate()
    {
        boolean ret = true;
        CurrencyCode companyCurrencyCode;
        ExchangeRateHelper  exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId), this.CurrencyCode);

        // This method is used to validate the Exch rate field.  Since the exchange rate
        // is for the account company need to use the account company currency code during validation
        // when this is an intercompany transaction.

        if (this.isCompanyIntercompany(this.company()))
        {
            changecompany(this.Company)
            {
                companyCurrencyCode = CompanyInfoHelper::standardCurrency();
            }
        }
        else
        {
            companyCurrencyCode = CompanyInfoHelper::standardCurrency();
        }

        if (this.ExchRate != 100.00 && this.CurrencyCode == companyCurrencyCode)
        {
            ret = checkFailed(strFmt("@SYS85793", exchangeRateHelper.displayStoredExchangeRate(100)));
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReportingCurrencyExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to validate the reporting Exch rate field.  Since the exchange rate
    /// is for the account company need to use the account reporting currency code during validation
    /// when this is an intercompany transaction.
    /// </summary>
    private boolean checkReportingCurrencyExchRate()
    {
        boolean ret = true;
        CurrencyCode reportingCurrencyCode;

        ExchangeRateHelper  exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId), this.CurrencyCode);

        exchangeRateHelper.parmToCurrency(Ledger::reportingCurrency());
        exchangeRateHelper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());

        if (this.isCompanyIntercompany(this.company()))
        {
            changecompany(this.Company)
            {
                reportingCurrencyCode = Ledger::reportingCurrency();
            }
        }
        else
        {
            reportingCurrencyCode = Ledger::reportingCurrency();
        }

        if (this.ReportingCurrencyExchRate != 100.00 && this.CurrencyCode == reportingCurrencyCode)
        {
            ret = checkFailed(strFmt("@GeneralLedger:CurrencyExchRateForReportingCurrencyMustBe100", exchangeRateHelper.displayStoredExchangeRate(100)));
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInterCompany</Name>
				<Source><![CDATA[
    public boolean checkInterCompany(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok;

        ok = this.isInterCompanySupportedByTransType();

        if (ok && this.isCompanyIntercompany())
        {
            LedgerInterCompany ledgerInterCompany = LedgerInterCompany::findCompanyPair(curExt(), this.Company);

            if (!ledgerInterCompany.OriginatingDebitLedgerDimension ||
                !ledgerInterCompany.OriginatingCreditLedgerDimension ||
                !ledgerInterCompany.DestinationCreditLedgerDimension ||
                !ledgerInterCompany.DestinationDebitLedgerDimension)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS21636", this.Company));
                }
                else
                {
                    ok = checkFailed(strFmt("@SYS21636", this.Company));
                }
            }
        }

        if (ok && this.OffsetLedgerDimension && this.isOffsetCompanyIntercompany())
        {
            LedgerInterCompany ledgerInterCompany = LedgerInterCompany::findCompanyPair(curExt(), this.OffsetCompany);

            if (!ledgerInterCompany.OriginatingDebitLedgerDimension ||
                !ledgerInterCompany.OriginatingCreditLedgerDimension ||
                !ledgerInterCompany.DestinationCreditLedgerDimension ||
                !ledgerInterCompany.DestinationDebitLedgerDimension)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS21636", this.OffsetCompany));
                }
                else
                {
                    ok = checkFailed(strFmt("@SYS21636", this.OffsetCompany));
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalAccountControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs journal control validation on the current record.
    /// </summary>
    /// <returns>
    /// true if journal control validation passes; otherwise, false.
    /// </returns>
    public boolean checkJournalAccountControl()
    {
        boolean isValid;
        LedgerJournalNameId journalName;

        journalName = this.ledgerJournalTable().JournalName;

        isValid = LedgerJournalControlHeader::validate(
            this.Company,
            this.AccountType,
            this.LedgerDimension,
            journalName,
            true);

        // only validate the offset account when it has a value
        if (this.OffsetLedgerDimension != 0 && isValid)
        {
            isValid = LedgerJournalControlHeader::validate(
                this.getOffsetCompany(),
                this.OffsetAccountType,
                this.OffsetLedgerDimension,
                journalName,
                true);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettleVoucherForNegInstPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the settlement voucher type.
    /// </summary>
    /// <returns>
    ///     true if the settlement voucher type is not selectedTransact; otherwise, false.
    /// </returns>
    protected boolean checkSettleVoucherForNegInstPosting()
    {
        return this.SettleVoucher != SettlementType::SelectedTransact;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNegInstPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the negotiable instrument journal is valid for posting.
    /// </summary>
    /// <param name = "_ledgerPostingMessageCollection">
    ///     The posting messages collection.
    /// </param>
    /// <returns>
    ///     true if the negotiable instrument journal is valid for posting; otherwise, false.
    /// </returns>
    public boolean checkNegInstPosting(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean                 ok = true;
        SpecTrans               specTransFieldList;
        CustTrans               markedCustTrans;
        CustBillOfExchangeTrans custBillOfExchangeTrans;
        VendTrans               markedVendTrans;

        switch (this.ledgerJournalTable().JournalType)
        {
            case LedgerJournalType::CustBillOfExchangeDraw :
                while select crossCompany RefCompany, RefTableId, RefRecId from specTransFieldList
                    where specTransFieldList.SpecCompany == this.company()
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecRecId == this.RecId
                {
                    markedCustTrans = specTransFieldList.custTrans();

                    custBillOfExchangeTrans =  CustBillOfExchangeTrans::findIdVoucherDate(
                                                markedCustTrans.BillOfExchangeID,
                                                markedCustTrans.Voucher,
                                                markedCustTrans.TransDate);

                    if (custBillOfExchangeTrans.RecId != 0)
                    {
                        // The transaction cannot be marked from a draw BOE
                        if (_ledgerPostingMessageCollection)
                        {
                            ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71530");
                        }
                        else
                        {
                            ok = checkFailed("@SYS71530");
                        }
                    }
                }

                if (this.checkSettleVoucherForNegInstPosting())
                {
                    // Transaction(s) must be marked to settle from a draw BOE
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS74480");
                    }
                    else
                    {
                        ok = checkFailed("@SYS74480");
                    }
                }

                if (this.AmountCurDebit != 0.0)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@CashManagement:BillOfExchangeDebitBalanceError");
                    }
                    else
                    {
                        ok = checkFailed("@CashManagement:BillOfExchangeDebitBalanceError");
                    }
                }

                break;

            case LedgerJournalType::CustBillOfExchangeProtest :
                while select crossCompany RefCompany, RefTableId, RefRecId from specTransFieldList
                    where specTransFieldList.SpecCompany == this.company()
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecRecId == this.RecId
                {
                    markedCustTrans = specTransFieldList.custTrans();

                    custBillOfExchangeTrans =  CustBillOfExchangeTrans::findIdVoucherDate(
                                                markedCustTrans.BillOfExchangeID,
                                                markedCustTrans.Voucher,
                                                markedCustTrans.TransDate);

                    if (custBillOfExchangeTrans.RecId == 0)
                    {
                        // Only other BOE transactions can be protested
                        if (_ledgerPostingMessageCollection)
                        {
                            ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71688");
                        }
                        else
                        {
                            ok = checkFailed("@SYS71688");
                        }
                    }
                    else
                    {
                        if (custBillOfExchangeTrans.Status != CustVendNegInstStatus::Drawn      &&
                            custBillOfExchangeTrans.Status != CustVendNegInstStatus::Redrawn    &&
                            custBillOfExchangeTrans.Status != CustVendNegInstStatus::Remitted   &&
                            custBillOfExchangeTrans.Status != CustVendNegInstStatus::Honored)
                        {
                            // Only draw, redraw, remittance and settled BOE transactions can be protested
                            if (_ledgerPostingMessageCollection)
                            {
                                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71555");
                            }
                            else
                            {
                                ok = checkFailed("@SYS71555");
                            }
                        }
                    }
                }

                break;

            case LedgerJournalType::CustBillOfExchangeRedraw :
                while select crossCompany RefCompany, RefTableId, RefRecId from specTransFieldList
                    where specTransFieldList.SpecCompany == this.company()
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecRecId == this.RecId
                {
                    markedCustTrans = specTransFieldList.custTrans();

                    custBillOfExchangeTrans =  CustBillOfExchangeTrans::findIdVoucherDate(
                                                markedCustTrans.BillOfExchangeID,
                                                markedCustTrans.Voucher,
                                                markedCustTrans.TransDate);

                    if (custBillOfExchangeTrans.RecId == 0)
                    {
                        // Only other BOE transactions can be redrawn
                        if (_ledgerPostingMessageCollection)
                        {
                            ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71688");
                        }
                        else
                        {
                            ok = checkFailed("@SYS71688");
                        }
                    }
                    else
                    {
                        if (custBillOfExchangeTrans.Status != CustVendNegInstStatus::Protested)
                        {
                            // Only protested BOE transactions can be redrawn
                            if (_ledgerPostingMessageCollection)
                            {
                                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71558");
                            }
                            else
                            {
                                ok = checkFailed("@SYS71558");
                            }
                        }
                    }
                }

                break;

            case LedgerJournalType::CustPaymRemittance :
                while select crossCompany RefCompany, RefTableId, RefRecId from specTransFieldList
                    where specTransFieldList.SpecCompany == this.company()
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecRecId == this.RecId
                {
                    markedCustTrans = specTransFieldList.custTrans();

                    custBillOfExchangeTrans =  CustBillOfExchangeTrans::findIdVoucherDate(
                                                markedCustTrans.BillOfExchangeID,
                                                markedCustTrans.Voucher,
                                                markedCustTrans.TransDate);

                    if (custBillOfExchangeTrans.RecId == 0)
                    {
                        // Only other BOE transactions can be remitted
                        if (_ledgerPostingMessageCollection)
                        {
                            ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71688");
                        }
                        else
                        {
                            ok = checkFailed("@SYS71688");
                        }
                    }
                    else
                    {
                        if (custBillOfExchangeTrans.Status != CustVendNegInstStatus::Drawn      &&
                            custBillOfExchangeTrans.Status != CustVendNegInstStatus::Redrawn)
                        {
                            // Only drawn and redrawn BOE transactions can be remitted
                            if (_ledgerPostingMessageCollection)
                            {
                                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71567");
                            }
                            else
                            {
                                ok = checkFailed("@SYS71567");
                            }
                        }
                    }

                    if (!this.BankAccountId)
                    {
                        // A bank account is required for a remittance BOE
                        if (_ledgerPostingMessageCollection)
                        {
                            ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS74043");
                        }
                        else
                        {
                            ok = checkFailed("@SYS74043");
                        }
                    }
                }

                break;

            case LedgerJournalType::CustBillOfExchangeSettle :
                while select crossCompany RefCompany, RefTableId, RefRecId from specTransFieldList
                    where specTransFieldList.SpecCompany == this.company()
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecRecId == this.RecId
                {
                    markedCustTrans = specTransFieldList.custTrans();

                    custBillOfExchangeTrans =  CustBillOfExchangeTrans::findIdVoucherDate(
                                                markedCustTrans.BillOfExchangeID,
                                                markedCustTrans.Voucher,
                                                markedCustTrans.TransDate);

                    if (custBillOfExchangeTrans.RecId == 0)
                    {
                        // Only other BOE transactions can be settled
                        if (_ledgerPostingMessageCollection)
                        {
                            ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71688");
                        }
                        else
                        {
                            ok = checkFailed("@SYS71688");
                        }
                    }
                }

                break;

            case LedgerJournalType::VendPromissoryNoteDraw :
                while select crossCompany RefCompany, RefTableId, RefRecId from specTransFieldList
                    where specTransFieldList.SpecCompany == this.company()
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecRecId == this.RecId
                {
                    markedVendTrans = specTransFieldList.vendTrans();

                    switch (markedVendTrans.PromissoryNoteStatus)
                    {
                        case CustVendNegInstStatus::None:
                        case CustVendNegInstStatus::Invoiced:
                            break;
                        default:
                            if (_ledgerPostingMessageCollection)
                            {
                                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71711");
                            }
                            else
                            {
                                ok = checkFailed("@SYS71711");
                            }
                    }
                }

                if (this.checkSettleVoucherForNegInstPosting())
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS75395");
                    }
                    else
                    {
                        ok = checkFailed("@SYS75395");
                    }
                }

                if (this.AmountCurCredit != 0.0)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@CashManagement:PromissoryNoteCreditBalanceError");
                    }
                    else
                    {
                        ok = checkFailed("@CashManagement:PromissoryNoteCreditBalanceError");
                    }
                }

                break;

            case LedgerJournalType::VendPromissoryNoteRedraw :
                while select crossCompany RefCompany, RefTableId, RefRecId from specTransFieldList
                    where specTransFieldList.SpecCompany == this.company()
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecRecId == this.RecId
                {
                    markedVendTrans = specTransFieldList.vendTrans();

                    switch (markedVendTrans.PromissoryNoteStatus)
                    {
                        case CustVendNegInstStatus::None:
                            if (_ledgerPostingMessageCollection)
                            {
                                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71692");
                            }
                            else
                            {
                                ok = checkFailed("@SYS71692");
                            }
                            break;
                        case CustVendNegInstStatus::Honored:
                            break;
                        default:
                            if (_ledgerPostingMessageCollection)
                            {
                                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71559");
                            }
                            else
                            {
                                ok = checkFailed("@SYS71559");
                            }
                            break;
                    }
                }

                break;

            case LedgerJournalType::VendPaymRemittance :
                while select crossCompany RefCompany, RefTableId, RefRecId from specTransFieldList
                    where specTransFieldList.SpecCompany == this.company()
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecRecId == this.RecId
                {
                    markedVendTrans = specTransFieldList.vendTrans();

                    switch (markedVendTrans.PromissoryNoteStatus)
                    {
                        case CustVendNegInstStatus::None:
                            if (_ledgerPostingMessageCollection)
                            {
                                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71692");
                            }
                            else
                            {
                                ok = checkFailed("@SYS71692");
                            }
                            break;
                        case CustVendNegInstStatus::Drawn:
                        case CustVendNegInstStatus::Redrawn:
                        case CustVendNegInstStatus::Invoiced:
                            break;
                        default:
                            if (_ledgerPostingMessageCollection)
                            {
                                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71568");
                            }
                            else
                            {
                                ok = checkFailed("@SYS71568");
                            }
                    }
                }
                if (!this.BankAccountId)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS74043");
                    }
                    else
                    {
                        ok = checkFailed("@SYS74043");
                    }
                }

                break;

            case LedgerJournalType::VendPromissoryNoteSettle :
                while select crossCompany RefCompany, RefTableId, RefRecId from specTransFieldList
                    where specTransFieldList.SpecCompany == this.company()
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecRecId == this.RecId
                {
                    markedVendTrans = specTransFieldList.vendTrans();

                    switch (markedVendTrans.PromissoryNoteStatus)
                    {
                        case CustVendNegInstStatus::None:
                            if (_ledgerPostingMessageCollection)
                            {
                                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS71692");
                            }
                            else
                            {
                                ok = checkFailed("@SYS71692");
                            }
                            break;

                        case CustVendNegInstStatus::Invoiced,
                             CustVendNegInstStatus::Protested:
                            if (_ledgerPostingMessageCollection)
                            {
                                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS73399");
                            }
                            else
                            {
                                ok = checkFailed("@SYS73399");
                            }
                            break;
                    }
                }

                break;

            default :
                ok = true;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymentFilledOk</Name>
				<Source><![CDATA[
    public boolean checkPaymentFilledOk(LedgerJournalTable _ledgerJournalTable, Map _tmpVoucherMap = null)
    {
        boolean ok = true;

        switch (_ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::CustPayment:
                if (this.AccountType == LedgerJournalACType::Cust)
                {
                    ok = this.custPaymentFilledOk(_tmpVoucherMap);
                }
                break;

            case LedgerJournalType::Payment:
                if (this.AccountType == LedgerJournalACType::Vend)
                {
                    ok = this.vendPaymentFilledOk(_tmpVoucherMap);
                }
                break;

            default:
                switch (this.AccountType)
                {
                    case LedgerJournalACType::Cust:
                        if (this.AmountCurCredit)
                        {
                            ok = this.custPaymentFilledOk(_tmpVoucherMap);
                        }
                        break;

                    case LedgerJournalACType::Vend:
                        if (this.AmountCurDebit)
                        {
                            ok = this.vendPaymentFilledOk(_tmpVoucherMap);
                        }
                        break;
                }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymentReferenceIS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies whether the payment reference is required for the transaction record.
    /// </summary>
    /// <param name="_ledgerJournalTrans_Asset">
    /// A table buffer representing the fix asset information related to the <c>LedgerJournalTrans</c>
    /// record; optional.
    /// </param>
    /// <returns>
    /// false if the general ledger account has the Mandatory Payment Reference option selected and the
    /// Payment Reference field is empty; otherwise, true.
    /// </returns>
    /// <remarks>
    /// A check for the payment reference is executed for ledger accounts only. However, this is a public
    /// method and you can pass in a <c>LedgerJournalTrans</c> record together with a
    /// <c>LedgerJournalTrans_Asset</c> instance that has not been committed to the database.
    /// </remarks>
    public boolean checkPaymentReferenceIS(LedgerJournalTrans_Asset _ledgerJournalTrans_Asset =
                                           this.findLedgerJournalTransAssetSibling())
    {
        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIS00003, funcName());

        CompanyId                       companyId;
        boolean                         ok = true;
        LedgerDimensionDefaultAccount   ledgerDimensionDefaultAccount;
        MainAccount                     mainAccount;

        if (this.LedgerDimension && this.PaymReference == '')
        {
            switch (this.AccountType)
            {
                case LedgerJournalACType::Ledger,
                     LedgerJournalACType::Project,
                     LedgerJournalACType::FixedAssets:
                    ledgerDimensionDefaultAccount = LedgerJournalEngine::getDefaultAccount(this, _ledgerJournalTrans_Asset);
                    break;

                case LedgerJournalACType::Bank :
                    ledgerDimensionDefaultAccount = BankAccountTable::findByLedgerDimension(this.LedgerDimension).LedgerDimension;
                    break;

                case LedgerJournalACType::Cust :
                    ledgerDimensionDefaultAccount = CustLedgerAccounts::summaryLedgerDimension(this.parmAccount(), CustParameters::find().PostingProfile);
                    break;

                case LedgerJournalACType::Vend :
                    ledgerDimensionDefaultAccount = VendLedgerAccounts::summaryLedgerDimension(this.parmAccount(), VendParameters::find().PostingProfile);
                    break;

                default :
                    ledgerDimensionDefaultAccount = 0;
            }

            // The following block is needed for the case that intercompany transactions is disabled
            // and someone passes in an empty string.
            companyId = this.Company;
            if (!companyId)
            {
                companyId = curext();
            }
            else
            {
                if (! xDataArea::exist(companyId))
                {
                    throw error(strFmt("@SYS10666",companyId));
                }
            }

            changecompany(companyId)
            {
                mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimensionDefaultAccount);
                if (mainAccount.MandatoryPaymentReference)
                {
                    ok = checkFailed(strFmt("@SYS113268", this.Voucher, mainAccount.MainAccountId,
                                            this.accountNameFind(LedgerJournalACType::Ledger, ledgerDimensionDefaultAccount, companyId)));
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPrepaymentTaxGroups</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies the tax groups of a prepayment against any linked advance invoices.
    /// </summary>
    /// <param name="_ledgerPostingMessageCollection">
    /// The posting messages collection; optional.
    /// </param>
    /// <remarks>
    /// This method will only issue warnings, and therefore does not return a status.
    /// </remarks>
    public void checkPrepaymentTaxGroups(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        CzVendAdvanceInvoiceTable   vendAdvanceInvoiceTable;
        CzCustAdvanceInvoiceTable   custAdvanceInvoiceTable;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL, #isoCZ, #isoHU]))
        {
            if (this.Prepayment && this.isTaxable())
            {
                // For taxable prepayments, warn of any linked advance invoices having different tax groups.
                if (this.AccountType == LedgerJournalACType::Vend)
                {
                    vendAdvanceInvoiceTable = CzVendAdvanceInvoiceTable::findAllForPaymentDifferentTaxGroups(this);
                    while (vendAdvanceInvoiceTable)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            _ledgerPostingMessageCollection.logAndThrowWarning(strFmt("@GLS223588", vendAdvanceInvoiceTable.InvoiceId, this.Voucher));
                        }
                        else
                        {
                            warning(strFmt("@GLS223588", vendAdvanceInvoiceTable.InvoiceId, this.Voucher));
                        }
                        next vendAdvanceInvoiceTable;
                    }
                }
                else if (this.AccountType == LedgerJournalACType::Cust)
                {
                    custAdvanceInvoiceTable = CzCustAdvanceInvoiceTable::findAllForPaymentDifferentTaxGroups(this);
                    while (custAdvanceInvoiceTable)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            _ledgerPostingMessageCollection.logAndThrowWarning(strFmt("@GLS223588", custAdvanceInvoiceTable.InvoiceId, this.Voucher));
                        }
                        else
                        {
                            warning(strFmt("@GLS223588", custAdvanceInvoiceTable.InvoiceId, this.Voucher));
                        }
                        next custAdvanceInvoiceTable;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjId</Name>
				<Source><![CDATA[
    public boolean checkProjId()
    {
        boolean ret = true;

        if ( (this.AccountType == LedgerJournalACType::Project) && this.LedgerDimension)
        {
            ProjTable projTable = ProjTable::findByLedgerDimension(this.LedgerDimension);

            ret = ret & projTable.checkActiveInTree();

        }

        if (ret && (this.OffsetAccountType == LedgerJournalACType::Project) && this.OffsetLedgerDimension)
        {
            ProjTable projTable = ProjTable::findByLedgerDimension(this.OffsetLedgerDimension);

            ret = ret & projTable.checkActiveInTree();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReasonRefRecID</Name>
				<Source><![CDATA[
    public boolean checkReasonRefRecID(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        ReasonCode          reasonCode;
        ReasonTable         reasonTable;
        boolean             isValid = true;
        LedgerJournalType   ledgerJournalType;
        LedgerJournalTable  ledgerJournalTable  = this.ledgerJournalTable();

        ledgerJournalType = ledgerJournalTable.JournalType;

        // isValidrieve the Reaon code from the reason reference table.
        reasonCode = ReasonTableRef::find(this.ReasonRefRecID).Reason;

        if (isValid &&
            reasonCode)
        {
            reasonTable = ReasonTable::find(reasonCode);
            if (reasonTable.RecId == 0)
            {
                if (_ledgerPostingMessageCollection)
                {
                    isValid = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS112224", reasonCode, fieldPName(ReasonTable, Reason), tablePName(ReasonTable)));
                }
                else
                {
                    isValid = checkFailed(strFmt("@SYS112224", reasonCode, fieldPName(ReasonTable, Reason), tablePName(ReasonTable)));
                }
            }
        }

        // Validate Reason code for these journals.
        if (isValid &&
           (ledgerJournalType == LedgerJournalType::BankChequeReversal ||
            ledgerJournalType == LedgerJournalType::BankDepositPaymCancel))
        {
            if (!reasonCode)
            {
                if ((ledgerJournalType == LedgerJournalType::BankChequeReversal &&
                     BankParameters::find().RequireChequeReversalReason) ||
                    (ledgerJournalType == LedgerJournalType::BankDepositPaymCancel &&
                     BankParameters::find().RequireDepositCancelReason))
                {
                    // The Reason code required.
                    if (_ledgerPostingMessageCollection)
                    {
                        isValid = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS26332", "@SYS111246"));
                    }
                    else
                    {
                        isValid = checkFailed(strFmt("@SYS26332", "@SYS111246"));
                    }
                }
            }
            else
            {
                // If a Reason code is blank then these validations will not occur.
                if (reasonTable.Bank == NoYes::No)
                {
                    // The Reason code is not active for 'Bank' transactions.
                    if (_ledgerPostingMessageCollection)
                    {
                        isValid = _ledgerPostingMessageCollection.logCheckFailed("@SYS115522");
                    }
                    else
                    {
                        isValid = checkFailed("@SYS115522");
                    }
                }
                else
                {
                    switch (ledgerJournalType)
                    {
                        case LedgerJournalType::BankChequeReversal:
                            if ((this.AccountType == LedgerJournalACType::Cust &&
                                 reasonTable.Cust == NoYes::No) ||
                                (this.AccountType == LedgerJournalACType::Vend &&
                                 reasonTable.Vend == NoYes::No))
                            {
                                // The Reason code is not active for 'Customer or Vendor' transactions.
                                if (_ledgerPostingMessageCollection)
                                {
                                    isValid = _ledgerPostingMessageCollection.logCheckFailed("@SYS115522");
                                }
                                else
                                {
                                    isValid = checkFailed("@SYS115522");
                                }
                            }
                            break;

                        case LedgerJournalType::BankDepositPaymCancel:
                            if ((this.AccountType   == LedgerJournalACType::Cust &&
                                 reasonTable.Cust   == NoYes::No) ||
                                (this.AccountType   == LedgerJournalACType::Ledger &&
                                 reasonTable.Ledger == NoYes::No))
                            {
                                // The Reason code is not active for 'Customer or ledger' transactions.
                                if (_ledgerPostingMessageCollection)
                                {
                                    isValid = _ledgerPostingMessageCollection.logCheckFailed("@SYS115522");
                                }
                                else
                                {
                                    isValid = checkFailed("@SYS115522");
                                }
                            }
                            break;
                    }
                }
            }
        }
        else if (isValid && !reasonCode && ledgerJournalType == LedgerJournalType::Assets)
        {
            LedgerJournalTrans_Asset ledgerJournalTrans_Asset = LedgerJournalTrans_Asset::find(this.RecId);

            if (AssetParameters::transTypeRequiresValidation(ledgerJournalTrans_Asset.TransType))
            {
                if (_ledgerPostingMessageCollection)
                {
                    isValid = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS26332", "@SYS111246"));
                }
                else
                {
                    isValid = checkFailed(strFmt("@SYS26332", "@SYS111246"));
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReleaseDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the release date against the current date.
    /// </summary>
    /// <param name="_ledgerPostingMessageCollection">
    /// The posting messages collection; optional.
    /// </param>
    /// <returns>
    /// true if the release date is satisfied (in the past) and the transaction can be posted; otherwise,
    /// false.
    /// </returns>
    public boolean checkReleaseDate(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
        utcdatetime localUtc;

        if (this.ReleaseDate != utcDateTimeNull() && this.ReleaseDate > DateTimeUtil::utcNow())
        {
            localUtc = DateTimeUtil::applyTimeZoneOffset(this.ReleaseDate, DateTimeUtil::getUserPreferredTimeZone());

            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS114593", datetime2str(localUtc, DateFlags::FormatAll)));
            }
            else
            {
                ok = checkFailed(strFmt("@SYS114593", datetime2str(localUtc, DateFlags::FormatAll)));
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVATNumJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the tax exempt number status for the journal line.
    /// </summary>
    /// <returns>
    /// true if the tax exempt number status for the journal line is valid; otherwise, false.
    /// </returns>
    protected boolean checkVATNumJournal()
    {
        boolean     ret = true;

        if (this.ledgerJournalTable().JournalType == LedgerJournalType::VendPaymRemittance       ||
           (this.ledgerJournalTable().JournalType == LedgerJournalType::VendPromissoryNoteSettle &&
            VendParameters::find().NotesJournalsValidations))
        {
            return true;
        }

        if (this.AccountType == LedgerJournalACType::Cust && this.Invoice)
        {
            if (this.checkCustIsVATNumMandatory())
            {
                ret = checkFailed("@SYS54494");
            }
        }
        else
        {
            if (this.AccountType == LedgerJournalACType::Vend && this.Invoice)
            {
                if (this.checkVendIsVATNumMandatory())
                {
                    ret = checkFailed("@SYS54494");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustIsVATNumMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the tax exempt number is mandatory for customer and is specified.
    /// </summary>
    /// <returns>
    /// true if the tax exempt number is mandatory and not specified; otherwise, false.
    /// </returns>
    protected boolean checkCustIsVATNumMandatory()
    {
        return TaxVATNumTable::isVATNumMandatory(CustParameters::find().MandatoryInvoiceVATNum, this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVendIsVATNumMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the tax exempt number is mandatory for vendor and is specified.
    /// </summary>
    /// <returns>
    /// true if the tax exempt number is mandatory and not specified; otherwise, false.
    /// </returns>
    protected boolean checkVendIsVATNumMandatory()
    {
        return TaxVATNumTable::isVATNumMandatory(VendParameters::find().MandatoryInvoiceVATNum, this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVATPosting</Name>
				<Source><![CDATA[
    public boolean checkVATPosting()
    {
        boolean                 ok;
        TaxLedgerAccountGroup   taxLedgerAccountGroupFieldList;
        MainAccount             mainAccount;
        LedgerJournalTable      ledgerJournalTable;
        #ISOCountryRegionCodes
        LedgerDimensionDefaultAccount       defaultAccount;
        boolean                             countryRegion_RU;
        ok = true;

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return ok;
        }

        // skip validation if the journal is an adjustmentJournal
        ledgerJournalTable = this.ledgerJournalTable();
        boolean skipTaxValidation = ledgerJournalTable.IsAdjustmentJournal
            && FeatureStateProvider::isFeatureEnabled(GeneralLedgerAdjustmentFeature::instance());

        if (this.TaxCode == '' && this.AccountType == LedgerJournalACType::Ledger && !skipTaxValidation)
        {
            mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(this.LedgerDimension);

            if (mainAccount &&
                MainAccount::existLedgerPostingType(mainAccount.RecId, LedgerPostingType::Tax))
            {
                defaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(this.LedgerDimension);

                countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
                select firstonly RecId from taxLedgerAccountGroupFieldList
                    where   taxLedgerAccountGroupFieldList.TaxReportLedgerDimension == defaultAccount
                            || (countryRegion_RU
                                 && (
                                       taxLedgerAccountGroupFieldList.TaxDeferredLedgerDimension_RU         == defaultAccount
                                    || taxLedgerAccountGroupFieldList.TaxOutgoingOffsetLedgerDimension_RU   == defaultAccount
                                    || taxLedgerAccountGroupFieldList.TaxIncomingPaymentLedgerDimension_RU  == defaultAccount
                                    || taxLedgerAccountGroupFieldList.TaxIncomingLedgerDimension            == defaultAccount
                                    || taxLedgerAccountGroupFieldList.TaxOffsetUseTaxLedgerDimension        == defaultAccount
                                    )
                                 );

                if (!taxLedgerAccountGroupFieldList.RecId)
                {
                    return checkFailed("@SYS27130");
                }
            }
        }

        ok = this.checkVatTransaction() && ok;
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVatTransaction</Name>
				<Source><![CDATA[
    protected boolean checkVatTransaction()
    {
        #ISOCountryRegionCodes
        RTax25LedgerAccountGroup    rTax25LedgerAccountGroup;
        boolean                     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        TaxLedgerAccounts_IN        taxLedgerAccounts;
        TaxLedgerAccountGroup_IN    taxLedgerAccountGrp;
        TaxLedgerAccountSetup_IN    taxLedgerAccountSetup;
        boolean                     taxesMarked = TaxParameters::checkTaxParameters_IN();
        boolean                         ok = true;
        TaxLedgerAccountGroup           taxLedgerAccountGroup;
        LedgerDimensionDefaultAccount   ledgerDimensionDefaultAccount;

        if ((this.AccountType == LedgerJournalACType::Ledger || this.AccountType == LedgerJournalACType::Project)  && this.TaxCode)
        {
            taxLedgerAccountGroup = TaxLedgerAccountGroup::find(TaxTable::find(this.TaxCode).TaxAccountGroup);

            if (countryRegion_RU)
            {
                rTax25LedgerAccountGroup = RTax25LedgerAccountGroup::find(taxLedgerAccountGroup.TaxAccountGroup);
            }
            if (taxesMarked)
            {
                taxLedgerAccountGrp   = TaxLedgerAccountGroup_IN::find(TaxTable::find(this.TaxCode).TaxLedgerAccountGroup_IN);
            }

            ledgerDimensionDefaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(this.LedgerDimension);
            if (this.checkVATDefaultAccount(ledgerDimensionDefaultAccount,
                                            taxLedgerAccountGroup,
                                            rTax25LedgerAccountGroup,
                                            countryRegion_RU))
            {
                ok = true;
            }

            else if (taxLedgerAccountGrp)
            {
                select firstonly taxLedgerAccounts
                    exists join taxLedgerAccountSetup
                    where taxLedgerAccountSetup.RecId  == taxLedgerAccounts.TaxLedgerAccountSetup
                        && taxLedgerAccountSetup.TaxLedgerAccountGroup == taxLedgerAccountGrp.RecId;

                if (taxLedgerAccounts)
                {
                    ok = true;
                }
                else
                {
                    return checkFailed(strFmt("@GLS5805", LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(ledgerDimensionDefaultAccount), taxLedgerAccountGrp.TaxAccountGroup, this.TaxCode));
                }
            }
            else
            {
                if (taxesMarked && TaxTable::find(this.TaxCode).TaxType_IN != TaxType_IN::None)
                {
                    return checkFailed(strFmt("@GLS5805", LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(ledgerDimensionDefaultAccount), taxLedgerAccountGrp.TaxAccountGroup, this.TaxCode));
                }
                else
                {
                    ok = checkFailed(strFmt("@SYS323550",
                                        LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(ledgerDimensionDefaultAccount),
                                        taxLedgerAccountGroup.TaxAccountGroup,
                                        this.TaxCode));
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVATDefaultAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the Ledger dimension default account.
    /// </summary>
    /// <param name = "_ledgerDimensionDefaultAccount">
    /// The <c>LedgerDimensionDefaultAccount</c> record.
    /// </param>
    /// <param name = "_taxLedgerAccountGroup">
    /// The Tax ledger account group.
    /// </param>
    /// <param name = "_rTax25LedgerAccountGroup">
    /// The RTax25 ledger account group.
    /// </param>
    /// <param name = "_countryRegion_RU">
    /// A boolean value for validating if the country context is RU.
    /// </param>
    /// <returns>
    /// Returns true if dimension default account is validated; otherwise, false.
    /// </returns>
    protected boolean checkVATDefaultAccount(LedgerDimensionDefaultAccount _ledgerDimensionDefaultAccount,
                                             TaxLedgerAccountGroup _taxLedgerAccountGroup,
                                             RTax25LedgerAccountGroup _rTax25LedgerAccountGroup,
                                             boolean _countryRegion_RU)
    {
        boolean countryRegion_BR = BrazilParameters::isEnabled();

        return (LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxIncomingLedgerDimension) ||
                LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxOutgoingLedgerDimension) ||
                LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxReportLedgerDimension)   ||
                LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxUseTaxLedgerDimension)   ||
                LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxOffsetUseTaxLedgerDimension) ||
                (TaxConsInvoice_JP::isTaxDifferencePostingOnConsInvoiceEnabled(true)
                    && LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxNondeductibleTaxLedgerDimension)) ||
                (_countryRegion_RU
                    && (LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxOutgoingOffsetLedgerDimension_RU)
                        || LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxDeferredLedgerDimension_RU)
                        || LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxIncomingPaymentLedgerDimension_RU)
                        || LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _rTax25LedgerAccountGroup.AssessedTaxLedgerDimension)
                        || LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _rTax25LedgerAccountGroup.ctaLedgerDimension)
                        || LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _rTax25LedgerAccountGroup.ctlLedgerDimension)
                        || LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _rTax25LedgerAccountGroup.dtaLedgerDimension)
                        || LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _rTax25LedgerAccountGroup.dtlLedgerDimension))) ||
                (countryRegion_BR
                        && (LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxSalesOffsetLedgerDimension_BR)
                            || LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxIncomingLongTermLedgerDimension_BR)
                            || LedgerDimensionFacade::areEqual(_ledgerDimensionDefaultAccount, _taxLedgerAccountGroup.TaxIncomingShortTermLedgerDimension_BR))));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucherNotUsed</Name>
				<Source><![CDATA[
    private boolean checkVoucherNotUsed(LedgerJournalTable _ledgerJournalTable,
                                               Voucher            _voucher = this.Voucher)
    {
        LedgerJournalTrans      ledgerJournalTransLocal;
        LedgerJournalTable      ledgerJournalTableLocal;

        ledgerJournalTransLocal.selectLocked(false);

        select firstonly RecId from ledgerJournalTransLocal
            where ledgerJournalTransLocal.Voucher == _voucher &&
                    ledgerJournalTransLocal.JournalNum != this.JournalNum
            exists join ledgerJournalTableLocal
                where ledgerJournalTableLocal.JournalNum == ledgerJournalTransLocal.JournalNum &&
                    ledgerJournalTableLocal.NumberSequenceTable == _ledgerJournalTable.NumberSequenceTable;

        if (ledgerJournalTransLocal)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucherNotUsedDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the voucher is being used by a different <c>ledgerJournalTrans</c> row on a form's datasource that is not in the database.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher number in use; optional.
    /// </param>
    /// <returns>
    /// False if the voucher is in use; otherwise, true.
    /// </returns>
    public boolean checkVoucherNotUsedDataSource(Voucher _voucher = this.Voucher)
    {
        FormDataSource      formDataSource;
        LedgerJournalTrans  ledgerJournalTransLocal;
        LedgerJournalTrans  ledgerJournalTransEmpty;

        if (FormDataUtil::isFormDataSource(this))
        {
            ledgerJournalTransEmpty.clear();
            formDataSource = FormDataUtil::getFormDataSource(this);
            // The getFirst method must have false specified so only the records currently in memory are read since the upsaved record can only exist in memory
            ledgerJournalTransLocal = formDataSource.getFirst(0, false) as LedgerJournalTrans;
            while (!ledgerJournalTransLocal.equal(ledgerJournalTransEmpty))
            {
                if (!ledgerJournalTransLocal.RecId &&
                    ledgerJournalTransLocal.LineNum     != this.LineNum    &&
                    ledgerJournalTransLocal.JournalNum  == this.JournalNum &&
                    ledgerJournalTransLocal.Voucher     == _voucher)
                {
                    return false;
                }
                ledgerJournalTransLocal = formDataSource.getNext() as LedgerJournalTrans;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucherSeries</Name>
				<Source><![CDATA[
    public boolean checkVoucherSeries(LedgerJournalTable _ledgerJournalTable)
    {
        boolean                 voucherOk = true;
        NumberSequenceTable     numberSequenceTable;
        RefRecId                voucherSeries;
        NumberSequenceFormat    format;
        Integer                 voucherNumber;

        voucherSeries = _ledgerJournalTable.NumberSequenceTable;
        if (!voucherSeries)
        {
            voucherSeries = LedgerJournalName::find(_ledgerJournalTable.JournalName).NumberSequenceTable;
        }

        format = NumberSequenceTable::find(voucherSeries).Format;

        voucherNumber = NumberSeq::numRemoveFormat(this.Voucher, format);

        numberSequenceTable = NumberSequenceTable::find(voucherSeries);

        if (any2int(voucherNumber) < numberSequenceTable.Lowest ||
            any2int(voucherNumber) > numberSequenceTable.Highest)
        {
            voucherOk = checkFailed(strFmt("@SYS18410", this.Voucher));
        }

        return voucherOk;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWithholdingTax_MX</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for the operation type if it is blank.
    /// </summary>
    /// <param name="_ledgerJournalType">
    /// The value that is used to identify the journal.
    /// </param>
    /// <returns>
    /// true if the operation type is not blank; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The method is called to check whether the value of the operation type is available when the record
    /// is saved.
    /// </remarks>
    public boolean checkWithholdingTax_MX(LedgerJournalType  _ledgerJournalType)
    {
        boolean ret = true;

        switch(_ledgerJournalType)
        {
            case LedgerJournalType::PurchaseLedger,
                LedgerJournalType::Approval,
                LedgerJournalType::Periodic,
                LedgerJournalType::Daily,
                LedgerJournalType::VendInvoiceRegister:

                if ((this.AccountType == LedgerJournalACType::Vend || this.OffsetAccountType == LedgerJournalACType::Vend))
                {
                    ret = CFDIWithholdingType_MX::checkWithholdingType(this.ledgerJournalTrans_W().WithholdingTypeCode_MX, this.TaxGroup, this.TaxItemGroup);
                }
                break;

            default:
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkZeroAmount</Name>
				<Source><![CDATA[
    public boolean checkZeroAmount(AssetTransTypeJournal _assetTransType, LedgerPostingMessageLog _ledgerPostingMessageCollection = null
        ,boolean _isAssembling = false
        )
    {
        boolean ok = true;
        boolean skipCheckZeroAmount;
        // <GBR>
        boolean acceptZeroAmount;

        if (BrazilParameters::isEnabled())
        {
            if (this.AccountType != LedgerJournalACType::Bank)
            {
                if (this.AccountType == LedgerJournalACType::Vend)
                {
                    acceptZeroAmount = TaxWithhold::hasWithhold_BR(this.findVendTransOpen_BR(), this);
                }
                else if (this.AccountType == LedgerJournalACType::Cust)
                {
                    acceptZeroAmount = TaxWithhold::hasWithhold_BR(this.findCustTransOpen_BR(), this);
                }
            }
            else
            {
                acceptZeroAmount = true;
            }
        }
        // </GBR>

        EventHandlerResult eventHandlerResult = new EventHandlerResult();
        // By default don't skip the check for zero amount.
        eventHandlerResult.result(false);
        this.skipCheckZeroAmountDelegate(this, _assetTransType, eventHandlerResult);
        skipCheckZeroAmount = eventHandlerResult.result();

        if (_assetTransType   != AssetTransTypeJournal::DisposalSale  &&
            _assetTransType   != AssetTransTypeJournal::DisposalScrap &&
            !_isAssembling                                            &&
            this.TransactionType  != LedgerTransType::Allocation          &&
            this.AmountCurCredit  == 0                                    &&
            this.AmountCurDebit   == 0                                    &&
            this.Qty              == 0
            // <GBR>
            && ((BrazilParameters::isEnabled() && !acceptZeroAmount) || !BrazilParameters::isEnabled())
            // </GBR>
            && !skipCheckZeroAmount
            )
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS25624");
            }
            else
            {
                ok = checkFailed("@SYS25624");
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxBooksSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes the checks for the tax books setup and sales/item sales tax groups.
    /// </summary>
    /// <returns>true if tax books setup and tax groups setup are OK for a ledger journal transaction; false otherwise.</returns>
    [Replaceable]
    public boolean checkTaxBooksSetup()
    {
        boolean isValid = true;
        boolean postponeCheckAfterTaxCalculation = false;
        LedgerJournalTable ledgerJournalTable = this.ledgerJournalTable();

        // Italian functionality of VAT books and VAT book sections
        if (ledgerJournalTable.shouldCheckTaxBooksSetup_IT())
        {
            isValid = TaxBookSection::checkTaxBookSection(
                NumberSequenceTable::find(ledgerJournalTable.ledgerJournalName().NumberSequenceTable).RecId,
                this.TransDate);

            if (this.isTaxIntegrationEnabled()
                && TaxPostponeCheckTaxGroupAfterTaxCalculation_ITFlight::instance().isEnabled()
                && TaxIntegrationCheckTaxCode_ITFlight::instance().isEnabled())
            {
                postponeCheckAfterTaxCalculation = this.ledgerJournalTransTaxExtension().OverrideSalesTax != NoYes::Yes;
            }

            if (isValid && !postponeCheckAfterTaxCalculation)
            {
                isValid = TaxGroupData::checkTaxGroups(this.TaxGroup, this.TaxItemGroup);
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearBankCurrencyAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the bank currency amount.
    /// </summary>
    public void clearBankCurrencyAmount()
    {
        this.BankCurrencyAmount = 0;
        this.BankCurrency       = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>CompanyInfo</c> record associated with the current record.
    /// </summary>
    /// <returns>
    /// The <c>CompanyInfo</c> record.
    /// </returns>
    public CompanyInfo companyInfo()
    {
        return CompanyInfo::findDataArea(this.company());
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertCustPaymAmountCurToDebitCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified customer payment amount into the appropriate debit or credit.
    /// </summary>
    /// <param name="_custPaymAmountCur">
    /// The customer payment amount to be converted.
    /// </param>
    /// <remarks>
    /// The <c>displayCustPaymAmount</c> method is the complement of this method.
    /// </remarks>
    public void convertCustPaymAmountCurToDebitCredit(AmountCur _custPaymAmountCur)
    {
        if (_custPaymAmountCur > 0)
        {
            this.AmountCurCredit = _custPaymAmountCur;
            this.AmountCurDebit = 0;
        }
        else
        {
            this.AmountCurDebit = -_custPaymAmountCur;
            this.AmountCurCredit = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies a dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </summary>
    /// <param name="_defaultDimension">
    /// A dimension set that can be applied to the <c>defaultDimension</c> field on this table.
    /// </param>
    /// <param name="_dimensionCopy">
    /// A <c>dimensionCopy</c> object that was created by using the current buffer; optional.
    /// </param>
    /// <returns>
    /// A dimension set that can be applied to the <c>defaultDimension</c> field on the current record.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are not overwritten.
    /// </remarks>
    public DimensionDefault copyDimension(
        DimensionDefault _defaultDimension,
        DimensionCopy    _dimensionCopy = DimensionCopy::newFromTable(this, this.companyInfo().RecId)
        )
    {
        return _dimensionCopy.copy(_defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyTo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the nonsystem fields from this buffer to the destination buffer.
    /// </summary>
    /// <param name="_destination">
    /// The buffer to which to copy the nonsystem fields.
    /// </param>
    /// <remarks>
    /// The <c>Common.data</c> method forces the system fields to be copied across. Some scenarios, such as
    /// in-memory rollbacks of buffers, should not have those fields copied across.
    /// </remarks>
    public void copyTo(LedgerJournalTrans _destination)
    {
        SysDictField field;
        FieldId fieldId;
        SysDictTable sysDictTable = new SysDictTable(tableNum(LedgerJournalTrans));
        Set fieldsSet;
        Set systemFieldIds = new Set(Types::Integer);
        SetEnumerator fieldSetEnumerator;

        // Generate the list of system fields contained by this table.
        systemFieldIds.add(fieldNum(LedgerJournalTrans, RecId));
        systemFieldIds.add(fieldNum(LedgerJournalTrans, RecVersion));
        systemFieldIds.add(fieldNum(LedgerJournalTrans, DataAreaId));

        // Copy the non-system fields from this buffer to the destination buffer.
        fieldsSet = sysDictTable.fields();
        fieldSetEnumerator = fieldsSet.getEnumerator();
        while (fieldSetEnumerator.moveNext())
        {
            field = fieldSetEnumerator.current();
            fieldId = field.id();
            if (!systemFieldIds.in(fieldId))
            {
                // This is not a system field, so copy the value across.
                _destination.(fieldId) = this.(fieldId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>correct</Name>
				<Source><![CDATA[
    public boolean correct()
    {
        boolean isCorrection = ((this.AmountCurCredit < 0) || (this.AmountCurDebit < 0));

        // Verifies if correction is needed for project related storno scenario.
        if (isCorrection
            && (this.AccountType == LedgerJournalACType::Project || this.OffsetAccountType == LedgerJournalACType::Project)
            && isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            LedgerJournalTrans_Project ledgerJournalTrans_Project = LedgerJournalTrans_Project::find(this.RecId);
            if (ledgerJournalTrans_Project)
            {
                isCorrection = ledgerJournalTrans_Project.Correction;
            }
        }
        return isCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewPayment</Name>
				<Source><![CDATA[
    public void createNewPayment(
        SpecTrans     _specTrans,
        CustVendTrans _custVendTrans)
    {
        LedgerJournalTrans      newLedgerJournalTrans = this.data();
        LedgerJournalTrans      existLedgerJournalTrans;
        VendTransOpen           vendTransOpenCur;
        CustTransOpen           custTransOpenCur;
        LedgerJournalType       journalType;
        AmountCur               fineInterestAmountCur;
        AmountCur               fineAmountCur;
        LedgerJournalTransPayment_BR existTransPayment_BR;
        LedgerJournalTransPayment_BR newTransPayment_BR;
        LedgerJournalTransPayment_BR thisPayment_BR;
        TaxWithholdTrans        withholdTransData;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]))
        {
            newLedgerJournalTrans.SysExtensionSerializerMap::copyExtensionTableData(this);
        }

        ttsbegin;

        if (SpecTrans::getSpecTransCount(this.company(), this.TableId, this.RecId) > 1)
        {
            if (CustVendPaymModeTable::findCommon(_custVendTrans).PaymSumBy != PaymSumBy::Invoice)
            {
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))

                {
                    _custVendTrans.DefaultDimension = newLedgerJournalTrans.DefaultDimension;
                    select forupdate firstonly existLedgerJournalTrans
                    where existLedgerJournalTrans.JournalNum            == newLedgerJournalTrans.JournalNum
                       && existLedgerJournalTrans.AccountType           == newLedgerJournalTrans.AccountType
                       && existLedgerJournalTrans.LedgerDimension       == newLedgerJournalTrans.LedgerDimension
                       && existLedgerJournalTrans.PaymMode              == _custVendTrans.PaymMode
                       && existLedgerJournalTrans.PaymSpec              == newLedgerJournalTrans.PaymSpec
                       && existLedgerJournalTrans.CurrencyCode          == newLedgerJournalTrans.CurrencyCode
                       && existLedgerJournalTrans.PostingProfile        == newLedgerJournalTrans.PostingProfile
                       && existLedgerJournalTrans.DefaultDimension      == newLedgerJournalTrans.DefaultDimension
                       && existLedgerJournalTrans.CustVendBankAccountId == newLedgerJournalTrans.CustVendBankAccountId
                       && existLedgerJournalTrans.OffsetAccountType     == newLedgerJournalTrans.OffsetAccountType
                       && existLedgerJournalTrans.OffsetLedgerDimension == newLedgerJournalTrans.OffsetLedgerDimension
                       && existLedgerJournalTrans.PaymentStatus         == newLedgerJournalTrans.PaymentStatus
                       && existLedgerJournalTrans.PaymId                == newLedgerJournalTrans.PaymId;
                }
                else
                {
                    select forupdate firstonly existLedgerJournalTrans
                    where existLedgerJournalTrans.JournalNum        == newLedgerJournalTrans.JournalNum
                       && existLedgerJournalTrans.AccountType       == newLedgerJournalTrans.AccountType
                       && existLedgerJournalTrans.LedgerDimension   == newLedgerJournalTrans.LedgerDimension
                       && existLedgerJournalTrans.PaymMode          == _custVendTrans.PaymMode
                       && existLedgerJournalTrans.PaymSpec          == newLedgerJournalTrans.PaymSpec
                       && existLedgerJournalTrans.CurrencyCode      == newLedgerJournalTrans.CurrencyCode
                       && existLedgerJournalTrans.PaymId            == newLedgerJournalTrans.PaymId;
                }
            }

            if (existLedgerJournalTrans.RecId)
            {
                existLedgerJournalTrans.amountCur2DebCred(existLedgerJournalTrans.amount() - _specTrans.Balance01);
                this.amountCur2DebCred(this.amount() + _specTrans.Balance01);

                if (BrazilParameters::isEnabled())
                {
                    journalType = LedgerJournalTable::find(this.JournalNum).JournalType;

                    if (journalType == LedgerJournalType::Payment)
                    {
                        vendTransOpenCur = VendTransOpen::find(_specTrans.RefRecId);

                        fineInterestAmountCur  = vendTransOpenCur.InterestAmountPaymCur_BR;
                        fineAmountCur          = vendTransOpenCur.FineAmountPaymCur_BR;

                        existLedgerJournalTrans.amountCur2DebCred(existLedgerJournalTrans.amount()
                                                                  - (fineInterestAmountCur + fineAmountCur));

                        existTransPayment_BR = existLedgerJournalTrans.getPaymentExtension_BR();
                        existTransPayment_BR.FinInterestAmountCur_BR -= fineInterestAmountCur;
                        existTransPayment_BR.FineAmountCur_BR        -= fineAmountCur;
                        existLedgerJournalTrans.packExtensionTable(existTransPayment_BR);

                        this.amountCur2DebCred(this.amount() + (fineInterestAmountCur + fineAmountCur));

                        thisPayment_BR = this.getPaymentExtension_BR();
                        thisPayment_BR.FinInterestAmountCur_BR += fineInterestAmountCur;
                        thisPayment_BR.FineAmountCur_BR        += fineAmountCur;
                        this.packExtensionTable(thisPayment_BR);
                    }
                    else if (journalType == LedgerJournalType::CustPayment)
                    {
                        custTransOpenCur = CustTransOpen::find(_specTrans.RefRecId);

                        fineInterestAmountCur  = custTransOpenCur.InterestAmountPaymCur_BR;
                        fineAmountCur          = custTransOpenCur.FineAmountPaymCur_BR;

                        existLedgerJournalTrans.amountCur2DebCred(existLedgerJournalTrans.amount()
                                                                  - (fineInterestAmountCur + fineAmountCur));

                        existTransPayment_BR = existLedgerJournalTrans.getPaymentExtension_BR();
                        existTransPayment_BR.FinInterestAmountCur_BR += fineInterestAmountCur;
                        existTransPayment_BR.FineAmountCur_BR        += fineAmountCur;
                        existLedgerJournalTrans.packExtensionTable(existTransPayment_BR);

                        this.amountCur2DebCred(this.amount() + fineInterestAmountCur + fineAmountCur);

                        thisPayment_BR = this.getPaymentExtension_BR();
                        thisPayment_BR.FinInterestAmountCur_BR -= fineInterestAmountCur;
                        thisPayment_BR.FineAmountCur_BR        -= fineAmountCur;
                        this.packExtensionTable(thisPayment_BR);
                    }
                }

                _specTrans.SpecRecId = existLedgerJournalTrans.RecId;
                changecompany(_specTrans.RefCompany)
                {
                    _specTrans.update();
                }
                existLedgerJournalTrans.fillPaymentNotes();
                existLedgerJournalTrans.update();
            }
            else
            {
                newLedgerJournalTrans.PaymentNotes = '';
                newLedgerJournalTrans.amountCur2DebCred(-_specTrans.Balance01);
                this.amountCur2DebCred(this.amount() + _specTrans.Balance01);

                if (BrazilParameters::isEnabled())
                {
                    if (LedgerJournalTable::find(this.JournalNum).JournalType == LedgerJournalType::Payment)
                    {
                        vendTransOpenCur = VendTransOpen::find(_specTrans.RefRecId);

                        select sum(PaymTaxWithholdAmount) from withholdTransData where withholdTransData.SpecTransId == _specTrans.RecId;

                        newLedgerJournalTrans.amountCur2DebCred(newLedgerJournalTrans.amount() - (vendTransOpenCur.InterestAmount_BR+ vendTransOpenCur.FineAmount_BR + withholdTransData.PaymTaxWithholdAmount));

                        newTransPayment_BR = newLedgerJournalTrans.getPaymentExtension_BR();
                        newTransPayment_BR.FinInterestAmountCur_BR = abs(vendTransOpenCur.InterestAmountPaymCur_BR);
                        newTransPayment_BR.FineAmountCur_BR = abs(vendTransOpenCur.FineAmountPaymCur_BR);
                        newLedgerJournalTrans.packExtensionTable(newTransPayment_BR);

                        this.amountCur2DebCred(this.amount() + (vendTransOpenCur.InterestAmount_BR+ vendTransOpenCur.FineAmount_BR+ withholdTransData.PaymTaxWithholdAmount));

                        thisPayment_BR = this.getPaymentExtension_BR();
                        thisPayment_BR.FinInterestAmountCur_BR += vendTransOpenCur.InterestAmountPaymCur_BR;
                        thisPayment_BR.FineAmountCur_BR += vendTransOpenCur.FineAmountPaymCur_BR;
                        this.packExtensionTable(thisPayment_BR);
                    }
                    else if (LedgerJournalTable::find(this.JournalNum).JournalType == LedgerJournalType::CustPayment)
                    {
                        custTransOpenCur = CustTransOpen::find(_specTrans.RefRecId);

                        newLedgerJournalTrans.amountCur2DebCred(newLedgerJournalTrans.amount() - (custTransOpenCur.InterestAmount_BR + custTransOpenCur.FineAmount_BR));
                        newTransPayment_BR = newLedgerJournalTrans.getPaymentExtension_BR();
                        newTransPayment_BR.FinInterestAmountCur_BR = custTransOpenCur.InterestAmountPaymCur_BR;
                        newTransPayment_BR.FineAmountCur_BR = custTransOpenCur.FineAmountPaymCur_BR;
                        newLedgerJournalTrans.packExtensionTable(newTransPayment_BR);

                        this.amountCur2DebCred(this.amount() + (custTransOpenCur.InterestAmountPaymCur_BR + custTransOpenCur.FineAmountPaymCur_BR));
                        thisPayment_BR = this.getPaymentExtension_BR();
                        thisPayment_BR.FinInterestAmountCur_BR -= custTransOpenCur.FineAmountPaymCur_BR;
                        thisPayment_BR.FineAmountCur_BR -= custTransOpenCur.FineAmountPaymCur_BR;
                        this.packExtensionTable(thisPayment_BR);
                    }
                }

                newLedgerJournalTrans.PaymMode = _custVendTrans.PaymMode;
                newLedgerJournalTrans.paymModeModified();
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
                {
                    newLedgerJournalTrans.PaymSpec = _custVendTrans.PaymSpec;
                }

                newLedgerJournalTrans.insert();
                _specTrans.SpecRecId = newLedgerJournalTrans.RecId;
                changecompany(_specTrans.RefCompany)
                {
                    _specTrans.update();
                }
                newLedgerJournalTrans.fillPaymentNotes();
            }
        }
        else
        {
            if (this.PaymMode != _custVendTrans.PaymMode)
            {
                this.PaymMode = _custVendTrans.PaymMode;
                this.paymModeModified();
                this.update();
            }
        }
        this.fillPaymentNotes();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferTrans</Name>
				<Source><![CDATA[
    public void createTransferTrans(
        LedgerJournalTrans  _ledgerJournalOld,
        LedgerJournalId     _ledgerJournalId)
    {
        LedgerJournalTrans                  ledgerJournalNew = _ledgerJournalOld.data();
        LedgerJournalTransTaxExtensionIN    ledgerJournalTransTaxExtensionIN;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]))
        {
            ledgerJournalNew.SysExtensionSerializerMap::copyExtensionTableData(_ledgerJournalOld);
        }

        ledgerJournalNew.JournalNum         = _ledgerJournalId;

        if (_ledgerJournalOld.Cancel && LedgerParameters::find().TransactionReversalCorrection)
        {
            ledgerJournalNew.AmountCurCredit    = -_ledgerJournalOld.AmountCurCredit;
            ledgerJournalNew.AmountCurDebit     = -_ledgerJournalOld.AmountCurDebit;
        }
        else
        {
            ledgerJournalNew.AmountCurCredit    = _ledgerJournalOld.AmountCurDebit;
            ledgerJournalNew.AmountCurDebit     = _ledgerJournalOld.AmountCurCredit;
        }

        ledgerJournalNew.LineNum = LedgerJournalTrans::lastLineNum(_ledgerJournalId) + 1;

        ledgerJournalNew.insert();

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            ledgerJournalTransTaxExtensionIN.TaxModelDocLineExtensionIN::initFromBaseTable(ledgerJournalNew);
            ledgerJournalTransTaxExtensionIN.insert();
        }
        // </GIN>
        // <GTE>
        if (TaxIntegrationUtils::isTaxInformationEnabled())
        {
            TransTaxInformationHelper::copyTransTaxInformation(_ledgerJournalOld, ledgerJournalNew);
        }
        // </GTE>

        if (ledgerJournalNew.ledgerJournalTable().JournalType == LedgerJournalType::VendInvoicePool
            && TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(LedgerJournalType::VendInvoicePool))
        {
            LedgerJournalTransTaxExtension::copyLedgerJournalTransTaxExtension(_ledgerJournalOld, ledgerJournalNew, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>crossrate</Name>
				<Source><![CDATA[
    public display ExchrateSecondary crossrate()
    {
        ExchrateSecondary crossrate;
        ExchangeRateHelper  exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId), this.CurrencyCode);

        if (! this.ExchRateSecond)
        {
            crossrate = this.ExchRate;
        }
        else
        {
            crossrate = this.ExchRate ? (this.ExchRateSecond / this.ExchRate)*100 : 0;
        }
        return exchangeRateHelper.displayStoredExchangeRate(crossrate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingCurrencyCrossrate</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method calculate the cross rate for reporting currency.
    /// </summary>
    public display ReportingCurrencyExchRateSecondary reportingCurrencyCrossrate()
    {
        ReportingCurrencyExchRateSecondary reportingCurrencyCrossrate;

        ExchangeRateHelper  exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId), this.CurrencyCode);
        exchangeRateHelper.parmToCurrency(Ledger::reportingCurrency());
        exchangeRateHelper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());

        if (! this.ReportingCurrencyExchRateSecondary)
        {
            reportingCurrencyCrossrate = this.ReportingCurrencyExchRate;
        }
        else
        {
            reportingCurrencyCrossrate = this.ReportingCurrencyExchRate ? (this.ReportingCurrencyExchRateSecondary / this.ReportingCurrencyExchRate)*100 : 0;
        }
        return exchangeRateHelper.displayStoredExchangeRate(reportingCurrencyCrossrate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>custPaymentFilledOkDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to ensure a <c>LedgerJournalTrans</c> field has been entered and is valid for the corresponding <c>CustPaymentValidate</c> value.
    /// </summary>
    /// <param name = "_custPaymentValidate">Identifies the type of payment validation.</param>
    /// <param name = "_ledgerJournalTrans">The journal line that needs validation.</param>
    /// <param name = "_tmpVoucherMap">A map that contains vouchers.</param>
    /// <param name = "_eventHandlerResult">An <c>EventHandlerResult</c> where the boolean validation result can be returned.</param>
    delegate void custPaymentFilledOkDelegate(CustPaymentValidate _custPaymentValidate, LedgerJournalTrans _ledgerJournalTrans, Map _tmpVoucherMap, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>custPaymentFilledOk</Name>
				<Source><![CDATA[
    private boolean custPaymentFilledOk(Map _tmpVoucherMap = null)
    {
        boolean ok = true;

        if (this.PaymMode)
        {
            LedgerJournalType ledgerJournalType = this.ledgerJournalTable().JournalType;

            if (ledgerJournalType == LedgerJournalType::CustPayment
                || (ledgerJournalType == LedgerJournalType::Daily
                    && !this.Invoice))
            {
                CustPaymMethodVal custPaymMethodValFieldList;
                while select CustPaymValidate from custPaymMethodValFieldList
                    where custPaymMethodValFieldList.CustPaymMode == this.PaymMode
                {
                    switch (custPaymMethodValFieldList.CustPaymValidate)
                    {
                        case CustPaymentValidate::PaymReference:
                            if (!this.PaymReference)
                            {
                                ok = checkFailed(strFmt("@SYS54960", LedgerJournalTrans::findTmpVoucher(this.Voucher, _tmpVoucherMap), date2StrUsr(this.TransDate, DateFlags::FormatAll)));
                            }
                            break;

                        case CustPaymentValidate::BankPostType:
                            if (!this.BankTransType)
                            {
                                ok = checkFailed(strFmt("@SYS54961", LedgerJournalTrans::findTmpVoucher(this.Voucher, _tmpVoucherMap), date2StrUsr(this.TransDate, DateFlags::FormatAll)));
                            }
                            break;

                        case CustPaymentValidate::OffsetAccountIsBank:
                            if (this.OffsetAccountType != LedgerJournalACType::Bank)
                            {
                                ok = checkFailed(strFmt("@SYS54962", LedgerJournalTrans::findTmpVoucher(this.Voucher, _tmpVoucherMap), date2StrUsr(this.TransDate, DateFlags::FormatAll)));
                            }
                            break;

                        case CustPaymentValidate::DepositSlip:
                            if (!this.BankDepositVoucher)
                            {
                                ok = checkFailed(strFmt("@SYS54963", LedgerJournalTrans::findTmpVoucher(this.Voucher, _tmpVoucherMap), date2StrUsr(this.TransDate, DateFlags::FormatAll)));
                            }
                            break;

                        case CustPaymentValidate::CheckNo:
                            if (!this.BankChequeNum)
                            {
                                ok = checkFailed(strFmt("@SYS54964", LedgerJournalTrans::findTmpVoucher(this.Voucher, _tmpVoucherMap), date2StrUsr(this.TransDate, DateFlags::FormatAll)));
                            }
                            break;

                        default:
                            EventHandlerResult result = new EventHandlerResult();
                            this.custPaymentFilledOkDelegate(custPaymMethodValFieldList.CustPaymValidate, this, _tmpVoucherMap, result);
                            if (result.hasResult())
                            {
                                ok = result.result();
                            }
                            break;
                    }
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>debitCreditDifferenceCur</Name>
				<Source><![CDATA[
    public display AmountCur debitCreditDifferenceCur()
    {
        return this.AmountCurDebit - this.AmountCurCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of a field to the default value.
    /// </summary>
    /// <param name="_fieldId">
    /// The ID of the field you want to set to its default value.
    /// </param>
    public void defaultField(FieldId _fieldId)
    {
        LedgerJournalTransType ledgerJournalTransType;
        List ledgerJournalTransTypeList;
        ListEnumerator enumerator;

        // The LedgerJournalTrans.AccountType represents one logical line and
        // LedgerJournalTrans.OffsetAccountType represents another logical line.
        // Therefore, a set is used to encapsulate the polymorphic business logic.
        ledgerJournalTransTypeList = this.type();
        if (ledgerJournalTransTypeList)
        {
            enumerator = ledgerJournalTransTypeList.getEnumerator();
            while (enumerator.moveNext())
            {
                ledgerJournalTransType = enumerator.current();
                ledgerJournalTransType.defaultField(_fieldId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultRow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the values of the fields in a particular <c>LedgerJournalTrans</c> table row to their default
    /// values.
    /// </summary>
    public void defaultRow()
    {
        LedgerJournalTransType ledgerJournalTransType;
        List ledgerJournalTransTypeList;
        ListEnumerator enumerator;

        // The LedgerJournalTrans.AccountType represents one logical line and
        // LedgerJournalTrans.OffsetAccountType represents another logical line.
        // Therefore, a set is used to encapsulate the polymorphic business logic.
        ledgerJournalTransTypeList = this.type();

        if (ledgerJournalTransTypeList)
        {
            enumerator = ledgerJournalTransTypeList.getEnumerator();
            while (enumerator.moveNext())
            {
                ledgerJournalTransType = enumerator.current();
                ledgerJournalTransType.defaultRow();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExchRate_HU</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Update exchange rates based on <c>HuExchOutflowType</c>.
    /// </summary>
    /// <param name = "_exchOutflowType"><c>HuExchOutflowType</c> based on which the values are recalculated.</param>
    /// <param name = "_isCalc">Determines whether to update or calculate exchange rates for FIFO outflow type.</param>
    protected void updateExchRate_HU(HuExchOutflowType _exchOutflowType, boolean _isCalc = false)
    {
        switch (_exchOutflowType)
        {
            case HuExchOutflowType::FIFO :
                if (_isCalc)
                {
                    this.calcFIFOLineExchRate_HU();
                }
                else
                {
                    this.updateFIFOLineExchRate_HU();
                }
                break;

            case HuExchOutflowType::AverageRate :
                this.calcAverageLinesExchRate_HU();
                break;

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete(boolean _deleteVoucher = true)
    {
        Voucher                         voucher = this.orig().Voucher;
        InvoiceId                       origInvoice = this.orig().Invoice;
        LedgerJournalTable              ledgerJournalTable = this.ledgerJournalTable();

        LedgerJournalTrans_RAsset       ljTransDeleted_RAsset, ljTransLinked_RAsset;
        #ISOCountryRegionCodes
        HuExchOutflowType               exchOutflowType = RCashParameters::find().ExchOutflowType_HU;

        boolean isIsoRU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        ttsbegin;

        if (this.rCashPayTransType != RCashPayLedgerTransType::None)
        {
            this.paySheetTransDeleteLink_RU();
        }

        // Delete related existing bank document.
        if (this.isBankDocumentPayment())
        {
            BankDocumentProcessor::deleteBankDocument(this.TableId, this.RecId);
        }

        if (this.AccountType == LedgerJournalACType::RCash &&
            exchOutflowType == HuExchOutflowType::FIFO &&
            this.amount()   < 0.0)
        {
            this.rollbackFIFOLineExchRate_HU();
        }

        if (BrazilParameters::isEnabled())
        {
            switch (this.AccountType)
            {
                case LedgerJournalACType::Vend:
                case LedgerJournalACType::Cust:
                    TaxWithhold::uncheckWithholdTrans_BR(this);
                    break;
                default :
            }
        }
        if (this.AccountType == LedgerJournalACType::FixedAssets_RU)
        {
            ljTransDeleted_RAsset = LedgerJournalTrans_RAsset::find(this.RecId);
            if (! ljTransDeleted_RAsset.BudgetModel &&
                ljTransDeleted_RAsset.TransType != RAssetTransType::PartialTakeDown &&
                (ljTransDeleted_RAsset.CanDisposal || ! ljTransDeleted_RAsset.ToFromRecId))
            {
                ljTransLinked_RAsset = ljTransDeleted_RAsset.madeDisposable(this.orig());
            }
            ljTransDeleted_RAsset.deleteTaxGroupDepreciations();
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            // delete record of <c>TaxEngineLedgerJournalTransHeader</c> related to this record.
            TaxEngineLedgerJournalTransHeader::deleteByLedgerJournalTrans(this);
        }
        // </GTE>

        if (TaxIntegrationUtils::isTransitDocumentEnabled())
        {
            this.TransitDocumentTransactionMap_IN::deleteTransitDocuments();
        }

        super();
        if (ljTransLinked_RAsset)
        {
            ljTransLinked_RAsset.updateGainLoss();
        }

        if (this.AccountType == LedgerJournalACType::RCash && this.amount())
        {
            this.updateExchRate_HU(exchOutflowType);
        }

        if (ledgerJournalTable && ledgerJournalTable.JournalType != ledgerJournalType::Assets)
        {
            // Tax lines are out of date so delete them.
            TaxUncommitted::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher, origInvoice);

            if (!ledgerJournalTable.Posted
                && !(this.DelayTaxCalculation
                    || ledgerJournalTable.isTaxIntegrationEnabled()))
            {
                LedgerJournalTrans::getTaxInstance(this.JournalNum, this.Voucher, this.Invoice, true
                   , null, false, this.TransDate);//Service tax
            }
        }

        if (ledgerJournalTable && TaxWithholdParameters_IN::checkTaxParameters()
            && (!TaxWithholdNotCalcTaxForInvoicePool_INFlight::instance().isEnabled() || ledgerJournalTable.JournalType != LedgerJournalType::VendInvoicePool))
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = this.ledgerJournalTransTaxExtensionIN();

            // delete the cache for the document header if the threshold is not exceeded.
            // because this will impact the tax calculation for other journal lines.
            if ((!TaxWithholdCalculation_IN::checkRecoverableAccount(this)
                && TaxWithholdTrans_IN::isThresholdExceededForAccount(this.parmAccount(),
                                                                      ledgerJournalTransTaxExt.tdsGroup? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup,
                                                                      this.TransDate))
                || TaxWithholdUncommitted_IN::existBySourceId(this.TableId, this.RecId))
            {
                if (TaxWithholdUncommitted_IN::existByDocumentId(ledgerJournalTable.TableId, ledgerJournalTable.RecId))
                {
                    TaxWithholdUncommitted_IN::deleteForDocumentHeader(ledgerJournalTable.TableId, ledgerJournalTable.RecId);
                }
                if (!ledgerJournalTable.Posted)
                {
                    TaxVoucherService::calculateWithholdTaxForJournal_IN(this.JournalNum);
                }
            }
            else
            {
                TaxWithholdUncommitted_IN::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher, this.orig().getWHTUsingInvoiceId_IN());
                if (!ledgerJournalTable.Posted
                    && ((ledgerJournalTransTaxExt.TDSGroup || ledgerJournalTransTaxExt.TCSGroup)))
                {
                    if (TaxWithholdCustPaymDeleteInBatchPreventReDelTax_INFlight::instance().isEnabled())
                    {
                        LedgerJournalTrans_IN_Extension::getTaxWithholdInstance_IN(this.JournalNum, this.Voucher, this.Invoice, true);
                    }
                    else
                    {
                        LedgerJournalTrans_IN_Extension::getTaxWithholdInstance_IN(this.JournalNum, this.Voucher, this.getWHTUsingInvoiceId_IN(), true);
                    }
                }
            }
        }

        // Delete the SpecTrans records associated with the LedgerJournalTrans.  This
        // is needed because the cascading delete action will not remove the SpecTrans
        // records that might exist in a different company from the LedgerJournalTrans.
        SpecTransManager specTransManager = SpecTransManager::newFromSpec(this, false);
        specTransManager.deleteAll();

        if (ledgerJournalTable &&
            _deleteVoucher &&
            ledgerJournalTable.JournalType != LedgerJournalType::Periodic    &&
            ledgerJournalTable.JournalType != LedgerJournalType::VendInvoicePool)
        {
            this.deleteVoucher(voucher);
        }

        this.deleteForJournalType(_deleteVoucher, ledgerJournalTable.JournalType);

        // Remove the referenced reason code and comment if the journal has not been posted.
        if (ledgerJournalTable && ledgerJournalTable.Posted == NoYes::No && this.ReasonRefRecID != 0)
        {
            ReasonTableRef::deleteByReference(this.ReasonRefRecID);
        }

        // Remove any accrual records
        this.removeAccruals(true);

        // delete the related intrastat line from VendInvoiceIntrastat table.
        if (ledgerJournalTable && _deleteVoucher && ledgerJournalTable.Posted == NoYes::No && this.Transferred == NoYes::No)
        {
            VendInvoiceIntrastatType::deleteLine(this.Voucher, this.TransDate);
        }

        TradeBLWIJournalPurposeCodes::deleteRecord(this.RecId, TradeBLWITypeOfForm::LedgerJournalTrans);
        TradeBLWIJournalPurposeCodes::deleteRecord(this.RecId, TradeBLWITypeOfForm::InvoiceRegister);

        BankClientPayment_RU::updateOnTransDelete(this);

        if (isConfigurationkeyEnabled(configurationKeyNum(LedgerBasicSalesTax)) &&
            SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) &&
            !LedgerJournalTrans::existTransMinusThis(this.JournalNum, this.Voucher, this.RecId))
        {
            ExportSalesInvoiceDomesticTaxVoucher::deleteUnpostedDomesticSalesTaxVoucher(this.JournalNum, this.Voucher);
        }

        ttscommit;

        // Remove the journalNum cache that was set on \Classes\LedgerJournalTaxDocument\doTaxGroupExistsForDocument,
        // but only if taxes previously existed on this buffer since having no taxes on this line would
        // not impact the caching of whether or not taxes existed for the journal
        if (ledgerJournalTable && this.isTaxCalculationNeeded(ledgerJournalTable.isTaxIntegrationEnabled()))
        {
            LedgerJournalTaxDocument::clearCachedTaxExistenceCheck(this.JournalNum);
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            this.markCurrentTaxDocumentTaxStatusDirty();
            TaxEngineLedgerJournalTransHeader::clearCacheForTaxableDocumentType(this.JournalNum, this.Voucher);
        }
        // </GTE>

        if (TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(this.TableId, this.RecId))
        {
            TaxSpecificExchangeRate::deleteBySourceRecord(this.TableId, this.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForJournalType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the deletion logic for various journal types.
    /// </summary>
    /// <param name = "_deleteVoucher">
    /// A boolean that indicates if the voucher should be deleted.
    /// </param>
    /// <param name = "_ledgerJournalType">
    /// A <c>LedgerJournalType</c> enumeration value.
    /// </param>
    protected void deleteForJournalType(boolean _deleteVoucher, LedgerJournalType _ledgerJournalType)
    {
        boolean isIsoRU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        switch (_ledgerJournalType)
        {
            case LedgerJournalType::CustBillOfExchangeDraw:
                if (CustBillOfExchangeJour::find(this.NegInstId).Status == CustVendNegInstStatus::None)
                {
                    CustBillOfExchangeJour custBillOfExchangeJour;
                    delete_from custBillOfExchangeJour
                        where custBillOfExchangeJour.BillOfExchangeId == this.NegInstId;
                }
                break;

            case LedgerJournalType::VendPromissoryNoteDraw:
                if (VendPromissoryNoteJour::find(this.NegInstId).Status == CustVendNegInstStatus::None)
                {
                    VendPromissoryNoteJour vendPromissoryNoteJour;
                    delete_from vendPromissoryNoteJour
                        where vendPromissoryNoteJour.PromissoryNoteId == this.NegInstId;
                }
                break;
            case LedgerJournalType::VendPromissoryNoteRedraw:
                if (this.BankPromissoryNoteNum)
                {
                    BankPromissoryNoteTable  bankPromissoryNoteTable = BankPromissoryNoteTable::findBankPNDocStatus(this.BankAccountId,this.BankPromissoryNoteNum,BankPromissoryNoteStatus::Printed,true);
                    bankPromissoryNoteTable.DocumentStatus = BankPromissoryNoteStatus::Posted;
                    bankPromissoryNoteTable.update();
                }
                break;

            case LedgerJournalType::BankChequeReversal:
                if (this.ledgerJournalTable().Posted == NoYes::No)
                {
                    this.revertBankAccountTrans(_ledgerJournalType);
                    this.revertBankChequeTable();
                }
                break;

            case LedgerJournalType::BankDepositPaymCancel:
                if (this.ledgerJournalTable().Posted == NoYes::No)
                {
                    this.revertBankAccountTrans(_ledgerJournalType);
                    this.revertBankDeposit();
                }
                break;

            case LedgerJournalType::Payment:
                if (isIsoRU && this.AccountType == LedgerJournalACType::Vend && this.Prepayment)
                {
                    FactureTrans_RU factureTrans = FactureTrans_RU::findLedgerJournalTrans('', 0.0, this.RecId, false);
                    FactureJour_RU factureJour = FactureJour_RU::find(factureTrans.FactureId, factureTrans.Module, true);
                    if (factureJour)
                    {
                        FactureDelete_RU factureDelete = FactureDelete_RU::construct(factureJour);
                        factureDelete.runOperation();
                    }
                }
                break;

            case ledgerJournalType::CustomsDeclaration_IT:
                if (!this.ledgerJournalTable().Posted)
                {
                    LedgerJournalTrans_Customs_IT::deleteRecord(this.RecId);
                }
                break;

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the compositional records related to the <c>LedgerJournalTable</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> table buffer.
    /// </param>
    [SysObsolete('LedgerJournalTrans.deleteForHeader() is obsolete.  Use the class LedgerJournalDeleteTransaction class instead', false, 30\06\2020)]
    public void deleteForHeader(LedgerJournalTable _ledgerJournalTable)
    {
        this.deleteBankDocument();

        this.updateForRCash();

        this.uncheckWithholdTransBR();

        this.updateRAssetForDelete();

        this.updateRelatedForDelete(_ledgerJournalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBankDocument</Name>
				<Source><![CDATA[
    internal void deleteBankDocument()
    {
        // Delete related existing bank document.
        if (this.isBankDocumentPayment())
        {
            BankDocumentProcessor::deleteBankDocument(tableNum(LedgerJournalTrans), this.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>uncheckWithholdTransBR</Name>
				<Source><![CDATA[
    internal void uncheckWithholdTransBR()
    {
        if (BrazilParameters::isEnabled()
            && (this.AccountType == LedgerJournalACType::Vend
            || this.AccountType == LedgerJournalACType::Cust))
        {
            TaxWithhold::uncheckWithholdTrans_BR(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateForRCash</Name>
				<Source><![CDATA[
    internal void updateForRCash()
    {
        if (this.AccountType == LedgerJournalACType::RCash)
        {
            HuExchOutflowType exchOutflowType = RCashParameters::find().ExchOutflowType_HU;

            if (exchOutflowType == HuExchOutflowType::FIFO && this.amount() < 0.0)
            {
                this.rollbackFIFOLineExchRate_HU();
            }

            if (this.amount())
            {
                this.updateExchRateInternalHU(exchOutflowType);
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRAssetForDelete</Name>
				<Source><![CDATA[
    internal void updateRAssetForDelete()
    {
        LedgerJournalTrans_RAsset ljTransDeleted_RAsset, ljTransLinked_RAsset;

        if (this.AccountType == LedgerJournalACType::FixedAssets_RU)
        {
            ljTransDeleted_RAsset = LedgerJournalTrans_RAsset::find(this.RecId);
            if (!ljTransDeleted_RAsset.BudgetModel &&
                ljTransDeleted_RAsset.TransType != RAssetTransType::PartialTakeDown &&
                (ljTransDeleted_RAsset.CanDisposal || ! ljTransDeleted_RAsset.ToFromRecId))
            {
                ljTransLinked_RAsset = ljTransDeleted_RAsset.madeDisposable(this.orig());
            }
            ljTransDeleted_RAsset.deleteTaxGroupDepreciations();
        }
        if (ljTransLinked_RAsset)
        {
            ljTransLinked_RAsset.updateGainLoss();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExchRateInternalHU</Name>
				<Source><![CDATA[
    internal void updateExchRateInternalHU(HuExchOutflowType _exchOutflowType)
    {
        if (this.AccountType == LedgerJournalACType::RCash && this.amount())
        {
            this.updateExchRate_HU(_exchOutflowType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedForDelete</Name>
				<Source><![CDATA[
    internal void updateRelatedForDelete(LedgerJournalTable _ledgerJournalTable)
    {
        switch (_ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::CustBillOfExchangeDraw:
                if (CustBillOfExchangeJour::find(this.NegInstId).Status == CustVendNegInstStatus::None)
                {
                    CustBillOfExchangeJour custBillOfExchangeJour;

                    delete_from custBillOfExchangeJour
                        where custBillOfExchangeJour.BillOfExchangeId == this.NegInstId;
                }
                break;

            case LedgerJournalType::VendPromissoryNoteDraw:
                if (VendPromissoryNoteJour::find(this.NegInstId).Status == CustVendNegInstStatus::None)
                {
                    VendPromissoryNoteJour vendPromissoryNoteJour;

                    delete_from vendPromissoryNoteJour
                        where vendPromissoryNoteJour.PromissoryNoteId == this.NegInstId;
                }
                break;

            case LedgerJournalType::VendPromissoryNoteRedraw:
                if (this.BankPromissoryNoteNum)
                {
                    BankPromissoryNoteTable bankPromissoryNoteTable;

                    bankPromissoryNoteTable = BankPromissoryNoteTable::findBankPNDocStatus(this.BankAccountId,this.BankPromissoryNoteNum,BankPromissoryNoteStatus::Printed,true);
                    bankPromissoryNoteTable.DocumentStatus = BankPromissoryNoteStatus::Posted;
                    bankPromissoryNoteTable.update();
                }
                break;

            case LedgerJournalType::BankChequeReversal:
                if (_ledgerJournalTable.Posted == NoYes::No)
                {
                    this.revertBankAccountTrans(_ledgerJournalTable.JournalType);
                    this.revertBankChequeTable();
                }
                break;

            case LedgerJournalType::BankDepositPaymCancel:
                if (_ledgerJournalTable.Posted == NoYes::No)
                {
                    this.revertBankAccountTrans(_ledgerJournalTable.JournalType);
                    this.revertBankDeposit();
                }
                break;

            case LedgerJournalType::Payment:
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
                    && this.AccountType == LedgerJournalACType::Vend && this.Prepayment)
                {
                    FactureTrans_RU factureTrans_RU;
                    FactureJour_RU factureJour_RU;

                    factureTrans_RU = FactureTrans_RU::findLedgerJournalTrans('', 0.0, this.RecId, false);
                    factureJour_RU = FactureJour_RU::find(factureTrans_RU.FactureId, factureTrans_RU.Module, true);
                    if (factureJour_RU)
                    {
                        FactureDelete_RU factureDelete_RU;

                        factureDelete_RU = FactureDelete_RU::construct(factureJour_RU);
                        factureDelete_RU.runOperation();
                    }
                }
                break;
        }

        // Remove the referenced reason code and comment if the journal has not been posted.
        if (_ledgerJournalTable.Posted == NoYes::No && this.ReasonRefRecID != 0)
        {
            ReasonTableRef::deleteByReference(this.ReasonRefRecID);
        }

        // delete action manual deletes
        AssetBookTableDerivedJournal assetBookTableDerivedJournal;
        delete_from assetBookTableDerivedJournal
            where assetBookTableDerivedJournal.RefRecId == this.RecId;

        AssetReversalRelatedVoucher assetReversalRelatedVoucher;
        delete_from assetReversalRelatedVoucher
                where assetReversalRelatedVoucher.Voucher == this.Voucher
                    && assetReversalRelatedVoucher.TransDate == this.TransDate;

        CustTransCashDisc custTransCashDisc;
        delete_from custTransCashDisc
            where custTransCashDisc.RefTableId == tableNum(LedgerJournalTrans)
                && custTransCashDisc.RefRecId == this.RecId;

        CustVendCreditInvoicingTable custVendCreditInvoicingTable;
        delete_from custVendCreditInvoicingTable
            where custVendCreditInvoicingTable.RefTableId == tableNum(LedgerJournalTrans)
                && custVendCreditInvoicingTable.RefRecId == this.RecId;

        CustVendNACHAIATInfoTable_US custVendNACHAIATInfoTable_US;
        delete_from custVendNACHAIATInfoTable_US
            where custVendNACHAIATInfoTable_US.LedgerJournalTransRecId == this.RecId;

        CustVendPaymJournalFee custVendPaymJournalFee;
        delete_from custVendPaymJournalFee
            where custVendPaymJournalFee.RefRecId == this.RecId;

        LedgerJournalTransAccrual ledgerJournalTransAccrual;
        delete_from ledgerJournalTransAccrual
            where ledgerJournalTransAccrual.RefTableid == tableNum(LedgerJournalTrans)
                && ledgerJournalTransAccrual.RefRecid == this.RecId;

        LedgerJournalTransBankLC ledgerJournalTransBankLC;
        delete_from ledgerJournalTransBankLC
            where ledgerJournalTransBankLC.LedgerJournalTrans == this.RecId;

        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;
        delete_from ledgerJournalTrans_Asset
            where ledgerJournalTrans_Asset.RefRecId == this.RecId;

        TaxServiceTariff::deleteByParent(tableNum(LedgerJournalTrans), this.RecId);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBE]))
        {
            TradeBLWIJournalPurposeCodes tradeBLWIJournalPurposeCodes;
            delete_from tradeBLWIJournalPurposeCodes
                where tradeBLWIJournalPurposeCodes.RefRecId == this.RecId
                    && tradeBLWIJournalPurposeCodes.TypeOfForm == TradeBLWITypeOfForm::InvoiceRegister;

            delete_from tradeBLWIJournalPurposeCodes
                where tradeBLWIJournalPurposeCodes.RefRecId == this.RecId
                    && tradeBLWIJournalPurposeCodes.TypeOfForm == TradeBLWITypeOfForm::LedgerJournalTrans;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]))
        {
            CustEPRemitInfo_BR custEPRemitInfo_BR;
            delete_from custEPRemitInfo_BR
                where custEPRemitInfo_BR.LedgerJournalTrans == this.RecId;

            LedgerJournalTransPayment_BR ledgerJournalTransPayment_BR;
            delete_from ledgerJournalTransPayment_BR
                where ledgerJournalTransPayment_BR.RefRecId == this.RecId;

            VendEPRemitInfo_BR vendEPRemitInfo_BR;
            delete_from vendEPRemitInfo_BR
                where vendEPRemitInfo_BR.LedgerJournalTrans == this.RecId;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN;
            delete_from ledgerJournalTransTaxExtensionIN
                where ledgerJournalTransTaxExtensionIN.LedgerJournalTrans == this.RecId;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]))
        {
            LedgerJournalTransSymbol ledgerJournalTransSymbol;
            delete_from ledgerJournalTransSymbol
                where ledgerJournalTransSymbol.LedgerJournalTrans == this.RecId;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLV]))
        {
            LedgerJournalTransPayment_LV ledgerJournalTransPayment_LV;
            delete_from ledgerJournalTransPayment_LV
                where ledgerJournalTransPayment_LV.LedgerJournalTrans == this.RecId;

            LedgerJournalTransPaymTransCode ledgerJournalTransPaymTransCode;
            delete_from ledgerJournalTransPaymTransCode
                where ledgerJournalTransPaymTransCode.LedgerJournalTrans == this.RecId;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
        {
            DIOTAdditionalInfoForNoVendor_MX diotAdditionalInfoForNoVendor_MX;
            delete_from diotAdditionalInfoForNoVendor_MX
                where diotAdditionalInfoForNoVendor_MX.InstanceRelationType == this.RecId;
        }

        PlSADFinanceLedgerJournalRef::clearReference(this.RecId);

        if (RCashParameters::isCashModuleEnabled())
        {
            LedgerJournalTrans_RCash ledgerJournalTrans_RCash;
            delete_from ledgerJournalTrans_RCash
                where ledgerJournalTrans_RCash.RefRecId == this.RecId;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            BankClientPayment_RU::updateOnTransDelete(this);

            LedgerJournalTrans_RDeferrals ledgerJournalTrans_RDeferrals;
            delete_from ledgerJournalTrans_RDeferrals
                where ledgerJournalTrans_RDeferrals.RefRecId == this.RecId;

            RAssetPurchTrans rAssetPurchTrans;
            delete_from rAssetPurchTrans
                where rAssetPurchTrans.TableTableId == tableNum(LedgerJournalTrans)
                    && rAssetPurchTrans.TableRecId == this.RecId;

            RCashDestinationTrans rCashDestinationTrans;
            delete_from rCashDestinationTrans
                where rCashDestinationTrans.LedgerJournalTransRecId == this.RecId;
        }

        if (LedgerJournalTransExtensionTH::isExtensionEnabled())
        {
            LedgerJournalTransExtensionTH   ledgerJournalTransExtensionTH;
            delete_from ledgerJournalTransExtensionTH
                where ledgerJournalTransExtensionTH.LedgerJournalTrans == this.RecId;
        }

        LedgerJournalTransTaxExtension ledgerJournalTransTaxExt;
        delete_from ledgerJournalTransTaxExt
            where ledgerJournalTransTaxExt.LedgerJournalTrans == this.RecId;

        if (CFMParameters::isPaymentRequestsEnabled())
        {
            CFMPaymentRequestPaymentLink::deletePaymentRequestLinkJournalTrans(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>TaxUncommitted</c> records if a field that affects tax has changed.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record for the <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if the <c>TaxUncommitted</c> records were deleted; otherwise, false.
    /// </returns>
    protected boolean deleteTaxUncommitted(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans originalLedgerJournalTrans;
        #ISOCountryRegionCodes
        boolean                 isoIN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

        originalLedgerJournalTrans = this.orig();

        if (this.haveTaxesChanged())
        {
             // 1. In Tax Integration, calculation is per voucher. It does not support multiple invoices in one voucher.
            // 2. If single side, in tax integration, changes in customer/vendor line will impact tax on ledger line, so all tax in this voucher should be cleared.
            if (this.isTaxIntegrationEnabled())
            {
                TaxUncommitted::deleteForVoucher(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, originalLedgerJournalTrans.Voucher);
            }
            else if (TaxUncommitted::existByDocumentAndInvoice(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, originalLedgerJournalTrans.Voucher, originalLedgerJournalTrans.Invoice))
            {
                TaxUncommitted::deleteForInvoice(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, originalLedgerJournalTrans.Voucher, originalLedgerJournalTrans.Invoice);
            }

            if (isoIN
               && TaxItemGroupHeading::find(originalLedgerJournalTrans.TaxItemGroup).ServiceTaxBasis_IN != ServiceTaxBasis_IN::None
               && originalLedgerJournalTrans.isPaymentJournal_IN())
            {
                TaxUncommitted_IN::deleteByMainVoucher(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, originalLedgerJournalTrans.Voucher);
            }

            // if the invoice # changed then since taxes are calculated per voucher per invoice we need to also remove the
            // TaxUncommitted records from the new invoice so that taxes get recalculated on the new invoice.
            if (this.Invoice != originalLedgerJournalTrans.Invoice)
            {
                TaxUncommitted::deleteForInvoice(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, originalLedgerJournalTrans.Voucher, this.Invoice);
            }

            // if the voucher changed then since taxes are calculated per voucher per invoice we need to also remove the
            // TaxUncommitted records from the new voucher so that taxes get recalculated on the new voucher.
            if (this.Voucher != originalLedgerJournalTrans.Voucher)
            {
                 if (this.isTaxIntegrationEnabled())
                {
                    TaxUncommitted::deleteForVoucher(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, this.Voucher);
                }
                else
                {
                    TaxUncommitted::deleteForInvoice(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, this.Voucher, this.Invoice);
                }
            }
           
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>haveTaxesChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if taxes may have changed for the <c>LedgerJournalTrans</c> table record.
    /// </summary>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> table record.
    /// </param>
    /// <returns>
    /// true if taxes may have changed; otherwise, false.
    /// </returns>
    public boolean haveTaxesChanged(LedgerJournalTrans _originalLedgerJournalTrans = this.orig())
    {
        boolean taxesChanged = this.haveTaxesChangedForTaxIntegration(_originalLedgerJournalTrans)
            || this.Invoice != _originalLedgerJournalTrans.Invoice
            || this.Voucher != _originalLedgerJournalTrans.Voucher
            || this.CashDiscAmount != _originalLedgerJournalTrans.CashDiscAmount
            || this.CashDiscPercent != _originalLedgerJournalTrans.CashDiscPercent
            || this.CashDiscCode != _originalLedgerJournalTrans.CashDiscCode
            || this.TransDate != _originalLedgerJournalTrans.TransDate
            || this.DocumentDate != _originalLedgerJournalTrans.DocumentDate
            || this.ExchRateSecond != _originalLedgerJournalTrans.ExchRateSecond
            || this.ExchRate != _originalLedgerJournalTrans.ExchRate
            || this.ReportingCurrencyExchRateSecondary != _originalLedgerJournalTrans.ReportingCurrencyExchRateSecondary
            || this.ReportingCurrencyExchRate != _originalLedgerJournalTrans.ReportingCurrencyExchRate
            || this.Triangulation != _originalLedgerJournalTrans.Triangulation
            || this.CurrencyCode != _originalLedgerJournalTrans.CurrencyCode
            || this.AccountType != _originalLedgerJournalTrans.AccountType
            || this.Company != _originalLedgerJournalTrans.Company
            || this.OffsetCompany != _originalLedgerJournalTrans.OffsetCompany
            || this.OffsetAccountType != _originalLedgerJournalTrans.OffsetAccountType
            || !LedgerDimensionFacade::areEqual(this.LedgerDimension, _originalLedgerJournalTrans.LedgerDimension)
            || !LedgerDimensionFacade::areEqual(this.OffsetLedgerDimension, _originalLedgerJournalTrans.OffsetLedgerDimension)
            || !DimensionDefaultFacade::areEqual(this.DefaultDimension, _originalLedgerJournalTrans.DefaultDimension)
            || !DimensionDefaultFacade::areEqual(this.OffsetDefaultDimension, _originalLedgerJournalTrans.OffsetDefaultDimension)
            || this.Qty != _originalLedgerJournalTrans.Qty
            || this.TaxCode != _originalLedgerJournalTrans.TaxCode
            || this.TaxGroup != _originalLedgerJournalTrans.TaxGroup
            || this.TaxItemGroup != _originalLedgerJournalTrans.TaxItemGroup
            || this.AmountCurDebit != _originalLedgerJournalTrans.AmountCurDebit
            || this.AmountCurCredit != _originalLedgerJournalTrans.AmountCurCredit
            || this.Txt != _originalLedgerJournalTrans.Txt
            || this.Prepayment != _originalLedgerJournalTrans.Prepayment
            || this.Company != _originalLedgerJournalTrans.Company
            || this.OffsetCompany != _originalLedgerJournalTrans.OffsetCompany
            || this.VatDueDate_W != _originalLedgerJournalTrans.VatDueDate_W
            || this.vatOperationCode_RU != _originalLedgerJournalTrans.vatOperationCode_RU
            || this.TaxBase_W != _originalLedgerJournalTrans.TaxBase_W
            || this.TaxDirectionControl != _originalLedgerJournalTrans.TaxDirectionControl
            || this.hasIndirectTaxFieldChanged_IN(_originalLedgerJournalTrans)
            // <GEEPL>
            || (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL])
                && (this.CustVendAccount_PL != _originalLedgerJournalTrans.CustVendAccount_PL
                    || (this.VATNumJournal != _originalLedgerJournalTrans.VATNumJournal
                        || this.Addressing_PL != _originalLedgerJournalTrans.Addressing_PL
                        || this.TaxPeriodPaymentCode_PL != _originalLedgerJournalTrans.TaxPeriodPaymentCode_PL)));
        // </GEEPL>
        return taxesChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>haveTaxesChangedForTaxIntegration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if taxes may have changed for the <c>LedgerJournalTrans</c> table record under tax service integration.
    /// </summary>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> table record.
    /// </param>
    /// <returns>
    /// true if taxes may have changed; otherwise, false.
    /// </returns>
    protected boolean haveTaxesChangedForTaxIntegration(LedgerJournalTrans _originalLedgerJournalTrans = this.orig())
    {
        return this.isTaxIntegrationEnabled()
            && (this.VATNumJournal != _originalLedgerJournalTrans.VATNumJournal
                || this.Listcode != _originalLedgerJournalTrans.Listcode
                || this.Prepayment != _originalLedgerJournalTrans.Prepayment
                || (TaxIntegrationUtils::isTaxIntegrationEnabledForTaxSolutionProvider()
                    && (this.VendorVATDate != _originalLedgerJournalTrans.VendorVATDate
                        || this.ReverseDate != _originalLedgerJournalTrans.ReverseDate)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteVoucher</Name>
				<Source><![CDATA[
    public void deleteVoucher(Voucher _voucher = this.Voucher)
    {
        LedgerJournalTable  ledgerJournalTable = LedgerJournalTable::find(this.JournalNum);

        if (ledgerJournalTable && !ledgerJournalTable.Posted && !this.Transferred)
        {
            if (_voucher && ! LedgerJournalTrans::existTransMinusThis(this.JournalNum, _voucher, this.RecId))
            {
                if (this.checkVoucherNotUsed(ledgerJournalTable, _voucher))
                {
                    if (this.checkVoucherNotUsedDataSource(_voucher))
                    {
                        // replace the voucher number so it can be re-used  except journals types which do not default
                        if ((ledgerJournalTable.JournalType != LedgerJournalType::Periodic) &&
                            (ledgerJournalTable.JournalType != LedgerJournalType::Approval ||
                            _voucher != LedgerJournalTrans::ledgerJournalTransPool(this).Voucher) && ledgerJournalTable.NumberSequenceTable)
                        {
                            NumberSequenceTable numberSequenceTable = NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable);

                            if (numberSequenceTable)
                            {
                                if (NumberSeq::numCheckFormat(_voucher, numberSequenceTable))
                                {
                                    NumberSeq::releaseNumber(ledgerJournalTable.NumberSequenceTable, _voucher);
                                }
                                else
                                {
                                    // The NumberSeq::numCheckFormat API displays a warning message if the number sequence format did not match
                                    // remove the warning message to not introduce confusion to the end user
                                    int line = infolog.line();
                                    infolog.clear(line-1);
                                }
                            }
                        }
                        if (this.Voucher == _voucher)
                        {
                            // delete voucher template record if exists and the voucher on the line is not being changed
                            LedgerJournalTransVoucherTemplate::deleteForJournalOrVoucher(this.JournalNum, _voucher);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayBankLCLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the <c>BankLCShipmentLineNum</c> object of the letter of credit that is related to the
    /// <c>CustVendTransOpen</c> record, which is settled using the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <returns>
    /// The <c>BankLCShipmentLineNum</c> object of the letter of credit.
    /// </returns>
    public display BankLCShipmentLineNum displayBankLCLineNum()
    {
        BankLCShipmentLineNum       bankLCShipmentLineNum;
        LedgerJournalTransBankLC    ledgerJournalTransBankLC;

        ledgerJournalTransBankLC = this.getLedgerJournalTransBankLC();
        if (ledgerJournalTransBankLC.RecId != 0)
        {
            bankLCShipmentLineNum = ledgerJournalTransBankLC.getBankLCLine().LineNum;
        }

        return bankLCShipmentLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayBankLCNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the <c>BankLCNumber</c> object of the letter of credit that is related to the
    /// <c>CustVendTransOpen</c> record, which is settled using the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <returns>
    /// The <c>BankLCNumber</c> object of the letter of credit.
    /// </returns>
    public display BankLCNumber displayBankLCNumber()
    {
        BankLCNumber                bankLCNumber;
        LedgerJournalTransBankLC    ledgerJournalTransBankLC;

        ledgerJournalTransBankLC = this.getLedgerJournalTransBankLC();
        if (ledgerJournalTransBankLC.RecId != 0)
        {
            bankLCNumber = ledgerJournalTransBankLC.getBankLC().BankLCNumber;
        }

        return bankLCNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCurrencyCode</Name>
				<Source><![CDATA[
    public display CurrencyCode displayCurrencyCode()
    {
        return this.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCustPaymAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer payment amount from the debit or credit of the transaction.
    /// </summary>
    /// <returns>
    /// The customer payment amount of the transaction.
    /// </returns>
    /// <remarks>
    /// The <c>convertCustPaymAmountToDebitCredit</c> method is the complement of this method.
    /// </remarks>
    public display Amount displayCustPaymAmount()
    {
        Amount paymAmount;

        if (this.AmountCurCredit > 0)
        {
            paymAmount = this.AmountCurCredit;
        }
        else
        {
            paymAmount = -this.AmountCurDebit;
        }

        return paymAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayExchRate</Name>
				<Source><![CDATA[
    public display ExchRate displayExchRate()
    {
        ExchangeRateHelper  exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId), this.CurrencyCode);

        return exchangeRateHelper.displayStoredExchangeRate(this.ExchRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayExchRateSecond</Name>
				<Source><![CDATA[
    public display ExchrateSecondary displayExchRateSecond()
    {
        ExchangeRateHelper  exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId), this.CurrencyCode);

        return exchangeRateHelper.displayStoredExchangeRate(this.ExchRateSecond);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayMainAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the main account type of the voucher.
    /// </summary>
    /// <returns>
    /// The main account type of the voucher.
    /// </returns>
    /// <remarks>
    /// If more than one account is of type Cust, the main account is considered a ledger account.The
    /// project account type is considered the most important type, and overrules the other accounts.
    /// </remarks>
    public display LedgerJournalACType displayMainAccountType()
    {
        #IsoCountryRegionCodes
        LedgerJournalACType accountType;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#IsoPL]))
        {
            // In Poland, use the account type from the actual transaction if possible.
            accountType = this.mainAccountType_PL();
            if (accountType != LedgerJournalACType::Ledger)
            {
                return accountType;
            }
        }

        if (this.MainAccountType != conNull())
        {
            [accountType] = this.MainAccountType;
            return accountType;
        }

        return this.ledgerJournalTable().mainAccountType(this.Voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTaxBranchDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the tax branch code depending on the ledger dimension.
    /// </summary>
    /// <returns>
    /// Returns tax branch code getted by ledger dimension.
    /// </returns>
    public display TaxBranchCode displayTaxBranchDimension()
    {
        return TaxBranchType::getTBDisplayValueByLedgerDimension(this.LedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>editExchRate</Name>
				<Source><![CDATA[
    public edit ExchRate editExchRate(boolean set, ExchRate _exchRate)
    {
        ExchRate            exchRate = _exchRate;
        ExchangeRateHelper  exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId), this.CurrencyCode);
        if (set)
        {
            this.ExchRate = exchangeRateHelper.prepareExchangeRateForStorage(exchRate);
            if (!this.checkExchRate())
            {
                this.ExchRate = this.orig().ExchRate;
                exchRate = exchangeRateHelper.displayStoredExchangeRate(this.ExchRate);
            }

            // When accounting currency exchange rate is changed, that new exchange rate is defaulted to the reporting currency exchange rate
            // if the accounting and reporting currency are the same in the Ledger setup
            if (Ledger::isReportingCurrencySameAsAccountingCurrencyforLegalEntity(this.getCompanyLegalEntity()))
            {
                this.editReportingCurrencyExchRate(set, _exchRate);
            }
        }
        else
        {
            exchRate = exchangeRateHelper.displayStoredExchangeRate(this.ExchRate);
        }

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editReportingCurrencyExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// gets and sets the reporting currency exchange rate.
    /// </summary>
    /// <param name = "set">A Boolean value that determines whether the reason code is set.
    /// </param>
    /// <param name = "_reportingCurrencyExchRate">The new  exchange rate when <paramref name="set" /> is true.
    /// </param>
    /// <returns>The  exchange rate value from the reocrd of <c>ExchangeRate</c> table.
    /// </returns>
    public edit ReportingCurrencyExchRate editReportingCurrencyExchRate(boolean set, ReportingCurrencyExchRate _reportingCurrencyExchRate)
    {
        return this.LedgerJournalReportingCurrencyExchangeRates::editReportingCurrencyExchangeRate(set, _reportingCurrencyExchRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>editExchRateSecond</Name>
				<Source><![CDATA[
    public edit ExchrateSecondary editExchRateSecond(boolean set, ExchRate _exchRate)
    {
        ExchRate            exchRate = _exchRate;
        ExchangeRateHelper  exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId), this.CurrencyCode);
        if (set)
        {
            this.ExchRateSecond = exchangeRateHelper.prepareExchangeRateForStorage(exchRate);

            this.setReportingCurrencyExchangeRateSecond();
        }
        else
        {
            exchRate = exchangeRateHelper.displayStoredExchangeRate(this.ExchRateSecond);
        }

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editReportingCurrencyExchRateSecond</Name>
				<Source><![CDATA[
    /// <summary>
    /// gets and sets the second reporting currency second exchange rate.
    /// </summary>
    /// <param name = "set">A Boolean value that determines whether the reason code is set.
    /// </param>
    /// <param name = "_reportingCurrencyExchrateSecond">The new second exchange rate when <paramref name="set" /> is true.
    /// </param>
    /// <returns>The second exchange rate value from the reocrd of <c>ExchangeRate</c> table.
    /// </returns>
    public edit ReportingCurrencyExchrateSecondary editReportingCurrencyExchRateSecond(boolean set, ReportingCurrencyExchrateSecondary _reportingCurrencyExchrateSecond)
    {
        return this.LedgerJournalReportingCurrencyExchangeRates::editReportingCurrencyExchangeRateSecond(set, _reportingCurrencyExchrateSecond);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportingCurrencyExchangeRateSecondField</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the reporting currency exchange rate secondary field ID.
    /// </summary>
    /// <returns>
    ///     The reporting currency exchange rate secondary field ID.
    /// </returns>
    /// <remarks>
    ///     Used with the <c>LedgerJournalReportingCurrencyExchangeRates</c> map.
    /// </remarks>
    internal FieldId getReportingCurrencyExchangeRateSecondField()
    {
        return fieldNum(LedgerJournalTrans, ReportingCurrencyExchRateSecondary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the currency code.
    /// </summary>
    /// <returns>
    ///     The currency code.
    /// </returns>
    /// <remarks>
    ///     Used with the <c>LedgerJournalReportingCurrencyExchangeRates</c> map.
    /// </remarks>
    internal CurrencyCode getCurrencyCode()
    {
        return this.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editReasonCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the reason code.
    /// </summary>
    /// <param name="set">
    /// A Boolean value that determines whether the reason code is set.
    /// </param>
    /// <param name="_reasonCode">
    /// The new reason code when <paramref name="set" /> is true.
    /// </param>
    /// <returns>
    /// The reason code of the record in the <c>ReasonTableRef</c> table.
    /// </returns>
    public edit ReasonCode editReasonCode(boolean set, ReasonCode _reasonCode)
    {
        ReasonCode      reasonCode = strLRTrim(_reasonCode);

        if (set)
        {
            if (this.ReasonRefRecID == 0)
            {
                this.ReasonRefRecID = ReasonTableRef::createFromCode(reasonCode);
            }
            else
            {
                this.ReasonRefRecID = ReasonTableRef::updateCode(reasonCode, this.ReasonRefRecID);
            }

            //
            // Update the reason comment with the default comment value for the updated reason code.
            // A blank reasonCode will result in a blank comment because a blank reasonCode
            // will return an empty reasonTable buffer.
            //
            this.editReasonComment(true, ReasonTable::find(reasonCode).Description);
        }
        else
        {
            reasonCode = ReasonTableRef::find(this.ReasonRefRecID).Reason;
        }

        return reasonCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editReasonComment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the reason comment.
    /// </summary>
    /// <param name="set">
    /// A Boolean value that specifies whether to set if the reason comment.
    /// </param>
    /// <param name="_reasonComment">
    /// The new reason comment when <paramref name="set" /> is true.
    /// </param>
    /// <returns>
    /// The reason comment of the record in the <c>ReasonTableRef</c> table.
    /// </returns>
    public edit ReasonComment editReasonComment(boolean set, ReasonComment _reasonComment)
    {
        ReasonComment   reasonComment = _reasonComment;

        if (set)
        {
            // If the ReasonRefRecID is 0, then create a new ReasonTableRef record
            // otherwise, update the existing record.
            if (this.ReasonRefRecID == 0)
            {
                this.ReasonRefRecID = ReasonTableRef::createFromComment(reasonComment);
            }
            else
            {
                this.ReasonRefRecID = ReasonTableRef::updateComment(reasonComment, this.ReasonRefRecID);
            }
        }
        else
        {
            reasonComment = ReasonTableRef::find(this.ReasonRefRecID).ReasonComment;
        }

        return reasonComment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateTxt</Name>
				<Source><![CDATA[
    public display ExchRateSecondTxt exchRateTxt()
    {
        return ExchangeRateHelper::exchRateTxt(Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId), this.CurrencyCode, this.ExchRateSecond);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateTxtForReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns the exchange rate text for reporting currency.
    /// </summary>
    public display ExchRateSecondTxt exchRateTxtForReportingCurrency()
    {
        Description exchRateTxt;
        LedgerRecId ledger = Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId);

        if (this.CurrencyCode && Ledger::reportingCurrency())
        {
            if (this.ReportingCurrencyExchRateSecondary == 0.0)
            {
                // only two exchange rates
                exchRateTxt = strFmt("@SYS53184", Ledger::reportingCurrencyByLedger(ledger),
                                                  this.CurrencyCode);
            }
            else
            {
                // three exchange rates since this uses triangulation
                exchRateTxt = strFmt("@SYS53179", this.CurrencyCode,
                                                  Currency::findEuroCurrencyCode(),
                                                  Ledger::reportingCurrencyByLedger(ledger));
            }
        }

        return exchRateTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPaymentNotes</Name>
				<Source><![CDATA[
    //insert info from marked transactions into the field PaymentNotes in ledgerJournalTrans
    public void fillPaymentNotes()
    {
        CustVendTransStatic custVendTransStatic;
        CustVendPaymNote    custVendPaymNote;
        PaymNote            paymentNote;

        if (this.SettleVoucher == SettlementType::SelectedTransact)
        {
            // create the custVendTransStatic instance in the company of the payment
            changecompany(this.Company)
            {
                switch (this.AccountType)
                {
                    case LedgerJournalACType::Vend :
                        custVendTransStatic = CustVendTransStatic::newModuleCustVend(ModuleCustVend::Vend);
                        break;

                    case LedgerJournalACType::Cust :
                        custVendTransStatic = CustVendTransStatic::newModuleCustVend(ModuleCustVend::Cust);
                        break;
                }
            }

            if (custVendTransStatic)
            {
                if (this.PaymentNotes == '')
                {
                    custVendPaymNote = CustVendPaymNote::newCustVendTransStatic(custVendTransStatic);
                    this.PaymentNotes = custVendPaymNote.buildPaymNote(this.company(), this.TableId, this.RecId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAssetTable</Name>
				<Source><![CDATA[
    public AssetTable findAssetTable()
    {
        AssetTable  assetTable;

        if (!this.isCompanyIntercompany())
        {
            assetTable = AssetTable::findByLedgerDimension(this.LedgerDimension);
        }
        else
        {
            if (! xDataArea::exist(this.Company))
            {
                throw error(strFmt("@SYS10666", this.Company));
            }

            changecompany(this.Company)
            {
                assetTable = AssetTable::findByLedgerDimension(this.LedgerDimension);
            }
        }
        return assetTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBankAccountTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>BankAccountTable</c> record that corresponds to the bank account.
    /// </summary>
    /// <returns>
    /// A <c>BankAccountTable</c> record; otherwise, an empty record.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The account company does not exist.
    /// </exception>
    public BankAccountTable findBankAccountTable()
    {
        BankAccountTable   bankAccountTable;

        Debug::assert(this.AccountType == LedgerJournalACType::Bank);

        if (this.isCompanyIntercompany())
        {
            if (!xDataArea::exist(this.Company))
            {
                throw error(strFmt("@SYS10666", this.Company));
            }

            bankAccountTable = BankAccountTable::findByCompany(this.Company, this.parmAccount());
        }
        else
        {
            bankAccountTable = BankAccountTable::findByLedgerDimension(this.LedgerDimension);
        }

        return bankAccountTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBankAccountTableForOffset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>BankAccountTable</c> record that corresponds to the offset bank account.
    /// </summary>
    /// <returns>
    /// A <c>BankAccountTable</c> record; otherwise, an empty record.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The offset account company does not exist.
    /// </exception>
    public BankAccountTable findBankAccountTableForOffset()
    {
        BankAccountTable   bankAccountTable;

        Debug::assert(this.OffsetAccountType == LedgerJournalACType::Bank);

        if (this.isOffsetCompanyIntercompany())
        {
            if (!xDataArea::exist(this.OffsetCompany))
            {
                throw error(strFmt("@SYS10666", this.OffsetCompany));
            }

            bankAccountTable = BankAccountTable::findByCompany(this.OffsetCompany, this.parmOffsetAccount());
        }
        else
        {
            bankAccountTable = BankAccountTable::findByLedgerDimension(this.OffsetLedgerDimension);
        }

        return bankAccountTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustForOffset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>CustTable</c> record corresponding to the offset account.
    /// </summary>
    /// <returns>
    /// A record from the <c>CustTable</c> table; otherwise, an empty record.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The offset company does not exist.
    /// </exception>
    public CustTable findCustForOffset()
    {
        CustTable cust;

        Debug::assert(this.OffsetAccountType == LedgerJournalACType::Cust);

        if (this.isOffsetCompanyIntercompany())
        {
            if (!xDataArea::exist(this.OffsetCompany))
            {
                throw error(strFmt("@SYS10666", this.OffsetCompany));
            }

            cust = CustTable::findByCompany(this.OffsetCompany, this.parmOffsetAccount());
        }
        else
        {
            cust = CustTable::findByLedgerDimension(this.OffsetLedgerDimension);
        }

        return cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>CustTable</c> record corresponding to the account.
    /// </summary>
    /// <returns>
    /// A record from the <c>CustTable</c> table; otherwise, an empty record.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The account company does not exist.
    /// </exception>
    public CustTable findCustTable()
    {
        CustTable cust;

        if (this.isCompanyIntercompany())
        {
            if (!xDataArea::exist(this.Company))
            {
                throw error(strFmt("@SYS10666", this.Company));
            }

            cust = CustTable::findByCompany(this.Company, this.parmAccount());
        }
        else
        {
            cust = CustTable::findByLedgerDimension(this.LedgerDimension);
        }

        return cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerJournalTransAssetSibling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a company-safe lookup of a <c>LedgerJournalTrans_Asset</c> sibling record of the
    /// transaction.
    /// </summary>
    /// <returns>
    /// The <c>LedgerJournalTrans_Asset</c> sibling record of the record.
    /// </returns>
    /// <remarks>
    /// This method should be used to retrieve the <c>LedgerJournalTrans_Asset</c> sibling of a
    /// <c>LedgerJournalTrans</c>. If the find method of the <c>LedgerJournalTrans_Asset</c> is used
    /// directly, the find may be performed in the wrong company.
    /// </remarks>
    public LedgerJournalTrans_Asset findLedgerJournalTransAssetSibling()
    {
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;

        if (this.isFixedAssetsTransaction())
        {
            // This is a fixed assets transaction and should have a sibling record.

            // This LedgerJournalTrans buffer and its sibling always exist in the same company, but the active company might have
            // changed since this buffer was selected. Perform a company-safe lookup.
            // Changecompany is smart enough to know to not make a switch when we are already in the correct company.
            changecompany (
                           this.company()
                           )
            {
                // Switch to the company the transaction exists in and find the record.
                ledgerJournalTrans_Asset = LedgerJournalTrans_Asset::find(this.RecId);
            }
        }

        return ledgerJournalTrans_Asset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>MainAccount</c> record that corresponds to the account.
    /// </summary>
    /// <returns>
    /// A record in the <c>MainAccount</c> table; otherwise, an empty record.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The company does not exist.
    /// </exception>
    public MainAccount findMainAccount()
    {
        MainAccount mainAccount;

        Debug::assert(this.AccountType == LedgerJournalACType::Ledger);

        if (!this.isCompanyIntercompany())
        {
            mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(this.LedgerDimension);
        }
        else
        {
            if (! xDataArea::exist(this.Company))
            {
                throw error(strFmt("@SYS10666",this.Company));
            }

            changecompany(this.Company)
            {
                mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(this.LedgerDimension);
            }
        }
        return mainAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMainAccountForOffset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>MainAccount</c> record that corresponds to the offset account.
    /// </summary>
    /// <returns>
    /// A record in the <c>MainAccount</c> table; otherwise, an empty record.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The offset company does not exist.
    /// </exception>
    public MainAccount findMainAccountForOffset()
    {
        MainAccount mainAccount;

        Debug::assert(this.OffsetAccountType == LedgerJournalACType::Ledger);

        if (this.isOffsetCompanyIntercompany())
        {
            if (!xDataArea::exist(this.OffsetCompany))
            {
                throw error(strFmt("@SYS10666", this.OffsetCompany));
            }

            changecompany(this.OffsetCompany)
            {
                mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(this.OffsetLedgerDimension);
            }
        }
        else
        {
            mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(this.OffsetLedgerDimension);
        }

        return mainAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProjTable</Name>
				<Source><![CDATA[
    public ProjTable findProjTable(boolean _offsetAccount = false)
    {
        ProjTable   projTable;
        ProjId      projId;

        if (_offsetAccount)
        {
            projId = this.parmOffsetAccount();
        }
        else
        {
            projId = this.AccountType == LedgerJournalACType::Project ? this.parmAccount() : this.parmOffsetAccount();
        }

        projTable = ProjTable::find(projId);
        return projTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVendForOffset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>VendTable</c> record corresponding to the offset account.
    /// </summary>
    /// <returns>
    /// A record from the <c>VendTable</c> table; otherwise, an empty record.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The offset company does not exist.
    /// </exception>
    public VendTable findVendForOffset()
    {
        VendTable vend;

        Debug::assert(this.OffsetAccountType == LedgerJournalACType::Vend);

        if (this.isOffsetCompanyIntercompany())
        {
            if (!xDataArea::exist(this.OffsetCompany))
            {
                throw error(strFmt("@SYS10666", this.OffsetCompany));
            }

            vend = VendTable::findByCompany(this.OffsetCompany, this.parmOffsetAccount());
        }
        else
        {
            vend = VendTable::findByLedgerDimension(this.OffsetLedgerDimension);
        }

        return vend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVendTable</Name>
				<Source><![CDATA[
    public VendTable findVendTable()
    {
        VendTable   vendTable;
        VendAccount vendAccount = this.AccountType == LedgerJournalACType::Vend ? this.parmAccount() : this.parmOffsetAccount();

        if (this.isCompanyIntercompany())
        {
            if (!xDataArea::exist(this.Company))
            {
                throw error(strFmt("@SYS10666", this.Company));
            }

            vendTable = VendTable::findByCompany(this.Company, vendAccount);
        }
        else
        {
            vendTable = VendTable::find(vendAccount);
        }

        return vendTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushAllowEditCaches</Name>
				<Source><![CDATA[
    public void flushAllowEditCaches()
    {
        #macrolib.LedgerAIF
        container cacheKey;
        SysGlobalCache      cache = classfactory.globalCache();

        cacheKey = [this.JournalNum, this.Voucher];

        if (cache.isSet(#LedgerJournalTransCanNotBeChangedWhenCheckPrinted, cacheKey) == true)
        {
            cache.remove(#LedgerJournalTransCanNotBeChangedWhenCheckPrinted, cacheKey);
        }
        if (cache.isSet(#LedgerJournalTransCanNotBeChangedForPromissoryNote, cacheKey) == true)
        {
            cache.remove(#LedgerJournalTransCanNotBeChangedForPromissoryNote, cacheKey);
        }
        if (cache.isSet(#LedgerJournalTransCanNotBeDeletedForPromissoryNote, cacheKey) == true)
        {
            cache.remove(#LedgerJournalTransCanNotBeDeletedForPromissoryNote, cacheKey);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formSelectSettledNegInst</Name>
				<Source><![CDATA[
    public boolean formSelectSettledNegInst(LedgerJournalEngine _ledgerJournalEngine)
    {
        FormRun         formRun;
        Args            args = new Args();
        boolean         end  = false;

        if (!this.LedgerDimension)
        {
            throw error("@SYS25989");
        }

        args.record(this);
        args.parmObject(_ledgerJournalEngine);

        switch (this.AccountType)
        {
            case LedgerJournalACType::Cust :
                formRun = new MenuFunction(menuitemDisplayStr(CustBillOfExchangeProtestSettledSelect), MenuItemType::Display).create(args);
                break;

            case LedgerJournalACType::Vend :
                formRun = new MenuFunction(menuitemDisplayStr(VendPromissoryNoteRedrawSettledSelect), MenuItemType::Display).create(args);
                break;

            default:
                end  = true;
        }
        if (! end)
        {
            if (formRun)
            {
                formRun.run();
                formRun.wait();
            }
        }
        return end;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateRemittanceFeeTrans</Name>
				<Source><![CDATA[
    public void generateRemittanceFeeTrans()
    {
        LedgerJournalTable ledgerJournalTable = this.ledgerJournalTable();

        if (ledgerJournalTable.JournalType != LedgerJournalType::CustPaymRemittance
            && ledgerJournalTable.JournalType != LedgerJournalType::VendPaymRemittance)
        {
            return;
        }

        BankAccountTable bankAccountTable = BankAccountTable::find(this.BankAccountId);
        LedgerDimensionDefaultAccount defaultAccount;
        AmountCur amountCur;
        switch (this.BankRemittanceType)
        {
            case BankRemittanceType::Discount:
                amountCur = bankAccountTable.RemitDiscountAmount;
                defaultAccount = bankAccountTable.RemittanceDiscountLedgerDimension;
                break;

            case BankRemittanceType::Collection:
                if (ledgerJournalTable.JournalType != LedgerJournalType::VendPaymRemittance)
                {
                    amountCur = bankAccountTable.RemitCollectionAmount;
                    defaultAccount = bankAccountTable.RemittanceCollectionLedgerDimension;
                    break;
                }

            case BankRemittanceType::None:
                if (ledgerJournalTable.JournalType != LedgerJournalType::VendPaymRemittance)
                {
                    return;
                }
                amountCur = bankAccountTable.InvoiceRemitAmount;
                defaultAccount = bankAccountTable.InvoiceRemittanceLedgerDimension;
                break;

            default:
                return;
        }

        if (!amountCur)
        {
            return;
        }

        DimensionAttribute sysGenBankAccount = DimensionAttribute::getAttributeByHierarchyType(DimensionHierarchyType::BankAccount);
        FieldId bankAccountKeyFieldId = fieldName2Id(tableNum(DimensionAttributeValueCombination), sysGenBankAccount.DimensionKeyColumnName);

        CustVendPaymJournalFee journalFee;
        LedgerJournalTrans ledgerJournalTransFieldList;
        DimensionAttributeValueCombination dimAttrValueCombo;
        select firstonly journalFee
            where journalFee.RefRecId == 0
               && journalFee.LedgerJournalACType == LedgerJournalACType::Bank
        join RecId from dimAttrValueCombo
            where dimAttrValueCombo.RecId == journalFee.LedgerDimension
               && dimAttrValueCombo.(bankAccountKeyFieldId) == bankAccountTable.RecId
        join RecId from ledgerJournalTransFieldList
            where ledgerJournalTransFieldList.JournalNum == ledgerJournalTable.JournalNum
               && ledgerJournalTransFieldList.RecId == journalFee.FeeTransRecId
               && ledgerJournalTransFieldList.BankRemittanceFileId == this.BankRemittanceFileId;

        if (journalFee)
        {
            return;
        }

        ttsbegin;

        LedgerJournalTrans ledgerJournalTrans;
        ledgerJournalTrans.data(this);

        ledgerJournalTrans.AccountType = LedgerJournalACType::Ledger;
        ledgerJournalTrans.LedgerDimension = ledgerJournalTrans.getLedgerDimensionForLedgerType(defaultAccount, ledgerJournalTrans.Company);
        ledgerJournalTrans.DefaultDimension = 0;

        ledgerJournalTrans.parmOffsetAccount(this.BankAccountId, LedgerJournalACType::Bank);
        ledgerJournalTrans.CurrencyCode = bankAccountTable.CurrencyCode;
        ledgerJournalTrans.amountCur2DebCred(amountCur);
        ledgerJournalTrans.PaymentStatus = CustVendPaymStatus::None;

        if (ledgerJournalTable.ledgerJournalName().NewVoucher != NewVoucher::OneVoucher)
        {
            ledgerJournalTrans.Voucher = new JournalVoucherNum(JournalTableData::newTable(ledgerJournalTable)).getNew(false);
        }
        ledgerJournalTrans.LineNum = LedgerJournalTrans::lastLineNum(ledgerJournalTrans.JournalNum) + 1;
        ledgerJournalTrans.insert();

        journalFee.clear();
        journalFee.FeeTransRecId = ledgerJournalTrans.RecId;
        journalFee.LedgerJournalACType = ledgerJournalTrans.OffsetAccountType;
        journalFee.parmCustVendAccount(ledgerJournalTrans.parmOffsetAccount());
        journalFee.FeeCurrency = ledgerJournalTrans.CurrencyCode;
        journalFee.FeeId = '-';
        journalFee.insert(true);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualAndCalculatedTaxForSingleLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total actual and calculated tax amount for the current line.
    /// </summary>
    /// <param name="_includeUseTax">
    /// A value that indicates whether the use tax is included in the tax amount; optional.
    /// </param>
    /// <returns>
    /// The actual and calculated tax amount for the current line.
    /// </returns>
    public container getActualAndCalculatedTaxForSingleLine(boolean _includeUseTax)
    {
        TaxAmountCur            actualTax, calculatedTax;

        [actualTax, calculatedTax] = LedgerJournalTrans::getActualAndCalculatedTaxForSingleLineIL([this, _includeUseTax]);

        return [actualTax, calculatedTax];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssetCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the company that the fixed asset transaction belongs to.
    /// </summary>
    /// <returns>
    /// The company that the fixed asset transaction belongs to.
    /// </returns>
    public CompanyId getAssetCompany()
    {
        if (this.AccountType == LedgerJournalACType::FixedAssets)
        {
            if (this.Company)
            {
                // The primary fixed asset account's company has been specified.
                return this.Company;
            }
        }
        else if (this.OffsetAccountType == LedgerJournalACType::FixedAssets)
        {
            if (this.OffsetCompany)
            {
                // The primary account isn't of type fixed asset, but the offset is and its
                // company has been specified.
                return this.OffsetCompany;
            }
        }
        else
        {
            // This isn't a fixed asset transaction, so throw an error.
            throw error("@SYS112955");
        }

        // No company has been specified, so we need to return the current one in order to support
        // the case that intercompany has been disabled (that is, companies can't be specified).
        return curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssetId</Name>
				<Source><![CDATA[
    // This method returns the assetId. AssetId is specified as account or offset account.
    // If the account type is FixedAssets, then account number needs to be returned.
    // If the account type is not FA, but offset account type is FA, then offsetAccount is returned.
    public AssetId getAssetId()
    {
        AssetId assetId;

        if (this.AccountType == LedgerJournalACType::FixedAssets)
        {
            assetId = this.parmAccount();
        }
        else if (this.OffsetAccountType == LedgerJournalACType::FixedAssets)
        {
            assetId = this.parmOffsetAccount();
        }

        return assetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankLCLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>BankLCLine</c> record that is related to the <c>CustVendTransOpen</c> record, which is
    /// settled by using the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// The <c>BankLCLine</c> record.
    /// </returns>
    public BankLCLine getBankLCLine(boolean _forUpdate = false)
    {
        BankLCLine bankLCLineLocal;
        LedgerJournalTransBankLC ledgerJournalTransBankLCLocal;

        ledgerJournalTransBankLCLocal = this.getLedgerJournalTransBankLC();

        if (ledgerJournalTransBankLCLocal.BankLCLine != 0)
        {
            bankLCLineLocal = BankLCLine::find(ledgerJournalTransBankLCLocal.BankLCLine, _forUpdate);
        }

        return bankLCLineLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankTransactionCurrencyAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank transaction currency amount.
    /// </summary>
    /// <returns>
    /// The bank transaction currency amount.
    /// </returns>
    /// <remarks>
    /// Only return valid value when the line is related to bank account.
    /// </remarks>
    public AmountCur getBankTransactionCurrencyAmount()
    {
        AmountCur       amountCur;

        if (this.parmBankAccount())
        {
            amountCur = this.amount();

            if (this.OffsetAccountType == LedgerJournalACType::Bank)
            {
                amountCur = -amountCur;
            }
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetCheckResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>BudgetCheckResult</c> value for the specified <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <returns>
    /// The <c>BudgetCheckResult</c> value for the specified <c>LedgerJournalTrans</c> record.
    /// </returns>
    public BudgetCheckResult getBudgetCheckResult()
    {
        BudgetCheckResult budgetCheckResult;

        if (this.RecId != 0 &&
            BudgetControlConfiguration::isControlConfigured() &&
            hasTableAccess(tableNum(BudgetSource)) &&
            hasTableAccess(tableNum(LedgerJournalTrans)) &&
            hasTableAccess(tableNum(CompanyInfo)) &&
            hasTableAccess(tableNum(GeneralJournalEntry)) &&
            hasTableAccess(tableNum(LedgerEntryJournal)))
        {
            budgetCheckResult = BudgetSourceLedgerJournalTrans::findBudgetCheckResult(this.company(), this.JournalNum, this.Voucher);
        }

        return budgetCheckResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerAccountForAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the dispaly value of the ledger dimension to be posted to based on the account and account type.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> table.
    /// </param>
    /// <param name="_isOffsetTrans">
    /// A boolean value that indicates whether it is an offset transaction.
    /// </param>
    /// <returns>
    /// The display value for the account that will be posted to.
    /// </returns>
    public DimensionDisplayValue getLedgerAccountForAccount(LedgerJournalTable _ledgerJournalTable, boolean _isOffsetTrans = false)
    {
        DimensionDisplayValue ledgerDimensionDisplayValue;
        LedgerDimensionAccount ledgerDimension;

        if (this.AccountType != LedgerJournalACType::Ledger)
        {
            ledgerDimension = this.getLedgerDimensionForJournalAccount(_ledgerJournalTable, _isOffsetTrans);
            ledgerDimensionDisplayValue = DimensionAttributeValueCombination::find(ledgerDimension).DisplayValue;
        }
        else
        {
            ledgerDimensionDisplayValue = LedgerDimensionFacade::getDisplayValueForLedgerDimension(this.LedgerDimension);
        }

        return ledgerDimensionDisplayValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForJournalAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger dimension to be posted to based on the account and account type.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> table.
    /// </param>
    /// <param name="_isOffsetTrans">
    /// A boolean value that indicates whether it is an offset transaction.
    /// </param>
    /// <returns>
    /// The ledger dimension for the account that will be posted to.
    /// </returns>
    public LedgerDimensionAccount getLedgerDimensionForJournalAccount(LedgerJournalTable _ledgerJournalTable, boolean _isOffsetTrans = false)
    {
        DimensionDynamicAccount ledgerDimension;
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;
        AssetPostingProfile postingProfile;
        DimensionDisplayValue ledgerDimensionDisplayValue;
        RAssetStandards rAssetStandards;
        LedgerDimensionAccount mainAccountLedgerDimension;
        LedgerJournalTrans_RAsset ledgerJournalTrans_RAsset;
        LedgerJournalTrans_RDeferrals ledgerJournalTrans_RDeferrals;

        ledgerDimensionDisplayValue = LedgerDimensionFacade::getDisplayValueForLedgerDimension(this.LedgerDimension);
        mainAccountLedgerDimension = this.LedgerDimension;

        if (this.AccountType != LedgerJournalACType::Ledger)
        {
            if (this.Company == curext())
            {
                switch (this.AccountType)
                {
                    case LedgerJournalACType::Cust:
                        ledgerDimension = CustLedgerAccounts::summaryLedgerDimension(
                            ledgerDimensionDisplayValue,
                            this.getPostingProfileForCustVend(_ledgerJournalTable, _isOffsetTrans));
                        break;

                    case LedgerJournalACType::Vend:
                        ledgerDimension = VendLedgerAccounts::summaryLedgerDimension(
                            ledgerDimensionDisplayValue,
                            this.getPostingProfileForCustVend(_ledgerJournalTable, _isOffsetTrans));
                        break;

                    case LedgerJournalACType::Project:
                        ledgerDimension = ProjTrans::newLedgerJournalTrans(this).journalReportLedgerDimension(0);
                        break;

                    case LedgerJournalACType::FixedAssets:
                        ledgerJournalTrans_Asset = this.findLedgerJournalTransAssetSibling();
                        postingProfile = AssetTable::find(ledgerJournalTrans_Asset.AssetId).postingProfile(ledgerJournalTrans_Asset.BookId);
                        if (!postingProfile)
                        {
                            postingProfile = AssetParameters::find().postingProfile();
                        }
                        ledgerDimension = AssetLedgerAccounts::findAssetLedgerDimension(
                            ledgerDimensionDisplayValue,
                            ledgerJournalTrans_Asset.BookId,
                            AssetPost::assetTransTypeJournal2AssetTransType(ledgerJournalTrans_Asset.TransType),
                            true,
                            postingProfile);
                        break;

                    case LedgerJournalACType::Bank:
                        ledgerDimension = BankAccountTable::findLedgerDimension(ledgerDimensionDisplayValue);
                        break;

                    case LedgerJournalACType::Employee_RU:
                        ledgerDimension = EmplLedgerAccounts_RU::summaryLedgerDimension(ledgerDimensionDisplayValue, this.PostingProfile);
                        break;

                    case LedgerJournalACType::RCash:
                        ledgerDimension = RCashLedgerAccount::summaryLedgerDimension(ledgerDimensionDisplayValue, this.PostingProfile);
                        break;

                    case LedgerJournalACType::FixedAssets_RU:
                        ledgerJournalTrans_RAsset = LedgerJournalTrans_RAsset::find(this.RecId);
                        if (ledgerJournalTrans_RAsset.DebLedgerDimension)
                        {
                            ledgerDimension = ledgerJournalTrans_RAsset.DebLedgerDimension;
                        }
                        else
                        {
                            rAssetStandards = RAssetStandards::find(ledgerDimensionDisplayValue,
                                  ledgerJournalTrans_RAsset.StandardId ? ledgerJournalTrans_RAsset.StandardId : RAssetParameters::standardIdDefault());

                            ledgerDimension = rAssetStandards.assetLedgerDimension(ledgerJournalTrans_RAsset.StandardId,
                                  this.PostingProfile, ledgerJournalTrans_RAsset.TransType);
                        }
                        break;

                    case LedgerJournalACType::RDeferrals:
                        ledgerJournalTrans_RDeferrals = LedgerJournalTrans_RDeferrals::find(this.RecId);

                        if (ledgerJournalTrans_RDeferrals.LedgerDimension)
                        {
                            ledgerDimension = ledgerJournalTrans_RDeferrals.LedgerDimension;
                        }
                        else
                        {
                            ledgerDimension = RDeferralsLedgerAccounts::deferralsLedgerDim(LedgerDimensionFacade::getDisplayValueForLedgerDimension(this.LedgerDimension),
                                ledgerJournalTrans_RDeferrals.TransType,
                                ledgerJournalTrans_RDeferrals.BookId);
                        }
                        break;

                    default :
                        ledgerDimension = 0;
                }

                mainAccountLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension, this.DefaultDimension);
            }
            else
            {
                AmountMSTDebCred transactionAmount = this.AmountCurDebit ?
                    abs(this.AmountCurDebit) :
                    - abs(this.AmountCurCredit);

                ledgerDimension = LedgerInterCompany::getOriginatingCompanyLedgerDimensionWithAmount(
                    transactionAmount,
                    curExt(),
                    this.Company);

                mainAccountLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension, this.DefaultDimension);
            }
        }

        return mainAccountLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForLedgerType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger account for the default account.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The default account.
    /// </param>
    /// <param name="_company">
    /// The company ID of the default account.
    /// </param>
    /// <returns>
    /// The ledger account.
    /// </returns>
    /// <remarks>
    /// This method combines the default account together with the pertinent default dimensions to create a
    /// ledger account.
    /// </remarks>
    public LedgerDimensionAccount getLedgerDimensionForLedgerType(
        LedgerDimensionDefaultAccount _ledgerDimension,
        CompanyId _company)
    {
        if (_ledgerDimension == 0)
        {
            return 0;
        }

        return LedgerJournalTrans::getLedgerDimensionForLedgerTypeServer(_ledgerDimension, _company, this.ledgerJournalTable());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalTransBankLC</Name>
				<Source><![CDATA[
    public LedgerJournalTransBankLC getLedgerJournalTransBankLC()
    {
        return LedgerJournalTransBankLC::findByLedgerJournalTrans(this.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetCompany</Name>
				<Source><![CDATA[
    public CompanyId getOffsetCompany()
    {
        if (this.OffsetCompany == '')
        {
            return curext();
        }
        else
        {
            return this.OffsetCompany;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetLedgerDimensionForLedgerType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the offset ledger account for the default account.
    /// </summary>
    /// <param name="_defaultLedgerDimension">
    /// The default account.
    /// </param>
    /// <param name="_offsetCompany">
    /// The company ID of the default account.
    /// </param>
    /// <returns>
    /// The ledger account.
    /// </returns>
    /// <remarks>
    /// This method combines the default account and the pertinent default dimensions
    /// to create a ledger account.
    /// </remarks>
    public LedgerDimensionAccount getOffsetLedgerDimensionForLedgerType(
        LedgerDimensionDefaultAccount   _defaultLedgerDimension,
        CompanyId                       _offsetCompany)
    {
        if (_defaultLedgerDimension == 0)
        {
            return 0;
        }

        return LedgerJournalTrans::getOffsetLedgerDimForLedgerTypeServer(_defaultLedgerDimension, _offsetCompany, this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetLedgerDimensionForProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the offset ledger account for the default account for a proposal.
    /// </summary>
    /// <param name="_defaultLedgerDimension">
    /// The default account.
    /// </param>
    /// <param name="_accountNumber">
    /// The account number of the entity.
    /// </param>
    /// <param name="_accountType">
    /// The account type of the entity.
    /// </param>
    /// <param name="_assetBookId">
    /// The asset book ID; optional.
    /// </param>
    /// <returns>
    /// The ledger account.
    /// </returns>
    /// <remarks>
    /// Proposals are never intercompany. The primary and offset companies are the same, and these also
    /// match the company on the journal header. The company is assumed to be the current company.This
    /// method combines the default account together with the pertinent default dimensions to create a
    /// ledger account.
    /// </remarks>
    public LedgerDimensionAccount getOffsetLedgerDimensionForProposal(
        LedgerDimensionDefaultAccount   _defaultLedgerDimension,
        LedgerJournalAC                 _accountNumber,
        LedgerJournalACType             _accountType,
        AssetBookIdPurchSalesInvent     _assetBookId = '')
    {
        if (_defaultLedgerDimension == 0)
        {
            return 0;
        }

        return LedgerJournalTrans::getOffsetLedgerDimForProposalServer(_defaultLedgerDimension, _accountNumber, _accountType, _assetBookId, this.ledgerJournalTable());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingProfileForCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the posting profile for customer or vendor account type.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name = "_isOffsetTrans">
    /// A boolean value that indicates whether it is an offset transaction.
    /// </param>
    /// <returns>
    /// returns the <c>PostingProfile</c> value.
    /// </returns>
    protected PostingProfile getPostingProfileForCustVend(LedgerJournalTable _ledgerJournalTable, boolean _isOffsetTrans)
    {
        #EECountryRegionCodes
        if (_isOffsetTrans)
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll) && this.OffsetPostingProfile_RU)
            {
                return this.OffsetPostingProfile_RU;
            }
            else
            {
                // Offset transaction: get the posting profile from the current set according to the journal type
                return CustVendNegInstPost::getPostingProfile(_ledgerJournalTable.JournalType, this.BankRemittanceType);
            }
        }
        else
        {
            // Current transaction: get the posting profile directly from the ledgerJournalTrans
            return this.PostingProfile;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the project ID for this transaction.
    /// </summary>
    /// <returns>
    /// The <c>ProjId</c> of the primary project that is used by this transaction.
    /// </returns>
    /// <remarks>
    /// If this is not a project transaction, an empty ID is returned.
    /// </remarks>
    public ProjId getProjectId()
    {
        ProjId projId;

        if (this.AccountType == LedgerJournalACType::Project)
        {
            projId = this.parmAccount();
        }
        else if (this.OffsetAccountType == LedgerJournalACType::Project)
        {
            projId = this.parmOffsetAccount();
        }

        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCashDiscChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the cash discount has been changed.
    /// </summary>
    /// <returns>
    /// true if the cash discount has changed; otherwise false.
    /// </returns>
    public boolean hasCashDiscChanged()
    {
        return (this.CashDiscAmount != this.orig().CashDiscAmount || this.DateCashDisc != this.orig().DateCashDisc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPendingInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a pending invoice exists for a <c>LedgerJournalTrans</c> table record.
    /// </summary>
    /// <returns>
    /// true if a pending invoice exists for the <c>LedgerJournalTrans</c> table record; otherwise, false.
    /// </returns>
    public display boolean hasPendingInvoice()
    {
        LedgerJournalTrans localLedgerJournalTrans;
        VendInvoiceInfoTable localVendInvoiceInfoTable;

        localLedgerJournalTrans = LedgerJournalTrans::ledgerJournalTransPool(this);

        if (localLedgerJournalTrans.RecId != 0)
        {
            select firstonly RecId from localVendInvoiceInfoTable
                where localVendInvoiceInfoTable.PoolRecId == localLedgerJournalTrans.RecId &&
                        localVendInvoiceInfoTable.ParmJobStatus != ParmJobStatus::Executed &&
                        localVendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::Pending;
        }

        return localVendInvoiceInfoTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPendingInvoiceInWorkflow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a pending invoice is in review for a <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <returns>
    /// true if a pending invoice is in review for the <c>LedgerJournalTrans</c> table record; otherwise, false.
    /// </returns>
    public boolean hasPendingInvoiceInWorkflow()
    {
        LedgerJournalTrans ledgerJournalTrans;
        VendInvoiceInfoTable vendInvoiceInfoTable;

        ledgerJournalTrans = LedgerJournalTrans::ledgerJournalTransPool(this);

        if (ledgerJournalTrans.RecId != 0)
        {
            select firstonly RecId from vendInvoiceInfoTable
                where vendInvoiceInfoTable.PoolRecId == ledgerJournalTrans.RecId &&
                        vendInvoiceInfoTable.ParmJobStatus != ParmJobStatus::Executed &&
                        vendInvoiceInfoTable.RequestStatus == VendInvoiceRequestStatus::InReview;
        }

        return vendInvoiceInfoTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasRelatedTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a <c>TaxWithholdTrans</c> table record exists for a <c>LedgerJournalTrans</c> table record.
    /// </summary>
    /// <returns>
    /// true if a <c>TaxWithholdTrans</c> table record exists for the <c>LedgerJournalTrans</c> table record; otherwise, false.
    /// </returns>
    public boolean hasRelatedTaxWithholdTrans()
    {
        TaxWithholdTrans    taxWithholdTrans;
        SpecTrans           specTrans;

        if (this.RecId)
        {
            select firstonly RecId
                from taxWithholdTrans
                exists join specTrans
                    where specTrans.RecId           == taxWithholdTrans.SpecTransId
                        && specTrans.SpecRecId      == this.RecId
                        && specTrans.SpecTableId    == this.TableId
                        && specTrans.SpecCompany    == this.DataAreaId;
        }

        return taxWithholdTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initForCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current record for a new currency.
    /// </summary>
    /// <param name="_parentLedgerJournalTable">
    /// The <c>LedgerJournalTable</c> record that corresponds to the current record.
    /// </param>
    /// <remarks>
    /// The new currency should already be set. This method supports multicompany.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// Triangulation is enabled and the Euro currency is not defined.
    /// </exception>
    public void initForCurrency(LedgerJournalTable _parentLedgerJournalTable)
    {
        ExchangeRateHelper helper;

        Debug::assert(this.company() == _parentLedgerJournalTable.company());

        if (this.CurrencyCode == '')
        {
            // nothing to do
            return;
        }

        if ((_parentLedgerJournalTable.FixedExchRate != 0) &&
            (_parentLedgerJournalTable.CurrencyCode == this.CurrencyCode))
        {
            this.ExchRate = _parentLedgerJournalTable.ExchRate;
            this.ExchRateSecond = _parentLedgerJournalTable.ExchrateSecondary;
            this.Triangulation = _parentLedgerJournalTable.euroTriangulation;
        }
        else
        {
            helper = this.initExchangeRateHelper();

            this.ExchRate = helper.getExchangeRate1();
            this.ExchRateSecond = helper.getExchangeRate2();
            this.Triangulation = this.ExchRateSecond != 0 ? true : false;
        }

        if (Ledger::reportingCurrency() != '')
        {
            if (_parentLedgerJournalTable.ReportingCurrencyFixedExchRate &&
                    _parentLedgerJournalTable.CurrencyCode == this.CurrencyCode)
            {
                this.ReportingCurrencyExchRate           = _parentLedgerJournalTable.ReportingCurrencyExchRate;
                this.ReportingCurrencyExchRateSecondary  = _parentLedgerJournalTable.ReportingCurrencyExchRateSecondary;
            }
            else
            {
                helper = this.initExchangeRateHelper();
                helper.parmToCurrency(Ledger::reportingCurrency());
                helper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());

                this.ReportingCurrencyExchRate          = helper.getExchangeRate1();
                this.ReportingCurrencyExchRateSecondary = helper.getExchangeRate2();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initExchangeRateHelper</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of the <c>ExchangeRateHelper</c> class.
    /// </summary>
    /// <returns>
    /// Returns an initialized instance of the <c>ExchangeRateHelper</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final ExchangeRateHelper initExchangeRateHelper()
    {
        return ExchangeRateHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(this.Company).RecId),
                this.CurrencyCode,
                this.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustPaymModeTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs initialization by using the specified payment method.
    /// </summary>
    /// <param name="_paymMode">
    /// The payment method to use for initialization.
    /// </param>
    /// <remarks>
    /// This method supports multi-company by verifying the values before they are set.
    /// </remarks>
    public void initFromCustPaymModeTable(CustPaymModeTable _paymMode)
    {
        Debug::assert(_paymMode.RecId != 0);

        if (this.BankDepositVoucher)
        {
            // bank is required for deposit
            this.OffsetAccountType = LedgerJournalACType::Bank;

            if (_paymMode.AccountType == LedgerJournalACType::Bank)
            {
                if (BankAccountTable::existByCompany(this.getOffsetCompany(), _paymMode.parmPaymAccount()))
                {
                    // default is deposit compatible
                    this.parmOffsetAccount(_paymMode.parmPaymAccount());
                }
            }
        }
        else if (_paymMode.paymACType() == LedgerJournalACType::Bank ||
            _paymMode.paymACType() == LedgerJournalACType::Ledger)
        {
            if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()) && _paymMode.isBridgingByBankAccount())
            {
                this.bridgingBankAccountModified();
            }
            else
            {
                // normal default
                this.OffsetAccountType = _paymMode.paymACType();

                if (this.OffsetAccountType == LedgerJournalACType::Bank)
                {
                    if (BankAccountTable::existByCompany(this.getOffsetCompany(), _paymMode.parmPaymAccount()))
                    {
                        this.parmOffsetAccount(_paymMode.parmPaymAccount());
                    }
                }
                else if (this.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    changecompany(this.getOffsetCompany())
                    {
                        if (LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_paymMode.offsetLedgerDimension()) != 0)
                        {
                            this.OffsetLedgerDimension = this.getOffsetLedgerDimensionForLedgerType(_paymMode.offsetLedgerDimension(), this.getOffsetCompany());
                        }
                        else
                        {
                            this.OffsetLedgerDimension = 0;
                        }
                    }
                }
            }
        }
        else if (this.OffsetAccountType != LedgerJournalACType::Ledger)
        {
            // final fallback
            this.OffsetAccountType = LedgerJournalACType::Ledger;
            this.OffsetLedgerDimension = 0;
        }
        if (this.OffsetAccountType == LedgerJournalACType::Bank)
        {
            this.BankClientDocumentTypeId_RU = _paymMode.BankClientDocumentTypeId_RU;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs initialization using the specified customer.
    /// </summary>
    /// <param name="_cust">
    /// The customer to use for initialization.
    /// </param>
    /// <param name="_initPaymMode">
    /// Indicates whether to initialize the payment methods from customer.
    /// </param>
    /// <remarks>
    /// This method supports multicompany.
    /// </remarks>
    public void initFromCustTable(CustTable _cust, boolean _initPaymMode = true)
    {
        CustParameters parms;
        CustPaymModeTable paymMode;

        if (Debug::debugMode())
        {
            Debug::assert(this.AccountType == LedgerJournalACType::Cust);
            Debug::assert(this.Company == _cust.company());
            Debug::assert(this.parmAccount() == _cust.AccountNum);
            Debug::assert(this.company() == curext());
        }

        this.Due = this.TransDate;

        this.CurrencyCode = _cust.Currency;

        parms = CustParameters::findByCompany(this.Company);
        this.PostingProfile = parms.PostingProfile;

        this.CustVendBankAccountId = _cust.BankAccount;

        paymMode = CustPaymModeTable::find(_cust.PaymMode);
        if (paymMode.RecId != 0)
        {
            if (_initPaymMode)
            {
                this.PaymMode = _cust.PaymMode;
            }

            this.initFromCustPaymModeTable(paymMode);
        }

        this.PaymSpec = _cust.PaymSpec;
        this.BankTransType = paymMode.BankTransType;
        this.Payment = _cust.PaymTermId;
        this.SettleVoucher = parms.AutoSettle ? SettlementType::OpenTransact : SettlementType::None;
        this.BankCentralBankPurposeCode = _cust.BankCentralBankPurposeCode;
        this.BankCentralBankPurposeText = _cust.BankCentralBankPurposeText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromGeneralJournal</Name>
				<Source><![CDATA[
    public void initFromGeneralJournal(
        GeneralJournalAccountEntry  _generalJournalAccountEntry,
        GeneralJournalEntry         _generalJournalEntry,
        LedgerEntry                 _ledgerEntry)
    {
        BankChequeTable bankChequeTable;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        this.AccountType = LedgerJournalACType::Ledger;

        this.LedgerDimension = _generalJournalAccountEntry.LedgerDimension;

        this.FurtherPostingRecId = _ledgerEntry.RecId;

        if (_generalJournalAccountEntry.AccountingCurrencyAmount > 0)
        {
            this.AmountCurCredit = _generalJournalAccountEntry.AccountingCurrencyAmount;
            this.AmountCurDebit = 0;
        }
        else
        {
            this.AmountCurDebit = -_generalJournalAccountEntry.AccountingCurrencyAmount;
            this.AmountCurCredit = 0;
        }

        // get the voucher assoicated with the generalJournalEntry. There should only be one in this case.
        select firstonly * from subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == _generalJournalEntry.RecId;
        Debug::assert(subledgerVoucherGeneralJournalEntry != null);

        this.PaymReference  = _generalJournalAccountEntry.PaymentReference;

        this.TransDate              = _generalJournalEntry.AccountingDate;
        this.Voucher                = subledgerVoucherGeneralJournalEntry.Voucher;
        this.AcknowledgementDate    = _generalJournalEntry.AcknowledgementDate;
        this.DocumentDate           = _generalJournalEntry.DocumentDate;
        this.DocumentNum            = _generalJournalEntry.DocumentNumber;

        this.Qty                = _generalJournalAccountEntry.Quantity;
        this.Txt                = _generalJournalAccountEntry.Text;
        this.PaymMode           = _ledgerEntry.PaymentMode;
        this.FurtherPostingType = _ledgerEntry.IsBridgingPosting;

        if (_generalJournalAccountEntry.PaymentReference != '')
        {
            select firstonly bankChequeTable
                where bankChequeTable.Voucher == subledgerVoucherGeneralJournalEntry.Voucher &&
                      bankChequeTable.TransDate == _generalJournalEntry.AccountingDate &&
                      bankChequeTable.ChequeNum == _generalJournalAccountEntry.PaymentReference;

            if (bankChequeTable != null)
            {
                this.BankChequeNum = bankChequeTable.ChequeNum;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTAMDeduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>LedgerJournalTrans</c> record from current record.
    /// </summary>
    /// <param name="_tamDeduction">
    /// The <c>TamDedution</c> record to use in the initialization.
    /// </param>
    /// <param name="_tamDeductionUpdateType">
    /// The update type.
    /// </param>
    /// <param name="_amountCur">
    /// The amount to use to initialize the <c>LedgerJournalTrans</c>.
    /// </param>
    public void initFromTAMDeduction(
        TAMDeduction            _tamDeduction,
        TAMDeductionUpdateType  _tamDeductionUpdateType,
        AmountCur               _amountCur)
    {
        LedgerJournalTrans  ledgerJournalTransParent;
        NumberSeq           numberSeq;

        this.initValue();

        MCRLedgerJournalTransInit::setApproval(this);

        this.BankTransType      = '';
        this.Company            = curext();
        this.CurrencyCode       = _tamDeduction.CurrencyCode;
        this.Due                = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        this.ExchRate           = ExchangeRateHelper::exchRate(this.CurrencyCode);
        this.OffsetLedgerDimension = _tamDeduction.DeductOffLedgerDimension;
        if (this.OffsetLedgerDimension)
        {
            this.SkipBlockedForManualEntryCheck = NoYes::Yes;
        }
        this.OffsetAccountType  = LedgerJournalACType::Ledger;
        this.PaymentStatus      = CustVendPaymStatus::None;
        this.PaymId             = '';
        this.PaymMode           = '';
        this.PostingProfile     = CustParameters::find().PostingProfile;
        this.TransDate          = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        this.TransactionType    = LedgerTransType::Payment;

        ledgerJournalTransParent = _tamDeduction.ledgerJournalTransParent();

        // Default dimensions from parent
        if (!this.DefaultDimension
            && ledgerJournalTransParent.DefaultDimension)
        {
            this.DefaultDimension = ledgerJournalTransParent.DefaultDimension;
        }

        // Default offset dimensions from parent
        if (!this.OffsetDefaultDimension
            && ledgerJournalTransParent.OffsetDefaultDimension)
        {
            this.OffsetDefaultDimension = ledgerJournalTransParent.OffsetDefaultDimension;
        }

        if (_tamDeductionUpdateType == TAMDeductionUpdateType::Create)
        {
            // Posting negative amount (credit to customer)
            this.amountCur2DebCred(- _tamDeduction.AmountCur);
        }
        else
        {
            this.amountCur2DebCred(_amountCur);
        }
        switch (_tamDeductionUpdateType)
        {
            case TAMDeductionUpdateType::Create              :
                this.LedgerDimension=LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_tamDeduction.AccountNum, LedgerJournalACType::Cust);
                this.AccountType    = LedgerJournalACType::Cust;

                // Copy from parent
                this.JournalNum      = ledgerJournalTransParent.JournalNum;
                this.TransactionType = LedgerTransType::Payment;
                this.Txt = "@SYS14364" + ' ' + "@SYS32341" + ' ' + _tamDeduction.tamDeductionID;

                // Get new voucher based on journal of parent
                numberSeq = NumberSeq::newGetVoucherFromId(
                    ledgerJournalTransParent.ledgerJournalTable().NumberSequenceTable);
                this.Voucher = numberSeq.voucher();
                break;
            case TAMDeductionUpdateType::Match               :
                this.LedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_tamDeduction.AccountNum, LedgerJournalACType::Cust);
                this.AccountType = LedgerJournalACType::Cust;
                this.Txt = "@MCR27625" + ' ' + "@SYS32341" + ' ' + _tamDeduction.tamDeductionID;
                break;
            case TAMDeductionUpdateType::ReverseMatch        :
                this.LedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_tamDeduction.AccountNum, LedgerJournalACType::Cust);
                this.AccountType = LedgerJournalACType::Cust;
                this.Txt = "@MCR27660" + ' ' + "@SYS32341" + ' ' + _tamDeduction.tamDeductionID;
                break;
            case TAMDeductionUpdateType::Deny                :
                this.LedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_tamDeduction.AccountNum, LedgerJournalACType::Cust);
                this.AccountType = LedgerJournalACType::Cust;
                this.Txt = "@MCR27606" + ' ' + "@SYS32341" + ' ' + _tamDeduction.tamDeductionID;
                break;
            case TAMDeductionUpdateType::ReverseDenial       :
                this.LedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_tamDeduction.AccountNum, LedgerJournalACType::Cust);
                this.AccountType = LedgerJournalACType::Cust;
                this.Txt = "@MCR27654" + ' ' + "@SYS32341" + ' ' + _tamDeduction.tamDeductionID;
                break;
            case TAMDeductionUpdateType::WriteOff            :
                // AccountNum specified elsewhere
                this.AccountType = LedgerJournalACType::Ledger;
                this.Txt = "@SYS99195" + ' ' + "@SYS32341" + ' ' + _tamDeduction.tamDeductionID;
                break;
            case TAMDeductionUpdateType::ReverseWriteOff    :
                this.LedgerDimension  = _tamDeduction.DeductWriteOffLedgerDimension;
                this.AccountType = LedgerJournalACType::Ledger;
                this.Txt = "@MCR27649" + ' ' + "@SYS32341" + ' ' + _tamDeduction.tamDeductionID;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue()
    {
        #ISOCountryRegionCodes
        CompanyInfo companyInfo;

        super();

        if (!this.CurrencyCode)
        {
            this.CurrencyCode = CompanyInfoHelper::standardCurrency();
        }

        if (!this.ExchRate)
        {
            // For defaulting logic to properly default the exchange rate if the user changes the transaction
            // currency, the exchange rate field state must be reset to not set.
            this.initFieldValue(fieldNum(LedgerJournalTrans, ExchRate), ExchangeRateHelper::exchRate(this.CurrencyCode));

            this.defaultReportingCurrencyExchangeRateIfSameCurrencies();
        }

        this.Company = curext();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.AgreementCompany_RU = curext();
            this.OffsetAgreementCompany_RU = curext();
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)))
        {
            // Only initialize the OffsetCompany if the Intercompany config key is
            // enabled.
            this.OffsetCompany = curext();
        }
        this.NoEdit         = NoYes::No;

        companyInfo = CompanyInfo::find();
        this.PaymInstruction1 = companyInfo.PaymInstruction1;
        this.PaymInstruction2 = companyInfo.PaymInstruction2;
        this.PaymInstruction3 = companyInfo.PaymInstruction3;
        this.PaymInstruction4 = companyInfo.PaymInstruction4;

        // Determine if the tax direction is required.
        if (TaxParameters::find().MandatoryTaxDirection)
        {
            this.TaxDirectionControl = NoYes::Yes;
        }

        if (TaxParameters::checkTaxParameters_IN() || TaxWithholdParameters_IN::checkTaxParameters())
        {
            this.SalesPurchJournalLine::initFromCompanyInformation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFieldValue</Name>
				<Source><![CDATA[
    private void initFieldValue(FieldId _fieldId, anytype _fieldValue)
    {
        this.(_fieldId) = _fieldValue;
        this.fieldState(_fieldId, FieldState::NotSet);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert()
    {
        LedgerJournalTable  ledgerJournalTable;
        HuExchOutflowType   exchOutflowType;

        #ISOCountryRegionCodes
        #OCCRetryCount

        ledgerJournalTable = this.ledgerJournalTable();
        if (! this.Company)
        {
            this.Company = curext();
        }

        if((this.AccountType == LedgerJournalACType::Project || this.OffsetAccountType == LedgerJournalACType::Project) &&
            ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
        {
            throw error(strFmt("@Proj:ProjProjectOperationFeatureAccountTypeIsNotSupported",
                                  this.Company));
        }

        if(!this.DelayTaxCalculation && TaxParameters::find().DelayTaxCalculation)
        {
            this.DelayTaxCalculation = ledgerJournalTable.DelayTaxCalculation;
        }

        if (! this.OffsetCompany && isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)))
        {
            // Only initialize the OffsetCompany if the Intercompany config key is
            // enabled and it has not been previously set.
            this.OffsetCompany = curext();
        }

        if (this.Transfer)
        {
            this.TransactionType = LedgerTransType::Transfer;
        }

        if (! this.CurrencyCode)
        {
            throw error("@SYS23229");
        }

        if (this.TaxCode)
        {
            if (TaxParameters::checkTaxParameters_IN() && TaxTable::find(this.TaxCode).TaxType_IN != TaxType_IN::None)
            {
                this.TaxCode = this.TaxCode;
            }
            else
            {
                if (!TaxVoucherService::ledgerAccountIsVATAccount(this.AccountType, this.LedgerDimension))
                {
                    this.TaxCode = '';
                }
            }
        }

        this.negotiableInstrumentPreInsert();

        if (! this.LineNum)
        {
            this.LineNum = LedgerJournalTrans::lastLineNum(this.JournalNum) + 1;
        }

        if (!this.AcknowledgementDate)
        {
            this.AcknowledgementDate = this.TransDate;
        }

        this.defaultReportingCurrencyExchangeRateIfSameCurrencies();

        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            this.modifyVatDueDate_W();
        }

        if (this.AccountType != LedgerJournalACType::Vend && this.AccountType != LedgerJournalACType::Cust && this.AccountType != LedgerJournalACType::Project)
        {
            this.CustBankAccount = 0;
            this.VendBankAccount = 0;
            this.CustVendBankAccountId = '';
        }
        else
        {
            if (strLen(this.CustVendBankAccountId) > 0)
            {
                if (this.CustBankAccount == 0 && this.VendBankAccount == 0)
                {
                    this.updateCustVendBankAccount();
                }
            }
            else
            {
                this.CustBankAccount = 0;
                this.VendBankAccount = 0;
            }
        }

        if (this.LedgerDimensionName == '')
        {
            this.LedgerDimensionName = LedgerJournalTransLedgerDimensionNameHelper::findName(this.Company, this.AccountType, this.LedgerDimension);
        }

        ttsbegin;

        try
        {
            super();
        }
        catch (Exception::DuplicateKeyException)
        {
            if (xSession::currentRetryCount() < #RetryNum)
            {
                this.LineNum = LedgerJournalTrans::lastLineNum(this.JournalNum) + 1;

                // In order to suppress any duplicate key error messages, issue a retry.
                retry;
            }
            else if (LedgerJournalTransThrowDupKeyExcepFlight::instance().isEnabled())
            {
                throw Exception::DuplicateKeyExceptionNotRecovered;
            }
        }

        this.SysExtensionSerializerMap::postInsert();

        ttscommit;

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            if (FormDataUtil::isFormDataSource(this))
            {
                Object ledgerJournalTransTaxExtDataSource = FormDataUtil::getFormDataSource(this);

                if (formDataSourceHasMethod(ledgerJournalTransTaxExtDataSource, identifierStr(insertIntoLedgerJournalTransTaxExt_IN)))
                {
                    ledgerJournalTransTaxExtDataSource.insertIntoLedgerJournalTransTaxExt_IN();
                }
            }
        }
        // </GIN>

        if (LedgerJournalTransTaxExtension::isExtensionEnabledV2())
        {
            if (FormDataUtil::isFormDataSource(this))
            {
                Object ledgerJournalTransTaxDataSource = FormDataUtil::getFormDataSource(this);

                if (formDataSourceHasMethod(ledgerJournalTransTaxDataSource, identifierStr(insertIntoLedgerJournalTransTaxExtension)))
                {
                    ledgerJournalTransTaxDataSource.insertIntoLedgerJournalTransTaxExtension();
                }
            }
        }

        if (BrazilParameters::isEnabled())
        {
            LedgerJournalTransPayment_BR ledgerJournalTransPayment_BR = this.SysExtensionSerializerMap::getExtensionTable(tableNum(ledgerJournalTransPayment_BR), true);
            ledgerJournalTransPayment_BR.EPPaymentType_BR = this.paymSpec ? VendPaymModeSpec::findSpec(this.paymMode, this.paymSpec).EPPaymentType_BR : '';
            ledgerJournalTransPayment_BR.EPPaymentWay_BR  = this.paymSpec ? VendPaymModeSpec::findSpec(this.paymMode, this.paymSpec).EPPaymentWay_BR  : '';
            this.SysExtensionSerializerMap::packExtensionTable(ledgerJournalTransPayment_BR);
            this.SysExtensionSerializerMap::postUpdate();
        }

        boolean isTaxIntegrationEnabledForJournalType = ledgerJournalTable.isTaxIntegrationEnabled();
        if (isTaxIntegrationEnabledForJournalType)
        {
            // Delete TaxUncommitted. TaxUncommitted.Invoice is not set in both CoreTax and TaxIntegration, use voucher instead.
            if (ledgerJournalTable.RecId
                && TaxUncommitted::existByDocumentAndVoucher(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher))
            {
                TaxUncommitted::deleteForVoucher(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher);
            }
        }

        if (this.DelayTaxCalculation == NoYes::No
            && !isTaxIntegrationEnabledForJournalType
            && !(this.isFixedAssetsTransaction() || this.isProjectTransaction()))
        {
            // Do not calculate taxes for fixed assets or project transactions, they will get calculated when the
            // LedgerJournalTrans_Asset and LedgerJournalTrans_Project records get inserted since those records are
            // required to successfully calculate taxes.
            if (((this.TaxGroup && this.TaxItemGroup) || this.TaxCode) && (ledgerJournalTable.JournalType != LedgerJournalType::Assets))
            {
                // tax information is out of date so delete and recalculate taxes.
                if (TaxUncommitted::existByDocumentAndInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher, this.Invoice))
                {
                    TaxUncommitted::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher, this.Invoice);
                }

                // don't calculate taxes if this is marked as posted.  Also, records in the invoice pool don't
                // get Taxes calculated since they have already been posted to TaxTrans.
                // documents in the invoice pool are already posted and should not have taxes calculated.
                if (!ledgerJournalTable.Posted && !(ledgerJournalTable.JournalType == LedgerJournalType::VendInvoicePool))
                {
                    LedgerJournalTrans::getTaxInstance(this.JournalNum, this.Voucher, this.Invoice, true
                        , null, false, this.TransDate);
                }
            }

            if (TaxWithholdParameters_IN::checkTaxParameters()
                && (!TaxWithholdNotCalcTaxForInvoicePool_INFlight::instance().isEnabled() || ledgerJournalTable.JournalType != LedgerJournalType::VendInvoicePool))
            {
                LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = this.ledgerJournalTransTaxExtensionIN();

                if (ledgerJournalTransTaxExt.tdsGroup || ledgerJournalTransTaxExt.tcsGroup)
                {
                    // delete the cache for the document header if the threshold is not exceeded.
                    // because this will impact the tax calculation for other journal lines.
                    if (!TaxWithholdCalculation_IN::checkRecoverableAccount(this)
                        && TaxWithholdTrans_IN::isThresholdExceededForAccount(this.parmAccount(),
                                                                              ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup,
                                                                              this.TransDate))
                    {
                        if (TaxWithholdUncommitted_IN::existByDocumentId(ledgerJournalTable.TableId, ledgerJournalTable.RecId))
                        {
                            TaxWithholdUncommitted_IN::deleteForDocumentHeader(ledgerJournalTable.TableId, ledgerJournalTable.RecId);
                        }
                        if (!ledgerJournalTable.Posted)
                        {
                            TaxVoucherService::calculateWithholdTaxForJournal_IN(this.JournalNum);
                        }
                    }
                    else
                    {
                        if (TaxWithholdUncommitted_IN::existByDocumentId(ledgerJournalTable.TableId, ledgerJournalTable.RecId))
                        {
                            TaxWithholdUncommitted_IN::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher, this.Invoice);
                            TaxWithholdUncommitted_IN::includeAsNonTaxedRecordsInVoucher(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher);

                        }

                        if (!ledgerJournalTable.Posted
                            && ((ledgerJournalTransTaxExt.TDSGroup || ledgerJournalTransTaxExt.TCSGroup)))
                        {
                            LedgerJournalTrans_IN_Extension::getTaxWithholdInstance_IN(this.JournalNum, this.Voucher, this.Invoice, true);
                        }
                    }
                }
            }
        }

        this.negotiableInstrumentPostInsert();

        if (this.AccountType == LedgerJournalACType::RCash &&
            this.amount()    <  0)
        {
            exchOutflowType = RCashParameters::find().ExchOutflowType_HU;
            this.updateExchRate_HU(exchOutflowType, true);
        }

        // Remove the journalNum cache that was set on \Classes\LedgerJournalTaxDocument\doTaxGroupExistsForDocument,
        // but only if taxes exist on this buffer since having no taxes on this line would
        // not impact the caching of whether or not taxes existed for the journal
        if (this.isTaxCalculationNeeded(isTaxIntegrationEnabledForJournalType))
        {
            LedgerJournalTaxDocument::clearCachedTaxExistenceCheck(this.JournalNum);
        }

        this.setPayWhenPaid();

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            this.markCurrentTaxDocumentTaxStatusDirty();
            TaxEngineLedgerJournalTransHeader::clearCacheForTaxableDocumentType(this.JournalNum, this.Voucher);
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankDocumentPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the journal line is linked to a payment bank document.
    /// </summary>
    /// <returns>
    /// A value that indicates whether the journal line is linked to a payment bank document.
    /// </returns>
    public boolean isBankDocumentPayment()
    {
        boolean result;

        if (this.isBankDocumentPaymentProcessNeeded()
            &&  BankDocumentTable::findBySource(tableNum(LedgerJournalTrans), this.RecId))
        {
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankDocumentPaymentProcessNeeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the bank document processing logic is needed.
    /// </summary>
    /// <returns>
    /// Whether the bank document processing logic is needed.
    /// </returns>
    private boolean isBankDocumentPaymentProcessNeeded()
    {
        CompanyBankAccountId    bankAccount;
        boolean                 result;
        BankDocumentBookType    bankDocumentBookType;

        //This method will not introduce extra RPC call since every field it accesses is cached.
        //It can avoid unecessary RPC call when the bank document processing logic is not needed to run.
        bankDocumentBookType = this.parmBankDocumentBookType();
        if (bankDocumentBookType == BankDocumentBookType::CustPayment
            || bankDocumentBookType == BankDocumentBookType::VendPayment
            || bankDocumentBookType == BankDocumentBookType::BankClearing)
        {
            bankAccount = this.parmBankAccount();
            if (BankAccountTable::isAdvancedBankReconciliationEnabled(bankAccount))
            {
                result = true;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetCheckRequiredForUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the check for available budget funds is required for the update on the
    /// <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> record before the update.
    /// </param>
    /// <returns>
    /// true if the check for available budget funds is required for the update on the
    /// <c>LedgerJournalTrans</c> record; otherwise, false.
    /// </returns>
    public boolean isBudgetCheckRequiredForUpdate(LedgerJournalTrans _originalLedgerJournalTrans)
    {
        return (_originalLedgerJournalTrans.AccountType != this.AccountType ||
            _originalLedgerJournalTrans.Company != this.Company ||
            _originalLedgerJournalTrans.AmountCurDebit != this.AmountCurDebit ||
            _originalLedgerJournalTrans.CurrencyCode != this.CurrencyCode ||
            _originalLedgerJournalTrans.AmountCurCredit != this.AmountCurCredit ||
            _originalLedgerJournalTrans.OffsetAccountType != this.OffsetAccountType ||
            _originalLedgerJournalTrans.OffsetCompany != this.OffsetCompany ||
            _originalLedgerJournalTrans.TransDate != this.TransDate ||
            _originalLedgerJournalTrans.LedgerDimension != this.LedgerDimension ||
            _originalLedgerJournalTrans.OffsetLedgerDimension != this.OffsetLedgerDimension ||
            _originalLedgerJournalTrans.JournalNum != this.JournalNum ||
            _originalLedgerJournalTrans.Voucher != this.Voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNewBudgetSourceRequired</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Identifies whether the orig voucher is different than the current voucher.
    /// </summary>
    /// <param name="_originalLedgerJournalTrans">
    ///    The original <c>LedgerJournalTrans</c> record before the update.
    /// </param>
    /// <returns>
    ///    true if the orig voucher is different than the current voucher; otherwise, false.
    /// </returns>
    internal boolean isNewBudgetSourceRequired(LedgerJournalTrans _originalLedgerJournalTrans)
    {
        return (_originalLedgerJournalTrans.Voucher != this.Voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCompanyIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Identifies whether a company account is intercompany.
    /// </summary>
    /// <param name="_currentCompany">
    ///    The current company; optional.
    /// </param>
    /// <returns>
    ///    true if the company account differs from the current company; otherwise, false.
    /// </returns>
    public boolean isCompanyIntercompany(DataAreaId _currentCompany = curext())
    {
        return (this.Company && this.Company != _currentCompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDependantOnSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether journal amounts and dates depend on transactions marked for settlement with the
    /// journal line.
    /// </summary>
    /// <returns>
    /// true if journal amounts and dates depend on transactions marked for settlement with the journal
    /// line; otherwise false.
    /// </returns>
    /// <remarks>
    /// This dependency pertains to transaction date, cash discount, and exchange rates. It is used to
    /// determine whether the user should be able to change the transaction date of a journal line.
    /// </remarks>
    public boolean isDependantOnSettlement()
    {
        SpecTrans           specTrans;
        CustVendTrans       custVendTrans;
        CustVendTransOpen   custVendTransOpen;

        CustTrans           custTrans;
        CustTransOpen       custTransOpen;

        VendTrans           vendTrans;
        VendTransOpen       vendTransOpen;

        if (this.SettleVoucher != SettlementType::SelectedTransact)
        {
            return false;
        }

        switch (this.AccountType)
        {
            case LedgerJournalACType::Cust :
                custVendTrans       = custTrans;
                custVendTransOpen   = custTransOpen;
                break;

            case LedgerJournalACType::Vend :
                custVendTrans       = vendTrans;
                custVendTransOpen   = vendTransOpen;
                break;

            default :
                return false;
        }

        custVendTrans.skipPostLoad(true);
        select firstonly crossCompany RecId from specTrans
            where specTrans.SpecRecId     == this.RecId
               && specTrans.SpecTableId   == this.TableId
               && specTrans.SpecCompany   == this.company()
        join RecId from custVendTransOpen
            where custVendTransOpen.TableId == specTrans.RefTableId
               && custVendTransOpen.RecId   == specTrans.RefRecId
               && custVendTransOpen.DataAreaId == specTrans.RefCompany
        join RecId from custVendTrans
            where custVendTrans.AccountNum  == custVendTransOpen.AccountNum
               && custVendTrans.RecId       == custVendTransOpen.RefRecId
               && (custVendTrans.CurrencyCode != this.CurrencyCode || custVendTrans.CashDiscCode);

        if (specTrans.RecId != 0)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFixedAssetsTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a transaction is a fixed assets transaction.
    /// </summary>
    /// <returns>
    /// true if the transaction is a fixed assets transaction; otherwise, false.
    /// </returns>
    public boolean isFixedAssetsTransaction()
    {
        if (this.AccountType == LedgerJournalACType::FixedAssets ||
            this.OffsetAccountType == LedgerJournalACType::FixedAssets)
        {
            // This is a fixed assets transaction.
            return true;
        }

        // This is not a fixed assets transaction.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInterCompanySupportedByTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if intercompany is supported by the account type or offset account type.
    /// </summary>
    /// <returns>
    /// true if intercompany is supported; otherwise, false.
    /// </returns>
    private boolean isInterCompanySupportedByTransType()
    {
        boolean ok = true;

        if (this.isProjectTransaction() && (this.isCompanyIntercompany() || this.isOffsetCompanyIntercompany()))
        {
            ok = checkFailed(strFmt("@SYS75337", "@SYS80304"));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>iso20022EndToEndId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ISO20022 end to end identifier as composed value from voucher, separator and last symbols of
    /// the recId value for the current record.
    /// </summary>
    /// <returns>
    /// The identifier value.
    /// </returns>
    #define.MaxLength(35)
    #define.Separator('-')
    public str iso20022EndToEndId()
    {
        int         separatorLength = strLen(#Separator);
        int         voucherLength = strLen(this.Voucher);
        str         res;

        res   = int642str(this.RecId);

        res   = this.Voucher + #Separator +
                substr(
                    res,
                    strLen(res),
                    voucherLength + separatorLength - #MaxLength);

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankDepositVoucherSplit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see whether the line is part of a split entry and if deposit slip is set to true.
    /// </summary>
    /// <returns>True if deposit slip is checked and if this is a split entry; otherwise, false.</returns>
    public boolean isBankDepositVoucherSplit()
    {
        return (this.AccountType == LedgerJournalACType::Ledger
                || this.AccountType == LedgerJournalACType::Cust)
            && this.OffsetAccountType == LedgerJournalACType::Bank
            && this.BankDepositVoucher
            && !this.OffsetLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOffsetCompanyIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks to see whether the offset company account is intercompany.
    /// </summary>
    /// <param name="_currentCompany">
    ///    The current company; optional.
    /// </param>
    /// <returns>
    ///    true if the offset company is entered and differs from the current company; otherwise, false.
    /// </returns>
    public boolean isOffsetCompanyIntercompany(DataAreaId _currentCompany = curext())
    {
        return (this.OffsetCompany &&
                this.OffsetCompany != _currentCompany &&
                isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOffsetTaxable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the primary account type is taxable.
    /// </summary>
    /// <returns>
    /// true if the primary account type is taxable; otherwise, false.
    /// </returns>
    public boolean isOffsetTaxable()
    {
        LedgerJournalTaxDocument ledgerJournalTaxDocument;
        LedgerJournalTaxLine ledgerJournalTaxLine;

        ledgerJournalTaxDocument = LedgerJournalTaxDocument::construct(this.JournalNum, this.Voucher, this.Invoice, this);
        ledgerJournalTaxLine = ledgerJournalTaxDocument.getLineByLedgerJournalTrans(this, ledgerJournalTaxDocument.getTaxOnPrepayment()) as LedgerJournalTaxLine;

        return ledgerJournalTaxLine.isOffsetBeingCalculated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrimaryTaxable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the primary account type is taxable.
    /// </summary>
    /// <returns>
    /// true if the primary account type is taxable; otherwise, false.
    /// </returns>
    public boolean isPrimaryTaxable()
    {
        LedgerJournalTaxDocument ledgerJournalTaxDocument;
        LedgerJournalTaxLine ledgerJournalTaxLine;

        ledgerJournalTaxDocument = LedgerJournalTaxDocument::construct(this.JournalNum, this.Voucher, this.Invoice, this);
        ledgerJournalTaxLine = ledgerJournalTaxDocument.getLineByLedgerJournalTrans(this, ledgerJournalTaxDocument.getTaxOnPrepayment()) as LedgerJournalTaxLine;

        return ledgerJournalTaxLine.isPrimaryBeingCalculated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustVendLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether this journal line contains customer or vendor account.
    /// </summary>
    /// <returns>
    /// true if there is a customer or vendor account; otherwise, false.
    /// </returns>
    internal boolean isCustVendLine()
    {
        return this.AccountType == LedgerJournalACType::Cust
                || this.AccountType == LedgerJournalACType::Vend
                || this.OffsetAccountType == LedgerJournalACType::Cust
                || this.OffsetAccountType == LedgerJournalACType::Vend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether this journal line contains vendor account.
    /// </summary>
    /// <returns>
    /// true if there is a vendor account; otherwise, false.
    /// </returns>
    internal boolean isVendLine()
    {
        return this.AccountType == LedgerJournalACType::Vend
                || this.OffsetAccountType == LedgerJournalACType::Vend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjectTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether this is a project transaction.
    /// </summary>
    /// <returns>
    /// true if this is a project transaction; otherwise, false.
    /// </returns>
    public boolean isProjectTransaction()
    {
        if (this.AccountType == LedgerJournalACType::Project ||
            this.OffsetAccountType == LedgerJournalACType::Project)
        {
            // This is a project transaction.
            return true;
        }

        // This is not a project transaction.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorTransaction</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsolete.', false, 03\11\2022)]
    public boolean isVendorTransaction()
    {
        LedgerJournalType journalType = this.ledgerJournalTable().JournalType;

        if ((this.AccountType == LedgerJournalACType::Vend || this.OffsetAccountType == LedgerJournalACType::Vend)
            &&
            (journalType == LedgerJournalType::VendInvoiceRegister || journalType == LedgerJournalType::PurchaseLedger))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSEPAPaymentRejected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the SEPA payment is rejected.
    /// </summary>
    /// <param name = "_custPaymModeTable">
    /// The <c>CustPaymModeTable</c> table buffer.
    /// </param>
    /// <param name = "_ledgerJournalTrans_orig">
    /// The <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <returns>
    /// Returns true if the SEPA payment is rejected; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean isSEPAPaymentRejected(CustPaymModeTable _custPaymModeTable = CustPaymModeTable::find(this.PaymMode), LedgerJournalTrans _ledgerJournalTrans_orig = this.orig())
    {
        boolean result = false;

        if (_custPaymModeTable.IsSEPA &&
            (_ledgerJournalTrans_orig.PaymentStatus == CustVendPaymStatus::Sent ||
            _ledgerJournalTrans_orig.PaymentStatus  == CustVendPaymStatus::Confirmed ||
            _ledgerJournalTrans_orig.PaymentStatus  == CustVendPaymStatus::Recieved) &&
            (this.PaymentStatus == CustVendPaymStatus::Rejected ||
            this.PaymentStatus == CustVendPaymStatus::None))
        {
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTax1099DetailTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether this is a 1099 transaction that requires Tax1099Details.
    /// </summary>
    /// <returns>
    /// true if this is a 1099 transaction; otherwise, false .
    /// </returns>
    public boolean isTax1099DetailTransaction()
    {
        Tax1099Box  tax1099Box = Tax1099Fields::find(this.Tax1099Fields).Tax1099Box;

        if (tax1099Box == Tax1099G::unemploymentCompensation().tax1099Box || tax1099Box == Tax1099G::incomeTaxRefundsCreditsOffsets().tax1099Box || tax1099Box == Tax1099S::grossProceeds().tax1099Box)
        {
            // This is a 1099 transaction.
            return true;
        }
        // This is not a 1099 transaction.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks to see whether tax should be calculated for the journal line.
    /// </summary>
    /// <returns>
    ///    true if tax should be calculated for the journal line; otherwise, false.
    /// </returns>
    public boolean isTaxable()
    {
        #ISOCountryRegionCodes
        boolean ret;

        boolean countryRegion_RU    = SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]);
        boolean countryRegion_IN    = SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoIN ]);
        TaxItemGroupHeading taxItemGroupHeadingPOT;
        boolean isCashModuleEnabled = RCashParameters::isCashModuleEnabled();

        boolean accountTypeIsTaxable()
        {
            return (this.AccountType    == LedgerJournalACType::Ledger  ||
                    this.AccountType    == LedgerJournalACType::Project ||
                    this.AccountType    == LedgerJournalACType::FixedAssets ||
                    (countryRegion_RU
                        && (this.AccountType    == LedgerJournalACType::FixedAssets_RU
                            || this.AccountType == LedgerJournalACType::RDeferrals)));
        }

        boolean offsetAccountTypeIsTaxable()
        {
            return (this.OffsetLedgerDimension &&
                    (this.OffsetAccountType  == LedgerJournalACType::Ledger  ||
                     this.OffsetAccountType  == LedgerJournalACType::Project ||
                     this.OffsetAccountType  == LedgerJournalACType::FixedAssets ||
                     (countryRegion_RU
                        && (this.OffsetAccountType    == LedgerJournalACType::FixedAssets_RU
                            || this.OffsetAccountType == LedgerJournalACType::RDeferrals))));
        }

        boolean prePaymentIsTaxAble(
            LedgerJournalACType _accountType = this.AccountType
        )
        {
            switch (_accountType)
            {
                case LedgerJournalACType::Cust:
                    return this.Prepayment && CustParameters::find().TaxOnPrepayment;

                case LedgerJournalACType::Vend:
                    return this.Prepayment && (VendParameters::find().TaxOnPrepayment || this.isVatTaxAgentPrepayment_RU());
            }
            return false;
        }
        if (countryRegion_IN)
        {
            taxItemGroupHeadingPOT = TaxItemGroupHeading::find(this.TaxItemGroup);
        }
        ret = this.amount() != 0;

        ret = ret && this.isTaxCalculationNeeded();
        if (ret
            && countryRegion_IN
            && this.isServiceTax_IN())
        {
            ret = LedgerJournalTrans_IN_Extension::existsAdvancePaymentForServiceTax_IN(this);
        }
        else
        {
            ret = ret && (accountTypeIsTaxable() || offsetAccountTypeIsTaxable() || prePaymentIsTaxAble());
        }
        // As per new POT change, Vendor payment on Legacy POT has no tax associated. Legacy POT is identified by ZERO reverse charge %.
        if (ret
            && this.isPaymentJournal_IN()
            && (this.AccountType == LedgerJournalACType::Vend
                || this.OffsetAccountType == LedgerJournalACType::Vend)
            && taxItemGroupHeadingPOT.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
            && taxItemGroupHeadingPOT.ReverseChargePercentage_IN == 0)
        {
            ret = false;
        }

        if (isCashModuleEnabled
            && this.AccountType == LedgerJournalACType::RCash
            && !ret)
        {
            ret = prePaymentIsTaxAble(this.OffsetAccountType);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxIntegrationEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether tax integration is enabled, and current journal type is supported.
    /// </summary>
    /// <returns>true if tax integration is enabled and support current journal type; otherwise, false.</returns>
    internal boolean isTaxIntegrationEnabled()
    {
        return this.ledgerJournalTable().isTaxIntegrationEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxCalculationNeeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether tax calculation is needed for this journal line.
    /// </summary>
    /// <param name = "_isTaxIntegrationEnabled">Is tax integration enabled for this journal type.</param>
    /// <returns>true if tax should be calculated; otherwise, false.</returns>
    internal boolean isTaxCalculationNeeded(boolean _isTaxIntegrationEnabled = this.isTaxIntegrationEnabled())
    {
        return (this.TaxGroup && this.TaxItemGroup)
            || this.TaxCode
            || _isTaxIntegrationEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransferred</Name>
				<Source><![CDATA[
    public display boolean isTransferred()
    {
        LedgerJournalTrans  transferredTrans;

        if (this.RecId)
        {
            select firstonly RecId from transferredTrans
                index PoolRecId
                where transferredTrans.PoolRecId == this.RecId;
        }

        return transferredTrans.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransIntercompany</Name>
				<Source><![CDATA[
    public boolean isTransIntercompany(DataAreaId _currentCompany = curext())
    {
        return (this.isCompanyIntercompany(_currentCompany) || this.isOffsetCompanyIntercompany(_currentCompany));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether this transaction is a vendor payment
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>True if this transaction is a vendor payment</returns>
    public static boolean isVendorPayment(LedgerJournalTrans _ledgerJournalTrans)
    {
        return TaxEngineLedgerJournalTransHeader::determineTaxableDocumentType(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher) == classStr(TaxableDocTypeDefGenJourVendPayment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorInvoice</Name>
				<Source><![CDATA[
    // </GTE>

    /// <summary>
    /// Check whether this transaction is a vendor invoice
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>True if this transaction is a vendor invoice</returns>
    public static boolean isVendorInvoice(LedgerJournalTrans _ledgerJournalTrans)
    {
        return TaxEngineLedgerJournalTransHeader::determineTaxableDocumentType(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher) == classStr(TaxableDocumentTypeDefinitionGeneralJournalVendInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjectInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether this transaction is a project invoice
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>True if this transaction is a project invoice</returns>
    public static boolean isProjectInvoice(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans  ledgerJournalTransProject;

        if (LedgerJournalTrans::isVendorInvoice(_ledgerJournalTrans)
        || LedgerJournalTrans::isCustomerInvoice(_ledgerJournalTrans))
        {
            select firstOnly RecId from ledgerJournalTransProject
                where ledgerJournalTransProject.JournalNum == _ledgerJournalTrans.JournalNum
                    && ledgerJournalTransProject.Voucher == _ledgerJournalTrans.Voucher
                    && (ledgerJournalTransProject.AccountType == LedgerJournalACType::Project
                        || ledgerJournalTransProject.OffsetAccountType == LedgerJournalACType::Project);

            if (ledgerJournalTransProject.RecId)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustomerInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether this transaction is a customer invoice.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>True if this transaction is a customer invoice.</returns>
    public static boolean isCustomerInvoice(LedgerJournalTrans _ledgerJournalTrans)
    {
        return TaxEngineLedgerJournalTransHeader::determineTaxableDocumentType(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher) == classStr(TaxableDocumentTypeDefinitionGeneralJournalCustInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustomerPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether this transaction is a customer payment.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>True if this transaction is a customer payment.</returns>
    public static boolean isCustomerPayment(LedgerJournalTrans _ledgerJournalTrans)
    {
        return TaxEngineLedgerJournalTransHeader::determineTaxableDocumentType(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher) == classStr(TaxableDocumentTypeDefinitionGeneralJournalCustPayment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustomerPaymentByAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether this transaction is a customer payment.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>true if this transaction is a customer payment; otherwise, false.</returns>
    public static boolean isCustomerPaymentByAccounts(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean isCustTransaction;
        LedgerJournalTrans ledgerJournalTransDiff;

        isCustTransaction = _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust;
        if (!isCustTransaction && !_ledgerJournalTrans.OffsetLedgerDimension)
        {
            select firstonly RecId from ledgerJournalTransDiff
                where ledgerJournalTransDiff.Voucher == _ledgerJournalTrans.Voucher
                    && ledgerJournalTransDiff.JournalNum == _ledgerJournalTrans.JournalNum
                    && ledgerJournalTransDiff.RecId != _ledgerJournalTrans.RecId
                    && ledgerJournalTransDiff.AccountType == LedgerJournalACType::Cust
                    && ledgerJournalTransDiff.OffsetLedgerDimension == 0;
            if (ledgerJournalTransDiff.RecId)
            {
                isCustTransaction = true;
            }
        }

        boolean isPayment;
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
        {
            LedgerDimensionAccount ledgerDimension = _ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger ? _ledgerJournalTrans.LedgerDimension : _ledgerJournalTrans.OffsetLedgerDimension;

            if (MainAccount::findByLedgerDimension(ledgerDimension).PostingType == LedgerPostingType::SalesCash)
            {
                isPayment = true;
            }
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
        {
            isPayment = true;
        }

        if (!isPayment && !_ledgerJournalTrans.OffsetLedgerDimension)
        {
            select firstonly RecId from ledgerJournalTransDiff
                where ledgerJournalTransDiff.Voucher == _ledgerJournalTrans.Voucher
                    &&  ledgerJournalTransDiff.JournalNum == _ledgerJournalTrans.JournalNum
                    &&  ledgerJournalTransDiff.RecId != _ledgerJournalTrans.RecId
                    &&  ledgerJournalTransDiff.AccountType == LedgerJournalACType::Bank
                    &&  ledgerJournalTransDiff.OffsetLedgerDimension == 0;
            if (ledgerJournalTransDiff.RecId)
            {
                isPayment = true;
            }

            MainAccount mainAccount;
            DimensionAttributeValueCombination dimensionAttributeValueCombination;

            select firstonly RecId from ledgerJournalTransDiff
                where ledgerJournalTransDiff.Voucher == _ledgerJournalTrans.Voucher
                    &&  ledgerJournalTransDiff.JournalNum == _ledgerJournalTrans.JournalNum
                    &&  ledgerJournalTransDiff.RecId != _ledgerJournalTrans.RecId
                    &&  ledgerJournalTransDiff.AccountType == LedgerJournalACType::Ledger
                    &&  ledgerJournalTransDiff.OffsetLedgerDimension == 0
                join RecId from dimensionAttributeValueCombination
                    where dimensionAttributeValueCombination.RecId == ledgerJournalTransDiff.LedgerDimension
                    join RecId from mainAccount
                        where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                            && mainAccount.PostingType == LedgerPostingType::SalesCash;
            if (ledgerJournalTransDiff.RecId)
            {
                isPayment = true;
            }
        }

        return isCustTransaction && isPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGeneralInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether this transaction is a general invoice
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>True if this transaction is a general invoice</returns>
    public static boolean isGeneralInvoice(LedgerJournalTrans _ledgerJournalTrans)
    {
        return TaxEngineLedgerJournalTransHeader::determineTaxableDocumentType(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher) == classStr(TaxableDocumentTypeDefinition);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the journal record that is the parent of this <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <returns>
    /// The <c>LedgerJournalTable</c> record that is the parent of this record.
    /// </returns>
    public LedgerJournalTable ledgerJournalTable()
    {
        #ISOCountryRegionCodes
        LedgerJournalTable ledgerJournalTable;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL])
            && this.isTmp())
        {
            ledgerJournalTable = CustVendPrepaymentHandling_W::ledgerJournalTable();
        }
        else
        {
            changecompany (this.company())
            {
                ledgerJournalTable = LedgerJournalTable::find(this.JournalNum);
            }
        }
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>listCodeAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the list code field is available.
    /// </summary>
    /// <returns>
    /// true if the list code is available; otherwise, false.
    /// </returns>
    public boolean listCodeAllowed()
    {
        return (this.AccountType == LedgerJournalACType::Cust
            || (this.AccountType == LedgerJournalACType::Vend && IntrastatParameters::find().euSalesListTransferPurchases));
    }

]]></Source>
			</Method>
			<Method>
				<Name>markAsApprovedByCurrentUser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the journal line as approved by the current user.
    /// </summary>
    public void markAsApprovedByCurrentUser()
    {
        this.Approved = NoYes::Yes;
        this.Approver = HcmWorker::userId2Worker(curUserId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>markedForSettlementError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the journal line has withholding tax, and if so checks if the total settled amount is the same as journal line amount.
    /// </summary>
    /// <returns>
    /// Returns true if the journal line amount of withholding tax matches the total settled amount; otherwise, false.
    /// </returns>
    protected boolean markedForSettlementError()
    {
        boolean                     ret = true;
        AmountCur                   totalSettleAmountForSpecReference;
        LedgerJournalTransPayment_BR payment_BR;
        SpecTrans specTrans;
        boolean isGetTotalSettleAmount = false;

        if (this.RecId != 0)
        {
            select firstonly RecId from specTrans
                where specTrans.SpecCompany == this.company()
                    && specTrans.SpecTableId == this.TableId
                    && specTrans.SpecRecId == this.RecId;
        }

        // The settlement amount is always in the opposite sign of the LedgerJournalTrans amount.
        // For example, if an Accounts Payable payment journal has debit balance of 100 (+100), it
        // would settle some invoices of credit balance (-100).
        if ((specTrans
            || (this.AccountType == LedgerJournalACType::Vend
                 && this.OffsetAccountType == LedgerJournalACType::Bank)) &&
            // <GBR>
            (!BrazilParameters::isEnabled() || this.TaxWithholdCalculate_TH) &&
            // </GBR>
            this.TaxWithholdGroup)
        {
            isGetTotalSettleAmount = true;
            totalSettleAmountForSpecReference = SpecTransManager::getTotalSettleAmountForSpecReference(this.company(),
                                                                                                this.TableId,
                                                                                                this.RecId,
                                                                                                this.CurrencyCode,
                                                                                                this.Company,
                                                                                                this.TransDate,
                                                                                                this.crossrate());

            if (this.amount() != -totalSettleAmountForSpecReference)
            {
                ret = checkFailed("@SYS99308");
            }
        }

        if (ret &&
            BrazilParameters::isEnabled())
        {
            payment_BR = this.getPaymentExtension_BR();
            if (payment_BR.FineAmountCur_BR != 0 || payment_BR.FinInterestAmountCur_BR != 0)
            {
                if (!isGetTotalSettleAmount)
                {
                    totalSettleAmountForSpecReference = SpecTransManager::getTotalSettleAmountForSpecReference(this.company(),
                                                                                                    this.TableId,
                                                                                                    this.RecId,
                                                                                                    this.CurrencyCode,
                                                                                                    this.Company,
                                                                                                    this.TransDate,
                                                                                                    this.crossrate());
                }

                if (this.amount() != -totalSettleAmountForSpecReference)
                {
                    ret = checkFailed("@GLS60592");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markedForSettlementMaxDueDate</Name>
				<Source><![CDATA[
    public DueDate markedForSettlementMaxDueDate()
    {
        SpecTrans           specTransFieldList;
        CustTransOpen       custTransOpen;
        VendTransOpen       vendTransOpen;
        DueDate             dueDate = dateNull();

        if (this.AccountType == LedgerJournalACType::Cust || this.OffsetAccountType == LedgerJournalACType::Cust)
        {
            while select crossCompany DueDate, TransDate from custTransOpen
            join RecId from specTransFieldList
                where specTransFieldList.RefTableId     == custTransOpen.TableId
                  &&  specTransFieldList.RefRecId       == custTransOpen.RecId
                  &&  specTransFieldList.RefCompany     == custTransOpen.DataAreaId
                  &&  specTransFieldList.SpecTableId    == this.TableId
                  &&  specTransFieldList.SpecRecId      == this.RecId
                  &&  specTransFieldList.SpecCompany    == this.company()

            {
                if (dueDate == dateNull())
                {
                    dueDate = custTransOpen.DueDate ? custTransOpen.DueDate : custTransOpen.TransDate;
                }
                else
                {
                    if (dueDate < (custTransOpen.DueDate ? custTransOpen.DueDate : custTransOpen.TransDate))
                    {
                        dueDate = custTransOpen.DueDate ? custTransOpen.DueDate : custTransOpen.TransDate;
                    }
                }
            }
        }
        else
        {
            if (this.AccountType == LedgerJournalACType::Vend || this.OffsetAccountType == LedgerJournalACType::Vend)
            {
                while select crossCompany DueDate, TransDate from vendTransOpen
                join RecId from specTransFieldList
                    where specTransFieldList.RefTableId     == vendTransOpen.TableId
                       && specTransFieldList.RefRecId       == vendTransOpen.RecId
                       && specTransFieldList.RefCompany     == vendTransOpen.DataAreaId
                       && specTransFieldList.SpecTableId    == this.TableId
                       && specTransFieldList.SpecRecId      == this.RecId
                       && specTransFieldList.SpecCompany    == this.company()
                {
                    if (dueDate == dateNull())
                    {
                        dueDate = vendTransOpen.DueDate ? vendTransOpen.DueDate : vendTransOpen.TransDate;
                    }
                    else
                    {
                        if (dueDate < (vendTransOpen.DueDate ? vendTransOpen.DueDate : vendTransOpen.TransDate))
                        {
                            dueDate = vendTransOpen.DueDate ? vendTransOpen.DueDate : vendTransOpen.TransDate;
                        }
                    }
                }
            }
        }
        return dueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markedForSettlementWarning</Name>
				<Source><![CDATA[
    private boolean markedForSettlementWarning()
    {
        boolean                     ret = true;
        AmountCur                   totalSettleAmountForSpecReference;

        if (!this.isFormDataSource())
        {
            return ret;
        }

        if (SpecTrans::getSpecTransCount(this.company(), this.TableId, this.RecId) > 0)
        {
            totalSettleAmountForSpecReference = SpecTransManager::getTotalSettleAmountForSpecReference(this.company(),
                                                                                                    this.TableId,
                                                                                                    this.RecId,
                                                                                                    this.CurrencyCode,
                                                                                                    this.Company,
                                                                                                    this.TransDate,
                                                                                                    this.crossrate());

            // The settlement amount is always in the opposite sign of the LedgerJournalTrans amount.
            // For example, if an Accounts Payable payment journal has debit balance of 100 (+100), it
            // would settle some invoices of credit balance (-100).
            if (this.amount() != -totalSettleAmountForSpecReference)
            {
                if (Box::okCancel("@SYS59380", DialogButton::Cancel,'') == DialogButton::Cancel)
                {
                    ret = false;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markedForSettlementWarnMixedDueDate</Name>
				<Source><![CDATA[
    public void markedForSettlementWarnMixedDueDate()
    {
        SpecTrans           specTransFieldList;
        CustVendTransOpen   custVendTransOpenFieldList;
        CustTransOpen       custTransOpenFieldList;
        VendTransOpen       vendTransOpenFieldList;
        CustVendTrans       custVendTransFieldList;
        CustTrans           custTransFieldList;
        VendTrans           vendTransFieldList;
        DueDate             dueDate               = dateNull();
        boolean             warningIssuedDueDate  = false;

        if (!LedgerJournalName::isNegotiableInstrumentJournal(this.ledgerJournalTable().JournalType))
        {
            return;
        }

        if (this.AccountType == LedgerJournalACType::Cust)
        {
            custVendTransOpenFieldList = custTransOpenFieldList;
            custVendTransFieldList     = custTransFieldList;
        }
        else
        {
            custVendTransOpenFieldList = vendTransOpenFieldList;
            custVendTransFieldList     = vendTransFieldList;
        }

        while select crossCompany RecId from specTransFieldList
            where specTransFieldList.SpecCompany    == this.DataAreaId
               && specTransFieldList.SpecTableId    == this.TableId
               && specTransFieldList.SpecRecId      == this.RecId
        join DueDate from custVendTransOpenFieldList
            where custVendTransOpenFieldList.DataAreaId == specTransFieldList.RefCompany
               && custVendTransOpenFieldList.TableId    == specTransFieldList.RefTableId
               && custVendTransOpenFieldList.RecId      == specTransFieldList.RefRecId
        join RecId from custVendTransFieldList
            where custVendTransFieldList.RecId      == custVendTransOpenFieldList.RefRecId
               && custVendTransFieldList.AccountNum == custVendTransOpenFieldList.AccountNum
        {
            if (!warningIssuedDueDate                   &&
                dueDate != dateNull()                   &&
                dueDate != custVendTransOpenFieldList.DueDate)
            {
                warningIssuedDueDate = !checkFailed("@SYS73746");
            }
            dueDate = max(dueDate, custVendTransOpenFieldList.DueDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the currency code for the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <returns>
    /// The currency code of the <c>LedgerJournalTrans</c> record.
    /// </returns>
    public display CurrencyCode mcrCurrencyCode()
    {
        return this.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrIsDeduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>LedgerJournalTrans</c> table.
    /// </summary>
    /// <returns>
    /// true if this <c>LedgerJournalTrans</c> record is a deduction.; Otherwise, false
    /// </returns>
    /// <remarks>
    /// Only customer payment journal lines may have deductions.  There are many other journal lines that will be related
    /// to deductions (for matching, write-offs etc.) but these are not considered to "be" a
    /// deduction.  A journal line is a deduction when it is used to short pay invoices.
    /// See TAMDeduction table method ledgerJournalTransParent for more relation of deduction and
    /// LedgerJournalTrans.
    /// </remarks>
    public boolean mcrIsDeduction()
    {
        LedgerJournalTrans  ledgerJournalTrans;
        TAMDeduction        tamDeduction;
        boolean             isDeduction;

        if (this.AccountType        == LedgerJournalACType::Cust
            && this.TransactionType == LedgerTransType::Payment
            && this.RecId)
        {
            // Find parent journal line of deduction that has this record as its LedgerJournalTrans
            // Deduction has parent RecId as index.
            select firstonly RecId from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == this.JournalNum
                join TableId from tamDeduction
                    where ledgerJournalTrans.RecId == tamDeduction.LedgerJournalTransParentRecId
                       && tamDeduction.LedgerJournalTransRecId == this.RecId;
            if (ledgerJournalTrans.RecId)
            {
                isDeduction = true;
            }
        }
        return isDeduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrIsDeductionParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>TAMDeduction</c> table.
    /// </summary>
    /// <returns>
    /// true if this <c>LedgerJournalTrans</c> record is parent of at least one deduction (a
    /// deduction is being added to the payment); Otherwise, false
    /// </returns>
    /// <remarks>
    /// See TAMDeduction table method ledgerJournalTransParent for more on the parent relationship.
    /// </remarks>
    public boolean mcrIsDeductionParent()
    {
        TAMDeduction    tamDeduction;
        boolean         hasDeduction;

        if (this.AccountType        == LedgerJournalACType::Cust
            && this.TransactionType == LedgerTransType::Payment
            && this.RecId)
        {
            select firstonly RecId from tamDeduction
                where tamDeduction.LedgerJournalTransParentRecId == this.RecId;

            if (tamDeduction.RecId)
            {
                hasDeduction = true;
            }
        }
        return hasDeduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrUpdateRelatedPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the related payment record if one exists.
    /// </summary>
    /// <param name="_fieldId">
    /// ID of the field being modified.
    /// </param>
    /// <remarks>
    /// Called from the modifiedField method.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Validation failure when updating the <c>MCRCustPaymTable</c> record.
    /// </exception>
    private void mcrUpdateRelatedPayment(FieldId _fieldId)
    {
        MCRCustPaymTable mcrCustPaymTable;
        CustAccount      custAccount;

        if (this.RecId
            && this.AccountType == LedgerJournalACType::Cust
            && isConfigurationkeyEnabled(configurationKeyNum(MCRPayment)))
        {
            mcrCustPaymTable = MCRCustPaymTable::findByRefRecIDRefTableID(this.RecId,
                                                                          this.TableId,
                                                                          true);
            if (mcrCustPaymTable)
            {
                ttsbegin;

                switch (_fieldId)
                {
                    case fieldNum(LedgerJournalTrans, AmountCurDebit):
                    case fieldNum(LedgerJournalTrans, AmountCurCredit):
                        mcrCustPaymTable.Amount = this.AmountCurCredit ? this.AmountCurCredit : -this.AmountCurDebit;
                        break;
                    case fieldNum(LedgerJournalTrans, CurrencyCode):
                        if (this.CurrencyCode != mcrCustPaymTable.CurrencyCode)
                        {
                            mcrCustPaymTable.CurrencyCode = this.CurrencyCode;
                        }
                        break;
                    case fieldNum(LedgerJournalTrans, LedgerDimension):
                        custAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(this.LedgerDimension);
                        if (custAccount != mcrCustPaymTable.CustAccount)
                        {
                            mcrCustPaymTable.CustAccount = custAccount;
                        }
                        break;
                }
                if (mcrCustPaymTable.validateWrite())
                {
                    mcrCustPaymTable.update();
                }
                else
                {
                    throw error("@SYS104318");
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a dimension set that holds the merged combination of the current <c>defaultDimension</c>
    /// field on this table and the provided dimension set.
    /// </summary>
    /// <param name="_primaryDefaultDimension">
    /// A first dimension set to merge with the current <c>defaultDimension</c> field on this table.
    /// </param>
    /// <param name="_secondaryDefaultDimension">
    /// A second dimension set to merge with the current <c>defaultDimension</c> field on this table;
    /// optional.
    /// </param>
    /// <param name="_dimensionMerge">
    /// A <c>dimensionMerge</c> object that was previously instantiated with the current buffer; optional.
    /// </param>
    /// <returns>
    /// A dimension set that holds the merged combination of the current <c>defaultDimension</c> field on
    /// this table and the provided dimension set.
    /// </returns>
    /// <remarks>
    /// This method makes sure that potential linked dimensions are not overwritten when merging.
    /// Additionally, the entity specifier defaulting will be considered.
    /// </remarks>

    public DimensionDefault mergeDimension(
        DimensionDefault _primaryDefaultDimension,
        DimensionDefault _secondaryDefaultDimension = 0,
        DimensionMerge   _dimensionMerge = DimensionMerge::newFromTable(this,
                                                                        this.companyInfo().RecId
                                                                        )
        )
    {
        return _dimensionMerge.merge(_primaryDefaultDimension, _secondaryDefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId)
    {
        #ISOCountryRegionCodes
        boolean             countryRegion_RU    = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean             countryRegion_IN    = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        LedgerJournalTxt    ledgerJournalTxt;
        ProjJournalTxt      projJournalTxt;
        LedgerJournalEngine ledgerJournalEngine = LedgerJournalEngine::construct(this.ledgerJournalTable().JournalType);

        super(_fieldId);

        switch (_fieldId)
        {
            // General fields
            case fieldNum(LedgerJournalTrans, AccountType):
                ledgerJournalEngine.accountTypeModified(this);
                this.updateCustVendBankAccount(true);
                this.LedgerDimensionName = '';

                break;

            case fieldNum(LedgerJournalTrans, OffsetAccountType):
                ledgerJournalEngine.offsetAccountTypeModified(this);
                break;

            case fieldNum(LedgerJournalTrans, LedgerDimension):
                ledgerJournalEngine.accountNumModified(this);
                this.updateCustVendBankAccount();
                this.mcrUpdateRelatedPayment(_fieldId);
                if (TaxIntegrationUtils::isTaxInformationEnabled())
                {
                    if (this.AccountType == LedgerJournalACType::Cust && this.orig().LedgerDimension != 0)
                    {
                        CustTable custTable = CustTable::find(this.parmAccount());

                        TransTaxInformation transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(this);
                        if (transTaxInformation)
                        {
                            ttsbegin;
                            transTaxInformation.selectForUpdate(true);
                            transTaxInformation.CustomerLocation = 0;
                            TransTaxInformationHelper::initFromCustVend(transTaxInformation, custTable);
                            transTaxInformation.update();
                            ttscommit;
                        }
                    }
                    else if (this.AccountType == LedgerJournalACType::Vend && this.orig().LedgerDimension != 0)
                    {
                        VendTable vendTable = VendTable::find(this.parmAccount());

                        TransTaxInformation transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(this);
                        if (transTaxInformation)
                        {
                            ttsbegin;
                            transTaxInformation.selectForUpdate(true);
                            TransTaxInformationHelper::initFromCustVend(transTaxInformation, vendTable);
                            transTaxInformation.update();
                            ttscommit;
                        }
                    }
                    else if (this.TransactionType == LedgerTransType::Fee && this.AccountType == LedgerJournalACType::Ledger && this.OffsetAccountType == LedgerJournalACType::Bank)
                    {
                        BankAccountTable bankAccountTable = BankAccountTable::find(this.parmOffsetAccount());

                        TransTaxInformation transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(this);
                        if (transTaxInformation)
                        {
                            ttsbegin;
                            transTaxInformation.selectForUpdate(true);
                            TransTaxInformationHelper::initDefaultBankTaxInformation(transTaxInformation, bankAccountTable);
                            transTaxInformation.update();
                            ttscommit;
                        }
                    }
                }

                this.LedgerDimensionName = LedgerJournalTransLedgerDimensionNameHelper::findName(this.Company, this.AccountType, this.LedgerDimension);

                break;

            case fieldNum(LedgerJournalTrans, OffsetLedgerDimension):
                ledgerJournalEngine.offsetAccountModified(this);

                if (TaxWithholdParameters_IN::checkTaxParameters() && this.ledgerJournalTable().JournalType == LedgerJournalType::Cost)
                {
                    this.initTDSAndTCSByCustVendAccount(this.OffsetLedgerDimension, this.OffsetAccountType);
                }
                break;

            case fieldNum(LedgerJournalTrans, Company):
                this.LedgerDimension = 0;
                this.TaxGroup           = '';
                this.TaxItemGroup       = '';
                this.DefaultDimension = 0;
                this.updateCustVendBankAccount(true);
                this.LedgerDimensionName = '';

                if (TaxIntegrationUtils::isTaxInformationEnabled())
                {
                    TransTaxInformationHelper::newHelper().UpdateCompanyLocationFromTransTable(this, LogisticsPostalAddress::findByLocation(TransTaxInformationHelper::getDefaultCompanyLocation(this.Company ? this.Company : curext())).RecId);
                }
                if (countryRegion_RU)
                {
                    this.AgreementCompany_RU = this.Company;

                    this.setAgreementEmptyValues_RU(AccountOffsetaccount::Account);
                }
                break;

            case fieldNum(LedgerJournalTrans, OffsetCompany):
                this.OffsetLedgerDimension = 0;
                this.OffsetDefaultDimension = 0;
                if (countryRegion_RU)
                {
                    this.OffsetAgreementCompany_RU = this.OffsetCompany;

                    this.setAgreementEmptyValues_RU(AccountOffsetaccount::OffsetAccount);
                }
                break;

            case fieldNum(LedgerJournalTrans, AgreementCompany_RU):
                this.setAgreementEmptyValues_RU(AccountOffsetaccount::Account);
                break;

            case fieldNum(LedgerJournalTrans, OffsetAgreementCompany_RU):
                this.setAgreementEmptyValues_RU(AccountOffsetaccount::OffsetAccount);
                break;

            case fieldNum(LedgerJournalTrans, Txt):
                if (this.AccountType == LedgerJournalACType::Project)
                {
                    projJournalTxt = ProjJournalTxt::findTxt(this.Txt);
                }
                else
                {
                    ledgerJournalTxt = LedgerJournalTxt::findTxt(this.Txt);
                }

                if (projJournalTxt.Txt)
                {
                    this.Txt = projJournalTxt.Txt;
                }

                if (ledgerJournalTxt.Txt)
                {
                    this.Txt = ledgerJournalTxt.Txt;
                }

                if (BrazilParameters::isEnabled())
                {
                    this.formatTransactionText_BR();
                }

                break;

            case fieldNum(LedgerJournalTrans, OffsetTxt):
                if (this.OffsetAccountType == LedgerJournalACType::Project)
                {
                    projJournalTxt = ProjJournalTxt::findTxt(this.OffsetTxt);
                }
                else
                {
                    ledgerJournalTxt = LedgerJournalTxt::findTxt(this.OffsetTxt);
                }

                if (projJournalTxt.Txt)
                {
                    this.OffsetTxt = projJournalTxt.Txt;
                }

                if (ledgerJournalTxt.Txt)
                {
                    this.OffsetTxt = ledgerJournalTxt.Txt;
                }
                break;

            case fieldNum(LedgerJournalTrans, AmountCurDebit):
                if (countryRegion_IN)
                {
                    this.setAssessableValue_IN();
                }

                if (BrazilParameters::isEnabled())
                {
                    this.setInterestAndFine_BR(_fieldId);
                }

                ledgerJournalEngine.amountCurDebitModified(this);

                this.mcrUpdateRelatedPayment(_fieldId);
                break;

            case fieldNum(LedgerJournalTrans, AmountCurCredit):
                if (countryRegion_IN)
                {
                    this.setAssessableValue_IN();
                }

                if (BrazilParameters::isEnabled())
                {
                    this.setInterestAndFine_BR(_fieldId);
                }

                ledgerJournalEngine.amountCurCreditModified(this);

                this.mcrUpdateRelatedPayment(_fieldId);
                break;

            case fieldNum(LedgerJournalTrans, TransDate) :
                this.AcknowledgementDate = this.TransDate;
                break;

            case fieldNum(LedgerJournalTrans, ReverseEntry):
                if (!this.ReverseEntry)
                {
                    this.ReverseDate = dateNull();
                }
                break;

            case fieldNum(LedgerJournalTrans, Approver):
                if (this.Approver == 0)
                {
                    this.InvoiceReleaseDate = utcDateTimeNull();
                    this.ReleaseDateComment = '';
                }
                break;

            case fieldNum(LedgerJournalTrans, RemittanceLocation) :
                this.RemittanceAddress = LogisticsPostalAddress::addressRecIdFromLocationRecId(this.RemittanceLocation);
                break;

            // Customer/vendor fields
            case fieldNum(LedgerJournalTrans, PaymMode):
                this.paymModeModified();
                if (BrazilParameters::isEnabled())
                {
                    this.setEPRemitInfo_BR();
                }
                break;

            case fieldNum(LedgerJournalTrans, PaymSpec):
                this.paymSpecModified();
                break;

            case fieldNum(LedgerJournalTrans, Prepayment):
                ledgerJournalEngine.prepaymentModified(this);
                break;

            case fieldNum(LedgerJournalTrans, Invoice):
                ledgerJournalEngine.invoiceModified(this);
                break;

            case fieldNum(LedgerJournalTrans, BankDepositVoucher):
                ledgerJournalEngine.bankDepositVoucherModified(this);
                break;

            case fieldNum(LedgerJournalTrans, PaymentStatus):
                if (this.isSEPAPaymentRejected())
                {
                    this.cancelMandateLogRecord();
                }
                break;

            // Banking fields
            case fieldNum(LedgerJournalTrans, BankCentralBankPurposeCode):
                this.BankCentralBankPurposeText = BankCentralBankPurpose::find(this.BankCentralBankPurposeCode).Text;
                break;

            case fieldNum(LedgerJournalTrans, CustVendBankAccountId):
                this.updateCustVendBankAccount();
                break;
            // <GEERU>
            case fieldNum(LedgerJournalTrans, rCashDocRepresType):
                if (RCashParameters::isCashModuleEnabled())
                {
                    this.rCashDocRepresPersonId = '';
                    this.setRepresPersonValues_W();
                }
                break;
            case fieldNum(LedgerJournalTrans, RCashDocRepresPersonId):
                if (RCashParameters::isCashModuleEnabled())
                {
                    this.setRepresPersonValues_W();
                }
                break;
            // </GEERU>
            case fieldNum(LedgerJournalTrans, CurrencyCode):
                this.mcrUpdateRelatedPayment(_fieldId);
                break;
            case fieldNum(LedgerJournalTrans, InvoiceSeries_MX):
                if (this.InvoiceSeries_MX != '')
                {
                    this.CFDIUUID_MX = '';
                }
                break;
            case fieldNum(LedgerJournalTrans, CFDIUUID_MX):
                if (this.CFDIUUID_MX != '')
                {
                    this.InvoiceSeries_MX = '';
                }
                break;
            case fieldNum(LedgerJournalTrans,CashDiscBaseDate):
                ledgerJournalEngine.cashDiscBaseDateModified(this);
                break;
            case fieldNum(LedgerJournalTrans,TaxGroup):
                ledgerJournalEngine.taxGroupModified(this);
                break;
            case fieldNum(LedgerJournalTrans,TaxItemGroup):
                ledgerJournalEngine.taxGroupModified(this);
                break;
            case fieldNum(LedgerJournalTrans, ExchRate),
                 fieldNum(LedgerJournalTrans, ReportingCurrencyExchRate):
                ledgerJournalEngine.exchRateModified(this);
                break;
            case fieldNum(LedgerJournalTrans, BridgingBankAccount):
                this.bridgingBankAccountModified();
                break;
        }

        if (this.modifiedFieldRemovesAccruals(_fieldId))
        {
            this.removeAccruals();
        }

        if (!(VatDueDateFeature::isEnabled() && _fieldId == fieldNum(LedgerJournalTrans, VatDueDate_W)))
        {
            this.modifyVatDueDate_W();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldRemovesAccruals</Name>
				<Source><![CDATA[
    public boolean modifiedFieldRemovesAccruals(
        FieldId _fieldId)
    {
        switch (_fieldId)
        {
            case fieldNum(LedgerJournalTrans, Company),
                 fieldNum(LedgerJournalTrans, AccountType),
                 fieldNum(LedgerJournalTrans, LedgerDimension),
                 fieldNum(LedgerJournalTrans, OffsetCompany),
                 fieldNum(LedgerJournalTrans, OffsetAccountType),
                 fieldNum(LedgerJournalTrans, OffsetLedgerDimension),
                 fieldNum(LedgerJournalTrans, AmountCurDebit),
                 fieldNum(LedgerJournalTrans, AmountCurCredit):

                return true;

            case fieldNum(LedgerJournalTrans, TaxGroup),
                  fieldNum(LedgerJournalTrans, TaxItemGroup):

                if (this.TaxGroup     != this.orig().TaxGroup ||
                    this.TaxItemGroup != this.orig().TaxItemGroup)
                {
                    return true;
                }

            default :
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the field value.
    /// </summary>
    /// <param name="_fieldName">
    /// The field name.
    /// </param>
    /// <param name="_arrayIndex">
    /// The array index.
    /// </param>
    public void modifiedFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        super(_fieldName, _arrayIndex);
    }

]]></Source>
			</Method>
			<Method>
				<Name>negotiableInstrumentPostInsert</Name>
				<Source><![CDATA[
    private void negotiableInstrumentPostInsert()
    {
        switch (this.ledgerJournalTable().JournalType)
        {
            case LedgerJournalType::CustBillOfExchangeDraw:
                CustBillOfExchangeJour::setLedgerJournalTransRecId(this.NegInstId, this.RecId);
                break;

            case LedgerJournalType::VendPromissoryNoteDraw:
                VendPromissoryNoteJour::setLedgerJournalTransRecId(this.NegInstId, this.RecId);
                break;

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>negotiableInstrumentPreInsert</Name>
				<Source><![CDATA[
    private void negotiableInstrumentPreInsert()
    {
        switch (this.ledgerJournalTable().JournalType)
        {
            case LedgerJournalType::CustBillOfExchangeDraw:
                this.NegInstId = CustBillOfExchangeJour::createNewBillOfExhange(this.parmAccount(),CustVendNegInstStatus::None,this.Due).BillOfExchangeId;
                break;

            case LedgerJournalType::VendPromissoryNoteDraw:
                this.NegInstId = VendPromissoryNoteJour::createNewPromissoryNote(this.parmAccount(),CustVendNegInstStatus::None,this.Due).PromissoryNoteId;
                break;

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>negotiableInstrumentUpdate</Name>
				<Source><![CDATA[
    private void negotiableInstrumentUpdate()
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            switch (this.ledgerJournalTable().JournalType)
            {
                case LedgerJournalType::CustBillOfExchangeDraw:
                    break;

                case LedgerJournalType::VendPromissoryNoteDraw:
                    break;

                default:
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountName</Name>
				<Source><![CDATA[
    public display LedgerJournalOffsetAccountName offsetAccountName()
    {
        if (this.OffsetLedgerDimension)
        {
            if (!this.OffsetCompany)
            {
                return this.accountNameFind(this.OffsetAccountType, this.OffsetLedgerDimension, curext());
            }
            else
            {
                return this.accountNameFind(this.OffsetAccountType, this.OffsetLedgerDimension, this.OffsetCompany);
            }
        }

        return "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>packExtensionTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs a <c>SysExtensionSerializerExtensionMap</c> extension table's buffer inside the
    /// record's internal cache.
    /// </summary>
    /// <param name="_sysExtensionSerializerExtensionTableMap">
    /// The <c>SysExtensionSerializerExtensionMap</c> map to be packed.
    /// </param>
    /// <returns>
    /// A value that indicates whether the pack was successful.
    /// </returns>
    public boolean packExtensionTable(SysExtensionSerializerExtensionMap _sysExtensionSerializerExtensionTableMap)
    {
        return this.SysExtensionSerializerMap::packExtensionTable(_sysExtensionSerializerExtensionTableMap.data());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccount</Name>
				<Source><![CDATA[
    public LedgerJournalAC parmAccount(LedgerJournalAC _account = '', LedgerJournalACType _accountType = this.AccountType, SelectableDataArea _currentCompany = this.Company)
    {
        LedgerJournalAC                     account;

        if (!prmisDefault(_accountType))
        {
            this.AccountType = _accountType;
        }
        if (!prmisDefault(_currentCompany))
        {
            this.Company = _currentCompany;
        }

        // If company has not been specified, use the current company
        if (!_currentCompany || !xDataArea::exist(_currentCompany))
        {
            _currentCompany = curext();
        }

        changecompany(_currentCompany)
        {
            // If account has been changed, update the backing ledger dimension value
            if (!prmisDefault(_account))
            {
                if (_account)
                {
                    this.LedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_account, _accountType);
                    account = _account;
                }
                else
                {
                    account = '';
                    this.LedgerDimension = 0;
                }
            }
            else if (this.LedgerDimension)
            {
                // If the account has not been changed, then pull the value from ledger dimension as the master
                account = LedgerDimensionFacade::getDisplayValueForLedgerDimension(this.LedgerDimension);
            }
        }

        return account;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank account ID.
    /// </summary>
    /// <returns>
    /// The bank account ID.
    /// </returns>
    public CompanyBankAccountId parmBankAccount()
    {
        CompanyBankAccountId bankAccount;

        BankBridgingTrans bankBridgingTrans = BankBridgingTrans::findByBridgedLedgerJournalTransRecId(this.RecId);
        if (bankBridgingTrans)
        {
            return bankBridgingTrans.AccountId;
        }

        if (this.AccountType == LedgerJournalACType::Bank)
        {
            bankAccount = this.parmAccount();
        }
        else if (this.OffsetAccountType == LedgerJournalACType::Bank)
        {
            bankAccount = this.parmOffsetAccount();
        }

        return bankAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankCurrencyAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank currency amount.
    /// </summary>
    /// <returns>
    /// The bank currency amount.
    /// </returns>
    public AmountCur parmBankCurrencyAmount()
    {
        return this.BankCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankDocumentBookType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the bank document type.
    /// </summary>
    /// <returns>
    /// The bank document type.
    /// </returns>
    public BankDocumentBookType parmBankDocumentBookType()
    {
        BankDocumentBookType bankDocumentBookType = BankDocumentBookType::None;

        if ((this.OffsetAccountType     == LedgerJournalACType::Bank
                &&  this.AccountType    == LedgerJournalACType::Cust)
            || (this.OffsetAccountType  == LedgerJournalACType::Cust
                &&  this.AccountType    == LedgerJournalACType::Bank))
        {
            if (this.BankDepositNum == ''
                && this.BankDepositVoucher == NoYes::No
                && this.BankChequeNum == '')
            {
                bankDocumentBookType = BankDocumentBookType::CustPayment;
            }
        }
        else if ((this.OffsetAccountType    == LedgerJournalACType::Bank
                    &&  this.AccountType    == LedgerJournalACType::Vend)
                || (this.OffsetAccountType   == LedgerJournalACType::Vend
                    &&  this.AccountType    == LedgerJournalACType::Bank))
        {
            if (this.BankDepositNum == ''
                && this.BankDepositVoucher == NoYes::No
                && this.BankChequeNum == '')
            {
                bankDocumentBookType = BankDocumentBookType::VendPayment;
            }
        }
        else if (this.BridgingBankAccount != ''
            && this.OffsetAccountType == LedgerJournalACType::Ledger
            && this.BankDepositNum == ''
            && this.BankDepositVoucher == NoYes::No
            && this.BankChequeNum == '')
        {
            bankDocumentBookType = BankDocumentBookType::BankClearing;
        }

        return bankDocumentBookType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault parmDefaultDimension(DimensionDefault  _defaultDimension = this.DefaultDimension)
    {
        if (!prmisDefault(_defaultDimension))
        {
            this.DefaultDimension = _defaultDimension;
        }

        return this.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimension</Name>
				<Source><![CDATA[
    public DimensionDynamicAccount parmLedgerDimension(LedgerDimensionAccount _ledgerDimension = this.LedgerDimension, SelectableDataArea _currentCompany = this.Company)
    {
        if (!prmisDefault(_currentCompany))
        {
            this.Company = _currentCompany;
        }

        if (!prmisDefault(_ledgerDimension))
        {
            this.LedgerDimension = _ledgerDimension;
        }

        return this.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOffsetAccount</Name>
				<Source><![CDATA[
    public LedgerJournalAC parmOffsetAccount(LedgerJournalAC _offsetAccount = '', LedgerJournalACType _offsetAccountType = this.OffsetAccountType, SelectableDataArea _offsetCompany = this.getOffsetCompany())
    {
        DimensionAttributeValueCombination  ledgerDimension;
        LedgerJournalAC                     offsetAccount;

        if (!prmisDefault(_offsetAccountType))
        {
            this.OffsetAccountType = _offsetAccountType;
        }
        if (!prmisDefault(_offsetCompany))
        {
            this.OffsetCompany = _offsetCompany;
        }

        // If offset company has not been specified, use the current company
        if (!_offsetCompany || !xDataArea::exist(_offsetCompany))
        {
            _offsetCompany = curext();
        }

        changecompany(_offsetCompany)
        {
            // If account has been changed, update the backing ledger dimension value
            if (!prmisDefault(_offsetAccount))
            {
                if (_offsetAccount)
                {
                    this.OffsetLedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_offsetAccount, _offsetAccountType);
                    offsetAccount = _offsetAccount;
                }
                else
                {
                    offsetAccount = '';
                    this.OffsetLedgerDimension = 0;
                }
            }
            else if (this.OffsetLedgerDimension)
            {
                // If the account has not been changed, then pull the value from ledger dimension as the master
                select firstonly DisplayValue from ledgerDimension
                    where ledgerDimension.RecId == this.OffsetLedgerDimension;

                offsetAccount = ledgerDimension.DisplayValue;
            }
        }

        return offsetAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOffsetDefaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault parmOffsetDefaultDimension(DimensionDefault  _offsetDefaultDimension = this.OffsetDefaultDimension)
    {
        if (!prmisDefault(_offsetDefaultDimension))
        {
            this.OffsetDefaultDimension = _offsetDefaultDimension;
        }

        return this.OffsetDefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOffsetLedgerDimension</Name>
				<Source><![CDATA[
    public DimensionDynamicAccount parmOffsetLedgerDimension(
        LedgerDimensionAccount _offsetLedgerDimension = this.OffsetLedgerDimension,
        SelectableDataArea _currentCompany = this.getOffsetCompany())
    {
        if (!prmisDefault(_currentCompany))
        {
            this.OffsetCompany = _currentCompany;
        }

        if (!prmisDefault(_offsetLedgerDimension))
        {
            this.OffsetLedgerDimension = _offsetLedgerDimension;
        }

        return this.OffsetLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bridgingBankAccountModified</Name>
				<Source><![CDATA[
    private void bridgingBankAccountModified()
    {
        LedgerDimensionDefaultAccount bridgingAccount;
        if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()))
        {
            if (!this.BridgingBankAccount)
            {
                warning("@CashManagement:BankAccountEmptyError");
            }
            else
            {
                bridgingAccount = BankAccountTable::findBridgingAccount(this.BridgingBankAccount);
                if (!bridgingAccount)
                {
                    warning("@CashManagement:BridgingAccountEmptyError");
                }
            }

            this.setOffsetLedgerDimension(
                this.ledgerJournalTable(),
                LedgerJournalACType::Ledger,
                this.getOffsetLedgerDimensionForLedgerType(bridgingAccount, this.getOffsetCompany()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBridgingBankAccount</Name>
				<Source><![CDATA[
    internal boolean checkBridgingBankAccount()
    {
        if (!FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()) || !BankAccountBridgingPostingHelper::isCustOrVendPayment(this.ledgerJournalTable().JournalType))
        {
            return true;
        }

        CustVendPaymModeTable paymModeTable = CustVendPaymModeTable::findCommon(this);

        if (paymModeTable && paymModeTable.BridgingAccountByBank)
        {
            if (!this.BridgingBankAccount)
            {
                return checkFailed("@CashManagement:BankAccountEmptyError");
            }
            else
            {
                LedgerDimensionDefaultAccount bridgingAccount = BankAccountTable::findBridgingAccount(this.BridgingBankAccount);

                if (!bridgingAccount)
                {
                    return checkFailed("@CashManagement:BridgingAccountEmptyError");
                }
                else if (LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(this.OffsetLedgerDimension) != bridgingAccount)
                {
                    return checkFailed("@CashManagement:BridgingAccountOffsetAccountNotAlignError");
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymModeModified</Name>
				<Source><![CDATA[
    public void paymModeModified()
    {
        #ISOCountryRegionCodes
        LedgerJournalTable ledgerJournalTable = this.ledgerJournalTable();
        CustVendPaymModeTable custVendPaymModeTable;

        // Setting the offset account according to the payment mode if appropriate
        if (this.Invoice == '')
        {
            switch (ledgerJournalTable.JournalType)
            {
                case LedgerJournalType::PurchaseLedger,
                    LedgerJournalType::VendInvoiceRegister,
                    LedgerJournalType::CustBillOfExchangeAccept,
                    LedgerJournalType::CustBillOfExchangeDraw,
                    LedgerJournalType::CustBillOfExchangeProtest,
                    LedgerJournalType::CustPaymRemittance,
                    LedgerJournalType::CustBillOfExchangeRedraw,
                    LedgerJournalType::VendPromissoryNoteDraw,
                    LedgerJournalType::VendPromissoryNoteRedraw,
                    LedgerJournalType::VendPaymRemittance:
                    break;

                case LedgerJournalType::Payment:
                    if (this.PaymMode != '')
                    {
                        changecompany(this.company())
                        {
                            custVendPaymModeTable = VendPaymModeTable::find(this.PaymMode);

                            if (!custVendPaymModeTable)
                            {
                                this.PaymMode = '';
                            }
                        }
                    }
                    else
                    {
                        this.OffsetAccountType = LedgerJournalACType::Ledger;
                        this.OffsetLedgerDimension = 0;
                    }
                    break;

                case LedgerJournalType::CustPayment:
                    if (this.PaymMode != '')
                    {
                        changecompany(this.company())
                        {
                            custVendPaymModeTable = CustPaymModeTable::find(this.PaymMode);

                            if (!custVendPaymModeTable)
                            {
                                this.PaymMode = '';
                            }
                        }
                    }
                    else
                    {
                        this.OffsetAccountType = LedgerJournalACType::Ledger;
                        this.OffsetLedgerDimension = 0;
                    }
                    break;

                default:
                    if (this.PaymMode != '')
                    {
                        changecompany(this.company())
                        {
                            custVendPaymModeTable = CustVendPaymModeTable::findCommon(this);

                            if (!custVendPaymModeTable)
                            {
                                this.PaymMode = '';
                            }
                        }
                    }
                    else
                    {
                        this.OffsetAccountType = LedgerJournalACType::Ledger;
                        this.OffsetLedgerDimension = 0;
                    }
                    break;
            }
        }

        if (custVendPaymModeTable)
        {
            // Do not add as part of previous if; just do not want to update accounts if
            // line has a related payment record.
            if (!MCROrderParameters::isCallCenterEnabledAndInUse()
                || !MCRCustPaymTable::findByRefRecIDRefTableID(this.RecId, this.TableId))
            {
                if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()) && custVendPaymModeTable.FurtherPosting)
                {
                    this.BankDepositVoucher = NoYes::No;
                }

                if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()) && custVendPaymModeTable.BridgingAccountByBank)
                {
                    BankAccountTable bankAccountTable = BankAccountTable::find(custVendPaymModeTable.parmPaymAccount());

                    this.BridgingBankAccount = bankAccountTable.AccountID;
                    this.bridgingBankAccountModified();
                }
                else
                {
                    this.BridgingBankAccount = '';
                    
                    DimensionDynamicDefaultAccount custVendOffsetLedgerDimension = custVendPaymModeTable.offsetLedgerDimension();

                    if (custVendOffsetLedgerDimension)
                    {
                        LedgerJournalACType accountType = custVendPaymModeTable.paymACType();

                        if (accountType == LedgerJournalACType::Ledger)
                        {
                            changecompany(this.company())
                            {
                                this.setOffsetLedgerDimension(
                                    ledgerJournalTable,
                                    accountType,
                                    this.getOffsetLedgerDimensionForLedgerType(
                                        custVendOffsetLedgerDimension,
                                        this.getOffsetCompany()));
                            }

                            this.BankClientDocumentTypeId_RU = custVendPaymModeTable.BankClientDocumentTypeId_RU;
                        }
                        else
                        {
                            this.setOffsetLedgerDimension(ledgerJournalTable,
                                accountType,
                                custVendOffsetLedgerDimension);
                        }
                    }
                }

                this.BankTransType = custVendPaymModeTable.BankTransType;

                boolean enableLedgerJournalTrans_W = LedgerJournalTrans_W::isLegalEntitySupported();

                if ((ledgerJournalTable.JournalType == LedgerJournalType::Payment || ledgerJournalTable.JournalType == LedgerJournalType::CustPayment)
                    && enableLedgerJournalTrans_W)
                {
                    LedgerJournalTrans_W ledgerJournalTrans_W = this.ledgerJournalTrans_W();

                    if (PaymentFormatCodeSets_W::isISO20022Country())
                    {
                        if (ledgerJournalTrans_W)
                        {
                            ttsbegin;
                            changecompany(ledgerJournalTrans_W.DataAreaId)
                            {
                                ledgerJournalTrans_W.selectForUpdate(true);
                                ledgerJournalTrans_W.initFromLedgerJournalTable_W();
                                ledgerJournalTrans_W.initFromPaymModeTable_generic(custVendPaymModeTable);
                                ledgerJournalTrans_W.update();
                            }
                            this.packExtensionTable(ledgerJournalTrans_W);
                            ttscommit;
                        }
                        else
                        {
                            ledgerJournalTrans_W.initFromLedgerJournalTable_W();
                            ledgerJournalTrans_W.initFromPaymModeTable_generic(custVendPaymModeTable);
                        }
                    }
                    else
                    {
                        ledgerJournalTrans_W.clearPaymentFormatCodes();
                    }
                }
            }
        }
        else
        {
            this.BridgingBankAccount = '';
        }

        if (!this.OffsetLedgerDimension
            && this.getOffsetCompany() == ledgerJournalTable.company())
        {
            if (ledgerJournalTable.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                // if type is ledger need to create ledger account structure by merging the main
                // account and the dimensions for the main account
                this.setOffsetLedgerDimension(ledgerJournalTable,
                    ledgerJournalTable.OffsetAccountType,
                    this.getOffsetLedgerDimensionForLedgerType(
                        ledgerJournalTable.parmOffsetLedgerDimension(),
                        this.getOffsetCompany()));
            }
            else
            {
                this.setOffsetLedgerDimension(ledgerJournalTable,
                    ledgerJournalTable.OffsetAccountType,
                    ledgerJournalTable.parmOffsetLedgerDimension());
            }
        }

        this.PaymModeMap::modifiedPaymMode(); // Set specification
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymSpecModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes payment codes from defaults when payment specification modified.
    /// </summary>
    public void paymSpecModified()
    {
        LedgerJournalTrans_W ledgerJournalTrans_W = this.ledgerJournalTrans_W();

        if (PaymentFormatCodeSets_W::isISO20022Country())
        {
            CustVendPaymModeTable custVendPaymModeTable = CustVendPaymModeTable::findCommon(this);

            CustVendPaymModeSpec custVendpaymModeSpec = CustVendPaymModeSpec::findCommon(this);

            ttsbegin;
            if (PaymFixMissingInitLedgerJournalTransWFlight::instance().isEnabled())
            {
                changecompany(ledgerJournalTrans_W.DataAreaId)
                {
                    ledgerJournalTrans_W.selectForUpdate(true);
                    ledgerJournalTrans_W.initFromLedgerJournalTable_W();
                    ledgerJournalTrans_W.initFromPaymSpec_generic(custVendPaymModeSpec);
                    ledgerJournalTrans_W.initFromPaymModeTable_generic(custVendPaymModeTable);
                    if (ledgerJournalTrans_W)
                    {
                        ledgerJournalTrans_W.update();
                    }
                }
                this.packLedgerJournalTrans_W(ledgerJournalTrans_W);
            }
            else
            {
                if (ledgerJournalTrans_W)
                {
                    changecompany(ledgerJournalTrans_W.DataAreaId)
                    {
                        ledgerJournalTrans_W.selectForUpdate(true);
                        ledgerJournalTrans_W.initFromLedgerJournalTable_W();
                        ledgerJournalTrans_W.initFromPaymSpec_generic(custVendPaymModeSpec);
                        ledgerJournalTrans_W.initFromPaymModeTable_generic(custVendPaymModeTable);
                        ledgerJournalTrans_W.update();
                    }
                    this.packLedgerJournalTrans_W(ledgerJournalTrans_W);
                }
            }
            ttscommit;
        }
        else
        {
            ledgerJournalTrans_W.clearPaymentFormatCodes();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymStatusModified</Name>
				<Source><![CDATA[
    public void paymStatusModified(TransDate _approvalDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        CustBillOfExchangeJour  custBillOfExchangeJour;
        VendPromissoryNoteJour  vendPromissoryNoteJour;
        SpecTrans               specTransFieldList;
        LedgerJournalType       ledgerJournalType   = this.ledgerJournalTable().JournalType;

        switch (ledgerJournalType)
        {
            case LedgerJournalType::CustBillOfExchangeDraw,
                 LedgerJournalType::CustBillOfExchangeRedraw,
                 LedgerJournalType::CustPaymRemittance:
                ttsbegin;

                while select firstonly crossCompany specTransFieldList
                    where specTransFieldList.SpecRecId == this.RecId
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecCompany == this.company()
                {
                    while select firstonly forupdate custBillOfExchangeJour
                        where custBillOfExchangeJour.BillOfExchangeId == specTransFieldList.custTrans().BillOfExchangeID ||
                            custBillOfExchangeJour.BillOfExchangeId == this.NegInstId
                    {
                        custBillOfExchangeJour.ApprovalDate = _approvalDate;
                        custBillOfExchangeJour.update();
                    }
                }
                ttscommit;
                break;

            case LedgerJournalType::VendPromissoryNoteDraw,
                LedgerJournalType::VendPromissoryNoteRedraw,
                LedgerJournalType::VendPaymRemittance:
                ttsbegin;
                while select firstonly crossCompany specTransFieldList
                    where specTransFieldList.SpecRecId == this.RecId
                        && specTransFieldList.SpecTableId == this.TableId
                        && specTransFieldList.SpecCompany == this.company()
                {
                    while select firstonly forupdate vendPromissoryNoteJour
                    where   vendPromissoryNoteJour.PromissoryNoteId == specTransFieldList.vendTrans().PromissoryNoteID ||
                            vendPromissoryNoteJour.PromissoryNoteId == this.NegInstId
                    {
                        vendPromissoryNoteJour.ApprovalDate = _approvalDate;
                        vendPromissoryNoteJour.update();
                    }
                }
                ttscommit;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCalcAmt</Name>
				<Source><![CDATA[
    public void pdsCalcAmt(boolean _credit, Amount _amount)
    {
        if (#PdsRebateEnabled)
        {
            if (_credit)
            {
                if (_amount > 0)
                {
                    this.AmountCurCredit    = _amount;
                    this.AmountCurDebit     = 0;
                }
                else
                {
                    this.AmountCurDebit     = -_amount;
                    this.AmountCurCredit    = 0;
                }
            }
            else
            {
                if (_amount > 0)
                {
                    this.AmountCurCredit    = 0;
                    this.AmountCurDebit     = _amount;
                }
                else
                {
                    this.AmountCurDebit     = 0;
                    this.AmountCurCredit    = -_amount;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPaymentBankDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes payment type bank document from this table.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    /// An exception is thrown when status is not consistent with its bank document.
    /// </exception>
    private void processPaymentBankDocument()
    {
        BankDocument            bankDocument;

        if (this.isBankDocumentPaymentProcessNeeded())
        {
            switch (this.PaymentStatus)
            {
                case CustVendPaymStatus::Sent:
                    if (BankAccountTable::find(this.parmBankAccount()).isBankStatementUsedAsPaymentConfirmation())
                    {
                        BankDocumentTable bankDocumentTable;
                        // For reverse reconcile, bankDocumentTable exists, should not call this.calculateBankCurrencyAmount() and BankDocumentProcessor::submitBankDocumentTable
                        bankDocumentTable = BankDocumentTable::findBySource(tableNum(LedgerJournalTrans), this.RecId);

                        if (!bankDocumentTable.RecId)
                        {
                            //create electronic payment bank document
                            if (!this.parmBankCurrencyAmount())
                            {
                                this.calculateBankCurrencyAmount();
                            }
                            BankDocumentProcessor::submitBankDocumentTable(this);
                        }
                    }
                    break;

                case CustVendPaymStatus::Recieved:
                    bankDocument = BankDocument::construct(this);
                    if (bankDocument)
                    {
                        if (!bankDocument.getIsReconciled())
                        {
                            // Not allow user updates Recieved status manually if related document is not reconciled.
                            throw error("@GLS221741");
                        }
                    }
                    break;

                default:
                    // Delete related existing bank document.
                    this.clearBankCurrencyAmount();
                    BankDocumentProcessor::deleteBankDocument(this.TableId, this.RecId);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchOffsetLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount purchOffsetLedgerDimension()
    {
        return this.findVendTable().purchOffsetLedgerDimension(this.PostingProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAccruals</Name>
				<Source><![CDATA[
    public void removeAccruals(boolean _skipWarning = false)
    {
        LedgerJournalTransAccrual   ledgerJournalTransAccrual;

        ttsbegin;

        ledgerJournalTransAccrual = LedgerJournalTransAccrual::find(this.TableId, this.RecId, true);

        if (ledgerJournalTransAccrual)
        {
            ledgerJournalTransAccrual.delete();
            if (!_skipWarning)
            {
                warning("@SYS78328");
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the budget amounts for the current <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <remarks>
    /// The ledger accounts actual expenditure amounts on the current record are removed from the budgetary control system.
    /// </remarks>
    public void removeBudget()
    {
        if (this.RecId != 0)
        {
            BudgetControlAccountingJournalProcessor::submitLedgerJournalTransToRemoveBudget(
                this.RecId,
                this.ledgerJournalTable().JournalType,
                this.JournalNum,
                this.company(),
                this.Voucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeBudgetForVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the budget amounts for all the <c>LedgerJournalTrans</c> records that are associated to the
    /// voucher of the current <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <remarks>
    /// The ledger accounts actual expenditure amounts for all the <c>LedgerJournalTrans</c> records that
    /// are associated to the voucher of the current record are removed from the budgetary control system.
    /// </remarks>
    public void removeBudgetForVoucher()
    {
        BudgetControlAccountingJournalProcessor::submitLedgerJournalVoucherToRemoveBudget(
            this.JournalNum,
            this.company(),
            this.Voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reuseCheck</Name>
				<Source><![CDATA[
    public void reuseCheck(LedgerJournalTrans ljtRecord)
    {
        CustVendPaymReconciliationSetStatus custVendPaymReconciliationSetStatus;
        LedgerJournalTrans                  localLedgerJournalTrans;
        FormDataSource                      formDS;

        formDS = FormDataUtil::getFormDataSource(ljtRecord);
        if (formDS)
        {
            custVendPaymReconciliationSetStatus = new CustVendPaymReconciliationSetStatus();
            custVendPaymReconciliationSetStatus.parmStatus(CustVendPaymStatus::None); // args.parmEnum()

            for (localLedgerJournalTrans = getFirstSelection(formDS);
            localLedgerJournalTrans;
            localLedgerJournalTrans = formDS.getNext() as LedgerJournalTrans)
            {
                custVendPaymReconciliationSetStatus.parmRecid(localLedgerJournalTrans.RecId);
            }

            CustVendPaymReconciliationSetStatus::runServerReuseChecks(custVendPaymReconciliationSetStatus.pack());
            formDS.research();
        }
        else
        {
            custVendPaymReconciliationSetStatus = new CustVendPaymReconciliationSetStatus();
            custVendPaymReconciliationSetStatus.parmStatus(CustVendPaymStatus::None);
            custVendPaymReconciliationSetStatus.parmRecid(ljtRecord.RecId);
            CustVendPaymReconciliationSetStatus::runServerReuseChecks(custVendPaymReconciliationSetStatus.pack());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>revertBankAccountTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverts the <c>BankAccountTrans</c> table updates that were made when a bank check or deposit
    /// reversal journal is created.
    /// </summary>
    /// <param name="_ledgerJournalType">
    /// The ledger journal type of the bank check or deposit reversal journal to revert.
    /// </param>
    private void revertBankAccountTrans(LedgerJournalType _ledgerJournalType)
    {
        BankAccountTrans    bankAccountTrans;

        // Find the related bankAccountTrans.
        switch (_ledgerJournalType)
        {
            case LedgerJournalType::BankChequeReversal:
                bankAccountTrans = BankAccountTrans::findByAccountIDAndChequeNum(this.parmOffsetAccount(), this.BankChequeNum, true);
                break;

            case LedgerJournalType::BankDepositPaymCancel:
                bankAccountTrans = BankAccountTrans::findByDepositNum(this.BankDepositNum, true);
                break;
        }

        if (bankAccountTrans.RecId != 0)
        {
            // Revert the CancelPending and remove any related reason code data.
            bankAccountTrans.CancelPending = NoYes::No;
            bankAccountTrans.ReasonRefRecID = 0;

            if (bankAccountTrans.validateWrite())
            {
                bankAccountTrans.write();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>revertBankChequeTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverts the <c>BankChequeTable</c> table updates that were made when a bank check reversal journal
    /// is created.
    /// </summary>
    private void revertBankChequeTable()
    {
        BankChequeTable     bankChequeTable;

        bankChequeTable = BankChequeTable::find(this.parmOffsetAccount(), this.BankChequeNum, true);

        if (bankChequeTable.RecId != 0)
        {
            // Revert the CancelPending and remove any related reason code data.
            if (ChequeStatusIsCancelledWhenDeleteRevJourAfterReversePaymJourFlight::instance().isEnabled()
                && CustTrans::findByVoucher(bankChequeTable.Voucher).CancelledPayment)
            {
                bankChequeTable.ChequeStatus = ChequeStatus::Cancelled;
            }
            else
            {
                bankChequeTable.ChequeStatus = ChequeStatus::Payment;
            }

            bankChequeTable.ReasonRefRecID = 0;
            bankChequeTable.ReversalTableId = 0;
            bankChequeTable.ReversalRecId = 0;

            if (bankChequeTable.validateWrite())
            {
                bankChequeTable.write();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>revertBankDeposit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverts the <c>BankDeposit</c> table updates that were made when a bank deposit slip cancellation
    /// journal is created.
    /// </summary>
    private void revertBankDeposit()
    {
        BankDeposit     bankDeposit;

        bankDeposit = BankDeposit::find(this.BankChequeDepositTransRefRecID, true);

        if (bankDeposit.RecId != 0)
        {
            // Revert the CancelPending and remove any related reason code data.
            bankDeposit.CancelPending = NoYes::No;
            bankDeposit.ReasonRefRecID = 0;
            bankDeposit.ReversalTableId = 0;
            bankDeposit.ReversalRecId = 0;

            if (bankDeposit.validateWrite())
            {
                bankDeposit.write();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendSettlementbuffer</Name>
				<Source><![CDATA[
    private CustVendSettlement setCustVendSettlementbuffer()
    {
        CustSettlement  custSettlement;
        VendSettlement  vendSettlement;

        if (this.AccountType == LedgerJournalACType::Cust)
        {
            return custSettlement;
        }
        else
        {
            return vendSettlement;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendTransOpenbuffer</Name>
				<Source><![CDATA[
    private CustVendTransOpen setCustVendTransOpenbuffer()
    {
        CustTransOpen   custTransOpen;
        VendTransOpen   vendTransOpen;

        if (this.AccountType == LedgerJournalACType::Cust)
        {
            return custTransOpen;
        }
        else
        {
            return vendTransOpen;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultAccount</Name>
				<Source><![CDATA[
    public void setDefaultAccount(
        boolean     _isOffset,
        CustVendAC  _custVendAC)
    {
        VendDefaultAccounts             vendDefaultAccounts;
        LedgerDimensionDefaultAccount   ledgerDimensionDefaultAccount;
        LedgerJournalType               ledgerJournalType = this.ledgerJournalTable().JournalType;
        LedgerDimensionAccount          combinedLedgerDimension;

        if (ledgerJournalType != LedgerJournalType::PurchaseLedger && // diff. from Invoice register
            ledgerJournalType != LedgerJournalType::Payment)
        {
            vendDefaultAccounts = VendDefaultAccounts::findDefault(_custVendAC,  _isOffset ? this.OffsetCompany : this.Company);

            if (vendDefaultAccounts)
            {
                if (_isOffset && this.AccountType == LedgerJournalACType::Ledger && !this.LedgerDimension)
                {
                    this.AccountType    = vendDefaultAccounts.LedgerJournalACType;
                    if (this.AccountType == LedgerJournalACType::Ledger)
                    {
                        // Need to merge ledger dimension account and the default dimensions.
                        ledgerDimensionDefaultAccount = vendDefaultAccounts.parmLedgerDimension();
                        this.LedgerDimension = this.getLedgerDimensionForLedgerType(ledgerDimensionDefaultAccount, this.Company);
                    }
                    else
                    {
                        this.LedgerDimension = vendDefaultAccounts.parmLedgerDimension();
                    }
                    combinedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(this.LedgerDimension, VendTable::find(_custVendAC).DefaultDimension);
                    if (combinedLedgerDimension != 0)
                    {
                        this.LedgerDimension = combinedLedgerDimension;
                    }
                }

                if (!_isOffset && this.OffsetAccountType == LedgerJournalACType::Ledger && !this.OffsetLedgerDimension)
                {
                    this.OffsetAccountType  = vendDefaultAccounts.LedgerJournalACType;
                    if (this.OffsetAccountType == LedgerJournalACType::Ledger)
                    {
                        // Need to merge ledger dimension account and the default dimensions.
                        ledgerDimensionDefaultAccount = vendDefaultAccounts.parmLedgerDimension();
                        this.OffsetLedgerDimension = this.getOffsetLedgerDimensionForLedgerType(ledgerDimensionDefaultAccount, this.getOffsetCompany());
                    }
                    else
                    {
                        this.OffsetLedgerDimension = vendDefaultAccounts.parmLedgerDimension();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOffsetDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes offset default dimension.
    /// </summary>
    /// <returns>Offset default dimension.</returns>
    public LedgerDimensionValueSet initOffsetDefaultDimension()
    {
        if (this.OffsetAccountType != LedgerJournalACType::Ledger)
        {
            var ledgerJournalEngine = LedgerJournalEngine::construct();
            ledgerJournalEngine.initOffsetDefaultDimension(this);
        }
        return this.OffsetDefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the default <c>LedgerDimensionAccount</c> value based on settings.
    /// </summary>
    /// <returns><c>LedgerDimensionAccount</c> value.</returns>
    public LedgerDimensionAccount getOffsetLedgerDimension()
    {
        return LedgerDimensionFacade::serviceCreateLedgerDimension(this.OffsetLedgerDimension, this.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setListCode</Name>
				<Source><![CDATA[
    public void setListCode()
    {
        LogisticsPostalAddress           postalAddress;
        LogisticsAddressCountryRegionId  countryRegionId;
        LogisticsAddressCountryRegionId  offSetCountryRegionId;
        ModuleCustVend                   module;

        module          = this.AccountType == LedgerJournalACType::Cust? ModuleCustVend::Cust : ModuleCustVend::Vend;
        postalAddress   = DirParty::primaryPostalAddress(CustVendTable::findModule(module, this.parmAccount()).Party);
        countryRegionId = postalAddress.CountryRegionId;

        if (IntrastatCountryRegionParameters::isCountryRegionStateInEU(postalAddress))
        {
            if (this.OffsetAccountType == LedgerJournalACType::Cust || this.OffsetAccountType == LedgerJournalACType::Vend)
            {
                module                = this.OffsetAccountType == LedgerJournalACType::Cust? ModuleCustVend::Cust : ModuleCustVend::Vend;
                postalAddress         = DirParty::primaryPostalAddress(CustVendTable::findModule(module,this.parmOffsetAccount()).Party);
                offSetCountryRegionId = postalAddress.CountryRegionId;

                if (countryRegionId != offSetCountryRegionId)
                {
                    this.Listcode  = Listcode::TriangularEUTrade;
                }
                else
                {
                    this.Listcode  = Listcode::EUTrade;
                }
            }
            else
            {
                this.Listcode  = Listcode::EUTrade;
            }
        }
        else
        {
            this.Listcode  = Listcode::IncludeNot;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOffsetLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the offset account type and offset account fields on the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> table.
    /// </param>
    /// <param name="_ledgerJournalACType">
    /// The ledger journal account type.
    /// </param>
    /// <param name="_ledgerJournalAccount">
    /// The ledger journal account number.
    /// </param>
    public void setOffsetLedgerDimension(
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalACType _ledgerJournalACType,
        LedgerDimensionAccount _ledgerJournalAccount)
    {
        if (_ledgerJournalTable.FixedOffsetAccount)
        {
            // The LedgerJournalTable has a fixed offset, so use the values from the LedgerJournalTable to
            // set the offset fields
            this.OffsetAccountType = _ledgerJournalTable.OffsetAccountType;
            if (_ledgerJournalTable.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                // if type is ledger need to create ledger account structure by merging the main
                // account and the dimensions for the main account with the currently entered values
                this.OffsetLedgerDimension =
                    LedgerDimensionFacade::serviceMergeLedgerDimensions(this.OffsetLedgerDimension, this.getOffsetLedgerDimensionForLedgerType(_ledgerJournalTable.parmOffsetLedgerDimension(), this.getOffsetCompany()));
            }
            else
            {
                // if type isn't ledger can just copy the ledgerDimension value
                this.OffsetLedgerDimension = _ledgerJournalTable.parmOffsetLedgerDimension();
            }
        }
        else
        {
            // The LedgerJournalTable offset is not fixed, so use passed in values to set offset
            this.OffsetAccountType = _ledgerJournalACType;
            this.OffsetLedgerDimension = _ledgerJournalAccount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSettleVoucher</Name>
				<Source><![CDATA[
    public void setSettleVoucher()
    {
        if (this.SettleVoucher != SettlementType::SelectedTransact)
        {
            switch (this.AccountType)
            {
                case LedgerJournalACType::Cust:
                    this.SettleVoucher = CustParameters::find().AutoSettle ? SettlementType::OpenTransact : SettlementType::None;
                    break;
                case LedgerJournalACType::Vend:
                    this.SettleVoucher = VendParameters::find().AutoSettle ? SettlementType::OpenTransact : SettlementType::None;
                    break;
                default:
                    switch (this.OffsetAccountType)
                    {
                        case LedgerJournalACType::Cust:
                            this.SettleVoucher = CustParameters::find().AutoSettle ? SettlementType::OpenTransact : SettlementType::None;
                            break;
                        case LedgerJournalACType::Vend:
                            this.SettleVoucher = VendParameters::find().AutoSettle ? SettlementType::OpenTransact : SettlementType::None;
                            break;
                        default:
                            this.SettleVoucher = SettlementType::None;
                    }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettlementType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the settlement type.
    /// </summary>
    /// <returns>
    ///     The settlement type.
    /// </returns>
    protected SettlementType getSettlementType()
    {
        return SettlementType::SelectedTransact;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitPaymentInvoiceSettled</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Splits the settled payment invoice.
    /// </summary>
    /// <param name = "_ledgerJournalEngine">
    ///     A instance of <c>LedgerJournalEngine</c> class.
    /// </param>
    /// <param name = "_transDate">
    ///     The transaction date; optional.
    /// </param>
    public void splitPaymentInvoiceSettled(
        LedgerJournalEngine _ledgerJournalEngine,
        TransDate           _transDate = dateNull())
    {
        SpecTrans               localSpecTrans;
        LedgerJournalTrans      localLedgerJournalTrans = this;
        CustVendSettlement      localSettlement         = this.setCustVendSettlementbuffer();
        boolean                 first                   = true;
        Counter                 idx;
        container               conRecid;
        LineNum                 lastLineNum;
        AmountCur               amountCur;

        ttsbegin;

        // This is called during the Bill of Exchange and Promissory Note processing and will always
        // occur in the context of a single company.  As a result, there is no need to cross
        // company boundaries in the code below.

        //create a ledgerJournalTrans for each specTrans
        while select forupdate localSpecTrans
            where localSpecTrans.SpecTableId    == this.TableId &&
                  localSpecTrans.SpecRecId      == this.RecId &&
                  localSpecTrans.SpecCompany    == this.company()
        {
            // because the first specTrans shall reamin attached to the original ledgerJournalTrans
            select firstonly DueDate, TransDate from localSettlement
                where localSettlement.TableId   == localSpecTrans.RefTableId
                   && localSettlement.RecId     == localSpecTrans.RefRecId
                   && localSettlement.DataAreaId == localSpecTrans.RefCompany;

            localLedgerJournalTrans.Due             = localSettlement.DueDate  ? localSettlement.DueDate : localSettlement.TransDate;
            localLedgerJournalTrans.TransDate       = _transDate != dateNull() ? _transDate              : localLedgerJournalTrans.Due;
            localLedgerJournalTrans.SettleVoucher   = this.getSettlementType();

            if (first)
            {
                lastLineNum = LedgerJournalTrans::lastLineNum(this.JournalNum);
                first       = false;
            }
            else
            {
                // create new LedgerJournalTrans and attach the settlement to it
                lastLineNum++;
                localLedgerJournalTrans.Voucher = LedgerJournalTrans::splitCreateNewVoucher(this.JournalNum);
                localLedgerJournalTrans.LineNum = lastLineNum;
                localLedgerJournalTrans.insert();

                localSpecTrans.SpecRecId = localLedgerJournalTrans.RecId;

                localSpecTrans.update();
            }
            amountCur = CurrencyExchangeHelper::curAmount2CurAmount(localSpecTrans.Balance01, localSpecTrans.Code, localLedgerJournalTrans.CurrencyCode, localLedgerJournalTrans.TransDate);
            if (amountCur < 0)
            {
                localLedgerJournalTrans.AmountCurDebit  = abs(amountCur);
                localLedgerJournalTrans.AmountCurCredit = 0;
            }
            else
            {
                localLedgerJournalTrans.AmountCurCredit = abs(amountCur);
                localLedgerJournalTrans.AmountCurDebit  = 0;
            }
            localLedgerJournalTrans.write();
            conRecid += localLedgerJournalTrans.RecId;
        }
        for (idx = conLen(conRecid);
        idx;
        idx--)
        {
            localLedgerJournalTrans = LedgerJournalTrans::findRecId(conPeek(conRecid,idx), true);
            localLedgerJournalTrans.fillPaymentNotes();
            _ledgerJournalEngine.settleTransUpdate(localLedgerJournalTrans);
            _ledgerJournalEngine.calcPaymentFee(localLedgerJournalTrans);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>swapAccountOffsetAccount</Name>
				<Source><![CDATA[
    public void swapAccountOffsetAccount()
    {
        #ISOCountryRegionCodes
        LedgerJournalTrans  ledgerJournalTransSaveTmp;

        ledgerJournalTransSaveTmp.data(this);
        this.AccountType           = this.OffsetAccountType;
        this.LedgerDimension       = this.OffsetLedgerDimension;

        switch (ledgerJournalTransSaveTmp.ledgerJournalTable().JournalType)
        {
            case LedgerJournalType::VendPromissoryNoteDraw:
                if (ledgerJournalTransSaveTmp.LedgerDimension == this.LedgerDimension)
                {
                    this.DefaultDimension  = ledgerJournalTransSaveTmp.DefaultDimension;
                }
                break;
            case LedgerJournalType::Cost:
                this.DefaultDimension = ledgerJournalTransSaveTmp.DefaultDimension;
                break;
            default:
                this.DefaultDimension      = this.OffsetDefaultDimension;
        }

        this.Company               = this.OffsetCompany ? this.OffsetCompany : this.Company;
        this.Txt                   = this.OffsetTxt ? this.OffsetTxt : this.Txt;
        this.FinTag                = this.OffsetFinTag;
        this.AmountCurDebit        = this.AmountCurCredit;

        this.OffsetAccountType     = ledgerJournalTransSaveTmp.AccountType;
        this.OffsetLedgerDimension = ledgerJournalTransSaveTmp.LedgerDimension;
        this.OffsetDefaultDimension = ledgerJournalTransSaveTmp.DefaultDimension;
        this.OffsetCompany         = ledgerJournalTransSaveTmp.Company;
        this.OffsetTxt             = ledgerJournalTransSaveTmp.Txt;
        this.OffsetFinTag          = ledgerJournalTransSaveTmp.FinTag;
        this.AmountCurCredit       = ledgerJournalTransSaveTmp.AmountCurDebit;
        this.CashDiscAmount        = -this.CashDiscAmount;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
        {
            this.AccountAgreementId_RU       = this.OffsetAccountAgreementId_RU;
            this.OffsetAccountAgreementId_RU = ledgerJournalTransSaveTmp.AccountAgreementId_RU;
        }
        // // <GEERU><GEEU>
        if (this.OffsetPostingProfile_RU && RCashParameters::isCashModuleEnabled())
        {
            this.PostingProfile          = this.OffsetPostingProfile_RU;
            this.OffsetPostingProfile_RU = ledgerJournalTransSaveTmp.PostingProfile;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountJournal</Name>
				<Source><![CDATA[
    public display TaxAmountJournal taxAmountJournal()
    {
        LedgerJournalTable ledgerJournalTable;
        TaxAmountJournal   taxAmountCur = 0;

        ledgerJournalTable= LedgerJournalTable::find(this.JournalNum);

        if (ledgerJournalTable.Posted)
        {
            taxAmountCur = Tax::taxTotalVoucherDateRecId(this.Voucher, this.TransDate, this.RecId);
        }
        else
        {
            taxAmountCur = 0;
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountForInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for an invoice.
    /// </summary>
    /// <param name="_includeActualTax">
    /// Indicates whether the actual tax or the calculated tax is retrieved.
    /// </param>
    /// <param name="_includeUseTax">
    /// Indicates whether the use tax is included in the tax amount.
    /// </param>
    /// <param name="_useTransactionalCurrency">
    /// Indicates whether the tax amount is retrieved in the transaction or accounting currency.
    /// </param>
    /// <returns>
    /// The tax amount for the invoice.
    /// </returns>
    public TaxAmountCur totalTaxAmountForInvoice(boolean _includeActualTax = true, boolean _includeUseTax = false, boolean _useTransactionalCurrency = true)
    {
        LedgerJournalTable ledgerJournalTable;
        TaxCalculation taxCalculation;

        if (!_includeActualTax && !_useTransactionalCurrency)
        {
            Error::wrongUseOfFunction(funcName());
        }

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return 0;
        }

        ledgerJournalTable = this.ledgerJournalTable();

        if (!TaxUncommitted::existByDocumentAndInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher, this.Invoice))
        {
            taxCalculation = LedgerJournalTrans::getTaxInstance(ledgerJournalTable.JournalNum, this.Voucher, this.Invoice, false, this);

            if (_includeActualTax)
            {
                return taxCalculation.totalTaxAmount(_includeUseTax);
            }
            else
            {
                return taxCalculation.totalTaxAmountCalculated(false);
            }
        }

        if (_includeActualTax)
        {
            return TaxUncommitted::getActualTaxAmountForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher, this.Invoice, _includeUseTax);
        }
        else
        {
            return TaxUncommitted::getCalculatedTaxAmountForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher, this.Invoice, _includeUseTax);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountSingleLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for the current line.
    /// </summary>
    /// <param name="_includeActualTax">
    /// Indicates whether the actual tax or calculated tax is retrieved.
    /// </param>
    /// <param name="_includeUseTax">
    /// Indicates whether the use tax is included in the tax amount.
    /// </param>
    /// <param name="_useTransactionalCurrency">
    /// Indicates whether the tax amount is retrieved in the transaction or accounting currency.
    /// </param>
    /// <returns>
    /// The tax amount for the current line.
    /// </returns>
    public TaxAmountCur totalTaxAmountSingleLine(boolean _includeActualTax = true, boolean _includeUseTax = false, boolean _useTransactionalCurrency = true)
    {
        TaxAmountCur            taxAmountCur;

        if (this.isTaxIntegrationEnabled())
        {
            [taxAmountCur] = LedgerJournalTrans::totalTaxAmountSingleLineIL([this, _includeActualTax, _includeUseTax, _useTransactionalCurrency, this.ledgerJournalTransTaxExtension()]);
        }
        else
        {
            [taxAmountCur] = LedgerJournalTrans::totalTaxAmountSingleLineIL([this, _includeActualTax, _includeUseTax, _useTransactionalCurrency]);
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>type</Name>
				<Source><![CDATA[
    private List type()
    {
        return LedgerJournalTransType::construct(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateExchRates</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Recalculate exchange rates based on <c>HuExchOutflowType</c>.
    /// </summary>
    /// <param name = "_original">The journal line record.</param>
    /// <param name = "_exchOutflowtype">Value based on which the values are recalculated.</param>
    protected void recalculateExchRates(LedgerJournalTrans _original, HuExchOutflowType _exchOutflowtype)
    {
        switch (_exchOutflowType)
        {
            case HuExchOutflowType::FIFO :
                if ((this.isCashTransaction_RU() ||
                     _original.isCashTransaction_RU())         &&
                    (
                     this.TransDate    != _original.TransDate                           ||
                     this.CurrencyCode != _original.CurrencyCode                        ||
                     this.amount()     != _original.amount()                            ||
                     ((this.AccountType             == LedgerJournalACType::RCash ||
                       _original.AccountType        == LedgerJournalACType::RCash) &&
                       this.LedgerDimension    != _original.LedgerDimension)                      ||
                     ((this.OffsetAccountType       == LedgerJournalACType::RCash ||
                       _original.OffsetAccountType  == LedgerJournalACType::RCash) &&
                       this.OffsetLedgerDimension != _original.OffsetLedgerDimension)
                    )
                   )
                {
                    this.updateFIFOLineExchRate_HU();
                }
                break;

            case HuExchOutflowType::AverageRate :
                this.calcAverageLinesExchRate_HU();
                break;

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void update()
    {
        #ISOCountryRegionCodes
        #OCCRetryCount

        LedgerJournalTrans              this_orig;
        LedgerJournalTrans_Project      ledgerJournalTrans_Project;
        LedgerJournalTrans_Asset        ledgerJournalTrans_Asset;
        LedgerJournalTrans_RAsset       ledgerJournalTrans_RAsset;
        LedgerJournalTrans_RDeferrals   ledgerJournalTrans_RDeferrals;
        LedgerJournalTrans_RCash        ledgerJournalTrans_RCash;
        boolean                         countryRegion_RU    = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        CustPaymModeTable               custPaymModeTable;
        LedgerJournalTable              ledgerJournalTable;
        boolean                         recalculateTaxes;
        boolean                         checkNACHARecord;
        boolean                         recalculateWithholdTaxes;
        HuExchOutflowType               exchOutflowType;
        boolean                         cashModuleEnabled = RCashParameters::isCashModuleEnabled();

        if (cashModuleEnabled)
        {
            ttsbegin;
        }

        ledgerJournalTable = this.ledgerJournalTable();

        this_orig = this.orig();

        if (! this.CurrencyCode)
        {
            throw error("@SYS23229");
        }

        if (! this.Company)
        {
            this.Company = curext();
        }

        if((this.AccountType == LedgerJournalACType::Project || this.OffsetAccountType == LedgerJournalACType::Project) &&
            ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
        {
            throw error(strFmt("@Proj:ProjProjectOperationFeatureAccountTypeIsNotSupported",
                                  this.Company));
        }

        if (! this.OffsetCompany)
        {
            this.OffsetCompany = curext();
        }

        if (this.Transfer)
        {
            this.TransactionType = LedgerTransType::Transfer;
        }

        if (this.TaxCode)
        {
            this.updateTaxCode();
        }

        if (!this.AcknowledgementDate)
        {
            this.AcknowledgementDate = this.TransDate;
        }

        this.defaultReportingCurrencyExchangeRateIfSameCurrencies();

        custPaymModeTable = CustPaymModeTable::find(this.PaymMode);

        if (this.isSEPAPaymentRejected(custPaymModeTable, this_orig))
        {
            this.cancelMandateLogRecord();
        }

        if ((this.OffsetLedgerDimension != this_orig.OffsetLedgerDimension ||
             this.OffsetAccountType != this_orig.OffsetAccountType ||
             this.PaymReference != this_orig.PaymReference) &&
             CustVendPaymJournalFee::existRefRecId(this.RecId))
        {
            this.updateFeeOffsetAccount();
        }

        if (!VatDueDateFeature::isEnabled())
        {
            this.modifyVatDueDate_W();
        }

        if (this.AccountType != LedgerJournalACType::Vend && this.AccountType != LedgerJournalACType::Cust && this.AccountType != LedgerJournalACType::Project )
        {
            this.CustBankAccount = 0;
            this.VendBankAccount = 0;
            this.CustVendBankAccountId = "";
        }
        else
        {
            if (this.CustVendBankAccountId != "")
            {
                if ((this.CustBankAccount == 0 && this.VendBankAccount == 0)
                    || this.CustVendBankAccountId != this.orig().CustVendBankAccountId)
                {
                    this.updateCustVendBankAccount();
                }
            }
            else
            {
                this.CustBankAccount = 0;
                this.VendBankAccount = 0;
            }
        }

        if (countryRegion_RU)
        {
            this.updateBankPaymentOrderJour_RU();
            this.updatePaymentOrderBudgetTrans_RU();
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL]))
        {
            this.updateCzCustVendAdvanceInvoiceLink();
        }

        // taxes are out of date to delete TaxUncommitted records.
        recalculateTaxes = this.deleteTaxUncommitted(ledgerJournalTable);

        // Remove the journalNum tax cache that was set on \Classes\LedgerJournalTaxDocument\doTaxGroupExistsForDocument,
        // but only if tax data was changed on this buffer since updates to other fields of
        // the buffer would not impact whether or not taxes existed for the journal
        if (this.TaxGroup != this_orig.TaxGroup
            || this.TaxItemGroup != this_orig.TaxItemGroup
            || this.TaxCode != this_orig.TaxCode
            || ledgerJournalTable.isTaxIntegrationEnabled())
        {
            LedgerJournalTaxDocument::clearCachedTaxExistenceCheck(this.JournalNum);
        }

        if (TaxWithholdParameters_IN::checkTaxParameters()
            && (!TaxWithholdNotCalcTaxForInvoicePool_INFlight::instance().isEnabled() || ledgerJournalTable.JournalType != LedgerJournalType::VendInvoicePool))
        {
            recalculateWithholdTaxes = this.deleteTaxWitholdUncommitted_IN(ledgerJournalTable, recalculateTaxes);
        }

        if (this.PaymentStatus != this_orig.PaymentStatus)
        {
            this.processPaymentBankDocument();
        }

        exchOutflowType = RCashParameters::find().ExchOutflowType_HU;
        if (exchOutflowType == HuExchOutflowType::FIFO &&
            (this.isCashTransaction_RU() ||
             this_orig.isCashTransaction_RU())         &&
            (
             this.TransDate    != this_orig.TransDate                           ||
             this.CurrencyCode != this_orig.CurrencyCode                        ||
             this.amount()     != this_orig.amount()                            ||
             ((this.AccountType             == LedgerJournalACType::RCash ||
               this_orig.AccountType        == LedgerJournalACType::RCash) &&
               this.LedgerDimension    != this_orig.LedgerDimension)                      ||
             ((this.OffsetAccountType       == LedgerJournalACType::RCash ||
               this_orig.OffsetAccountType  == LedgerJournalACType::RCash) &&
               this.OffsetLedgerDimension != this_orig.OffsetLedgerDimension)
            )
           )
        {
            this.rollbackFIFOLineExchRate_HU();
        }
        this.updatePaySheetTrans_RU();
        this.SysExtensionSerializerMap::postUpdate();

        if (this.LedgerDimensionName == '')
        {
            this.LedgerDimensionName = LedgerJournalTransLedgerDimensionNameHelper::findName(this.Company, this.AccountType, this.LedgerDimension);
        }

        // <GIN>
        if ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
            && (this.LedgerDimension != this_orig.LedgerDimension
            || this.OffsetLedgerDimension != this_orig.OffsetLedgerDimension
            || this.AccountType != this_orig.AccountType
            || this.OffsetAccountType != this_orig.OffsetAccountType)
           )
        {
            this.updateCustVendLocationAndTaxInformation_IN();
        }
        // </GIN>

        ttsbegin;

        try
        {
            super();
        }
        catch (Exception::DuplicateKeyException)
        {
            if (xSession::currentRetryCount() < #RetryNum)
            {
                this.LineNum = LedgerJournalTrans::lastLineNum(this.JournalNum) + 1;

                // In order to suppress any duplicate key error messages, issue a retry.
                retry;
            }
            else if (LedgerJournalTransThrowDupKeyExcepFlight::instance().isEnabled())
            {
                throw Exception::DuplicateKeyExceptionNotRecovered;
            }
        }

        this.SysExtensionSerializerMap::postUpdate();
        ttscommit;

        this.recalculateExchRates(this_orig, exchOutflowType);

        if (!(this.DelayTaxCalculation
                || ledgerJournalTable.isTaxIntegrationEnabled())
            && (recalculateTaxes
                || !TaxUncommitted::existByDocumentAndInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, this.Voucher, this.Invoice)))
        {
            // if the journal is posted, we don't want to recalculate taxes.
            // For the invoice register, some updates happen prior to the Posted flag gets marked as true.
            // In this case, checking the transferred by field is a reliable way to tell it was posted and that
            // we don't want to recalculate taxes.
            // documents in the invoice pool are already posted and should not have taxes calculated.
            // Asset Journal does not support taxes.
            if (!ledgerJournalTable.Posted && !(ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger && this.TransferredBy) &&
            !(ledgerJournalTable.JournalType == LedgerJournalType::VendInvoicePool)
                && !(ledgerJournalTable.JournalType == LedgerJournalType::Assets))
            {
                LedgerJournalTrans::getTaxInstance(this.JournalNum, this.Voucher, this.Invoice, true
                    , null, false, this.TransDate);
            }
        }
        if (TaxWithholdParameters_IN::checkTaxParameters()
            && (!TaxWithholdNotCalcTaxForInvoicePool_INFlight::instance().isEnabled() || ledgerJournalTable.JournalType != LedgerJournalType::VendInvoicePool))
        {
            if (recalculateWithholdTaxes || !TaxWithholdUncommitted_IN::existByDocumentId(ledgerJournalTable.TableId, ledgerJournalTable.RecId))
            {
                LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = this.ledgerJournalTransTaxExtensionIN();

                // delete the cache for the document header if the threshold is not exceeded.
                // because this will impact the tax calculation for other journal lines.
                if (!TaxWithholdCalculation_IN::checkRecoverableAccount(this)
                    && TaxWithholdTrans_IN::isThresholdExceededForAccount(this.parmAccount(),
                                                                          ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup,
                                                                          this.TransDate))
                {
                    if (TaxWithholdUncommitted_IN::existByDocumentId(ledgerJournalTable.TableId, ledgerJournalTable.RecId))
                    {
                        TaxWithholdUncommitted_IN::deleteForDocumentHeader(ledgerJournalTable.TableId, ledgerJournalTable.RecId);
                    }
                    if (!ledgerJournalTable.Posted)
                    {
                        TaxVoucherService::calculateWithholdTaxForJournal_IN(this.JournalNum);
                    }
                }
                else
                {
                    if (!ledgerJournalTable.Posted && !(ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger && this.TransferredBy)
                        && !(ledgerJournalTable.JournalType == LedgerJournalType::VendInvoicePool)
                        && ((ledgerJournalTransTaxExt.TDSGroup || ledgerJournalTransTaxExt.TCSGroup)))
                    {
                        // if taxes were deleted then recalculate taxes
                        LedgerJournalTrans_IN_Extension::getTaxWithholdInstance_IN(this.JournalNum, this.Voucher, this.Invoice, true);
                    }
                }
            }
        }

        if (this.PaymentStatus != this_orig.PaymentStatus)
        {
            this.updateInvoicePaymStatus();
        }

        if (this.TaxWithholdGroup != this_orig.TaxWithholdGroup && !BrazilParameters::isEnabled())
        {
            if (!TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled())
            {
                new TaxWithhold(this).createAllTaxWithholdTrans();
                TaxWithhold::clearCache();
            }
        }
        else
        {
            if (this.TaxWithholdGroup &&
                    (this.CurrencyCode    != this_orig.CurrencyCode  ||
                     this.Triangulation   != this_orig.Triangulation ||
                     this.ExchRate        != this_orig.ExchRate      ||
                     this.ExchRateSecond  != this_orig.ExchRateSecond ||
                     this.TransDate       != this_orig.TransDate))
            {
                new TaxWithhold(this).updateAllTaxWithholdTransJournal();
            }
        }

        if (this.NegInstId && this.Due != this_orig.Due)
        {
            switch (this.ledgerJournalTable().JournalType)
            {
                case LedgerJournalType::CustBillOfExchangeDraw:
                    CustBillOfExchangeJour::updateDueDate(this.NegInstId, this.Due);
                    break;

                case LedgerJournalType::VendPromissoryNoteDraw:
                    VendPromissoryNoteJour::updateDueDate(this.NegInstId, this.Due);
                    break;

                default:
                    break;
            }
        }

        // Update account number for BOE
        if (this.NegInstId && this.LedgerDimension != this_orig.LedgerDimension)
        {
            switch (this.ledgerJournalTable().JournalType)
            {
                case LedgerJournalType::CustBillOfExchangeDraw:
                    CustBillOfExchangeJour::updateAccountNum(this.NegInstId, this.parmAccount());
                    break;

                case LedgerJournalType::VendPromissoryNoteDraw:
                    VendPromissoryNoteJour::updateAccountNum(this.NegInstId, this.parmAccount());
                    break;

                default:
                    break;
            }
        }

        // record has become unassociated with a project - remove the obsolete related project information
        if ((this_orig.AccountType == LedgerJournalACType::Project ||
             (this_orig.OffsetAccountType == LedgerJournalACType::Project && this_orig.OffsetLedgerDimension)) &&

            (this.AccountType != LedgerJournalACType::Project &&
             (this.OffsetAccountType != LedgerJournalACType::Project ||
              (this.OffsetAccountType == LedgerJournalACType::Project && !this.OffsetLedgerDimension))))
        {
            delete_from ledgerJournalTrans_Project where
                ledgerJournalTrans_Project.RefRecId == this.RecId;
        }

        // record has become unassociated with an asset - remove the obsolete related asset information
        if ((this_orig.AccountType == LedgerJournalACType::FixedAssets ||
             (this_orig.OffsetAccountType == LedgerJournalACType::FixedAssets && this_orig.OffsetLedgerDimension)) &&

            (this.AccountType != LedgerJournalACType::FixedAssets &&
             (this.OffsetAccountType != LedgerJournalACType::FixedAssets ||
              (this.OffsetAccountType == LedgerJournalACType::FixedAssets && !this.OffsetLedgerDimension))))
        {
            delete_from ledgerJournalTrans_Asset where
                ledgerJournalTrans_Asset.RefRecId == this.RecId;
        }

        if (countryRegion_RU)
        {
            if ((this_orig.AccountType == LedgerJournalACType::FixedAssets_RU ||
                   (this_orig.OffsetAccountType == LedgerJournalACType::FixedAssets_RU && this_orig.parmOffsetLedgerDimension())) &&
                  (this.AccountType != LedgerJournalACType::FixedAssets_RU &&
                   (this.OffsetAccountType != LedgerJournalACType::FixedAssets_RU ||
                    (this.OffsetAccountType == LedgerJournalACType::FixedAssets_RU && !this.parmOffsetLedgerDimension()))))
            {
                delete_from ledgerJournalTrans_RAsset where
                      ledgerJournalTrans_RAsset.RefRecId == this.RecId;
            }

            if ((this_orig.AccountType == LedgerJournalACType::RDeferrals ||
                 (this_orig.OffsetAccountType == LedgerJournalACType::RDeferrals && this_orig.parmOffsetLedgerDimension())) &&
                (this.AccountType != LedgerJournalACType::RDeferrals &&
                 (this.OffsetAccountType != LedgerJournalACType::RDeferrals ||
                  (this.OffsetAccountType == LedgerJournalACType::RDeferrals && !this.parmOffsetLedgerDimension()))))
            {
                delete_from ledgerJournalTrans_RDeferrals where
                    ledgerJournalTrans_RDeferrals.RefRecId == this.RecId;
            }
        }

        if (cashModuleEnabled)
        {
            if ((this_orig.AccountType == LedgerJournalACType::RCash ||
                 (this_orig.OffsetAccountType == LedgerJournalACType::RCash && this_orig.parmOffsetLedgerDimension())) &&
                (this.AccountType != LedgerJournalACType::RCash &&
                 (this.OffsetAccountType != LedgerJournalACType::RCash ||
                  (this.OffsetAccountType == LedgerJournalACType::RCash && !this.parmOffsetLedgerDimension()))))
            {
                delete_from ledgerJournalTrans_RCash where
                    ledgerJournalTrans_RCash.RefRecId == this.RecId;
            }
        }

        // update the LedgerJournalTransVoucherTemplate record for JournalNum or Voucher change
        if (this_orig.Voucher != this.Voucher ||
            this_orig.JournalNum != this.JournalNum)
        {
            LedgerJournalTransVoucherTemplate::updateVoucherTemplate(this, this_orig.JournalNum, this_orig.Voucher);
            this.updateLedgerJournalTransFeeVoucher(this_orig.JournalNum, this_orig.Voucher, this.Voucher, this_orig.RecId);
        }

        if (cashModuleEnabled)
        {
            ttscommit;
        }

        if (this_orig.PaymMode
            && this_orig.PaymMode != this.PaymMode)
        {
            if (this.AccountType == LedgerJournalACType::Cust)
            {
                if (CustOutPaym_NACHA_IAT::isIATNACHAFormat(this_orig.PaymMode))
                {
                    CustVendNACHAIATInfoTable_US::deleteByVoucher(this.RecId);
                }
            }
            else if (this.AccountType == LedgerJournalACType::Vend)
            {
                if (VendOutPaym_NACHA_IAT::isIATNACHAFormat(this_orig.PaymMode))
                {
                    CustVendNACHAIATInfoTable_US::deleteByVoucher(this.RecId);
                }
            }
        }

        // If the Debit value has changed to the credit, or negative credit changed positive credit,
        // and NACHA information was previously entered, the NACHA record needs to be deleted.
        if (this.PaymMode)
        {
            if (this.AccountType == LedgerJournalACType::Cust
                && CustOutPaym_NACHA_IAT::isIATNACHAFormat(this.PaymMode))
            {
                checkNACHARecord = true;
            }
            else if (this.AccountType == LedgerJournalACType::Vend
                && VendOutPaym_NACHA_IAT::isIATNACHAFormat(this_orig.PaymMode))
            {
                checkNACHARecord = true;
            }

            if (checkNACHARecord
                && ((this_orig.AmountCurCredit < 0 && this.AmountCurCredit > 0)
                || (this_orig.AmountCurDebit > 0 && this.AmountCurDebit < 0)
                || (this_orig.AmountCurDebit > 0 && this.AmountCurCredit > 0)
                || (this_orig.AmountCurCredit < 0 && this.AmountCurDebit < 0)))
            {
                CustVendNACHAIATInfoTable_US::deleteByVoucher(this.RecId);
            }
        }

        //start update negotiable instrument
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && this.NegInstId  &&
            (this.parmLedgerDimension() != this_orig.parmLedgerDimension()|| this.Due!= this_orig.Due))
        {
            this.negotiableInstrumentUpdate();
        }

        this.setPayWhenPaid();

        if (TaxSolutionScopeIntegrationUtil::IsCompanyEnabled() && recalculateTaxes)
        {
            // mark current tax document status to dirty.
            this.markCurrentTaxDocumentTaxStatusDirty();

            if (this.isTaxDocmentTypeChanged(this_orig))
            {
                TaxEngineLedgerJournalTransHeader::clearCacheForTaxableDocumentType(this.JournalNum, this.Voucher);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAmountCurDelete</Name>
				<Source><![CDATA[
    public void updateAmountCurDelete(
        Amount          _amount,
        CurrencyCode    _oldCurrencyCode)
    {
        if (this.AmountCurCredit)
        {
            this.AmountCurCredit += (CurrencyExchangeHelper::curAmount2CurAmount(0, _oldCurrencyCode, this.CurrencyCode, this.TransDate, true))
                                    - (CurrencyExchangeHelper::curAmount2CurAmount(_amount, _oldCurrencyCode, this.CurrencyCode, this.TransDate, true));
            if (this.AmountCurCredit < 0)
            {
                this.AmountCurDebit   = abs(this.AmountCurCredit);
                this.AmountCurCredit  = 0;
            }
        }
        else
        {
            this.AmountCurDebit -= (CurrencyExchangeHelper::curAmount2CurAmount(0, _oldCurrencyCode, this.CurrencyCode, this.TransDate, true))
                                - (CurrencyExchangeHelper::curAmount2CurAmount(_amount, _oldCurrencyCode, this.CurrencyCode, this.TransDate, true));
            if (this.AmountCurDebit < 0)
            {
                this.AmountCurCredit = abs(this.AmountCurDebit);
                this.AmountCurDebit  = 0;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAmountCurWrite</Name>
				<Source><![CDATA[
    public void updateAmountCurWrite(
        Amount          _amount,
        Amount          _amountLocal,
        CurrencyCode    _oldCurrencyCode)
    {
        if (this.AmountCurCredit)
        {
            this.AmountCurCredit -=   (CurrencyExchangeHelper::curAmount2CurAmount(_amountLocal, _oldCurrencyCode, this.CurrencyCode, this.TransDate, true))
                                    - (CurrencyExchangeHelper::curAmount2CurAmount(_amount, _oldCurrencyCode, this.CurrencyCode, this.TransDate, true));
        }
        if (this.AmountCurDebit)
        {
            this.AmountCurDebit  +=   (CurrencyExchangeHelper::curAmount2CurAmount(_amountLocal, _oldCurrencyCode, this.CurrencyCode, this.TransDate, true))
                                    - (CurrencyExchangeHelper::curAmount2CurAmount(_amount, _oldCurrencyCode, this.CurrencyCode, this.TransDate, true));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustVendBankAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the record ID of the <c>CustBankAccount</c> or <c>VendBankAccount</c> table in the
    /// <c>CustBankAccount</c> or <c>VendBankAccount</c> fields to complete the relation.
    /// </summary>
    /// <param name="_clearField">
    /// A Boolean value that indicates whether to clear the current references and the
    /// <c>CustVendBankAccountID</c> field when the account type changes.
    /// </param>
    /// <remarks>
    /// This upgrade script was introduced to fix the relations that using the <c>DEL_AccountNum</c> field.
    /// </remarks>
    public void updateCustVendBankAccount(boolean _clearField = false)
    {
        VendBankAccount         vendBankAccount;
        CustBankAccount         custBankAccount;
        DimensionDisplayValue   accountNumber;

        if (!_clearField &&
            (this.AccountType == LedgerJournalACType::Cust || this.AccountType == LedgerJournalACType::Vend || this.AccountType == LedgerJournalACType::Project))
        {
            accountNumber = LedgerDimensionFacade::getDisplayValueForLedgerDimension(this.LedgerDimension);

            if (this.AccountType == LedgerJournalACType::Cust)
            {
                changecompany (this.Company)
                {
                    select firstonly RecId from custBankAccount
                        where this.CustVendBankAccountId  == custBankAccount.AccountID    &&
                            custBankAccount.CustAccount == accountNumber;
                }

                this.CustBankAccount = custBankAccount.RecId;
            }
            else if (this.AccountType == LedgerJournalACType::Vend)
            {
                changecompany (this.Company)
                {
                    select firstonly RecId from vendBankAccount
                        where this.CustVendBankAccountId  == vendBankAccount.AccountID    &&
                            vendBankAccount.VendAccount == accountNumber;
                }

                this.VendBankAccount = vendBankAccount.RecId;
            }
            else if (this.AccountType == LedgerJournalACType::Project && this.OffsetAccountType == LedgerJournalACType::Vend && this.OffsetLedgerDimension)
            {
                accountNumber = LedgerDimensionFacade::getDisplayValueForLedgerDimension(this.OffsetLedgerDimension);
                changecompany (this.Company)
                {
                    select RecId from vendBankAccount
                        where vendBankAccount.AccountID == this.CustVendBankAccountId &&
                            vendBankAccount.VendAccount == accountNumber;
                }
                this.VendBankAccount = vendBankAccount.RecId;
            }
        }
        else
        {
            this.CustBankAccount = 0;
            this.VendBankAccount = 0;
            this.CustVendBankAccountId = "";
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFeeOffsetAccount</Name>
				<Source><![CDATA[
    public void updateFeeOffsetAccount()
    {
        CustVendPaymJournalFee custVendPaymJournalFeeLocal;
        LedgerJournalTrans ledgerJournalTransLocal;

        ttsbegin;

        while select forupdate ledgerJournalTransLocal join custVendPaymJournalFeeLocal
            where custVendPaymJournalFeeLocal.RefRecId == this.RecId &&
                custVendPaymJournalFeeLocal.FeeTransRecId == ledgerJournalTransLocal.RecId
        {
            ledgerJournalTransLocal.OffsetLedgerDimension = this.OffsetLedgerDimension;
            ledgerJournalTransLocal.OffsetAccountType = this.OffsetAccountType;
            ledgerJournalTransLocal.PaymReference = this.PaymReference;
            ledgerJournalTransLocal.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoicePaymStatus</Name>
				<Source><![CDATA[
    private void updateInvoicePaymStatus()
    {
        SpecTrans   specTrans;

        update_recordset specTrans
            setting PaymentStatus = this.PaymentStatus
            where specTrans.SpecTableId == this.TableId &&
                  specTrans.SpecRecId   == this.RecId &&
                  specTrans.SpecCompany == this.company();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournalTable</Name>
				<Source><![CDATA[
    public LedgerJournalTable updateLedgerJournalTable(ExchRate _exchRate = 0)
    {
        LedgerJournalTable  ledgerJournalTable;

        if (this.ExchRate != _exchRate ||
            prmIsDefault(_exchRate))
        {
            ledgerJournalTable = LedgerJournalTable::find(this.JournalNum, true);
            ledgerJournalTable.JournalTotalOffsetBalance = ledgerJournalTable.journalBalanceOnAccount(ledgerJournalTable.OffsetAccountType, ledgerJournalTable.OffsetLedgerDimension);

            [ledgerJournalTable.JournalTotalDebit,
             ledgerJournalTable.JournalTotalCredit] = LedgerJournalTable::journalBalanceMST(this.JournalNum);

            ledgerJournalTable.update();
        }

        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournalTransFeeVoucher</Name>
				<Source><![CDATA[
    public void updateLedgerJournalTransFeeVoucher(LedgerJournalId _oldJournalNum, Voucher _oldVoucher, Voucher _newVoucher, RecId _recId)
    {
        LedgerJournalTrans      ledgerJournalTrans;
        CustVendPaymJournalFee  custVendPaymJournalFee;

        ttsbegin;

        while select FeeTransRecId
                from  custVendPaymJournalFee
                where custVendPaymJournalFee.RefRecId == _recId
            join forupdate ledgerJournalTrans
                where   ledgerJournalTrans.JournalNum == _oldJournalNum    &&
                        ledgerJournalTrans.Voucher    == _oldVoucher  &&
                        ledgerJournalTrans.RecId      == custVendPaymJournalFee.FeeTransRecId
        {
            ledgerJournalTrans.Voucher = _newVoucher;
            ledgerJournalTrans.doUpdate();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkedInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the marked invoice of the current payment.
    /// </summary>
    /// <param name="_openTransMarkedCount">
    /// The number of open transactions marked for settlement.
    /// </param>
    /// <remarks>
    /// This method should be used for cases where a marked open transaction is not available.
    /// </remarks>
    public void updateMarkedInvoice(int _openTransMarkedCount)
    {
        CustTrans trans;
        CustTransOpen transOpen;
        SpecTrans specTrans;
        container sharedCompanyList;

        Debug::assert(this.RecId != 0);

        if (_openTransMarkedCount == 0)
        {
            this.MarkedInvoice = '';
        }
        else if (_openTransMarkedCount == 1)
        {
            // Retrieve the companies that the query should be limited to.
            sharedCompanyList = CustVendOpenTransManager::findSharedServiceCompanies(this.Company);

            // Check if the marked transaction is an invoice
            select firstonly crosscompany:sharedCompanyList RecId, Invoice from trans
                join transOpen
                where transOpen.RefRecId == trans.RecId
                join RecId from specTrans
                where specTrans.RefCompany == transOpen.DataAreaId && // transOpen.company is not allowed because it is a part of the select
                    specTrans.RefTableId == tableNum(CustTransOpen) &&
                    specTrans.RefRecId == transOpen.RecId &&
                    specTrans.SpecCompany == this.company() &&
                    specTrans.SpecTableId == tableNum(LedgerJournalTrans) &&
                    specTrans.SpecRecId == this.RecId;

            Debug::assert(trans.RecId != 0);

            if (trans.Invoice == '')
            {
                this.MarkedInvoice = LedgerJournalEngine_CustPayment::getMarkedInvoiceSettlementIndicator();
            }
            else
            {
                this.MarkedInvoice = trans.Invoice;
            }
        }
        else
        {
            this.MarkedInvoice = LedgerJournalEngine_CustPayment::getMarkedInvoiceSettlementIndicator();
        }

        if ((this.MarkedInvoice != '') && (this.MarkedInvoice == trans.Invoice))
        {
            // the marked invoice is a valid reference
            this.MarkedInvoiceCompany = transOpen.company();
            this.MarkedInvoiceRecId = transOpen.RecId;
        }
        else
        {
            this.MarkedInvoiceCompany = '';
            this.MarkedInvoiceRecId = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkedInvoiceWithTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the marked invoice of the current payment by using the specified marked transaction.
    /// </summary>
    /// <param name="_openTransMarkedCount">
    /// The number of open transactions marked for settlement.
    /// </param>
    /// <param name="_markedOpenTrans">
    /// The open transaction marked for settlement.
    /// </param>
    /// <param name="_trans">
    /// The customer transaction.
    /// </param>
    /// <remarks>
    /// This method should be used when the marked transaction is available.
    /// </remarks>
    public void updateMarkedInvoiceWithTrans(
        int _openTransMarkedCount,
        CustTransOpen _markedOpenTrans,
        CustTrans _trans)
    {
        if (_openTransMarkedCount == 0)
        {
            this.MarkedInvoice = '';
        }
        else if (_openTransMarkedCount == 1)
        {
            if (_trans.Invoice == '')
            {
                this.MarkedInvoice = LedgerJournalEngine_CustPayment::getMarkedInvoiceSettlementIndicator();
            }
            else
            {
                this.MarkedInvoice = _trans.Invoice;
            }
        }
        else
        {
            this.MarkedInvoice = LedgerJournalEngine_CustPayment::getMarkedInvoiceSettlementIndicator();
        }

        if ((this.MarkedInvoice != '') && (this.MarkedInvoice == _trans.Invoice))
        {
            // the marked invoice is a valid reference
            this.MarkedInvoiceCompany = _markedOpenTrans.company();
            this.MarkedInvoiceRecId = _markedOpenTrans.RecId;
        }
        else
        {
            this.MarkedInvoiceCompany = '';
            this.MarkedInvoiceRecId = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxCode</Name>
				<Source><![CDATA[
    private void updateTaxCode()
    {
        TaxTable    taxTable;

        if (TaxParameters::checkTaxParameters_IN()
           && TaxTable::find(this.TaxCode).TaxType_IN != TaxType_IN::None)
        {
            taxTable = TaxTable::find(this.TaxCode);
            if (!LedgerJournalTrans_IN_Extension::existsLedgerAccount_IN(this.AccountType, this.LedgerDimension, taxTable.TaxType_IN))
            {
                this.TaxCode = '';
            }
        }
        else
        {
            changecompany(this.Company)
            {
                if (!TaxVoucherService::ledgerAccountIsVATAccount(this.AccountType, this.LedgerDimension))
                {
                    if (this.OffsetLedgerDimension)
                    {
                        changecompany(this.OffsetCompany)
                        {
                            if (!TaxVoucherService::ledgerAccountIsVATAccount(this.OffsetAccountType, this.OffsetLedgerDimension))
                            {
                                this.TaxCode = '';
                            }
                        }
                    }
                    else
                    {
                        this.TaxCode = '';
                    }
                }
                // if account type isn't ledger check the offset account
                // if the account type is ledger and ledgerAccountIsVATAccount returned true
                // it is valid to leave the tax code and the offset account shouldn't be checked
                else if (this.OffsetLedgerDimension && this.AccountType != LedgerJournalACType::Ledger)
                {
                    changecompany(this.OffsetCompany)
                    {
                        if (!TaxVoucherService::ledgerAccountIsVATAccount(this.OffsetAccountType, this.OffsetLedgerDimension))
                        {
                            this.TaxCode = '';
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBankAccount</Name>
				<Source><![CDATA[
    public boolean validateBankAccount()
    {
        boolean ok = true;

        if (this.CustVendBankAccountId && !this.isInvoiceApprovalCancellation())
        {
            if (!PaymentRequestRecepientBankAccountCorrectionHelper::isEnabled())
            {
                ok = Bank::construct(
                    Bank::paymIdValidationCountryRegionISOCode(
                    this.AccountType,
                    this.LedgerDimension,
                    this.CustVendBankAccountId,
                    this.OffsetAccountType,
                    this.OffsetLedgerDimension)).checkPaymId(this.PaymId);
                if (this.AccountType == LedgerJournalAcType::Vend)
                {
                    ok = ok && VendBankAccount::checkBankAccountIsActiveForDate(this.parmAccount(), this.CustVendBankAccountId, this.TransDate, this.Company);
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvoiceApprovalCancellation</Name>
				<Source><![CDATA[
    private boolean isInvoiceApprovalCancellation()
    {
        boolean ok;

        if (this.AccountType == LedgerJournalACType::Vend && this.Cancel == NoYes::Yes
            && LedgerJournalTable::find(this.JournalNum).JournalType == LedgerJournalType::Approval)
        {
            ok = true;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean ret = true;

        if (this.TransferredBy && this.Transferred &&
            LedgerJournalTable::find(this.JournalNum).JournalType == LedgerJournalType::Approval)

        {
            ret = checkFailed("@SYS23847");
        }

        if (this.PaymentStatus == CustVendPaymStatus::Confirmed
            || this.PaymentStatus == CustVendPaymStatus::Recieved
            || this.PaymentStatus == CustVendPaymStatus::Sent)
        {
            ret = checkFailed(strFmt("@SYS68189", CustVendPaymStatus::None, CustVendPaymStatus::Rejected));
        }
        else
        {
            MCRCustPaymTable::deletePaymentForJournalLine(this);
        }

        if (BrazilParameters::isEnabled())
        {
            this.handleDeleteTaxWithholdEditStatus_BR();
        }

        if (ret)
        {
            ret = this.checkAllowEdit(true);
        }

        if (ret)
        {
            ret = super();
        }
        // Deductions must be deleted first
        if (ret
            && this.mcrIsDeductionParent())
        {
            ret = checkFailed("@MCR27446");
        }

        // Prevent deletion if record is for a refund check created for
        // sales order payment.
        if (this.RecId != 0 && RetailPaymentsJournalLineHelper::canDeleteJournalLine(this.ledgerJournalTable(), this))
        {
            ret = checkFailed("@MCR28910");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified field is valid.
    /// </summary>
    /// <param name="field">
    /// The field ID of the field to validate.
    /// </param>
    /// <returns>
    /// true if the field is valid; otherwise, false.
    /// </returns>
    public boolean validateField(FieldId field)
    {
        boolean                 ret = true;
        LedgerJournalTransType  ledgerJournalTransType;
        List                    ledgerJournalTransTypeList;
        ListEnumerator          enumerator;
        VendTable               vendTable;
        CompanyId               offsetCompanyId;

        #ISOCountryRegionCodes

        // The LedgerJournalTrans.AccountType represents one logical line and
        // LedgerJournalTrans.OffsetAccountType represents another logical line.
        // Therefore, a set is used to encapsulate the polymorphic business logic.
        // The logic is placed before other validation because the kernel validates the Company
        // returning by false in the super call and does not put anything into the infolog.  This
        // fault must be returned to the consumer.
        ledgerJournalTransTypeList = this.type();

        if (ledgerJournalTransTypeList)
        {
            enumerator = ledgerJournalTransTypeList.getEnumerator();
            while (enumerator.moveNext())
            {
                ledgerJournalTransType = enumerator.current();
                ret = ledgerJournalTransType.validateField(field);

                if (ret == false)
                {
                    break;
                }
            }
        }

        if (ret)
        {
            switch (field)
            {
                case fieldNum(LedgerJournalTrans, TaxCode):
                    // only test if a value is set else the exists fails
                    // for intercompany when the tax code has been cleared.
                    if (this.TaxCode)
                    {
                        //check for intercompany transaction
                        if (this.Company == curext())
                        {
                            ret = super(field);
                        }
                        else
                        {
                            changecompany(this.Company)
                            {
                                ret = TaxTable::exist(this.TaxCode);
                                if (!ret)
                                {
                                    //this error message is used for consistency between nonintercompany and intercompany transactions
                                    ret = checkFailed(strFmt("@SYS112224", this.TaxCode, fieldPName(TaxTable, TaxCode), tablePName(TaxTable)));
                                }
                            }
                        }
                        // if tax code is specified verify that the tax amount can be posted to the account or offset account
                        if (this.AccountType == LedgerJournalACType::Ledger)
                        {
                            changecompany(this.Company)
                            {
                                ret = TaxLedgerAccountGroup::verifyVATAccountNum(this.LedgerDimension,this.TaxCode);
                            }
                        }
                        else if (this.OffsetAccountType == LedgerJournalACType::Ledger)
                        {
                            if (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)))
                            {
                                offsetCompanyId = this.OffsetCompany;
                            }
                            else
                            {
                                offsetCompanyId = this.Company;
                            }
                            changecompany(offsetCompanyId)
                            {
                                ret = TaxLedgerAccountGroup::verifyVATAccountNum(this.OffsetLedgerDimension, this.TaxCode);
                            }
                        }
                        else
                        {
                            ret = checkFailed(strFmt("@TaxCoreTax:TaxJournalLineAccountTypeMustBeLedgerJournalACType", LedgerJournalACType::Ledger));
                        }
                    }
                    break;
                case fieldNum(LedgerJournalTrans, Txt):
                case fieldNum(LedgerJournalTrans, OffsetTxt):
                    return true;

                case fieldNum(LedgerJournalTrans, AccountAgreementId_RU):
                    ret = this.checkAgreement_RU();
                    break;
                case fieldNum(LedgerJournalTrans, OffsetAccountAgreementId_RU):
                    ret = this.checkAgreement_RU(AccountOffsetaccount::OffsetAccount);
                    break;
                case fieldNum(LedgerJournalTrans, DirectDebitMandate):
                    ret = CustDirectDebitMandate::checkExist(this.DirectDebitMandate, this.Company);
                    break;

                default:
                    if ((TaxParameters::checkTaxParameters_IN() || TaxWithholdParameters_IN::checkTaxParameters()) &&
                        (this.Company != this.OffsetCompany))
                    {
                        // When Two different companies are involve in invoice and payment..
                        ret = true;
                    }
                    else
                    {
                        ret = super(field);
                    }
            }
        }

        if (TaxParameters::checkTaxParameters_IN() || TaxWithholdParameters_IN::checkTaxParameters())
        {
            if (!this.Company)
            {
                this.Company = curext();
            }
        }

        if (ret)
        {
            switch (field)
            {
                case fieldNum(LedgerJournalTrans, ExchRate) :
                    ret = this.checkExchRate();
                    break;

                case fieldNum(LedgerJournalTrans, Company) :

                    if (this.Company != curext() && !isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)))
                    {
                        ret = checkFailed("@SYS125880");
                    }

                    ret = ret && this.isInterCompanySupportedByTransType();

                    ret = ret && this.checkDataAreaAccessible(this.Company);

                    if (this.LedgerDimension && ret)
                    {
                        ret = this.checkAllowPosting(this.LedgerDimension,
                                                     this.AccountType,
                                                     this.Company);
                    }
                    break;

                case fieldNum(LedgerJournalTrans, OffsetCompany) :
                    ret = this.isInterCompanySupportedByTransType();

                    ret = ret && this.checkDataAreaAccessible(this.OffsetCompany);

                    if (this.OffsetLedgerDimension && ret)
                    {
                        ret = this.checkAllowPosting(this.OffsetLedgerDimension,
                                                     this.OffsetAccountType,
                                                     this.OffsetCompany);
                    }
                    break;

                case fieldNum(LedgerJournalTrans, BankAccountId) :
                    if (this.BankAccountId)
                    {
                        ret = ret && BankAccountTable::checkIsActive(this.BankAccountId, this.TransDate);
                    }
                    break;

                case fieldNum(LedgerJournalTrans, LedgerDimension) :
                    ret = this.checkAllowPosting(this.LedgerDimension,
                                                 this.AccountType,
                                                 this.Company);

                    if (this.AccountType == LedgerJournalACType::Bank)
                    {
                        if (this.parmAccount())
                        {
                            ret = ret && BankAccountTable::checkIsActive(this.parmAccount(), this.TransDate, this.Company);
                        }
                    }
                    break;

                case fieldNum(LedgerJournalTrans, OffsetLedgerDimension) :
                    ret = this.checkAllowPosting(this.OffsetLedgerDimension,
                                                 this.OffsetAccountType,
                                                 this.OffsetCompany);

                    if (this.OffsetAccountType == LedgerJournalACType::Bank)
                    {
                        if (this.parmOffsetAccount())
                        {
                            ret = ret && BankAccountTable::checkIsActive(this.parmOffsetAccount(), this.TransDate, this.getOffsetCompany());
                        }
                    }
                    break;

                case fieldNum(LedgerJournalTrans, TransDate) :
                    if (this.OffsetAccountType == LedgerJournalACType::Bank)
                    {
                        if (this.parmOffsetAccount())
                        {
                            ret = ret && BankAccountTable::checkIsActive(this.parmOffsetAccount(), this.TransDate, this.getOffsetCompany());
                        }
                    }
                    if (this.AccountType == LedgerJournalACType::Bank)
                    {
                        if (this.parmAccount())
                        {
                            ret = ret && BankAccountTable::checkIsActive(this.parmAccount(), this.TransDate, this.Company);
                        }
                    }
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                    {
                        if ((this.AccountAgreementId_RU &&
                            AgreementHeader::find(
                                AgreementHeaderExt_RU::findByAgreementId(this.AccountAgreementId_RU).AgreementHeader).canReleaseAgreement(this.TransDate) != true) ||
                            (this.OffsetAccountAgreementId_RU &&
                            AgreementHeader::find(
                                AgreementHeaderExt_RU::findByAgreementId(this.OffsetAccountAgreementId_RU).AgreementHeader).canReleaseAgreement(this.TransDate) != true) &&
                            (!CFMParameters::isPaymentRequestsEnabled() || !CFMPaymentRequestPaymentLink::isGeneratedFromPaymentSchedule(this)))
                        {
                            ret = checkFailed(strFmt("@GLS221056", fieldPName(LedgerJournalTrans, TransDate)));
                        }
                    }
                    break;

                case fieldNum(LedgerJournalTrans, vatNumJournal) :
                    ret = TaxVATNumTable::checkVATNum(this.vatNumJournal, this, field);
                    ret = ret && TaxEnterpriseBranchNumber_BE::checkEnterPriseNumber(this.EnterpriseNumber, this.vatNumJournal, true);
                    break;

                case fieldNum(LedgerJournalTrans, ForeignCompany) :
                    ret = this.checkDataAreaAccessible(this.ForeignCompany);
                    break;

                case fieldNum(LedgerJournalTrans, CustVendBankAccountId):
                    switch (this.AccountType)
                    {
                        case LedgerJournalACType::Cust:
                            ret = this.checkCustBankAccount();
                            break;

                        case LedgerJournalACType::Vend:
                            ret = this.checkVendBankAccount();
                            break;
                    }

                case fieldNum(LedgerJournalTrans, CurrencyCode):
                    // If line has at least one deduction, don't allow currency code to change
                    if (this.mcrIsDeductionParent())
                    {
                        ret = checkFailed(strFmt("@MCR27299",
                                                 fieldId2pname(tableNum(LedgerJournalTrans),
                                                               fieldNum(LedgerJournalTrans, CurrencyCode))));
                    }
                    break;

                case fieldNum(LedgerJournalTrans, AmountCurDebit):
                    if (TaxWithholdParameters_IN::checkTaxParameters())
                    {
                        this.checkSettledVendorAutority_IN(true);
                    }

                case fieldNum(LedgerJournalTrans, AmountCurCredit):
                    ret = this.markedForSettlementError();
                    if (ret)
                    {
                        ret = this.markedForSettlementWarning();
                    }

                    if (ret
                        && this.ledgerJournalTable().isPositiveDRCROnlyEnabled_JP()
                        && (this.AmountCurCredit < 0
                            || this.AmountCurDebit   < 0))
                    {
                        ret = checkFailed("@GLS60021");
                    }
                    break;

                case fieldNum(LedgerJournalTrans, EnterpriseNumber):
                    ret = TaxEnterpriseBranchNumber_BE::checkEnterPriseNumber(this.EnterpriseNumber);

                    break;

                case fieldNum(LedgerJournalTrans, PaymId):
                    if (this.AccountType == LedgerJournalACType::Vend && VendParameters::find().VendInvoiceRefNumValidation_FI)
                    {
                        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceFI00005, funcName());

                        ret = CustVendInvoiceRefNum_FI::checkReferenceNumber(this.PaymId);
                        if (!ret)
                        {
                            ret = checkFailed("@SYS97602");
                        }
                    }
                    break;

                case fieldNum(LedgerJournalTrans, AccountType) :
                    ret = this.isInterCompanySupportedByTransType();

                    if (ret && !LedgerJournalEngine::accountTypeValid(this, this.ledgerJournalTable()))
                    {
                        ret = checkFailed(strFmt("@SYS111828", this.AccountType));
                    }
                    break;

                case fieldNum(LedgerJournalTrans, OffsetAccountType) :
                    ret = this.isInterCompanySupportedByTransType();

                    if (ret && !LedgerJournalEngine::accountTypeValid(this, this.ledgerJournalTable()))
                    {
                        ret = checkFailed(strFmt("@SYS111828", this.OffsetAccountType));
                    }
                    break;
                case fieldNum(LedgerJournalTrans, BankSpecAccountId_RU):
                    ret = this.validateSpecBankAccountId_RU();
                    break;

                case fieldNum(LedgerJournalTrans, InvoiceReleaseDate) :
                    if (this.InvoiceReleaseDate != utcDateTimeNull() && DateTimeUtil::addDays(this.InvoiceReleaseDate,1) < DateTimeUtil::utcNow())
                    {
                        ret = checkFailed("@SYS114595");
                    }
                    break;

                case fieldNum(LedgerJournalTrans, TaxWithholdGroup):
                    if (TaxWithholdParameters_IN::checkTaxParameters()
                        && this.TaxWithholdGroup)
                    {
                        changecompany(this.Company ? this.Company : curext())
                        {
                            if (TaxWithholdGroupHeading::find(this.TaxWithholdGroup).TaxType_IN != TaxWithholdCodeType_IN::None)
                            {
                                ret = checkFailed(strFmt("@GLS5461", this.TaxWithholdGroup, TaxWithholdCodeType_IN::None));
                            }
                        }
                    }
                    break;

                case fieldNum(LedgerJournalTrans, TaxItemGroup):
                    if (TaxParameters::isServiceTaxEnable_IN())
                    {
                        if (this.AccountType == LedgerJournalACType::Vend)
                        {
                            vendTable = this.findVendTable();
                        }
                        else if (this.OffsetAccountType == LedgerJournalACType::Vend)
                        {
                            vendTable = this.findVendForOffset();
                        }
                        if (vendTable.RecId != 0)
                        {
                            ret = TaxItemGroupHeading::validatePOTForGTA_IN(vendTable, this.TaxItemGroup);
                        }
                    }
                    break;

                case fieldNum(LedgerJournalTrans, PaymMode):
                    if (FeatureStateProvider::isFeatureEnabled(PaymentJournalAccountTypeValidateFeature::instance())
                        && this.ledgerJournalTable().JournalType == LedgerJournalType::Payment
                        && !LedgerJournalEngine::accountTypeValid(this, this.ledgerJournalTable()))
                    {
                        ret = checkFailed(strFmt("@CashManagement:WrongCombinationBetweenVendorPaymModeAndAccountType", this.PaymMode, this.AccountType, this.OffsetAccountType));
                    }
                    if (ret
                        && this.orig().PaymMode
                        && this.orig().PaymMode != this.PaymMode)
                    {
                        if (CustVendNACHAIATInfoTable_US::findByLedgerJournalTrans(this.RecId).RecId)
                        {
                            if (Box::yesNo("@SYS313183", DialogButton::No,'') == DialogButton::No)
                            {
                                ret = false;
                            }
                        }
                    }
                    break;

                case fieldNum(LedgerJournalTrans,OperationType_MX):
                    if (VendTable::findByLedgerDimension(this.LedgerDimension).VendorType_MX == VendorType_MX::ForeignVendor
                        && this.OperationType_MX == VendorOperationType_MX::RentLease)
                    {
                        ret = checkFailed(strFmt("@SYS312599", this.OperationType_MX));
                    }
                    break;

                case fieldNum(LedgerJournalTrans, InvoiceSeries_MX):
                    if (strKeep(this.InvoiceSeries_MX, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz') != this.InvoiceSeries_MX)
                    {
                        ret = checkFailed(strFmt("@Mexico:ELedgerAccounting_InvoiceSeriesValidation", this.InvoiceSeries_MX));
                    }
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates field value.
    /// </summary>
    /// <param name="_fieldName">
    /// The field name.
    /// </param>
    /// <param name="_arrayIndex">
    /// The array index.
    /// </param>
    /// <returns>
    /// true if the validation succeed; otherwise, false.
    /// </returns>
    public boolean validateFieldValue(FieldName _fieldName, int _arrayIndex = 1)
    {
        boolean ret;
        if (_fieldName == fieldId2Name(TableNum(LedgerJournalTrans), fieldNum(LedgerJournalTrans, TaxGroup)) || _fieldName == fieldId2Name(TableNum(LedgerJournalTrans), fieldNum(LedgerJournalTrans, TaxItemGroup)))
        {
            LedgerJournalTaxDocument ledgerJournalTaxDocument = LedgerJournalTaxDocument::construct(this.JournalNum, this.Voucher, this.Invoice, this);
            DataAreaId sourceCompany = ledgerJournalTaxDocument.getSourceCompany();
            DataAreaId destinationCompany = ledgerJournalTaxDocument.getLineByLedgerJournalTrans(this).getDestinationCompany();

            if(LedgerJournalTable::find(this.JournalNum).TaxObligationCompany == TaxObligationCompany::Source)
            {
                if(sourceCompany)
                {
                    changecompany(sourceCompany)
                    {
                        if(_fieldName == fieldId2Name(TableNum(LedgerJournalTrans), fieldNum(LedgerJournalTrans, TaxGroup)) && TaxGroupHeading::find(this.TaxGroup))
                        {
                            return true;
                        }
                        else if(_fieldName == fieldId2Name(TableNum(LedgerJournalTrans), fieldNum(LedgerJournalTrans, TaxItemGroup)) && TaxItemGroupHeading::find(this.TaxItemGroup))
                        {
                            return true;
                        }
                    }
                }
            }
            else
            {
                if(destinationCompany)
                {
                    changecompany(destinationCompany)
                    {
                        if(_fieldName == fieldId2Name(TableNum(LedgerJournalTrans), fieldNum(LedgerJournalTrans, TaxGroup)) && TaxGroupHeading::find(this.TaxGroup))
                        {
                            return true;
                        }
                        else if(_fieldName == fieldId2Name(TableNum(LedgerJournalTrans), fieldNum(LedgerJournalTrans, TaxItemGroup)) && TaxItemGroupHeading::find(this.TaxItemGroup))
                        {
                            return true;
                        }
                    }
                }
            }
        }

        ret = super(_fieldName, _arrayIndex);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInvoice</Name>
				<Source><![CDATA[
    public boolean validateInvoice(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
        TransDate fromDate;
        TransDate toDate;

        if (this.Invoice && !this.Invisible)
        {
            switch (this.AccountType)
            {
                case LedgerJournalACType::Vend :
                    [fromDate, toDate] = this.getJournalDateRange();

                    LedgerJournalTrans ledgerJournalTransLocal;

                    select firstonly RecId from ledgerJournalTransLocal
                        where ledgerJournalTransLocal.JournalNum      == this.JournalNum      &&
                              ledgerJournalTransLocal.AccountType     == this.AccountType     &&
                              ledgerJournalTransLocal.LedgerDimension == this.LedgerDimension &&
                              ledgerJournalTransLocal.Invoice         == this.Invoice         &&
                              ledgerJournalTransLocal.RecId           != this.RecId           &&
                              ledgerJournalTransLocal.TransDate       >= fromDate             &&
                              ledgerJournalTransLocal.TransDate       <= toDate               &&
                              !ledgerJournalTransLocal.Invisible;

                    if (ledgerJournalTransLocal.RecId)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS60176");
                        }
                        else
                        {
                            ok = checkFailed("@SYS60176");
                        }
                    }
                    break;
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalDateRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the date range for validating journal lines.
    /// </summary>
    /// <returns>
    /// The container containing period start and end date.
    /// </returns>
    [Wrappable(true)]
    protected final container getJournalDateRange()
    {
        TransDate fromDate, toDate;
        RecId calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();

        switch (VendParameters::find().CheckInvoice)
        {
            case ReuseVoucher::NoDuplicate :
                fromDate = dateNull();
                toDate = maxDate();
                break;

            case ReuseVoucher::NoDuplicateInYear, ReuseVoucher::WarnDuplicate :
                fromDate = LedgerFiscalCalendar::findOpeningStartDateByDate(calendarRecId, this.TransDate);
                toDate = LedgerFiscalCalendar::findClosingPeriodEndDateByDate(calendarRecId, this.TransDate);
                break;
        }

        return [fromDate, toDate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateW9Received</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that a W-9 has been received from the vendor if the journal's account or
    /// offset account corresponds to a vendor.
    /// </summary>
    /// <param name="_validateAll">
    /// Specifies whether to validate both the account and offset account or just the account
    /// specified by the second parameter.
    /// </param>
    /// <param name="_accountType">
    /// Specifies whether to validate the account or offset account; optional.
    /// </param>
    public void validateW9Received(boolean _validateAll,
        AccountOffsetaccount _accountType = AccountOffsetaccount::Account)
    {
        LedgerJournalTable  ledgerJournalTableLoc;

        ledgerJournalTableLoc = this.ledgerJournalTable();

        switch (ledgerJournalTableLoc.JournalType)
        {
            case LedgerJournalType::VendInvoiceRegister:
            case LedgerJournalType::PurchaseLedger:
            case LedgerJournalType::Approval:
            case LedgerJournalType::Daily:
                if (_validateAll || _accountType == AccountOffsetaccount::Account)
                {
                    switch (this.AccountType)
                    {
                        case LedgerJournalACType::Vend :
                            VendTable::checkW9Received(this.parmAccount());
                            break;

                        case LedgerJournalACType::Ledger :
                            if (this.VendTransId)
                            {
                                VendTable::checkW9Received(VendTrans::find(this.VendTransId).AccountNum);
                            }
                            break;
                    }
                }

                if ((_validateAll || _accountType == AccountOffsetaccount::OffsetAccount)
                    && this.OffsetAccountType == LedgerJournalACType::Vend)
                {
                    VendTable::checkW9Received(this.parmOffsetAccount());
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current record is valid and ready to be written to the database.
    /// </summary>
    /// <returns>
    /// true if the record is valid; otherwise, false.
    /// </returns>
    public boolean validateWrite()
    {
        boolean isValid;

        FiscalCalendarRecId     fiscalCalendarRecId;

        isValid = this.validateWrite_ServerPre();

        if (isValid)
        {
            isValid = super();
        }

        if (isValid)
        {
            isValid = this.validateWrite_Server();
        }

        if (this.AccountType != LedgerJournalACType::Ledger)
        {
            changecompany(this.Company)
            {
                DimensionValidation::validateDefaultDimension(this.DefaultDimension);
            }
        }

        LedgerJournalType ledgerJournalType = this.ledgerJournalTable().JournalType;
        if (isValid
            && LedgerParameters::isChineseVoucher_CN()
            && ledgerJournalType != LedgerJournalType::Approval
            && ledgerJournalType != LedgerJournalType::BankChequeReversal
            && ledgerJournalType != LedgerJournalType::Periodic)
        {
            if (!this.LedgerVoucherType_CN)
            {
                // Voucher type must be filled in
                isValid = checkFailed(strFmt("@SYS26332","@GLS54929"));
            }

            if (isValid
                && this.Voucher_CN
                && !LedgerJournalTrans_CN_Extension::checkVoucherNotUsed_CN(this, false))
            {
                // Voucher number has already been used
                isValid = checkFailed(strFmt("@GLS60257", this.Voucher_CN));
            }

            if (isValid
                && this.TransDate == dateNull())
            {
                // Date must be specified
                isValid = checkFailed("@SYS24455");
            }

            if (isValid)
            {
                fiscalCalendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
                if (!LedgerFiscalCalendar::findYearEndClosingPeriodByDate(fiscalCalendarRecId, this.TransDate).RecId)
                {
                    // The transaction date is not in a valid period
                    isValid = checkFailed("@GLS54501");
                }
            }
        }
        if (this.OffsetAccountType != LedgerJournalACType::Ledger)
        {
            if (isConfigurationKeyEnabled(configurationkeynum(LedgerAdvIntercompanyAccounting)))
            {
                changecompany(this.OffsetCompany)
                {
                    DimensionValidation::validateDefaultDimension(this.OffsetDefaultDimension);
                }
            }
            else
            {
                changecompany(this.Company)
                {
                    DimensionValidation::validateDefaultDimension(this.OffsetDefaultDimension);
                }
            }
        }

        if (isValid
            && VendBankAccountChangeProposalFeature::instance().isEnabled()
            && VendBankAccount::validateIsDraft(this.parmAccount(), this.CustVendBankAccountId, this.Company))
        {
            isValid = checkFailed(strFmt("@AccountsPayable:VendBankAccountValidateIsDraftError", this.CustVendBankAccountId));
        }

        if (isValid
            && this.Invoice
            && !FeatureStateProvider::isFeatureEnabled(VendInvoiceExtendInvoiceIdFeature::instance())
            && strLen(this.Invoice) > 20)
        {
            isValid = checkFailed(strFmt("@AccountsPayable:VendInvoiceWithLongNumFail", this.Invoice));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite_Server</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the current record is valid and ready to be written to the database.
    /// </summary>
    /// <returns>
    /// true if the record is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method was created to move execution of the logic for the <c>validateWrite</c> method onto the
    /// server.
    /// </remarks>
    protected boolean validateWrite_Server()
    {
        #LedgerJournalFaults
        LedgerJournalType   ledgerJournalType;
        LedgerJournalTable  ledgerJournalTable  = this.ledgerJournalTable();
        boolean             isValid;
        container           taxCheck;
        AmountCur           amountCurCreditDebit;
        classId             classId;
        boolean             isPayrollClass;
        #ISOCountryRegionCodes

        ledgerJournalType = ledgerJournalTable.JournalType;
        classId = VendPaymModeTable::find(this.paymMode).ClassId;
        isPayrollClass  = (classId == classNum(VendOutPaym_Cheque_Payroll) || classId == classNum(VendOutPaymNACHAPayroll));

        // Start by assuming the record is valid.
        isValid = true;

        if (isValid)
        {
            isValid = this.checkAllowEdit();
        }

        if (isValid)
        {
            isValid = this.checkApprovalActive();
        }

        if (isValid)
        {
            isValid = this.checkJournalAccountControl();
        }

        if (isValid)
        {
            isValid = this.checkVATNumJournal();
        }

        if (this.checkAccountTypesProject())
        {
            isValid = checkFailed("@SYS76796");
        }

        if (isValid)
        {
            isValid = this.isInterCompanySupportedByTransType();
        }

        if (isValid)
        {
            isValid = this.checkBankAccounts();
        }

        if (isValid && this.checkLedgerDimension(ledgerJournalType))
        {
            if (this.AccountType == LedgerJournalACType::Cust ||
                this.AccountType == LedgerJournalACType::Vend)
            {
                if ((this.AccountType == this.OffsetAccountType &&
                    this.LedgerDimension == this.OffsetLedgerDimension) ||
                    SpecTrans::getSpecTransCount(this.company(), this.TableId, this.RecId))
                {
                    isValid = checkFailed("@SYS65180");
                }
            }
            else
            {
                isValid = AifFault::checkFailedLogFault("@SYS65180", #AccountAndOffsetAccountCanNotBeEqual);
            }
        }

        // This validation does not need to be checked for the cost journals
        // as this validation calls checkIsActive method of BankAccountTable
        // which is not required at the time of posting of cost journals
        if (isValid && ledgerJournalType != LedgerJournalType::Cost && this.parmOffsetLedgerDimension())
        {
            if (!this.RecId && this.OffsetAccountType == LedgerJournalACType::Bank)
            {
                isValid = BankAccountTable::checkIsActive(this.parmOffsetAccount(), this.TransDate, this.getOffsetCompany());
            }
        }

        // the following code is moved from Validatefield
        // because it prevented the lookup to pass over the enumaration value Project
        if (isValid &&
            ((ledgerJournalType     == LedgerJournalType::CustPayment   ||
             (ledgerJournalType     == LedgerJournalType::Payment)      &&
            this.OffsetAccountType  == LedgerJournalACType::Project)))
        {
            isValid = checkFailed("@SYS58297");
        }

        if (isValid)
        {
            isValid = this.checkTaxBooksSetup();
        }

        if (isValid && this.AccountType == LedgerJournalACType::Vend)
        {
            amountCurCreditDebit =  this.AmountCurDebit ? this.AmountCurDebit : -this.AmountCurCredit;

            // this.AmountCurDebit is sent in as a negative amount because it's how Axapta actually treats this amount.
            taxCheck = [amountCurCreditDebit, this.Tax1099Amount, this.Tax1099StateAmount, this.Tax1099Fields, this.Tax1099State];
            isValid = Tax1099ElectronicCheck::tax1099EntryValidation(taxCheck);
        }

        // Validation for Opertaion type
        if (isValid && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
        {
            isValid = this.checkOpertaionType_MX(ledgerJournalType);
            isValid = this.checkWithholdingTax_MX(ledgerJournalType) && isValid;
        }

        if (isValid && this.checkRecipientName())
        {
            isValid = checkFailed("@SYS92827");
        }

        if (isValid &&
            this.AccountType == LedgerJournalACType::FixedAssets &&
            this.OffsetAccountType == LedgerJournalACType::FixedAssets &&
            this.OffsetLedgerDimension &&
            this.Company != this.OffsetCompany &&
            isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)))
        {
            isValid = checkFailed("@SYS112198");
        }

        if (this.isReverseDateBeforeTransactionDate(isValid))
        {
            isValid = checkFailed("@SYS116157");
        }

        if (isValid
            && LedgerParameters::isChineseVoucher_CN()
            && ledgerJournalType == LedgerJournalType::Daily)
        {
            if (this.amount() == 0)
            {
                // Amount not specified in the line
                isValid = checkFailed("@SYS58995");
            }
            if (isValid && this.Txt == "")
            {
                // Transaction text must be input
                isValid = checkFailed("@GLS54513");
            }
        }

        if (isValid && BrazilParameters::isEnabled())
        {
            isValid = this.handleWriteTaxWithholdEditStatus_BR();
        }

        if (isValid)
        {
            isValid = this.checkReasonRefRecID();
        }

        if (isValid                                                         &&
            (ledgerJournalType == LedgerJournalType::PurchaseLedger         ||
             ledgerJournalType == LedgerJournalType::VendInvoiceRegister)   &&
            this.Payment                                                    &&
            !this.LedgerJournalDlvDate_ES                                   &&
            SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES])    &&
            PaymTerm::find(this.Payment).UseDeliveryDateForDueDate_ES)
        {
            isValid = checkFailed(strFmt("@SYS4000479", this.Payment));
        }

        isValid = this.validateCurrencyConvBankTransAccount_RU() && isValid;

        if (isValid && ledgerJournalType == LedgerJournalType::Payment && isPayrollClass)
        {
            isValid = checkFailed(strFmt("@SYS4004015", enum2str(ledgerJournalType), VendPaymFormat::find(classId, BankFormat::Export).format));
        }

        if (isValid && ledgerJournalType == LedgerJournalType::PayrollDisbursement && !isPayrollClass)
        {
            isValid = checkFailed(strFmt("@SYS4004022", enum2str(ledgerJournalType), VendPaymFormat::find(classNum(VendOutPaym_Cheque_Payroll), BankFormat::Export).format, VendPaymFormat::find(classNum(VendOutPaymNACHAPayroll), BankFormat::Export).format));
        }

        if (isValid && !this.shouldSuppressTaxValidation())
        {
            DataAreaId dataAreaIdPostInterCompany = LedgerJournalTrans::getSalesTaxGroupCompanyForIntercompany(this);

            if (!dataAreaIdPostInterCompany)
            {
                dataAreaIdPostInterCompany = this.Company;
            }
            // Verify that a tax code is derived for the given Tax Group and Tax Item Group.
            //isValid = true;
            isValid = Tax::isValidTaxGroupIntersectionForInterCompanyV2(
                this.TaxGroup,
                this.TaxItemGroup,
                dataAreaIdPostInterCompany,
                this.isTaxIntegrationEnabled()) != CheckTaxGroups::Error;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            isValid = this.validateCorrectiveTrans_RU() && isValid;
        }

        if (this.RecId && CFMParameters::isPaymentRequestsEnabled() && CFMPaymentRequestPaymentLink::isGeneratedFromPaymentSchedule(this))
        {
            isValid = this.validatePaymentRequestConsistent() && isValid;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the account in <c>LedgerJournalTrans</c> is matched to <c>LedgerJournalTrans</c> offset account.
    /// </summary>
    /// <param name = "_ledgerJournalType">
    /// The Ledger journal type enumeration value.
    /// </param>
    /// <returns>
    /// Returns true if <c>LedgerJournalTrans</c> fields are matched to <c>LedgerJournalTrans</c> offset fields; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean checkLedgerDimension(LedgerJournalType _ledgerJournalType)
    {
        return ((!isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) ||
               this.Company == this.OffsetCompany) &&
               this.AccountType == this.OffsetAccountType &&
               this.LedgerDimension == this.OffsetLedgerDimension &&
               this.LedgerDimension != 0 &&
               this.OffsetLedgerDimension != 0 &&
               this.checkLedgerJournalType(_ledgerJournalType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerJournalType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the Ledger journal type is associated with the given enumeration values.
    /// </summary>
    /// <param name = "_ledgerJournalType">
    /// The Ledger journal type enumeration value.
    /// </param>
    /// <returns>
    /// Returns true if Ledger journal type is not associated with given enumeration values; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean checkLedgerJournalType(LedgerJournalType _ledgerJournalType)
    {
        LedgerJournalTable ledgerJournalTable = this.ledgerJournalTable();

        return ((_ledgerJournalType != LedgerJournalType::CustBillOfExchangeDraw &&
               _ledgerJournalType != LedgerJournalType::CustBillOfExchangeProtest &&
               _ledgerJournalType != LedgerJournalType::CustBillOfExchangeRedraw &&
               _ledgerJournalType != LedgerJournalType::CustPaymRemittance &&
               _ledgerJournalType != LedgerJournalType::VendPromissoryNoteDraw &&
               _ledgerJournalType != LedgerJournalType::VendPaymRemittance) ||
               (_ledgerJournalType == LedgerJournalType::CustBillOfExchangeProtest &&
               ledgerJournalTable.ProtestSettledBill == NoYes::Yes));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRecipientName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the Recipient name given and the <c>LedgerJournalTrans</c> Account type is not Ledger.
    /// </summary>
    /// <returns>
    /// Returns true if the Recipient name is given and selected Account type is not Ledger; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean checkRecipientName()
    {
        return (this.BankNegInstRecipientName && (this.AccountType != LedgerJournalACType::Ledger));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReverseDateBeforeTransactionDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates reverse entry date.
    /// </summary>
    /// <param name = "_isValid">
    /// A boolean value that indicates the current state of the validation.
    /// </param>
    /// <returns>
    /// True if there is reverse date and valid; otherwise, false.
    /// </returns>
    protected boolean isReverseDateBeforeTransactionDate(boolean _isValid)
    {
        return _isValid && this.ReverseEntry && this.ReverseDate <= this.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustPaymentTermsOfPaymentByInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults Payment based on the customer invoice, if any.
    /// </summary>
    public void setCustPaymentTermsOfPaymentByInvoice()

    {
        CustTrans custTrans;
        CustInvoiceTable custInvoiceTable;
        CustInvoiceJour custInvoiceJour;

        custTrans = CustTransOpen::find(this.MarkedInvoiceRecId).custTrans();
        if (custTrans)
        {
            if (custTrans.TransType == LedgerTransType::Cust)
            {
                custInvoiceTable = CustInvoiceTable::findPostedInvoice(custTrans.AccountNum, custTrans.Invoice, custTrans.TransDate);
                if (custInvoiceTable.Payment)
                {
                    this.Payment = custInvoiceTable.Payment;
                }
            }
            else if (custTrans.TransType == LedgerTransType::Sales)
            {
                custInvoiceJour = CustInvoiceJour::findFromCustTrans(custTrans.Invoice, custTrans.TransDate, custTrans.AccountNum);
                if (custInvoiceJour.Payment)
                {
                    this.Payment = custInvoiceJour.Payment;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSuppressTaxValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not it is appropriate to validate tax intersection on this journal line.
    /// </summary>
    /// <returns>true if validation should be suppressed; false otherwise</returns>
    public boolean shouldSuppressTaxValidation()
    {
        // taxes don't apply to non-ledger transactions without an offset; in this case, a separate line will represent tax.
        // if we apply validation to such a line, unexpected errors will prevent the user from proceeding with entering the actual tax line
        return this.isTaxIntegrationEnabled()
                || (this.AccountType != LedgerJournalACType::Ledger
                    && this.AccountType != LedgerJournalACType::FixedAssets
                    && this.AccountType != LedgerJournalACType::Project
                    && !this.OffsetLedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite_ServerPre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the current record is valid and ready to be written to the database.
    /// </summary>
    /// <returns>
    /// true if the record is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method was created to move execution of the logic for the <c>validateWrite</c> method onto the
    /// server. The logic is positioned before other validation logic because the kernel validates
    /// information that will not be exposed as faults.
    /// </remarks>
    private boolean validateWrite_ServerPre()
    {
        boolean                 isValid;
        LedgerJournalTransType  ledgerJournalTransType;
        List                    ledgerJournalTransTypeList;
        ListEnumerator          enumerator;

        isValid = true;

        // The LedgerJournalTrans.AccountType represents one logical line and
        // LedgerJournalTrans.OffsetAccountType represents another logical line.
        // Therefore, a set is used to encapsulate the polymorphic business logic.
        ledgerJournalTransTypeList = this.type();
        if (ledgerJournalTransTypeList)
        {
            enumerator = ledgerJournalTransTypeList.getEnumerator();
            while (enumerator.moveNext())
            {
                ledgerJournalTransType = enumerator.current();
                isValid = ledgerJournalTransType.validateRow();

                if (isValid == false)
                {
                    break;
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendPaymentFilledOk</Name>
				<Source><![CDATA[
    private boolean vendPaymentFilledOk(Map _tmpVoucherMap = null)
    {
        boolean ok = true;
        LedgerJournalType ledgerJournalType = this.ledgerJournalTable().JournalType;

        if (!this.PaymMode
            || (ledgerJournalType != LedgerJournalType::Payment
                && (ledgerJournalType != LedgerJournalType::Daily
                    || this.Invoice)))
        {
            return ok;
        }

        VendPaymMethodVal vendPaymMethodValFieldList;
        while select VendPaymValidate from vendPaymMethodValFieldList
            where vendPaymMethodValFieldList.VendPaymentMode == this.PaymMode
        {
            VendPaymentFieldValidator vendPaymentFieldValidator = VendPaymentFieldValidatorFactory::constructFieldValidator(
                vendPaymMethodValFieldList.VendPaymValidate,
                this,
                ledgerJournalType,
                _tmpVoucherMap);

            ok = vendPaymentFieldValidator.validate() && (ok || !VendPaymConsiderAllPaymControlFlight::instance());
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>write</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes data to ledger journal trans.
    /// </summary>
    public void write()
    {
        LedgerJournalTrans              this_orig = this.orig();
        LedgerJournalTrans              ledgerJournalTrans;
        boolean                         updateChineseVoucher;
        boolean                         updateAttachments;
        boolean                         allRecordsChange = false;
        boolean                         isCallingFromFormDataSource;
        RefRecId                        numberSequenceTableRecId;
        NumberSeq                       numberSeq;
        boolean                         isChineseVoucher = LedgerParameters::isChineseVoucher_CN();
        #define.OneRecord(1)

        if (isChineseVoucher)
        {
            if (this.LedgerVoucherType_CN != this_orig.LedgerVoucherType_CN
                || this.Voucher           != this_orig.Voucher)
            {
                updateChineseVoucher = true;
            }

            if (LedgerJournalTable::find(this.JournalNum).JournalType == LedgerJournalType::Daily
                && this_orig.Attachments_CN != this.Attachments_CN)
            {
                updateAttachments = true;
            }

            if (updateChineseVoucher
                || updateAttachments)
            {
                select count(RecId) from ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum == this.JournalNum
                        && ledgerJournalTrans.Voucher    == this.Voucher;

                if ((this.RecId && (ledgerJournalTrans.RecId > #OneRecord)) //If this is updating and at least 2+ records(>1), then prompt.
                    || (!this.RecId && (ledgerJournalTrans.RecId >= #OneRecord))) // or if this is insertion and has records(>=1), then prompt.
                {
                    isCallingFromFormDataSource = FormDataUtil::getFormDataSource(this) ? true : false;
                    if (isCallingFromFormDataSource)
                    {
                        if (Box::yesNo("@GLS64340", DialogButton::Yes) == DialogButton::Yes)
                        {
                            allRecordsChange = true;
                        }
                        else
                        {
                            allRecordsChange = false;
                            if (updateChineseVoucher)
                            {
                                this.LedgerVoucherType_CN = this_orig.LedgerVoucherType_CN;
                                numberSequenceTableRecId = LedgerVoucherType_CN::find(this_orig.LedgerVoucherType_CN).NumberSequenceTable;

                                if (numberSequenceTableRecId != 0)
                                {
                                    numberSeq = NumberSeq_Voucher_CN::newGetVoucherFromCode(numberSequenceTableRecId, this.TransDate);
                                }

                                if (numberSeq)
                                {
                                    this.Voucher_CN = numberSeq.voucher();
                                }
                            }

                            if (updateAttachments)
                            {
                                this.Attachments_CN = this_orig.Attachments_CN;
                            }
                        }
                    }
                    else
                    {
                        //if not calling from formdatasource, don't prompt dialog and update the records always.
                        allRecordsChange = true;
                    }
                }
            }
        }

        super();

        if (isChineseVoucher)
        {
            if (updateChineseVoucher
                && allRecordsChange)
            {
                this.updateVoucherHeader_CN();
            }

            if (updateAttachments
                && allRecordsChange)
            {
                this.updateAttachments_CN();
            }
            //Since in the updateVoucherHeader_CN() and updateAttachments_CN() method shall do
            //set based updating after super() call in this write method, so here shall need to
            //call reread of current record to refresh the RecVersion field, otherwise, the next
            //updating on current record cursor shall cause the update conflicts exception.
            this.reread();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipTableMethodsOnDelete</Name>
				<Source><![CDATA[
    internal static void skipTableMethodsOnDelete(Common _common)
    {
        _common.skipDeleteActions(true);
        _common.skipDataMethods(true);
        _common.skipAosValidation(true);
        _common.skipDatabaseLog(true);
        _common.skipEvents(true);

        if (LedgerJournalTransSkipBusinessEventsFlight::instance().isEnabled())
        {
            _common.skipBusinessEvents(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteChildrenForLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the records in the delete action tables of the <c>LedgerJournalTrans</c>
    /// table associated with the specified <c>LedgerJournalTable</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <remarks>
    /// The records in the country specific delete action tables are not deleted.
    /// </remarks>
    public static void deleteChildrenForLedgerJournalTable(LedgerJournalTable _ledgerJournalTable)
    {
        boolean setBasedFlight = LedgerJournalDeleteTransactionSetBasedFlight::instance().isEnabled();
        LedgerJournalTrans ledgerJournalTrans;

        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;
        if (setBasedFlight)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTrans_Asset);
        }
        

        delete_from ledgerJournalTrans_Asset
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == ledgerJournalTrans_Asset.RefRecId
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        AssetReversalRelatedVoucher assetReversalRelatedVoucher;
        if (setBasedFlight)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(assetReversalRelatedVoucher);
        }

        delete_from assetReversalRelatedVoucher
            exists join ledgerJournalTrans
                where ledgerJournalTrans.Voucher == assetReversalRelatedVoucher.Voucher
                    && ledgerJournalTrans.TransDate == assetReversalRelatedVoucher.TransDate
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;
     
        LedgerJournalTrans_Project ledgerJournalTrans_Project;
        if (setBasedFlight)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTrans_Project);
        }

        delete_from ledgerJournalTrans_Project
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == ledgerJournalTrans_Project.RefRecId
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        AssetBookTableDerivedJournal assetBookTableDerivedJournal;
        if (setBasedFlight)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(assetBookTableDerivedJournal);
        }

        delete_from assetBookTableDerivedJournal
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == assetBookTableDerivedJournal.RefRecId
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        CustTransCashDisc custTransCashDisc;
        if (setBasedFlight)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(custTransCashDisc);
        }

        delete_from custTransCashDisc
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == custTransCashDisc.RefRecId
                    && ledgerJournalTrans.TableId == custTransCashDisc.RefTableId
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        CustVendNACHAIATInfoTable_US custVendNACHAIATInfoTable_US;
        if (setBasedFlight)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(custVendNACHAIATInfoTable_US);
        }

        delete_from custVendNACHAIATInfoTable_US
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == custVendNACHAIATInfoTable_US.LedgerJournalTransRecId
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        CustVendPaymJournalFee custVendPaymJournalFee;
        if (setBasedFlight)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(custVendPaymJournalFee);
        }

        delete_from custVendPaymJournalFee
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == custVendPaymJournalFee.RefRecId
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        CustVendPDCRegister custVendPDCRegister;
        if (setBasedFlight)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(custVendPDCRegister);
        }

        delete_from custVendPDCRegister
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == custVendPDCRegister.LedgerJournalTrans
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        LedgerJournalTransBankLC ledgerJournalTransBankLC;
        if (setBasedFlight)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTransBankLC);
        }

        delete_from ledgerJournalTransBankLC
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == ledgerJournalTransBankLC.LedgerJournalTrans
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        CustVendNetJournalLineLink custVendNetJournalLineLink;
        if (setBasedFlight)
        {
            LedgerJournalTrans::skipTableMethodsOnDelete(custVendNetJournalLineLink);
        }

        delete_from custVendNetJournalLineLink
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == custVendNetJournalLineLink.VendNetLineRecId
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        CustVendCreditInvoicingTable custVendCreditInvoicingTable;
        LedgerJournalTrans::skipTableMethodsOnDelete(custVendCreditInvoicingTable);

        delete_from custVendCreditInvoicingTable
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == custVendCreditInvoicingTable.RefRecId
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        LedgerJournalTransAccrual ledgerJournalTransAccrual;
        LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTransAccrual);

        delete_from ledgerJournalTransAccrual
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == ledgerJournalTransAccrual.RefRecId
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        TradeBLWIJournalPurposeCodes tradeBLWIJournalPurposeCodes;
        LedgerJournalTrans::skipTableMethodsOnDelete(tradeBLWIJournalPurposeCodes);

        delete_from tradeBLWIJournalPurposeCodes
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == tradeBLWIJournalPurposeCodes.RefRecId
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                    && tradeBLWIJournalPurposeCodes.TypeOfForm == TradeBLWITypeOfForm::InvoiceRegister;

        delete_from tradeBLWIJournalPurposeCodes
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == tradeBLWIJournalPurposeCodes.RefRecId
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                    && tradeBLWIJournalPurposeCodes.TypeOfForm == TradeBLWITypeOfForm::LedgerJournalTrans;

        CustEPRemitInfo_BR custEPRemitInfo_BR;
        LedgerJournalTrans::skipTableMethodsOnDelete(custEPRemitInfo_BR);

        delete_from custEPRemitInfo_BR
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == custEPRemitInfo_BR.LedgerJournalTrans
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        VendEPRemitInfo_BR vendEPRemitInfo_BR;
        LedgerJournalTrans::skipTableMethodsOnDelete(vendEPRemitInfo_BR);

        delete_from vendEPRemitInfo_BR
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == vendEPRemitInfo_BR.LedgerJournalTrans
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        LedgerJournalTransPayment_BR ledgerJournalTransPayment_BR;
        LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTransPayment_BR);

        delete_from ledgerJournalTransPayment_BR
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == ledgerJournalTransPayment_BR.RefRecId
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN;
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTransTaxExtensionIN);

            delete_from ledgerJournalTransTaxExtensionIN
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == ledgerJournalTransTaxExtensionIN.LedgerJournalTrans
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]))
        {
            LedgerJournalTransSymbol ledgerJournalTransSymbol;
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTransSymbol);

            delete_from ledgerJournalTransSymbol
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == ledgerJournalTransSymbol.LedgerJournalTrans
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLV]))
        {
            LedgerJournalTransPayment_LV ledgerJournalTransPayment_LV;
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTransPayment_LV);

            delete_from ledgerJournalTransPayment_LV
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == ledgerJournalTransPayment_LV.LedgerJournalTrans
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

            LedgerJournalTransPaymTransCode ledgerJournalTransPaymTransCode;
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTransPaymTransCode);

            delete_from ledgerJournalTransPaymTransCode
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == ledgerJournalTransPaymTransCode.LedgerJournalTrans
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
        {
            DiotAdditionalInfoForNoVendor_MX diotAdditionalInfoForNoVendor_MX;
            LedgerJournalTrans::skipTableMethodsOnDelete(diotAdditionalInfoForNoVendor_MX);

            delete_from diotAdditionalInfoForNoVendor_MX
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == diotAdditionalInfoForNoVendor_MX.InstanceRelationType
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            PlSADFinanceLedgerJournalRef reference;
            LedgerJournalTrans::skipTableMethodsOnDelete(reference);

            delete_from reference
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == reference.LedgerJournalTransRefRecId
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;
        }

        if (RCashParameters::isCashModuleEnabled())
        {
            LedgerJournalTrans_RCash ledgerJournalTrans_RCash;
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTrans_RCash);

            delete_from ledgerJournalTrans_RCash
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == ledgerJournalTrans_RCash.RefRecId
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            BankClientPayment_RU paymentTable;
            LedgerJournalTrans::skipTableMethodsOnDelete(paymentTable);

            update_recordset paymentTable
            setting JournalNum = "", Voucher = ""
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.Voucher == paymentTable.Voucher
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                        && paymentTable.JournalNum == _ledgerJournalTable.JournalNum;

            LedgerJournalTrans_RDeferrals ledgerJournalTrans_RDeferrals;
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTrans_RDeferrals);

            delete_from ledgerJournalTrans_RDeferrals
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == ledgerJournalTrans_RDeferrals.RefRecId
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

            RAssetPurchTrans rAssetPurchTrans;

            delete_from rAssetPurchTrans
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == rAssetPurchTrans.TableRecId
                        && rAssetPurchTrans.TableTableId == tableNum(LedgerJournalTrans)
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

            RCashDestinationTrans rCashDestinationTrans;
            LedgerJournalTrans::skipTableMethodsOnDelete(rCashDestinationTrans);

            delete_from rCashDestinationTrans
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == rCashDestinationTrans.LedgerJournalTransRecId
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;
        }

        if (LedgerJournalTransExtensionTH::isExtensionEnabled())
        {
            LedgerJournalTransExtensionTH ledgerJournalTransExtensionTH;
            LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTransExtensionTH);

            delete_from ledgerJournalTransExtensionTH
                exists join ledgerJournalTrans
                    where ledgerJournalTrans.RecId == ledgerJournalTransExtensionTH.LedgerJournalTrans
                        && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;
        }

        LedgerJournalTransTaxExtension ledgerJournalTransTaxExt;
        LedgerJournalTrans::skipTableMethodsOnDelete(ledgerJournalTransTaxExt);

        delete_from ledgerJournalTransTaxExt
            exists join ledgerJournalTrans
                where ledgerJournalTrans.RecId == ledgerJournalTransTaxExt.LedgerJournalTrans
                    && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;

        LedgerJournalTrans_Error::deleteJournalErrorLinks(_ledgerJournalTable.JournalNum);

        if (LedgerJournalTable::hasAnySpecTrans(_ledgerJournalTable.JournalNum)
            && LedgerJournalTable::canJournalTypeHaveSettlements(_ledgerJournalTable.JournalType))
        {
            LedgerJournalTable::deleteMarkedTransactionsForJournal(_ledgerJournalTable.JournalNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteForLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all the <c>LedgerJournalTrans</c> records associated with the
    /// specified <c>LedgerJournalTable</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <remarks>
    /// The caller has to verify deleting all the <c>LedgerJournalTrans</c>
    /// records is supported. The row-by-row delete must be used if any of the
    /// following are true.
    /// <list type="bullet">
    /// <item>
    /// <description>A payment exists that is confirmed, received, or sent.</description>
    /// </item>
    /// <item>
    /// <description>Budget sources exist.</description>
    /// </item>
    /// <item>
    /// <description>This is an approval journal.</description>
    /// </item>
    /// <item>
    /// <description>Any of the country specific delete action tables is in context.</description>
    /// </item>
    /// </list>
    /// </remarks>
    public static void deleteForLedgerJournalTable(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans ledgerJournalTrans;

        ttsbegin;

        if (_ledgerJournalTable.JournalType == LedgerJournalType::Daily ||
            _ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister)
        {
            LedgerJournalTransVoucherTemplate::deleteForJournalOrVoucher(_ledgerJournalTable.JournalNum);
        }

        LedgerJournalTrans::deleteChildrenForLedgerJournalTable(_ledgerJournalTable);

        TaxUncommitted::deleteForDocumentHeader(tablenum(LedgerJournalTable), _ledgerJournalTable.RecId);

        NumberSequenceTable numberSequenceTable = NumberSequenceTable::find(_ledgerJournalTable.NumberSequenceTable);

        if (_ledgerJournalTable.JournalType != LedgerJournalType::Periodic
            && _ledgerJournalTable.JournalType != LedgerJournalType::VendInvoicePool
            && numberSequenceTable.Continuous)
        {
            select firstonly RecId from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                    && ledgerJournalTrans.Transferred == true;

            if (ledgerJournalTrans == null)
            {
                while select Voucher from ledgerJournalTrans
                    group by Voucher
                    where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                {
                    if (ledgerJournalTrans && numberSequenceTable.RecId)
                    {
                        LedgerJournalTrans::releaseNumber(_ledgerJournalTable.JournalType, numberSequenceTable, ledgerJournalTrans.Voucher);
                    }
                }
            }
        }

        if ((_ledgerJournalTable.Posted == NoYes::No)
            && (_ledgerJournalTable.JournalType == LedgerJournalType::BankDepositPaymCancel
            || _ledgerJournalTable.JournalType == LedgerJournalType::BankChequeReversal))
        {
            ledgerJournalTrans::clearBankDepositSlipStatus(_ledgerJournalTable);
            ledgerJournalTrans::clearBankChequeStatus(_ledgerJournalTable);
        }

        LedgerJournalTrans::processSetDeleteForLedgerJournalTable(_ledgerJournalTable.JournalNum);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearBankDepositSlipStatus</Name>
				<Source><![CDATA[
    private static void clearBankDepositSlipStatus(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans ledgerJournalTrans;

        while select ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                && ledgerJournalTrans.BankChequeDepositTransRefRecID != 0
                && ledgerJournalTrans.BankDepositNum != ''
        {
            ledgerJournalTrans.revertBankAccountTrans(_ledgerJournalTable.JournalType);
            ledgerJournalTrans.revertBankDeposit();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearBankChequeStatus</Name>
				<Source><![CDATA[
    private static void clearBankChequeStatus(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans ledgerJournalTrans;

        while select ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                && ledgerJournalTrans.BankChequeDepositTransRefRecID != 0
                &&  ledgerJournalTrans.BankChequeNum != ''
        {
            ledgerJournalTrans.revertBankAccountTrans(_ledgerJournalTable.JournalType);
            ledgerJournalTrans.revertBankChequeTable();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteIfZeroAmount</Name>
				<Source><![CDATA[
    public static void deleteIfZeroAmount(LedgerJournalId  _ledgerJournalId)
    {
        LedgerJournalTrans  ledgerJournalTrans;

        ttsbegin;

        delete_from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum      == _ledgerJournalId
               && ledgerJournalTrans.AmountCurCredit == 0
               && ledgerJournalTrans.AmountCurDebit  == 0;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLineAfterPosting</Name>
				<Source><![CDATA[
    public static void deleteLineAfterPosting(LedgerJournalId _ledgerJournalId)
    {
        LedgerJournalTrans  ledgerJournalTrans;

        ttsbegin;

        while select forupdate ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalId
        {
            ledgerJournalTrans.delete(false);
        }

        // delete any voucher template rows existing for this journal
        LedgerJournalTransVoucherTemplate::deleteForJournalOrVoucher(_ledgerJournalId);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTransFromVoucher</Name>
				<Source><![CDATA[
    public static void deleteTransFromVoucher(
        LedgerJournalId _journalNum,
        Voucher         _voucher)
    {
        LedgerJournalTrans  ledgerJournalTrans;
        Counter             counter;
        boolean             numberSeqRelease = true;
        LedgerJournalType   journalType;
        RefRecId            voucherSeries;

        ttsbegin;

        LedgerJournalTable  ledgerJournalTable = LedgerJournalTable::find(_journalNum);

        while select forupdate ledgerJournalTrans
            index hint NumVoucherIdx
            where ledgerJournalTrans.JournalNum == _journalNum &&
                  ledgerJournalTrans.Voucher    == _voucher
        {
            if (!counter)
            {
                journalType = ledgerJournalTable.JournalType;
                voucherSeries = ledgerJournalTable.NumberSequenceTable;
            }

            if (ledgerJournalTrans.Transferred)
            {
                numberSeqRelease = false;
            }

            // Delete the SpecTrans records associated with the LedgerJournalTrans.
            // Normally this is handled by the delete method, but this is calling doDelete
            SpecTransManager specTransManager = SpecTransManager::newFromSpec(ledgerJournalTrans, false);
            specTransManager.deleteAll();

            if (CFMParameters::isPaymentRequestsEnabled())
            {
                CFMPaymentRequestPaymentLink::deletePaymentRequestLinkJournalTrans(ledgerJournalTrans);
            }

            ledgerJournalTrans.deleteTransFromVoucherDelegate(ledgerJournalTrans);

            if (journalType == LedgerJournalType::CustomsDeclaration_IT)
            {
                LedgerJournalTrans_Customs_IT::deleteRecord(ledgerJournalTrans.RecId);
            }

            ledgerJournalTrans.doDelete();

            counter++;
        }

        if (counter > 0)
        {
            TaxUncommitted::deleteForDocumentHeader(ledgerJournalTable.TableId, ledgerJournalTable.RecId, false);
        }

        // delete associated LedgerJournalTransVoucherTemplate record
        if (journalType == LedgerJournalType::Daily ||
            journalType == LedgerJournalType::VendInvoiceRegister)
        {
            LedgerJournalTransVoucherTemplate::deleteForJournalOrVoucher(_journalNum, _voucher);
        }

        if (counter && numberSeqRelease)
        {
            NumberSequenceTable numberSequenceTable = NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable);

            LedgerJournalTrans::releaseNumber(ledgerJournalTable.JournalType, numberSequenceTable, _voucher);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseNumber</Name>
				<Source><![CDATA[
    internal static void releaseNumber(LedgerJournalType _journalType, NumberSequenceTable _numberSequenceTable, Voucher _voucher)
    {
        if (_journalType != LedgerJournalType::Periodic
                && _journalType != LedgerJournalType::VendInvoicePool
                && _numberSequenceTable)
        {
            if (_numberSequenceTable.Continuous)
            {
                if (NumberSeq::numCheckFormat(_voucher, _numberSequenceTable))
                {
                    NumberSeq::releaseNumber(_numberSequenceTable.RecId, _voucher);
                }
                else
                {
                    // The NumberSeq::numCheckFormat API displays a warning message if the number sequence format did not match
                    // remove the warning message to not introduce confusion to the end user.
                    int line = infolog.line();
                    infolog.clear(line-1);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    public static boolean exist(
        LedgerJournalId _ledgerJournalId,
        Voucher         _voucher,
        LineNum         _lineNum)
    {
        if (_ledgerJournalId == '' || _voucher == '')
        {
            return false;
        }

        LedgerJournalTrans ledgerJournalTrans;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalId
                && ledgerJournalTrans.Voucher == _voucher
                && ledgerJournalTrans.LineNum == _lineNum;

        return ledgerJournalTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForVoucherInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether a <c>LedgerJournalTrans</c> record exists for the specified values.
    /// </summary>
    /// <param name="_ledgerJournalId">
    /// The journal batch number.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice ID.
    /// </param>
    /// <returns>
    /// A value that indicates whether a <c>LedgerJournalTrans</c> record exists for the specified values.
    /// </returns>
    public static boolean existForVoucherInvoice(
        LedgerJournalId _ledgerJournalId,
        Voucher _voucher,
        InvoiceId _invoiceId)
    {
        if (_ledgerJournalId == '' || _voucher == '')
        {
            return false;
        }

        LedgerJournalTrans ledgerJournalTrans;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalId
                && ledgerJournalTrans.Voucher == _voucher
                && ledgerJournalTrans.Invoice == _invoiceId;

        return ledgerJournalTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existTransMinusThis</Name>
				<Source><![CDATA[
    public static boolean existTransMinusThis(
        LedgerJournalId _ledgerJournalId,
        Voucher         _voucher,
        RecId           _recId = 0)
    {
        if (_ledgerJournalId == '' || _voucher == '')
        {
            return false;
        }

        LedgerJournalTrans ledgerJournalTrans;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalId
                && ledgerJournalTrans.Voucher == _voucher
                && ledgerJournalTrans.RecId != _recId;

        return ledgerJournalTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existVoucher</Name>
				<Source><![CDATA[
    public static boolean existVoucher(
        LedgerJournalId _ledgerJournalId,
        Voucher         _voucher)
    {
        if (_ledgerJournalId == '' || _voucher == '')
        {
            return false;
        }

        LedgerJournalTrans ledgerJournalTrans;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalId
                && ledgerJournalTrans.Voucher == _voucher;

        return ledgerJournalTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    public static LedgerJournalTrans find(
        LedgerJournalId _ledgerJournalId,
        Voucher         _voucher,
        boolean         _forUpdate)

    {
        LedgerJournalTrans ledgerJournalTrans;

        if (_ledgerJournalId && _voucher)
        {
            ledgerJournalTrans.selectForUpdate(_forUpdate);

            select
                firstonly
                ledgerJournalTrans
                index NumVoucherIdx
                where ledgerJournalTrans.JournalNum == _ledgerJournalId &&
                        ledgerJournalTrans.Voucher    == _voucher;
        }
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>LedgerJournalTrans</c> table.
    /// </summary>
    /// <param name="_refCompany">
    /// The reference company of the record to find.
    /// </param>
    /// <param name="_ledgerJournalTransRecId">
    /// The reference record ID of the record to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>LedgerJournalTrans</c> table; otherwise, an empty record.
    /// </returns>
    public static LedgerJournalTrans findByRef(
        CompanyId _refCompany,
        RecId _ledgerJournalTransRecId,
        boolean _forUpdate = false)
    {
        LedgerJournalTrans ledgerJournalTrans;

        if (_refCompany != '' && _ledgerJournalTransRecId != 0)
        {
            ledgerJournalTrans.selectForUpdate(_forUpdate);

            select firstonly crossCompany ledgerJournalTrans
                where ledgerJournalTrans.Company == _refCompany &&
                    ledgerJournalTrans.RecId == _ledgerJournalTransRecId ;
        }
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRefAndDataArea</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>LedgerJournalTrans</c> table.
    /// </summary>
    /// <param name="_dataArea">
    /// The data area of the <c>LedgerJournalTrans</c> record to find.
    /// </param>
    /// <param name="_ledgerJournalTransRecId">
    /// The reference record ID of the <c>LedgerJournalTrans</c> record to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record from the <c>LedgerJournalTrans</c> table; otherwise, an empty record.
    /// </returns>
    public static LedgerJournalTrans findByRefAndDataArea(
        CompanyId _dataArea,
        RecId _ledgerJournalTransRecId,
        boolean _forUpdate = false)
    {
        LedgerJournalTrans ledgerJournalTrans;

        if (_dataArea != '' && _ledgerJournalTransRecId != 0)
        {
            ledgerJournalTrans.selectForUpdate(_forUpdate);

            select firstonly crossCompany ledgerJournalTrans
                where ledgerJournalTrans.DataAreaId == _dataArea &&
                    ledgerJournalTrans.RecId == _ledgerJournalTransRecId ;
        }

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByReverse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>LedgerJournalTrans</c> table by using the reverse reference.
    /// </summary>
    /// <param name="_reverseRecID">
    /// The reverse reference record ID of the <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record from the <c>LedgerJournalTrans</c> table; otherwise, an empty record.
    /// </returns>
    public static LedgerJournalTrans findByReverse(
        RecId   _reverseRecID,
        boolean _forUpdate = false)
    {
        LedgerJournalTrans ledgerJournalTrans;

        // Only run if the reversal record ID is specified
        if (_reverseRecID != 0)
        {
            ledgerJournalTrans.selectForUpdate(_forUpdate);

            // We add in `allowIndexHint(true)` as without it appends ORDER BY instead of suggesting clustered index
            ledgerJournalTrans.allowIndexHint(true);

            // Find fields associated with the ledger journal transaction with the suggested index hint
            // to avoid using the RecID index (causing long lookups)
            select firstonly ledgerJournalTrans
                index hint RevRecIdIdx
                where ledgerJournalTrans.RevRecId == _reverseRecID;
        }

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVoucherForIntercompanyPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the voucher for the payment, based on if the <c>LedgerJournalTrans</c>
    /// table record is a part of an payment that is intercompany.
    /// </summary>
    /// <returns>
    /// The voucher for the payment.
    /// </returns>
    /// <remarks>
    /// When a payment is intercompany, the voucher of the <c>LedgerJournalTrans</c>
    /// table record in the source company does not match the voucher on the
    /// corresponding <c>CustVendTrans</c> table record. It is necessary to get the
    /// <c>LedgerJournalTrans</c> table record from the destination company first.
    /// </remarks>
    public Voucher findVoucherForIntercompanyPayment()
    {
        Voucher voucherNumber;

        if (this.isCompanyIntercompany())
        {
            LedgerJournalTrans intercompanyLedgerJournalTrans;

            changecompany(this.Company)
            {
                select firstonly Voucher from intercompanyLedgerJournalTrans
                    where intercompanyLedgerJournalTrans.LedgerDimension == this.LedgerDimension
                        && intercompanyLedgerJournalTrans.ForeignCompany == this.DataAreaId
                        && intercompanyLedgerJournalTrans.ForeignVoucher == this.Voucher
                        && intercompanyLedgerJournalTrans.TransDate == this.TransDate;
            }

            if (intercompanyLedgerJournalTrans)
            {
                voucherNumber = intercompanyLedgerJournalTrans.Voucher;
            }
            else
            {
                voucherNumber = '';
            }
        }
        else
        {
            voucherNumber = this.Voucher;
        }

        return voucherNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findIntercompanyPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>LedgerJournalTrans</c> record from
    /// the operating company of an intercompany payment.
    /// </summary>
    /// <param name = "_ledgerJournalTransPaymentCompany">Payment transaction made in the payment company</param>
    /// <param name = "_forupdate">A Boolean value that indicates whether to read the record for update; optional.</param>
    /// <returns>Payment transaction created in the operating company.</returns>
    public static LedgerJournalTrans findIntercompanyPayment(LedgerJournalTrans _ledgerJournalTransPaymentCompany, boolean _forupdate = false)
    {
        LedgerJournalTrans ledgerJournalTransOperatingCompany;

        changecompany(_ledgerJournalTransPaymentCompany.Company)
        {
            ledgerJournalTransOperatingCompany.selectForUpdate(_forupdate);

            select firstonly ledgerJournalTransOperatingCompany
                where ledgerJournalTransOperatingCompany.LedgerDimension == _ledgerJournalTransPaymentCompany.LedgerDimension
                    && ledgerJournalTransOperatingCompany.ForeignCompany == _ledgerJournalTransPaymentCompany.DataAreaId
                    && ledgerJournalTransOperatingCompany.ForeignVoucher == _ledgerJournalTransPaymentCompany.Voucher
                    && ledgerJournalTransOperatingCompany.TransDate == _ledgerJournalTransPaymentCompany.TransDate;
        }

        return ledgerJournalTransOperatingCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findIntercompanyPaymentFromOperating</Name>
				<Source><![CDATA[
    public static LedgerJournalTrans findIntercompanyPaymentFromOperating(LedgerJournalTrans _ledgerJournalTransOperatingCompany, boolean _forupdate = false)
    {
        LedgerJournalTrans ledgerJournalTransPayment;

        changecompany(_ledgerJournalTransOperatingCompany.OffsetCompany)
        {
            ledgerJournalTransPayment.selectForUpdate(_forupdate);

            select firstonly ledgerJournalTransPayment
                where ledgerJournalTransPayment.LedgerDimension == _ledgerJournalTransOperatingCompany.LedgerDimension
                    && ledgerJournalTransPayment.DataAreaId == _ledgerJournalTransOperatingCompany.ForeignCompany
                    && ledgerJournalTransPayment.Voucher == _ledgerJournalTransOperatingCompany.ForeignVoucher
                    && ledgerJournalTransPayment.TransDate == _ledgerJournalTransOperatingCompany.TransDate;
        }

        return ledgerJournalTransPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByCustVendTrans</Name>
				<Source><![CDATA[
    public static LedgerJournalTrans findByCustVendTrans(CustVendTrans _custVendTrans, boolean _forupdate = false)
    {
        LedgerJournalTrans ledgerJournalTrans;

        if (_custVendTrans)
        {
            ledgerJournalTrans.selectForUpdate(_forUpdate);

            if (_custVendTrans.TableId == tableNum(CustTrans))
            {
                select firstonly ledgerJournalTrans
                    where ledgerJournalTrans.CustTransId == _custVendTrans.RecId;
            }
            else
            {
                select firstonly ledgerJournalTrans
                    where ledgerJournalTrans.VendTransId == _custVendTrans.RecId;
            }
        }

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findJournalForVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the specified record in the <c>LedgerJournalTrans</c> table, depending on the
    /// <c>Voucher</c> parameter and the <c>transDate</c> parameter.
    /// </summary>
    /// <param name="_voucherNum">
    /// The voucher number of the record to find.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date of the record to find.
    /// </param>
    /// <returns>
    /// The <c>LedgerJournalTrans</c> table buffer.
    /// </returns>
    public static LedgerJournalTrans findJournalForVoucher(Voucher _voucherNum, TransDate _transDate)
    {
        LedgerJournalTrans ledgerJournalTrans;

        select firstonly ledgerJournalTrans
                where ledgerJournalTrans.Voucher == _voucherNum &&
                ledgerJournalTrans.TransDate     == _transDate;

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerJournalId</Name>
				<Source><![CDATA[
    public static LedgerJournalTrans findLedgerJournalId(
        Voucher _voucher,
        boolean _forUpdate = false)
    {
        LedgerJournalTrans  ledgerJournalTrans;

        if (_voucher)
        {
            ledgerJournalTrans.selectForUpdate(_forUpdate);

            select firstonly ledgerJournalTrans
                where ledgerJournalTrans.Voucher    == _voucher;
        }

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecId</Name>
				<Source><![CDATA[
    public static LedgerJournalTrans findRecId(
        RecId   _recId,
        boolean _forUpdate)
    {
        LedgerJournalTrans ledgerJournalTrans;

        if (_recId)
        {
            ledgerJournalTrans.selectForUpdate(_forUpdate);

            select firstonly ledgerJournalTrans
                where ledgerJournalTrans.RecId == _recId;
        }
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTaxSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines which <c>LedgerJournalTrans</c> record in an intercompany document is the tax obligation source company.
    /// </summary>
    /// <param name="_journalBatchNumber">
    ///    The journal batch number.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher.
    /// </param>
    /// <param name="_isIntercompanyJournal">
    ///    true if this is an intercompany journal; otherwise, false.
    /// </param>
    /// <param name="_primaryJournalVoucher">
    ///    The voucher for the primary journal.  Used in intercompany scenarios to ensure we get the original journal and voucher when
    ///    invoked on an intercompany journal.
    /// </param>
    /// <param name="_returnNullForSingleCompany">
    ///    A parameter determining whether this method should return null in the case when all lines on the given journal/voucher are for the same
    ///    company. This is useful if an alternative algorithm for determining source company exists as a fallback. When this parameter is set to false
    ///    and all journal/voucher lines have the current company as both source and destination, any of the matching lines will be returned.
    /// </param>
    /// <returns>
    ///   The source company.
    /// </returns>
    /// <remarks>
    ///   The source company is the company where the payable to the vendor or receivable
    ///   to the customer, vendor, or bank is recorded.  If multiple sources are used on the document then
    ///   the order of priority is Vendor, Customer, and then Bank.
    /// </remarks>
    public static LedgerJournalTrans findTaxSource(LedgerJournalId _journalBatchNumber, Voucher _voucher, boolean _isIntercompanyJournal = false, Voucher _primaryJournalVoucher = '', boolean _returnNullForSingleCompany = true)
    {
        LedgerJournalTrans ledgerJournalTrans;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _journalBatchNumber &&
                ((ledgerJournalTrans.Voucher == _voucher &&
                !_isIntercompanyJournal) ||
                (ledgerJournalTrans.ForeignVoucher == _primaryJournalVoucher &&
                _isIntercompanyJournal)) &&
                (ledgerJournalTrans.Company != curext() ||
                ledgerJournalTrans.OffsetCompany != curext());

        // if this isn't an intercompany scenario then no need to execute the queries below
        // whether we treat it as "source" or "destination" in this scenario will make no difference
        // in terms of functionality except that treating it as "destination" will perform better.
        if (ledgerJournalTrans)
        {
            // if multiline scenario check for Vend/Cust.  If both Vend/Cust are used then
            // we need to use order by account type to select Vend first.
            select firstonly * from ledgerJournalTrans
                order by Invoice, AccountType desc, RecId
                where ledgerJournalTrans.JournalNum == _journalBatchNumber &&
                    ((ledgerJournalTrans.Voucher == _voucher &&
                    !_isIntercompanyJournal) ||
                    (ledgerJournalTrans.ForeignVoucher == _primaryJournalVoucher &&
                    _isIntercompanyJournal)) &&
                    (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
                    ledgerJournalTrans.AccountType == LedgerJournalACType::Cust);

            if (ledgerJournalTrans == null)
            {
                // check for single line scenario where vend/cust is the offset account type.
                select firstonly * from ledgerJournalTrans
                    order by Invoice, OffsetAccountType desc, RecId
                    where ledgerJournalTrans.JournalNum == _journalBatchNumber &&
                        ((ledgerJournalTrans.Voucher == _voucher &&
                        !_isIntercompanyJournal) ||
                        (ledgerJournalTrans.ForeignVoucher == _primaryJournalVoucher &&
                        _isIntercompanyJournal)) &&
                        (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend ||
                        ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust);
            }

            if (ledgerJournalTrans == null)
            {
                // Bank is the lowest priority for a source.  If Bank is not found then we will return
                // an empty record since there is no source.
                select firstonly * from ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum == _journalBatchNumber &&
                        ((ledgerJournalTrans.Voucher == _voucher &&
                        !_isIntercompanyJournal) ||
                        (ledgerJournalTrans.ForeignVoucher == _primaryJournalVoucher &&
                        _isIntercompanyJournal)) &&
                        (ledgerJournalTrans.AccountType == LedgerJournalACType::Bank ||
                        ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank);
            }
        }
        else if (!_returnNullForSingleCompany)
        {
            select firstonly * from ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum == _journalBatchNumber &&
                        ((ledgerJournalTrans.Voucher == _voucher &&
                        !_isIntercompanyJournal) ||
                        (ledgerJournalTrans.ForeignVoucher == _primaryJournalVoucher &&
                        _isIntercompanyJournal));
        }

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTmpVoucher</Name>
				<Source><![CDATA[
    public static Voucher findTmpVoucher(
        Voucher _voucher,
        Map     _tmpVoucherMap)
    {
        Voucher tmpVoucher;

        if (_tmpVoucherMap && _tmpVoucherMap.exists(_voucher))
        {
            tmpVoucher = _tmpVoucherMap.lookup(_voucher);
        }
        else
        {
            tmpVoucher = _voucher;
        }

        return tmpVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVendTransId</Name>
				<Source><![CDATA[
    public static RecId findVendTransId(
        LedgerJournalId _ledgerJournalId,
        Voucher         _voucher)
    {
        LedgerJournalTrans  ledgerJournalTrans;

        select firstonly VendTransId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalId
               && ledgerJournalTrans.Voucher    == _voucher
               && ledgerJournalTrans.VendTransId;

        return ledgerJournalTrans.VendTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualAndCalculatedTaxForSingleLineIL</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the actual and calculated tax amount for the specified line.
    /// </summary>
    /// <param name="_params">
    ///    A container holding the <c>LedgerJournalTtrans</c> record and a value that indicates whether to include the use tax.
    /// </param>
    /// <returns>
    ///   A container holding the actual and calculated tax amount.
    /// </returns>
    /// <remarks>
    ///   This method exists so calls can transition to IL before computing taxes. The standard
    ///   API consumers should use is LedgerJournalTrans.getCalculatedAndActualTaxForSingleLine().
    /// </remarks>
    private static container getActualAndCalculatedTaxForSingleLineIL(container _params)
    {
        LedgerJournalTable ledgerJournalTable;
        TaxCalculation taxCalculation;
        LedgerJournalTrans ledgerJournalTrans;
        boolean includeUseTax;
        TaxAmountCur actualTax, calculatedTax;

        // Unpack incoming parameters
        [ledgerJournalTrans, includeUseTax] = _params;

        ledgerJournalTable = ledgerJournalTrans.ledgerJournalTable();

        ledgerJournalTrans.DelayTaxCalculation = ledgerJournalTable.DelayTaxCalculation;

        if (!(ledgerJournalTrans.DelayTaxCalculation
                || ledgerJournalTable.isTaxIntegrationEnabled())
            && (!ledgerJournalTrans.RecId
                || !TaxUncommitted::existByDocumentAndInvoice(tableNum(LedgerJournalTable), ledgerJournalTable.RecId, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice)))
        {
            taxCalculation = LedgerJournalTrans::getTaxInstance(ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice, false, ledgerJournalTrans);

            if (includeUseTax)
            {
                actualTax = taxCalculation.totalRegTaxAmountSingleLineIncludeUseTax(tableNum(LedgerJournalTrans), ledgerJournalTrans.RecId, false);
            }
            else
            {
                actualTax = taxCalculation.totalRegulatedTaxAmountSingleLine(tableNum(LedgerJournalTrans), ledgerJournalTrans.RecId);
            }

            calculatedTax = taxCalculation.totalTaxAmountSingleLine(tableNum(LedgerJournalTrans), ledgerJournalTrans.RecId, false, includeUseTax);
        }
        else
        {
            actualTax = TaxUncommitted::getActualTaxAmountForSourceLineWithCompany(tableNum(LedgerJournalTrans), ledgerJournalTrans.RecId, includeUseTax, true);
            calculatedTax = TaxUncommitted::getCalculatedTaxAmountForSourceLine(tableNum(LedgerJournalTrans), ledgerJournalTrans.RecId, includeUseTax);
        }

        return [actualTax, calculatedTax];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForLedgerTypeServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger account for the default account.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The default account.
    /// </param>
    /// <param name="_company">
    /// The company ID of the default account.
    /// </param>
    /// <param name="_ledgerJournalTable">
    /// The header for the transaction.
    /// </param>
    /// <returns>
    /// The ledger account.
    /// </returns>
    /// <remarks>
    /// This method mirrors the <c>getLedgerDimensionForLedgerType</c> method but is guaranteed to run on
    /// the server.
    /// </remarks>
    private static LedgerDimensionAccount getLedgerDimensionForLedgerTypeServer(
        LedgerDimensionDefaultAccount   _ledgerDimension,
        CompanyId                       _company,
        LedgerJournalTable              _ledgerJournalTable)
    {
        LedgerDimensionAccount mergedLedgerDimension;
        List dimensionSources;

        Debug::assert(_ledgerDimension);

        changecompany(_company)
        {
            // Get dimensions from journal header
            dimensionSources = new List(Types::Class);
            if (_company == _ledgerJournalTable.company())
            {
                dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_ledgerJournalTable.DefaultDimension));
            }

            // Get dimensions from main account
            LedgerDimensionDefaultingEngine::addDefaultDimensionForLedgerDimension(dimensionSources, _ledgerDimension);

            mergedLedgerDimension = LedgerDimensionDefaultingEngine::createLedgerDimension(_ledgerDimension, dimensionSources);
        }

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetLedgerDimForLedgerTypeServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the offset ledger account for the default account.
    /// </summary>
    /// <param name="_defaultLedgerDimension">
    /// The default account.
    /// </param>
    /// <param name="_offsetCompany">
    /// The company ID of the default account.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The ledger account.
    /// </returns>
    /// <remarks>
    /// This method mirrors the <c>getOffsetLedgerDimForLedgerTypeServer</c> method
    /// but is guaranteed to run on the server.
    /// </remarks>
    private static LedgerDimensionAccount getOffsetLedgerDimForLedgerTypeServer(
        LedgerDimensionDefaultAccount   _defaultLedgerDimension,
        CompanyId                       _offsetCompany,
        LedgerJournalTrans              _ledgerJournalTrans)
    {
        LedgerDimensionAccount  mergedLedgerDimension;
        List                    dimensionSources;
        Map                     primaryDimensionSpecifiers;

        Debug::assert(_defaultLedgerDimension);

        changecompany(_offsetCompany)
        {
            // Get dimension values from the primary side
            dimensionSources = new List(Types::Class);
            primaryDimensionSpecifiers = null;
            if (_ledgerJournalTrans.Company == _offsetCompany)
            {
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
                {
                    if (_ledgerJournalTrans.LedgerDimension)
                    {
                        primaryDimensionSpecifiers = LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(_ledgerJournalTrans.LedgerDimension, true);
                    }
                }
                else
                {
                    if (_ledgerJournalTrans.DefaultDimension)
                    {
                        primaryDimensionSpecifiers = LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_ledgerJournalTrans.DefaultDimension);
                    }
                }
            }
            if (primaryDimensionSpecifiers)
            {
                dimensionSources.addEnd(primaryDimensionSpecifiers);
            }

            // Get dimensions from main account
            LedgerDimensionDefaultingEngine::addDefaultDimensionForLedgerDimension(dimensionSources, _defaultLedgerDimension);

            mergedLedgerDimension = LedgerDimensionDefaultingEngine::createLedgerDimension(_defaultLedgerDimension, dimensionSources);
        }

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetLedgerDimForProposalServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the offset ledger account for the default account for a proposal.
    /// </summary>
    /// <param name="_defaultLedgerDimension">
    /// The default account.
    /// </param>
    /// <param name="_accountNumber">
    /// The account number of the entity.
    /// </param>
    /// <param name="_accountType">
    /// The account type of the entity.
    /// </param>
    /// <param name="_assetBookId">
    /// The asset book ID.
    /// </param>
    /// <param name="_ledgerJournalTable">
    /// The header for the transaction.
    /// </param>
    /// <returns>
    /// The ledger account.
    /// </returns>
    /// <remarks>
    /// This method mirrors the <c>getOffsetLedgerDimensionForProposal</c> method
    /// but is guaranteed to run on the server.
    /// </remarks>
    private static LedgerDimensionAccount getOffsetLedgerDimForProposalServer(
        LedgerDimensionDefaultAccount   _defaultLedgerDimension,
        LedgerJournalAC                 _accountNumber,
        LedgerJournalACType             _accountType,
        AssetBookIdPurchSalesInvent     _assetBookId,
        LedgerJournalTable              _ledgerJournalTable)
    {
        LedgerDimensionAccount  mergedLedgerDimension;
        List                    dimensionSources;
        DimensionDefault        defaultDimension;

        if (_defaultLedgerDimension == 0)
        {
            return 0;
        }

        // Get dimensions from journal header (everything should be in the current company)
        dimensionSources = new List(Types::Class);
        dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_ledgerJournalTable.DefaultDimension));

        // Get dimensions from the entity
        defaultDimension = LedgerJournalEngine::getAccountDefaultDimension(_accountNumber, curext(), _accountType, _assetBookId);
        if (defaultDimension)
        {
            dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(defaultDimension));
        }

        // Get dimensions from main account
        LedgerDimensionDefaultingEngine::addDefaultDimensionForLedgerDimension(dimensionSources, _defaultLedgerDimension);

        mergedLedgerDimension = LedgerDimensionDefaultingEngine::createLedgerDimension(_defaultLedgerDimension, dimensionSources);

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxInstance</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets an instance of <c>TaxCalculation</c> with the tax lines loaded into <c>TmpTaxWorkTrans</c>.
    /// </summary>
    /// <param name="_journalNum">
    ///    The journal number.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher.
    /// </param>
    /// <param name="_invoiceId">
    ///    The invoice ID.
    /// </param>
    /// <param name="_persistToTaxUncommitted">
    ///    true if calculated taxes should be persisted to the <c>TaxUncommitted</c> table; otherwise, false.
    /// </param>
    /// <param name="_unsavedLedgerJournalTrans">
    ///    If a <c>LedgerJournalTrans</c> record is unsaved then it needs to be passed
    ///    into so that the new values may be considered for tax calculations.
    /// </param>
    /// <param name="_forceTaxable_RU">
    ///    true if taxes should be calculated for purpose text building; otherwise, false.
    /// </param>
    /// <param name="_transDate">
    ///    The transaction date.
    /// </param>
    /// <param name="_taxRateDateOverride">
    ///    The date to be used in overriding the default date when retrieving the tax rate for tax calculation.
    /// </param>
    /// <returns>
    ///   An instance of the <c>TaxCalculation</c> class.
    /// </returns>
    public static TaxCalculation getTaxInstance(
        LedgerJournalId     _journalNum,
         Voucher            _voucher,
        InvoiceId          _invoiceId,
        boolean            _persistToTaxUncommitted,
        LedgerJournalTrans _unsavedLedgerJournalTrans = null,
        boolean            _forceTaxable_RU = false,
        TransDate          _transDate = dateNull(),
        TransDate          _taxRateDateOverride = dateNull()
        )
        {
        TaxCalculation taxCalculation;
        LedgerJournalTaxDocument ledgerJournalTaxDocument;
        DataAreaId dataAreaId;
        #ISOCountryRegionCodes
        LedgerJournalTrans ledgeJournalTrans;
        LedgerJournalTrans ledgerJournalTransServiceTax;
        TaxItemGroupHeading taxItemGroupHeadingPOTRev;
        boolean            iscentralizedAdvancePayment;
        boolean            countryRegionIN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

        if (countryRegionIN)
        {
            ledgeJournalTrans = LedgerJournalTrans::findJournalForVoucher(_voucher, _transDate);
            ledgerJournalTransServiceTax = _unsavedLedgerJournalTrans.RecId ? _unsavedLedgerJournalTrans : ledgeJournalTrans;
            iscentralizedAdvancePayment = LedgerJournalTrans_IN_Extension::isCentralizedAdvancePayment_IN(ledgerJournalTransServiceTax);
        }
        if (iscentralizedAdvancePayment)
        {
            ledgerJournalTaxDocument = LedgerJournalTaxDocument::construct(_journalNum, _voucher, _invoiceId, ledgerJournalTransServiceTax);
            ledgerJournalTaxDocument.parmServTaxCentralizedPayment_IN(iscentralizedAdvancePayment);
        }
        else
        {
            ledgerJournalTaxDocument = LedgerJournalTaxDocument::construct(_journalNum, _voucher, _invoiceId, _unsavedLedgerJournalTrans);
        }
        ledgerJournalTaxDocument.parmForceTaxable_RU(_forceTaxable_RU);
        ledgerJournalTaxDocument.parmTaxRateDateOverride(_taxRateDateOverride);

        LedgerJournalTable ledgerJournalTable = LedgerJournalTable::find(_journalNum);
        if (ledgerJournalTaxDocument.shouldDeleteTaxForPrepayment(ledgerJournalTable))
        {
            TaxUncommitted::deleteForInvoice(tableNum(LedgerJournalTable), ledgerJournalTable.RecId, _voucher, _invoiceId);
            if (countryRegionIN)
            {
                TaxUncommitted::deleteForDocumentLine(ledgerJournalTransServiceTax.TableId, ledgerJournalTransServiceTax.RecId);
            }
        }
        if (iscentralizedAdvancePayment)
        {
            dataAreaId = (ledgerJournalTransServiceTax.Company != '') ? ledgerJournalTransServiceTax.Company : curext();
        }
        else
        {
            dataAreaId = curext();
        }
        changecompany(dataAreaId)
        {
            if (countryRegionIN)
            {
                TaxUncommitted::deleteForDocumentLine(ledgerJournalTransServiceTax.TableId, ledgerJournalTransServiceTax.RecId);
            }
            if (_persistToTaxUncommitted)
            {
                taxCalculation = TaxCalculation::newForSourceTypeWithTaxUncommitted(TaxSourceType::Journals, ledgerJournalTaxDocument, true, false);

                ledgeJournalTrans = LedgerJournalTrans::findJournalForVoucher(_voucher, _transDate);
                taxCalculation.parmExchRate(ledgeJournalTrans.exchRate);
                taxCalculation.parmExchRateSecond(ledgeJournalTrans.ExchRateSecond);
                taxCalculation.parmReportingCurrencyExchRate(ledgeJournalTrans.ReportingCurrencyExchRate);
                taxCalculation.parmReportingCurrencyExchRateSecondary(ledgeJournalTrans.ReportingCurrencyExchRateSecondary);

                if (iscentralizedAdvancePayment)
                {
                    taxCalculation.parmLedgerJournalTrans_IN(ledgerJournalTransServiceTax);
                }
                if (!taxCalculation.taxExists())
                {
                    if (countryRegionIN)
                    {
                        taxItemGroupHeadingPOTRev = TaxItemGroupHeading::find(ledgerJournalTransServiceTax.TaxItemGroup);
                        if (taxItemGroupHeadingPOTRev.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                            && taxItemGroupHeadingPOTRev.ReverseChargePercentage_IN == 0
                            && !(ledgerJournalTransServiceTax.TaxGroup
                                && ledgerJournalTransServiceTax.TaxItemGroup
                                && ledgerJournalTransServiceTax.isTaxable()))
                        {
                            return taxCalculation;
                        }
                        taxCalculation.parmLedgerJournalTrans_IN(ledgerJournalTransServiceTax);
                    }
                    taxCalculation.calculateTax();
                    TaxUseTaxAssessmentUtil::adjustSalesTaxFromVendorChargedSalesTax(LedgerJournalTrans::findVendLedgerJournalTrans(_journalNum, _voucher, _transDate), taxCalculation);
                }
                else
                {
                    if (ledgerJournalTaxDocument.shouldDeleteTaxForPrepayment(ledgerJournalTable))
                    {
                        if (TaxUncommitted::existByDocumentAndInvoice(tableNum(LedgerJournalTable), ledgerJournalTable.RecId, _voucher, _invoiceId))
                        {
                            TaxUncommitted::deleteForInvoice(tableNum(LedgerJournalTable), LedgerJournalTable::find(_journalNum).RecId, _voucher, _invoiceId);
                        }
                    }
                    if (ledgerJournalTransServiceTax.isPaymentJournal_IN()
                        && (TaxItemGroupHeading::find(ledgerJournalTransServiceTax.TaxItemGroup).ServiceTaxBasis_IN !=ServiceTaxBasis_IN::None))
                    {
                        _voucher = TaxSettlement_IN::determineRelatedVoucher(_voucher, ledgerJournalTransServiceTax.TransDate);
                        TaxUncommitted::deleteForInvoice(tableNum(LedgerJournalTable), LedgerJournalTable::find(_journalNum).RecId, _voucher, '');
                    }
                }
            }
            else
            {
                taxCalculation = TaxCalculation::newForSourceType(TaxSourceType::Journals, ledgerJournalTaxDocument);
                if (iscentralizedAdvancePayment)
                {
                    taxCalculation.parmLedgerJournalTrans_IN(ledgerJournalTransServiceTax);
                }
                // </GIN>
                taxCalculation.calculateTax();
            }
        }

        return taxCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransDateByReverse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the transDate in the <c>LedgerJournalTrans</c> table by using the reverse reference.
    /// </summary>
    /// <param name="_reverseRecID">
    /// The reverse reference record ID of the <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// TransDate from the <c>LedgerJournalTrans</c> table.
    /// </returns>
    public static TransDate getTransDateByReverse(RecId _reverseRecID)
    {
        LedgerJournalTrans ledgerJournalTrans;

        if (_reverseRecID != 0)
        {
            select firstonly TransDate from ledgerJournalTrans
                index hint RevRecIdIdx
                where ledgerJournalTrans.RevRecId == _reverseRecID;
        }

        return ledgerJournalTrans.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLegalEntityInCountryRegionForDelAct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether any of the country specific delete
    /// action tables of the <c>LedgerJournalTrans</c> table are in scope.
    /// </summary>
    /// <returns>
    /// true if any of the country specific delete action tables of the
    /// <c>LedgerJournalTrans</c> table are in scope.
    /// </returns>
    /// <remarks>
    /// Only the country specific delete action tables are checked.
    /// </remarks>
    public static boolean isLegalEntityInCountryRegionForDelAct()
    {
        SysDictTable dictTable;
        SysDictTable dictTableDeleteAction;
        container regionCodes;
        int i;

        dictTable = new SysDictTable(tableNum(LedgerJournalTrans));
        for (i = 1; i <= dictTable.deleteActionCnt(); i++)
        {
            dictTableDeleteAction = new SysDictTable(dictTable.deleteActionTableId(i));
            regionCodes = dictTableDeleteAction.getCountryRegionCodes();
            if (regionCodes != conNull())
            {
                if (SysCountryRegionCode::isLegalEntityInCountryRegion(regionCodes))
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the first line number of a ledger journal.
    /// </summary>
    /// <param name="_ledgerJournalId">
    /// A ledger journal number.
    /// </param>
    /// <returns>
    /// The line number of the first line in the ledger journal, if one exists; otherwise, zero.
    /// </returns>
    public static LineNum firstLineNum(LedgerJournalId _ledgerJournalId)
    {
        LedgerJournalTrans ledgerJournalTrans;

        if (_ledgerJournalId)
        {
            select firstonly LineNum from ledgerJournalTrans
                order by LineNum asc
                where ledgerJournalTrans.JournalNum == _ledgerJournalId;
        }

        return ledgerJournalTrans.LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last line number of a ledger journal.
    /// </summary>
    /// <param name="_ledgerJournalId">
    /// A ledger journal number.
    /// </param>
    /// <returns>
    /// The line number of the last line in the ledger journal, if one exists; otherwise, zero.
    /// </returns>
    public static LineNum lastLineNum(LedgerJournalId _ledgerJournalId)
    {
        return (select maxof(LineNum) from ledgerJournalTrans
                   where ledgerJournalTrans.JournalNum == _ledgerJournalId).LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTransPool</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>LedgerJournalTrans</c> table record that represents an AP invoice pool.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgetJournalTrans</c> table record representing an AP Invoice Pool, or its corresponding Approval Journal.
    /// </param>
    /// <returns>
    /// A <c>LedgerJournalTrans</c> table record representing an AP Invoice Pool.
    /// </returns>
    public static LedgerJournalTrans ledgerJournalTransPool(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans      ledgerJournalTransPool;
        LedgerJournalId         vendInvoicePoolJournalNum = LedgerJournalTable::findVendorInvoicePool().JournalNum;

        // If the ledgerJournalTrans has the Invoice Pool JournalId, and AccountType of Vend, then this is the Invoice Pool
        if (_ledgerJournalTrans.JournalNum == vendInvoicePoolJournalNum && _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            ledgerJournalTransPool = _ledgerJournalTrans;
        }
        // If the ledgerJournalTrans we have isn't the Invoice Pool, then it is the Approval Journal;  Get the Invoice Pool
        else
        {
            LedgerJournalVoucherChanged ledgerJournalVoucherChanged = LedgerJournalVoucherChanged::find(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher);

            select firstonly ledgerJournalTransPool
                where ledgerJournalTransPool.JournalNum   == vendInvoicePoolJournalNum
                   && ledgerJournalTransPool.Voucher      == ledgerJournalVoucherChanged.FromVoucher
                   && ledgerJournalTransPool.AccountType  == LedgerJournalACType::Vend
                   && ledgerJournalTransPool.Invoice      == _ledgerJournalTrans.Invoice;
        }

        return ledgerJournalTransPool;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTransRegister</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a record in the <c>LedgerJournalTrans</c> table that represents an AP invoice register.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A record in the <c>LedgetJournalTrans</c> table that represents an AP invoice pool or its
    /// corresponding approval journal.
    /// </param>
    /// <returns>
    /// A record in the <c>LedgerJournalTrans</c> table that represents an AP invoice register.
    /// </returns>
    public static LedgerJournalTrans ledgerJournalTransRegister(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans      ledgerJournalTrans;
        LedgerJournalId         vendInvoicePoolJournalNum = LedgerJournalTable::findVendorInvoicePool().JournalNum;

        select firstonly ledgerJournalTrans
            where ledgerJournalTrans.JournalNum   != vendInvoicePoolJournalNum
                && ledgerJournalTrans.Voucher     == _ledgerJournalTrans.Voucher
                && ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                && ledgerJournalTrans.Invoice     == _ledgerJournalTrans.Invoice;

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mainAccount</Name>
				<Source><![CDATA[
    public static LedgerJournalTrans mainAccount(
        LedgerJournalId    _ledgerJournalId,
        Voucher            _voucher)
    {
        LedgerJournalTrans  ledgerJournalTrans;

        select firstonly ledgerJournalTrans
            where ledgerJournalTrans.JournalNum     == _ledgerJournalId
               && ledgerJournalTrans.Voucher        == _voucher
               && (ledgerJournalTrans.AccountType   == LedgerJournalACType::Cust ||
                   ledgerJournalTrans.AccountType   == LedgerJournalACType::Vend ||
                   ledgerJournalTrans.AccountType   == LedgerJournalACType::Project ||
                   ledgerJournalTrans.AccountType   == LedgerJournalACType::FixedAssets);

        if (!ledgerJournalTrans)
        {
            select firstonly ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalId
                   && ledgerJournalTrans.Voucher    == _voucher;
        }
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>revertBankChequeNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds <c>LedgerJournalTrans</c> records and sets their check number to empty.
    /// </summary>
    /// <param name="_transDate">
    /// The transaction date to find records for.
    /// </param>
    /// <param name="_voucher">
    /// The voucher to find records for.
    /// </param>
    /// <param name="_bankChequeNum">
    /// The check number to find records for.
    /// </param>
    /// <param name="_journalNum">
    /// The journal number of a <c>LedgerJournalTrans</c> record that should be skipped; optional.
    /// </param>
    /// <remarks>
    /// This method is used by the check reversal process.
    /// </remarks>
    [SysObsolete ('The cheque number should remain on the payment journal during the cancellation process.',false, 30\06\2020)]
    public static void revertBankChequeNum(TransDate _transDate,
        Voucher         _voucher,
        BankChequeNum   _bankChequeNum,
        LedgerJournalId _journalNum = '')
    {

    }

]]></Source>
			</Method>
			<Method>
				<Name>splitCreateNewVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Split and create a new voucher.
    /// </summary>
    /// <param name = "_ledgerJournalId">The journal number.</param>
    /// <returns>The new voucher.</returns>
    public static Voucher splitCreateNewVoucher(LedgerJournalId _ledgerJournalId)
    {
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalName   ledgerJournalName;
        LedgerJournalTrans  ledgerJournalTrans;

        select firstonly JournalNum from ledgerJournalTable
            where ledgerJournalTable.JournalNum == _ledgerJournalId
        join firstonly NewVoucher from ledgerJournalName
            where ledgerJournalName.JournalName == ledgerJournalTable.JournalName;

        if (ledgerJournalName.NewVoucher == NewVoucher::OneVoucher)
        {
            select firstonly Voucher from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalId;

            if (ledgerJournalTrans)
            {
                return ledgerJournalTrans.Voucher;
            }
        }

        return new JournalVoucherNum(JournalTableData::newTable(LedgerJournalTable::find(_ledgerJournalId))).getNew(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountSingleLineIL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for the current line.
    /// </summary>
    /// <param name="_params">
    /// A container that contains the parameters <paramref name="LedgerJournalTrans" />, <paramref
    /// name="IncludeActualTax" />, <paramref name="IncludeUseTax" />, and <paramref
    /// name="UseTransactionalCurrency" />.
    /// </param>
    /// <returns>
    /// A container that contains the tax amount for the current line.
    /// </returns>
    /// <remarks>
    /// This method exists so calls can transition to IL before computing taxes. API consumers should use
    /// the <c>LedgerJournalTrans.totalTaxAmountSingleLine</c> method.
    /// </remarks>
    private static container totalTaxAmountSingleLineIL(container _params)
    {
        LedgerJournalTable ledgerJournalTable;
        TaxCalculation taxCalculation;
        LedgerJournalTrans ledgerJournalTrans;
        boolean includeActualTax;
        boolean includeUseTax;
        boolean useTransactionalCurrency;
        LedgerJournalTransTaxExtension ledgerJournalTransTaxExtension;

        // Unpack incoming parameters
        [ledgerJournalTrans, includeActualTax, includeUseTax, useTransactionalCurrency, ledgerJournalTransTaxExtension] = _params;
        ledgerJournalTrans.packExtensionTable(ledgerJournalTransTaxExtension);

        if (!includeActualTax && !useTransactionalCurrency)
        {
            Error::wrongUseOfFunction(funcName());
        }

        ledgerJournalTable = ledgerJournalTrans.ledgerJournalTable();

        ledgerJournalTrans.DelayTaxCalculation = ledgerJournalTable.DelayTaxCalculation;

        boolean shouldDelayForTaxIntegration = TaxIntegrationTaxCalculationNoDelayContext::current() == null
            && ledgerJournalTable.isTaxIntegrationEnabled();

        if (!(ledgerJournalTrans.DelayTaxCalculation || shouldDelayForTaxIntegration)
            && (!TaxUncommitted::existByDocumentAndInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice)
                || !ledgerJournalTrans.RecId))
        {
            taxCalculation = LedgerJournalTrans::getTaxInstance(ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice, false, ledgerJournalTrans
            , false, ledgerJournalTrans.TransDate//Service tax
            );

            if (includeActualTax)
            {
                if (includeUseTax)
                {
                    return [taxCalculation.totalRegTaxAmountSingleLineIncludeUseTax(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId, false)];
                }
                else
                {
                    return [taxCalculation.totalRegulatedTaxAmountSingleLine(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId)];
                }
            }
            else
            {
                return [taxCalculation.totalTaxAmountSingleLine(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId, false, includeUseTax)];
            }
        }

        if (includeActualTax)
        {
            return [TaxUncommitted::getActualTaxAmountForSourceLineWithCompany(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId, includeUseTax, useTransactionalCurrency)];
        }
        else
        {
            return [TaxUncommitted::getCalculatedTaxAmountForSourceLine(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId, includeUseTax)];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateApproveJBAPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates field approved and approver according to the journal number
    /// </summary>
    /// <param name="_approver">
    /// The approver who approved journal transaction.
    /// </param>
    /// <param name="_journalNum">
    /// The journal number.
    /// </param>
    /// <remarks>
    /// For Japan feature JBA bank format.
    /// </remarks>
    public static void updateApproveJBAPayment(
        HcmApprover     _approver,
        LedgerJournalId _journalNum)
    {
        LedgerJournalTrans  ledgerJournalTrans;

        if (!_approver)
        {
            return;
        }

        ttsbegin;
        ledgerJournalTrans.skipDataMethods(true);

        update_recordset ledgerJournalTrans
            setting Approved   = NoYes::Yes,
                Approver = _approver
        where ledgerJournalTrans.JournalNum == _journalNum;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDisplayValueForPrimaryAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the display value of the primary account.
    /// </summary>
    /// <returns>The primary account display value.</returns>
    public DimensionDisplayValue getDisplayValueForPrimaryAccount()
    {
        return LedgerDimensionFacade::getDisplayValueForLedgerDimension(this.LedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDisplayValueForOffsetAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the display value of the offset account.
    /// </summary>
    /// <returns>The offset account display value.</returns>
    public DimensionDisplayValue getDisplayValueForOffsetAccount()
    {
        return LedgerDimensionFacade::getDisplayValueForLedgerDimension(this.OffsetLedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>configureForSkipDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the <c>skip</c> methods that are relevant when doing inserts or deletes.
    /// </summary>
    public void configureForSkipDelete()
    {
        this.skipDataMethods(true);
        this.skipDeleteActions(true);
        this.skipDeleteMethod(true);
        this.skipEvents(true);
        this.skipPostLoad(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendBankAccountInTransactionCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets vendor bank account in the company where the current line will be posted.
    /// </summary>
    /// <returns><c>VendBankAccount</c> for vendor.</returns>
    public VendBankAccount vendBankAccountInTransactionCompany()
    {
        return VendBankAccount::findByCompany(this.Company, this.parmAccount(), this.CustVendBankAccountId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>custBankAccountInTransactionCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets customer bank account in the company where the current line will be posted.
    /// </summary>
    /// <returns><c>CustBankAccount</c> for customer.</returns>
    public CustBankAccount custBankAccountInTransactionCompany()
    {
        return CustBankAccount::findByCompany(this.Company, this.parmAccount(), this.CustVendBankAccountId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustDirectDebitMandates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all <c>CustDirectDebitMandate</c> records linked with current record.
    /// </summary>
    /// <returns><c>RecordLinkList</c> containing all found records.</returns>
    [ERTableName(tableStr(CustDirectDebitMandate))]
    public RecordLinkList getCustDirectDebitMandates()
    {
        SpecTrans                 specTrans;
        CustTransOpen             custTransOpen;
        CustTrans                 custTrans;
        CustDirectDebitMandate    custDirectDebitMandate;
        CustTrans                 custTransInvoice;
        CustBillOfExchangeInvoice custBillOfExchangeInvoice;
        RecordLinkList          recordList = new RecordLinkList();

        if (this.DirectDebitMandate)
        {
            recordList.ins(CustDirectDebitMandate::findByCompany(this.company, this.DirectDebitMandate));
            return recordList;
        }

        boolean paymentTypeBillOfExchangeExists = false;

        RefRecId custTransRecId;
        SpecTransDirectDebitMandate_W specTransDirectDebitMandate;

        while select crosscompany specTransDirectDebitMandate
            where specTransDirectDebitMandate.SpecCompany == this.DataAreaId
                && specTransDirectDebitMandate.SpecRecId == this.RecId
                && specTransDirectDebitMandate.SpecTableId == this.TableId
        join custDirectDebitMandate
            where custDirectDebitMandate.RecId == specTransDirectDebitMandate.DirectDebitMandate
        {
            if (custTransRecId != specTransDirectDebitMandate.CustTransRecId)
            {
                if (!specTransDirectDebitMandate.BillOfExchangeID)
                {
                    recordList.ins(custDirectDebitMandate);
                }
                else
                {
                    paymentTypeBillOfExchangeExists = true;
                }

                custTransRecId = specTransDirectDebitMandate.CustTransRecId;
            }
        }

        if (paymentTypeBillOfExchangeExists)
        {
            CustSettlement custSettlementInvoice;
            CustTrans custTransBillOfExchange;
            while select crosscompany custDirectDebitMandate
                join RecId from custTransInvoice
                    where custTransInvoice.DirectDebitMandate == custDirectDebitMandate.RecId
                        && custTransInvoice.BillOfExchangeID
                join TableId from custSettlementInvoice
                    where custSettlementInvoice.OffsetRecid == custTransInvoice.RecId
                exists join TableId from custTransBillOfExchange
                    where custTransBillOfExchange.RecId == custSettlementInvoice.TransRecId
                exists join TableId from custBillOfExchangeInvoice
                    where custBillOfExchangeInvoice.InvoiceId == custTransBillOfExchange.Invoice
                        && custBillOfExchangeInvoice.InvoiceCompany == custTransBillOfExchange.DataAreaId
                exists join TableId from custTrans
                    where custTrans.BillOfExchangeID == custBillOfExchangeInvoice.BillOfExchangeID
                        && custTrans.BillOfExchangeID == custTransInvoice.BillOfExchangeID
                exists join TableId from custTransOpen
                    where custTransOpen.RefRecId == custTrans.RecId
                exists join TableId from specTrans
                    where specTrans.RefRecId == custTransOpen.RecId
                        && specTrans.RefTableId == custTransOpen.TableId
                        && specTrans.RefCompany == custTransOpen.DataAreaId
                        && specTrans.SpecCompany == this.company()
                        && specTrans.SpecRecId == this.RecId
                        && specTrans.SpecTableId == this.TableId
            {
                recordList.ins(custDirectDebitMandate);
            }
        }

        return recordList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountAgreementDocumentTitle_RU</Name>
				<Source><![CDATA[
    // Leave these methods on the base table so they can be referenced in field groups and on form edit methods

    /// <summary>
    ///     Displays document title of the current <c>LedgerJournalTrans</c> agreement.
    /// </summary>
    /// <returns>
    ///     The agreement document title.
    /// </returns>
    [SysClientCacheDataMethodAttribute]
    public display AgreementDocumentTitle accountAgreementDocumentTitle_RU()
    {
        CompanyId company;

        company = this.AgreementCompany_RU ?
                    this.AgreementCompany_RU :
                    curext();

        if (xDataArea::exist(company))
        {
            changecompany(company)
            {
                return AgreementHeader::find(
                    AgreementHeaderExt_RU::findByAgreementId(this.AccountAgreementId_RU).AgreementHeader).DocumentTitle;
            }
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetDefaultDimensionDisplay_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays offset dimensions of the current <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <returns>
    ///     <c>DimensionDisplayValue</c> filled with offset dimensions of the current <c>LedgerJournalTrans</c> record.
    /// </returns>
    public display DimensionDisplayValueCorr_RU offsetDefaultDimensionDisplay_RU()
    {
        DimensionDisplayValue           ret;
        DimensionAttributeValueSetItem  dimensionAttrValueSetItem;
        str                             accountDelimiter = DimensionParameters::getDimensionSegmentDelimiter();

        switch (this.OffsetAccountType)
        {
            case LedgerJournalACType::Ledger:
                ret = LedgerDimensionFacade::getDisplayValueForLedgerDimension(this.OffsetLedgerDimension);
                break;
            default:
                while select DisplayValue from dimensionAttrValueSetItem
                    where dimensionAttrValueSetItem.DimensionAttributeValueSet == this.OffsetDefaultDimension
                {
                    ret += (ret ? accountDelimiter : '') + dimensionAttrValueSetItem.DisplayValue;
                }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountAgreementDocumentTitle_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Displays document title of the current <c>LedgerJournalTrans</c> offset agreement.
    /// </summary>
    /// <returns>
    ///     The offset agreement document title.
    /// </returns>
    [SysClientCacheDataMethodAttribute]
    public display AgreementDocumentTitle offsetAccountAgreementDocumentTitle_RU()
    {
        CompanyId company;

        company = this.OffsetAgreementCompany_RU ?
                    this.OffsetAgreementCompany_RU :
                    curext();

        if (xDataArea::exist(company))
        {
            changecompany(company)
            {
                return AgreementHeader::find(
                    AgreementHeaderExt_RU::findByAgreementId(this.OffsetAccountAgreementId_RU).AgreementHeader).DocumentTitle;
            }
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentDocumentName_RU</Name>
				<Source><![CDATA[
    [SysClientCacheDataMethodAttribute]
    public display Name paymentDocumentName_RU()
    {
        return BankClientDocumentType_RU::find(this.BankClientDocumentTypeId_RU).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPaymFeeTotalInTransactionCurrency_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Display the payment fee total.
    /// </summary>
    /// <returns>The payment fee total amount in transaction currency.</returns>
    public display AmountCur displayPaymFeeTotalInTransactionCurrency_JP()
    {
        return CustVendPaymJournalFee::getPaymFeeTotalInTransactionCurrency_JP(this.RecId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTCSGroupForWHTTaxJournal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Display the TCS group for WHT tax journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// The instance of the <c>TaxWithholdGroup</c> class.
    /// </returns>
    public display TaxWithholdGroup displayTCSGroupForWHTTaxJournal_IN()
    {
        TaxWithholdTaxJournalTrans_IN   taxWithholdTaxJournalTransloc;
        TaxWithholdGroup                taxWithholdGroup;

        taxWithholdTaxJournalTransloc = TaxWithholdTaxJournalTrans_IN::findByLedgerJournalTrans(this.RecId);
        if (taxWithholdTaxJournalTransloc.RecId != 0
            && taxWithholdTaxJournalTransloc.TaxWithholdType == TaxWithholdType_IN::TCS)
        {
            taxWithholdGroup = taxWithholdTaxJournalTransloc.TaxWithholdGroup;
        }

        return taxWithholdGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayTDSGroupForWHTTaxJournal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Display TDS group for WHT tax journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// The instance of the <c>TaxWithholdGroup</c> class.
    /// </returns>
    public display TaxWithholdGroup displayTDSGroupForWHTTaxJournal_IN()
    {
        TaxWithholdTaxJournalTrans_IN   taxWithholdTaxJournalTransloc;
        TaxWithholdGroup                taxWithholdGroup;

        taxWithholdTaxJournalTransloc = TaxWithholdTaxJournalTrans_IN::findByLedgerJournalTrans(this.RecId);
        if (taxWithholdTaxJournalTransloc.RecId != 0
             && taxWithholdTaxJournalTransloc.TaxWithholdType == TaxWithholdType_IN::TDS)
        {
            taxWithholdGroup = taxWithholdTaxJournalTransloc.TaxWithholdGroup;
        }

        return taxWithholdGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuAllowEdit_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether document attachments are allowed or not, overriding the default behavior
    /// of the attachment framework, which usually follows the datasource editability. In this case,
    /// for invoice pools, the datasource will be not editable, but attachments should still be possible to do.
    /// </summary>
    /// <returns>true if the document is an invoice pool; otherwise preserves current behavior by following the datasource editability.</returns>
    internal boolean docuAllowEdit_W()
    {
        boolean result;

        if (this.ledgerJournalTable().JournalType == LedgerJournalType::VendInvoicePool)
        {
            result = true;
        }
        else
        {
            FormDataSource thisFormDatasource = FormDataUtil::getFormDataSource(this);
            if (thisFormDatasource && thisFormDatasource.allowEdit())
            {
                result = true;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>represPersonCard_LT</Name>
				<Source><![CDATA[
    public display RepresPersonCard_LT represPersonCard_LT()
    {
        return  RCashTrans::findLedgerJournalTrans(this).RepresPersonCard_LT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>represPersonName_LT</Name>
				<Source><![CDATA[
    public display EmplName represPersonName_LT()
    {
        return RCashTransType::represPersonName_LT(this.rCashDocRepresPersonId,
                                                   this.AccountType == LedgerJournalACType::RCash ? any2Enum(this.OffsetAccountType) : any2Enum(this.AccountType),
                                                   this.AccountType == LedgerJournalACType::RCash ? this.parmOffsetAccount() : this.parmAccount(),
                                                   this.rCashDocRepresType
                                                  );
    }

]]></Source>
			</Method>
			<Method>
				<Name>represPersonCardEdit_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Edits the representative person card information.
    /// </summary>
    /// <param name="_set">
    /// A Boolean determining whether to set the value.
    /// </param>
    /// <param name="_cardInfo">
    /// The value to be set.
    /// </param>
    /// <returns>
    /// Card information to set.
    /// </returns>
    /// <remarks>
    /// Returns the calculated representative person card information if tha corresponding table field is empty.
    /// </remarks>
    public edit PayeeDocument_RU represPersonCardEdit_W(boolean _set, PayeeDocument_RU _cardInfo)
    {
        return LedgerJournalTrans_W_Extension::represPersonCardEdit_W(_set, _cardInfo, this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>represPersonNameEdit_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Edits the representative person name.
    /// </summary>
    /// <param name="_set">
    /// A Boolean determining whether to set the value.
    /// </param>
    /// <param name="_name">
    /// The value to be set.
    /// </param>
    /// <returns>
    /// Representative person name.
    /// </returns>
    /// <remarks>
    /// Returns the calculated represemtative person name if the corresponding table field is empty.
    /// </remarks>
    public edit PersonName represPersonNameEdit_W(boolean _set, EmplName _name)
    {
        return LedgerJournalTrans_W_Extension::represPersonNameEdit_W(_set, _name, this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountMST_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the accounting currency amount.
    /// </summary>
    /// <returns>The currency amount.</returns>
    public display AmountMST amountMST_RU()
    {
        return this.calcAmountMST();
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPurchJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the head table.
    /// </summary>
    /// <returns>The record for ledgerJournalTable.</returns>
    public SalesPurchJournalTable salesPurchJournalTable()
    {
        return this.ledgerJournalTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>containsCurrentCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the transaction contains the current company.
    /// </summary>
    /// <returns>True if the transaction contains the current company; otherwise, false.</returns>
    public boolean containsCurrentCompany()
    {
        return this.Company == curExt() || (this.OffsetLedgerDimension && this.OffsetCompany == curExt());
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTrans_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>LedgerJournalTrans_W</c> record associated with the current record.
    /// </summary>
    /// <returns>
    /// The <c>LedgerJournalTrans_W</c> record associated with the current record.
    /// </returns>
    public LedgerJournalTrans_W ledgerJournalTrans_W()
    {
        return this.SysExtensionSerializerMap::getExtensionTable(tableNum(LedgerJournalTrans_W));
    }

]]></Source>
			</Method>
			<Method>
				<Name>packLedgerJournalTrans_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the <c>LedgerJournalTrans_W</c> record associated with the current record.
    /// </summary>
    /// <param name="_ledgerJournalTrans_W">
    /// The <c>LedgerJournalTrans_W</c> record.
    /// </param>
    public void packLedgerJournalTrans_W(LedgerJournalTrans_W _ledgerJournalTrans_W)
    {
        _ledgerJournalTrans_W.LedgerJournalTrans = this.RecId;

        this.SysExtensionSerializerMap::packExtensionTable(_ledgerJournalTrans_W);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVoucherType_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the voucher_CN and sets it in table LedgerJournalTrans according to the voucherType.
    /// </summary>
    // <GCN>
    public void createVoucherType_CN()
    {
        LedgerVoucherTypeRule_CN ledgerVoucherTypeRule = LedgerVoucherTypeRule_CN::newFromVoucher(this.JournalNum, this.Voucher);
        if(ledgerVoucherTypeRule)
        {
            LedgerVoucherType_CN ledgerVoucherType = ledgerVoucherTypeRule.getVoucherType();
            if(ledgerVoucherType.RecId)
            {
                this.LedgerVoucherType_CN = ledgerVoucherType.RecId;
                this.Voucher_CN = NumberSeq_Voucher_CN::newGetVoucherFromCode(ledgerVoucherType.NumberSequenceTable,this.TransDate, true).voucher();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPayWhenPaid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets Pay When Paid flag in <c>LedgerJournalTrans_Project</c> when <c>LedgerJournalTrans</c>
    /// has Project line with same voucher as the Vendor line.
    /// </summary>
    private void setPayWhenPaid()
    {
        if (Project::Enabled() &&
            this.AccountType == LedgerJournalACType::Vend &&
            this.OffsetAccountType == LedgerJournalACType::Ledger &&
            this.OffsetLedgerDimension == 0)
        {
            LedgerJournalTrans          ledgerJournalTrans;
            LedgerJournalTrans_Project  ledgerJournalTrans_Project;

            ttsbegin;

            select forUpdate ledgerJournalTrans_Project
                join ledgerJournalTrans
                    where ledgerJournalTrans_Project.RefRecId == ledgerJournalTrans.RecId &&
                        ledgerJournalTrans.AccountType == LedgerJournalACType::Project &&
                        ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger &&
                        ledgerJournalTrans.Voucher == this.Voucher;

            if (ledgerJournalTrans && ledgerJournalTrans_Project)
            {
                ledgerJournalTrans_Project.setPayWhenPaid(this);
                ledgerJournalTrans_Project.update();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markCurrentTaxDocumentTaxStatusDirty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark current tax status of <c> TaxEngineLedgerJournalTransView </c> to dirty
    /// </summary>
    public void markCurrentTaxDocumentTaxStatusDirty()
    {
        if (!TaxEngineTaxJournalUtil::isLedgerJournalTableCreatedFromTaxJournal(this.ledgerJournalTable().recId))
        {
            TaxableDocumentDescriptor descriptor = TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(this);
            ITaxableDocument taxableDocument = TaxableDocumentObject::construct(descriptor);
            TaxBusinessService::markTaxDocumentTaxStatus(taxableDocument, TaxDocumentCalculationLevel::Dirty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPartyRelatedLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get party related journal line for multiple lines vendor invoice, vendor payment, customer invoice, customer payment journal
    /// </summary>
    /// <returns>
    /// The party related journal line
    /// </returns>
    public LedgerJournalTrans getPartyRelatedLine()
    {
        // <GTE>
        LedgerJournalTrans ledgerJournalTransLoc;

        if (LedgerJournalTrans::isCustomerInvoice(this) || LedgerJournalTrans::isCustomerPayment(this))
        {
            if ((this.AccountType == LedgerJournalACType::Cust && this.LedgerDimension != 0)
                || (this.OffsetAccountType == LedgerJournalACType::Cust && this.OffsetLedgerDimension != 0))
            {
                ledgerJournalTransLoc = this;
            }
            else
            {
                select firstonly ledgerJournalTransLoc
                    where ledgerJournalTransLoc.Voucher == this.Voucher
                        && ledgerJournalTransLoc.JournalNum == this.JournalNum
                        && ((ledgerJournalTransLoc.AccountType == LedgerJournalACType::Cust
                                && ledgerJournalTransLoc.LedgerDimension != 0)
                            || (ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Cust
                                && ledgerJournalTransLoc.OffsetLedgerDimension != 0));
            }
        }
        else if (LedgerJournalTrans::isVendorInvoice(this) || LedgerJournalTrans::isVendorPayment(this))
        {
            if (LedgerJournalTable::find(this.JournalNum).JournalType == LedgerJournalType::Approval
                || (this.AccountType == LedgerJournalACType::Vend && this.LedgerDimension != 0)
                || (this.OffsetAccountType == LedgerJournalACType::Vend && this.OffsetLedgerDimension != 0))
            {
                ledgerJournalTransLoc = this;
            }
            else
            {
                select firstonly ledgerJournalTransLoc
                    where ledgerJournalTransLoc.Voucher == this.Voucher
                        && ledgerJournalTransLoc.JournalNum == this.JournalNum
                        && ((ledgerJournalTransLoc.AccountType == LedgerJournalACType::Vend
                                && ledgerJournalTransLoc.LedgerDimension != 0)
                            || (ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Vend
                                && ledgerJournalTransLoc.OffsetLedgerDimension != 0));
            }
        }

        if (ledgerJournalTransLoc.RecId == this.RecId)
        {
            // Use table buffer instead of record from db, since table buffer contains latest data
            ledgerJournalTransLoc = this;
        }

        return ledgerJournalTransLoc;
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxDocmentTypeChanged</Name>
				<Source><![CDATA[
    private boolean isTaxDocmentTypeChanged(LedgerJournalTrans _orig)
    {
        // <GTE>
        boolean isTDTChanged = false;

        if (this.AccountType                != _orig.AccountType
            || this.OffsetAccountType       != _orig.OffsetAccountType
            || this.LedgerDimension         != _orig.LedgerDimension
            || this.OffsetLedgerDimension   != _orig.OffsetLedgerDimension)
        {
            isTDTChanged = true;
        }

        return isTDTChanged;
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendInvoiceTransInterface</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>CustVendInvoiceTransInterface</c> object associated with the current table record.
    /// </summary>
    /// <returns>
    /// The <c>CustVendInvoiceTransInterface</c> object.
    /// </returns>
    public CustVendInvoiceTransInterface custVendInvoiceTransInterface()
    {
        return this.CustVendInvoiceTrans::CustVendInvoiceTransInterface();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustVendLocationAndTaxInformation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update customer or vendor tax information when change LedgerDimension or OffsetLedgerDimension to customer or vendor.
    /// </summary>
    // <GIN>
    public void updateCustVendLocationAndTaxInformation_IN()
    {
        CustVendTable       custVendTable;
        TransTaxInformation transTaxInformation;

        transTaxInformation = TransTaxInformationHelper::newHelper().findTransTaxInformationByRecord(this);

        if (!transTaxInformation)
        {
            return;
        }

        // Get customer or vendor.
        if ((this.AccountType == LedgerJournalACType::Cust && this.LedgerDimension)
             || (this.OffsetAccountType == LedgerJournalACType::Cust && this.OffsetLedgerDimension)
             && (this.LedgerDimension != this.orig().LedgerDimension || this.OffsetLedgerDimension != this.orig().OffsetLedgerDimension)
           )
        {
            if (this.AccountType == LedgerJournalACType::Cust)
            {
                custVendTable = CustTable::find(this.parmAccount());
            }
            else
            {
                custVendTable = CustTable::find(this.parmOffsetAccount());
            }
        }
        else if ((this.AccountType == LedgerJournalACType::Vend && this.LedgerDimension)
                || (this.OffsetAccountType == LedgerJournalACType::Vend && this.OffsetLedgerDimension)
                && (this.LedgerDimension != this.orig().LedgerDimension || this.OffsetLedgerDimension != this.orig().OffsetLedgerDimension)
                )
        {
            if (this.AccountType == LedgerJournalACType::Vend)
            {
                custVendTable = VendTable::find(this.parmAccount());
            }
            else
            {
                custVendTable = VendTable::find(this.parmOffsetAccount());
            }
        }
        else if (this.TransactionType == LedgerTransType::Vend
                && this.VendTransId
                && transTaxInformation.VendorLocation == 0
                && transTaxInformation.VendorTaxInformation == 0)
        {
            custVendTable = VendTable::find(VendTrans::find(this.VendTransId).AccountNum);
        }

        // Update location and tax information.
        transTaxInformation.selectForUpdate(true);
        if (custVendTable)
        {
            TransTaxInformationHelper::initFromCustVend(transTaxInformation, custVendTable);

            switch (custVendTable.TableId)
            {
                case tableNum(VendTable) :
                    transTaxInformation.CustomerLocation        = 0;
                    transTaxInformation.CustomerTaxInformation  = 0;
                    break;

                case tableNum(CustTable) :
                    transTaxInformation.VendorLocation          = 0;
                    transTaxInformation.VendorTaxInformation    = 0;
                    break;
            }
        }
        else
        {
            transTaxInformation.CustomerLocation        = 0;
            transTaxInformation.CustomerTaxInformation  = 0;
            transTaxInformation.VendorLocation          = 0;
            transTaxInformation.VendorTaxInformation    = 0;
        }

        ttsbegin;
        transTaxInformation.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCreditReportingCurrency</Name>
				<Source><![CDATA[
    // <GIN>
    /// <summary>
    /// Calculates the reporting currency amount for a <c>LedgerJournalTrans.amountCurCredit</c> value.
    /// </summary>
    /// <param name="_throwExceptions">
    /// Throw exceptions; optional.
    /// </param>
    /// <param name="_ledgerJournalTable">
    /// The corresponding <c>LedgerJournalTable</c> record; optional.
    /// </param>
    /// <returns>
    /// An amount in reporting currency.
    /// </returns>
    /// <remarks>
    /// For intercompany transactions, currency conversions will use the exchange rate of the current
    /// company for the transaction currency code and transaction date that is indicated on the transaction
    /// if the transaction currency codes are different in the two companies.
    /// Pass the corresponding <c>LedgerJournalTable</c> record so this method does not have to retrieve it.
    /// </remarks>
    public AmountMSTSecondary calcCreditReportingCurrency(boolean _throwExceptions = true, LedgerJournalTable _ledgerJournalTable = null)
    {
        AmountMSTSecondary  amountMSTSecondary;
        LedgerJournalTable  ledgerJournalTable;
        CurrencyCode        currentCompanyReportingCurrency = '';
        CurrencyCode        accountCompanyReportingCurrency = '';
        boolean             isInterCompany = false;

        if (Ledger::reportingCurrency() != '')
        {
            CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::current(),
                this.exchRateDate_W());

            // Allocations is a special case as the process uses transaction amounts to calculate exchange
            // rate values to balance properly, vs. using the exchange rate to calculate accounting/reporting
            // amounts.
            boolean forceExchangeRate = (_ledgerJournalTable.JournalType == LedgerJournalType::Allocation);

            if (!forceExchangeRate && this.isCompanyIntercompany(this.company()))
            {
                isInterCompany = true;
                currentCompanyReportingCurrency = Ledger::reportingCurrency();

                changecompany(this.Company)
                {
                    accountCompanyReportingCurrency = Ledger::reportingCurrency();
                }
            }

            if (isInterCompany)
            {
                if (_ledgerJournalTable == null)
                {
                    ledgerJournalTable = this.ledgerJournalTable();
                }
                else
                {
                    ledgerJournalTable = _ledgerJournalTable;
                }

                if (currentCompanyReportingCurrency == accountCompanyReportingCurrency
                    && (ledgerJournalTable.JournalType == LedgerJournalType::Daily
                    || ledgerJournalTable.JournalType == LedgerJournalType::Approval
                    || ledgerJournalTable.JournalType == LedgerJournalType::CustPayment
                    || ledgerJournalTable.JournalType == LedgerJournalType::Payment
                    || ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger
                    || ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister))
                {
                    currencyExchHelper.parmReportingExchangeRate1(this.ReportingCurrencyExchRate);
                    currencyExchHelper.parmReportingExchangeRate2(this.ReportingCurrencyExchRateSecondary);
                }
            }
            else
            {
                currencyExchHelper.parmReportingExchangeRate1(this.ReportingCurrencyExchRate);
                currencyExchHelper.parmReportingExchangeRate2(this.ReportingCurrencyExchRateSecondary);
            }

            // if we are in the service context (non-interactive), we want to log any problems as faults and continue forward
            if (!_throwExceptions)
            {
                currencyExchHelper.parmErrorType(AifErrorType::Fault);
            }

            LedgerJournalTrans_Asset ledgerJournalTrans_Asset;
            if (this.AccountType == LedgerJournalACType::FixedAssets)
            {
                ledgerJournalTrans_Asset = LedgerJournalTrans_Asset::find(this.RecId);
            }

            if (ledgerJournalTrans_Asset.AmountCreditReportingCurrency
                && this.isAssetJournalLineReportingCurrecyAmountShouldBeUsed(ledgerJournalTrans_Asset))
            {
                amountMSTSecondary = ledgerJournalTrans_Asset.AmountCreditReportingCurrency;
            }
            else
            {
                amountMSTSecondary = currencyExchHelper.calculateTransactionCurrencyToReportingCurrency(this.CurrencyCode, this.AmountCurCredit, true);
            }
        }

        return amountMSTSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowPosting_Ledger</Name>
				<Source><![CDATA[
    // <GIN>

    /// <summary>
    /// Check allow posting for type ledger.
    /// </summary>
    /// <param name = "_dimensionDynamicAccount">The record ID of the <c>DimensionAttributeValueCombination</c> table.</param>
    /// <returns>true if the Main account is allowed for posting; otherwise, false.</returns>
    protected boolean checkAllowPosting_Ledger(DimensionDynamicAccount _dimensionDynamicAccount)
    {
        return MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountFromLedgerDimension(_dimensionDynamicAccount).MainAccountId,
                                                              LedgerPostingType::LedgerJournal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowPosting_Cust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the customer account against the customer hold and also if the account exists.
    /// </summary>
    /// <param name = "_dimensionDynamicAccount">The record ID of the <c>DimensionAttributeValueCombination</c> table.</param>
    /// <returns>
    /// true if the customer is not on hold for an <c>Invoice</c> value, a <c>Payment</c> value, or an<c>All</c>; otherwise, false.
    /// </returns>
    protected boolean checkAllowPosting_Cust(DimensionDynamicAccount _dimensionDynamicAccount)
    {
        return CustTable::checkExistAndOpen(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount), this.amount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowPosting_Vend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the vendor account against the vendor hold and also if the account exists.
    /// </summary>
    /// <param name = "_dimensionDynamicAccount">The record ID of the <c>DimensionAttributeValueCombination</c> table.</param>
    /// <returns>
    /// true if the vendor is not on hold for an <c>Invoice</c> value, a <c>Payment</c> value, or an<c>All</c>; otherwise, false.
    /// </returns>
    protected boolean checkAllowPosting_Vend(DimensionDynamicAccount _dimensionDynamicAccount)
    {
        return VendTable::checkExistAndOpen(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount),
                                                            this.amount(),
                                                            this.TransactionType,
                                                            DateTimeUtil::newDateTime(this.TransDate,0),
                                                            this.ledgerJournalTable().JournalType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowPosting_Project</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the record is active or not based on corresponding <c>ProjStatusType</c> object based on the status of the current project record.
    /// </summary>
    /// <param name = "_dimensionDynamicAccount">The record ID of the <c>DimensionAttributeValueCombination</c> table.</param>
    /// <returns>
    /// true if the record is active otherwise, false.
    /// </returns>
    protected boolean checkAllowPosting_Project(DimensionDynamicAccount _dimensionDynamicAccount)
    {
        if (! ProjTable::find(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).status().activeInTree())
        {
            return checkFailed(strFmt("@Proj:ProjectIsHeaderOrFinished",LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)));
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowPosting_FixedAsset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the asset id exists.
    /// </summary>
    /// <param name = "_dimensionDynamicAccount">The record ID of the <c>DimensionAttributeValueCombination</c> table.</param>
    /// <returns>
    /// true if the asset id exists otherwise, false.
    /// </returns>
    protected boolean checkAllowPosting_FixedAsset(DimensionDynamicAccount _dimensionDynamicAccount)
    {
        return AssetTable::checkExist(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowPosting_FixedAsset_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the asset id exists.
    /// </summary>
    /// <param name = "_dimensionDynamicAccount">The record ID of the <c>DimensionAttributeValueCombination</c> table.</param>
    /// <returns>
    /// true if the asset id exists otherwise, false.
    /// </returns>
    protected boolean checkAllowPosting_FixedAsset_RU(DimensionDynamicAccount _dimensionDynamicAccount)
    {
        return RAssetTable::checkExist(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowPosting_Employee_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a record Id exists in <c>HcmWorkerAffiliationAdvHolder_RU</c> table and shows an infolog message if record does not exist.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the <c>DimensionAttributeValueCombination</c> table.
    /// </param>
    /// <returns>
    /// true if the record Id exists; otherwise, false.
    /// </returns>
    protected boolean checkAllowPosting_Employee_RU(DimensionDynamicAccount _dimensionDynamicAccount)
    {
        return EmployeeTable_RU::checkExist(EmployeeTable_RU::findByEmployeeId(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount)).RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowPosting_RDeferrals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if <c>RDeferralsTable</c> record exists.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the <c>DimensionAttributeValueCombination</c> table.
    /// </param>
    /// <returns>
    /// true if the record Id exists; otherwise, false.
    /// </returns>
    protected boolean checkAllowPosting_RDeferrals(DimensionDynamicAccount _dimensionDynamicAccount)
    {
        return RDeferralsTable::checkExist(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowPosting_RCash</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if <c>RCashTable</c> record exists.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the <c>DimensionAttributeValueCombination</c> table.
    /// </param>
    /// <returns>
    /// true if the record Id exists; otherwise, false.
    /// </returns>
    protected boolean checkAllowPosting_RCash(DimensionDynamicAccount _dimensionDynamicAccount)
    {
        return RCashTable::checkExist(LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dimensionDynamicAccount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDebitReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reporting currency amount for a <c>LedgerJournalTrans.amountCurDebit</c> value.
    /// </summary>
    /// <param name="_throwExceptions">
    /// Throw exceptions; optional.
    /// </param>
    /// <param name="_ledgerJournalTable">
    /// The corresponding <c>LedgerJournalTable</c> record; optional.
    /// </param>
    /// <returns>
    /// An amount in reporting currency.
    /// </returns>
    /// <remarks>
    /// For intercompany transactions, currency conversions will use the exchange rate of the current
    /// company for the transaction currency code and transaction date that is indicated on the transaction
    /// if the transaction currency codes are different in the two companies.
    /// Pass the corresponding <c>LedgerJournalTable</c> record so this method does not have to retrieve it.
    /// </remarks>
    public AmountMSTSecondary calcDebitReportingCurrency(boolean _throwExceptions = true, LedgerJournalTable _ledgerJournalTable = null)
    {
        AmountMSTSecondary  amountMSTSecondary;
        LedgerJournalTable  ledgerJournalTable;
        CurrencyCode        currentCompanyReportingCurrency = '';
        CurrencyCode        accountCompanyReportingCurrency = '';
        boolean             isInterCompany = false;

        if (Ledger::reportingCurrency() != '')
        {
            CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::current(),
                this.exchRateDate_W());

            // Allocations is a special case as the process uses transaction amounts to calculate exchange
            // rate values to balance properly, vs. using the exchange rate to calculate accounting/reporting
            // amounts.
            boolean forceExchangeRate = (_ledgerJournalTable.JournalType == LedgerJournalType::Allocation);

            if (!forceExchangeRate && this.isCompanyIntercompany(this.company()))
            {
                isInterCompany = true;
                currentCompanyReportingCurrency = Ledger::reportingCurrency();

                changecompany(this.Company)
                {
                    accountCompanyReportingCurrency = Ledger::reportingCurrency();
                }
            }

            if (isInterCompany)
            {
                if (_ledgerJournalTable == null)
                {
                    ledgerJournalTable = this.ledgerJournalTable();
                }
                else
                {
                    ledgerJournalTable = _ledgerJournalTable;
                }

                if (currentCompanyReportingCurrency == accountCompanyReportingCurrency
                    && (ledgerJournalTable.JournalType == LedgerJournalType::Daily
                    || ledgerJournalTable.JournalType == LedgerJournalType::Approval
                    || ledgerJournalTable.JournalType == LedgerJournalType::CustPayment
                    || ledgerJournalTable.JournalType == LedgerJournalType::Payment
                    || ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger
                    || ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister))
                {
                    currencyExchHelper.parmReportingExchangeRate1(this.ReportingCurrencyExchRate);
                    currencyExchHelper.parmReportingExchangeRate2(this.ReportingCurrencyExchRateSecondary);
                }
            }
            else
            {
                currencyExchHelper.parmReportingExchangeRate1(this.ReportingCurrencyExchRate);
                currencyExchHelper.parmReportingExchangeRate2(this.ReportingCurrencyExchRateSecondary);
            }

            // if we are in the service context (non-interactive), we want to log any problems as faults and continue forward
            if (!_throwExceptions)
            {
                currencyExchHelper.parmErrorType(AifErrorType::Fault);
            }

            LedgerJournalTrans_Asset ledgerJournalTrans_Asset;
            if (this.AccountType == LedgerJournalACType::FixedAssets)
            {
                ledgerJournalTrans_Asset = LedgerJournalTrans_Asset::find(this.RecId);
            }

            if (ledgerJournalTrans_Asset.AmountDebitReportingCurrency
                && this.isAssetJournalLineReportingCurrecyAmountShouldBeUsed(ledgerJournalTrans_Asset))
            {
                amountMSTSecondary = ledgerJournalTrans_Asset.AmountDebitReportingCurrency;
            }
            else
            {
                amountMSTSecondary = currencyExchHelper.calculateTransactionCurrencyToReportingCurrency(this.CurrencyCode, this.amountCurDebit, true);
            }
        }

        return amountMSTSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the net reporting currency total amount for a <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_throwExceptions">
    /// Throw exceptions; optional.
    /// </param>
    /// <returns>
    /// An amount in reporting currency.
    /// </returns>
    /// <remarks>
    /// For intercompany transactions, currency conversions will use the exchange rate of the current
    /// company for the transaction currency code and transaction date that is indicated on the transaction
    /// regardless of the exchange rate on the transaction.
    /// </remarks>
    public AmountMSTSecondary calcAmountReportingCurrency(boolean _throwExceptions = true)
    {
        AmountMSTSecondary     amountMSTSecondary;

        if (Ledger::reportingCurrency() != '')
        {
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                this.exchRateDate_W());

            // Allocations is a special case as the process uses transaction amounts to calculate exchange
            // rate values to balance properly, vs. using the exchange rate to calculate accounting/reporting
            // amounts.
            boolean forceExchangeRate = (this.ledgerJournalTable().JournalType == LedgerJournalType::Allocation);

            if (forceExchangeRate || !this.isCompanyIntercompany(this.company()))
            {
                // The exchange rate fields only apply to the account company and not the company of the
                // transaction, so only use them when there is not an intercompany transaction involved.
                currencyExchangeHelper.parmReportingExchangeRate1(this.ReportingCurrencyExchRate);
                currencyExchangeHelper.parmReportingExchangeRate2(this.ReportingCurrencyExchRateSecondary);
            }

            // if we are in the service context (non-interactive), we want to log any problems as faults and continue forward
            if (!_throwExceptions)
            {
                currencyExchangeHelper.parmErrorType(AifErrorType::Fault);
            }

            amountMSTSecondary = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(this.CurrencyCode, this.AmountCurDebit - this.AmountCurCredit, true);
        }

        return amountMSTSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxIntegrationAccrueUseTaxEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the accrue use tax is enabled.
    /// </summary>
    /// <returns>true if the accrue use tax is enabled, otherwise false.</returns>
    public boolean isTaxIntegrationAccrueUseTaxEnabled()
    {
        return TaxIntegrationUtils::isTaxIntegrationUseTaxAssessmentEnabled(TaxIntegrationBusinessProcess::Journal)
                && (this.isVendLine())
                && this.ledgerJournalTransTaxExtension().AccrueSalesTaxType != TaxAccrueSalesTaxType::Default;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePaymentRequestConsistent</Name>
				<Source><![CDATA[
    private boolean validatePaymentRequestConsistent ()
    {
        LedgerJournalTrans this_orig = this.orig();
        boolean ret = true;

        if (this.Company != this_orig.Company)
        {
            ret = checkFailed(strFmt("@CashFlowManagement:ChangeFieldIsNotAllowInconsistentPayment", fieldPName(LedgerJournalTrans, Company)));
        }

        if (this.LedgerDimension != this_orig.LedgerDimension)
        {
            ret = checkFailed(strFmt("@CashFlowManagement:ChangeFieldIsNotAllowInconsistentPayment", fieldPName(LedgerJournalTrans, LedgerDimension)));
        }

        if (this.AmountCurCredit != this_orig.AmountCurCredit)
        {
            ret = checkFailed(strFmt("@CashFlowManagement:ChangeFieldIsNotAllowInconsistentPayment", fieldPName(LedgerJournalTrans, AmountCurCredit)));
        }

        if (this.AmountCurDebit != this_orig.AmountCurDebit)
        {
            ret = checkFailed(strFmt("@CashFlowManagement:ChangeFieldIsNotAllowInconsistentPayment", fieldPName(LedgerJournalTrans, AmountCurDebit)));
        }

        if (this.OffsetAccountType != this_orig.OffsetAccountType)
        {
            ret = checkFailed(strFmt("@CashFlowManagement:ChangeFieldIsNotAllowInconsistentPayment", fieldPName(LedgerJournalTrans, OffsetAccountType)));
        }

        if (this.OffsetLedgerDimension != this_orig.OffsetLedgerDimension)
        {
            ret = checkFailed(strFmt("@CashFlowManagement:ChangeFieldIsNotAllowInconsistentPayment", fieldPName(LedgerJournalTrans, OffsetLedgerDimension)));
        }

        if (this.PaymMode != this_orig.PaymMode)
        {
            ret = checkFailed(strFmt("@CashFlowManagement:ChangeFieldIsNotAllowInconsistentPayment", fieldPName(LedgerJournalTrans, PaymMode)));
        }

        if (this.OffsetCompany != this_orig.OffsetCompany)
        {
            ret = checkFailed(strFmt("@CashFlowManagement:ChangeFieldIsNotAllowInconsistentPayment", fieldPName(LedgerJournalTrans, OffsetCompany)));
        }

        if (this.CurrencyCode != this_orig.CurrencyCode)
        {
            ret = checkFailed(strFmt("@ChangeFieldIsNotAllowInconsistentPayment", fieldPName(LedgerJournalTrans, CurrencyCode)));
        }

        if (this.BankTransType != this_orig.BankTransType)
        {
            ret = checkFailed(strFmt("@CashFlowManagement:ChangeFieldIsNotAllowInconsistentPayment", fieldPName(LedgerJournalTrans, BankTransType)));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorPaymentWithTDSCalculation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether this transaction is a vendor payment and check whether this transaction can calculate WHT for TDS Group.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>True if this transaction is a vendor payment and can calculate WHT for TDS Group</returns>
    public static boolean isVendorPaymentWithTDSCalculation_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtension = LedgerJournalTransTaxExtensionIN::findByLedgerJournalTrans(_ledgerJournalTrans.RecId);
        if ((_ledgerJournalTrans.SettleVoucher == SettlementType::None
            || _ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact
            || (_ledgerJournalTrans.SettleVoucher == SettlementType::OpenTransact
                && VendParameters::find().AutoSettle))
            && ledgerJournalTransTaxExtension.TDSGroup
            && TaxParameters::checkTaxParameters_IN()
            && LedgerJournalTrans::isVendorPayment(_ledgerJournalTrans))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustomerPaymentWithTDSCalculation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether this transaction is a customer payment and check whether this transaction can calculate WHT for TDS Group.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>True if this transaction is a vendor payment and can calculate WHT for TDS Group</returns>
    public static boolean isCustomerPaymentWithTDSCalculation_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtension = LedgerJournalTransTaxExtensionIN::findByLedgerJournalTrans(_ledgerJournalTrans.RecId);
        if ((_ledgerJournalTrans.SettleVoucher == SettlementType::None
            || _ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact
            || (_ledgerJournalTrans.SettleVoucher == SettlementType::OpenTransact
                && CustParameters::find().AutoSettle))
            && ledgerJournalTransTaxExtension.TDSGroup
            && TaxParameters::checkTaxParameters_IN()
            && LedgerJournalTrans::isCustomerPayment(_ledgerJournalTrans))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReportingCurrencyExchangeRateIfSameCurrencies</Name>
				<Source><![CDATA[
    private void defaultReportingCurrencyExchangeRateIfSameCurrencies()
    {
        // Ensure that reporting currency exchange rate is not changed for necessary journal types.
        if (this.doesJournalSupportReportingCurrencyExchangeRateDefaulting())
        {
            this.LedgerJournalReportingCurrencyExchangeRates::setReportingCurrencyExchangeRate();
            this.setReportingCurrencyExchangeRateSecond();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesJournalSupportReportingCurrencyExchangeRateDefaulting</Name>
				<Source><![CDATA[
    private boolean doesJournalSupportReportingCurrencyExchangeRateDefaulting()
    {
        LedgerJournalTable journal = this.ledgerJournalTable();

        return journal.JournalType != LedgerJournalType::Allocation
            && journal.JournalType != LedgerJournalType::Approval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReportingCurrencyExchangeRateSecond</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the reporting currency exchange rate second for the current buffer.
    /// </summary>
    /// <remarks>Reporting currency exchange rate second is set only if a reporting currency is setup in the <c>Ledger</c>.
    /// </remarks>
    internal void setReportingCurrencyExchangeRateSecond()
    {
        this.LedgerJournalReportingCurrencyExchangeRates::setReportingCurrencyExchangeRateSecond();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportingCurrencyExchangeRateField</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the reporting currency exchange rate field ID.
    /// </summary>
    /// <returns>
    ///     The reporting currency exchange rate field ID.
    /// </returns>
    /// <remarks>
    ///     Used with the <c>LedgerJournalReportingCurrencyExchangeRates</c> map.
    /// </remarks>
    internal FieldId getReportingCurrencyExchangeRateField()
    {
        return fieldNum(LedgerJournalTrans, ReportingCurrencyExchRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultAndValidateReportingExchangeRates</Name>
				<Source><![CDATA[
    internal boolean defaultAndValidateReportingExchangeRates(LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean areExchangeRatesValid = true;
        boolean shouldUpdateLedgerJournalTrans;

        // Ensure that reporting carrency exchange rate is not changed for necessary journal types.
        if (this.doesJournalSupportReportingCurrencyExchangeRateDefaulting() &&
            Ledger::isReportingCurrencySameAsAccountingCurrencyforLegalEntity(this.getCompanyLegalEntity()))
        {
            this.selectForUpdate(true);

            if (this.ExchRate != this.ReportingCurrencyExchRate)
            {
                if (this.ReportingCurrencyExchRate == 0)
                {
                    this.ReportingCurrencyExchRate = this.ExchRate;
                    shouldUpdateLedgerJournalTrans = true;
                }
                else if (_ledgerPostingMessageCollection)
                {
                    areExchangeRatesValid = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GeneralLedger:ExchangeRateMismatchForSameLedgerCurrency", Ledger::accountingCurrency(), Ledger::reportingCurrency()));
                }
                else
                {
                    areExchangeRatesValid = checkFailed(strFmt("@GeneralLedger:ExchangeRateMismatchForSameLedgerCurrency", Ledger::accountingCurrency(), Ledger::reportingCurrency()));
                }
            }

            if (this.ExchRateSecond != this.ReportingCurrencyExchRateSecondary)
            {
                if (this.ReportingCurrencyExchRateSecondary == 0)
                {
                    this.ReportingCurrencyExchRateSecondary = this.ExchrateSecond;
                    shouldUpdateLedgerJournalTrans = true;
                }
                else if (_ledgerPostingMessageCollection)
                {
                    areExchangeRatesValid = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GeneralLedger:SecondaryExchangeRateMismatchForSameLedgerCurrency", Ledger::accountingCurrency(), Ledger::reportingCurrency()));
                }
                else
                {
                    areExchangeRatesValid = checkFailed(strFmt("@GeneralLedger:SecondaryExchangeRateMismatchForSameLedgerCurrency", Ledger::accountingCurrency(), Ledger::reportingCurrency()));
                }
            }

            if (shouldUpdateLedgerJournalTrans)
            {
                ttsbegin;

                this.doUpdate();

                ttscommit;
            }
        }

        return areExchangeRatesValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTDSAndTCSByCustVendAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Init TDS and TCS by CustVendAccount.
    /// </summary>
    /// <param name = "_OffsetLedgerDimension">LedgerJournalTrans of offset ledger dimension.</param>
    /// <param name = "_ledgerJournalACType">LedgerJournalTrans of ledger journal type.</param>
    private void initTDSAndTCSByCustVendAccount(
        DimensionDynamicAccount _OffsetLedgerDimension,
        LedgerJournalACType _ledgerJournalACType)
    {
        if (_OffsetLedgerDimension)
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN;
            ledgerJournalTransTaxExtensionIN = this.ledgerJournalTransTaxExtensionIN();

            switch (_ledgerJournalACType)
            {
                case LedgerJournalACType::Vend :
                    VendTable vendTable = VendTable::findByLedgerDimension(_OffsetLedgerDimension);

                    ledgerJournalTransTaxExtensionIN.tdsAndTSCInitFromVendor(vendtable.AccountNum);
                    this.packledgerJournalTransTaxExtensionIN(ledgerJournalTransTaxExtensionIN);

                    break;

                case LedgerJournalACType::Cust :
                    CustTable custTable = CustTable::findByLedgerDimension(_OffsetLedgerDimension);

                    ledgerJournalTransTaxExtensionIN.tdsAndTSCInitFromCustomer(custTable.AccountNum);
                    this.packledgerJournalTransTaxExtensionIN(ledgerJournalTransTaxExtensionIN);

                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyLegalEntity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the primary company's <c>LegalEntityRecId</c>.
    /// </summary>
    /// <returns>
    ///     The primary company's <c>LegalEntityRecId</c>.
    /// </returns>
    /// <remarks>
    ///     Used with the <c>LedgerJournalReportingCurrencyExchangeRates</c> map.
    /// </remarks>
    internal LegalEntityRecId getCompanyLegalEntity()
    {
        return CompanyInfo::findDataArea(this.Company).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTaxGroupCompanyForIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets sales tax group company for intercompany.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">Buffered value on table <c>LedgerJournalTrans</c>.</param>
    /// <returns>Sales tax group company for intercompany</returns>
    [Hookable(false)]
    public static DataAreaId getSalesTaxGroupCompanyForIntercompany(LedgerJournalTrans _ledgerJournalTrans)
    {
        DataAreaId dataAreaIdPostInterCompany;

        LedgerJournalTaxDocument ledgerJournalTaxDocument = LedgerJournalTaxDocument::construct(
            _ledgerJournalTrans.JournalNum,
            _ledgerJournalTrans.Voucher,
            _ledgerJournalTrans.Invoice,
            _ledgerJournalTrans);

        if (_ledgerJournalTrans.ledgerJournalTable().TaxObligationCompany == TaxObligationCompany::Source)
        {
            dataAreaIdPostInterCompany = ledgerJournalTaxDocument.getSourceCompany();
        }
        else
        {
            dataAreaIdPostInterCompany = ledgerJournalTaxDocument.getLineByLedgerJournalTrans(_ledgerJournalTrans).getDestinationCompany();
        }

        return dataAreaIdPostInterCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVendLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find a ledgerJournalTrans with vendor account
    /// </summary>
    /// <param name = "_journalNum">LedgerJournalId</param>
    /// <param name = "_voucherNum">Voucher</param>
    /// <param name = "_transDate">TransDate></param>
    /// <returns>LedgerJournalTrans</returns>
    internal static LedgerJournalTrans findVendLedgerJournalTrans(LedgerJournalId _journalNum, Voucher _voucherNum, TransDate _transDate)
    {
        LedgerJournalTrans ledgerJournalTrans;
        select firstonly ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _journalNum
                && ledgerJournalTrans.Voucher == _voucherNum
                && ledgerJournalTrans.TransDate == _transDate
                && ((ledgerJournalTrans.AccountType == LedgerJournalACType::Vend && ledgerJournalTrans.LedgerDimension)
                    || (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend && ledgerJournalTrans.OffsetLedgerDimension));
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>CustVendTable</c> record corresponding to the account.
    /// </summary>
    /// <returns>
    /// A record from the <c>CustVendTable</c> table; otherwise, an empty record.
    /// </returns>
    public CustVendTable findCustVendTable()
    {
        CustVendTable custVendTable;

        if (this.AccountType == LedgerJournalACType::Vend || this.AccountType == LedgerJournalACType::Cust)
        {
            custVendTable = CustVendTable::findModule(this.AccountType == LedgerJournalACType::Vend ? ModuleCustVend::Vend : ModuleCustVend::Cust, this.parmAccount());
        }
        else if (this.OffsetAccountType == LedgerJournalACType::Vend || this.OffsetAccountType == LedgerJournalACType::Cust)
        {
            custVendTable = CustVendTable::findModule(this.OffsetAccountType == LedgerJournalACType::Vend ? ModuleCustVend::Vend : ModuleCustVend::Cust, this.parmOffsetAccount());
        }

        return custVendTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWHTUsingInvoiceId_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the invoice id which tax withholding is using.
    /// </summary>
    /// <returns>The invoice id.</returns>
    internal InvoiceId getWHTUsingInvoiceId_IN()
    {
        InvoiceId invoice = this.Invoice;
        if (!invoice
            && this.AccountType == LedgerJournalACType::Cust
            && this.OffsetAccountType == LedgerJournalACType::Bank)
        {
            invoice = this.MarkedInvoice;
        }

        return invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSetDeleteForLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the records of the <c>LedgerJournalTrans</c> table
    /// associated with the specified <c>LedgerJournalTable</c> record.
    /// The operation would downgrade to row by row if any of the following conditions is true:
    /// 1. The uptake logic has delete event handler.
    /// 2. Database logging is enabled for LedgerJournalTrans table.
    /// </summary>
    /// <param name="_journalNum">
    /// The <c>JournalNum</c> value.
    /// </param>
    protected static void processSetDeleteForLedgerJournalTable(LedgerJournalId _journalNum)
    {
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTable ledgerJournalTable = LedgerJournalTable::find(_journalNum);

        ledgerJournalTrans.skipDeleteActions(true);
        ledgerJournalTrans.skipDataMethods(true);

        if (LedgerJournalTrans::skipHandlerEventsOnDelete(ledgerJournalTable))
        {
            ledgerJournalTrans.skipDatabaseLog(true);
            ledgerJournalTrans.skipEvents(true);
        }

        delete_from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _journalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipHandlerEventsOnDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method decides if post or pre handler events on the LedgerJournalTrans should be skipped.
    /// Default true. Uptake module can override the behavior through CoC
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// Journal header buffer.
    /// </param>
    /// <returns>
    /// True if it is ok to skip event handler executions; otherwise False.
    /// </returns>
    protected static boolean skipHandlerEventsOnDelete(LedgerJournalTable _ledgerJournalTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAssetJournalLineReportingCurrecyAmountShouldBeUsed</Name>
				<Source><![CDATA[
    private boolean isAssetJournalLineReportingCurrecyAmountShouldBeUsed(LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        return (_ledgerJournalTrans_Asset
            && Ledger::reportingCurrency() != ''
            && this.CurrencyCode != Ledger::reportingCurrency()
            && (_ledgerJournalTrans_Asset.isDepreciationTransactionType()
                || (FeatureStateProvider::isFeatureEnabled(AssetSplitReportingCurrencyFeature::instance())
                    && _ledgerJournalTrans_Asset.isSplitTransaction())));
    }

]]></Source>
			</Method>
			<Method>
				<Name>impliedDataAreaFieldNameDelegate</Name>
				<Source><![CDATA[
    [SubscribesTo(classStr(DimensionObjectStorageTableReferenceProcessor), delegatestr(DimensionObjectStorageTableReferenceProcessor, impliedDataAreaFieldNameDelegate))]
    static void impliedDataAreaFieldNameDelegate(TableId _tableId, FieldId _fieldId, EventHandlerResult _result)
    {
        if (_tableId == tableNum(LedgerJournalTrans))
        {
            switch(_fieldId)
            {
                case(fieldNum(LedgerJournalTrans, LedgerDimension)):
                case(fieldNum(LedgerJournalTrans, DefaultDimension)):
                    _result.result(fieldStr(LedgerJournalTrans, Company));
                    break;
                case(fieldNum(LedgerJournalTrans, OffsetLedgerDimension)):
                case(fieldNum(LedgerJournalTrans, OffsetDefaultDimension)):
                    _result.result(fieldStr(LedgerJournalTrans, OffsetCompany));
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>supportsGenerateBankOrLedgerCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the <c>LedgerJournalTrans</c> record supports generating the bank or ledger check.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The corresponding <c>LedgerJournalTable</c> record of the <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// True is the record supports generating the bank or ledger check; otherwise false.
    /// </returns>
    internal boolean supportsGenerateBankOrLedgerCheck(LedgerJournalTable _ledgerJournalTable = this.ledgerJournalTable())
    {
        return BankParameters::find().AllowBankLedgerCheck == NoYes::Yes
            && _ledgerJournalTable.JournalType == LedgerJournalType::Payment
            && VendPaymModeTable::find(this.PaymMode).PaymentType == PaymentType::Check;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePostingDateAutoAdjustmentStrategy</Name>
				<Source><![CDATA[
    protected VendInvoicePostingDateAutoAdjustment determinePostingDateAutoAdjustmentStrategy()
    {
        return VendParameters::find().VendInvoicePostingDateAutoAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostingDate</Name>
				<Source><![CDATA[
    internal void updatePostingDate()
    {
        TransDate newDate;
        boolean canUpdate = false;
        LedgerJournalTable ledgerJournalTable = this.ledgerJournalTable();
        SysModule sysModule;

        if (VendInvoiceJourBasedOnVendModuleFlight::instance().isEnabled())
        {
            sysModule = ledgerJournalTable.ledgerJournalName().getSysModuleForJournal();
        }
        else
        {
            sysModule = SysModule::Purch;
        }

        switch (this.determinePostingDateAutoAdjustmentStrategy())
        {
            case VendInvoicePostingDateAutoAdjustment::NoChange:
                canUpdate = false;
                break;

            case VendInvoicePostingDateAutoAdjustment::AlwaysChangeToSystemDate:
                newDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                canUpdate = true;
                break;

            case VendInvoicePostingDateAutoAdjustment::ChangeToSystemDateWhenPeriodIsOnHoldOrClosed:
                if (!LedgerFiscalCalendar::checkLedgerPeriodDateModule(CompanyInfoHelper::fiscalCalendarRecId(), this.TransDate, sysModule, false))
                {
                    newDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    canUpdate = true;
                }
                break;

            case VendInvoicePostingDateAutoAdjustment::ChangeToFirstDayOfNewPeriodWhenPeriodIsOnHoldOrClosed:
                if (!LedgerFiscalCalendar::checkLedgerPeriodDateModule(CompanyInfoHelper::fiscalCalendarRecId(), this.TransDate, sysModule, false))
                {
                    newDate = LedgerFiscalCalendar::findFirstOpenStartDateModule(CompanyInfoHelper::fiscalCalendarRecId(), this.TransDate, sysModule);
                    canUpdate = true;
                }
                break;
        }

        if (canUpdate)
        {
            this.modifyTransDate(newDate, this.TransDate);

            if (VendInvoicePostingDateAutoAdjustmentV2Flight::instance().isEnabled())
            {
                LedgerJournalEngine ledgerJournalEngine = LedgerJournalEngine::construct(ledgerJournalTable.JournalType);
                ledgerJournalEngine.ledgerJournalTable(ledgerJournalTable);
                ledgerJournalEngine.currencyModified(this);
            }

            this.selectForUpdate(true);
            this.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyTransDate</Name>
				<Source><![CDATA[
    private void modifyTransDate(Transdate _newDate, Transdate _documentOrTransDate)
    {
        if ((_newDate != dateNull()) && (_newDate != _documentOrTransDate))
        {
            if (this.checkFiscalYear(_newDate, _documentOrTransDate))
            {
                this.TransDate = _newDate;
                this.modifiedField(fieldNum(LedgerJournalTrans, TransDate));
            }
        }
              
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFiscalYear</Name>
				<Source><![CDATA[
    private boolean checkFiscalYear(Transdate _newDate, TransDate _oldDate)
    {
        if (!FiscalCalendars::areDatesInSameFiscalYear(CompanyInfoHelper::fiscalCalendarRecId(), _newDate, _oldDate))
        {
            VendParameters vendParameters = VendParameters::find();

            if (vendParameters.CrossYearPostingDateAdjustment == CrossYearPostingDateAdjustment::BlockWithError)
            {
                throw error("@AccountsPayable:DatesAreNotInSameFiscalYear");
            }
            else if (vendParameters.CrossYearPostingDateAdjustment == CrossYearPostingDateAdjustment::AllowWithWarning)
            {
                warning("@AccountsPayable:DatesAreNotInSameFiscalYear");
            }

        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsVATDueDateDiffInJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the date of VAT register is different from other lines in journal.
    /// </summary>
    /// <returns>
    /// true if there is a different date of VAT register in journal; otherwise, false.
    /// </returns>
    public boolean existsVATDueDateDiffInJournal()
    {
        LedgerJournalTrans ledgerJournalTransOther;
        select firstonly RecId from ledgerJournalTransOther
            where ledgerJournalTransOther.JournalNum == this.JournalNum
                && ledgerJournalTransOther.Voucher == this.Voucher
                && ledgerJournalTransOther.RecId != this.RecId
                && (ledgerJournalTransOther.TaxCode
                    || (ledgerJournalTransOther.TaxGroup
                        && ledgerJournalTransOther.TaxItemGroup))
                && ledgerJournalTransOther.VatDueDate_W != this.VatDueDate_W;
        return (ledgerJournalTransOther.RecId > 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineExchangeRateDate</Name>
				<Source><![CDATA[
    internal TransDate determineExchangeRateDate()
    {
        TransDate exchRateDate;
        
        if (VendInvoicePostingDateAutoAdjustmentV2Flight::instance().isEnabled())
        {
            LedgerJournalType journalType = this.ledgerJournalTable().JournalType;

            if (journalType == LedgerJournalType::VendInvoiceRegister ||
                journalType == LedgerJournalType::PurchaseLedger ||
                journalType == LedgerJournalType::VendInvoicePool)             
            {
                VendParameters vendParameter = VendParameters::find();

                if (vendParameter.UseDocumentDate)
                {
                    exchRateDate = this.documentDate;
                }
                else
                {
                    PurchParameters purchParameters = purchParameters::find();
                    if (purchParameters.DateOfExchRate_W == DateOfExchRate_W::DocumentDate)
                    {
                        exchRateDate = this.documentDate;
                    }
                    else if (purchParameters.DateOfExchRate_W == DateOfExchRate_W::PostingDate)
                    {
                        exchRateDate = this.TransDate;
                    }
                }
            }
        }
        return exchRateDate ? exchRateDate : this.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasVendorPrepayment</Name>
				<Source><![CDATA[
    internal static boolean hasVendorPrepayment(
        LedgerJournalId _journalNum,
        Voucher _voucher)
    {
        return LedgerJournalTrans::hasPrepaymentByLedgerAccountType(
            _journalNum,
            _voucher,
            LedgerJournalACType::Vend);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCustomerPrepayment</Name>
				<Source><![CDATA[
    internal static boolean hasCustomerPrepayment(
        LedgerJournalId _journalNum,
        Voucher _voucher)
    {
        return LedgerJournalTrans::hasPrepaymentByLedgerAccountType(
            _journalNum,
            _voucher,
            LedgerJournalACType::Cust);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPrepaymentByLedgerAccountType</Name>
				<Source><![CDATA[
    private static boolean hasPrepaymentByLedgerAccountType(
        LedgerJournalId _journalNum,
        Voucher _voucher,
        LedgerJournalACType _accountType)
    {
        LedgerJournalTrans ledgerJournalTrans;
        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _JournalNum
                && ledgerJournalTrans.Voucher == _voucher
                && ledgerJournalTrans.Prepayment == NoYes::Yes
                && (ledgerJournalTrans.AccountType == _accountType
                    || ledgerJournalTrans.OffsetAccountType == _accountType);

        return LedgerJournalTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPrepaymentJournalLine</Name>
				<Source><![CDATA[
    internal static boolean hasPrepaymentJournalLine(
        LedgerJournalId _journalNum,
        Voucher _voucher)
    {
        LedgerJournalTrans ledgerJournalTrans;
        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _JournalNum
                && ledgerJournalTrans.Voucher == _voucher
                && ledgerJournalTrans.Prepayment == NoYes::Yes;

        return LedgerJournalTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimensionsOrOffsetDefaultDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns default dimensions or offset default dimensions from a given journal line (<c>LedgerJournalTrans</c> record).
    /// If account is not ledger account, then value of a DefaultDimension/OffsetDefaulDimension field is returned.
    /// If acccount is ledger account, then value of a DefaultDimension/OffsetDefaulDimension is retrieved from LedgerDimension.
    /// As default dimension / offset default dimension is empty in this case.
    /// </summary>
    /// <param name = "_isOffset">
    /// Boolean parameter to switch logic between default dimension and offset default dimension.
    /// </param>
    /// <returns>
    /// The record ID of the associated <c>DimensionAttributeValueSet</c> record.
    /// </returns>
    internal DimensionDefault getDefaultDimensionsOrOffsetDefaultDimensions(boolean _isOffset)
    {
        DimensionDefault defaultDimensions = 0;

        defaultDimensions = _isOffset ? this.OffsetDefaultDimension : this.DefaultDimension;

        if (!defaultDimensions)
        {
            LedgerJournalACType accountType = _isOffset ? this.OffsetAccountType : this.AccountType;

            if (accountType == LedgerJournalACType::Ledger)
            {
                defaultDimensions = _isOffset ? LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(this.OffsetLedgerDimension) : LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(this.LedgerDimension);
            }
        }
       
        return defaultDimensions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalTransDefaultDimensions</Name>
				<Source><![CDATA[
    internal DimensionDefault getLedgerJournalTransDefaultDimensions()
    {
        return this.getDefaultDimensionsOrOffsetDefaultDimensions(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalTransOffsetDefaultDimensions</Name>
				<Source><![CDATA[
    internal DimensionDefault getLedgerJournalTransOffsetDefaultDimensions()
    {
        return this.getDefaultDimensionsOrOffsetDefaultDimensions(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVendBankAccount</Name>
				<Source><![CDATA[
    private boolean checkVendBankAccount()
    {
        return PaymentRequestRecepientBankAccountCorrectionHelper::isEnabled() || VendBankAccount::checkBankAccountIsActiveForDate(
            this.parmAccount(),
            this.CustVendBankAccountId,
            this.TransDate,
            this.Company);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustBankAccount</Name>
				<Source><![CDATA[
    private boolean checkCustBankAccount()
    {
        return PaymentRequestRecepientBankAccountCorrectionHelper::isEnabled() || CustBankAccount::checkBankAccountReference(
            this.parmAccount(),
            this.CustVendBankAccountId,
            this.Company);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LedgerBasic</ConfigurationKey>
	<DeveloperDocumentation>@SYS125945</DeveloperDocumentation>
	<Label>@SYS23470</Label>
	<TableGroup>WorksheetLine</TableGroup>
	<TitleField1>JournalNum</TitleField1>
	<TitleField2>Voucher</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>NotInTTS</CacheLookup>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>AccountingFoundation</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>RCashDestinationTrans</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>RCashDestinationTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>RAssetPurchTrans</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>RAssetPurchTrans</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>PaymentOrderBudgetTrans_RU</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>PaymentOrderBudgetTrans_RU</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>LedgerJournalTrans_RDeferrals</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>LedgerJournalTrans_RDeferrals</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>LedgerJournalTrans_RCash</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>LedgerJournalTrans_RCash</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CashDueAnnouncementJournal_RU</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CashDueAnnouncementJournal_RU</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>LedgerJournalTransPayment_BR</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>LedgerJournalTransPayment_BR</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>LedgerJournalTransPayment_LV</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>LedgerJournalTransPayment_LV</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>LedgerJournalTrans_Asset</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>LedgerJournalTrans_Asset</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>PlSADFinanceLedgerJournalRef</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>PlSADFinanceLedgerJournalRef</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>AssetBookTableDerivedJournal</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>AssetBookTableDerivedJournal</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CustTransCashDisc</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustTransCashDisc</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CustVendCreditInvoicingTable</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustVendCreditInvoicingTable</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CustVendNACHAIATInfoTable_US</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustVendNACHAIATInfoTable_US</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CustVendPaymJournalFee</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustVendPaymJournalFee</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CustVendPDCRegister</Name>
			<Relation></Relation>
			<Table>CustVendPDCRegister</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>LedgerJournalTransBankLC</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>LedgerJournalTransBankLC</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction1</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>TaxGSTTaxInformation_MY</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction2</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>LedgerJournalTrans_Error</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction3</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustVendNetJournalLineLink</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction4</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation>LedgerJournalTrans</Relation>
			<Table>LedgerJournalTrans_W</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction5</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>VendTransCashDisc</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>DeleteAction6</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>AssetReversalRelatedVoucher</Table>
			<Tags></Tags>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JournalNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurDebit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurCredit</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Account_W</Name>
			<Label>@SYS2355</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Company</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Txt</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Administration</Name>
			<Label>@SYS9853</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymentStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Cancel</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Agreement_RU</Name>
			<Label>@GLS104636</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AgreementCompany_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountAgreementId_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>accountAgreementDocumentTitle_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Amount</Name>
			<Label>@SYS12227</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RemainAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CashDiscAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Approve</Name>
			<Label>@SYS16449</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Approver</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Approved</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceReleaseDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReleaseDateComment</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Bank</Name>
			<Label>@SYS22173</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankTransType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymReference</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AnnouncementNum_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankChequeDepositTransRef</Name>
			<Label>@SYS102674</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankChequeDepositTransRefRecID</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankClientDocumentType_RU</Name>
			<Label>@SYS80739</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankClientDocumentTypeId_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>paymentDocumentName_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankCurrencyDealCourse_RU</Name>
			<Label>@GLS114373</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankCurrencyDealCourse_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransferCurrency_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankClientDocumentTypeId_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankSpecAccountId_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankCommAccountId_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankVendAccountId_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankAgreementExt_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankRespWorkerId_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BankReconcileAtChequeReversal</Name>
			<Label>@SYS100071</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankReconcileAccountAtPost</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BillOfExchangeDocument</Name>
			<Label>@SYS79267</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankBillOfExchangeNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BTL91</Name>
			<Label>@SYS75603</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymInstruction1</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymInstruction2</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymInstruction3</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymInstruction4</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BudgetSource</Name>
			<Label>@SYS127829</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BudgetSourceLedgerEntryUnposted</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CashDiscBaseDate</Name>
			<Label>@SYS61119</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CashDiscBaseDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CashDiscount</Name>
			<Label>@SYS4376</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CashDiscCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateCashDisc</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CashDiscAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CashDiscPercent</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CashReceipts_LV</Name>
			<Label>@GLS113242</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CashReceiptNum_LV</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Correct_RU</Name>
			<Label>@SYS13069</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Correct_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CorrectedInvoiceId_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CorrectedInvoiceDate_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CorrectionType_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Currency</Name>
			<Label>@SYS7572</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AmountCurDebit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurCredit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ExchRateSecond</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CurrencyShow</Name>
			<Label>@SYS7572</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AmountCurDebit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountCurCredit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Triangulation</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>editExchRateSecond</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DEL_AssessableValue_IN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DEL_MaximumRetailPrice_IN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CustomerImportPayments</Name>
			<Label>@SYS26610</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LoadingDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dates</Name>
			<Label>@SYS80293</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AcknowledgementDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>DepositSlip</Name>
			<Label>@SYS23659</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankDepositVoucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankDepositNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankChequeNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Description</Name>
			<Label>@SYS7576</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Txt</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimension</Name>
			<Label>@SYS342338</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DefaultDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetDefaultDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>DiotInformation_MX</Name>
			<Label>@SYS312478</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OperationType_MX</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Document</Name>
			<Label>@SYS98369</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DocumentNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DocumentDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>EUSalesList</Name>
			<Label>@SYS11410</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>EUSalesList</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ExportPayments</Name>
			<Label>@SYS12612</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FileCreated</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentSequenceNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustEinvoicePaymDeliveryNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustEinvoicePaymSectionNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustEinvoicePaymTransNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ForeignPayments_LT</Name>
			<Label>@AccountsPayable:MiscellaneousPaymentInformation</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InformByTelex_LT</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InformByPhone_LT</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DebitCurrencyCode_LT</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>FurtherPosting</Name>
			<Label>@SYS83891</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FurtherPostingType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FurtherPostingRecId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>g1099Fields</Name>
			<Label>@SYS24226</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Tax1099Fields</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Tax1099Amount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Tax1099State</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Tax1099StateAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GSTHSTTaxType_CA</Name>
			<Label>@SYS313827</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>GSTHSTTaxType_CA</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>JournalNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LineNum</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerVoucherType_CN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FBSpedEcfDerexClasificationCode_BR</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>IntercompanyAccounting</Name>
			<Label>@SYS3805</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ForeignVoucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ForeignCompany</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Intrastat</Name>
			<Label>@SYS6530</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Listcode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Invoice</Name>
			<Label>@SYS12128</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Invoice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Due</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Payment</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VATNumJournal</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>EnterpriseNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PurchIdRange</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CFDIUUID_MX</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceSeries_MX</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>InvoicePool</Name>
			<Label>@SYS58907</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PoolRecId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Item</Name>
			<Label>@SYS14428</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerJournalDlvDate_ES</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Markup_RU</Name>
			<Label>@SYS116804</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MarkupCode_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>MCRBankReconciliation</Name>
			<Label>@SYS24040</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MCRCCGeneralLedgerId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>MCRMiscellaneous</Name>
			<Label>@SYS80069</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>MCRPrintTxtOnCheck</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustTransId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Misc</Name>
			<Label>@SYS80069</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CompanyLocation_IN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxWithholdAlternateVendorAcct_TH</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>NegInst</Name>
			<Label>@SYS71438</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankRemittanceFileId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NegInstId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>NegotiableInstrument</Name>
			<Label>@SYS71438</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustVendNegInstProtestReason</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Due</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankRemittanceType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankAccountId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>NotificationToTheCentralBank</Name>
			<Label>@SYS67156</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankCentralBankPurposeCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankCentralBankPurposeText</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ImportDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankCentralBankTransTypeCur_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankCurrencyTransferLog_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankPaymentRegistrationNum_LV</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Officials_RU</Name>
			<Label>@GLS102112</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OffSessionId_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>OffsetAccount</Name>
			<Label>@SYS11162</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OffsetTxt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetCompany</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetAccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetLedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetAgreementCompany_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetAccountAgreementId_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>offsetAccountAgreementDocumentTitle_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>OffsetAccount_W</Name>
			<Label>@SYS11162</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>OffsetCompany</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetAccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetTxt</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Payment</Name>
			<Label>@SYS828</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymentNotes</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymMode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymSpec</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Prepayment</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ErrorCodePayment</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RemitteeCurrency</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>BankNegInstRecipientName</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymPurpose_LT</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Payment_RU</Name>
			<Label>@SYS828</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PaymMode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymSpec</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PaymentNotes</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Prepayment</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustFactureAutoCreate_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UseOriginalDocumentAsFacture_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PaymentOrder_LV</Name>
			<Label>@GLS108610</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>IntBank_LV</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Periodic</Name>
			<Label>@SYS8782</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>FreqCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>FreqValue</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LastTransferred</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Posting</Name>
			<Label>@SYS12919</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PostingProfile</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Company</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountAgreementId_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>accountAgreementDocumentTitle_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Posting_W</Name>
			<Label>@SYS12919</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PostingProfile</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SettleVoucher</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PostingProfiles_RU</Name>
			<Label>@GLS103572</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PostingProfile</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetPostingProfile_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>SettleVoucher</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PostingRelease</Name>
			<Label>@sys114594</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReleaseDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PrintPaymentOrder_RU</Name>
			<Label>@GLS103114</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankPrintAccountNum_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ProjectIdentification</Name>
			<Label>@SYS89920</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ProjectIdentificationLedger</Name>
			<Label>@SYS89920</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransDate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LedgerDimension</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>OffsetLedgerDimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PromissoryNoteDocument</Name>
			<Label>@SYS74003</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankPromissoryNoteNum</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PSA</Name>
			<Label>@PSA43</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Purch</Name>
			<Label>@SYS9283</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PurchLedgerPosting</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Quantity</Name>
			<Label>@SYS3065</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Price</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>RCashOrderNotes_RU</Name>
			<Label>@GLS100690</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>BankCentralBankPurposeText</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>RCashPayTransType</Name>
			<Label>@SYS21201</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RCashPayTransType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reason</Name>
			<Label>@SYS107174</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReasonRefRecID</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReceiptDate_W</Name>
			<Label>@GLS110092</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReceiptDate_W</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reference_CN</Name>
			<Label>@SYS15217</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RefCopyReverse_CN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reference_RU</Name>
			<Label>@GLS106473</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VATPaymRefRecId_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Remittance</Name>
			<Label>@sys152838</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RemittanceAddress</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RemittanceLocation</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Representative_RU</Name>
			<Label>@SYS54387</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RCashDocRepresType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RCashDocRepresPersonId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>represPersonNameEdit_W</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>represPersonCardEdit_W</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReversingEntry</Name>
			<Label>@SYS116155</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>RevRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReverseEntry</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReverseDate</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTax</Name>
			<Label>@SYS5878</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxDirectionControl</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxBase_W</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VatDueDate_W</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntraComVATDueDate_W</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Settlement</Name>
			<Label>@SYS10163</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>SettleVoucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MarkedInvoice</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MarkedInvoiceRecId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MarkedInvoiceCompany</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MCRPaymOrderID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MCRCCGeneralLedgerId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MCRRefPaymID</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ThirdPartyBank</Name>
			<Label>@SYS79534</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustVendBankAccountId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>TransactionType</Name>
			<Label>@SYS21201</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Transfer</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransactionType</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transfer</Name>
			<Label>@SYS13220</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransferredBy</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransferredOn</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransferredTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Transferred</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VATOnPayment_RU</Name>
			<Label>@GLS106909</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VATOnPayment_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VatRegister_PL</Name>
			<Label>@GLS105955</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustVendAccount_PL</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Addressing_PL</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VATNumJournal</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustVendName_PL</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VatDueDate_W</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>IntraComVATDueDate_W</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxPeriodPaymentCode_PL</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VATTaxAgent_RU</Name>
			<Label>@GLS112871</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VATTaxAgentVendAccount_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VATOperationCode_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VATTaxAgentInvoice_RU</Name>
			<Label>@GLS112871</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VATOperationCode_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VendInvoiceDeclaration</Name>
			<Label>@SYS126906</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VendInvoiceDeclaration_IS</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>VendTrans</Name>
			<Label>@SYS13278</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>VendTransId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Voucher_CN</Name>
			<Label>@GLS60258</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>LedgerVoucherType_CN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher_CN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Attachments_CN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>WithHoldingTax</Name>
			<Label>@SYS7372</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxWithholdCalculate_TH</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxWithholdGroup</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxWithholdItemGroupHeading_TH</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TDSGroup_IN</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TCSGroup_IN</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CFDI_MX</Name>
			<Label>@SYS4081641</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CFDIUUID_MX</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReportingCurrency</Name>
			<Label>@GeneralLedger:ReportingCurrency</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ReportingCurrencyExchRate</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReportingCurrencyExchRateSecondary</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>CommissionTrade_RU</Name>
			<Label>@SalesPurchBook:CommissionTrade</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CommProfileType_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ElectronicPaymentNumberGroup</Name>
			<Label>@SYS22514</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ElectronicPaymentNumber</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxWithholdAlternateVendorAcct_TH</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxWithholdAlternateVendorAcct_TH</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PoolRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>LedgerJournalTransRefRecId</ExtendedDataType>
			<Label>@SYS76108</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymentAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>BankElectronicBanking</ConfigurationKey>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
			<Label>@SYS21686</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Company</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SelectableDataArea</ExtendedDataType>
			<Label>@SYS13342</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountAgreementId_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementId_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AccountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>LedgerJournalACType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>AcknowledgementDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AcknowledgementDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Addressing_PL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>PL</CountryRegionCodes>
			<ExtendedDataType>Addressing</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AgreementCompany_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementCompany_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AmountCurCredit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountCurCredit</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AmountCurDebit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountCurDebit</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AnnouncementNum_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankCashDueAnnouncement_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Approved</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Approved</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Approver</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>HcmApprover</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>DEL_AssessableValue_IN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@GLS5298</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>Attachments_CN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>CN</CountryRegionCodes>
			<ExtendedDataType>Counter</ExtendedDataType>
			<Label>@SYS73813</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankAccountId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>CustVendNegotiableInstrument</ConfigurationKey>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankAgreementExt_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementHeaderExtRecId_RU</ExtendedDataType>
			<Label>@GLS114396</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankBillOfExchangeNum</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankBillOfExchangeNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankCentralBankPurposeCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankCentralBankPurposeCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankCentralBankPurposeText</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankCentralBankPurposeText</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankCentralBankTransTypeCur_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankCentralBankTransTypeCur_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankChequeDepositTransRefRecID</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ConfigurationKey>Bank</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS117501</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankChequeNum</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankChequeNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankClientDocumentTypeId_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankClientDocumentTypeId_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankCommAccountId_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
			<Label>@GLS102283</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>BankCurrencyAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>BankCurrencyDealCourse_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankCurrencyDealCourse_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankCurrencyTransferLog_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS114386</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankDepositNum</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankDepositNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankDepositVoucher</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankDepositVoucher</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankNegInstRecipientName</Name>
			<AssetClassification>Customer Content </AssetClassification>
			<ExtendedDataType>BankNegInstRecipientName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankPaymentRegistrationNum_LV</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>LV</CountryRegionCodes>
			<ExtendedDataType>LvBankPaymentRegistrationNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankPrintAccountNum_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Bank</ConfigurationKey>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>LedgerJournalAC</ExtendedDataType>
			<Label>@GLS103112</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankPromissoryNoteNum</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankPromissoryNoteNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankReconcileAccountAtPost</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>Bank</ConfigurationKey>
			<Label>@Sys117279</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankRemittanceFileId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankRemittanceFileId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>BankRemittanceType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>BankRemittanceType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BankRespWorkerId_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>HcmWorkerRecId</ExtendedDataType>
			<Label>@GLS102281</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankSpecAccountId_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
			<Label>@GLS107795</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankTransType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankTransactionType</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BankVendAccountId_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>VendAccount</ExtendedDataType>
			<Label>@GLS114384</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>BudgetSourceLedgerEntryUnposted</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerAdv2BudgetCtrl</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Cancel</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>VendInvoiceRegisterApproval</ConfigurationKey>
			<ExtendedDataType>Cancelled</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CashDiscAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DiscAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>CashDiscBaseDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CashDiscBaseDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>CashDiscBaseDays</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CashDiscBaseDays</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CashDiscCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CashDiscCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CashDiscPercent</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>ES</CountryRegionCodes>
			<ExtendedDataType>DiscPct</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CashReceiptNum_LV</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>LV</CountryRegionCodes>
			<ExtendedDataType>LvCashReceiptNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CompanyLocation_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>LogisticsLocationRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ConsignmentNoteNum_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>ConsignmentNum_IN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Correct_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Correct_RU</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>CorrectedInvoiceDate_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CorrectedInvoiceDate_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CorrectedInvoiceId_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CorrectedInvoiceId_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CorrectionType_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>FactureCorrectionType_RU</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencyCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CustBankAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>CustEinvoicePaymDeliveryNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustEinvoicePaymDeliveryNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>CustEinvoicePaymSectionNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustEinvoicePaymSectionNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>CustEinvoicePaymTransNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustEinvoicePaymTransNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CustFactureAutoCreate_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustFactureAutoCreate_RU</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CustomsDuty_IN</Name>
			<ConfigurationKey>SysDeletedObjects73</ConfigurationKey>
			<ExtendedDataType>CustomsAmount_IN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CustomsTariffCodeTable_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS5516</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CustomsTariffDirection_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<Label>@GLS5515</Label>
			<EnumType>Direction_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CustTransId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustTransRefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustVendAccount_PL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PlCustVendAccount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustVendBankAccountId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>BankAccountID</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CustVendName_PL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PlCustVendName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CustVendNegInstProtestReason</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CustVendNegInstProtestReason</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DateCashDisc</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS26471</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DebitCurrencyCode_LT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LtDebitCurrencyCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDimensionValueSet</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DocumentDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DocumentDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>DocumentNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DocumentNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>Due</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DueDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>EnterpriseNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxEnterpriseNumber</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ErrorCodePayment</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ErrorCodePayment</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>EUSalesList</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ListDispatchId</ExtendedDataType>
			<FeatureClass>EUSalesListToggle</FeatureClass>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchRate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExchRate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ExchRateSecond</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ExchrateSecondary</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ExciseRecordType_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<EnumType>ExciseRecordType_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ExciseTariffCodes_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS5344</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ExciseType_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<EnumType>ExciseType_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>FileCreated</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS22185</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ForeignCompany</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerAdvIntercompanyAccounting</ConfigurationKey>
			<ExtendedDataType>SelectableDataArea</ExtendedDataType>
			<Label>@SYS25343</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ForeignVoucher</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerAdvIntercompanyAccounting</ConfigurationKey>
			<ExtendedDataType>Voucher</ExtendedDataType>
			<Label>@SYS25344</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>FreqCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasic</ConfigurationKey>
			<EnumType>PeriodUnit</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>FreqValue</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasic</ConfigurationKey>
			<ExtendedDataType>Freq</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>FurtherPostingRecId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>LedgerJournalTransRefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>FurtherPostingType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>FurtherPostingType</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>GSTHSTTaxType_CA</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>GSTHSTTaxType_CA</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>GTAServiceCategory_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<EnumType>GTAServiceCategory_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ImportDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS66024</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InformByPhone_LT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LTInformByPhone</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InformByTelex_LT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LTInformByTelex</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>IntBank_LV</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>LV</CountryRegionCodes>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>IntraComVATDueDate_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>IntraComVATDueDate_W</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Invisible</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Invoice</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InvoiceId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>InvoiceReleaseDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InvoiceReleaseDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>JournalNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalId</ExtendedDataType>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>LastTransferred</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LastTransferred</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDynamicAccount</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>LedgerJournalDlvDate_ES</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalDlvDate_ES</ExtendedDataType>
			<FeatureClass>LedgerJournalDlvDateToggle</FeatureClass>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>LedgerVoucherType_CN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerVoucherTypeRefRecId_CN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>LineNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LineNum</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Listcode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ListcodeId</ExtendedDataType>
			<FeatureClass>EUSalesListToggle</FeatureClass>
			<EnumType>Listcode</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>LoadingDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS22179</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldContainer">
			<Name>MainAccountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SysContainer</ExtendedDataType>
			<Label>@SYS125447</Label>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MarkedInvoice</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InvoiceId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MarkedInvoiceCompany</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SelectableDataArea</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>MarkedInvoiceRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MarkupCode_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>MarkupCodeVend_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>DEL_MaximumRetailPrice_IN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>AmountCur</ExtendedDataType>
			<Label>@GLS5296</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MCRCCGeneralLedgerId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>MCRPayment</ConfigurationKey>
			<ExtendedDataType>LedgerJournalId</ExtendedDataType>
			<Label>@MCR24856</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>MCRPaymOrderID</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>MCRPaymOrderId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>MCRPrintTxtOnCheck</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>MCRPrintTxtOnCheck</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>MCRRefPaymID</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>MCRPayment</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS11443</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>NatureOfAssessee_IN</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ConfigurationKey>SysDeletedObjects73</ConfigurationKey>
			<EnumType>NatureOfAssessee_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>NegInstId</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustVendNegInstId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>NoEdit</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>NonRecoverablePercent_IN</Name>
			<ConfigurationKey>SysDeletedObjects73</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>Percent</ExtendedDataType>
			<Label>@GLS5534</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OffSessionId_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>OffSessionId_RU</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OffsetAccountAgreementId_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementId_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OffsetAccountType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS23950</Label>
			<EnumType>LedgerJournalACType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OffsetAgreementCompany_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AgreementCompany_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OffsetCompany</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerAdvIntercompanyAccounting</ConfigurationKey>
			<ExtendedDataType>SelectableDataArea</ExtendedDataType>
			<Label>@GeneralLedger:OffsetCompany</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OffsetDefaultDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerDefaultDimensionValueSet</ExtendedDataType>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OffsetLedgerDimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DimensionDynamicAccount</ExtendedDataType>
			<Label>@SYS11162</Label>
			<SysSharingType>Never</SysSharingType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OffsetPostingProfile_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PostingProfile</ExtendedDataType>
			<Label>@GLS104672</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OffsetTxt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalTransTxt</ExtendedDataType>
			<Label>@SYS24282</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>OperationType_MX</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>VendorOperationType_MX</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldContainer">
			<Name>PackedExtensions</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SysExtensionSerializerPackedContainer</ExtendedDataType>
			<SaveContents>No</SaveContents>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Payment</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymTermId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymentNotes</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymNote</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>PaymentSequenceNum</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Counter</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PaymentStatus</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>CustVendPaymStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PaymInstruction1</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymInstructionRecId</ExtendedDataType>
			<Label>@SYS75599</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PaymInstruction2</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymInstructionRecId</ExtendedDataType>
			<Label>@SYS75600</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PaymInstruction3</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymInstructionRecId</ExtendedDataType>
			<Label>@SYS75601</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>PaymInstruction4</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymInstructionRecId</ExtendedDataType>
			<Label>@SYS75602</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymMode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymMode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymPurpose_LT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LtPaymentPurpose</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymReference</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymReference</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymSpec</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PaymSpec</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PostingProfile</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PostingProfile</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Prepayment</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasicSalesTax</ConfigurationKey>
			<Label>@SYS59473</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Price</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Price</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PurchIdRange</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchIdRange</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PurchLedgerPosting</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>VendInvoiceRegisterApproval</ConfigurationKey>
			<ExtendedDataType>PurchLedgerPosting</ExtendedDataType>
			<EnumType>ArrivalPostingType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Qty</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>QtyStatistical</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RCashDocRepresPersonId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RCashDocRepresPersonId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RCashDocRepresType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>RCashDocRepresType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RCashPayTransType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<EnumType>RCashPayLedgerTransType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ReasonRefRecID</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ExtendedDataType>ReasonRefRecID</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ReceiptDate_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PurchReceiptDate_W</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>RefCopyReverse_CN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasic</ConfigurationKey>
			<CountryRegionCodes>CN</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS54944</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldUtcDateTime">
			<Name>ReleaseDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PostReleaseDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReleaseDateComment</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReleaseDateComment</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>RemainAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Amount</ExtendedDataType>
			<Label>@SYS95</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>RemittanceAddress</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RemittanceAddress</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>RemittanceLocation</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RemittanceLocation</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RemitteeCurrency</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<Label>@SYS91987</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RepresPersonCard_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU,PL,LV,EE,CZ,HU</CountryRegionCodes>
			<ExtendedDataType>PayeeDocument_RU</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>RepresPersonName_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU,PL,LV,EE,CZ,HU</CountryRegionCodes>
			<ExtendedDataType>EmplName</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ReverseDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasicReversingEntries</ConfigurationKey>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS116153</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ReverseEntry</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasicReversingEntries</ConfigurationKey>
			<Label>@SYS116155</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>RevRecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ConfigurationKey>LedgerBasicReversingEntries</ConfigurationKey>
			<ExtendedDataType>LedgerJournalTransRefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SalesTaxFormTypes_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>SalesTaxFormTypesRecId_IN</ExtendedDataType>
			<Label>@GLS5518</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ServiceCodeTable_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@GLS5065</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SettleVoucher</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>SettlementType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SkipBlockedForManualEntryCheck</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>SoftwareDeclReceived_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>SoftwareDeclReceived_IN</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Tax1099Amount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Tax1099Amount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Tax1099Fields</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Tax1099FieldsRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>Tax1099RecId</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<ConfigurationKey>PublicSector</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Tax1099State</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Tax1099State</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Tax1099StateAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Tax1099StateAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxBase_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxBase_W</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxDirectionControl</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>LedgerBasicSalesTax</ConfigurationKey>
			<Label>@SYS22926</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxGroupJournal</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxItemGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxGroupJournal</ExtendedDataType>
			<Label>@SYS21932</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxPeriodPaymentCode_PL</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PlTaxPeriodPaymentCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxSetoffVoucher_IN</Name>
			<ConfigurationKey>SysDeletedObjects73</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>Voucher</ExtendedDataType>
			<Label>@GLS221798</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TaxWithholdCalculate_TH</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxWithholdCalculate_TH</ExtendedDataType>
			<FeatureClass>TaxWithholdingGlobalItemGroupToggle</FeatureClass>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxWithholdCode_IN</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>TaxWithholdCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxWithholdGroup</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxWithholdGroup</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>TaxWithholdItemGroupHeading_TH</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxWithholdItemGroupId_TH</ExtendedDataType>
			<FeatureClass>TaxWithholdingGlobalItemGroupToggle</FeatureClass>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TCSGroup_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>TaxWithholdGroup</ExtendedDataType>
			<Label>@GLS5363</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TDSGroup_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>TaxWithholdGroup</ExtendedDataType>
			<Label>@GLS5362</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TransactionType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>LedgerTransType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>TransDate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Transfer</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS10443</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransferCurrency_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Transferred</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS12615</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransferredBy</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>UserId</ExtendedDataType>
			<Label>@SYS23830</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>TransferredOn</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS23831</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransferredTo</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalId</ExtendedDataType>
			<Label>@SYS25348</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Triangulation</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EUROTriangulation</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Txt</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>LedgerJournalTransTxt</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>VatDueDate_W</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VatDueDate_W</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>VATGoodsType_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<EnumType>VATGoodsType_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VATNumJournal</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VATNumJournal</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>VATOnPayment_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VATOnPayment_RU</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VATOperationCode_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VATOperationCode_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>VATPaymRefRecId_RU</Name>
			<AssetClassification>System Metadata</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VATTaxAgentVendAccount_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VATTaxAgentVendAccount_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>VendBankAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>VendInvoiceDeclaration_IS</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InvoiceDeclarationId_IS</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>VendTransId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VendTransRefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Voucher</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Voucher</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Voucher_CN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Voucher_CN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VendPaymFeeGroup_JP</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>JP</CountryRegionCodes>
			<ExtendedDataType>VendPaymFeeGroupId_JP</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>DelayTaxCalculation</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<HelpText>@TaxDelayTaxCalculation:DelayTaxCalculationDescription</HelpText>
			<Label>@TaxDelayTaxCalculation:DelayTaxCalculation</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CFDIUUID_MX</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>EInvoiceCFDIUUID_MX</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InvoiceSeries_MX</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InvoiceSeries_MX</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>DirectDebitMandate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CustDirectDebitMandateRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ForeignBankFee_LT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>LTForeignBankFee</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>ForeignBankFee_LT</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PaymentPriority_LT</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>LTPaymentPriority</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>PaymentPriority_LT</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>OldLineNum</Name>
			<AllowEdit>No</AllowEdit>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>SysDeletedObjects72</ConfigurationKey>
			<ExtendedDataType>LineNum</ExtendedDataType>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProvisionalAssessment_IN</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>IN</CountryRegionCodes>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<HelpText>@TaxGST:HelpTextOfProvisionalAssessment</HelpText>
			<Label>@TaxGST:ProvisionalAssessment</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CustomerLocation_IN</Name>
			<ConfigurationKey>SysDeletedObjects73</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CustomerTaxInformation_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Exempt_IN</Name>
			<ConfigurationKey>SysDeletedObjects73</ConfigurationKey>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>HSNCodeTable_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InvoiceIdentification_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<EnumType>InvoiceIdentification_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ITCCategory_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<EnumType>ITCCategory_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>NonBusinessUsagePercentage_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>Percent</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>OriginalTransactionDate_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>TransDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>OriginalTransactionID_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>TaxGSTTransactionID_IN</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ServiceAccountingCodeTable_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ServiceCategory_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<EnumType>ServiceCategory_IN</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>VendorLocation_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>VendorTaxInformation_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>AssessableValue_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>AmountCur</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>MaximumRetailPrice_IN</Name>
			<ConfigurationKey>SysDeletedObjects80</ConfigurationKey>
			<ExtendedDataType>AmountCur</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LedgerDimensionName</Name>
			<ExtendedDataType>DirPartyName</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>FBSpedEcfDerexClasificationCode_BR</Name>
			<CountryRegionCodes>BR</CountryRegionCodes>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ReportingCurrencyExchRate</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReportingCurrencyExchRate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>ReportingCurrencyExchRateSecondary</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ReportingCurrencyExchRateSecondary</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>CommProfileType_RU</Name>
			<EnumType>CommProfileType_RU</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UseOriginalDocumentAsFacture_RU</Name>
			<ExtendedDataType>UseOriginalDocumentAsFacture_RU</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ElectronicPaymentNumber</Name>
			<ExtendedDataType>VendorElectronicPaymentReference</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PaymSched</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VendPaymSchedId</ExtendedDataType>
			<FeatureClass>InvoiceJournalPaymentScheduleFeature</FeatureClass>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>FinTag</Name>
			<ExtendedDataType>FinTagRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>OffsetFinTag</Name>
			<ExtendedDataType>FinTagRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>SysRowVersionNumber</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>SysRowVersionNumber</ExtendedDataType>
			<IsObsolete>Yes</IsObsolete>
			<Null>Yes</Null>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>BridgingBankAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CompanyBankAccountId</ExtendedDataType>
			<FeatureClass>BankBridgedTransAutoClearingFeature</FeatureClass>
			<Label>@SYS119238</Label>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>NaturalKeyIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>JournalNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>NumVoucherIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>JournalNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Voucher</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Invoice</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AccountType</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>OffsetAccountType</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>OffsetLedgerDimension</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransactionType</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxGroup</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxItemGroup</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TaxCode</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>FurtherPostingRecIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>FurtherPostingRecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>VoucherTransdate</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>Voucher</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransDate</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransactionType</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PoolRecId</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PoolRecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>VendTransIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>VendTransId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueSetIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>DefaultDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueSetIdx1</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>OffsetDefaultDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueCombinationIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>LedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimensionAttributeValueCombinationIdx1</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>OffsetLedgerDimension</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PaymInstructionIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>PaymInstruction1</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PaymInstruction2</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PaymInstruction3</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PaymInstruction4</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>VendInvoiceDeclaration_ISIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSEIceland</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>VendInvoiceDeclaration_IS</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>Tax1099FieldsIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSEUnitedStates</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>Tax1099Fields</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>BudgetSourceIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>LedgerAdv2BudgetCtrl</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>BudgetSourceLedgerEntryUnposted</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ApproverIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>Approver</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>LedgerVoucherType_CNIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSEChina</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>LedgerVoucherType_CN</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>BankCurrencyTransferLog_RUIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSERussia</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>BankCurrencyTransferLog_RU</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>MCRInvoice</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>MCRCallCenter</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>Invoice</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DataAreaId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>RevRecIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>RevRecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransDate</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ReverseEntry</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Voucher</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>BankRespWorkerId_RUIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSERussia</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>BankRespWorkerId_RU</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>BankAgreementExt_RUIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSERussia</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>BankAgreementExt_RU</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>OffsetAccountAgreement_RUIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSERussia</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>OffsetAccountAgreementId_RU</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>AccountAgreement_RUIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSERussia</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>AccountAgreementId_RU</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PlTaxDueTableIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSEPoland</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>TaxPeriodPaymentCode_PL</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>MCRPaymOrderID</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>MCRCallCenter</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>MCRPaymOrderID</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransactionType</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AccountType</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AmountCurCredit</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AmountCurDebit</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CurrencyCode</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PaymMode</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PaymReference</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PrePayment</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransDate</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DirectDebitMandateIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>DirectDebitMandate</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>JournalNum</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>JournalBalanceIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>JournalNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Voucher</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>OffsetLedgerDimension</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CurrencyCode</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AmountCurDebit</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>AmountCurCredit</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CustomerTransIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>CustTransId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PaymReferenceIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>Prepayment</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PaymReference</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>JournalLineVisibleIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>JournalNum</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Invisible</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Voucher</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LineNum</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>VoucherVoucherType_CNIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSEChina</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>Voucher_CN</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>LedgerVoucherType_CN</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>BankDocumentTableMap</MappingTable>
			<Connections />
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>CustVendInvoiceTrans</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>Category_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DefaultDimension_RU</MapField>
					<MapFieldTo>DefaultDimension</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Dimension_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DiscAmount_JP</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DiscPercent_JP</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>EmplLineType_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExciseAmountMST_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExciseAmount_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExciseValue_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExternalItemId_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FacturedFully_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FacturedQty_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FactureId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>FactureModule</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>IntrastatFulfillmentDate_HU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventDimId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventQty</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventTransId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceDate</MapField>
					<MapFieldTo>TransDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InvoiceNum</MapField>
					<MapFieldTo>JournalNum</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineAmountMST</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineAmountMST_JP</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineAmountMST_W</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineNum_RU</MapField>
					<MapFieldTo>LineNum</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineType_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Name_JP</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Name_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>NumberSequenceGroupId_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Price</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PriceUnit</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Price_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PurchInternalInvoiceId_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Qty</MapField>
					<MapFieldTo>Qty</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>QtyPhysical</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchId_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchOrigId_JP</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchPrice_JP</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceDocumentLine</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>StockedProduct</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAmountMST_JP</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAmountMST_W</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAmount_JP</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxAmount_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxCode</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup_RU</MapField>
					<MapFieldTo>TaxGroup</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxItemGroup</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxItemGroup_RU</MapField>
					<MapFieldTo>TaxItemGroup</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TransactionCode</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Unit</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Unit_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VATAmountMST_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VATAmount_RU</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>VATValue_RU</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>DimensionDefaultMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>DefaultDimension</MapField>
					<MapFieldTo>DefaultDimension</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>JournalTransMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>JournalId</MapField>
					<MapFieldTo>JournalNum</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineNum</MapField>
					<MapFieldTo>LineNum</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TransDate</MapField>
					<MapFieldTo>TransDate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>Voucher</MapField>
					<MapFieldTo>Voucher</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>PaymModeMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>PaymMode</MapField>
					<MapFieldTo>PaymMode</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PaymSpec</MapField>
					<MapFieldTo>PaymSpec</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SysExtensionSerializerMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>PackedExtensions</MapField>
					<MapFieldTo>PackedExtensions</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>PackedPrioritizedIdList</MapField>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>TransitDocumentTransactionMap_IN</MappingTable>
			<Connections />
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>SalesPurchJournalLine</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>CurrencyCode</MapField>
					<MapFieldTo>CurrencyCode</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryLocation</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>DeliveryState</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventDimId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>InventTransId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ItemId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineAmount</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>LineNum</MapField>
					<MapFieldTo>LineNum</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchQty</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SalesPurchUnit</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceId</MapField>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceRecId</MapField>
					<MapFieldTo>RecId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>SourceTableId</MapField>
					<MapFieldTo>TableId</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxGroup</MapField>
					<MapFieldTo>TaxGroup</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TaxItemGroup</MapField>
					<MapFieldTo>TaxItemGroup</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>TransDate</MapField>
					<MapFieldTo>TransDate</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>LedgerJournalReportingCurrencyExchangeRates</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>ExchangeRate</MapField>
					<MapFieldTo>ExchRate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ExchangeRateSecond</MapField>
					<MapFieldTo>ExchRateSecond</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ReportingCurrencyExchangeRate</MapField>
					<MapFieldTo>ReportingCurrencyExchRate</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ReportingCurrencyExchangeRateSecond</MapField>
					<MapFieldTo>ReportingCurrencyExchRateSecondary</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
		<AxTableMapping>
			<MappingTable>TaxExemptVATNumMap</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>VATNum</MapField>
					<MapFieldTo>VATNumJournal</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation>
			<Name>AccountAgreementHeaderExt_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>AgreementHeaderExt_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>AccountAgreementHeaderExt_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AgreementCompany_RU</Name>
					<Field>AgreementCompany_RU</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountAgreementId_RU</Name>
					<SourceEDT>AgreementId_RU</SourceEDT>
					<Field>AccountAgreementId_RU</Field>
					<RelatedField>AgreementId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Approver_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>HcmWorker</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>Approver_LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Approver</Name>
					<Field>Approver</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>AssetLedger</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125946</EntityRelationshipRole>
			<RelatedTable>AssetLedger</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>AssetLedger</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Company</Name>
					<Field>Company</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::FixedAssets</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PostingProfile</Name>
					<Field>PostingProfile</Field>
					<RelatedField>PostingProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankAccountTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankAccountTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymentAccount</Name>
					<SourceEDT>CompanyBankAccountId</SourceEDT>
					<Field>PaymentAccount</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankAccountTable_BankAccountId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankAccountTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankAccountTable_BankAccountId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankAccountId</Name>
					<SourceEDT>CompanyBankAccountId</SourceEDT>
					<Field>BankAccountId</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankAgreementHeaderExt_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>AgreementHeaderExt_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankAgreementHeaderExt_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankAgreementExt_RU</Name>
					<Field>BankAgreementExt_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankCentralBankPurpose</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankCentralBankPurpose</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankCentralBankPurposeCode</Name>
					<SourceEDT>BankCentralBankPurposeCode</SourceEDT>
					<Field>BankCentralBankPurposeCode</Field>
					<RelatedField>Code</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankChequeReversalCust</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125948</EntityRelationshipRole>
			<RelatedTable>CustTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankChequeReversalCust</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankChequeDepositTransRefRecID</Name>
					<Field>BankChequeDepositTransRefRecID</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankChequeReversalVend</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125949</EntityRelationshipRole>
			<RelatedTable>VendTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankChequeReversalVend</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankChequeDepositTransRefRecID</Name>
					<Field>BankChequeDepositTransRefRecID</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankChequeTable_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>BankChequeTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankChequeTable_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TransDate</Name>
					<Field>TransDate</Field>
					<RelatedField>TransDate</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Voucher</Name>
					<Field>Voucher</Field>
					<RelatedField>Voucher</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankClientDocumentType_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankClientDocumentType_RU</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankClientDocumentTypeId_RU</Name>
					<SourceEDT>BankClientDocumentTypeId_RU</SourceEDT>
					<Field>BankClientDocumentTypeId_RU</Field>
					<RelatedField>TypeId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TypeIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankCommAccountId_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankAccountTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>BankCommAccountId_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankCommAccountId_RU</Name>
					<SourceEDT>CompanyBankAccountId</SourceEDT>
					<Field>BankCommAccountId_RU</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankCurrencyTransferLog_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>BankCurrencyTransferLog_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankCurrencyTransferLog_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankCurrencyTransferLog_RU</Name>
					<Field>BankCurrencyTransferLog_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankDepositCancel</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125950</EntityRelationshipRole>
			<RelatedTable>BankDeposit</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankDepositCancel</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankChequeDepositTransRefRecID</Name>
					<Field>BankChequeDepositTransRefRecID</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankPaymentOrderJour_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>BankPaymentOrderJour_RU</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>BankPaymentOrderJour</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TransDate</Name>
					<Field>TransDate</Field>
					<RelatedField>JournalTransDate</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LineNum</Name>
					<Field>LineNum</Field>
					<RelatedField>JournalLineNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<RelatedField>LedgerACType</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JournalNum</Name>
					<Field>JournalNum</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Voucher</Name>
					<Field>Voucher</Field>
					<RelatedField>Voucher</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankPromissoryNoteTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankPromissoryNoteTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankPromissoryNoteTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankPromissoryNoteNum</Name>
					<SourceEDT>BankPromissoryNoteNum</SourceEDT>
					<Field>BankPromissoryNoteNum</Field>
					<RelatedField>PromissoryNoteNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankRemittanceFilesCust</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125951</EntityRelationshipRole>
			<RelatedTable>BankRemittanceFilesCust</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankRemittanceFilesCust</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankRemittanceFileId</Name>
					<Field>BankRemittanceFileId</Field>
					<RelatedField>FileId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>BankRemittanceFilesVend</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125952</EntityRelationshipRole>
			<RelatedTable>BankRemittanceFilesVend</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankRemittanceFilesVend</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankRemittanceFileId</Name>
					<Field>BankRemittanceFileId</Field>
					<RelatedField>FileId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankRespWorker_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>HcmWorker</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankRespWorker_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankRespWorkerId_RU</Name>
					<Field>BankRespWorkerId_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankSpecAccountId_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankAccountTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>BankSpecAccountId_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankSpecAccountId_RU</Name>
					<SourceEDT>CompanyBankAccountId</SourceEDT>
					<Field>BankSpecAccountId_RU</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankTransType</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankTransType</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankTransType</Name>
					<SourceEDT>BankTransactionType</SourceEDT>
					<Field>BankTransType</Field>
					<RelatedField>BankTransType</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TransType</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BankVendAccountId_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>BankVendAccountId_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankVendAccountId_RU</Name>
					<SourceEDT>VendAccount</SourceEDT>
					<Field>BankVendAccountId_RU</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>BudgetSource</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>BudgetSource</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BudgetSource</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>BudgetSource_LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BudgetSourceLedgerEntryUnposted</Name>
					<Field>BudgetSourceLedgerEntryUnposted</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CashDisc</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>CashDisc</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CashDiscCode</Name>
					<SourceEDT>CashDiscCode</SourceEDT>
					<Field>CashDiscCode</Field>
					<RelatedField>CashDiscCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>CurrencyCode</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TransactionCurrency</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CurrencyCode</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>CurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency_RemitteeCurrency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Currency_RemitteeCurrency</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RemitteeCurrency</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>RemitteeCurrency</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustBankAccount_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustBankAccount</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustBankAccount_FK</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustBankAccount</Name>
					<Field>CustBankAccount</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustEPRemitInfo_BR</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>CustEPRemitInfo_BR</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>LedgerJournalTrans</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustomsTariffCodeTable_IN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@GLS5192</EntityRelationshipRole>
			<RelatedTable>CustomsTariffCodeTable_IN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustomsTariffCodeTable_IN</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CustomsTariffCodeTable_IN_LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustomsTariffCodeTable_IN</Name>
					<Field>CustomsTariffCodeTable_IN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustPaymMode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125953</EntityRelationshipRole>
			<RelatedTable>CustPaymModeTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustPaymMode</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Cust</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymMode</Name>
					<Field>PaymMode</Field>
					<RelatedField>PaymMode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustPaymModeSpec</Name>
			<Cardinality>ZeroMore</Cardinality>
			<CreateNavigationPropertyMethods>Yes</CreateNavigationPropertyMethods>
			<EntityRelationshipRole>@SYS125954</EntityRelationshipRole>
			<NavigationPropertyMethodNameOverride>CustPaymModeSpec</NavigationPropertyMethodNameOverride>
			<RelatedTable>CustPaymModeSpec</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustPaymModeSpec</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Cust</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymMode</Name>
					<Field>PaymMode</Field>
					<RelatedField>PaymMode</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymSpec</Name>
					<Field>PaymSpec</Field>
					<RelatedField>Specification</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustPostingProfile</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125955</EntityRelationshipRole>
			<RelatedTable>CustLedger</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustPostingProfile</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Company</Name>
					<Field>Company</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Cust</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PostingProfile</Name>
					<Field>PostingProfile</Field>
					<RelatedField>PostingProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustTable_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustTable_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Company</Name>
					<Field>Company</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Cust</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankPrintAccountNum_RU</Name>
					<Field>BankPrintAccountNum_RU</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustTable_W</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustTable_W</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RCashDocRepresPersonId</Name>
					<Field>RCashDocRepresPersonId</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RCashDocRepresType</Name>
					<Field>RCashDocRepresType</Field>
					<ValueStr>RCashDocRepresType::Customer</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustTrans</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>CustTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustTransId</Name>
					<SourceEDT>CustTransRefRecId</SourceEDT>
					<Field>CustTransId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustTransCashDisc</Name>
			<EntityRelationshipRole>@SYS125957</EntityRelationshipRole>
			<RelatedTable>CustTransCashDisc</RelatedTable>
			<RelatedTableRole>CustTransCashDisc</RelatedTableRole>
			<RelationshipType>Link</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>RefRecId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TableId</Name>
					<Field>TableId</Field>
					<RelatedField>RefTableId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustTransOpen</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125958</EntityRelationshipRole>
			<RelatedTable>CustTransOpen</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustTransOpen</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MarkedInvoiceCompany</Name>
					<Field>MarkedInvoiceCompany</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MarkedInvoiceRecId</Name>
					<Field>MarkedInvoiceRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DataArea_AgreementCompany</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>DataArea</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>RContractCompanyCredit</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>AgreementCompany_RU</Name>
					<SourceEDT>AgreementCompany_RU</SourceEDT>
					<Field>AgreementCompany_RU</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>isVirtual_Extern</Name>
					<SourceEDT>AgreementCompany_RU</SourceEDT>
					<RelatedField>isVirtual</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DataArea_Company</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>DataArea</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DataArea_Company</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Company</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<Field>Company</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>isVirtual_Extern</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<RelatedField>isVirtual</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DataArea_ForeignCompany</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>DataArea</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DataArea_ForeignCompany</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ForeignCompany</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<Field>ForeignCompany</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>isVirtual_Extern</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<RelatedField>isVirtual</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DataArea_MarkedInvoiceCompany</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>DataArea</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DataArea_MarkedInvoiceCompany</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MarkedInvoiceCompany</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<Field>MarkedInvoiceCompany</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>isVirtual_Extern</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<RelatedField>isVirtual</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DataArea_OffsetAgreementCompany</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>DataArea</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>RContractCompanyDebit</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetAgreementCompany_RU</Name>
					<SourceEDT>AgreementCompany_RU</SourceEDT>
					<Field>OffsetAgreementCompany_RU</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>isVirtual_Extern</Name>
					<SourceEDT>AgreementCompany_RU</SourceEDT>
					<RelatedField>isVirtual</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DataArea_OffsetCompany</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>DataArea</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DataArea_OffsetCompany</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetCompany</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<Field>OffsetCompany</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>isVirtual_Extern</Name>
					<SourceEDT>SelectableDataArea</SourceEDT>
					<RelatedField>isVirtual</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>DebitCurrencyCode_LT</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>DebitCurrencyCode_LT</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DebitCurrencyCode_LT</Name>
					<SourceEDT>LtDebitCurrencyCode</SourceEDT>
					<Field>DebitCurrencyCode_LT</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>DefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DefaultDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DefaultDimension</Name>
					<Field>DefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>EmplPostingProfile_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>EmplLedger_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>EmplPostingProfile_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Employee_RU</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PostingProfile</Name>
					<Field>PostingProfile</Field>
					<RelatedField>PostingProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>IntBank_LV</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>BankAccountTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>BankAccountTable_LV</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>IntBank_LV</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>IntBank_LV</Name>
					<SourceEDT>CompanyBankAccountId</SourceEDT>
					<Field>IntBank_LV</Field>
					<RelatedField>AccountID</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InvoiceDeclarationId_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendInvoiceDeclaration_IS</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>DeclarationUsedForInvoicing</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>JournalLines</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendInvoiceDeclaration_IS</Name>
					<Field>VendInvoiceDeclaration_IS</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerDimension</Name>
					<Field>LedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JournalNum</Name>
					<SourceEDT>LedgerJournalId</SourceEDT>
					<Field>JournalNum</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TypeNumIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalTable_TransferredTo</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalTable_TransferredTo</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TransferredTo</Name>
					<SourceEDT>LedgerJournalId</SourceEDT>
					<Field>TransferredTo</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TypeNumIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalTrans</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PoolRecId</Name>
					<SourceEDT>LedgerJournalTransRefRecId</SourceEDT>
					<Field>PoolRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalTrans_FurtherPostingRecId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalTrans_FurtherPostingRecId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FurtherPostingRecId</Name>
					<SourceEDT>LedgerJournalTransRefRecId</SourceEDT>
					<Field>FurtherPostingRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerJournalTrans_RevRecId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalTrans_RevRecId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RevRecId</Name>
					<SourceEDT>LedgerJournalTransRefRecId</SourceEDT>
					<Field>RevRecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LedgerJournalTransVATPaym_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LedgerJournalTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalTransVATPaym_RU</RelatedTableRole>
			<RelationshipType>Composition</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VATPaymRefRecId_RU</Name>
					<Field>VATPaymRefRecId_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LedgerJournalTransVoucherTemplate</Name>
			<EntityRelationshipRole>@SYS125964</EntityRelationshipRole>
			<RelatedTable>LedgerJournalTransVoucherTemplate</RelatedTable>
			<RelatedTableRole>LedgerJournalTransVoucherTemplate</RelatedTableRole>
			<RelationshipType>Link</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JournalNum</Name>
					<Field>JournalNum</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Voucher</Name>
					<Field>Voucher</Field>
					<RelatedField>Voucher</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LedgerJournalTxt</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS124924</EntityRelationshipRole>
			<RelatedTable>LedgerJournalTxt</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalTxt</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Company</Name>
					<Field>Company</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Txt</Name>
					<Field>Txt</Field>
					<RelatedField>Txt</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LedgerJournalTxtOffset</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125965</EntityRelationshipRole>
			<RelatedTable>LedgerJournalTxt</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerJournalTxtOffset</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetCompany</Name>
					<Field>OffsetCompany</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetTxt</Name>
					<Field>OffsetTxt</Field>
					<RelatedField>Txt</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LedgerPaymMode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendPaymModeTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendPaymMode</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymMode</Name>
					<Field>PaymMode</Field>
					<RelatedField>PaymMode</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Vend</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>LedgerVoucherType_CN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>LedgerVoucherType_CN</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>LedgerVoucherType_CN</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerVoucherType_CN_LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LedgerVoucherType_CN</Name>
					<Field>LedgerVoucherType_CN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>LvOtherClients</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>LvOtherClients</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RCashDocRepresType</Name>
					<Field>RCashDocRepresType</Field>
					<ValueStr>RCashDocRepresType::Other</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RCashDocRepresPersonId</Name>
					<Field>RCashDocRepresPersonId</Field>
					<RelatedField>ClientId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>MCRCCGeneralLegerId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LedgerJournalTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>MCRCCGeneralLedgerId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTable</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MCRCCGeneralLedgerId</Name>
					<SourceEDT>LedgerJournalId</SourceEDT>
					<Field>MCRCCGeneralLedgerId</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TypeNumIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>MCRCustPaymTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>MCRCustPaymTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MCRRefPaymID</Name>
					<Field>MCRRefPaymID</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OfficialsTrans_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>OfficialsTrans_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Link</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffSessionId_RU</Name>
					<SourceEDT>OffSessionId_RU</SourceEDT>
					<Field>OffSessionId_RU</Field>
					<RelatedField>OffSessionId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OffsetAccountAgreementHeaderExt_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>AgreementHeaderExt_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetAccountAgreementHeaderExt_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetAgreementCompany_RU</Name>
					<Field>OffsetAgreementCompany_RU</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetAccountAgreementId_RU</Name>
					<SourceEDT>AgreementId_RU</SourceEDT>
					<Field>OffsetAccountAgreementId_RU</Field>
					<RelatedField>AgreementId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>OffsetDefaultDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueSet</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetDefaultDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetDefaultDimension</Name>
					<Field>OffsetDefaultDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>OffsetLedgerDimension</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>DimensionAttributeValueCombination</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetLedgerDimension</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetLedgerDimension</Name>
					<Field>OffsetLedgerDimension</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OffsetPostingProfileCust_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustLedger</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetPostingProfileCust_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Cust</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetPostingProfile_RU</Name>
					<Field>OffsetPostingProfile_RU</Field>
					<RelatedField>PostingProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OffsetPostingProfileEmpl_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>EmplLedger_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetPostingProfileEmpl_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Employee_RU</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetPostingProfile_RU</Name>
					<Field>OffsetPostingProfile_RU</Field>
					<RelatedField>PostingProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OffsetPostingProfileRCash</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RCashLedger</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetPostingProfileRCash</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::RCash</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetPostingProfile_RU</Name>
					<Field>OffsetPostingProfile_RU</Field>
					<RelatedField>PostingProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OffsetPostingProfileVend_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendLedger</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetPostingProfileVend_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Vend</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetPostingProfile_RU</Name>
					<Field>OffsetPostingProfile_RU</Field>
					<RelatedField>PostingProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OffsetRCashDocRepresBankEmplId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>EmployeeTable_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetRCashDocRepresBankEmplId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Bank</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RCashDocRepresType</Name>
					<Field>RCashDocRepresType</Field>
					<ValueStr>RCashDocRepresType::Employee</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RCashDocRepresPersonId</Name>
					<Field>RCashDocRepresPersonId</Field>
					<RelatedField>EmployeeId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetCompany</Name>
					<Field>OffsetCompany</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OffsetRCashDocRepresCustPersonId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ContactPerson</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetRCashDocRepresCustPersonId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RCashDocRepresPersonId</Name>
					<Field>RCashDocRepresPersonId</Field>
					<RelatedField>ContactPersonId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetCompany</Name>
					<Field>OffsetCompany</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RCashDocRepresType</Name>
					<Field>RCashDocRepresType</Field>
					<ValueStr>RCashDocRepresType::Employee</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Cust</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OffsetRCashDocRepresEmplId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>EmployeeTable_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetRCashDocRepresEmplId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Employee_RU</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RCashDocRepresType</Name>
					<Field>RCashDocRepresType</Field>
					<ValueStr>RCashDocRepresType::Employee</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetCompany</Name>
					<Field>OffsetCompany</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RCashDocRepresPersonId</Name>
					<Field>RCashDocRepresPersonId</Field>
					<RelatedField>EmployeeId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>AdvHolder_Extern</Name>
					<RelatedField>AdvHolder</RelatedField>
					<Value>1</Value>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OffsetRCashDocRepresLedgerEmplId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>EmployeeTable_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetRCashDocRepresLedgerEmplId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Ledger</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RCashDocRepresType</Name>
					<Field>RCashDocRepresType</Field>
					<ValueStr>RCashDocRepresType::Employee</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetCompany</Name>
					<Field>OffsetCompany</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RCashDocRepresPersonId</Name>
					<Field>RCashDocRepresPersonId</Field>
					<RelatedField>EmployeeId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>OffsetRCashDocRepresVendPersonId</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ContactPerson</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetRCashDocRepresVendPersonId</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetCompany</Name>
					<Field>OffsetCompany</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RCashDocRepresType</Name>
					<Field>RCashDocRepresType</Field>
					<ValueStr>RCashDocRepresType::Employee</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Vend</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RCashDocRepresPersonId</Name>
					<Field>RCashDocRepresPersonId</Field>
					<RelatedField>ContactPersonId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PaymInstruction1</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PaymInstruction</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PaymInstruction1</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymInstruction1</Name>
					<Field>PaymInstruction1</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PaymInstruction2</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PaymInstruction</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PaymInstruction2</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymInstruction2</Name>
					<Field>PaymInstruction2</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PaymInstruction3</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PaymInstruction</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PaymInstruction3</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymInstruction3</Name>
					<Field>PaymInstruction3</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PaymInstruction4</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PaymInstruction</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PaymInstruction4</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymInstruction4</Name>
					<Field>PaymInstruction4</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PaymTerm</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>PaymTerm</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Payment</Name>
					<SourceEDT>PaymTermId</SourceEDT>
					<Field>Payment</Field>
					<RelatedField>PaymTermId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TermIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PlCustVendVatRegNums</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PlCustVendVatRegNums</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PlCustVendVatRegNums</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustVendAccount_PL</Name>
					<Field>CustVendAccount_PL</Field>
					<RelatedField>CustVendAccount</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PlTaxDueTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>PlTaxDueTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PlTaxDueTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxPeriodPaymentCode_PL</Name>
					<Field>TaxPeriodPaymentCode_PL</Field>
					<RelatedField>TaxPeriodPaymentCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>PostingProfileRCash</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>RCashLedger</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PostingProfileRCash</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::RCash</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PostingProfile</Name>
					<Field>PostingProfile</Field>
					<RelatedField>PostingProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjJournalTxt</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125968</EntityRelationshipRole>
			<RelatedTable>ProjJournalTxt</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjJournalTxt</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Project</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Txt</Name>
					<Field>Txt</Field>
					<RelatedField>Txt</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProjJournalTxtOffset</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125969</EntityRelationshipRole>
			<RelatedTable>ProjJournalTxt</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ProjJournalTxtOffset</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Project</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetTxt</Name>
					<Field>OffsetTxt</Field>
					<RelatedField>Txt</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ReasonRef</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125970</EntityRelationshipRole>
			<RelatedTable>ReasonTableRef</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>ReasonRef</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReasonRefRecID</Name>
					<SourceEDT>ReasonRefRecID</SourceEDT>
					<Field>ReasonRefRecID</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>RefCopyReverse_CN</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LedgerJournalTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>RefCopyReverse_CN</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RefCopyReverse_CN</Name>
					<Field>RefCopyReverse_CN</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RemittanceAddress_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LogisticsPostalAddress</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>RemittanceAddress_FK</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RemittanceAddress</Name>
					<Field>RemittanceAddress</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>RemittanceLocation_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>LogisticsLocation</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>RemittanceLocation_FK</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RemittanceLocation</Name>
					<Field>RemittanceLocation</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TAMDeduction</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TAMDeduction</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>LedgerJournalTransRecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Tax1099BoxDetail</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>Tax1099BoxDetail</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Tax1099BoxDetail</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>Tax1099BoxDetail_LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Tax1099RecId</Name>
					<Field>Tax1099RecId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Tax1099Fields</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Tax1099Fields</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Tax1099Fields</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Tax1099Fields</Name>
					<Field>Tax1099Fields</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>Tax1099State</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>LogisticsAddressState</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>Tax1099State</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Tax1099State</Name>
					<SourceEDT>Tax1099State</SourceEDT>
					<Field>Tax1099State</Field>
					<RelatedField>StateId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TaxGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123571</EntityRelationshipRole>
			<RelatedTable>TaxGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxGroup</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Company</Name>
					<Field>Company</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxGroup</Name>
					<Field>TaxGroup</Field>
					<RelatedField>TaxGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TaxItemGroup</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125972</EntityRelationshipRole>
			<RelatedTable>TaxItemGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxItemGroup</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Company</Name>
					<Field>Company</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxItemGroup</Name>
					<Field>TaxItemGroup</Field>
					<RelatedField>TaxItemGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TaxServiceTariff</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>TaxServiceTariff</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxServiceTariff</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>ParentRecId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TableId</Name>
					<Field>TableId</Field>
					<RelatedField>ParentTableId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TaxTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125973</EntityRelationshipRole>
			<RelatedTable>TaxTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxTable</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxCode</Name>
					<SourceEDT>TaxCode</SourceEDT>
					<Field>TaxCode</Field>
					<RelatedField>TaxCode</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Company</Name>
					<Field>Company</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxWithholdAltVendorAccount</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxWithholdAltVendorAccount</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxWithholdAltVendorAccount</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxWithholdAlternateVendorAcct_TH</Name>
					<SourceEDT>TaxWithholdAlternateVendorAcct_TH</SourceEDT>
					<Field>TaxWithholdAlternateVendorAcct_TH</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxWithholdGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxWithholdGroupHeading</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxWithholdGroup</Name>
					<SourceEDT>TaxWithholdGroup</SourceEDT>
					<Field>TaxWithholdGroup</Field>
					<RelatedField>TaxWithholdGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxWithholdGroupIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxWithholdItemGroupHeading_TH</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>TaxWithholdItemGroupHeading_TH</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>TaxWithholdItemGroupHeading_TH</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>TaxWithholdItemGroupHeading_TH_LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxWithholdItemGroupHeading_TH</Name>
					<Field>TaxWithholdItemGroupHeading_TH</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TransferCurrency_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>TransferCurrency_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TransferCurrency_RU</Name>
					<SourceEDT>CurrencyCode</SourceEDT>
					<Field>TransferCurrency_RU</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>UserInfo</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>UserInfo</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TransferredBy</Name>
					<SourceEDT>UserId</SourceEDT>
					<Field>TransferredBy</Field>
					<RelatedField>id</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>Id</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VATOperationCodeTable_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>VATOperationCodeTable_RU</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VATOperationCode_RU</Name>
					<SourceEDT>VATOperationCode_RU</SourceEDT>
					<Field>VATOperationCode_RU</Field>
					<RelatedField>OperationCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VATTaxAgentVendAccount_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VATTaxAgentVendAccount_RU</Name>
					<SourceEDT>VATTaxAgentVendAccount_RU</SourceEDT>
					<Field>VATTaxAgentVendAccount_RU</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>VATTaxAgent_RU_Extern</Name>
					<SourceEDT>VATTaxAgentVendAccount_RU</SourceEDT>
					<RelatedField>VATTaxAgent_RU</RelatedField>
					<Value>1</Value>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>AccountIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendBankAccount_FK</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendBankAccount</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendBankAccount_FK</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendBankAccount</Name>
					<Field>VendBankAccount</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendEPRemitInfo_BR</Name>
			<Cardinality>ZeroOne</Cardinality>
			<RelatedTable>VendEPRemitInfo_BR</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>LedgerJournalTrans</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendPaymentMode</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125974</EntityRelationshipRole>
			<RelatedTable>VendPaymModeTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendPaymentMode</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Vend</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymMode</Name>
					<Field>PaymMode</Field>
					<RelatedField>PaymMode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendPaymentModeCostJournal</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125975</EntityRelationshipRole>
			<RelatedTable>VendPaymModeTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendPaymentModeCostJournal</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Project</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Vend</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymMode</Name>
					<Field>PaymMode</Field>
					<RelatedField>PaymMode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendPaymentModeSpec</Name>
			<Cardinality>ZeroMore</Cardinality>
			<CreateNavigationPropertyMethods>Yes</CreateNavigationPropertyMethods>
			<EntityRelationshipRole>@SYS125976</EntityRelationshipRole>
			<NavigationPropertyMethodNameOverride>VendPaymentModeSpec</NavigationPropertyMethodNameOverride>
			<RelatedTable>VendPaymModeSpec</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendPaymentModeSpec</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Vend</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymMode</Name>
					<Field>PaymMode</Field>
					<RelatedField>PaymMode</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymSpec</Name>
					<Field>PaymSpec</Field>
					<RelatedField>Specification</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendPaymentModeSpecCostJournal</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125977</EntityRelationshipRole>
			<RelatedTable>VendPaymModeSpec</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendPaymentModeSpecCostJournal</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Project</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Vend</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymMode</Name>
					<Field>PaymMode</Field>
					<RelatedField>PaymMode</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymSpec</Name>
					<Field>PaymSpec</Field>
					<RelatedField>Specification</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendPostingProfile</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125978</EntityRelationshipRole>
			<RelatedTable>VendLedger</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendPostingProfile</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Company</Name>
					<Field>Company</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Vend</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PostingProfile</Name>
					<Field>PostingProfile</Field>
					<RelatedField>PostingProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendPostingProfileCostJournal</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS125979</EntityRelationshipRole>
			<RelatedTable>VendLedger</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendPostingProfileCostJournal</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Project</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>OffsetAccountType</Name>
					<Field>OffsetAccountType</Field>
					<ValueStr>LedgerJournalACType::Vend</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PostingProfile</Name>
					<Field>PostingProfile</Field>
					<RelatedField>PostingProfile</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendTable_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendTable_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Company</Name>
					<Field>Company</Field>
					<RelatedField>dataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>AccountType</Name>
					<Field>AccountType</Field>
					<ValueStr>LedgerJournalACType::Vend</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>BankPrintAccountNum_RU</Name>
					<Field>BankPrintAccountNum_RU</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendTable_W</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>VendTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>VendTable_W</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RCashDocRepresPersonId</Name>
					<Field>RCashDocRepresPersonId</Field>
					<RelatedField>AccountNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>RCashDocRepresType</Name>
					<Field>RCashDocRepresType</Field>
					<ValueStr>RCashDocRepresType::Vendor</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>VendTrans</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>VendTrans</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendTransId</Name>
					<SourceEDT>VendTransRefRecId</SourceEDT>
					<Field>VendTransId</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>VendTransCashDisc</Name>
			<EntityRelationshipRole>@SYS125981</EntityRelationshipRole>
			<RelatedTable>VendTransCashDisc</RelatedTable>
			<RelatedTableRole>VendTransCashDisc</RelatedTableRole>
			<RelationshipType>Link</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>RecId</Name>
					<Field>RecId</Field>
					<RelatedField>RefRecId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TableId</Name>
					<Field>TableId</Field>
					<RelatedField>RefTableId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustVendPaymFeeGroup_JP</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustVendPaymFeeGroup_JP</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VendPaymFeeGroup_JP</Name>
					<Field>VendPaymFeeGroup_JP</Field>
					<RelatedField>GroupId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>Module</Name>
					<RelatedField>Module</RelatedField>
					<ValueStr>ModuleCustVend::Vend</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>TaxEngineLedgerJournalTransHeader</Name>
			<Cardinality>OneMore</Cardinality>
			<RelatedTable>TaxEngineLedgerJournalTransHeader</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>JournalNum</Name>
					<Field>JournalNum</Field>
					<RelatedField>JournalNum</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Voucher</Name>
					<Field>Voucher</Field>
					<RelatedField>Voucher</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>CustDirectDebitMandate</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustDirectDebitMandate</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DirectDebitMandate</Name>
					<Field>DirectDebitMandate</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>PaymSched</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>PaymSched</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>PaymSched</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>PaymSched</Name>
					<SourceEDT>VendPaymSchedId</SourceEDT>
					<Field>PaymSched</Field>
					<RelatedField>Name</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>NameIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>FinTag</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>FinTag</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>FinTag</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>FinTag</Name>
					<Field>FinTag</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>OffsetFinTag</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>FinTag</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>OffsetFinTag</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>LedgerJournalTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>OffsetFinTag</Name>
					<Field>OffsetFinTag</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>