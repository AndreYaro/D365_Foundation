<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustBillingCodeVersion</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustBillingCodeVersion extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkBillingCodeVersionOnInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>ValidFrom</c> date is less than invoice minimum date and <c>ValidTo</c> date is greater than invoice maximum date.
    /// </summary>
    /// <param name="_custBillingCodeVersion">
    /// The <c>CustBillingCodeVersion</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the <c>ValidFrom</c> date is less than invoice minimum date and <c>ValidTo</c> date is greater than invoice maximum date; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Displays the error message.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// The billing code version is used on one or more customer invoices.
    /// </exception>
    public boolean checkBillingCodeVersionOnInvoiceLine(CustBillingCodeVersion _custBillingCodeVersion)
    {
        boolean             isUsed = true;
        CustInvoiceTable    custInvoiceTable;
        CustInvoiceLine     custInvoiceLine;
        date                invoiceMaxDate;
        date                invoiceMinDate;

        select maxOf(InvoiceDate) from custInvoiceTable
            join ParentRecId, CustBillingCode from custInvoiceLine
            where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
               && custInvoiceLine.CustBillingCode == _custBillingCodeVersion.CustBillingCode
               && custInvoiceTable.Posted == NoYes::No;

        invoiceMaxDate = custInvoiceTable.InvoiceDate;

        select minOf(InvoiceDate) from custInvoiceTable
            join ParentRecId, CustBillingCode from custInvoiceLine
            where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
               && custInvoiceLine.CustBillingCode == _custBillingCodeVersion.CustBillingCode
               && custInvoiceTable.Posted == NoYes::No;

        invoiceMinDate = custInvoiceTable.InvoiceDate;

        if (invoiceMaxDate && invoiceMinDate)
        {
            isUsed = _custBillingCodeVersion.ValidFrom < invoiceMinDate && _custBillingCodeVersion.ValidTo > invoiceMaxDate;
        }

        if (!isUsed)
        {
            throw error("@SPS669");
        }

        return isUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidBillingCodeVersionByDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the new date is in valid date range or not.
    /// </summary>
    /// <param name="_custInvoiceTableRefRecId">
    /// The record ID of the <c>CustInvoiceTable</c> table.
    /// </param>
    /// <param name="_oldInvoiceDate">
    /// The old invoice date on the date control.
    /// </param>
    /// <param name="_newInvoiceDate">
    /// The new invoice date on the date control.
    /// </param>
    /// <returns>
    /// true if the new date is valid; otherwise, false.
    /// </returns>
    public boolean checkValidBillingCodeVersionByDates(
        CustInvoiceTableRefRecId _custInvoiceTableRefRecId,
        date _oldInvoiceDate,
        date _newInvoiceDate)
    {
        CustBillingCodeVersion  custBillingCodeVersion;
        CustInvoiceLine         custInvoiceLine;
        boolean                 isValid = true;
        date                    minInvoiceDate;
        date                    maxInvoiceDate;

        minInvoiceDate = min(_oldInvoiceDate, _newInvoiceDate);
        maxInvoiceDate = max(_oldInvoiceDate, _newInvoiceDate);

        if (_custInvoiceTableRefRecId)
        {
            while select validtimestate(_oldInvoiceDate) AllowChangeAmount, AllowChangeLedgerAccount, ValidFrom, ValidTo, CustBillingCode from custBillingCodeVersion
                join CustBillingCode, ParentRecId from custInvoiceLine
                where custInvoiceLine.CustBillingCode == custBillingCodeVersion.CustBillingCode
                   && custInvoiceLine.ParentRecId == _custInvoiceTableRefRecId
            {
                if (!(custBillingCodeVersion.ValidFrom <= minInvoiceDate && custBillingCodeVersion.ValidTo >=  maxInvoiceDate))
                {
                    isValid = false;
                    break;
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidDatesForInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the new date is in valid date range or not.
    /// </summary>
    /// <param name="_custInvoiceTableRefRecId">
    /// The record ID of the <c>CustInvoiceTable</c> table.
    /// </param>
    /// <param name="_oldInvoiceDate">
    /// The old invoice date on the date control.
    /// </param>
    /// <param name="_newInvoiceDate">
    /// The new invoice date on the date control.
    /// </param>
    /// <returns>
    /// true if the new date is valid; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// The billing code line values will not be valid if this invoice date is used.
    /// </exception>
    public boolean checkValidDatesForInvoiceLine(
        CustInvoiceTableRefRecId _custInvoiceTableRefRecId,
        date _oldInvoiceDate,
        date _newInvoiceDate)
    {
        boolean isValid = true;
        date    maxValidFromDate;
        date    minValidToDate;

        if (_custInvoiceTableRefRecId)
        {
            if (!this.checkValidBillingCodeVersionByDates(_custInvoiceTableRefRecId, _oldInvoiceDate, _newInvoiceDate))
            {
                maxValidFromDate = this.getMaxValidFromDate(_custInvoiceTableRefRecId, _oldInvoiceDate);
                minValidToDate   = this.getMinValidToDate(_custInvoiceTableRefRecId, _oldInvoiceDate);

                throw error(strFmt("@SPS752", maxValidFromDate, minValidToDate));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>CustBillingCodeVersion</c> record. Corresponding record in <c>CustBillingCode</c> is also deleted if isOnlyVersion returns true.
    /// </summary>
    public void delete()
    {
        CustBillingCode  custBillingCode;
        SysDateEffectiveDataManager sysDateEffectiveDataManager = SysDateEffectiveDataManager::construct(SysDateEffectiveSetupType::CustBillingCode);

        custBillingCode = CustBillingCode::find(this.CustBillingCode, true);

        if (this.RecId && custBillingCode && sysDateEffectiveDataManager.isOnlyVersion(this.CustBillingCode))
        {
            ttsBegin;

            custBillingCode.delete();

            ttsCommit;
        }
        else
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMinMaxVersionFromInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the minimum and maximum dates of <c>CustBillingCodeVersion</c> table.
    /// </summary>
    /// <param name="_custInvoiceTableRefRecId">
    /// The record ID of the <c>CustInvoiceTable</c> table.
    /// </param>
    /// <param name="_originalInvoiceDate">
    /// The orignal invoice date to find the date range for which all the billing codes are effective.
    /// </param>
    /// <returns>
    /// A container holding the minimum and maximum date based on original invoice date.
    /// </returns>
    public static container findMinMaxVersionFromInvoice(RefRecId _custInvoiceTableRefRecId, TransDate _originalInvoiceDate)
    {
        container dateRange;
        CustInvoiceLine custInvoiceLine;
        CustBillingCodeVersion custBillingCodeVersion;

        select firstOnly validtimestate(_originalInvoiceDate) maxof(ValidFrom), minof(ValidTo), CustBillingCode
            from custBillingCodeVersion
            exists join custInvoiceLine
                where custInvoiceLine.CustBillingCode == custBillingCodeVersion.CustBillingCode
                   && custInvoiceLine.ParentRecId == _custInvoiceTableRefRecId;

        if (custBillingCodeVersion)
        {
            dateRange = [custBillingCodeVersion.ValidFrom, custBillingCodeVersion.ValidTo];
        }

        return dateRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllowChangeLedgerAcc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the value of <c>AllowChangeLedgerAccount</c> field.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    /// The ID of the record to find.
    /// </param>
    /// <returns>
    /// A boolean value to indicate either the ledger account changes are allowed or not.
    /// </returns>
    public boolean getAllowChangeLedgerAcc(recId _sourceDocumentLine)
    {
        CustInvoiceLine         custInvoiceLine;
        CustBillingCode         custBillingCode;
        CustBillingCodeVersion  custBillingCodeVersion;

        select AllowChangeLedgerAccount from custBillingCodeVersion
        join BillingCode from custBillingCode
            where   custBillingCode.RecId == custBillingCodeVersion.CustBillingCode
        join BillingCode from custInvoiceLine
            where   custInvoiceLine.BillingCode == custBillingCode.BillingCode
                    && custInvoiceLine.SourceDocumentLine == _sourceDocumentLine;

        return custBillingCodeVersion.AllowChangeLedgerAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCorrectedInvoiceDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the valid date range to be applied on corrected invoices.
    /// </summary>
    /// <param name="_custInvoiceTableRefRecId">
    /// The record ID of the <c>CustInvoiceTable</c> table.
    /// </param>
    /// <param name="_oldInvoiceDate">
    /// The original date of the invoice.
    /// </param>
    /// <param name="_newInvoiceDate">
    /// The new invoice date.
    /// </param>
    /// <returns>
    /// A container holding the date ranges and boolean value to indicate if version exists or not based on new invoice date.
    /// </returns>
    /// <remarks>
    /// Method returns empty container if the version of the billing code is same as of new invoice date or
    /// there are no lines with billing code exists in invoice.
    /// </remarks>
    public static container getCorrectedInvoiceDates(
                CustInvoiceTableRefRecId _custInvoiceTableRefRecId,
                date _oldInvoiceDate,
                date _newInvoiceDate)
    {
        CustBillingCodeVersion custBillingCodeVersion;
        CustInvoiceLine custInvoiceLine;
        NumberOfRecords invoiceLineWithBillingCodeAsOfNewDate, invoiceLinesWithBillingCodeAsOfOriginalDate;
        boolean needUpdateToInvoiceLine, isVersionDifferent;
        container dateRangeInfoContainerBasedOnNewInvoiceDate;

        select count(RecId) from custInvoiceLine
            where custInvoiceLine.CustBillingCode != 0
               && custInvoiceLine.ParentRecId == _custInvoiceTableRefRecId;

        invoiceLinesWithBillingCodeAsOfOriginalDate = custInvoiceLine.RecId;

        // look for billing codes version for new date.
        while select validtimestate(_newInvoiceDate) AllowChangeAmount, AllowChangeLedgerAccount, RecId, ValidFrom, ValidTo
            from custBillingCodeVersion
         join LineNum from custInvoiceLine
            where custInvoiceLine.CustBillingCode == custBillingCodeVersion.CustBillingCode
               && custInvoiceLine.ParentRecId == _custInvoiceTableRefRecId
        {
            invoiceLineWithBillingCodeAsOfNewDate++;

            if (custBillingCodeVersion.AllowChangeAmount == false || custBillingCodeVersion.AllowChangeLedgerAccount == false)
            {
                needUpdateToInvoiceLine = true;
            }
            if (_oldInvoiceDate < custBillingCodeVersion.ValidFrom || _oldInvoiceDate > custBillingCodeVersion.ValidTo)
            {
                isVersionDifferent = true;
            }
        }

        // Check if any of the billing code is not effective based on new date.
        if (invoiceLineWithBillingCodeAsOfNewDate < invoiceLinesWithBillingCodeAsOfOriginalDate)
        {
            // Some billing codes do not have a version effective as of invoice new date.
            dateRangeInfoContainerBasedOnNewInvoiceDate = CustBillingCodeVersion::findMinMaxVersionFromInvoice(_custInvoiceTableRefRecId, _oldInvoiceDate);
            dateRangeInfoContainerBasedOnNewInvoiceDate += false;
        }
        else
        {
            if (needUpdateToInvoiceLine && isVersionDifferent)
            {
                dateRangeInfoContainerBasedOnNewInvoiceDate = CustBillingCodeVersion::findMinMaxVersionFromInvoice(_custInvoiceTableRefRecId, _oldInvoiceDate);
                dateRangeInfoContainerBasedOnNewInvoiceDate += needUpdateToInvoiceLine;
            }
        }

        return dateRangeInfoContainerBasedOnNewInvoiceDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxValidFromDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the maximum value of <c>ValidFrom</c> field of <c>CustBillingCodeVersion</c> table.
    /// </summary>
    /// <param name="_custInvoiceTableRefRecId">
    /// The record ID of the <c>CustInvoiceTable</c> table.
    /// </param>
    /// <param name="_invoiceDate">
    /// The invoice date.
    /// </param>
    /// <returns>
    /// A date value <c>ValidFrom</c> of <c>CustBillingCodeVersion</c>
    /// </returns>
    public date getMaxValidFromDate(
        CustInvoiceTableRefRecId _custInvoiceTableRefRecId,
        date _invoiceDate)
    {
        CustBillingCodeVersion  custBillingCodeVersion;
        CustInvoiceLine         custInvoiceLine;

        select validtimestate(_invoiceDate) maxof(ValidFrom) from custBillingCodeVersion
            join ParentRecId from custInvoiceLine
            where custInvoiceLine.ParentRecId == _custInvoiceTableRefRecId;

        return custBillingCodeVersion.ValidFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMinValidToDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the minimum value of <c>ValidTo</c> field of <c>CustBillingCodeVersion</c> table.
    /// </summary>
    /// <param name="_custInvoiceTableRefRecId">
    /// The record ID of the <c>CustInvoiceTable</c> table.
    /// </param>
    /// <param name="_invoiceDate">
    /// The invoice date.
    /// </param>
    /// <returns>
    /// A date value <c>ValidTo</c> of <c>CustBillingCodeVersion</c>
    /// </returns>
    public date getMinValidToDate(
        CustInvoiceTableRefRecId _custInvoiceTableRefRecId,
        date _invoiceDate)
    {
        CustBillingCodeVersion  custBillingCodeVersion;
        CustInvoiceLine         custInvoiceLine;

        select validtimestate(_invoiceDate) minOf(ValidTo) from custBillingCodeVersion
            join ParentRecId from custInvoiceLine
            where custInvoiceLine.ParentRecId == _custInvoiceTableRefRecId;

        return custBillingCodeVersion.ValidTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>CustBillingCodeVersion</c> record.
    /// </summary>
    /// <remarks>
    /// Sets the AllowChangeLedgerAccount and AllowChangeAmount fields to true.
    /// </remarks>
    public void initValue()
    {
        super();

        this.AllowChangeLedgerAccount   = NoYes::Yes;
        this.AllowChangeAmount = NoYes::Yes;
        this.ProjIdAllowChanges = NoYes::Yes;
        this.ProjCategoryAllowChanges = NoYes::Yes;
        this.RateFieldSelector = RateField::LineAmount;
        this.UseFromBillingClass = NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the value of <c>ProjId</c> and ProjCategoryId, depending on their current values.
    /// </summary>
    /// <param name="_fieldId">
    /// The field for which the method is being called.
    /// </param>
    public void modifiedField(fieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(CustBillingCodeVersion, ProjId):
                this.ProjIdAllowChanges = NoYes::Yes;
                break;

            case fieldNum(CustBillingCodeVersion, ProjCategoryId):
                this.ProjCategoryAllowChanges = NoYes::Yes;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    public boolean validateDelete()
    {
        boolean             isValid;
        CustInvoiceLine     custInvoiceLine;
        CustInvoiceTable    custInvoiceTable;

        if (this.RecId)
        {
            // Find out if current version of the billing code is used by the invoice.
            select RecId from custInvoiceTable
                where custInvoiceTable.InvoiceDate >= this.ValidFrom
                    && custInvoiceTable.InvoiceDate <= this.ValidTo
                exists join custInvoiceLine
                    where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
                        && custInvoiceLine.CustBillingCode == this.CustBillingCode;
        }

        if (custInvoiceTable.RecId != 0)
        {
            // Won't allow to delete this version if it is used by an invoice.
            error("@SPS744");
            isValid = false;
        }
        else
        {
            isValid = super();
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean validateField(fieldId _fieldIdToCheck)
    {
        boolean ret;

        ret = super(_fieldIdToCheck);

        switch (_fieldIdToCheck)
        {
            case fieldNum(CustBillingCodeVersion, ProjId):
                if (ProjTable::find(this.ProjId).Status == ProjStatus::Completed)
                {
                    ret = checkFailed(strFmt("@SYS53010", ProjTable::find(this.ProjId).Stage()));
                }
                break;
            case fieldNum(CustBillingCodeVersion, ValidFrom):
            case fieldNum(CustBillingCodeVersion, ValidTo):
                if (this.RecId != 0)
                {
                    ret = this.checkBillingCodeVersionOnInvoiceLine(this);
                }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the ledger account(s) in the <c>CustBillingCodeLedgerAccount</c> table.
    /// </summary>
    /// <returns>
    /// true if the ledger accounts are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If AllowChangeLedgerAccount is set to NoYes::No, then there cannot be a ledger account associated with the billing code with percentage specified as 0.
    /// Also checks the sum of ledger accounts' percentages.
    /// </remarks>
    public boolean validateLedgerAccounts()
    {
        boolean                      isValid = true;
        CustBillingCodeLedgerAccount ledgerAccount;

        //if the AllowChangeLedgerAccount is not selected
        if (this.AllowChangeLedgerAccount == NoYes::No)
        {
            select count(RecId) from ledgerAccount
                where ledgerAccount.CustBillingCodeVersion == this.RecId
                   && ledgerAccount.Percentage  == 0.00;

            if (ledgerAccount.RecId > 0)
            {
                isValid = checkFailed("@SPS205");
            }
        }

        if ( isValid )
        {
            //calculating the count of ledger accounts and sum of their percentages
            select count(RecId), sum(Percentage)
            from ledgerAccount
                where ledgerAccount.CustBillingCodeVersion == this.RecId;

            //if one or more ledger accounts have been entered
            if (ledgerAccount.RecId > 0)
            {
                //if the sum of percentages is NOT equal to 100
                if (round(ledgerAccount.Percentage, 0.0001) != 100.00)
                {
                    isValid = checkFailed("@SPS204");
                }
                else
                {
                    //Only if above check fails following check for valid account will performed as database hit is required, this will
                    //save the database hit if the above check fails.
                    ledgerAccount.clear();
                    select count(RecId) from ledgerAccount
                        where ledgerAccount.LedgerDimension == 0
                           && ledgerAccount.CustBillingCodeVersion == this.RecId;

                    if (ledgerAccount.RecId > 0)
                    {
                        //Raise error if any record with null ledger account is found.
                        isValid = checkFailed("@SPS204");
                    }
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    public boolean validateWrite()
    {
        boolean ret;
        ProjValCheckTrans projValCheckTrans = new ProjValCheckTrans();

        ret = super();

        if (ret && this.ProjId != '')
        {
            ret = projValCheckTrans.validateMandatory(this);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record exists in the <c>CustBillingCodeVersion</c> table; if not, an error message is displayed.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the <c>CustBillingCodeVersion</c> table record to be checked for existence.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean checkExist(recId _recId)
    {
        boolean ret = true;

        if (!CustBillingCodeVersion::exist(_recId))
        {
            ret = checkFailed(strFmt(CustBillingCodeVersion::txtNotExist(), _recId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>CustBillingCodeVersion</c> table exists.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the <c>CustBillingCodeVersion</c> table to check for existence.
    /// </param>
    /// <returns>
    /// true if the specified record exists, otherwise, false.
    /// </returns>
    public static boolean exist(recId _recId)
    {
        boolean found;
        date    fromDate;
        date    endDate;

        fromDate = dateNull();
        endDate = maxDate();

        found = (select firstOnly validTimeState(fromDate, endDate) RecId
                    from custBillingCodeVersion
                         where custBillingCodeVersion.RecId == _recId).RecId != 0;

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existByDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>CustBillingCodeVersion</c> table exists.
    /// </summary>
    /// <param name="_billingCodeRecId">
    /// The record ID of the <c>CustBillingCodeVersion</c> table to check for existence.
    /// </param>
    /// <param name="_validFromDate">
    /// The validFromDate of the <c>CustBillingCodeVersion</c> table to check for existence.
    /// </param>
    /// <returns>
    /// true if the specified record exists, otherwise, false.
    /// </returns>
    public static boolean existByDate(recId _billingCodeRecId, date _validFromDate)
    {
        boolean isValidBillingCodeVersion;

        isValidBillingCodeVersion = (select validtimestate(_validFromDate) custBillingCodeVersion
                                        where custBillingCodeVersion.CustBillingCode == _billingCodeRecId).RecId != 0;

        return isValidBillingCodeVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>find</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the billing code version based on RecID field.
    /// </summary>
    /// <param name="_custBillingCodeVersionRefRecId">
    /// The RefRecId corresponds the RecID field.
    /// </param>
    /// <param name="_forupdate">
    /// A boolean that determines whether to read the record for updating; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// A value used when the table is not automatically concurrent; optional.
    /// </param>
    /// <returns>
    /// A <c>CustBillingCodeVersion</c> table buffer.
    /// </returns>
    /// <remarks>
    /// A public method to find billing code version records.
    /// </remarks>
    public static CustBillingCodeVersion find(
        RefRecId _custBillingCodeVersionRefRecId,
        boolean             _forupdate = false,
        ConcurrencyModel    _concurrencyModel = ConcurrencyModel::Auto)
    {
        CustBillingCodeVersion  custBillingCodeVersion;
        date                    fromDate;
        date                    endDate;

        fromDate = dateNull();
        endDate = maxDate();

        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            custBillingCodeVersion.concurrencyModel(_concurrencyModel);
        }

        if (_custBillingCodeVersionRefRecId)
        {
            custBillingCodeVersion.selectForUpdate(_forupdate);
            select firstOnly validTimeState(fromDate, endDate) custBillingCodeVersion
                where custBillingCodeVersion.RecId == _custBillingCodeVersionRefRecId;
        }

        return custBillingCodeVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>CustBillingCodeVersion</c> table based upon transaction date and <paramref name="_billingCodeRecId"/> .
    /// </summary>
    /// <param name="_billingCodeRecId">
    /// The record Id of the <c>CustBillingCode</c> table.
    /// </param>
    /// <param name="_validFromDate">
    /// The date used for finding the version for billing code.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record of the <c>CustBillingCodeVersion</c> table if found; otherwise, an empty buffer.
    /// </returns>
    public static CustBillingCodeVersion findByDate(
        recId   _billingCodeRecId,
        date    _validFromDate,
        boolean _forUpdate = false)
    {
        CustBillingCodeVersion  custBillingCodeVersion;

        custBillingCodeVersion.selectForUpdate(_forUpdate);

        select validtimestate(_validFromDate) custBillingCodeVersion
            where custBillingCodeVersion.CustBillingCode == _billingCodeRecId;

        return custBillingCodeVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCurrentVersionByBillingCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the current version in the <c>CustBillingCodeVersion</c> table by billing code.
    /// </summary>
    /// <param name="_billingCodeRecId">
    /// The record id of <c>CustBillingCode</c> table to find.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model option to be used when reading the record; optional.
    /// </param>
    /// <returns>
    /// A record of the <c>CustBillingCodeVersion</c> table if found; otherwise, an empty buffer.
    /// </returns>
    public static CustBillingCodeVersion findCurrentVersionByBillingCode(
        recId               _billingCodeRecId,
        boolean             _forUpdate = false,
        ConcurrencyModel    _concurrencyModel = ConcurrencyModel::Auto)
    {
        CustBillingCodeVersion custBillingCodeVersion;

        if (_forUpdate && _concurrencyModel != ConcurrencyModel::Auto)
        {
            custBillingCodeVersion.concurrencyModel(_concurrencyModel);
        }

        custBillingCodeVersion.selectForUpdate(_forUpdate);

        select firstOnly custBillingCodeVersion
            where custBillingCodeVersion.CustBillingCode == _billingCodeRecId;

        return custBillingCodeVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves interest code associated with the billing code version.
    /// </summary>
    /// <param name="_custTrans">
    /// The customer transaction record.
    /// </param>
    /// <param name="_billingCodeRecId">
    /// The Billing Code record ID.
    /// </param>
    /// <returns>
    /// Returns interest code record and interest calculation source.
    /// </returns>
    public static container interestCode(
        CustTrans           _custTrans,
        BillingCodeRefRecId _billingCodeRecId)
    {
        RefRecId                custInterestRecId;
        CustBillingCodeVersion  custBillingCodeVersion;
        CustInterestCodeSource  interestCodeSource;

        custBillingCodeVersion = CustBillingCodeVersion::findByDate(_billingCodeRecId, _custTrans.TransDate);

        if (custBillingCodeVersion)
        {
            switch (custBillingCodeVersion.UseFromBillingClass)
            {
                case NoYes::No:
                    custInterestRecId = custBillingCodeVersion.CustInterest;

                    if (custInterestRecId)
                    {
                        interestCodeSource = custBillingCodeVersion.getCustInterestCodeSourceBillingCode();
                    }
                    break;

                case NoYes::Yes:
                    [custInterestRecId, interestCodeSource] = CustBillingClassification::interestCode(_custTrans);
                    break;
            }
        }
        else
        {
            [custInterestRecId, interestCodeSource] = CustBillingClassification::interestCode(_custTrans);
        }

        return [custInterestRecId, interestCodeSource];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustInterestCodeSourceBillingCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the billing code enum value of <c>CustInterestCodeSource</c>.
    /// </summary>
    /// <returns>
    /// Enum value of BillingCode of enum <c>CustInterestCodeSource</c>.
    /// </returns>
    protected CustInterestCodeSource getCustInterestCodeSourceBillingCode()
    {
        return CustInterestCodeSource::BillingCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfDateRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the number of date versions for the specified billing code record.
    /// </summary>
    /// <param name="_billingCodeRecId">
    /// The record id of <c>CustBillingCode</c> table to find.
    /// </param>
    /// <returns>
    /// The number of versions of the <c>CustBillingCodeVersion</c> table record.
    /// </returns>
    public static int numberOfDateRecords(recId _billingCodeRecId)
    {
        CustBillingCodeVersion  custBillingCodeVersion;
        date                    beginDate;
        date                    endDate;

        beginDate   = dateNull();
        endDate     = maxDate();

        select validtimestate(beginDate, endDate) count(RecId)
            from custBillingCodeVersion
                where custBillingCodeVersion.CustBillingCode == _billingCodeRecId;

        return any2int(custBillingCodeVersion.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtNotExist</Name>
				<Source><![CDATA[
    public static TxtNotExist txtNotExist()
    {
        return "@SYS127989";
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultRow</Name>
				<Source><![CDATA[
    public void defaultRow()
    {
        super();

        if (this.ProjId == '')
        {
            this.ProjIdAllowChanges = NoYes::Yes;
        }

        if (this.ProjCategoryId == '')
        {
            this.ProjCategoryAllowChanges = NoYes::Yes;
        }

        if (this.UseFromBillingClass)
        {
            this.CustInterest = 0;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>PublicSector</ConfigurationKey>
	<DeveloperDocumentation>@SPS850</DeveloperDocumentation>
	<FormRef>CustBillingCode</FormRef>
	<Label>@SPS865</Label>
	<TitleField1>CustBillingCode</TitleField1>
	<TitleField2>ValidFrom</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<CacheLookup>Found</CacheLookup>
	<ClusteredIndex>RecId</ClusteredIndex>
	<Modules>AccountsReceivable</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<ReplacementKey>CustBillingCodeVersionIdx</ReplacementKey>
	<ValidTimeStateFieldType>Date</ValidTimeStateFieldType>
	<DeleteActions>
		<AxTableDeleteAction>
			<Name>CustBillingCodeCustomField</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustBillingCodeCustomField</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CustBillingCodeLedgerAccount</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustBillingCodeLedgerAccount</Table>
		</AxTableDeleteAction>
		<AxTableDeleteAction>
			<Name>CustBillingCodeRate</Name>
			<DeleteAction>Cascade</DeleteAction>
			<Relation></Relation>
			<Table>CustBillingCodeRate</Table>
		</AxTableDeleteAction>
	</DeleteActions>
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustBillingCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountDetails</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AllowChangeLedgerAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroupHeading</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AllowChangeAmount</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ValidTo</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustBillingCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Amount</Name>
			<Label>@SPS22</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AllowChangeAmount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AmountDetails</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RateFieldSelector</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>BillingCode</Name>
			<Label>@SPS21</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustBillingCode</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Dimension</Name>
			<Label>@SYS14926</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>Dimension</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS36186</Label>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Interest</Name>
			<Label>@SYS3854</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>UseFromBillingClass</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CustInterest</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>LedgerAccount</Name>
			<Label>@SYS8343</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AllowChangeLedgerAccount</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>UseDimensionsFromLine</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@SYS34991</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CustBillingCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroupHeading</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Project</Name>
			<Label>@SYS80304</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjCategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjIdAllowChanges</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjCategoryAllowChanges</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SalesTax</Name>
			<Label>@SYS22916</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxItemGroupHeading</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ValidDates</Name>
			<Label>@SYS7402</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ValidFrom</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidTo</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AllowChangeAmount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@Publicsector:CustBillingCode_AmountChange</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AllowChangeLedgerAccount</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@PublicSector:CustBillingCode_LedgerAccountChange</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AmountDetails</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountDetails</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CustBillingCode</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>CustInterest</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RefRecId</ExtendedDataType>
			<Label>@SYS8324</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Dimension</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>String255</ExtendedDataType>
			<Label>@SYS850</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjCategoryAllowChanges</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PublicSector</ConfigurationKey>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@PublicSector:CustBillingCode_ProjectCategoryChange</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjCategoryId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PublicSector</ConfigurationKey>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PublicSector</ConfigurationKey>
			<ExtendedDataType>ProjId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ProjIdAllowChanges</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ConfigurationKey>PublicSector</ConfigurationKey>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@PublicSector:CustBillingCode_ProjectIdChange</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>RateFieldSelector</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>RateFieldSelector</ExtendedDataType>
			<EnumType>RateField</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TaxItemGroupHeading</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxItemGroup</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UseDimensionsFromLine</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS4004021</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>UseFromBillingClass</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>NoYesId</ExtendedDataType>
			<Label>@SPS508</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ValidFrom</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ValidFromDate</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ValidTo</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ValidToDate</ExtendedDataType>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>CustBillingCodeVersionIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<ValidTimeStateKey>Yes</ValidTimeStateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ValidTo</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValidFrom</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CustBillingCode</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>CustInterestIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>CustInterest</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings>
		<AxTableMapping>
			<MappingTable>SysDateEffectiveVersion</MappingTable>
			<Connections>
				<AxTableMappingConnection>
					<MapField>ValidFrom</MapField>
					<MapFieldTo>ValidFrom</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ValidTo</MapField>
					<MapFieldTo>ValidTo</MapFieldTo>
				</AxTableMappingConnection>
				<AxTableMappingConnection>
					<MapField>ParentId</MapField>
					<MapFieldTo>CustBillingCode</MapFieldTo>
				</AxTableMappingConnection>
			</Connections>
		</AxTableMapping>
	</Mappings>
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustBillingCode</Name>
			<Cardinality>OneMore</Cardinality>
			<RelatedTable>CustBillingCode</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustBillingCode</RelatedTableRole>
			<RelationshipType>Composition</RelationshipType>
			<Role>CustBillingCode_CustBillingCodeVersion</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustBillingCode</Name>
					<Field>CustBillingCode</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>CustInterest</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>CustInterest</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>CustInterest</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>CustInterest_CustBillingCodeVersion</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CustInterest</Name>
					<Field>CustInterest</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjCategory</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjCategoryId</Name>
					<SourceEDT>ProjCategoryId</SourceEDT>
					<Field>ProjCategoryId</Field>
					<RelatedField>CategoryId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CategoryIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjId</Name>
					<SourceEDT>ProjId</SourceEDT>
					<Field>ProjId</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ProjectIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>TaxItemGroupHeading</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>TaxItemGroupHeading</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>TaxItemGroupHeading</Name>
					<SourceEDT>TaxItemGroup</SourceEDT>
					<Field>TaxItemGroupHeading</Field>
					<RelatedField>TaxItemGroup</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>TaxItemGroupIdx</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>