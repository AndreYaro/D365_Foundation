<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class InventTrans extends common
{
    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountBalanceSheetLedgerDimension</Name>
				<Source><![CDATA[
    public display LedgerDimensionAccount accountBalanceSheetLedgerDimension()
    {
        return this.inventTransPostingFinancial().LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveSettlements</Name>
				<Source><![CDATA[
    private boolean canHaveSettlements()
    {
        return (this.isUpdatedFinancial() || this.isUpdatedPhysical());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatusIncludedInPhysicalInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if transactions with the specified inventory status affect physical on hand.
    /// </summary>
    /// <param name="_statusReceipt">
    /// The receipt status of the transaction.
    /// </param>
    /// <param name="_statusIssue">
    /// The issue status of the transaction.
    /// </param>
    /// <returns>
    /// true if the transactions with the specified inventory status affect physical on hand; otherwise, false.
    /// </returns>
    public static boolean isStatusIncludedInPhysicalInventory(StatusReceipt _statusReceipt, StatusIssue _statusIssue)
    {
        return (_statusReceipt != StatusReceipt::None && _statusReceipt <= StatusReceipt::Registered)
            || InventTrans::isStatusIssueIncludedInPhysicalInventory(_statusIssue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatusIssueIncludedInPhysicalInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if issue transactions with the specified inventory status affect physical on hand.
    /// </summary>
    /// <param name="_statusIssue">
    /// The issue status of the transaction.
    /// </param>
    /// <returns>
    /// true if the issue transactions with the specified inventory status affect physical on hand; otherwise, false.
    /// </returns>
    [Hookable(false)]
    public static boolean isStatusIssueIncludedInPhysicalInventory(StatusIssue _statusIssue)
    {
        return _statusIssue != StatusIssue::None && _statusIssue <= StatusIssue::Picked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountLossProfitLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionAccount accountLossProfitLedgerDimension(CostAmount _adjustment)
    {
        InventAccountType inventAccountType = _adjustment > 0
                                                  ? InventAccountType::InventProfit
                                                  : InventAccountType::InventLoss;

        InventPostingItemLedgerDimensionParameters searchParameters = this.buildItemLedgerDimensionParameter(inventAccountType);
        searchParameters.InventDim_RU = this.inventDim();

        LedgerDimensionDefaultAccount ldda = InventPosting::itemLedgerDimensionFromParameter(searchParameters);

        return this.getLedgerDimensionFromDefaultAccount(ldda, this.dimensionFinancialOrPhysicalDefaultDim());
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting ledger dimension for an item.
    /// </summary>
    /// <param name = "_inventAccountType">A inventory account type.</param>
    /// <returns>The built parameter instance.</returns>
    protected InventPostingItemLedgerDimensionParameters buildItemLedgerDimensionParameter(
        InventAccountType   _inventAccountType)
    {
        InventPostingItemLedgerDimensionParameters searchParameters = InventPostingItemLedgerDimensionParameters::newFromParameters(
            _inventAccountType,
            this.ItemId);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            searchParameters.InventDim_RU = this.inventDim();
        }

        return searchParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensionFinancialOrPhysicalDefaultDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the default financial or physical dimension.
    /// </summary>
    /// <returns>The default financial or physical dimension.</returns>
    /// <remarks>This method exists for extensibility purposes.</remarks>
    protected DimensionDefault dimensionFinancialOrPhysicalDefaultDim()
    {
        return this.dimensionFinancialDefaultDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperationsLedgerDimension</Name>
				<Source><![CDATA[
    public display LedgerDimensionAccount accountOperationsLedgerDimension()
    {
        return this.inventTransPostingFinancial().OffsetLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysicalLedgerDimension</Name>
				<Source><![CDATA[
    public display LedgerDimensionAccount accountPhysicalLedgerDimension()
    {
        return this.inventTransPostingPhysical().LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysicalOffsetLedgerDimension</Name>
				<Source><![CDATA[
    public display LedgerDimensionAccount accountPhysicalOffsetLedgerDimension()
    {
        return this.inventTransPostingPhysical().OffsetLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountStdLossLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionAccount accountStdLossLedgerDimension()
    {
        if (InventPostingExtendParm_CN::checkExtendParmEnabled())
        {
            return this.getLedgerDimensionFromDefaultAccount(
                InventPosting::itemExtendParm_CN(
                    InventAccountType::InventStdLoss,
                    InventPostingExtendParm_CN::constructInventDim(this.inventDim()),
                    this.ItemId));
        }

        return this.getLedgerDimensionFromDefaultAccount(
                        InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::InventStdLoss)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountStdProfitLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionAccount accountStdProfitLedgerDimension()
    {
        if (InventPostingExtendParm_CN::checkExtendParmEnabled())
        {
            return this.getLedgerDimensionFromDefaultAccount(
                InventPosting::itemExtendParm_CN(
                    InventAccountType::InventStdProfit,
                    InventPostingExtendParm_CN::constructInventDim(this.inventDim()),
                    this.ItemId));
        }

        return this.getLedgerDimensionFromDefaultAccount(
                        InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::InventStdProfit)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowDimChange</Name>
				<Source><![CDATA[
    public boolean  allowDimChange()
    {
        return (this.StatusReceipt  == StatusReceipt::Ordered               ||
                this.StatusReceipt  == StatusReceipt::QuotationReceipt      ||
                this.StatusIssue    == StatusIssue::QuotationIssue          ||
                this.StatusIssue    == StatusIssue::OnOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assemblyInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the related assembly inventory transaction originator.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    An assembly inventory transaction originator if a record exists; otherwise, an empty buffer.
    /// </returns>
    public InventTransOrigin assemblyInventTransOrigin(boolean _forUpdate = false)
    {
        return InventTransOrigin::assemblyInventTransOriginByOriginRecId(this.InventTransOrigin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCostAmountStdAdjustment</Name>
				<Source><![CDATA[
    private CostAmountStdAdjustment calcCostAmountStdAdjustment()
    {
        InventSettlement inventSettlement;
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        select sum(CostAmountAdjustment) from inventSettlement
            where inventSettlement.TransRecId           == this.RecId
              &&  inventSettlement.Cancelled            == NoYes::No
              && (inventSettlement.OperationsPosting    == LedgerPostingType::PurchStdProfit
              ||  inventSettlement.OperationsPosting    == LedgerPostingType::PurchStdLoss
              ||  inventSettlement.OperationsPosting    == LedgerPostingType::InventStdProfit
              ||  inventSettlement.OperationsPosting    == LedgerPostingType::InventStdLoss)
              && (!countryRegion_RU
                || (countryRegion_RU
                    && inventSettlement.InventTransCurrency_RU == InventTransCurrency_RU::PrimaryCur));

        return inventSettlement.CostAmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCostAmountStdAdjustment_PL</Name>
				<Source><![CDATA[
    private CostAmountStdAdjustment calcCostAmountStdAdjustment_PL()
    {
        CostAmountStdAdjustment ret = 0;
        InventSettlement        inventSettlement;
        InventSettlement        inventSettlementRef;
        InventTrans             inventTransRef;

        while select SettleTransId, RecId from inventSettlement
              where inventSettlement.TransRecId == this.RecId &&
                    inventSettlement.Cancelled  == NoYes::No
        {
            select firstonly inventSettlementRef 
                where inventSettlementRef.SettleTransId == inventSettlement.SettleTransId &&
                        inventSettlementRef.RecId         != inventSettlement.RecId;

            if (inventSettlementRef)
            {
                inventTransRef = inventSettlementRef.inventTrans();
                ret -= inventTransRef.calcCostAmountStdAdjustment() / inventTransRef.Qty * inventSettlementRef.QtySettled;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditDimensions</Name>
				<Source><![CDATA[
    public boolean canEditDimensions()
    {
        return ! this.TransChildType && ! this.QtySettled && this.ValueOpen == InventTransOpen::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCostValue</Name>
				<Source><![CDATA[
    public boolean checkCostValue( CostPricePcsMaxValue _maxReceiptCostPricePcs = 0)    // set the parameter for better performance if available
    {
        CostPricePcsMaxValue    maxReceiptCostPricePcs;

        if (this.Qty >= 0)
        {
            if (this.CostAmountPosted < 0 || this.costValue() < 0)
            {
                return checkFailed("@SYS53174");
            }

            if (prmisDefault(_maxReceiptCostPricePcs))
            {
                maxReceiptCostPricePcs = InventParameters::find().CostPricePcsMaxValue;
            }
            else
            {
                maxReceiptCostPricePcs = _maxReceiptCostPricePcs;
            }

            if (maxReceiptCostPricePcs > 0  && this.costPrice() > maxReceiptCostPricePcs)
            {
                return checkFailed(strFmt("@SYS96678",this.costPrice(),maxReceiptCostPricePcs));
            }
        }
        else
        {
            if (this.CostAmountPosted > 0 || this.costValue() > 0)
            {
                return checkFailed("@SYS53173");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFixFields</Name>
				<Source><![CDATA[
    public void checkFixFields(
        InventConsistencyCheck_Trans    _inventConsistencyCheck_Trans,
        InventTransOrigin               _inventTransOrigin)
    {
        InventTrans     copy = this.data();
        // <GEERU>
        boolean         countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        copy.setClosedOpen();
        // <GEERU>
        if (countryRegion_RU)
        {
            copy.setClosedOpenSecCur_RU();
        }
        // </GEERU>
        copy.setStatusDate();

        setPrefix( strFmt("@SYS26312", _inventTransOrigin.ReferenceId) );

        if (!copy.DatePhysical && copy.DateFinancial)
        {
            checkFailed("@SYS2476", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, DatePhysical)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.DatePhysical = copy.DateFinancial;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }

        if (copy.DateStatus != this.DateStatus)
        {
            checkFailed("@SYS18457", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, DateStatus)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.DateStatus = copy.DateStatus;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }

        if (copy.ValueOpen != this.ValueOpen)
        {
            checkFailed( "@SYS18458", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, ValueOpen)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.ValueOpen = copy.ValueOpen;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }

        if (copy.DateClosed != this.DateClosed)
        {
            checkFailed("@SYS18460", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, DateClosed)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.DateClosed = copy.DateClosed;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }

        // <GEERU>
        if (countryRegion_RU
            && copy.ValueOpenSecCur_RU != this.ValueOpenSecCur_RU)
        {
            checkFailed( "@GLS110481", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, ValueOpenSecCur_RU)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.ValueOpenSecCur_RU = copy.ValueOpenSecCur_RU;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }

        if (countryRegion_RU
            && copy.DateClosedSecCur_RU != this.DateClosedSecCur_RU)
        {
            checkFailed("@GLS110482", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, DateClosedSecCur_RU)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.DateClosedSecCur_RU = copy.DateClosedSecCur_RU;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }
        // </GEERU>

        if (this.Qty   > 0)
        {
            if (this.StatusReceipt == StatusReceipt::None)
            {
                checkFailed("@SYS18462", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, StatusReceipt)));
                if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                {
                    this.StatusReceipt = StatusReceipt::Purchased;
                    this.doUpdate();

                    _inventConsistencyCheck_Trans.updateCorrected();
                }
                else
                {
                    _inventConsistencyCheck_Trans.updateNotCorrected();
                }
            }

            if (this.StatusIssue  != StatusIssue::None)
            {
                checkFailed("@SYS18463", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, StatusIssue)));
                if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                {
                    this.StatusIssue = StatusIssue::None;
                    this.doUpdate();

                    _inventConsistencyCheck_Trans.updateCorrected();
                }
                else
                {
                    _inventConsistencyCheck_Trans.updateNotCorrected();
                }
            }
        }
        else
        if (this.Qty   < 0)
        {
            if (this.StatusIssue  == StatusIssue::None)
            {
                checkFailed("@SYS18463", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, StatusIssue)));
                if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                {
                    this.StatusIssue = StatusIssue::Sold;
                    this.doUpdate();

                    _inventConsistencyCheck_Trans.updateCorrected();
                }
                else
                {
                    _inventConsistencyCheck_Trans.updateNotCorrected();
                }
            }

            if (this.StatusReceipt != StatusReceipt::None)
            {
                checkFailed("@SYS18462", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, StatusReceipt)));
                if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                {
                    this.StatusReceipt = StatusReceipt::None;
                    this.doUpdate();

                    _inventConsistencyCheck_Trans.updateCorrected();
                }
                else
                {
                    _inventConsistencyCheck_Trans.updateNotCorrected();
                }
            }
        }
        else
        {
            if (this.StatusIssue  != StatusIssue::None)
            {
                checkFailed("@SYS18463", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, StatusIssue)));
                if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                {
                    this.StatusIssue = StatusIssue::None;
                    this.doUpdate();

                    _inventConsistencyCheck_Trans.updateCorrected();
                }
                else
                {
                    _inventConsistencyCheck_Trans.updateNotCorrected();
                }
            }

            if (this.StatusReceipt != StatusReceipt::None)
            {
                checkFailed("@SYS18462", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, StatusReceipt)));
                if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                {
                    this.StatusReceipt = StatusReceipt::None;
                    this.doUpdate();

                    _inventConsistencyCheck_Trans.updateCorrected();
                }
                else
                {
                    _inventConsistencyCheck_Trans.updateNotCorrected();
                }
            }
        }
        if (this.ItemId != _inventTransOrigin.ItemId)
        {
            checkFailed("@SYS134705", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, ItemId)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                if (_inventTransOrigin.ItemId)
                {
                    this.ItemId = _inventTransOrigin.ItemId;
                    this.doUpdate();
                    _inventConsistencyCheck_Trans.updateCorrected();
                }
                else
                {
                    _inventConsistencyCheck_Trans.updateNotCorrected();
                }
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFixReference</Name>
				<Source><![CDATA[
    public void checkFixReference(
        InventConsistencyCheck_Trans    _inventConsistencyCheck_Trans,
        InventTransOrigin               _inventTransOrigin)
    {
        SalesLine                               salesLine;
        PurchLine                               purchLine;
        PurchRFQCaseLine                        purchRFQCaseLine;
        PurchRFQLine                            purchRFQLine;
        PurchRFQTable                           purchRFQTable;
        ProdTable                               prodTable;
        ProdBOM                                 prodBOM;
        InventDimGroupFieldSetupEnumerator      enumerator;
        InventDimGroupFieldSetup                inventDimGroupFieldSetup;
        FieldId                                 inventDimFieldId;
        SalesQuotationLine                      salesQuotationLine;
        RetailTransactionSalesTrans    rboTransactionSalesTrans;

        void _check(
                RecId               recId,
                ItemId              itemId,
                InventDim           inventDim,
                InventTransRefId    refNum,
                InventTrans         inventTrans)
        {
            if (! recId)
            {
                checkFailed(strFmt("@SYS17680", _inventTransOrigin.ReferenceId), '', SysInfoAction_TableField::newBufferField(_inventTransOrigin, fieldNum(InventTransOrigin, ReferenceId)));
            }
            else
            {
                if (refNum   != _inventTransOrigin.ReferenceId)
                {
                    checkFailed("@SYS77053", '', SysInfoAction_TableField::newBufferField(_inventTransOrigin, fieldNum(InventTransOrigin,ReferenceId)));
                }

                if (itemId != inventTrans.ItemId)
                {
                    checkFailed("@SYS18474", '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, ItemId)));
                }

                enumerator = InventDimGroupSetup::newItemId(itemId).getFieldSetupEnumerator();
                while (enumerator.moveNext())
                {
                    inventDimGroupFieldSetup = enumerator.current();
                    inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();

                    if (inventDim.(inventDimFieldId) && !inventDimGroupFieldSetup.isActive())
                    {
                        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                        {
                            checkFailed(strFmt(itemId +  "@SYS54773",fieldId2pname(inventDim.TableId, inventDimFieldId)),
                                       '',SysInfoAction_TableField::newBufferField(inventTrans.inventDim(), inventDimFieldId));
                        }
                        else
                        {
                            checkFailed(strFmt("@SYS54773",fieldId2pname(inventDim.TableId, inventDimFieldId)),
                                        '',SysInfoAction_TableField::newBufferField(inventTrans.inventDim(), inventDimFieldId));
                        }
                    }

                    if (inventDimGroupFieldSetup.isProductDimension() && inventDim.(inventDimFieldId) != inventTrans.inventDim().(inventDimFieldId))
                    {
                        checkFailed(strFmt("@SYS71042",fieldId2pname(inventDim.TableId, inventDimFieldId)),
                                    '',SysInfoAction_TableField::newBufferField(inventTrans.inventDim(), inventDimFieldId));
                    }
                }
            }
        }

        if (! this.isUpdatedFinancial())
        {
            setPrefix( strFmt("@SYS26312", _inventTransOrigin.ReferenceId) );

            switch (_inventTransOrigin.ReferenceCategory)
            {
                case InventTransType::Sales:
                    salesLine = InventTransOriginSalesLine::salesLine(_inventTransOrigin.RecId);
                    _check(salesLine.RecId,salesLine.ItemId,salesLine.inventDim(),salesLine.SalesId,this);
                    break;

                case InventTransType::Statement:
                    if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                    {
                        rboTransactionSalesTrans = this.rboTransactionSalesTrans();
                        _check(rboTransactionSalesTrans.RecId,rboTransactionSalesTrans.ItemId,rboTransactionSalesTrans.inventDim(),rboTransactionSalesTrans.StatementId,this);
                    }
                    break;

                case InventTransType::Purch:
                    if (this.StatusReceipt == StatusReceipt::QuotationReceipt)
                    {
                        purchRFQCaseLine = InventTransOriginPurchRFQCaseLine::purchRFQCaseLine(_inventTransOrigin.RecId);
                        if (purchRFQCaseLine)
                        {
                            _check(purchRFQCaseLine.RecId,purchRFQCaseLine.ItemId,purchRFQCaseLine.inventDim(),purchRFQCaseLine.rfqCaseId,this);
                        }
                        else
                        {
                            purchRFQLine = InventTransOriginPurchRFQLine::purchRFQLine(_inventTransOrigin.RecId);
                            if (purchRFQLine)
                            {
                                purchRFQTable = purchRFQLine.purchRFQTable();
                                _check(purchRFQLine.RecId,purchRFQLine.ItemId,purchRFQLine.inventDim(),purchRFQTable.rfqCaseId,this);
                            }
                        }
                    }
                    else
                    {
                        purchLine = InventTransOriginPurchLine::purchLine(_inventTransOrigin.RecId);
                        _check(purchLine.RecId,purchLine.ItemId,purchLine.inventDim(),purchLine.PurchId,this);
                    }
                    break;
                case InventTransType::Production:
                    prodTable= InventTransOriginProdTable::prodTable(_inventTransOrigin.RecId);
                    _check(prodTable.RecId,prodTable.ItemId,prodTable.inventDim(),prodTable.ProdId,this);

                    if (! prodTable.RecId && this.isUpdatedEstimated() && ! this.TransChildType && _inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                    {
                        this.delete();

                        _inventConsistencyCheck_Trans.updateCorrected();
                    }
                    else
                    {
                        _inventConsistencyCheck_Trans.updateNotCorrected();
                    }
                    break;
                case InventTransType::ProdLine:
                    prodBOM = InventTransOriginProdBOM::prodBOM(_inventTransOrigin.RecId);
                    _check(prodBOM.RecId,prodBOM.ItemId,prodBOM.inventDim(),prodBOM.ProdId,this);

                    if (! prodBOM.RecId && this.isUpdatedEstimated() && ! this.TransChildType && _inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                    {
                        this.delete();

                        _inventConsistencyCheck_Trans.updateCorrected();
                    }
                    else
                    {
                        _inventConsistencyCheck_Trans.updateNotCorrected();
                    }
                    break;
                case InventTransType::SalesQuotation:
                    salesQuotationLine = InventTransOriginSalesQuotationLine::salesQuotationLine(_inventTransOrigin.RecId);
                    _check(salesQuotationLine.RecId,salesQuotationLine.ItemId,salesQuotationLine.inventDim(),salesQuotationLine.QuotationId,this);
                    break;
                default:
                    break;
            }

            this.checkFixChildReference(_inventConsistencyCheck_Trans, _inventTransOrigin);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFixSettlement</Name>
				<Source><![CDATA[
    public void checkFixSettlement(InventConsistencyCheck_Trans _inventConsistencyCheck_Trans)
    {
        InventSettlement    inventSettlement;
        InventTransOrigin   inventTransOrigin   = this.inventTransOrigin();
        // <GEERU>
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        setPrefix("@SYS55578");

        while select forupdate inventSettlement
            // <GEERU>
            where inventSettlement.TransRecId == this.RecId &&
                  (!countryRegion_RU ||
                  (countryRegion_RU   &&
                  inventSettlement.InventTransCurrency_RU == InventTransCurrency_RU::PrimaryCur))
            // </GEERU>
        {
            setPrefix(#prefixField(inventSettlement,RecId));

            boolean incorrectInventTransId = inventSettlement.InventTransId != inventTransOrigin.InventTransId;
            boolean incorrectItemId = inventSettlement.ItemId != this.ItemId;

            if (incorrectInventTransId
                || incorrectItemId)
            {
                checkFailed("@SYS67934",'', SysInfoAction_TableField::newBufferField(inventSettlement, fieldNum(InventSettlement, RecId)));

                if (incorrectInventTransId)
                {
                    checkFailed("@SCM:MessageValidation_InventConsistencyCheck_Trans_IncorrectInventTransId");
                    if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                    {
                        inventSettlement.inventTransId = inventTransOrigin.InventTransId;
                        inventSettlement.update();

                        _inventConsistencyCheck_Trans.updateCorrected();
                    }
                    else
                    {
                        _inventConsistencyCheck_Trans.updateNotCorrected();
                    }
                }
            
                if (incorrectItemId)
                {
                    checkFailed("@SCM:MessageValidation_InventConsistencyCheck_Trans_IncorrectItemId");
                    if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                    {
                        InventSettlement associatedInventSettlementWithIncorrectItemId;

                        select firstonly RecId from associatedInventSettlementWithIncorrectItemId
                        where associatedInventSettlementWithIncorrectItemId.RecId != inventSettlement.RecId
                            && associatedInventSettlementWithIncorrectItemId.ItemId != this.ItemId
                            && associatedInventSettlementWithIncorrectItemId.SettleTransId == inventSettlement.SettleTransId;

                        if (associatedInventSettlementWithIncorrectItemId)
                        {
                            // There exists another associated settlement with a different item ID
                            checkFailed("@SCM:MessageValidation_InventConsistencyCheck_Trans_AssociatedSettlementWithDifferentItemID");
                            _inventConsistencyCheck_Trans.updateNotCorrected();
                        }
                        else
                        {
                            inventSettlement.ItemId = this.ItemId;
                            inventSettlement.update();

                            _inventConsistencyCheck_Trans.updateCorrected();
                        }
                    }
                    else
                    {
                        _inventConsistencyCheck_Trans.updateNotCorrected();
                    }
                }
            }
        }

        select sum(QtySettled),sum(CostAmountSettled),sum(CostAmountAdjustment)
        ,sum(PdsCWSettled)
         from inventSettlement
            where inventSettlement.TransRecId   == this.RecId
               && inventSettlement.Cancelled    == NoYes::No
                  // <GEERU>
                  && inventSettlement.SettleModel            != InventSettleModel::PhysicalValue &&
                  (!countryRegion_RU ||
                  (countryRegion_RU   &&
                  inventSettlement.InventTransCurrency_RU == InventTransCurrency_RU::PrimaryCur));
        // </GEERU>

        if (inventSettlement.QtySettled != this.QtySettled)
        {
            checkFailed("@SYS67938",'', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, QtySettled)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.QtySettled = inventSettlement.QtySettled;
                this.PdsCWSettled = inventSettlement.PdsCWSettled;

                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }

        if (inventSettlement.CostAmountSettled != this.CostAmountSettled)
        {
            checkFailed("@SYS67939",'', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, CostAmountSettled)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.CostAmountSettled = inventSettlement.CostAmountSettled;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }

        if (inventSettlement.CostAmountAdjustment != this.CostAmountAdjustment)
        {
            checkFailed("@SYS67940",'', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, CostAmountAdjustment)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.CostAmountAdjustment = inventSettlement.CostAmountAdjustment;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFixSettlementSecCur_RU</Name>
				<Source><![CDATA[
    public void checkFixSettlementSecCur_RU(InventConsistencyCheck_Trans _inventConsistencyCheck_Trans)
    {
        InventSettlement    inventSettlement;
        InventTransOrigin   inventTransOrigin = this.inventTransOrigin();

        setPrefix("@SYS55578");

        while select forupdate inventSettlement
            where inventSettlement.TransRecId             == this.RecId &&
                  inventSettlement.InventTransCurrency_RU == InventTransCurrency_RU::SecondaryCur
        {
            setPrefix(#prefixField(inventSettlement,RecId));

            if (inventSettlement.ItemId         != this.ItemId ||
                inventSettlement.InventTransId  != inventTransOrigin.InventTransId)
            {
                checkFailed("@GLS110478", '', SysInfoAction_TableField::newBufferField(inventSettlement, fieldNum(InventSettlement, RecId)));
                if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
                {
                    inventSettlement.doDelete();
                    _inventConsistencyCheck_Trans.updateCorrected();
                }
                else
                {
                    _inventConsistencyCheck_Trans.updateNotCorrected();
                }
            }
        }

        select sum(QtySettled), sum(CostAmountSettled), sum(CostAmountAdjustment) from inventSettlement
            where inventSettlement.TransRecId             == this.RecId                       &&
                  inventSettlement.Cancelled              == NoYes::No                        &&
                  inventSettlement.SettleModel            != InventSettleModel::PhysicalValue &&
                  inventSettlement.InventTransCurrency_RU == InventTransCurrency_RU::SecondaryCur;

        if (inventSettlement.QtySettled != this.QtySettledSecCur_RU)
        {
            checkFailed("@GLS110477",'', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, QtySettledSecCur_RU)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.QtySettledSecCur_RU = inventSettlement.QtySettled;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }

        if (inventSettlement.CostAmountSettled != this.CostAmountSettledSecCur_RU)
        {
            checkFailed("@GLS110479",'', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, CostAmountSettledSecCur_RU)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.CostAmountSettledSecCur_RU = inventSettlement.CostAmountSettled;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }

        if (inventSettlement.CostAmountAdjustment != this.CostAmountSecCurAdjustment_RU)
        {
            checkFailed("@GLS110480",'', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, CostAmountSecCurAdjustment_RU)));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.CostAmountSecCurAdjustment_RU = inventSettlement.CostAmountAdjustment;
                this.doUpdate();

                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIsChanged</Name>
				<Source><![CDATA[
    public boolean checkIsChanged(InventTrans _trans)
    {
        if (_trans.StatusReceipt != this.StatusReceipt
         || _trans.StatusIssue   != this.StatusIssue
         || _trans.Qty           != this.Qty         )
        {
            return checkFailed("@SYS5149");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateSplit</Name>
				<Source><![CDATA[
    public boolean checkUpdateSplit(InventQty  _splitQty, PdsCWInventQty _cwQty = 0)
    {
        InventSplitTrans_Remain splitRemain = new InventSplitTrans_Remain();

        return splitRemain.check(this, _splitQty, _cwQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets all marking related fields to their default values.
    /// </summary>
    public void clearMarking()
    {
        this.MarkingRefInventTransOrigin    = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountExclStdAdjustment</Name>
				<Source><![CDATA[
    public display CostAmountExclStdAdjustment costAmountExclStdAdjustment()
    {
        InventSettlement inventSettlement;

        // <GEERU>
        boolean         countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        select sum(CostAmountAdjustment) from inventSettlement
            where inventSettlement.TransRecId           == this.RecId
             &&   inventSettlement.Cancelled            == NoYes::No
             &&  (inventSettlement.OperationsPosting    != LedgerPostingType::PurchStdProfit
             &&   inventSettlement.OperationsPosting    != LedgerPostingType::PurchStdLoss
             &&   inventSettlement.OperationsPosting    != LedgerPostingType::InventStdProfit
                  // <GEERU>
                  &&   inventSettlement.OperationsPosting    != LedgerPostingType::InventStdLoss)   &&
                  (!countryRegion_RU                                                           ||
                  (countryRegion_RU                                                            &&
                  inventSettlement.InventTransCurrency_RU == InventTransCurrency_RU::PrimaryCur));
        // </GEERU>

        return this.CostAmountPosted + inventSettlement.CostAmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountExclStdAdjustmentSecCur_RU</Name>
				<Source><![CDATA[
    public display CostAmountExclStdAdjustmentSecCur_RU costAmountExclStdAdjustmentSecCur_RU()
    {
        InventSettlement inventSettlement;

        select sum(CostAmountAdjustment) from inventSettlement
            where inventSettlement.TransRecId             == this.RecId                         &&
                  inventSettlement.Cancelled              == NoYes::No                          &&
                 (inventSettlement.OperationsPosting      != LedgerPostingType::PurchStdProfit  &&
                  inventSettlement.OperationsPosting      != LedgerPostingType::PurchStdLoss    &&
                  inventSettlement.OperationsPosting      != LedgerPostingType::InventStdProfit &&
                  inventSettlement.OperationsPosting      != LedgerPostingType::InventStdLoss)  &&
                  inventSettlement.InventTransCurrency_RU == InventTransCurrency_RU::SecondaryCur;

        return this.CostAmountSecCurPosted_RU + inventSettlement.CostAmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountFinancialVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the financial cost amount from the original voucher.
    /// </summary>
    /// <returns>
    ///    The financial cost amount from the original voucher.
    /// </returns>
    public CostAmount costAmountFinancialVoucher()
    {
        InventSettlement    inventSettlement;

        select sum(CostAmountAdjustment) from inventSettlement
            where inventSettlement.TransRecId   == this.RecId
               && inventSettlement.Cancelled    == NoYes::No
               && inventSettlement.SettleModel  == InventSettleModel::Adjustment
               && inventSettlement.TransDate    != this.DateFinancial
               && inventSettlement.Voucher      != this.Voucher;

        return this.costValue() - inventSettlement.CostAmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountPhysExclStdAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the physical cost amount excluding the adjustments for the standard cost items.
    /// </summary>
    /// <returns>
    ///    The physical cost amount excluding the adjustments for the standard cost items.
    /// </returns>
    public display CostAmount costAmountPhysExclStdAdjustment()
    {
        if (this.inventTable().modelGroup().inventModelType().stdCostBased())
        {
            return this.CostAmountPhysical - this.costAmountPhysicalAdjustment();
        }

        return this.CostAmountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountPhysicalAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physical cost adjustment.
    /// </summary>
    /// <returns>
    /// The physical cost adjustment.
    /// </returns>
    public CostAmount costAmountPhysicalAdjustment()
    {
        InventSettlement    inventSettlement;

        select sum(CostAmountAdjustment) from inventSettlement
            where inventSettlement.TransRecId  == this.RecId
               && inventSettlement.Cancelled   == NoYes::No
               && inventSettlement.SettleModel == InventSettleModel::PhysicalValue;

        return inventSettlement.CostAmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountPhysicalAsPerDate</Name>
				<Source><![CDATA[
    public CostAmountPhysical costAmountPhysicalAsPerDate(TransDate  _perDate)
    {
        InventSettlement    inventSettlement;

        if ( ! this.DatePhysical || this.DatePhysical > _perDate)
        {
            return 0;
        }

        select sum(CostAmountAdjustment) from inventSettlement
            where inventSettlement.TransRecId   == this.RecId
               && inventSettlement.Cancelled    == NoYes::No
               && inventSettlement.SettleModel  == InventSettleModel::PhysicalValue
               && inventSettlement.TransDate    >  _perDate;

        return this.CostAmountPhysical - inventSettlement.CostAmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountPhysicalVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the physical cost amount from the original voucher.
    /// </summary>
    /// <returns>
    ///    The physical cost amount from the original voucher.
    /// </returns>
    public CostAmountPhysical costAmountPhysicalVoucher()
    {
        InventSettlement    inventSettlement;

        select sum(CostAmountAdjustment) from inventSettlement
            where inventSettlement.TransRecId   == this.RecId
               && inventSettlement.Cancelled    == NoYes::No
               && inventSettlement.SettleModel  == InventSettleModel::PhysicalValue
               && inventSettlement.TransDate    != this.DatePhysical
               && inventSettlement.Voucher      != this.VoucherPhysical;

        return this.CostAmountPhysical - inventSettlement.CostAmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountSettlementAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the cost adjustment that is part of the settlements.
    /// </summary>
    /// <param name="_inventTransCurrency">
    ///    Currency type to calculate cost adjustment for.
    /// </param>
    /// <returns>
    ///    The adjustment amount.
    /// </returns>
    public CostAmount costAmountSettlementAdjustment(
        InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur)
    {
        // <GEERU>
        // </GEERU>
        InventSettlement inventSettlement;

        if (this.canHaveSettlements())
        {
            // <GEERU>
            boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
            // </GEERU>
            select sum(CostAmountAdjustment) from inventSettlement
            where inventSettlement.TransRecId  == this.RecId
               && inventSettlement.Cancelled   == NoYes::No
               && inventSettlement.SettleModel != InventSettleModel::PhysicalValue
               // <GEERU>
               && (!countryRegion_RU
               || (countryRegion_RU
               && inventSettlement.InventTransCurrency_RU == _inventTransCurrency))
               // </GEERU>
               && ((inventSettlement.SettleType        == InventSettleType::Receipt ||   inventSettlement.SettleType        == InventSettleType::Issue)
               &&  (inventSettlement.QtySettled        != 0                         ||   inventSettlement.CostAmountSettled != 0));
        }

        return inventSettlement.CostAmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountStdAdjustment</Name>
				<Source><![CDATA[
    public display CostAmountStdAdjustment costAmountStdAdjustment()
    {
        // <GEEU>
        CostAmountStdAdjustment costAmount;

        if (!this.StatusIssue || !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            costAmount = this.calcCostAmountStdAdjustment();
        }
        else
        {
            costAmount = this.calcCostAmountStdAdjustment_PL();
        }
        return costAmount;
        // </GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountStdAdjustmentSecCur_RU</Name>
				<Source><![CDATA[
    display CostAmountStdAdjustment costAmountStdAdjustmentSecCur_RU()
    {
        InventSettlement inventSettlement;

        select sum(CostAmountAdjustment) from inventSettlement
            where inventSettlement.TransRecId             == this.RecId                          &&
                  inventSettlement.Cancelled              == NoYes::No                           &&
                 (inventSettlement.OperationsPosting      == LedgerPostingType::PurchStdProfit   ||
                  inventSettlement.OperationsPosting      == LedgerPostingType::PurchStdLoss     ||
                  inventSettlement.OperationsPosting      == LedgerPostingType::InventStdProfit  ||
                  inventSettlement.OperationsPosting      == LedgerPostingType::InventStdLoss)   &&
                  inventSettlement.InventTransCurrency_RU == InventTransCurrency_RU::SecondaryCur;

        return inventSettlement.CostAmountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPrice</Name>
				<Source><![CDATA[
    public display CostPrice costPrice()
    {
        return this.Qty ? CurrencyExchangeHelper::price((this.CostAmountPosted + this.CostAmountAdjustment) / this.Qty, '') : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPricePhysical</Name>
				<Source><![CDATA[
    public display CostPricePhysical costPricePhysical()
    {
        return this.Qty ? CurrencyExchangeHelper::price(this.CostAmountPhysical / this.Qty, '') : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPricePhysicalSecCur_RU</Name>
				<Source><![CDATA[
    public display CostPricePhysical costPricePhysicalSecCur_RU()
    {
        CostPricePhysical costPricePhysical;
 
        if (this.Qty == 0 || this.CostAmountSecCurPhysical_RU == 0.0)
        {
            costPricePhysical = 0.0;
        }
        else
        {
            costPricePhysical = CurrencyExchangeHelper::price(this.CostAmountSecCurPhysical_RU / this.Qty, CompanyInfoHelper::secondaryCurrency_RU());
        }
 
        return costPricePhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costValue</Name>
				<Source><![CDATA[
    public display CostAmountValue costValue()
    {
        return CurrencyExchangeHelper::amount(this.CostAmountPosted + this.CostAmountAdjustment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjIdByMarkingRefInventTransOrigin</Name>
				<Source><![CDATA[
    internal static ProjId getProjIdByMarkingRefInventTransOrigin(InventTransOriginId _inventTransOriginId)
    {
        InventTrans inventTrans;
        select firstonly ProjId from inventTrans 
            where inventTrans.MarkingRefInventTransOrigin == _inventTransOriginId;
        return inventTrans.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costValueSecCur_RU</Name>
				<Source><![CDATA[
    public display CostAmountValueSecCur_RU costValueSecCur_RU()
    {
        CostAmountValueSecCur_RU costAmountValueSecCur;
         
        if (this.CostAmountSecCurPosted_RU == 0.0 && this.CostAmountSecCurAdjustment_RU == 0.0)
        {
            costAmountValueSecCur = 0.0;
        }
        else
        {
            costAmountValueSecCur = CurrencyExchangeHelper::amount(this.CostAmountSecCurPosted_RU + this.CostAmountSecCurAdjustment_RU, CompanyInfoHelper::secondaryCurrency_RU());
        }

        return costAmountValueSecCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countOfSettlements</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Counts how many settlements exist for this <c>inventTrans</c> record.
    /// </summary>
    /// <returns>
    ///    The number of settlements that are part of this <c>inventTrans</c> record.
    /// </returns>

    public int64 countOfSettlements()
    {
        InventSettlement    inventSettlement;

        // Now check how many settlements are there
        select count(RecId) from inventSettlement
            where inventSettlement.TransRecId == this.RecId;

        return inventSettlement.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custInvoiceLineAmount_RU</Name>
				<Source><![CDATA[
    display AmountCur custInvoiceLineAmount_RU()
    {
        InventTransOrigin   inventTransOrigin;
        CustInvoiceTrans    custInvoiceTrans;
        CustInvoiceTrans_RU custInvoiceTrans_RU;
        AmountCur           lineAmount;

        if (this.InventTransOriginSales_RU && ! this.InventTransOriginDelivery_RU)
        {
            select firstonly SalesPrice from custInvoiceTrans
                exists join custInvoiceTrans_RU
                    where custInvoiceTrans_RU.CustInvoiceTrans == custInvoiceTrans.RecId
                exists join inventTransOrigin
                    where inventTransOrigin.InventTransId == custInvoiceTrans_RU.InventTransIdDelivery_RU &&
                        inventTransOrigin.RecId == this.InventTransOrigin;

            lineAmount = - this.Qty * custInvoiceTrans.SalesPrice;
        }
        else
        {
            lineAmount = - this.Qty * SalesLine::findInventTransId(this.inventTransOrigin().InventTransId).SalesPrice;
        }

        return lineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    public void delete(
        NoYes   _dropInventOnHand= NoYes::No,
        NoYes   _deleteOriginIfPossible = NoYes::Yes)
    {
        InventSum           inventSum;
        InventSettlement    inventSettlement;
        InventTrans         inventTrans;
        // <GEERU>
        // </GEERU>

        ttsbegin;

        this.setStatusDate();
        this.setClosedOpen();
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.setClosedOpenSecCur_RU();
            TransLink_RU::remove(tableNum(InventTrans), this.RecId);
        }
        // </GEERU>

        super();

        if (this.isUpdatedFinancial())
        {
            delete_from inventSettlement
                where inventSettlement.TransRecId       == this.RecId
                   && inventSettlement.ItemId           == this.ItemId;
        }

        if (! _dropInventOnHand)
        {
            if (InventSum::mustInventTransBeUpdated(this))
            {
                inventSum.initFromInventTrans(this);
                inventSum.updateInventTrans(this, NoYes::No);
            }
            else if (InventSum::mustInventTransBeLogUpdated(this))
            {
                InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().addInventSumLogTTS(this, NoYes::No, false, true);
            }
            this.deleteReturnTransOrigin();
        }

        if (_deleteOriginIfPossible)
        {
            // delete origin record if there is no more transactions with this InventTransOrigin
            select firstonly RecId from inventTrans where inventTrans.InventTransOrigin == this.InventTransOrigin;
            if (!inventTrans.RecId) // there is NO more records with this InventTransOrigin
            {
                // delete corresponding inventory transaction origin
                this.inventTransOrigin(true).delete(NoYes::No); // transactions are already deleted
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInvalidMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes invalid marking by clearing the <c>MarkingRefInventTransOrigin</c> field for the current <c>InventTrans</c> record and for one or more marked <c>InventTrans</c> records.
    /// </summary>
    /// <param name = "_sourceDocumentMovement">
    ///  The source document movement.
    /// </param>
    /// <returns>
    /// A real value that holds the quantity that was unmarked.
    /// </returns>
    /// <remarks>
    /// A marking is invalid when the financial inventory dimensions are different between the current <c>InventTrans</c> record and the marked <c>InventTrans</c> record.
    /// </remarks>
    public InventQty deleteInvalidMarking(InventMovement _sourceDocumentMovement = null)
    {
        InventTransOrigin               inventTransOrigin;
        InventTrans                     inventTrans;
        InventDimGroupSetup             inventDimGroupSetup = InventDimGroupSetup::newItemId(this.ItemId);
        InventDim                       inventDimFrom       = this.inventDim();
        InventQty                       unmarkQty;
        InventMovement                  movement;

        PdsCWInventQty      cwUnmarkQty;
        InventQty           addQty;
        PdsCWInventQty      cwAddQty;

        container unmarkTrans(InventTrans _inventTrans, InventQty _unmarkQty, InventQty _maxUnmarkQty, PdsCWInventQty _cwMaxUnmarkQty)
        {
            if (abs(_maxUnmarkQty) < abs(_unmarkQty) && (abs(_inventTrans.Qty) - abs(_maxUnmarkQty)) >0  && _maxUnmarkQty ) // split
            {
                _inventTrans.updateSplit(_inventTrans.Qty > 0 ? abs(_maxUnmarkQty) : - abs(_maxUnmarkQty), _inventTrans.Qty > 0 ? abs(_cwMaxUnmarkQty) : -abs(_cwMaxUnmarkQty));
            }

            if (! movement || movement.inventTransOriginId() != _inventTrans.InventTransOrigin)
            {
                movement = _inventTrans.inventMovement(true);
            }

            if (movement && movement.markingRefInventTransOrigin() == _inventTrans.MarkingRefInventTransOrigin)
            {
                movement.clearInventRefFields();
            }

            _inventTrans.clearMarking();
            _inventTrans.update();

            _inventTrans.updateSumUp();

            return [abs(_inventTrans.Qty), this.PdsCWQty];
        }

        ttsbegin;

        while select TableId from inventTransOrigin
            where inventTransOrigin.RecId                       == this.MarkingRefInventTransOrigin
               && inventTransOrigin.ReferenceId
            join forupdate inventTrans
                where inventTrans.InventTransOrigin             == inventTransOrigin.RecId
                   && inventTrans.ValueOpen                     == InventTransOpen::Yes
                   && inventTrans.MarkingRefInventTransOrigin   == this.InventTransOrigin
        {
            if (inventTrans.financialOpenQty() != inventTrans.Qty)
            {
                inventTrans.updateSplit(inventTrans.financialOpenQty());
                inventTrans.update();
            }

            if (! InventDim::isInventDimEqualFinancialDim(inventDimGroupSetup, inventDimFrom ,inventTrans.inventDim()))
            {
                [addQty,cwAddQty] = unmarkTrans(inventTrans,
                                                inventTrans.Qty,
                                                abs(this.Qty)-unmarkQty,
                                                abs(this.PdsCWQty) - cwUnmarkQty);
                unmarkQty += addQty;
                cwUnmarkQty += cwAddQty;
            }
        }

        if (unmarkQty)
        {
            // Don't create new movement to avoid update conflict issue.
            movement = _sourceDocumentMovement;

            this.selectForUpdate(true);
            unmarkTrans(this, unmarkQty, this.Qty, this.PdsCWQty);
        }

        ttscommit;

        return unmarkQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteReturnTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Matches inventory transactions for return orders removing the <c>ReturnInventTransOrigin</c> field.
    /// </summary>
    /// <param name="_orderedOnly">
    ///    A Boolean parameter indicating whether to filtered only by <c>StatusReceipt::Ordered</c>; optional.
    /// </param>
    /// <remarks>
    ///    Note that we count remaining quantity in catch weight units if item is catch weight;
    ///    otherwise, in inventory quantity.
    ///    If a transaction partially fulfills the returned order, it will be split to match it exactly.
    ///    A transaction sum up is triggered as well.
    ///    This method is closely related to insertReturnTransOrigin.
    /// </remarks>
    public void deleteReturnTransOrigin(boolean _orderedOnly = true)
    {
        if (this.ReturnInventTransOrigin &&
            (this.statusReceiptAllowReturnOriginUpdate(_orderedOnly) || !_orderedOnly))
        {
            InventQty qtyRemain = this.Qty;
            PdsCWInventQty cwQtyRemain = this.PdsCWQty;
            boolean isCWItem = PdsGlobal::pdsIsCWItem(this.ItemId);

            // If there is nothing remaining to adjust, return.
            // Note that we count in CW units if item is CW, otherwise in qty
            if (isCWItem ? !cwQtyRemain : !qtyRemain)
            {
                return;
            }
            boolean isRussian = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
            
            Query query = this.buildDeleteReturnTransOriginQuery();
            QueryRun queryRun = new QueryRun(query);

            while (queryRun.next())
            {
                InventTrans inventTransReturn = queryRun.get(tableNum(InventTrans));

                if (isCWItem ? abs(inventTransReturn.PdsCWQty) > abs(cwQtyRemain) : abs(inventTransReturn.Qty) > abs(qtyRemain))
                {
                    InventSplitTrans splitTrans = new InventSplitTrans();
                    // <GEERU>
                    if (isRussian)
                    {
                        splitTrans.parmSplitLink_RU(true);
                        splitTrans.parmSplitOnlyReversalLink_RU(true);
                    }
                    // </GEERU>
                    splitTrans.update(inventTransReturn, -qtyRemain, -cwQtyRemain);
                }

                inventTransReturn.ReturnInventTransOrigin = 0;
                inventTransReturn.doUpdate();

                qtyRemain += inventTransReturn.Qty;
                cwQtyRemain += inventTransReturn.PdsCWQty;

                inventTransReturn.updateSumUp();

                if (isCWItem ? !cwQtyRemain : !qtyRemain)
                {
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDeleteReturnTransOriginQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for deleting inventory transactions for return orders.
    /// </summary>
    /// <returns>The query.</returns>
    protected Query buildDeleteReturnTransOriginQuery()
    {
        Query query = new Query();
        
        QueryBuildDataSource qbds = query.addDataSource(tableNum(InventTrans));
        qbds.update(true);
        qbds.addRange(fieldNum(InventTrans, InventTransOrigin)).value(queryValue(this.ReturnInventTransOrigin));
        qbds.addRange(fieldNum(InventTrans, ReturnInventTransOrigin)).value(queryValue(this.InventTransOrigin));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensionFinancialDefaultDimension</Name>
				<Source><![CDATA[
    public display DimensionDefault dimensionFinancialDefaultDimension()
    {
        return this.inventTransPostingFinancial().DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensionFinancialLedgerDimension</Name>
				<Source><![CDATA[
    public display LedgerDimensionDefaultAccount dimensionFinancialLedgerDimension()
    {
        return this.inventTransPostingFinancial().LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensionPhysicalDefaultDimension</Name>
				<Source><![CDATA[
    public display DimensionDefault dimensionPhysicalDefaultDimension()
    {
        return this.inventTransPostingPhysical().DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>direction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an <c>InventDirection</c> enumeration value
    /// </summary>
    /// <returns>
    ///    The <c>InventDirection</c> enumeration value.
    /// </returns>
    public display InventDirection direction()
    {
        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (countryRegion_RU && this.isInventTransferIssue_RU(this.inventTransOrigin()))
            return  InventDirection::Issue;
        // </GEERU>

        // optimized for performance, according to the frequency occurrence order: Issue\Receipt\None(should never happen)
        return  this.Qty   < 0 ? InventDirection::Issue     :
                       (this.Qty   >  0 ? InventDirection::Receipt  : InventDirection::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumUpTryDeleteBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified inventory transaction must be deleted.
    /// </summary>
    /// <param name = "_bufferToDelete">The inventory transaction to check.</param>
    /// <param name = "_deletedTrans">The collection of deleted inventory transactions.</param>
    /// <returns>true if the specified inventory transaction must be deleted; otherwise; false.</returns>
    protected boolean sumUpTryDeleteBuffer(InventTrans _bufferToDelete, Set _deletedTrans)
    {
        boolean ret;

        if (this.setSumAmount(_bufferToDelete))
        {
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                TransLink_RU::merge(_bufferToDelete, this);
            }
            // </GEERU>

            // Keep track of deleted transactions, so the consumer can avoid
            // processing these.
            if (_deletedTrans)
            {
                _deletedTrans.add(_bufferToDelete.RecId);
            }
            _bufferToDelete.delete(NoYes::Yes, NoYes::No);
            ret = true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discAmount</Name>
				<Source><![CDATA[
    [SysObsolete('To achieve better performance InventTransReference should be instantiated locally from consumer', false, 31\01\2016)]
    public display UnitDiscountAmountCur discAmount()
    {
        return InventTransReference::newFromInventTrans(this).discAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>discPercent</Name>
				<Source><![CDATA[
    [SysObsolete('To achieve better performance InventTransReference should be instantiated locally from consumer', false, 31\01\2016)]
    public display Percent discPercent()
    {
        return InventTransReference::newFromInventTrans(this).discPercent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialOpenQty</Name>
				<Source><![CDATA[
    public InventQty   financialOpenQty()
    {
        return (this.ValueOpen != InventTransOpen::No?
               (abs(this.Qty   - this.QtySettled) < InventAdj::settleQtyDiff() ? 0
                                                                    : decRound((this.Qty   - this.QtySettled),InventAdj::settleQtyDec()))
                                                                    : 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialOpenQtySecCur_RU</Name>
				<Source><![CDATA[
    public InventQty financialOpenQtySecCur_RU()
    {
        return this.ValueOpenSecCur_RU == InventTransOpen::No ? 0 :
               abs(this.Qty - this.QtySettledSecCur_RU) < InventAdj::settleQtyDiff() ? 0 :
                   decRound((this.Qty - this.QtySettledSecCur_RU), InventAdj::settleQtyDec());
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialOpenValue</Name>
				<Source><![CDATA[
    public CostAmount financialOpenValue()
    {
        return CurrencyExchangeHelper::amount(this.CostAmountPosted + this.CostAmountAdjustment - this.CostAmountSettled);
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialOpenValueSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmountSecCur_RU financialOpenValueSecCur_RU()
    {
        return CurrencyExchangeHelper::amount(this.CostAmountSecCurPosted_RU + this.CostAmountSecCurAdjustment_RU - this.CostAmountSettledSecCur_RU);
    }

]]></Source>
			</Method>
			<Method>
				<Name>forceDeleteReturnTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Matches inventory transactions for return orders removing the <c>ReturnInventTransOrigin</c> field.
    /// </summary>
    /// <remarks>
    ///    Note that we count remaining quantity in catch weight units if item is catch weight;
    ///    otherwise, in inventory quantity.
    ///    If a transaction partially fulfills the returned order, it will be split to match it exactly.
    ///    A transaction sum up is triggered as well.
    /// </remarks>
    public void forceDeleteReturnTransOrigin()
    {
        this.deleteReturnTransOrigin(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionFromDefaultAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Wraps the <c>LedgerDimensionFacade::serviceCreateLedgerDimension</c> method.
    /// </summary>
    /// <param name="_defaultAccount">
    /// The ID of the <c>DimensionAttributeValueCombination</c> record that represents the default account.
    /// </param>
    /// <param name="_defaultDimension">
    /// The ID of a default dimension set to use; optional.
    /// </param>
    /// <returns>
    /// The ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </returns>
    /// <remarks>
    /// Calling this method with empty default account will not throw an exception.
    /// </remarks>
    private LedgerDimensionAccount getLedgerDimensionFromDefaultAccount(
        LedgerDimensionDefaultAccount   _defaultAccount,
        DimensionDefault                _defaultDimension = 0)
    {
        if (!_defaultAccount)
        {
            return 0;
        }

        return LedgerDimensionFacade::serviceCreateLedgerDimension(_defaultAccount, _defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasSettlements</Name>
				<Source><![CDATA[
    public boolean hasSettlements()
    {
        return (select firstonly RecId from inventSettlement
                    where inventSettlement.TransRecId       == this.RecId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUnpostedInvoices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether any unposted invoices exist for the current record.
    /// </summary>
    /// <returns>
    /// A <c>HasUnpostedInvoices::Yes</c> enumeration value if an unposted invoice exists for this
    /// inventory transaction; otherwise, a <c>HasUnpostedInvoices::No</c> enumeration value.
    /// </returns>
    /// <remarks>
    /// This method includes unposted invoices saved in batches or being edited and those saved as pending.
    /// </remarks>
    public display HasUnpostedInvoicesId hasUnpostedInvoices()
    {
        HasUnpostedInvoicesId hasUnpostedInvoices;

        if (this.unpostedInvoiceId() == '')
        {
            hasUnpostedInvoices = HasUnpostedInvoices::No;
        }
        else
        {
            hasUnpostedInvoices = HasUnpostedInvoices::Yes;
        }

        return hasUnpostedInvoices;
    }

]]></Source>
			</Method>
			<Method>
				<Name>infoActionInventTrans</Name>
				<Source><![CDATA[
    public SysInfoAction_FormrunQuery infoActionInventTrans(Query  _query = null)
    {
        SysInfoAction_FormrunQuery  infoAction;
        QueryBuildDataSource        queryBuildDataSource;

        if (!_query)
        {
            _query = new Query();
            _query.addDataSource(tableNum(InventTrans));
            queryBuildDataSource = _query.dataSourceTable(tableNum(InventTrans));
            queryBuildDataSource.addRange(fieldNum(InventTrans,InventTransOrigin)).value(queryValue(this.InventTransOrigin));

            queryBuildDataSource.addDataSource(tableNum(InventDim));
            queryBuildDataSource = _query.dataSourceTable(tableNum(InventDim));
            queryBuildDataSource.joinMode(JoinMode::InnerJoin);
            queryBuildDataSource.addLink(fieldNum(InventTrans, InventDimId),fieldNum(InventDim,InventDimId));
        }

        infoAction = SysInfoAction_FormrunQuery::newFormnameQuery(formStr(InventTrans), _query);

        return  infoAction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>infoActionOrigin</Name>
				<Source><![CDATA[
    public SysInfoAction_Formrun infoActionOrigin()
    {
        SysInfoAction_Formrun   infoAction;
        InventTransOrigin       inventTransOrigin = this.inventTransOrigin();

        switch (inventTransOrigin.ReferenceCategory)
        {
            case InventTransType::InventLossProfit  ,
                 InventTransType::InventCounting    ,
                 InventTransType::InventTransfer    ,
                 InventTransType::InventTransaction ,
                 InventTransType::BOMMain           ,
                 InventTransType::BOMLine           ,
                 InventTransType::Project           :
                    infoAction = SysInfoAction_Formrun::newFormname(formStr(InventJournalTable));
                infoAction.parmCallerBuffer(InventJournalTable::find(inventTransOrigin.ReferenceId));
                return infoAction;
            case InventTransType::ProdLine          ,
                 InventTransType::Production
                 ,
                 InventTransType::PmfProdCoBy
                 :
                    infoAction = SysInfoAction_Formrun::newFormname(formStr(ProdTable));
                infoAction.parmCallerBuffer(ProdTable::find(inventTransOrigin.ReferenceId));
                return infoAction;
            case InventTransType::Sales:
                infoAction = SysInfoAction_Formrun::newFormname(formStr(SalesTable));
                infoAction.parmCallerBuffer(SalesTable::find(inventTransOrigin.ReferenceId));
                return infoAction;
            case InventTransType::Purch:
                infoAction = SysInfoAction_Formrun::newFormname(formStr(PurchTable));
                infoAction.parmCallerBuffer(PurchTable::find(inventTransOrigin.ReferenceId));
                return infoAction;
            case InventTransType::QuarantineOrder:
                infoAction = SysInfoAction_Formrun::newFormname(formStr(InventQuarantineOrder));
                infoAction.parmCallerBuffer(InventQuarantineOrder::find(inventTransOrigin.ReferenceId));
                return infoAction;
            case InventTransType::Statement:
                if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                {
                    infoAction = SysInfoAction_Formrun::newFormname(formStr(RetailStatementJour));
                    infoAction.parmCallerBuffer(RetailStatementJour::find(inventTransOrigin.ReferenceId));
                    return infoAction;
                }
                return null;
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    public void insert(NoYes _dropInventOnHand = NoYes::No, InventDimId _inventDimIdTransferIssue = '')
    {
        InventSum           inventSum;
        // <GEERU>
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        ttsbegin;

        if (! this.InventDimId)
        {
            this.InventDimId = InventDim::inventDimIdBlank();
        }

        this.setStatusDate();
        this.setClosedOpen();
        // <GEERU>
        if (countryRegion_RU)
        {
            this.setClosedOpenSecCur_RU();
        }
        // </GEERU>

        if (!this.InventTransOrigin)
        {
            throw error("@SYS26177");
        }

        // Additional Inventory checks for WHS items.
        if (!_dropInventOnHand && WHSInventEnabled::exist(this.ItemId))
        {
            // I don't believe we will ever hit a scenario where physical change in inventory is true.
            if (!WHSInvent::checkDimensions(this, (this.direction() == InventDirection::Receipt && this.StatusReceipt <= StatusReceipt::Registered)))
            {
                throw error("@SYS18447");
            }
        }
        
        super();

        if (! _dropInventOnHand)
        {
            if (InventSum::mustInventTransBeUpdated(this))
            {
                inventSum.initFromInventTrans(this);
                inventSum.updateInventTrans(this,NoYes::Yes,null,false,NoYes::No,_inventDimIdTransferIssue);
            }
            else if (InventSum::mustInventTransBeLogUpdated(this))
            {
                InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().addInventSumLogTTS(this, NoYes::Yes, false, true);
            }
            this.insertReturnTransOrigin();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isArchivedTransaction</Name>
				<Source><![CDATA[
    private boolean isArchivedTransaction()
    {
        return this.inventTransOrigin().isArchivedTransaction();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCountryRegionEEU</Name>
				<Source><![CDATA[
    private boolean isCountryRegionEEU()
    {
        return SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoPL, #isoHU, #isoCZ, #isoLT, #isoLV, #isoEE]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInsertReturnTransOriginQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for matching inventory transactions for return orders.
    /// </summary>
    /// <returns>The query.</returns>
    protected Query buildInsertReturnTransOriginQuery()
    {
        Query query = new Query();
        
        QueryBuildDataSource qbds = query.addDataSource(tableNum(InventTrans));
        qbds.update(true);
        qbds.addRange(fieldNum(InventTrans, InventTransOrigin)).value(queryValue(this.ReturnInventTransOrigin));
        qbds.addRange(fieldNum(InventTrans, StatusIssue)).value(queryValue(StatusIssue::Sold));
        qbds.addRange(fieldNum(InventTrans, StatusReceipt)).value(queryValue(StatusReceipt::None));
        qbds.addRange(fieldNum(InventTrans, ReturnInventTransOrigin)).value(SysQuery::valueEmptyString());

        if (this.ProjId && this.inventTransOrigin().ReferenceCategory == InventTransType::Project)
        {
            str cacheKey = strFmt(ProjConstants::twoParmCacheKeyConst, this.ProjId, this.ReturnInventTransOrigin);
            if (SysTransactionScopeCache::isSet(classStr(ProjAdjustmentUpdate_Post), cacheKey))
            {
                ProjAdjustRefId projAdjRefId =  SysTransactionScopeCache::get(classStr(ProjAdjustmentUpdate_Post), cacheKey);
                if (projAdjRefId)
                {
                    qbds.addRange(fieldNum(InventTrans, ProjAdjustRefId)).value(projAdjRefId);
                }
            }
        }
        
        if (this.InvoiceId && this.isCountryRegionEEU())
        {
            qbds.addRange(fieldNum(InventTrans, InvoiceId)).value(queryValue(this.InvoiceId));
        }
        else
        {
            SalesFindSalesCopyInventTransByInvoiceIdContext context = SalesFindSalesCopyInventTransByInvoiceIdContext::current();
            if (context
                && context.parmInvoiceId()
                && SalesFindSalesCopyInventTransByInvoiceIdFlight::instance().isEnabled())
            {
                qbds.addRange(fieldNum(InventTrans, InvoiceId)).value(queryValue(context.parmInvoiceId()));
            }
        }

        // <GEERU>
        if (this.isGoodsInRouteTransit_RU())
        {
            qbds.addRange(fieldNum(InventTrans, InventTransOriginTransit_RU)).value(queryValue(this.InventTransOrigin));
        }
        // </GEERU>

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReturnTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Matches inventory transactions for return orders filling the <c>ReturnInventTransOrigin</c> field.
    /// </summary>
    /// <remarks>
    ///    Note that we count remaining quantity in catch weight units if item is catch weight;
    ///    otherwise, in inventory quantity.
    ///    If a transaction partially fulfills the returned order, it will be split to match it exactly.
    ///    This method is closely related to deleteReturnTransOrigin.
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///    An exception is raised if the item ID in the inventory transaction being matched is not the same as
    ///    the item in the current transaction.
    /// </exception>
    /// <exception cref="Exception::Error">
    ///    An exception is raised if the inventory dimensions in the inventory transaction being matched are not
    ///    the same as the inventory dimensions in the current transaction.
    /// </exception>
    /// <exception cref="Exception::Error">
    ///    An exception is raised if not all the required quantity could be matched to existing inventory transactions.
    /// </exception>
    public void insertReturnTransOrigin()
    {
        InventQty qtyRemain;
        PdsCWInventQty cwQtyRemain;
        boolean isCWItem;

        void split(InventTrans _inventTransReturn)
        {
            // Split transactions if there is more quantity returned than in the order (in CW it is measured in CW units)
            if (isCWItem ? abs(_inventTransReturn.PdsCWQty) > abs(cwQtyRemain) : abs(_inventTransReturn.Qty) > abs(qtyRemain))
            {
                InventSplitTrans splitTrans = new InventSplitTrans();
                splitTrans.update(_inventTransReturn, -qtyRemain, -cwQtyRemain);
            }

            _inventTransReturn.ReturnInventTransOrigin = this.InventTransOrigin;
            _inventTransReturn.doUpdate();

            qtyRemain += _inventTransReturn.Qty;
            cwQtyRemain += _inventTransReturn.PdsCWQty;
        }

        if (this.ReturnInventTransOrigin && this.statusReceiptAllowReturnOriginUpdate(false))
        {
            var logger = InventInstrumentationLogger::CreateLogger(tableStr(InventTrans));
            using (var activityContext = logger.inventTrans().insertReturnTransOrigin())
            {
                logger.inventTrans().inventTransRecId(activityContext, this.RecId);
                qtyRemain = this.Qty;
                cwQtyRemain = this.PdsCWQty;
                isCWItem = PdsGlobal::pdsIsCWItem(this.ItemId);

				// If there is nothing remaining to adjust, return.
				// Note that we count in CW units if item is CW, otherwise in qty
				if (isCWItem ? !cwQtyRemain : !qtyRemain)
				{
					return;
				}

				Query query = this.buildInsertReturnTransOriginQuery();
				QueryRun queryRun = new QueryRun(query);

                if (WMSJournalTransInventDimContext::current())
                {
                    InventDim wmsJournalTransInventDim = WMSJournalTransInventDimContext::current().parmWMSJournalTransInventDim();
                    List inventTransList = new List(Types::Record);

                    this.buildReturnTransListWithFinDimCheck(queryRun, wmsJournalTransInventDim, inventTransList);

                    ListEnumerator listEnumerator = inventTransList.getEnumerator();
                    while (listEnumerator.moveNext())
                    {
                        InventTrans inventTransReturn = listEnumerator.current();
                        split(inventTransReturn);

                        if (isCWItem ? !cwQtyRemain : !qtyRemain)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    boolean checkActiveFinDim = false;

                    InventDimParm inventDimParmFinancial;
                    InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(this.ItemId);
                    inventDimGroupSetup.inventDimParmActiveFinancialInventory(inventDimParmFinancial);
                    checkActiveFinDim = inventDimParmFinancial.anyTrackingDimensionFlagSet();
                    
                    if (checkActiveFinDim)
                    {
                        List inventTransList = new List(Types::Record);

                        this.buildReturnTransListWithFinDimCheck(queryRun, InventDim::find(this.inventDimId), inventTransList);
                        ListEnumerator listEnumerator = inventTransList.getEnumerator();
                        while (listEnumerator.moveNext())
                        {
                            InventTrans inventTransReturn = listEnumerator.current();
                            split(inventTransReturn);

                            if (isCWItem ? !cwQtyRemain : !qtyRemain)
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        while (queryRun.next())
                        {
                            InventTrans inventTransReturn = queryRun.get(tableNum(InventTrans));
                            this.validate(inventTransReturn);
                            split(inventTransReturn);

                            if (isCWItem ? !cwQtyRemain : !qtyRemain)
                            {
                                break;
                            }
                        }
                    }
                }

				if (this.isExcessQuantityReturned(isCWItem, qtyRemain, cwQtyRemain))
				{
					throw error("@SYS53004");
				}
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReturnTransListWithFinDimCheck</Name>
				<Source><![CDATA[
    private void buildReturnTransListWithFinDimCheck(QueryRun _queryRun, InventDim _currInventDim, List _inventTransList)
    {
        InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(this.ItemId);
        while (_queryRun.next())
        {
            InventTrans inventTransReturn = _queryRun.get(tableNum(InventTrans));
            this.validate(inventTransReturn);
            if (InventDim::isInventDimEqualFinancialDim(inventDimGroupSetup, _currInventDim, inventTransReturn.inventDim()))
            {
                _inventTransList.addStart(inventTransReturn);
            }
            else
            {
                _inventTransList.addEnd(inventTransReturn);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    private void validate(InventTrans _inventTransReturn)
    {
        if (_inventTransReturn.ItemId != this.ItemId)
        {
            throw error("@SYS53014");
        }

        if (!InventDim::isInventDimEqualProductDim(EcoResProductDimGroupSetup::newItemId(this.ItemId), this.inventDim(), _inventTransReturn.inventDim()))
        {
            throw error("@SYS69874");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExcessQuantityReturned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether more quantity is returned than covered by return lot.
    /// </summary>
    /// <param name = "_isCatchWeightItem">Boolean value indicating whether item is a catch weight item.</param>
    /// <param name = "_remainingInventoryQuantity">Remaining inventory quantity.</param>
    /// <param name = "_remainingCatchWeightQuantity">Remaining catch weight quantity.</param>
    /// <returns>true if more quantity is returned than covered by return lot; otherwise, false.</returns>
    protected boolean isExcessQuantityReturned(boolean _isCatchWeightItem, InventQty _remainingInventoryQuantity, PdsCWInventQty _remainingCatchWeightQuantity)
    {
        return _isCatchWeightItem ? _remainingCatchWeightQuantity != 0 : _remainingInventoryQuantity != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventBatchId</Name>
				<Source><![CDATA[
    public display InventBatchId inventBatchId()
    {
        return InventDim::find(this.InventDimId).InventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    public InventDim inventDim()
    {
        return InventDim::find(this.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventJournalTrans</Name>
				<Source><![CDATA[
    public InventJournalTrans inventJournalTrans(boolean _forUpdate = false)
    {
        InventJournalTrans  inventJournalTrans;
        InventTransOrigin   inventTransOrigin   = this.inventTransOrigin();

        if (WHSMoveInventTransOriginRefCategoryCheck::instance().isEnabled())
        {
            if (!inventTransOrigin.isReferenceCategoryFromInventJournal())
            {
                throw error(strFmt("@SYS22828",funcName()));
            }
        }
        else
        {
            if ((inventTransOrigin.ReferenceCategory != InventTransType::InventTransaction) &&
                (inventTransOrigin.ReferenceCategory != InventTransType::InventTransfer)    &&
                (inventTransOrigin.ReferenceCategory != InventTransType::Project)           &&
                (inventTransOrigin.ReferenceCategory != InventTransType::Asset)             &&
                (inventTransOrigin.ReferenceCategory != InventTransType::BOMLine)           &&
                (inventTransOrigin.ReferenceCategory != InventTransType::BOMMain)           &&
                (inventTransOrigin.ReferenceCategory != InventTransType::InventCounting)    &&
                (inventTransOrigin.ReferenceCategory != InventTransType::InventLossProfit))
            {
                throw error(strFmt("@SYS22828",funcName()));
            }
        }

        if (inventTransOrigin.ReferenceCategory == InventTransType::InventTransfer && this.Qty > 0)
        {
            inventJournalTrans = InventTransOriginJournalTransReceipt::inventJournalTrans(inventTransOrigin.RecId, _forUpdate);
            if (inventJournalTrans.RecId)
            {
                return inventJournalTrans;
            }
        }

        return InventTransOriginJournalTrans::inventJournalTrans(inventTransOrigin.RecId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLocationId</Name>
				<Source><![CDATA[
    public display InventLocationId inventLocationId()
    {
        return InventDim::find(this.InventDimId).InventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructingInventMovementFromInventTransEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instances of a <c>InventMovement</c> class based on a <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">The inventTrans.</param>
    /// <param name = "_noThrow">A Boolean value indicating if constructors can throw exceptions in case of errors.</param>
    /// <param name = "_result">A <c>EventHandlerResult</c> containing the instantiated class.</param>
    [SubscribesTo(tableStr(InventTrans), delegateStr(InventTrans, constructingInventMovementFromInventTrans))]
    public static void constructingInventMovementFromInventTransEventHandler(InventTrans _inventTrans, boolean _noThrow, EventHandlerResult _result)
    {
        InventDirection direction = _inventTrans.direction();
        InventTransOrigin inventTransOrigin = _inventTrans.inventTransOrigin();

        switch (inventTransOrigin.ReferenceCategory)
        {
            case InventTransType::Sales:
            case InventTransType::Production:
            case InventTransType::PmfProdCoBy:
            case InventTransType::InventLossProfit:
            case InventTransType::InventTransfer:
            case InventTransType::ProdLine:
            case InventTransType::BOMLine:
            case InventTransType::BOMMain:
            case InventTransType::WMSOrder:
            case InventTransType::Project:
            case InventTransType::InventCounting:
            case InventTransType::WMSTransport:
            case InventTransType::QuarantineOrder:
            case InventTransType::Asset:
            case InventTransType::TransferOrderShip:
            case InventTransType::TransferOrderReceive:
            case InventTransType::TransferOrderScrap:
            case InventTransType::SalesQuotation:
            case InventTransType::QualityOrder:
            case InventTransType::Blocking:
            case InventTransType::KanbanJobProcess:
            case InventTransType::KanbanJobTransferReceipt:
            case InventTransType::KanbanJobPickingList:
            case InventTransType::KanbanJobWIP:
            case InventTransType::KanbanEmptied:
            case InventTransType::KanbanJobTransferIssue:
            case InventTransType::WHSWork:
            case InventTransType::WHSContainer:
            case InventTransType::WHSQuarantine:
            case InventTransType::ProdRelease_RU:
            case InventTransType::ConsignmentReplenishmentOrder:
            case InventTransType::WHSOrderCommittedReservation:
                _result.result(inventTransOrigin.inventMovement(direction,  _noThrow));
                break;

            case InventTransType::Statement:
                if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                {
                    _result.result(inventTransOrigin.inventMovement(direction,  _noThrow));
                }
                else
                {
                    _result.result(null);
                }
                break;

            case InventTransType::Purch:
                if (_inventTrans.StatusReceipt == StatusReceipt::QuotationReceipt)
                {
                    PurchRFQCaseLine purchRFQCaseLine = InventTransOriginPurchRFQCaseLine::purchRFQCaseLine(inventTransOrigin.RecId,true);

                    if (purchRFQCaseLine.RecId)
                    {
                        _result.result(InventMovement::constructNoThrow(purchRFQCaseLine));
                    }
                    else
                    {
                        _result.result(InventMovement::constructNoThrow(InventTransOriginPurchRFQLine::purchRFQLine(inventTransOrigin.RecId,true)));
                    }
                }
                else
                {
                    var movement = inventTransOrigin.inventMovement(direction);
                    movement.parmMCRInventTransRecid(_inventTrans.RecId);
                    _result.result(movement);
                }
                break;

            case InventTransType::InventTransaction:
                if (!inventTransOrigin.ReferenceId)
                {
                    _result.result(InventMovement::constructNoThrow(_inventTrans));
                }
                else
                {
                    _result.result(inventTransOrigin.inventMovement(direction));
                }
                break;

            case InventTransType::SummedUp:
                _result.result(InventMovement::constructNoThrow(_inventTrans));
                break;

            case InventTransType::InventTransArchive:
            case InventTransType::WHSInventTransArchiveOnlyAffectsLocationAndBelow:
                _result.result(InventMovement::constructNoThrow(_inventTrans));
                break;

                // <GEERU>
            case InventTransType::FixedAssets_RU:
                _result.result(InventMovement::constructNoThrow(InventTransOriginRAssetScrap_RU::rassetScrap(inventTransOrigin.RecId, true)));
                break;
            // </GEERU>

            // <GJP>
            case InventTransType::Assembling_JP:
                _result.result(InventMovement::constructNoThrow(InventTransOriginAssetComponent_JP::assetComponent(inventTransOrigin.RecId, true)));
                break;
            // </GJP>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructingInventMovementFromInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for creating a new instances of a <c>InventMovement</c> class based on a <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">The inventTrans.</param>
    /// <param name = "_noThrow">A Boolean value indicating if constructors can throw exceptions in case of errors.</param>
    /// <param name = "_result">A <c>EventHandlerResult</c> containing the instantiated class.</param>
    delegate void constructingInventMovementFromInventTrans(InventTrans _inventTrans, boolean _noThrow, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventMovement</Name>
				<Source><![CDATA[
    public InventMovement inventMovement(boolean _noThrow = false)
    {
        EventHandlerResult result = EventHandlerResult::newSingleResponse();
        this.constructingInventMovementFromInventTrans(this, _noThrow, result);

        if (!result.hasResult())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        InventMovement movement = result.result() as InventMovement;

        if (movement && (movement.buffer().RecId || movement.isVirtuel()))
        {
            return movement;
        }

        if (!_noThrow)
        {
            throw(error(strFmt("@SYS19306", funcName())));
        }
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventMovementChild</Name>
				<Source><![CDATA[
    public InventMovement inventMovementChild()
    {
        if (this.TransChildType)
        {
            var childReference = InventTransChildReference::newFromInventTrans(this);

            if (childReference.canInstantiateIssueChildMovement())
            {
                return childReference.instantiateIssueChildMovement();
            }
        }

        return this.inventMovement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSerialId</Name>
				<Source><![CDATA[
    public display InventSerialId inventSerialId()
    {
        return InventDim::find(this.InventDimId).InventSerialId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    public InventTable inventTable(boolean _forUpdate = false)
    {
        return InventTable::find(this.ItemId,_forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransferLine</Name>
				<Source><![CDATA[
    public InventTransferLine inventTransferLine(boolean _forUpdate = false)
    {
        InventTransferLine  inventTransferLine;
        InventTransOrigin   inventTransOrigin   = this.inventTransOrigin();

        switch (inventTransOrigin.ReferenceCategory)
        {
            case InventTransType::TransferOrderShip:
                // <GEERU>
                if (! this.isInventTransferIssue_RU(inventTransOrigin))
                // </GEERU>

                {
                    inventTransferLine = InventTransferLine::findTransIdTransitTo(inventTransOrigin.InventTransId, _forUpdate);
                    if (inventTransferLine.RecId)
                    {
                        return inventTransferLine;
                    }
                }

                return InventTransferLine::findTransIdShip(inventTransOrigin.InventTransId, _forUpdate);

            case InventTransType::TransferOrderReceive:
                // <GEERU>
                if (this.isInventTransferIssue_RU(inventTransOrigin))
                // </GEERU>
                {
                    inventTransferLine = InventTransferLine::findTransIdTransitFrom(inventTransOrigin.InventTransId, _forUpdate);
                    if (inventTransferLine.RecId)
                    {
                        return inventTransferLine;
                    }
                }

                return InventTransferLine::findTransIdReceive(inventTransOrigin.InventTransId, _forUpdate);

            case InventTransType::TransferOrderScrap:
                return InventTransferLine::findTransIdScrap(inventTransOrigin.InventTransId, _forUpdate);
        }

        throw error("@SYS78885");
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the originator of the inventory transaction.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    The originator of the inventory transaction.
    /// </returns>
    public InventTransOrigin inventTransOrigin(boolean _forUpdate = false)
    {
        return InventTransOrigin::find(this.InventTransOrigin, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransPostingFinancial</Name>
				<Source><![CDATA[
    public InventTransPosting inventTransPostingFinancial()
    {
        InventTransPosting inventTransPosting;

        if (this.DateFinancial && this.Voucher)
        {
            return InventTransPosting::findByNaturalKey(this.initializeFinancialInventTransPostingSearchParameters());
        }

        return inventTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransPostingPhysical</Name>
				<Source><![CDATA[
    public InventTransPosting inventTransPostingPhysical()
    {
        InventTransPosting inventTransPosting;

        if (this.DatePhysical && this.VoucherPhysical)
        {
            return InventTransPosting::findByNaturalKey(this.initializePhysicalInventTransPostingSearchParameters(InventTransPostingType::Physical));
        }

        return inventTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransPostingPhysicalCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>InventTransPosting</c> for the physical charge posting.
    /// </summary>
    /// <returns>
    /// The <c>InventTransPosting</c> for the physical charge posting.
    /// </returns>
    /// <remarks>
    /// If the <c>InventTransPosting</c> for the physical charge posting does not exist an empty record is returned.
    /// </remarks>
    public InventTransPosting inventTransPostingPhysicalCharge()
    {
        InventTransPosting inventTransPosting;

        if (this.DatePhysical && this.VoucherPhysical)
        {
            return InventTransPosting::findByNaturalKey(this.initializePhysicalInventTransPostingSearchParameters(InventTransPostingType::PhysicalCharge));
        }

        return inventTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransPostingPhysicalRevenue</Name>
				<Source><![CDATA[
    public InventTransPosting inventTransPostingPhysicalRevenue()
    {
        InventTransPosting inventTransPosting;

        if (this.DatePhysical && this.VoucherPhysical)
        {
            return InventTransPosting::findByNaturalKey(this.initializePhysicalInventTransPostingSearchParameters(InventTransPostingType::PhysicalRevenue));
        }

        return inventTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePhysicalInventTransPostingSearchParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the search parameters for finding the <c>InventTransPosting</c> table.
    /// </summary>
    /// <param name = "_inventTransPostingType">The posting type.</param>
    /// <returns>The search parameters.</returns>
    protected InventTransPosting initializePhysicalInventTransPostingSearchParameters(InventTransPostingType _inventTransPostingType)
    {
        InventTransPosting inventTransPosting;

        inventTransPosting.TransDate = this.DatePhysical;
        inventTransPosting.Voucher = this.VoucherPhysical;
        inventTransPosting.InventTransOrigin = this.InventTransOrigin;
        inventTransPosting.InventTransPostingType = _inventTransPostingType;

        return inventTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFinancialInventTransPostingSearchParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the search parameters for finding the <c>InventTransPosting</c> table.
    /// </summary>
    /// <returns>The search parameters.</returns>
    protected InventTransPosting initializeFinancialInventTransPostingSearchParameters()
    {
        InventTransPosting inventTransPosting;

        inventTransPosting.TransDate = this.DateFinancial;
        inventTransPosting.Voucher = this.Voucher;
        inventTransPosting.InventTransOrigin = this.InventTransOrigin;
        inventTransPosting.InventTransPostingType = InventTransPostingType::Financial;

        return inventTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventUnit</Name>
				<Source><![CDATA[
    public display UnitIDInventory inventUnit()
    {
        return InventTableModule::find(this.ItemId,ModuleInventPurchSales::Invent).UnitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventVendCust</Name>
				<Source><![CDATA[
    [SysObsolete('To achieve better performance InventTransReference should be instantiated locally from consumer', false, 31\01\2016)]
    public display InventVendCust inventVendCust()
    {
        return InventTransReference::newFromInventTrans(this).inventVendCust();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGoodsInRouteTransit_RU</Name>
				<Source><![CDATA[
    public boolean isGoodsInRouteTransit_RU()
    {
        InventTrans inventTrans;

        if (this.InventTransOriginSales_RU && ! this.InventTransOriginTransit_RU)
        {
            select firstonly RecId from inventTrans
                where inventTrans.InventTransOriginSales_RU   == this.InventTransOriginSales_RU
                   && inventTrans.InventTransOriginTransit_RU == this.InventTransOrigin
                   && inventTrans.StatusIssue != StatusIssue::Sold;
        }

        return inventTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIncludedInPhysicalInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the inventory transaction is included in physical on hand.
    /// </summary>
    /// <returns>
    /// true if the transaction is included in physical on hand; otherwise, false.
    /// </returns>
    public boolean isIncludedInPhysicalInventory()
    {
        return (this.StatusIssue == StatusIssue::None && this.StatusReceipt <= StatusReceipt::Registered)
            || (this.StatusReceipt == StatusReceipt::None && this.StatusIssue <= StatusIssue::Picked);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransInitialized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the specified inventory transaction is initialized.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction to check.</param>
    /// <returns>true if the specified inventory transaction is initialized; otherwise, false.</returns>
    public static boolean isInventTransInitialized(InventTrans _inventTrans)
    {
        return (_inventTrans.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransferIssue_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current inventory transaction is a transfer order issue.
    /// </summary>
    /// <param name = "_inventTransOrigin">The inventory transaction originator.</param>
    /// <returns>true, if the legal entity is not Russian and the transaction is an issue or if the legal entity is Russian and the transaction is a transfer order issue; otherwise, false.</returns>
    public boolean isInventTransferIssue_RU(InventTransOrigin _inventTransOrigin)
    {

        if (! SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
            return (this.Qty <= 0);

        switch (_inventTransOrigin.ReferenceCategory)
        {
            case InventTransType::TransferOrderScrap:
                return true;

            case InventTransType::TransferOrderShip:
                return (InventLocation::find(this.inventLocationId()).InventLocationType == InventLocationType::Standard);

            case InventTransType::TransferOrderReceive:
                return (InventLocation::find(this.inventLocationId()).InventLocationType == InventLocationType::Transit);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the current transaction the Issue transaction.
    /// </summary>
    /// <returns>
    /// true if the current transaction is the Issue transaction; otherwise, false.
    /// </returns>
    public boolean isIssue()
    {
        return InventTrans::isIssueByQty(this.Qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIssueByQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether an inventory transaction with the specified quantity is an issue transaction.
    /// </summary>
    /// <param name = "_qty">The quantity of the inventory transaction in the inventory unit.</param>
    /// <returns>
    /// true, if an inventory transaction with the specified quantity is an issue transaction; otherwise, false.
    /// </returns>
    public static boolean isIssueByQty(InventQty _qty)
    {
        return _qty < 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNonFinancialTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the inventory transaction is a non-financial transfer.
    /// </summary>
    /// <returns>
    ///    true if the transaction is a non-financial transfer; otherwise, false.
    /// </returns>
    display InventNonFinancialTransfer isNonFinancialTransfer()
    {
        InventClosingNonFinancialInventTrans inventClosingNonFinancialInventTrans;
        InventClosing inventClosing;

        if (this.NonFinancialTransferInventClosing)
        {
            return true;
        }

        // Handle transactions that were updated using InventUpd_FinancialLite
        if (this.ValueOpen  == InventTransOpen::No
            && this.Voucher == '')
        {
            return true;
        }

        select firstonly RecId, AllowCancel, InventClosing
        from inventClosingNonFinancialInventTrans
        order by InventClosing desc
        where inventClosingNonFinancialInventTrans.InventTrans == this.RecId;

        if (inventClosingNonFinancialInventTrans.RecId == 0)
        {
            return false;
        }
        else if (inventClosingNonFinancialInventTrans.AllowCancel == NoYes::No)
        {
            return true;
        }
        else
        {
            select firstonly Active
            from inventClosing
            where inventClosing.RecId == inventClosingNonFinancialInventTrans.InventClosing;

            return (inventClosing.Active == NoYes::Yes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the current transaction is the Receipt transaction.
    /// </summary>
    /// <returns>
    ///    true if the current transaction is the Receipt transaction; otherwise, false.
    /// </returns>
    public boolean isReceipt()
    {
        return InventTrans::isReceiptByQty(this.Qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReceiptByQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether an inventory transaction with the specified quantity is a receipt transaction.
    /// </summary>
    /// <returns>
    /// true, if an inventory transaction with the specified quantity is a receipt transaction; otherwise, false.
    /// </returns>
    public static boolean isReceiptByQty(InventQty _qty)
    {
        return _qty > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransfer</Name>
				<Source><![CDATA[
    public boolean isTransfer()
    {
        return this.inventTransOrigin().isTransfer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransferOrderStorno_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the current transaction is storno of InventTransferOrder.
    /// </summary>
    /// <returns>
    /// True if the current transaction is storno of InventTransferOrder, otherwise false.
    /// </returns>
    public boolean isTransferOrderStorno_RU()
    {
        InventTransOriginTransfer inventTransOriginTransfer;

        select firstonly inventTransOriginTransfer
            where inventTransOriginTransfer.IssueInventTransOrigin == this.InventTransOrigin ||
                  inventTransOriginTransfer.ReceiptInventTransOrigin == this.InventTransOrigin;

        if (inventTransOriginTransfer)
        {
            if ( (inventTransOriginTransfer.IssueInventTransOrigin   == this.InventTransOrigin && this.StatusIssue == StatusIssue::None) ||
                 (inventTransOriginTransfer.ReceiptInventTransOrigin == this.InventTransOrigin && this.StatusReceipt == StatusReceipt::None))
            {
                return true;
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransferReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether this inventory transaction is a receipt for an inventory transfer.
    /// </summary>
    /// <returns>
    ///    true if this inventory transaction is a receipt for an inventory transfer; otherwise, false.
    /// </returns>
    public boolean isTransferReceipt()
    {
        return this.isReceipt() && this.isTransfer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUpdatedEstimated</Name>
				<Source><![CDATA[
    public boolean  isUpdatedEstimated()
    {
        return (this.StatusReceipt  == StatusReceipt::Ordered       ||
                this.StatusReceipt  == StatusReceipt::Arrived       ||
                this.StatusIssue    == StatusIssue::ReservPhysical  ||
                this.StatusIssue    == StatusIssue::ReservOrdered   ||
                this.StatusIssue    == StatusIssue::OnOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUpdatedEstimatedReceipt</Name>
				<Source><![CDATA[
    public boolean  isUpdatedEstimatedReceipt()
    {
        return (this.StatusReceipt  == StatusReceipt::Ordered       ||
                this.StatusReceipt  == StatusReceipt::Arrived);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUpdatedFinancial</Name>
				<Source><![CDATA[
    public boolean  isUpdatedFinancial()
    {
        return (this.StatusReceipt  <= StatusReceipt::Purchased &&
                this.StatusIssue    <= StatusIssue::Sold);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUpdatedPhysical</Name>
				<Source><![CDATA[
    public boolean  isUpdatedPhysical()
    {
        return (this.StatusReceipt  == StatusReceipt::Received  ||
                this.StatusIssue    == StatusIssue::Deducted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUpdatedQuotation</Name>
				<Source><![CDATA[
    public boolean  isUpdatedQuotation()
    {
        return (this.StatusReceipt      == StatusReceipt::QuotationReceipt ||
                this.StatusIssue        == StatusIssue::QuotationIssue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransferShipCancellation</Name>
				<Source><![CDATA[
    private boolean isTransferShipCancellation()
    {       
        if (this.InvoiceReturned &&
            this.Voucher &&
            !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&             
            this.inventTransorigin().referenceCategory == InventTransType::TransferOrderShip)
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTransferShipCancellationClose</Name>
				<Source><![CDATA[
    private boolean canTransferShipCancellationClose()
    {
        InventTrans originalSettledTrans;

        if (this.ReturnInventTransOrigin)
        {
            select firstonly RecId from originalSettledTrans
                where originalSettledTrans.InventTransOrigin == this.ReturnInventTransOrigin
                && originalSettledTrans.RecId != this.RecId
                && originalSettledTrans.QtySettled != 0;
        }
                
        if (originalSettledTrans.RecId)
        {
            return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWMSReserved</Name>
				<Source><![CDATA[
    /*
        Returns true if the inventTrans is is considered reserved by WMS
        This is the case if inventTrans is Reserved Physical or is Reserved Ordered on a picking location
    */
    public boolean isWMSReserved()
    {
        InventDim   inventDim;
        WMSLocation wmsLocation;

        switch (this.StatusIssue)
        {
            case StatusIssue::ReservPhysical:
                return true;

            case StatusIssue::ReservOrdered:
                inventDim   = this.inventDim();
                wmsLocation = WMSLocation::find(inventDim.wmsLocationId,inventDim.InventLocationId);
                return (wmsLocation.RecId && wmsLocation.LocationType == WMSLocationType::Pick);

            default:
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemGroupId</Name>
				<Source><![CDATA[
    public display ItemGroupId itemGroupId()
    {
        return InventTable::find(this.ItemId).itemGroupId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemName</Name>
				<Source><![CDATA[
    public display SalesLineShowItemName itemName()
    {
        return this.inventTable().itemName(this.inventDim());
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastSettleDate</Name>
				<Source><![CDATA[
    public TransDate lastSettleDate(InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur)
    {
        InventSettlement inventSettlement;
        // <GEERU>
        boolean         countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        inventSettlement.selectLocked(false);

        select maxof(TransDate) from inventSettlement
            where inventSettlement.TransRecId      == this.RecId
               // <GEERU>
               && inventSettlement.Cancelled       == NoYes::No
               && (!countryRegion_RU
               || (countryRegion_RU
               && inventSettlement.InventTransCurrency_RU   == _inventTransCurrency));
        // </GEERU>

        return inventSettlement.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmount</Name>
				<Source><![CDATA[
    [SysObsolete('To achieve better performance InventTransReference should be instantiated locally from consumer', false, 31\01\2016)]
    public display LineAmount lineAmount()
    {
        return InventTransReference::newFromInventTrans(this).lineAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextNumberBatchId</Name>
				<Source><![CDATA[
    public InventBatchId nextNumberBatchId()
    {
        InventNumGroup      inventNumGroup;
        InventNumGroupId    numGroupId = InventTable::find(this.ItemId).BatchNumGroupId;
        InventBatchId       inventBatchId;
        InventBatch         inventBatch;
        InventTransOrigin   inventTransOrigin;

        ttsbegin;

        if (! numGroupId)
        {
            throw error(strFmt("@SYS68248",this.ItemId));
        }

        inventNumGroup = InventNumGroup::find(numGroupId);
        if (! inventNumGroup)
        {
            throw error(strFmt("@SYS3312",numGroupId));
        }
        inventTransOrigin = this.inventTransOrigin();

        inventBatchId = inventNumGroup.buildNumberParameters(this.DateExpected,
                                                             inventTransOrigin.ReferenceId,
                                                             inventTransOrigin.InventTransId,
                                                             extendedTypeNum(InventBatchId));

        inventBatch.initFromInventTrans(this);
        inventBatch.InventBatchId   = inventBatchId;
        inventBatch.insert();

        ttscommit;

        return inventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextNumberSerialId</Name>
				<Source><![CDATA[
    public InventSerialId nextNumberSerialId()
    {
        InventNumGroup      inventNumGroup;
        InventNumGroupId    numGroupId = InventTable::find(this.ItemId).SerialNumGroupId;
        InventSerialId      inventSerialId;
        InventTransOrigin   inventTransOrigin;

        ttsbegin;

        if (! numGroupId)
        {
            throw error(strFmt("@SYS68249",this.ItemId));
        }

        inventNumGroup = InventNumGroup::find(numGroupId);
        if (! inventNumGroup)
        {
            throw error(strFmt("@SYS3312",numGroupId));
        }

        inventTransOrigin = this.inventTransOrigin();

        inventSerialId = inventNumGroup.buildNumberParameters(this.DateExpected,
                                                              inventTransOrigin.ReferenceId,
                                                              inventTransOrigin.InventTransId,
                                                              extendedTypeNum(InventSerialId));
        ttscommit;

        return inventSerialId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openQty</Name>
				<Source><![CDATA[
    public display InventQty openQty()
    {
        return (abs(this.Qty   - this.QtySettled) < InventAdj::settleQtyDiff() ? 0 : decRound((this.Qty   - this.QtySettled),InventAdj::settleQtyDec()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>openQtySecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the open quantity of the item in inventory unit for reporting currency.
    /// </summary>
    /// <returns>
    ///     Open quantity for reporting currency.
    /// </returns>
    public display InventQty openQtySecCur_RU()
    {
        return (abs(this.Qty - this.QtySettledSecCur_RU) < InventAdj::settleQtyDiff() ? 0 : decRound((this.Qty - this.QtySettledSecCur_RU), InventAdj::settleQtyDec()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pcsPrice</Name>
				<Source><![CDATA[
    [SysObsolete('To achieve better performance InventTransReference should be instantiated locally from consumer', false, 31\01\2016)]
    public display PriceCur pcsPrice()
    {
        return InventTransReference::newFromInventTrans(this).pcsPrice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWFinancialOpenQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and returns the CW quantity open for the active record.
    /// </summary>
    /// <returns>Calculated cw open quantity.</returns>
    public PdsCWInventQty pdsCWFinancialOpenQty()
    {
        PdsCWInventQty pdsCWInventQty = 0;

        pdsCWInventQty = (this.ValueOpen != InventTransOpen::No
                            ? (abs(this.PdsCWQty  - this.PdsCWSettled)
                                < InventAdj::settleQtyDiff()
                                ? 0
                                : decRound((this.PdsCWQty
                                            - this.PdsCWSettled),0))
                            : 0);

        return pdsCWInventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWOpenQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and returns the CW quantity open for the active record.
    /// </summary>
    /// <returns>Calculated CW open quantity.</returns>
    /// <remarks>
    /// <syntax>
    /// public PdsCWOpenInventQty PdsCWOpenQty()
    /// </syntax>
    /// </remarks>
    public display PdsCWOpenInventQty pdsCWOpenQty()
    {
        return this.PdsCWQty - this.PdsCWSettled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWUnitId</Name>
				<Source><![CDATA[
    public display PdsCWUnitId pdsCWUnitId()
    {
        return PdsCatchWeight::cwUnitId(this.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsDispositionCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the batch disposition code associated with the <c>InventTrans</c> record.
    /// </summary>
    /// <returns>
    /// The disposition code associated with the <c>InventTrans</c> record.
    /// </returns>
    public display PdsBatchDispositionCode pdsDispositionCode()
    {
        InventDim               inventDim;
        PdsBatchDispositionCode dispositionCode = '';

        if (hasFieldAccess(
                tableNum(InventBatch),
                fieldNum(InventBatch,PdsDispositionCode),
                AccessType::View))
        {
            inventDim = this.inventDim();
            if (inventDim.InventBatchId)
            {
                dispositionCode = InventBatch::find(
                                    inventDim.InventBatchId,
                                    this.ItemId).PdsDispositionCode;
            }
        }

        return dispositionCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsDispositionStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the batch disposition status associated with the <c>InventTrans</c> record.
    /// </summary>
    /// <returns>
    /// The disposition status associated with the <c>InventTrans</c> record.
    /// </returns>
    public display PdsBatchDispositionStatus pdsDispositionStatus()
    {
        InventDim                   inventDim;
        PdsBatchDispositionStatus   status = PdsStatus::NotApplicable;

        inventDim = this.inventDim();

        if (inventDim.InventBatchId)
        {
            status = InventBatch::find(
                        inventDim.InventBatchId,
                        this.ItemId).pdsDispositionStatus();
        }

        return  status;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsGetPotencyValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the actual potency value for the item and batch on this <c>InventTrans</c>.
    /// </summary>
    /// <returns>
    /// The actual potency value for this inventory transaction or a blank value if the transaction is not for a potency item, there is no batch, or no actual potency
    /// has been set on the batch.
    /// </returns>
    public PDSBaseValue pdsGetPotencyValue()
    {
        PDSBaseValue            ret;
        InventTable             inventTable;

        inventTable = this.inventTable();
        if (inventTable.pdsBaseAttributeId)
        {
            ret = PdsBatchAttributes::find(this.ItemId, this.inventBatchId(), inventTable.pdsBaseAttributeId).PdsBatchAttribValue;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingBalanceSheet</Name>
				<Source><![CDATA[
    public display LedgerPostingTypeBalanceSheet postingBalanceSheet()
    {
        return this.inventTransPostingFinancial().PostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingLossProfit</Name>
				<Source><![CDATA[
    public LedgerPostingTypeLossProfit postingLossProfit(CostAmount _adjustment)
    {
        if (_adjustment > 0)
        {
            return LedgerPostingType::InventProfit;
        }

        return LedgerPostingType::InventLoss;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOperations</Name>
				<Source><![CDATA[
    public display LedgerPostingTypeOperations postingOperations()
    {
        return this.inventTransPostingFinancial().PostingTypeOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysical</Name>
				<Source><![CDATA[
    public display LedgerPostingTypePhysical postingPhysical()
    {
        return this.inventTransPostingPhysical().PostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysicalOffset</Name>
				<Source><![CDATA[
    public display LedgerPostingTypePhysicalOffset postingPhysicalOffset()
    {
        return this.inventTransPostingPhysical().PostingTypeOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodJournalBOM</Name>
				<Source><![CDATA[
    public ProdJournalBOM prodJournalBOM(boolean _forUpdate = false)
    {
        ProdJournalBOM prodJournalBOM;

        prodJournalBOM.selectForUpdate(_forUpdate);

        if (this.TransChildType != InventTransChildType::ProdJournalBOM || !this.TransChildRefId)
        {
            throw error("@SYS55039");
        }

        select firstonly prodJournalBOM
            where prodJournalBOM.InventTransId           == this.inventTransOrigin().InventTransId
               && prodJournalBOM.InventTransChildType    == this.TransChildType
               && prodJournalBOM.InventTransChildRefId   == this.TransChildRefId;

        return prodJournalBOM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodJournalProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the related production report as finished journal line.
    /// </summary>
    /// <param name="_forUpdate">
    ///    true if the record should be selected for update; otherwise, false. Optional
    /// </param>
    /// <returns>
    ///    A <c>ProdJournalProd</c> record.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///    This record is not related to a production report as finished journal line.
    /// </exception>
    public ProdJournalProd prodJournalProd(boolean _forUpdate = false)
    {
        ProdJournalProd prodJournalProd;

        prodJournalProd.selectForUpdate(_forUpdate);

        if (this.TransChildType != InventTransChildType::ProdJournalProd || !this.TransChildRefId)
        {
            throw error("@SYS24356");
        }

        select firstonly prodJournalProd
            where prodJournalProd.InventTransId             == this.inventTransOrigin().InventTransId
               && prodJournalProd.InventTransChildType      == this.TransChildType
               && prodJournalProd.InventTransChildRefId     == this.TransChildRefId;

        return prodJournalProd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodTableJour</Name>
				<Source><![CDATA[
    public ProdTableJour prodTableJour(boolean _forUpdate = false)
    {
        InventTransId       transIdAssembly;
        ProdTableJour       prodTableJour;
        InventTransOrigin   inventTransOrigin = this.inventTransOrigin();

        switch (inventTransOrigin.ReferenceCategory)
        {
            case InventTransType::Production:
                transIdAssembly = inventTransOrigin.InventTransId;
                break;
            case InventTransType::ProdLine:
                transIdAssembly = this.assemblyInventTransOrigin().InventTransId;
                break;
            default:
                throw error("@SYS24356");
        }

        prodTableJour.selectForUpdate(_forUpdate);

        select firstonly prodTableJour
            where prodTableJour.TransDate       == this.DateFinancial
               && prodTableJour.Voucher         == this.Voucher
               && prodTableJour.InventTransId   == transIdAssembly;

        return prodTableJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyUnit</Name>
				<Source><![CDATA[
    public display ProductQuantity qtyUnit()
    {
        return InventTransReference::newFromInventTrans(this).qtyUnit();
    }

]]></Source>
			</Method>
			<Method>
				<Name>rboTransactionSalesTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the sales order line with the current inventTransID value.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>RetailTransactionSalesTrans</c> table; otherwise error.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an exception if the reference category is not of statement type.
    /// </exception>
    RetailTransactionSalesTrans rboTransactionSalesTrans(boolean _forUpdate = false)
    {
        RetailTransactionSalesTrans salesOrderLine;
        InventTransOrigin           inventTransOrigin;

        salesOrderLine.selectForUpdate(_forUpdate);

        inventTransOrigin = InventTransOrigin::find(this.InventTransOrigin);

        if (inventTransOrigin.ReferenceCategory   != InventTransType::Statement)
            throw error("@RET5812"); // No sales order line exists for the inventory transaction

        salesOrderLine = inventTransOrigin.originator();

        return salesOrderLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the related <c>ReturnInventTransOrigin</c> value.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    A counterpart inventory originator.
    /// </returns>
    public InventTransOrigin returnInventTransOrigin(boolean _forUpdate = false)
    {
        InventTransOrigin           inventTransOrigin;

        if (!this.ReturnInventTransOrigin)
        {
            return inventTransOrigin;
        }

        return InventTransOrigin::find(this.ReturnInventTransOrigin, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setClosedOpen</Name>
				<Source><![CDATA[
    public void setClosedOpen()
    {
        switch (true)
        {
            case this.PackingSlipReturned :
                this.ValueOpen  = InventTransOpen::No;
                this.DateClosed = this.DatePhysical;
                break;

            case this.isUpdatedQuotation() :
                this.ValueOpen  = InventTransOpen::Quotation;
                this.DateClosed = dateNull();
                break;
                
            case this.isTransferShipCancellation() :
                if (InventTable::find(this.ItemId).modelGroup().inventModelType().mustBeClosed())
                {
                    if (this.canTransferShipCancellationClose())
                    {
                        this.valueOpen  = InventTransOpen::No;
                        this.DateClosed = this.DateFinancial;
                    }
                }
                break;

            case this.RecId && this.ValueOpen == InventTransOpen::No :                  // can closed transaction be reopened?
                if (this.CostAmountPosted       != this.orig().CostAmountPosted             ||
                    this.CostAmountAdjustment   != this.orig().CostAmountAdjustment         ||
                    this.CostAmountSettled      != this.orig().CostAmountSettled            ||
                    this.Qty                    != this.orig().Qty                          ||
                    this.QtySettled             != this.orig().QtySettled
                   )
                {
                    if (CurrencyExchangeHelper::amount(this.costValue() - this.CostAmountSettled) != 0    ||
                        abs(this.Qty - this.QtySettled) >= InventAdj::settleQtyDiff()
                       )
                    {
                        if (CostNonFinancialTransferClosingValidationToggle::instance().isEnabled() &&
                            this.NonFinancialTransferInventClosing != 0)
                        {
                            // Transaction cannot be reopened as it has already been pre-closed.
                            throw error(strFmt("@SCM:TransactionCannotBeReopened", this.RecId));
                        }

                        this.ValueOpen  = InventTransOpen::Yes;
                        this.DateClosed = dateNull();
                    }
                }
                break;

            case this.isUpdatedFinancial()                                    &&
                 abs(this.Qty - this.QtySettled) < InventAdj::settleQtyDiff() &&
                 CurrencyExchangeHelper::amount(this.costValue() - this.CostAmountSettled) == 0 :     // can transaction be closed?

                this.ValueOpen  = InventTransOpen::No;
                if (this.InventTransOrigin && this.RecId)
                {
                    this.DateClosed = this.lastSettleDate();
                }
                this.DateClosed = this.DateClosed ? this.DateClosed : this.DateFinancial;
                break;           

            default :
                this.ValueOpen  = InventTransOpen::Yes;
                this.DateClosed = dateNull();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setClosedOpenSecCur_RU</Name>
				<Source><![CDATA[
    public void setClosedOpenSecCur_RU()
    {
        switch (true)
        {
            case this.PackingSlipReturned :
                this.ValueOpenSecCur_RU  = InventTransOpen::No;
                this.DateClosedSecCur_RU = this.DatePhysical;
                break;

            case this.isUpdatedQuotation() :
                this.ValueOpenSecCur_RU  = InventTransOpen::Quotation;
                this.DateClosedSecCur_RU = dateNull();
                break;

            case this.RecId && this.ValueOpenSecCur_RU == InventTransOpen::No :
                if (this.CostAmountSecCurPosted_RU     != this.orig().CostAmountSecCurPosted_RU     ||
                    this.CostAmountSecCurAdjustment_RU != this.orig().CostAmountSecCurAdjustment_RU ||
                    this.CostAmountSettledSecCur_RU    != this.orig().CostAmountSettledSecCur_RU    ||
                    this.Qty                           != this.orig().Qty                           ||
                    this.QtySettledSecCur_RU           != this.orig().QtySettledSecCur_RU)
                {
                    if (CurrencyExchangeHelper::amount(this.costValueSecCur_RU() - this.CostAmountSettledSecCur_RU) != 0 ||
                        abs(this.Qty - this.QtySettledSecCur_RU) >= InventAdj::settleQtyDiff())
                    {
                        this.ValueOpenSecCur_RU  = InventTransOpen::Yes;
                        this.DateClosedSecCur_RU = dateNull();
                    }
                }
                break;

            case this.isUpdatedFinancial()                                             &&
                 abs(this.Qty - this.QtySettledSecCur_RU) < InventAdj::settleQtyDiff() &&
                 CurrencyExchangeHelper::amount(this.costValueSecCur_RU() - this.CostAmountSettledSecCur_RU) == 0 :     // can transaction be closed?

                this.ValueOpenSecCur_RU = InventTransOpen::No;
                if (this.InventTransOrigin && this.RecId)
                {
                    this.DateClosedSecCur_RU = this.lastSettleDate(InventTransCurrency_RU::SecondaryCur);
                }
                this.DateClosedSecCur_RU = this.DateClosedSecCur_RU ? this.DateClosedSecCur_RU : this.DateFinancial;
                break;

            default :
                this.ValueOpenSecCur_RU  = InventTransOpen::Yes;
                this.DateClosedSecCur_RU = dateNull();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMarking</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the marking field to reference the specified inventory transaction originator.
    /// </summary>
    /// <param name="_markingRefInventTransOrigin">
    ///    The inventory transaction originator with which this record is marked.
    /// </param>
    public void setMarking(InventTransOriginId     _markingRefInventTransOrigin)
    {
        this.MarkingRefInventTransOrigin    = _markingRefInventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStatusDate</Name>
				<Source><![CDATA[
    public void setStatusDate()
    {
        if (this.isUpdatedFinancial())
        {
            this.DateStatus  = this.DateFinancial;
        }
        else
        {
            if (this.isUpdatedPhysical())
            {
                this.DateStatus = this.DatePhysical;
            }
            else
            {
                this.DateStatus = this.DateInvent ? this.DateInvent : this.DateExpected;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSumAmount</Name>
				<Source><![CDATA[
    public boolean setSumAmount(InventTrans _buffer)
    {
        if (! InventHook::fieldEqual(this, _buffer))
        {
            return false;
        }

        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (this.mustSetSumAmount(_buffer))
        {
            this.CostAmountPosted       += _buffer.CostAmountPosted;
            this.CostAmountOperations   += _buffer.CostAmountOperations;
            this.CostAmountStd          += _buffer.CostAmountStd;
            this.CostAmountPhysical     += _buffer.CostAmountPhysical;
            this.RevenueAmountPhysical  += _buffer.RevenueAmountPhysical;
            this.TaxAmountPhysical      += _buffer.TaxAmountPhysical;
            this.Qty                    += _buffer.Qty;

            if (PdsGlobal::pdsIsCWItem(this.ItemId))
            {
                this.InventDimFixed     = this.InventDimFixed | _buffer.InventDimFixed;
                this.PdsCWQty           += _buffer.PdsCWQty;
            }
            // <GEERU>
            if (countryRegion_RU)
            {
                this.CostAmountSecCurPosted_RU   += _buffer.CostAmountSecCurPosted_RU;
                this.CostAmountStdSecCur_RU      += _buffer.CostAmountStdSecCur_RU;
                this.CostAmountSecCurPhysical_RU += _buffer.CostAmountSecCurPhysical_RU;
            }
            // </GEERU>

            InventHook::amountAdd(this, _buffer);

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetSumAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the sum amount must be set.
    /// </summary>
    /// <param name = "_buffer">
    /// An inventory transaction record buffer.
    /// </param>
    /// <returns>
    /// true if the sum amount can be set from the buffer; otherwise, false.
    /// </returns>
    protected boolean mustSetSumAmount(InventTrans _inventTrans)
    {
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        return this.StatusIssue                    == _inventTrans.StatusIssue
               // <SCM>
               && this.StatusReceipt                  == _inventTrans.StatusReceipt
               // </SCM>
               && this.DatePhysical                   == _inventTrans.DatePhysical
            && this.CurrencyCode                   == _inventTrans.CurrencyCode
            && this.InvoiceId                      == _inventTrans.InvoiceId
            && this.PackingSlipId                  == _inventTrans.PackingSlipId
            && this.Voucher                        == _inventTrans.Voucher
            && this.PackingSlipReturned            == _inventTrans.PackingSlipReturned
            && this.InvoiceReturned                == _inventTrans.InvoiceReturned
            && this.DateFinancial                  == _inventTrans.DateFinancial
            && this.InventTransOrigin              == _inventTrans.InventTransOrigin
            && this.VoucherPhysical                == _inventTrans.VoucherPhysical
            && this.ReturnInventTransOrigin        == _inventTrans.ReturnInventTransOrigin
            && this.ProjId                         == _inventTrans.ProjId
            && this.ProjCategoryId                 == _inventTrans.ProjCategoryId
            && this.InventDimId                    == _inventTrans.InventDimId
            && ((this.InventDimFixed == _inventTrans.InventDimFixed)
            || (PdsGlobal::pdsIsCWItem(this.ItemId) && (this.PdsCWQty == 0 || _inventTrans.PdsCWQty == 0)))
            && this.TransChildRefId                == _inventTrans.TransChildRefId
            && this.TransChildType                 == _inventTrans.TransChildType
            && this.TimeExpected                   == _inventTrans.TimeExpected
            && this.DateInvent                     == _inventTrans.DateInvent
            && this.MarkingRefInventTransOrigin    == _inventTrans.MarkingRefInventTransOrigin
            && this.PickingRouteID                 == _inventTrans.PickingRouteID
            && this.LoadId                         == _inventTrans.LoadId
            && this.ReceiptId                      == _inventTrans.ReceiptId
            // <GEERU>
            && this.InventDimIdSales_RU            == _inventTrans.InventDimIdSales_RU
            && this.InventTransOriginSales_RU      == _inventTrans.InventTransOriginSales_RU
            && this.InventTransOriginTransit_RU    == _inventTrans.InventTransOriginTransit_RU
            && this.InventTransOriginDelivery_RU   == _inventTrans.InventTransOriginDelivery_RU
            && this.GroupRefType_RU                == _inventTrans.GroupRefType_RU
            && this.GroupRefId_RU                  == _inventTrans.GroupRefId_RU
            // </GEERU>
            && _inventTrans.QtySettled                  == 0
            && _inventTrans.CostAmountSettled           == 0
            // <GEERU>
            && _inventTrans.CostAmountAdjustment            == 0
            && (!countryRegion_RU
            || (countryRegion_RU
            && _inventTrans.QtySettledSecCur_RU             == 0
            && _inventTrans.CostAmountSettledSecCur_RU      == 0
            && _inventTrans.CostAmountSecCurAdjustment_RU   == 0));
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransValueDate</Name>
				<Source><![CDATA[
    public void setTransValueDate(TransDate                 _transDate,
                                  InventTransCurrency_RU   _inventTransCurrency = InventTransCurrency_RU::PrimaryCur)
    {
        InventSettlement inventSettlement;
        // <GEERU>
        boolean         countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        select sum(CostAmountSettled),sum(QtySettled),sum(CostAmountAdjustment)
            , sum(PdsCWSettled)
        from inventSettlement
            where inventSettlement.TransRecId       == this.RecId
               && inventSettlement.Cancelled        == 0
               // <GEERU>
               && inventSettlement.TransDate        <= _transDate
               && (!countryRegion_RU
               || (countryRegion_RU
               && inventSettlement.InventTransCurrency_RU   == _inventTransCurrency));
        // </GEERU>

        // <GEERU>
        if (!countryRegion_RU
            || (countryRegion_RU
            && _inventTransCurrency == InventTransCurrency_RU::PrimaryCur))
        {
            this.CostAmountPosted  -= inventSettlement.CostAmountSettled;
            this.Qty               -= inventSettlement.QtySettled;
            this.CostAmountPosted  += inventSettlement.CostAmountAdjustment;
        }
        else
        {
            this.CostAmountSecCurPosted_RU  -= inventSettlement.CostAmountSettled;
            this.Qty                        -= inventSettlement.QtySettled;
            this.CostAmountSecCurPosted_RU  += inventSettlement.CostAmountAdjustment;
        }
        // </GEERU>

        this.PdsCWQty          -= inventSettlement.PdsCWSettled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>stockQtyChangeDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the date when the transaction changed the physical availability of the products in the inventory.
    /// </summary>
    /// <returns>
    /// The date when the transaction changed the physical availability of the products in the inventory.
    /// </returns>
    /// <remarks>
    /// Returns <c>DateInvent</c> if it is populated; otherwise <c>DatePhysical</c>.
    /// </remarks>
    public display StockQtyChangeDate stockQtyChangeDate()
    {
        return this.DateInvent ? this.DateInvent : this.DatePhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>stornoTxt_RU</Name>
				<Source><![CDATA[
    public display StornoTxt_RU stornoTxt_RU()
    {
        return this.Storno_RU ? 'V' : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionCurrencyCode</Name>
				<Source><![CDATA[
    [SysObsolete('To achieve better performance InventTransReference should be instantiated locally from consumer', false, 31\01\2016)]
    public display CurrencyCodeTransaction transactionCurrencyCode()
    {
        return InventTransReference::newFromInventTrans(this).currencyCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the lot ID of the related transfer.
    /// </summary>
    /// <returns>
    /// The lot ID of the related transfer.
    /// </returns>
    public display InventTransIdTransfer transferInventTransId()
    {
        return this.isTransfer() ? this.transferInventTransOrigin().InventTransId : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the related transfer <c>InventTransOrigin</c> object.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    A transfer counterpart inventory originator.
    /// </returns>
    public InventTransOrigin transferInventTransOrigin(boolean _forUpdate = false)
    {
        return InventTrans::transferInventTransOriginByOriginAndQty(this.InventTransOrigin, this.Qty, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferInventTransOriginByOriginAndQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the related transfer <c>InventTransOrigin</c> object given the origin and the quantity of the inventory transaction.
    /// </summary>
    /// <param name="_inventTransOriginRecId">
    /// The RecId of the inventory transaction originator.
    /// </param>
    /// <param name="_qty">
    /// The quantity of the transaction in the inventory unit of measure.
    /// </param>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    /// A transfer counterpart inventory originator.
    /// </returns>
    /// <remarks>Providing the quantity allows for a more efficient query plan.</remarks>
    public static InventTransOrigin transferInventTransOriginByOriginAndQty(
        InventTransOriginId     _inventTransOriginRecId,
        InventQty               _qty,
        boolean                 _forUpdate = false)
    {
        // using direct select for performance reasons

        InventTransOrigin           inventTransOrigin;
        InventTransOriginTransfer   inventTransOriginTransfer;

        if (_forUpdate)
        {
            inventTransOrigin.selectForUpdate(_forUpdate);
        }

        // don't combine the statements below as that most likely results in wide index scans instead of narrow index seeks.
        if (_qty <= 0)
        {
            // This is most likely the standard issue of a transfer so try that first.
            select firstonly inventTransOrigin
                exists join inventTransOriginTransfer
                where   inventTransOriginTransfer.IssueInventTransOrigin    == _inventTransOriginRecId
                     && inventTransOriginTransfer.ReceiptInventTransOrigin  == inventTransOrigin.RecId;

            if (!inventTransOrigin.RecId)
            {
                // This wasn't the issue - try the receipt
                select firstonly inventTransOrigin
                    exists join inventTransOriginTransfer
                    where   inventTransOriginTransfer.IssueInventTransOrigin    == inventTransOrigin.RecId
                         && inventTransOriginTransfer.ReceiptInventTransOrigin  == _inventTransOriginRecId;
            }
        }
        else
        {
            // This is most likely the standard receipt of a transfer so try that first.
            select firstonly inventTransOrigin
                exists join inventTransOriginTransfer
                where   inventTransOriginTransfer.IssueInventTransOrigin    == inventTransOrigin.RecId
                     && inventTransOriginTransfer.ReceiptInventTransOrigin  == _inventTransOriginRecId;

            if (!inventTransOrigin.RecId)
            {
                // This wasn't the receipt - try the issue
                select firstonly inventTransOrigin
                    exists join inventTransOriginTransfer
                    where   inventTransOriginTransfer.IssueInventTransOrigin    == _inventTransOriginRecId
                         && inventTransOriginTransfer.ReceiptInventTransOrigin  == inventTransOrigin.RecId;
            }
        }

        if (!inventTransOrigin.RecId)
        {
            // InventTransTransfer is set for transfer journal and transfer orders for versions after 4.0
            // before 4.0 the same InventTransId was set for both TransferFrom and TransferTo transactions
            // so we return reference to the same origin for backward compatibility
            inventTransOrigin = InventTransOrigin::find(_inventTransOriginRecId, _forUpdate);
        }

        return inventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unit</Name>
				<Source><![CDATA[
    [SysObsolete('To achieve better performance InventTransReference should be instantiated locally from consumer', false, 31\01\2016)]
    public display UnitOfMeasureSymbol unit()
    {
        return InventTransReference::newFromInventTrans(this).unitId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpostedInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an invoice ID of any unposted invoices.
    /// </summary>
    /// <returns>
    /// An invoice ID for the unposted invoice or invoices; otherwise, an empty string.
    /// </returns>
    /// <remarks>
    ///  The following invoice IDs can be returned from this method:
    ///  <list type="bullet">
    ///   <item>
    ///   <description>An empty string; if the receipt status is not received or there are no unposted
    ///   invoices.</description>
    ///   </item>
    ///   <item>
    ///   <description>New; if there is a single unposted invoice without an ID assigned.</description>
    ///   </item>
    ///   <item>
    ///   <description>The invoice ID; if there is a single unposted invoice with an ID
    ///   assigned.</description>
    ///   </item>
    ///   <item>
    ///   <description>Multiple; if there are multiple unposted invoices.</description>
    ///   </item>
    ///  </list>
    ///  It includes unposted invoices saved in batches or being edited and those saved as pending.
    /// </remarks>
    public display UnpostedInvoiceId unpostedInvoiceId()
    {
        if ((this.StatusReceipt == StatusReceipt::Received) || (this.StatusIssue == StatusIssue::Deducted) &&
           ((this.inventTransOrigin().ReferenceCategory == InventTransType::Purch)))
        {
            return this.unpostedInvoiceIdForReceivedPurchType();
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpostedInvoiceIdForReceivedPurchType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an invoice ID of any invoices that are not posted.
    /// </summary>
    /// <returns>
    /// An invoice ID for the invoice that is not posted; otherwise, an empty string.
    /// </returns>
    /// <remarks>
    ///  This method assumes the current record is already known to be a purchase type transaction and in a
    ///  received state. It should only be called from the
    ///  <c>
    ///  unpostedInvoiceId
    ///  </c>
    ///   display method. The following invoice IDs can be returned from this method:
    ///  <list type="bullet">
    ///   <item>
    ///   <description>An empty string; if the receipt status is not received or there are no invoices that
    ///   are not posted.</description>
    ///   </item>
    ///   <item>
    ///   <description>New; if there is a single invoice that is not posted without an ID
    ///   assigned.</description>
    ///   </item>
    ///   <item>
    ///   <description>The invoice ID; if there is a single invoice that is not posted with an ID
    ///   assigned.</description>
    ///   </item>
    ///   <item>
    ///   <description>*; if there are one or more invoices that are not posted with an ID
    ///   assigned.</description>
    ///   </item>
    ///  </list>
    /// </remarks>
    private UnpostedInvoiceId unpostedInvoiceIdForReceivedPurchType()
    {
        InventTransOrigin       inventTransOrigin = this.inventTransOrigin();
        VendInvoiceInfoLine     vendInvoiceInfoLine;
        VendInvoiceInfoTable    vendInvoiceInfoTable;
        VendInvoiceId           unpostedInvoiceId;
        boolean                 anyFound = false;

        while select Num from vendInvoiceInfoTable
            where
                vendInvoiceInfoTable.ParmJobStatus  == ParmJobStatus::Waiting
             || vendInvoiceInfoTable.ParmJobStatus  == ParmJobStatus::ContainErrors
            exists join vendInvoiceInfoLine
                where
                    vendInvoiceInfoLine.InventTransId       == inventTransOrigin.InventTransId
                    && vendInvoiceInfoLine.ParmId           == vendInvoiceInfoTable.ParmId
                    && vendInvoiceInfoLine.TableRefId       == vendInvoiceInfoTable.TableRefId
        {
            if (anyFound)
            {
                return "@SYS35668";     // More than 1 record found
            }
            unpostedInvoiceId = vendInvoiceInfoTable.Num;
            if (unpostedInvoiceId == '')
            {
                // A single pending invoice exists and has no Id; report New as the Id
                unpostedInvoiceId = "@SYS2055";
            }
            anyFound = true;
        }

        if (anyFound)
        {
            return unpostedInvoiceId;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the current record
    /// </summary>
    /// <param name="_dropInventOnHand">
    /// Yes if updating inventory on hand should be skippedM; otherwise, No.
    /// </param>
    /// <param name="_canDropInventSumDelta">
    /// Yes if <c>InventSum</c> should be updated directly instead of using <c>InventSumDelta</c>; otherwise, No.
    /// </param>
    /// <param name="_inventDimIdTransferIssue">
    ///    An <c>InventDimId</c> ID for the matching issue transaction for a transfer. This parameter is optional but can be passed to improve performance.
    /// </param>
    public void update(
        NoYes       _dropInventOnHand = NoYes::No,
        NoYes       _canDropInventSumDelta = NoYes::No,
        InventDimId _inventDimIdTransferIssue = '')
    {
        InventTrans     this_Orig;
        InventSum       inventSum;
        boolean         changesPhysInventory;

        ttsbegin;

        this.setStatusDate();
        this.setClosedOpen();
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.setClosedOpenSecCur_RU();
        }
        // </GEERU>

        if (!_dropInventOnHand)
        {
            this_Orig  = this.orig();

            // Additional inventory checks for WHS items.
            if (!InventDimLPCleanupInventTransUpdateContext::current() && WHSInventEnabled::exist(this.ItemId))
            {
                // Call validation methods if dimensions have changed or if status changes in a way that would affect physical inventory.
                changesPhysInventory = WHSInvent::changesPhysInventory(this_Orig, this);
                if (this_Orig.InventDimId != this.InventDimId
                    ||  changesPhysInventory)
                {
                    if (!WHSInvent::checkDimensions(this, changesPhysInventory))
                    {
                        throw error("@SYS18447");
                    }
                }
                else if (WHSInvent::doesTransStatusChangeRequireInventCheck(this_Orig, this))
                {
                    if (!WHSInvent::construct().checkDimHierarchy(this))
                    {
                        throw error("@SYS18447");
                    }
                }
            }

            if (InventSum::mustInventTransBeUpdated(this,this_Orig))
            {
                inventSum.initFromInventTrans(this);

                if (!inventSum.canInventTransBeUpdated(this_Orig))
                {
                    if (_canDropInventSumDelta && this.inventDim().InventSerialId)
                    {
                        inventSum = InventSum::find(this.ItemId, this.InventDimId, true);
                        if (!inventSum.RecId)
                        {
                            inventSum.initFromInventTrans(this);
                        }
                        inventSum.updateInventTrans(this,NoYes::Yes,null,false, _canDropInventSumDelta, _inventDimIdTransferIssue);
                    }
                    else
                    {
                        inventSum.updateInventTrans(this,NoYes::Yes,null,false, false, _inventDimIdTransferIssue);
                    }

                    inventSum.clear();
                    if (_canDropInventSumDelta && this_Orig.inventDim().InventSerialId)
                    {
                        inventSum = InventSum::find(this_Orig.ItemId, this_Orig.InventDimId, true);
                        if (!inventSum.RecId)
                        {
                            inventSum.initFromInventTrans(this_Orig);
                        }
                        inventSum.updateInventTrans(this_Orig,NoYes::No,null,true, _canDropInventSumDelta,_inventDimIdTransferIssue);
                    }
                    else
                    {
                        inventSum.initFromInventTrans(this_Orig);
                        inventSum.updateInventTrans(this_Orig,NoYes::No,null,true, false, _inventDimIdTransferIssue);
                    }
                }
                else
                {
                    if (_canDropInventSumDelta && this.inventDim().InventSerialId)
                    {
                        inventSum = InventSum::find(this.ItemId, this.InventDimId, true);
                        if (!inventSum.RecId)
                        {
                            inventSum.initFromInventTrans(this);
                        }
                        inventSum.updateInventTrans(this,NoYes::Yes,this_Orig, false, _canDropInventSumDelta, _inventDimIdTransferIssue);
                    }
                    else
                    {
                        inventSum.updateInventTrans(this,NoYes::Yes,this_Orig, false, false, _inventDimIdTransferIssue);
                    }
                }
            }
            else if (InventSum::mustInventTransBeLogUpdated(this,this_Orig))
            {
                if (InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().addInventSumLogTTS(this, NoYes::Yes))
                {
                    InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().addInventSumLogTTS(this_Orig, NoYes::No, true, true);
                }
            }
            else if (SalesLineCTPDeliveryDateControlRecalculateFeature::instance().isEnabled()
                     && SalesParameters::find().DeliveryDateCTPRecalculateOnUpdate)
            {
                InventTransOrigin inventTransOrigin = this.inventTransOrigin();
                if (inventTransOrigin.ReferenceCategory == InventTransType::Sales)
                {
                    SalesLine salesLine = inventTransOrigin.originator() as SalesLine;
                    if (salesLine && !salesLine.reqTrans() && salesLine.isDeliveryDateControlTypeClassicCTP()
                        && InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().addInventSumLogTTS(this, NoYes::Yes, false, true))
                    {
                        InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().addInventSumLogTTS(this_Orig, NoYes::No, true, true);
                    }
                }
            }
            this.updateReturnOrigin();
        }

        this.validateFinancialInventDimUpdate();
        super();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes inventory transaction changes to ensure that on-hand value are updated.
    /// </summary>
    /// <param name = "_newInventTrans">
    /// An <c>InventTrans</c> record containing new values.
    /// </param>
    /// <param name = "_origInventTrans">
    /// An <c>InventTrans</c> record containing original values.
    /// </param>
    [Hookable(false)]
    static internal void syncInventTrans(InventTrans _newInventTrans, InventTrans _origInventTrans)
    {
        if (appl.ttsLevel() == 0)
        {
            throw error(strFmt("@SCM:TransactionExpected", funcName()));
        }

        if (InventSum::mustInventTransBeUpdated(_newInventTrans, _origInventTrans))
        {
            InventSum newInventSum;
            InventSum origInventSum;

            newInventSum.initFromInventTrans(_newInventTrans);
            origInventSum.initFromInventTrans(_origInventTrans);

            if (_newInventTrans.RecId && _origInventTrans.RecId && newInventSum.canInventTransBeUpdated(_origInventTrans))
            {
                newInventSum.syncInventTrans(_newInventTrans, NoYes::Yes, _origInventTrans);
            }
            else
            {
                if (_newInventTrans.RecId)
                {
                    newInventSum.syncInventTrans(_newInventTrans, NoYes::Yes, null);
                }

                if (_origInventTrans.RecId)
                {
                    origInventSum.syncInventTrans(_origInventTrans, NoYes::No, null);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePriceRevaluationFin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes an inventory settlement record to adjust the financial transaction value to a new
    ///    cost.
    /// </summary>
    /// <param name="_inventTable">
    ///    An <c>InventTable</c> buffer.
    /// </param>
    /// <param name="_inventAccountType">
    ///     The inventory account type for the variance.
    /// </param>
    /// <param name="_voucher">
    ///    The revaluation voucher.
    /// </param>
    /// <param name="_adjustment">
    ///    The adjustment.
    /// </param>
    /// <param name="_revaluationDate">
    ///    The revaluation date.
    /// </param>
    /// <param name="_inventMovement">
    ///    The movement if the valuation is caused by backdating; optional.
    /// </param>
    /// <param name="_inventTransCurrency">
    ///    The currency associated with the transaction.
    /// </param>
    /// <returns>
    ///    An initialized inventory settlement record.
    /// </returns>
    public InventSettlement updatePriceRevaluationFin(
        InventTable         _inventTable,
        InventAccountType   _inventAccountType,
        Voucher             _voucher,
        CostAmount          _adjustment,
        date                _revaluationDate,
        InventMovement      _inventMovement = null,
        InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        InventCostPriceRevaluationHelper helper = new InventCostPriceRevaluationHelper();
        return helper.updatePriceRevaluationFin(this, _inventTable, _inventAccountType, _voucher, _adjustment, _revaluationDate, _inventMovement, _inventTransCurrency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildItemLedgerDimensionParameterFromInventTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting ledger dimension for an item.
    /// </summary>
    /// <param name = "_inventAccountType">A inventory account type.</param>
    /// <param name = "_inventTable">An item.</param>
    /// <returns>The built parameter instance.</returns>
    protected InventPostingItemLedgerDimensionParameters buildItemLedgerDimensionParameterFromInventTable(
        InventAccountType   _inventAccountType,
        InventTable         _inventTable)
    {
        InventPostingItemLedgerDimensionParameters searchParameters = InventPostingItemLedgerDimensionParameters::newFromParameters(
            _inventAccountType,
            _inventTable.ItemId,
            _inventTable.itemGroupId());

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            searchParameters.InventDim_RU = this.inventDim();
        }

        return searchParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePriceRevaluationPhy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes an inventory settlement record to adjust the physical transaction value to a new
    ///    cost.
    /// </summary>
    /// <param name="_inventTable">
    ///    An <c>InventTable</c> buffer.
    /// </param>
    /// <param name="_inventAccountType">
    /// The inventory account type for the variance.
    /// </param>
    /// <param name="_voucher">
    ///    The revaluation voucher.
    /// </param>
    /// <param name="_adjustment">
    ///    The adjustment.
    /// </param>
    /// <param name="_revaluationDate">
    ///    The revaluation date.
    /// </param>
    /// <param name="_inventMovement">
    ///    The movement if the valuation is caused by backdating; optional.
    /// </param>
    /// <param name="_inventTransCurrency">
    ///    Currency type to fetch initialize record.
    /// </param>
    /// <returns>
    ///    An initialized inventory settlement record.
    /// </returns>
    public InventSettlement updatePriceRevaluationPhy(
        InventTable         _inventTable,
        InventAccountType   _inventAccountType,
        Voucher             _voucher,
        CostAmount          _adjustment,
        date                _revaluationDate,
        InventMovement      _inventMovement = null,
        InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        InventCostPriceRevaluationHelper helper = new InventCostPriceRevaluationHelper();
        return helper.updatePriceRevaluationPhy(this, _inventTable, _inventAccountType, _voucher, _adjustment, _revaluationDate, _inventMovement, _inventTransCurrency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSettlementFromCostParameters</Name>
				<Source><![CDATA[
    private void initSettlementFromCostParameters(
        InventSettlement _inventSettlement,
        InventTable      _inventTable,
        InventMovement   _inventMovement)
    {
        if (InventCostDimensionDefaultingSourceFeature::instance().isEnabled())
        {
            CostParameters costParameters = CostParameters::find();
            switch (costParameters.DimensionDefaultingSource)
            {
                case DimensionDefaultingSource::None:
                    _inventSettlement.initFromInventTrans(this, 0);
                    break;
                case DimensionDefaultingSource::Posting:
                    _inventSettlement.initFromInventTrans(this, this.getDefaultDimensionFromLastRevaluation(_inventMovement));
                    break;
                case DimensionDefaultingSource::Table:
                default:
                    _inventSettlement.initFromInventTrans(this, _inventTable.inventDimLinkedDefaultDimension(this.inventDim()));
            }
        }
        else
        {
            _inventSettlement.initFromInventTrans(this, _inventTable.inventDimLinkedDefaultDimension(this.inventDim()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimensionFromLastRevaluation</Name>
				<Source><![CDATA[
    private DimensionDefault getDefaultDimensionFromLastRevaluation(InventMovement _inventMovement)
    {
        if (!_inventMovement)
        {
            InventTransPosting inventTransPosting;
            select firstonly inventTransPosting
                            where inventTransPosting.InventTransOrigin == this.InventTransOrigin;
            return inventTransPosting.DefaultDimension;
        }
        else
        {
            return _inventMovement.defaultDimension();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePriceVarianceFin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an <c>InventSettlement</c> record to compensate an price variance adjustment for a
    /// transaction.
    /// </summary>
    /// <param name="_movement">
    /// The current movement, where an adjustment to a <c>inventTrans</c> record occurred.
    /// </param>
    /// <param name="_inventAccountType">
    /// The inventory account type for the variance.
    /// </param>
    /// <param name="_voucher">
    /// The current voucher that belongs to the adjustment.
    /// </param>
    /// <param name="_postingDate">
    /// The posting date for the adjustment.
    /// </param>
    /// <param name="_varianceAmount">
    /// The variance amount, that should be offset. If no cost amount is passed, the whole adjusted cost amount
    /// (including all the standard cost changes will be considered for creating the offset
    /// <c>inventSettlement</c> record.
    /// </param>
    /// <param name="_inventTransCurrency">
    ///    The currency associated with the transaction.
    /// </param>
    /// <returns>
    /// An <c>inventSettlement</c> record that has the offset amount.
    /// </returns>
    /// <remarks>
    /// If no cost amount is specified, the difference to the standard cost value is used. The additional
    /// settlement, that will be created for a standard cost item is used, to adjust the inventory back
    /// down to the standard cost value.
    /// </remarks>
    public InventSettlement updatePriceVarianceFin(
        InventMovement      _movement,
        InventAccountType   _inventAccountType,
        Voucher             _voucher,
        date                _postingDate,
        CostAmount          _varianceAmount
        , InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        InventSettlement    inventSettlement;

        LedgerPostingType               postingBalanceSheet;
        LedgerDimensionDefaultAccount   accountBalanceSheet;
        DimensionDefault                dimension;
        ItemGroupId                     itemGroupId;
        InventTransPosting              inventTransPosting;

        if (_varianceAmount)
        {
            if (_movement)
            {
                dimension           = _movement.defaultDimension();
                postingBalanceSheet = _movement.postingBalanceSheet();
                accountBalanceSheet = _movement.accountBalanceSheet();
                itemGroupId         = _movement.itemGroupId();
            }
            else
            {
                // Movement was not initialized ==> retrieve the information from inventTransPosting
                inventTransPosting  = this.inventTransPostingFinancial();
                dimension           = inventTransPosting.DefaultDimension;
                postingBalanceSheet = inventTransPosting.PostingType;
                accountBalanceSheet = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(inventTransPosting.LedgerDimension);
                itemGroupId         = InventTable::find(this.ItemId).itemGroupId();
            }

            inventSettlement.initFromInventTrans(this, dimension);
            inventSettlement.CostAmountAdjustment           = _varianceAmount;
            boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
            if (countryRegion_RU)
            {
                inventSettlement.InventTransCurrency_RU     = _inventTransCurrency;
            }
            inventSettlement.TransDate                      = _postingDate;
            inventSettlement.Voucher                        = _voucher;
            inventSettlement.SettleModel                    = InventSettleModel::Adjustment;
            inventSettlement.SettleType                     = InventSettleType::CompleteAdjustment;
            inventSettlement.BalanceSheetPosting            = postingBalanceSheet;
            inventSettlement.BalanceSheetLedgerDimension    = this.getLedgerDimensionFromDefaultAccount(accountBalanceSheet, dimension);
            
            if (InventPostingExtendParm_CN::checkExtendParmEnabled())
            {
                inventSettlement.OperationsLedgerDimension  = this.getLedgerDimensionFromDefaultAccount(
                    InventPosting::itemExtendParm_CN(
                        _inventAccountType,
                        InventPostingExtendParm_CN::constructInventDim(this.inventDim()),
                        this.ItemId,
                        itemGroupId),
                    dimension);
            }
            else
            {
                InventPostingItemLedgerDimensionParameters searchParameters = this.buildItemLedgerDimensionParameter(_inventAccountType);
                searchParameters.ItemGroup = itemGroupId;

                inventSettlement.OperationsLedgerDimension = this.getLedgerDimensionFromDefaultAccount(
                                                                        InventPosting::itemLedgerDimensionFromParameter(searchParameters),
                                                                        dimension);
            }
            
            inventSettlement.OperationsPosting      = InventPosting::accountType2LedgerPostingType(_inventAccountType);

            if (_inventTransCurrency == InventTransCurrency_RU::SecondaryCur)
            {
                this.CostAmountSecCurAdjustment_RU += inventSettlement.CostAmountAdjustment;
            }
            else
            {
                this.CostAmountAdjustment += inventSettlement.CostAmountAdjustment;
            }
        }
        return inventSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePriceVariancePhy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an inventory settlement record that adjusts the physical value of the transaction with a price variance.
    /// </summary>
    /// <param name="_inventMovement">
    /// The inventory movement.
    /// </param>
    /// <param name="_inventAccountType">
    /// The inventory account type for the variance.
    /// </param>
    /// <param name="_varianceAmount">
    /// The variance amount.
    /// </param>
    /// <param name="_inventTransCurrency">
    ///    Currency type to fetch initialize record.
    /// </param>
    /// <returns>
    /// An inventory settlement record.
    /// </returns>
    public InventSettlement updatePriceVariancePhy(
        InventMovement      _inventMovement,
        InventAccountType   _inventAccountType,
        CostAmount          _varianceAmount,
        InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        InventSettlement    inventSettlement;
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        inventSettlement.initFromInventTrans(this, _inventMovement.defaultDimension());
        if (countryRegion_RU)
        {
            inventSettlement.InventTransCurrency_RU     = _inventTransCurrency;
        }
        inventSettlement.CostAmountAdjustment           = _varianceAmount;
        inventSettlement.TransDate                      = this.DatePhysical;
        inventSettlement.Voucher                        = this.VoucherPhysical;
        inventSettlement.SettleModel                    = InventSettleModel::PhysicalValue;
        inventSettlement.SettleType                     = InventSettleType::CompleteAdjustment;
        inventSettlement.BalanceSheetPosting            = _inventMovement.postingPhysical();
        inventSettlement.BalanceSheetLedgerDimension    = this.getLedgerDimensionFromDefaultAccount(_inventMovement.accountPhysical(), _inventMovement.defaultDimension());
        
        if (InventPostingExtendParm_CN::checkExtendParmEnabled())
        {
            inventSettlement.OperationsLedgerDimension = this.getLedgerDimensionFromDefaultAccount(
                InventPosting::itemExtendParm_CN(
                    _inventAccountType,
                    InventPostingExtendParm_CN::constructInventDim(this.inventDim()),
                    _inventMovement.itemId(),
                    _inventMovement.inventTable().itemGroupId()),
                _inventMovement.defaultDimension());
        }
        else
        {
            inventSettlement.OperationsLedgerDimension  = this.getLedgerDimensionFromDefaultAccount(
                InventPosting::itemLedgerDimensionFromParameter(_inventMovement.createInventPostingItemLedgerDimensionParameters(_inventAccountType)),
                _inventMovement.defaultDimension());
        }
        inventSettlement.OperationsPosting      = InventPosting::accountType2LedgerPostingType(_inventAccountType);

        if (_inventTransCurrency == InventTransCurrency_RU::SecondaryCur)
        {
            this.CostAmountSecCurPhysical_RU += inventSettlement.CostAmountAdjustment;
        }
        else
        {
            this.CostAmountPhysical += inventSettlement.CostAmountAdjustment;
        }

        return inventSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>statusReceiptAllowReturnOriginUpdate</Name>
				<Source><![CDATA[
    private boolean statusReceiptAllowReturnOriginUpdate(boolean _orderedOnly)
    {
        if (this.StatusReceipt == StatusReceipt::Ordered)
        {
            return true;
        }
        else if (this.StatusReceipt == StatusReceipt::Registered && !_orderedOnly)
        {
  
            InventMovement movement = this.inventMovement(true);

            if (movement)
            {
                return movement.canLinkToRegisteredReturns();
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReturnOrigin</Name>
				<Source><![CDATA[
    public void updateReturnOrigin()
    {
        if (!this.ReturnInventTransOrigin && !this.orig().ReturnInventTransOrigin)
        {
            return;
        }

        if (this.Qty == this.orig().Qty &&
            this.ReturnInventTransOrigin  == this.orig().ReturnInventTransOrigin)
        {
            return;
        }
        
        if (!this.statusReceiptAllowReturnOriginUpdate(false))
        {
            return;
        }

        InventTrans trans_Orig = this.orig();

        //if we are linking with a registered trans we should not only allow Ordered
        trans_Orig.deleteReturnTransOrigin(this.StatusReceipt == StatusReceipt::Ordered);
        
        this.insertReturnTransOrigin();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSplit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits <c>InventTrans</c> record.
    /// </summary>
    /// <param name="_splitQty">
    /// Inventory quantity to split.
    /// </param>
    /// <param name="_cwQty">
    /// Catch weight quantity to split.
    /// </param>
    /// <param name="_splitLink">
    /// If true, related TransLink_RU records are split too.
    /// </param>
    /// <param name="_splitOnlyReversalLink">
    /// If true, related TransLink_RU records are split only for links where split <c>InventTrans</c> record is reversal.
    /// </param>
    /// <returns>
    /// <c>InventTrans</c> record, the new part of the split <c>InventTrans</c> record.
    /// </returns>
    public InventTrans updateSplit(InventQty  _splitQty, PdsCWInventQty _cwQty = 0, boolean _splitLink = true, boolean _splitOnlyReversalLink = true)
    {
        InventSplitTrans_Remain splitRemain = new InventSplitTrans_Remain();
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            splitRemain.parmSplitLink_RU(_splitLink);
            splitRemain.parmSplitOnlyReversalLink_RU(_splitOnlyReversalLink);
        }
        // </GEERU>

        InventTransUpdateSplitWithPessimisticLockContext context = InventTransUpdateSplitWithPessimisticLockContext::current();

        if (context)
        {
            splitRemain.parmSplitWithPessimisticLock(context.parmSplitWithPessimisticLock());
        }

        return splitRemain.update(this, _splitQty, _cwQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSplitFromCWQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the current <c>InventTrans</c> record to the specified catch weight quantity and creates a new <c>InventTrans</c> record with the remaining quantity.
    /// </summary>
    /// <param name="_cwQty">
    /// A quantity to be split in catch weight unit.
    /// </param>
    /// <param name="_requestedInventQty">
    /// A requested quantity to be split in inventory unit.
    /// </param>
    /// <returns>
    /// The new created <c>InventTrans</c> record.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// If method is called with illegal values.
    /// </exception>
    public InventTrans updateSplitFromCWQty(
        PdsCWInventQty      _cwQty,
        InventQty           _requestedInventQty)
    {
        InventSplitTrans_Remain     splitRemain = new InventSplitTrans_Remain();

        // only split if ratio is below 1
        if (   !this.PdsCWQty
            || _cwQty/this.PdsCWQty > 1
            || sign(_cwQty) != sign(this.PdsCWQty))
        {
            throw error(strFmt("@SYS118115",funcName()));
        }

        return splitRemain.update(
            this,
            PdsCatchWeight::adjustSplitInventQty(
                this.ItemId,
                this.PdsCWQty,
                this.Qty,
                _cwQty,
                _requestedInventQty),
            _cwQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSplitSecCur_RU</Name>
				<Source><![CDATA[
    public InventTrans updateSplitSecCur_RU(InventQty _splitQty)
    {
        return new InventSplitTrans_RemainSecCur_RU().update(this, _splitQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStdCostAdjust</Name>
				<Source><![CDATA[
    public void updateStdCostAdjust(
        CostAmount          _adjustmentNow,
        TransDate           _transDate,
        Voucher             _voucher,
        DimensionDefault    _dimension,
        InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur)
    {
        InventSettlement    inventSettlement;
        AssetId             assetId;
        boolean             mustLookupAssetId = true;
        // <GEERU>
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        inventSettlement.initForStdCostAdjustment();
        inventSettlement.initFromInventTrans(this,_dimension);

        inventSettlement.CostAmountAdjustment = _adjustmentNow;

        if (InventTable::find(this.ItemId).modelGroup().PostOnhandFinancial)
        {
            if (inventSettlement.CostAmountAdjustment < 0)
            {
                inventSettlement.OperationsLedgerDimension = this.accountStdLossLedgerDimension();
                inventSettlement.OperationsPosting = LedgerPostingType::InventStdLoss;
            }
            else
            {
                inventSettlement.OperationsLedgerDimension = this.accountStdProfitLedgerDimension();
                inventSettlement.OperationsPosting = LedgerPostingType::InventStdProfit;
            }

            inventSettlement.BalanceSheetPosting   = this.postingBalanceSheet();

            if (! inventSettlement.BalanceSheetPosting)
            {
                if (this.Qty >= 0)
                {
                    inventSettlement.BalanceSheetPosting = LedgerPostingType::InventReceipt;
                }
                else
                {
                    // find AssetId for current Inventory transaction
                    assetId =   AssetInventTrans::findByInventTransOriginId(this.InventTransOrigin).AssetId;

                    // in case, the AssetId has not been found, we need to set mustLookupAssetId flag to false
                    // to prevent more lookup action for AssetId in this method
                    if (!assetId)
                    {
                        mustLookupAssetId = false;
                    }

                    inventSettlement.BalanceSheetPosting = (assetId) ?
                                                                          LedgerPostingType::InventIssueFixedAsset :
                                                                          LedgerPostingType::InventIssue;
                }
            }

            inventSettlement.BalanceSheetLedgerDimension   = this.accountBalanceSheetLedgerDimension();

            if (! inventSettlement.BalanceSheetLedgerDimension)
            {
                // <GCN>
                if (InventPostingExtendParm_CN::checkExtendParmEnabled())
                {
                    if (this.Qty >= 0)
                    {
                        inventSettlement.BalanceSheetLedgerDimension = this.getLedgerDimensionFromDefaultAccount(
                            InventPosting::itemExtendParm_CN(
                                InventAccountType::InventReceipt,
                                InventPostingExtendParm_CN::constructInventDim(this.inventDim()),
                                this.ItemId));
                    }
                    else
                    {
                        // find AssetId for current Inventory transaction, in case it hasn't been found before.
                        if (!assetId
                            && mustLookupAssetId)
                        {
                            assetId = AssetInventTrans::findByInventTransOriginId(this.InventTransOrigin).AssetId;
                        }

                        if (assetId)
                        {
                            inventSettlement.BalanceSheetLedgerDimension = this.getLedgerDimensionFromDefaultAccount(
                                InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::InventIssueFixedAsset)));
                        }
                        else
                        {
                            inventSettlement.BalanceSheetLedgerDimension = this.getLedgerDimensionFromDefaultAccount(
                                InventPosting::itemExtendParm_CN(
                                    InventAccountType::InventIssue,
                                    InventPostingExtendParm_CN::constructInventDim(this.inventDim()), this.ItemId));
                        }
                    }
                }
                else
                {
                    // </GCN>

                    if (this.Qty >= 0)
                    {
                        inventSettlement.BalanceSheetLedgerDimension = this.getLedgerDimensionFromDefaultAccount(
                            InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::InventReceipt)));
                    }
                    else
                    {
                        // find AssetId for current Inventory transaction, in case it hasn't been found before
                        if (!assetId && mustLookupAssetId)
                        {
                            assetId =   AssetInventTrans::findByInventTransOriginId(this.InventTransOrigin).AssetId;
                        }

                        inventSettlement.BalanceSheetLedgerDimension = (assetId) ?
                            this.getLedgerDimensionFromDefaultAccount(
                                InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::InventIssueFixedAsset))) :
                            this.getLedgerDimensionFromDefaultAccount(
                                InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::InventIssue)));
                    }
                    // <GCN>
                }
                // </GCN>
            }
        }

        inventSettlement.TransDate     = _transDate;
        inventSettlement.Voucher       = _voucher;

        inventSettlement.SettleModel   = InventSettleModel::Adjustment;
        inventSettlement.SettleType    = InventSettleType::CompleteAdjustment;
        // <GEERU>
        if (countryRegion_RU)
        {
            inventSettlement.InventTransCurrency_RU = _inventTransCurrency;
        }
        // </GEERU>

        inventSettlement.insert(inventSettlement.SettleTransId);

        // <GEERU>
        if (!countryRegion_RU
            || (countryRegion_RU
            && _inventTransCurrency == InventTransCurrency_RU::PrimaryCur))
        {
            // </GEERU>
            this.CostAmountAdjustment+= inventSettlement.CostAmountAdjustment;
            // <GEERU>
        }
        else
        {
            this.CostAmountSecCurAdjustment_RU += inventSettlement.CostAmountAdjustment;
        }
        // </GEERU>

        this.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStdCostPriceRevaluationFin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes an inventory settlement record to adjust the financial transaction value to a new
    ///    standard cost.
    /// </summary>
    /// <param name="_inventTable">
    ///    An <c>InventTable</c> buffer.
    /// </param>
    /// <param name="_voucher">
    ///    The revaluation voucher.
    /// </param>
    /// <param name="_adjustment">
    ///    The adjustment.
    /// </param>
    /// <param name="_revaluationDate">
    ///    The revaluation date.
    /// </param>
    /// <param name="_inventMovement">
    ///    The movement if the valuation is caused by backdating; optional.
    /// </param>
    /// <param name="_rounding">
    ///    A Boolean value that determines whether the adjustment is a rounding; optional.
    /// </param>
    /// <param name="_inventTransCurrency">
    ///    The currency associated with the transaction.
    /// </param>
    /// <returns>
    ///    An initialized inventory settlement record.
    /// </returns>
    public InventSettlement updateStdCostPriceRevaluationFin(
        InventTable         _inventTable,
        Voucher             _voucher,
        CostAmount          _adjustment,
        date                _revaluationDate,
        InventMovement      _inventMovement = null,
        boolean             _rounding = false
        , InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        InventCostPriceRevaluationHelper helper = new InventCostPriceRevaluationHelper();
        return helper.updateStdCostPriceRevaluationFin(this, _inventTable, _voucher, _adjustment, _revaluationDate, _inventMovement, _rounding, _inventTransCurrency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStdCostPriceRevaluationPhy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes an inventory settlement record to adjust the physical transaction value to a new
    ///    standard cost.
    /// </summary>
    /// <param name="_inventTable">
    ///    An <c>InventTable</c> buffer.
    /// </param>
    /// <param name="_voucher">
    ///    The revaluation voucher.
    /// </param>
    /// <param name="_adjustment">
    ///    The adjustment.
    /// </param>
    /// <param name="_revaluationDate">
    ///    The revaluation date.
    /// </param>
    /// <param name="_inventMovement">
    ///    The movement if the valuation is caused by backdating; optional.
    /// </param>
    /// <param name="_inventTransCurrency">
    ///    Currency type to fetch initialize record.
    /// </param>
    /// <returns>
    ///    An initialized inventory settlement record.
    /// </returns>
    public InventSettlement updateStdCostPriceRevaluationPhy(
        InventTable         _inventTable,
        Voucher             _voucher,
        CostAmount          _adjustment,
        date                _revaluationDate,
        InventMovement      _inventMovement = null
        , InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        InventCostPriceRevaluationHelper helper = new InventCostPriceRevaluationHelper();
        return helper.updateStdCostPriceRevaluationPhy(this, _inventTable, _voucher, _adjustment, _revaluationDate, _inventMovement
            //<GEERU>
            , _inventTransCurrency
            //</GEERU>
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStdCostPriceVarianceFin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an <c>InventSettlement</c> record to compensate an adjustment for a standard cost
    /// transaction.
    /// </summary>
    /// <param name="_movement">
    /// The current movement, where an adjustment to a <c>inventTrans</c> record occurred.
    /// </param>
    /// <param name="_voucher">
    /// The current voucher that belongs to the adjustment.
    /// </param>
    /// <param name="_postingDate">
    /// The posting date for the adjustment.
    /// </param>
    /// <param name="_costAmount">
    /// The cost amount, that should be offset. If no cost amount is passed, the whole adjusted cost amount
    /// (including all the standard cost changes will be considered for creating the offset
    /// <c>inventSettlement</c> record.
    /// </param>
    /// <param name="_inventTransCurrency">
    /// The type of currency(dual warehouse) for the adjustment.
    /// </param>
    /// <returns>
    /// An <c>inventSettlement</c> record that has the offset amount.
    /// </returns>
    /// <remarks>
    /// If no cost amount is specified, the difference to the standard cost value is used. The additional
    /// settlement, that will be created for a standard cost item is used, to adjust the inventory back
    /// down to the standard cost value.
    /// </remarks>
    public InventSettlement updateStdCostPriceVarianceFin(
        InventMovement  _movement,
        Voucher         _voucher,
        date            _postingDate,
        CostAmount      _costAmount = this.CostAmountPhysical - this.CostAmountPosted - this.CostAmountAdjustment
        , InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        return this.updatePriceVarianceFin(_movement, InventAccountType::InventStdCostRoundingVariance, _voucher, _postingDate, _costAmount
            // <GEERU>
            , _inventTransCurrency
            // </GEERU>
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStdCostPriceVariancePhy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an inventory settlement record that adjusts the physical value of the transaction to standard cost.
    /// </summary>
    /// <param name="_inventMovement">
    /// The inventory movement.
    /// </param>
    /// <param name="_inventTransCurrency">
    ///    Currency type to initialize settlement record.
    /// </param>
    /// <returns>
    /// An inventory settlement record.
    /// </returns>
    public InventSettlement updateStdCostPriceVariancePhy(
        InventMovement  _inventMovement
        , InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        InventSettlement    inventSettlement;
        CostAmount          physicalPriceVariance;

        // <GEERU>
        if (_inventTransCurrency == InventTransCurrency_RU::SecondaryCur)
        {
            physicalPriceVariance = InventModelType_StdCost::stdCostValueSecCur_RU(_inventMovement, this) - this.CostAmountSecCurPhysical_RU;
        }
        else
        {
            // </GEERU>
            physicalPriceVariance = InventModelType_StdCost::stdCostValue(_inventMovement, this) - this.CostAmountPhysical;
            // <GEERU>
        }
        // </GEERU>

        if (physicalPriceVariance)
        {
            inventSettlement = this.updatePriceVariancePhy(_inventMovement,
                                                           InventAccountType::InventStdCostRoundingVariance,
                                                           physicalPriceVariance
                                                           // <GEERU>
                                                           , _inventTransCurrency
                                                           // </GEERU>
                                                           );
        }
        return inventSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSumUp</Name>
				<Source><![CDATA[
    public void updateSumUp(NoYes _always= NoYes::No, boolean _disableCacheForBufferCheck = false, Set _deletedTransactions = null)
    {
        if (this.canSumUpInventoryTransactions(_always, _disableCacheForBufferCheck))
        {
            NoYes updateSum  = NoYes::No;
            boolean isThisBufferUpdatedFinOrPhys = this.isUpdatedFinancial() || this.isUpdatedPhysical();
            boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
            InventTrans buffer;
                
            if (!isThisBufferUpdatedFinOrPhys)
            {
                while select forupdate buffer
                        where buffer.InventTransOrigin  == this.InventTransOrigin
                            &&  buffer.StatusIssue      == this.StatusIssue
                            &&  buffer.StatusReceipt    == this.StatusReceipt
                            &&  buffer.InventDimId      == this.InventDimId
                            &&  buffer.RecId            != this.RecId
                            &&  (buffer.ValueOpen       != InventTransOpen::No
                            || (countryRegion_RU
                            && buffer.ValueOpenSecCur_RU != InventTransOpen::No))
                {
                    if (InventTrans::isInventTransInitialized(buffer) && this.sumUpTryDeleteBuffer(buffer, _deletedTransactions))
                    {
                        updateSum  = NoYes::Yes;
                    }
                }
            }
            else
            {
                InventSettlement    inventSettlement;
                while select forupdate buffer
                        where buffer.InventTransOrigin    == this.InventTransOrigin
                            &&  buffer.StatusIssue        == this.StatusIssue
                            &&  buffer.StatusReceipt      == this.StatusReceipt
                            &&  buffer.InventDimId        == this.InventDimId
                            &&  buffer.RecId              != this.RecId
                            &&  (buffer.ValueOpen         != InventTransOpen::No
                            || (countryRegion_RU
                            && buffer.ValueOpenSecCur_RU  != InventTransOpen::No))
                    notexists join inventSettlement
                        where inventSettlement.TransRecId == buffer.RecId
                {
                    if (InventTrans::isInventTransInitialized(buffer) && this.sumUpTryDeleteBuffer(buffer, _deletedTransactions))
                    {
                        updateSum  = NoYes::Yes;
                    }
                }
            }
            if (updateSum)
            {
                this.update(NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSumUpInventoryTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the inventory transaction can be summed up.
    /// </summary>
    /// <param name = "_always">Determines whether to ignore the automatic addition setting.</param>
    /// <param name = "_disableCacheForBufferCheck">Determines whether the cache should be disabled for
    /// the buffer used to determine whether the <c>InventTrans</c> is initialized.</param>
    /// <returns>true if the inventory transactions can be summed up; otherwise, false.</returns>
    protected boolean canSumUpInventoryTransactions(NoYes _always, boolean _disableCacheForBufferCheck)
    {
        if (this.ValueOpen == InventTransOpen::No)
        {
            return false;
        }

        if (!_always && !InventParameters::find().AddTransact)
        {
            return false;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && this.ValueOpenSecCur_RU == InventTransOpen::No)
        {
            return false;
        }

        if ((!this.isUpdatedFinancial() && !this.isUpdatedPhysical()) || ! this.hasSettlements())
        {
            InventTrans bufferCheck;
            bufferCheck.disableCache(_disableCacheForBufferCheck);
            bufferCheck.selectLocked(false);
            select firstonly RecId from bufferCheck
                where bufferCheck.InventTransOrigin == this.InventTransOrigin
                    &&  bufferCheck.StatusIssue     == this.StatusIssue
                    &&  bufferCheck.StatusReceipt   == this.StatusReceipt
                    &&  bufferCheck.InventDimId     == this.InventDimId
                    &&  bufferCheck.RecId           != this.RecId;

            if (InventTrans::isInventTransInitialized(bufferCheck))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useReturnTransToSyncCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the return origin information should be used to synchronize the cost on a return.
    /// </summary>
    /// <param name="_referenceCategory">
    /// The reference category.
    /// </param>
    /// <returns>
    /// true if the return information should be used to synchronize the cost on the return; otherwise, false.
    /// </returns>
    public boolean useReturnTransToSyncCostPrice(InventTransType _referenceCategory)
    {
        if (!this.ReturnInventTransOrigin)
        {
            return false;
        }

        switch (_referenceCategory)
        {
            case InventTransType::Sales:
            case InventTransType::BOMLine:
            case InventTransType::InventLossProfit:
            case InventTransType::InventTransaction:
            case InventTransType::Project:
            case InventTransType::ProdLine:
            // <GEERU>
            case InventTransType::ProdRelease_RU:
                // </GEERU>
                return true;
            // <GEERU>
            case InventTransType::TransferOrderScrap:
            case InventTransType::TransferOrderShip:
            case InventTransType::TransferOrderReceive:
                return SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]) && this.inventTransOrigin().isInventTransferIssue_RU(_referenceCategory);
            // </GEERU>
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wmsLocationId</Name>
				<Source><![CDATA[
    public display WMSLocationId wmsLocationId()
    {
        return InventDim::find(this.InventDimId).wmsLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wmsOrder</Name>
				<Source><![CDATA[
    public WMSOrder wmsOrder(boolean _forUpdate = false)
    {
        if (this.TransChildType != InventTransChildType::WMSOrder || !this.TransChildRefId)
        {
            throw error("@SYS53719");
        }

        return WMSOrder::find(this.TransChildRefId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>wmsPalletId</Name>
				<Source><![CDATA[
    [SysObsolete('Functionality related to Warehouse Management II is not supported', false, 7\11\2016)]
    public display WMSPalletId wmsPalletId()
    {
        return InventDim::find(this.InventDimId).wmsPalletId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasAnyBackorderIssueTransactions</Name>
				<Source><![CDATA[
    internal static boolean hasAnyBackorderIssueTransactions(
        ItemId        _itemId,
        InventDimId   _inventDimId,
        TransDate     _date   = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        InventDim       inventDimCriteria = InventDim::find(_inventDimId);
        InventDimParm   inventDimParm;
        inventDimParm.initConsistentDimAllGrp();
        
        InventDim       inventDim;
        InventTrans     inventTrans;
        select firstonly forceplaceholders RecId from inventTrans
            where  inventTrans.ItemId           == _itemId
                && inventTrans.StatusReceipt    == StatusReceipt::None
                && inventTrans.StatusIssue      >  StatusIssue::Deducted
                && inventTrans.StatusIssue      <= StatusIssue::QuotationIssue
                && inventTrans.DateExpected     <  _date
            #inventDimExistsJoin(inventTrans.inventDimId, inventDim, inventDimCriteria, inventDimParm);

        return inventTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>backOrderQtyIssue</Name>
				<Source><![CDATA[
    public static InventQty backOrderQtyIssue(
        ItemId        _itemId,
        InventDimId   _inventDimId,
        TransDate     _date   = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        InventDim       inventDim;
        InventDim       inventDimCriteria = InventDim::find(_inventDimId);
        InventDimParm   inventDimParm;
        InventTrans     inventTrans;

        inventDimParm.initConsistentDimAllGrp();

        select forceplaceholders sum(Qty) from inventTrans
            where  inventTrans.ItemId           == _itemId
                && inventTrans.StatusReceipt    == StatusReceipt::None
                && inventTrans.StatusIssue      >  StatusIssue::Deducted
                && inventTrans.StatusIssue      <= StatusIssue::QuotationIssue
                && inventTrans.DateExpected     <  _date
            #inventDimExistsJoin(inventTrans.inventDimId,inventDim,inventDimCriteria,InventDimParm);

        return inventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCostValue</Name>
				<Source><![CDATA[
    public static container calcCostValue(InventTransOriginId _inventTransOriginId)
    {
        InventTrans                         inventTrans;
        InventTransOrigin                   inventTransOrigin;
        InventDimParm                       inventDimParmFinancial;
        InventDimParm                       inventDimParmActive;
        InventQty                           qty;
        CostAmount                          value;
        InventMovement                      movement;
        InventOnhand                        inventOnhand;
        boolean                             first = true;

        while select ItemId from inventTransOrigin
            where inventTransOrigin.RecId   == _inventTransOriginId
            join inventTrans
            where inventTrans.InventTransOrigin    == inventTransOrigin.RecId
             &&  (inventTrans.StatusIssue           > StatusIssue::Sold
             ||   inventTrans.StatusReceipt         > StatusReceipt::Purchased)
        {
            if (first)
            {
                movement = InventMovement::constructNoThrow(inventTrans);
                movement.inventDimGroupSetup().inventDimParmActiveFinancialInventory(inventDimParmFinancial);
                movement.inventDimGroupSetup().inventDimParmActive(inventDimParmActive);
                first = false;
            }

            inventOnhand = InventOnhand::newParametersActive(inventTransOrigin.ItemId, inventTrans.inventDim(), inventDimParmFinancial, inventDimParmActive);

            qty   += inventTrans.Qty;
            value += movement.estimatedFinancialValue(inventTrans, inventOnhand);
        }

        return [qty,value];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCostValueSecCur_RU</Name>
				<Source><![CDATA[
    public static container calcCostValueSecCur_RU(InventTransOriginId _inventTransOriginId)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        InventDimParm       inventDimParmFinancial;
        InventDimParm       inventDimParmActive;
        InventQty           qty;
        CostAmount          value;
        InventMovement      movement;
        InventOnhand        inventOnhand;
        boolean             first = true;

        while select ItemId from inventTransOrigin
            where inventTransOrigin.RecId   == _inventTransOriginId
            join inventTrans
            where inventTrans.InventTransOrigin    == inventTransOrigin.RecId
             &&  (inventTrans.StatusIssue           > StatusIssue::Sold
             ||   inventTrans.StatusReceipt         > StatusReceipt::Purchased)
        {
            if (first)
            {
                movement = InventMovement::constructNoThrow(inventTrans);
                movement.inventDimGroupSetup().inventDimParmActiveFinancialInventory(inventDimParmFinancial);
                movement.inventDimGroupSetup().inventDimParmActive(inventDimParmActive);
                first = false;
            }

            inventOnhand = InventOnhand::newParametersActive(inventTransOrigin.ItemId, inventTrans.inventDim(), inventDimParmFinancial, inventDimParmActive);

            qty   += inventTrans.Qty;
            value += movement.estimatedFinancialValueSecCur_RU(inventTrans, inventOnhand);
        }

        return [qty,value];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTransTypeDoQuarantineMgmt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an inventory transaction type supports the use of quarantine management.
    /// </summary>
    /// <param name="_inventTransType">
    /// The Inventory transaction type that is examined.
    /// </param>
    /// <returns>
    /// A <c>NoYes</c> enumeration value that indicates whether the <c>InventTransType</c> class supports
    /// quarantine management.
    /// </returns>
    public static NoYes canTransTypeDoQuarantineMgmt(InventTransType _inventTransType)
    {
        switch (_inventTransType)
        {
            case InventTransType::TransferOrderScrap       : return NoYes::No;
            case InventTransType::TransferOrderShip        : return NoYes::No;
            case InventTransType::TransferOrderReceive     : return NoYes::No;
            case InventTransType::QuarantineOrder          : return NoYes::No;
            case InventTransType::KanbanEmptied            : return NoYes::No;
            case InventTransType::KanbanJobProcess         : return NoYes::No;
            case InventTransType::KanbanJobWIP             : return NoYes::No;
            case InventTransType::KanbanJobTransferIssue   : return NoYes::No;
            case InventTransType::KanbanJobTransferReceipt : return NoYes::No;
            case InventTransType::KanbanJobPickingList     : return NoYes::No;

            default: return NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existRecId</Name>
				<Source><![CDATA[
    public static boolean existRecId(RecId   _recId)
    {
        return (select firstonly RecId from inventTrans
                    where inventTrans.RecId == _recId
               ).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the random inventory transaction record for a specified <c>InventTransOriginId</c> value.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The <c>InventTransOriginId</c> value of the inventory transaction originator.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    An inventory transaction record for the specified <c>InventTransId</c> value if it exists;
    ///    otherwise, an empty buffer.
    /// </returns>
    public static InventTrans findByInventTransOrigin(
        InventTransOriginId _inventTransOriginId,
        boolean             _forUpdate = false)
    {
        InventTrans   inventTrans;

        if (_inventTransOriginId)
        {
            if (_forUpdate)
            {
                inventTrans.selectForUpdate(_forUpdate);
            }

            select firstonly inventTrans
                where inventTrans.InventTransOrigin == _inventTransOriginId;
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecId</Name>
				<Source><![CDATA[
    public static InventTrans findRecId(
        RecId       _recId,
        boolean     _forUpdate = false)
    {
        InventTrans inventTrans;

        if (_recId)
        {
            inventTrans.selectForUpdate(_forUpdate);

            select firstonly inventTrans
                where inventTrans.RecId == _recId;
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecIdTransOriginId</Name>
				<Source><![CDATA[
    public static InventTrans findRecIdTransOriginId(
        RecId               _recId,
        InventTransOriginId _inventTransOriginId,
        boolean             _forUpdate = false)
    {
        InventTrans inventTrans;

        if (_recId)
        {
            inventTrans.selectForUpdate(_forUpdate);

            select firstonly inventTrans
                where inventTrans.RecId             == _recId
                  &&  inventTrans.InventTransOrigin == _inventTransOriginId;
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransId</Name>
				<Source><![CDATA[
    public static InventTrans findTransId(
        InventTransId   _transId,
        boolean         _forUpdate = false)
    {
        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;

        inventTrans.selectForUpdate(_forUpdate);

        select firstonly inventTrans 
            exists join inventTransOrigin
                where inventTransOrigin.RecId         ==  inventTrans.InventTransOrigin
                   && inventTransOrigin.InventTransId == _transId;

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLatestByTransId</Name>
				<Source><![CDATA[
    internal static InventTrans findLatestByTransId(
        InventTransId   _transId,
        boolean         _forUpdate = false)
    {
        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;

        inventTrans.selectForUpdate(_forUpdate);

        select firstonly inventTrans 
            order by inventTrans.RecId desc
            exists join inventTransOrigin
                where inventTransOrigin.RecId         ==  inventTrans.InventTransOrigin
                   && inventTransOrigin.InventTransId == _transId;

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formSetCaption</Name>
				<Source><![CDATA[
    public static void formSetCaption(FormRun _formRun)
    {
        InventTransRelationType relationType = _formRun.args().parmEnum();

        switch (relationType)
        {
            case InventTransRelationType::InventTransId:
                _formRun.design().caption("@SYS2597");
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasNotReturnedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether there are not returned transactions for an <c>InventTransOrigin</c> table.
    /// </summary>
    /// <param name="_transOriginId">
    /// The origin ID to check.
    /// </param>
    /// <returns>
    /// true if there are not returned transactions; otherwise, false.
    /// </returns>
    public static boolean hasNotReturnedTransactions(InventTransOriginId _transOriginId)
    {
        return (select firstonly RecId from inventTrans
                where inventTrans.InventTransOrigin == _transOriginId
                   && !inventTrans.ReturnInventTransOrigin).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfTrans</Name>
				<Source><![CDATA[
    public static NumberOfRecords numOfTrans(InventTransOriginId _transOriginId)
    {
        return (select count(RecId) from inventTrans
                    where inventTrans.InventTransOrigin == _transOriginId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openTransactionsExist</Name>
				<Source><![CDATA[
    public static boolean openTransactionsExist(ItemId _itemId)
    {
        InventTrans inventTrans;

        return (select firstonly RecId from inventTrans
                    where inventTrans.ItemId        == _itemId
                       && inventTrans.StatusReceipt != StatusReceipt::Purchased
                       && inventTrans.StatusIssue   != StatusIssue::Sold).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyNoWMSIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight quantity that can be issued through a warehouse management order.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// The ID of the inventory transactions originator. It is the primary key on the <c>InventTransOrigin</c> table.
    /// </param>
    /// <returns>
    /// The catch weight quantity not on a warehouse management order yet.
    /// </returns>
    public static PdsCWInventQty pdsCWQtyNoWMSIssue(InventTransOriginId _inventTransOriginId)
    {
        InventTransIdSum    inventTransIdSum;

        inventTransIdSum    = InventTransIdSum::newTransIdNoChildType(_inventTransOriginId);

        return inventTransIdSum.pdsCWEstimatedIssue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyPickedDate</Name>
				<Source><![CDATA[
    public static PdsCWPicked pdsCWQtyPickedDate(
        TransDate           _perDate,
        ItemId              _itemId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm
        )
    {
        InventTrans inventTrans;
        InventDim   inventDim;

        if (_inventDimParm.InventSerialIdFlag
            && _inventDimCriteria.InventSerialId)
        {
            #inventDimSelect(
                inventDim,
                _inventDimCriteria,
                _inventDimParm,
                forceplaceholders tableId from,
                serialIdIdx)
                join sum(PdsCWQty)
                from inventTrans
                where inventTrans.InventDimId    == inventDim.InventDimId
                    && inventTrans.ItemId        == _itemId
                    && inventTrans.StatusReceipt == StatusReceipt::None
                    && inventTrans.StatusIssue   == StatusIssue::Picked
                    && inventTrans.ValueOpen     == InventTransOpen::Yes
                    && inventTrans.DateInvent    >  _perDate;
        }
        else
        {
            select sum(PdsCWQty) from inventTrans
                where inventTrans.ItemId         == _itemId
                    && inventTrans.StatusReceipt == StatusReceipt::None
                    && inventTrans.StatusIssue   == StatusIssue::Picked
                    && inventTrans.ValueOpen     == InventTransOpen::Yes
                    && inventTrans.DateInvent    >  _perDate
            #inventDimExistsJoin(
                inventTrans.InventDimId,
                inventDim,
                _inventDimCriteria,
                _inventDimParm);
        }

        return inventTrans.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyRegisteredDate</Name>
				<Source><![CDATA[
    public static PdsCWRegistered pdsCWQtyRegisteredDate(
        TransDate           _perDate,
        ItemId              _itemId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm
        )
    {
        InventTrans inventTrans;
        InventDim   inventDim;

        if (_inventDimParm.InventSerialIdFlag
            && _inventDimCriteria.InventSerialId)
        {
            #inventDimSelect(
                inventDim,
                _inventDimCriteria,
                _inventDimParm,
                forceplaceholders tableId from,
                serialIdIdx)
                join sum(PdsCWQty)
                from inventTrans
                where inventTrans.InventDimId    == inventDim.InventDimId
                    && inventTrans.ItemId        == _itemId
                    && inventTrans.StatusReceipt == StatusReceipt::Registered
                    && inventTrans.StatusIssue   == StatusIssue::None
                    && inventTrans.ValueOpen     == InventTransOpen::Yes
                    && inventTrans.DateInvent    >  _perDate;
        }
        else
        {
            select sum(PdsCWQty)
                from inventTrans
                where inventTrans.ItemId         == _itemId
                    && inventTrans.StatusReceipt == StatusReceipt::Registered
                    && inventTrans.StatusIssue   == StatusIssue::None
                    && inventTrans.ValueOpen     == InventTransOpen::Yes
                    && inventTrans.DateInvent    >  _perDate
            #inventDimExistsJoin(
                inventTrans.InventDimId,
                inventDim,
                _inventDimCriteria,
                _inventDimParm);
        }

        return inventTrans.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyTotalOrderPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the catch weight pick quantity for the order line.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// The ID of the inventory transactions originator. It is the primary key on the <c>InventTransOrigin</c> table.
    /// </param>
    /// <returns>
    /// The catch weight pick quantity for the order.
    /// </returns>
    public static PdsCWInventQty pdsCWQtyTotalOrderPick(InventTransOriginId _inventTransOriginId)
    {
        InventTransIdSum    inventTransIdSum;

        inventTransIdSum    = InventTransIdSum::newTransOriginId(_inventTransOriginId);

        return inventTransIdSum.pdsCWEstimatedReceipt() + inventTransIdSum.pdsCWRegistered()
             + inventTransIdSum.pdsCWEstimatedIssue() + inventTransIdSum.pdsCWPicked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyTotalWMSOrder</Name>
				<Source><![CDATA[
    public static PdsCWInventQty pdsCWQtyTotalWMSOrder(
        ItemId              _itemId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm
        )
    {
        InventTrans inventTrans;
        InventDim   inventDim;

        if (_inventDimParm.InventSerialIdFlag
            && _inventDimCriteria.InventSerialId)
        {
            #inventDimSelect(
                inventDim,
                _inventDimCriteria,
                _inventDimParm,
                forceplaceholders TableId from,
                serialIdIdx)
            join sum(PdsCWQty)
            from inventTrans
            where inventTrans.InventDimId    == inventDim.InventDimId
                && inventTrans.ItemId         == _itemId
                && inventTrans.StatusReceipt  == StatusReceipt::None
                && (inventTrans.StatusIssue    == StatusIssue::OnOrder
                    || inventTrans.StatusIssue == StatusIssue::ReservOrdered
                    || inventTrans.StatusIssue == StatusIssue::ReservPhysical)
                && inventTrans.ValueOpen      == InventTransOpen::Yes
                && inventTrans.TransChildType == InventTransChildType::WMSOrder;
        }
        else
        {
            select sum(PdsCWQty)
                from inventTrans
                where inventTrans.ItemId          == _itemId
                    && inventTrans.StatusReceipt  == StatusReceipt::None
                    && (inventTrans.StatusIssue   == StatusIssue::OnOrder
                    || inventTrans.StatusIssue    == StatusIssue::ReservOrdered
                    || inventTrans.StatusIssue    == StatusIssue::ReservPhysical)
                    && inventTrans.ValueOpen      == InventTransOpen::Yes
                    && inventTrans.TransChildType == InventTransChildType::WMSOrder
            #inventDimExistsJoin(
                inventTrans.InventDimId,
                inventDim,
                _inventDimCriteria,
                _inventDimParm);
        }

        return inventTrans.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyTotalWMSOrderNotReserved</Name>
				<Source><![CDATA[
    public static PdsCWInventQty pdsCWQtyTotalWMSOrderNotReserved(
        ItemId              _itemId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm
        )
    {
        InventTrans inventTrans;
        InventDim   inventDim;

        if (_inventDimParm.InventSerialIdFlag
            && _inventDimCriteria.InventSerialId)
        {
            #inventDimSelect(inventDim,_inventDimCriteria,_inventDimParm, forceplaceholders tableId from,serialIdIdx)
            join sum(PdsCWQty)
                from inventTrans
                where  inventTrans.InventDimId    == inventDim.InventDimId
                    && inventTrans.ItemId         == _itemId
                    && inventTrans.StatusReceipt  == StatusReceipt::None
                    && inventTrans.StatusIssue    == StatusIssue::OnOrder
                    && inventTrans.ValueOpen      == InventTransOpen::Yes
                    && inventTrans.TransChildType == InventTransChildType::WMSOrder;
        }
        else
        {
            select sum(PdsCWQty)
                from inventTrans
                where  inventTrans.ItemId         == _itemId
                    && inventTrans.StatusReceipt  == StatusReceipt::None
                    && inventTrans.StatusIssue    == StatusIssue::OnOrder
                    && inventTrans.ValueOpen      == InventTransOpen::Yes
                    && inventTrans.TransChildType == InventTransChildType::WMSOrder
            #inventDimExistsJoin(inventTrans.InventDimId,inventDim,_inventDimCriteria,_inventDimParm);
        }

        return inventTrans.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyWMSOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight quantity for a warehouse management order.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// The ID of the inventory transactions originator. It is the primary key on the <c>InventTransOrigin</c> table.
    /// </param>
    /// <returns>
    /// The catch weight quantity for a warehouse management order.
    /// </returns>
    public static PdsCWInventQty pdsCWQtyWMSOrder(InventTransOriginId _inventTransOriginId)
    {
        InventTransIdSum    inventTransIdSum;

        inventTransIdSum    = InventTransIdSum::newTransIdChildType(_inventTransOriginId, InventTransChildType::WMSOrder, '');

        return inventTransIdSum.pdsCWEstimatedReceipt() + inventTransIdSum.pdsCWEstimatedIssue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsItemIdFromTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the item associated with a transaction id.
    /// </summary>
    /// <param name="_transId">
    /// The transaction id of the item to find.
    /// </param>
    /// <returns>
    /// The item id for the transaction.
    /// </returns>
    public static ItemId pdsItemIdFromTransId(InventTransId _transId)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        select firstonly ItemId from inventTrans
            exists join inventTransOrigin
                where inventTransOrigin.RecId         ==  inventTrans.InventTransOrigin
                   && inventTransOrigin.InventTransId == _transId;
        return inventTrans.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalUpdateSign</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the inventory transaction update is physical and the direction.
    /// </summary>
    /// <param name="_afterStatusIssue">
    ///    The <c>StatusIssue</c> enumeration value the update is going towards.
    /// </param>
    /// <param name="_afterStatusReceipt">
    ///    The <c>StatusReceipt</c> enumeration value the update is going towards.
    /// </param>
    /// <param name="_beforeStatusIssue">
    ///    The <c>StatusIssue</c> enumeration value the update is coming from.
    /// </param>
    /// <param name="_beforeStatusReceipt">
    ///    The <c>StatusReceipt</c> enumeration value the update is coming from.
    /// </param>
    /// <returns>
    ///    -1 if the update is physical and the direction is going from physical to estimated.0 if the update
    ///    is not physical.1 if the update is physical and the direction is going from estimated to physical.
    /// </returns>
    public static int physicalUpdateSign(
        StatusIssue     _afterStatusIssue,
        StatusReceipt   _afterStatusReceipt,
        StatusIssue     _beforeStatusIssue,
        StatusReceipt   _beforeStatusReceipt)
    {
        boolean isAfterIncludedInPhysicalInventory = InventTrans::isStatusIncludedInPhysicalInventory(_afterStatusReceipt, _afterStatusIssue);
        boolean isBeforeIncludedInPhysicalInventory = InventTrans::isStatusIncludedInPhysicalInventory(_beforeStatusReceipt, _beforeStatusIssue);

        if (isAfterIncludedInPhysicalInventory && !isBeforeIncludedInPhysicalInventory)
        {
            return 1;
        }
        else if (!isAfterIncludedInPhysicalInventory && isBeforeIncludedInPhysicalInventory)
        {
            return -1;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalStatusUpdateSign</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the inventory transaction update is physical and the direction.
    /// </summary>
    /// <param name="_origInventTrans">
    /// The original <c>InventTrans</c> record before the change.
    /// </param>
    /// <returns>
    ///    -1 if the update is physical and the direction is going from physical to estimated.0 if the update
    ///    is not physical.1 if the update is physical and the direction is going from estimated to physical.
    /// </returns>
    public int physicalStatusUpdateSign(InventTrans _origInventTrans = this.orig())
    {
        return InventTrans::physicalUpdateSign(this.StatusIssue, this.StatusReceipt, _origInventTrans.StatusIssue, _origInventTrans.StatusReceipt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyFinancialOpen</Name>
				<Source><![CDATA[
    public static InventQty qtyFinancialOpen(InventTransOriginId _transOriginId)
    {
        InventTrans         inventTrans;

        select sum(Qty), sum(QtySettled), ValueOpen from inventTrans
            group by ValueOpen
            where inventTrans.InventTransOrigin     == _transOriginId
              &&  inventTrans.ValueOpen             == InventTransOpen::Yes;

        return inventTrans.financialOpenQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyNoWMSIssue</Name>
				<Source><![CDATA[
    public static InventQty qtyNoWMSIssue(InventTransOriginId _inventTransOriginId)
    {
        InventTransIdSum    inventTransIdSum;

        inventTransIdSum    = InventTransIdSum::newTransIdNoChildType(_inventTransOriginId);

        return inventTransIdSum.estimatedIssue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyPickedDate</Name>
				<Source><![CDATA[
    public static InventQtyPicked qtyPickedDate(
        TransDate           _perDate,
        ItemId              _itemId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm)
    {
        InventTrans inventTrans;
        InventDim   inventDim;

        if (_inventDimParm.InventSerialIdFlag && _inventDimCriteria.InventSerialId)
        {
            #inventDimSelect(inventDim,_inventDimCriteria,_inventDimParm,forcePlaceholders tableId from,serialIdIdx)
            join sum(Qty) from inventTrans
                where inventTrans.InventDimId    == inventDim.InventDimId
                   && inventTrans.ItemId         == _itemId
                   && inventTrans.StatusReceipt  == StatusReceipt::None
                   && inventTrans.StatusIssue    == StatusIssue::Picked
                   && inventTrans.ValueOpen      == InventTransOpen::Yes
                   && inventTrans.DateInvent     >  _perDate;
        }
        else
        {
            select sum(Qty) from inventTrans
                where inventTrans.ItemId         == _itemId
                   && inventTrans.StatusReceipt  == StatusReceipt::None
                   && inventTrans.StatusIssue    == StatusIssue::Picked
                   && inventTrans.ValueOpen      == InventTransOpen::Yes
                   && inventTrans.DateInvent     >  _perDate
            #inventDimExistsJoin(inventTrans.InventDimId,inventDim,_inventDimCriteria,_inventDimParm);
        }

        return inventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyRegisteredDate</Name>
				<Source><![CDATA[
    public static InventQtyRegistered qtyRegisteredDate(
        TransDate           _perDate,
        ItemId              _itemId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm)
    {
        InventTrans inventTrans;
        InventDim   inventDim;

        if (_inventDimParm.InventSerialIdFlag && _inventDimCriteria.InventSerialId)
        {
            #inventDimSelect(inventDim,_inventDimCriteria,_inventDimParm,forcePlaceholders tableId from,serialIdIdx)
            join sum(Qty) from inventTrans
                where inventTrans.InventDimId    == inventDim.InventDimId
                   && inventTrans.ItemId         == _itemId
                   && inventTrans.StatusReceipt  == StatusReceipt::Registered
                   && inventTrans.StatusIssue    == StatusIssue::None
                   && inventTrans.ValueOpen      == InventTransOpen::Yes
                   && inventTrans.DateInvent     >  _perDate;
        }
        else
        {
            select sum(Qty) from inventTrans
                where inventTrans.ItemId         == _itemId
                   && inventTrans.StatusReceipt  == StatusReceipt::Registered
                   && inventTrans.StatusIssue    == StatusIssue::None
                   && inventTrans.ValueOpen      == InventTransOpen::Yes
                   && inventTrans.DateInvent     >  _perDate
            #inventDimExistsJoin(inventTrans.InventDimId,inventDim,_inventDimCriteria,_inventDimParm);
        }

        return inventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyTotalOrderPick</Name>
				<Source><![CDATA[
    public static InventQty qtyTotalOrderPick(InventTransOriginId _transOriginId)
    {
        InventTransIdSum    inventTransIdSum;

        inventTransIdSum    = InventTransIdSum::newTransOriginId(_transOriginId);

        return inventTransIdSum.estimatedReceipt() + inventTransIdSum.registered()
             + inventTransIdSum.estimatedIssue() + inventTransIdSum.picked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyTotalWMSOrder</Name>
				<Source><![CDATA[
    public static InventQtyPicked qtyTotalWMSOrder(
        ItemId              _itemId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm)
    {
        InventTrans inventTrans;
        InventDim   inventDim;

        if (_inventDimParm.InventSerialIdFlag && _inventDimCriteria.InventSerialId)
        {
            #inventDimSelect(inventDim,_inventDimCriteria,_inventDimParm,forcePlaceholders tableId from,serialIdIdx)
            join sum(Qty) from inventTrans
                where inventTrans.InventDimId    == inventDim.InventDimId
                  &&  inventTrans.ItemId         == _itemId
                  &&  inventTrans.StatusReceipt  == StatusReceipt::None
                  && (inventTrans.StatusIssue    == StatusIssue::OnOrder
                  ||  inventTrans.StatusIssue    == StatusIssue::ReservOrdered
                  ||  inventTrans.StatusIssue    == StatusIssue::ReservPhysical)
                  &&  inventTrans.ValueOpen      == InventTransOpen::Yes
                  &&  inventTrans.TransChildType == InventTransChildType::WMSOrder;
        }
        else
        {
            select sum(Qty) from inventTrans
                where inventTrans.ItemId         == _itemId
                  &&  inventTrans.StatusReceipt  == StatusReceipt::None
                  && (inventTrans.StatusIssue    == StatusIssue::OnOrder
                  ||  inventTrans.StatusIssue    == StatusIssue::ReservOrdered
                  ||  inventTrans.StatusIssue    == StatusIssue::ReservPhysical)
                  &&  inventTrans.ValueOpen      == InventTransOpen::Yes
                  &&  inventTrans.TransChildType == InventTransChildType::WMSOrder
            #inventDimExistsJoin(inventTrans.InventDimId,inventDim,_inventDimCriteria,_inventDimParm);
        }

        return inventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyTotalWMSOrderNotReserved</Name>
				<Source><![CDATA[
    public static InventQtyPicked qtyTotalWMSOrderNotReserved(
        ItemId              _itemId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm)
    {
        InventTrans inventTrans;
        InventDim   inventDim;

        if (_inventDimParm.InventSerialIdFlag && _inventDimCriteria.InventSerialId)
        {
            #inventDimSelect(inventDim,_inventDimCriteria,_inventDimParm,forcePlaceholders tableId from,serialIdIdx)
            join sum(Qty) from inventTrans
                where inventTrans.InventDimId    == inventDim.InventDimId
                   && inventTrans.ItemId         == _itemId
                   && inventTrans.StatusReceipt  == StatusReceipt::None
                   && inventTrans.StatusIssue    == StatusIssue::OnOrder
                   && inventTrans.ValueOpen      == InventTransOpen::Yes
                   && inventTrans.TransChildType == InventTransChildType::WMSOrder;
        }
        else
        {
            select sum(Qty) from inventTrans
                where inventTrans.ItemId         == _itemId
                   && inventTrans.StatusReceipt  == StatusReceipt::None
                   && inventTrans.StatusIssue    == StatusIssue::OnOrder
                   && inventTrans.ValueOpen      == InventTransOpen::Yes
                   && inventTrans.TransChildType == InventTransChildType::WMSOrder
            #inventDimExistsJoin(inventTrans.InventDimId,inventDim,_inventDimCriteria,_inventDimParm);
        }

        return inventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyWMSOrder</Name>
				<Source><![CDATA[
    public static InventQty qtyWMSOrder(InventTransOriginId    _transOriginId)
    {
        InventTransIdSum    inventTransIdSum;

        inventTransIdSum    = InventTransIdSum::newTransIdChildType(_transOriginId, InventTransChildType::WMSOrder, '');

        return inventTransIdSum.estimatedReceipt() + inventTransIdSum.estimatedIssue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>quantitiesNoWMSIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves a pair of estimated CW and inventory issue quantities, that are not assigned to WMS orders.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///     The ID of transaction originator.
    /// </param>
    /// <returns>
    ///     A container of [InventQty, PdsCWInventQty].
    /// </returns>
    public static container quantitiesNoWMSIssue(InventTransOriginId _inventTransOriginId)
    {
        InventTransIdSum    inventTransIdSum = InventTransIdSum::newTransIdNoChildType(_inventTransOriginId);

        return [inventTransIdSum.estimatedIssue(), inventTransIdSum.pdsCWEstimatedIssue()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryAddHintFromCaller</Name>
				<Source><![CDATA[
    public static void queryAddHintFromCaller(QueryBuildDataSource _qbs,Args _callerArgs)
    {
        switch (_callerArgs.dataset())
        {
            case(tableNum(InventBatch)):
            case(tableNum(InventSerial)):
            case(tableNum(WMSLocation)):
                _qbs.addSortIndex(indexNum(InventTrans,DimIdIdx));
                _qbs.indexIsHint(true);
                break;

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryOpenTrans</Name>
				<Source><![CDATA[
    public static Query queryOpenTrans(ItemId _itemId)
    {
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;
        QueryBuildDataSource    queryBuildDataSourceDim;

        query = new Query();
        queryBuildDataSource = query.addDataSource(tableNum(InventTrans));
        queryBuildDataSourceDim = queryBuildDataSource.addDataSource(tableNum(InventDim));
        queryBuildDataSourceDim.relations(true);

        queryBuildDataSource.addRange(fieldNum(InventTrans,ItemId)).value(queryValue(_itemId));
        queryBuildDataSource.addRange(fieldNum(InventTrans,StatusReceipt)).value(SysQuery::valueNot(StatusReceipt::Purchased));
        queryBuildDataSource.addRange(fieldNum(InventTrans,StatusIssue)).value(SysQuery::valueNot(StatusIssue::Sold));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionsExist</Name>
				<Source><![CDATA[
    public static boolean transactionsExist(ItemId _itemId)
    {
        return (select firstonly RecId from inventTrans
                    where inventTrans.ItemId        == _itemId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionOpenExistForSymbol</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether open transactions exist for a unit of measure symbol.
    /// </summary>
    /// <param name="_symbol">
    ///    The symbol of the unit of measure that should be validated.
    /// </param>
    /// <returns>
    ///    true if open transactions exist for the symbol; otherwise, false.
    /// </returns>
    public static boolean transactionOpenExistForSymbol(UnitOfMeasureSymbol _symbol)
    {
        InventTrans         inventTrans;
        InventTableModule   inventTableModule;
                
        select firstonly crosscompany RecId from inventTableModule
            where inventTableModule.UnitId == _symbol
                && inventTableModule.ModuleType == ModuleInventPurchSales::Invent
            exists join inventTrans
                where inventTrans.ItemId == inventTableModule.ItemId
                    && inventTrans.ValueOpen == InventTransOpen::Yes;
        
        return inventTableModule.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateChangeToEstimated</Name>
				<Source><![CDATA[
    public static void updateChangeToEstimated(InventUpdate _inventUpdate)
    {
        InventTrans     inventTrans;

        ttsbegin;

        while select forupdate inventTrans
            where inventTrans.InventTransOrigin == _inventUpdate.movement().inventTransOriginId()
             &&  (inventTrans.StatusReceipt     == StatusReceipt::QuotationReceipt
             ||   inventTrans.StatusIssue       == StatusIssue::QuotationIssue)
        {
            if (inventTrans.StatusReceipt== StatusReceipt::QuotationReceipt)
            {
                inventTrans.StatusReceipt= StatusReceipt::Ordered;
                inventTrans.update();
            }
            else if (inventTrans.StatusIssue == StatusIssue::QuotationIssue)
            {
                inventTrans.StatusIssue= StatusIssue::OnOrder;
                inventTrans.update();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateChangeToQuotation</Name>
				<Source><![CDATA[
    public static void updateChangeToQuotation(InventUpdate _inventUpdate)
    {
        InventTrans             inventTrans;
        InventOnHandQty         inventOnHandQty;
        InventTransOrigin       markingRefInventTransOrigin;
        boolean                 anyTransUpdated = false;
        ttsbegin;

        while select forupdate inventTrans
            where inventTrans.InventTransOrigin == _inventUpdate.movement().inventTransOriginId()
               && inventTrans.StatusReceipt     == StatusReceipt::Ordered
               && inventTrans.StatusIssue       == StatusIssue::None
        {
            inventOnHandQty = InventOnHandQty::newPhysicalInvent(_inventUpdate.movement(),inventTrans.inventDim());
            inventOnHandQty.addDepreciateOrderedCheck(_inventUpdate.parmAllowNegativePhysical());

            inventTrans.StatusReceipt= StatusReceipt::QuotationReceipt;
            markingRefInventTransOrigin = InventTransOrigin::find(inventTrans.MarkingRefInventTransOrigin);
            if (!markingRefInventTransOrigin || !markingRefInventTransOrigin.ReferenceId)
            {
                inventTrans.clearMarking();
            }
            inventTrans.update();
            anyTransUpdated = true;
        }

        while select forupdate inventTrans
            where inventTrans.InventTransOrigin == _inventUpdate.movement().inventTransOriginId()
               && inventTrans.StatusReceipt     == StatusReceipt::None
               && inventTrans.StatusIssue       >= StatusIssue::ReservPhysical
               && inventTrans.StatusIssue       <= StatusIssue::OnOrder
        {
            if (inventTrans.StatusIssue== StatusIssue::ReservPhysical)
            {
                _inventUpdate.updateDimReservePhysical(InventDim::find(inventTrans.InventDimId),-inventTrans.Qty);
            }

            inventTrans.StatusIssue= StatusIssue::QuotationIssue;
            markingRefInventTransOrigin = InventTransOrigin::find(inventTrans.MarkingRefInventTransOrigin);
            if (!markingRefInventTransOrigin || !markingRefInventTransOrigin.ReferenceId)
            {
                inventTrans.clearMarking();
            }
            inventTrans.update();
            anyTransUpdated = true;
        }

        if (anyTransUpdated && _inventUpdate.movement().isItemWHSEnabled())
        {
            _inventUpdate.movement().checkWHSLoadLineInventTransConsistency();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventRefFields</Name>
				<Source><![CDATA[
    public static void updateInventRefFields(
        Map             _mapMovement,
        ReqMarkUpdate   _updateMethod = ReqMarkUpdate::Standard)
    {
        InventMovement      movement;
        InventMovement      movementRef;

        MapIterator         mi;

        InventQty           qtyMarked;
        Integer             numOfMarked;
        InventTransOriginId markedOriginId;

        if ( _updateMethod == ReqMarkUpdate::No)
        {
            return;
        }

        ttsbegin;

        if (_mapMovement)
        {
            mi   = new MapIterator(_mapMovement);
            mi.begin();
            while (mi.more())
            {
                movement = _mapMovement.lookup(mi.key());
                if (movement)
                {
                    if (movement.buffer() != null)
                    {
                        movement.buffer().reread();
                    }

                    [numOfMarked,qtyMarked,markedOriginId] = InventTransOrigin::numOfMarkedTransOrigin(movement.inventTransOriginId());

                    switch (true)
                    {
                        case (_updateMethod == ReqMarkUpdate::Standard || _updateMethod == ReqMarkUpdate::SingleLevelStandard) && numOfMarked == 1 && abs(qtyMarked) >= abs(movement.transQty()):
                        case (_updateMethod == ReqMarkUpdate::Extended || _updateMethod == ReqMarkUpdate::SingleLevelExtended) && numOfMarked == 1:
                            // update inventRefFields
                            if (_mapMovement.exists(markedOriginId))
                            {
                                movementRef = _mapMovement.lookup(markedOriginId);
                            }
                            else
                            {
                                movementRef = null;
                            }

                            if (movementRef && movement.markingRefInventTransOrigin() != movementRef.inventTransOriginId())
                            {
                                if (movementRef && movement.setInventRefFields(movementRef.transInventRefType(), movementRef.transRefId(), movementRef.inventTransOriginId()))
                                {
                                    movement.updateDoBuffer();
                                }
                            }
                            break;

                        default:
                            movement.clearInventRefFields();
                            break;
                    }
                }
                mi.next();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkReqTransCov</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Marks inventory transactions according to how the coverage is performed.
    /// </summary>
    /// <param name="_reqTrans">
    ///    A <c>ReqTrans</c> record.
    /// </param>
    /// <param name="_reqMarkUpdate">
    ///    An enumeration value that specifies how marking is performed.
    /// </param>
    /// <returns>
    ///    A real value that holds the marked quantity.
    /// </returns>
    public static InventQty updateMarkReqTransCov(
        ReqTrans        _reqTrans,
        ReqMarkUpdate   _reqMarkUpdate = ReqMarkUpdate::Standard)
    {
        if (_reqTrans.canBeMarked(_reqMarkUpdate))
        {
            return _reqTrans.markCoverage(_reqMarkUpdate);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>viewCacheBufferFromInventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an <c>InventTrans</c> record ready to be used with the <c>RecordViewCache></c> class.
    /// </summary>
    /// <param name = "_inventTransOriginId">The InventTransOriginId to scope the cache for.</param>
    /// <param name = "_forupdate">A Boolean indicating if the record should be selected for update; optional.</param>
    /// <returns>An <c>InventTrans</c> record.</returns>
    public static InventTrans viewCacheBufferFromInventTransOriginId(InventTransOriginId _inventTransOriginId, boolean _forupdate = false)
    {
        InventTrans inventTrans;
        inventTrans.selectForUpdate(_forupdate);
        select nofetch inventTrans where inventTrans.InventTransOrigin == _inventTransOriginId;
        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventSerialIdOrdered</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the serial Id from the inventory transactions.
    /// </summary>
    /// <param name="_itemId">
    /// The item id to look for.
    /// </param>
    /// <param name="_inventTransId">
    /// The Id of the inventory transaction to look for.
    /// </param>
    /// <returns>
    /// The serial Id associated with the inventory transaction which has been looked up.
    /// </returns>
    public static InventSerialId getInventSerialIdOrdered(
            ItemId              _itemId,
            InventTransId       _inventTransId)
    {
        InventDim           inventDim;
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        select firstonly InventSerialId from inventDim
            where inventDim.inventSerialId != ''
            exists join inventTrans
                where inventTrans.ItemId == _itemId
                    && inventTrans.StatusReceipt == StatusReceipt::Ordered
                    && inventTrans.InventDimId == inventDim.InventDimId
            exists join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                    && inventTransOrigin.InventTransId == _inventTransId;

        return inventDim.InventSerialId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFixBatchNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check and fix blank batch number issue that caused by the bug 3638345.
    /// </summary>
    /// <param name="_inventConsistencyCheck_Trans">
    ///     InventConsistencyCheck_Trans object parameter
    /// </param>
    /// <param name="_inventTransOrigin">
    ///     InventTransOrigin record parameter
    /// </param>
    public void checkFixBatchNumber(
        InventConsistencyCheck_Trans    _inventConsistencyCheck_Trans,
        InventTransOrigin               _inventTransOrigin)
    {
        InventDim                            inventDim = this.inventDim();
        InventDim                            inventDimTransfer;
        InventTrans                          inventTransTransfer;
        InventTransOrigin                    inventTransOriginTransfer;
        WHSWorkTable                         workTable;
        WHSWorkInventTrans                   workInventTrans;

        if ((this.StatusIssue      == StatusIssue::Sold
                 || this.StatusReceipt == StatusReceipt::Purchased)
                && !inventDim.inventBatchId
                && _inventTransOrigin.ReferenceCategory == InventTransType::WHSWork
                && InventTable::find(this.ItemId).isItemBatchActivated())

        {
            select firstonly inventBatchId from inventDimTransfer
                        where inventDimTransfer.inventBatchId
                            exists join workTable
                                where workTable.WorkId                                     == _inventTransOrigin.ReferenceId
                                    && workTable.WorkTransType                             == WHSWorkTransType::TransferReceipt
                                    && workTable.WorkStatus                                == WHSWorkStatus::Closed
                            exists join workInventTrans
                                where workInventTrans.WorkId                               == workTable.WorkId
                                    && (workInventTrans.InventTransIdFrom                  == _inventTransOrigin.InventTransId
                                    || workInventTrans.InventTransIdTo                 == _inventTransOrigin.InventTransId)
                            exists join inventTransTransfer
                                where inventTransTransfer.ItemId                           == this.ItemId
                                    && inventTransTransfer.inventDimId                     == inventDimTransfer.inventDimId
                            exists join inventTransOriginTransfer
                                where inventTransOriginTransfer.RecId                      == inventTransTransfer.InventTransOrigin
                                    && inventTransOriginTransfer.ItemId                    == this.ItemId
                                    && inventTransOriginTransfer.ReferenceCategory         == InventTransType::TransferOrderShip
                                    && inventTransOriginTransfer.ReferenceId               == workTable.OrderNum
                                    && inventTransOriginTransfer.InventTransId             == workInventTrans.InventTransIdParent;

            if (inventDimTransfer.inventBatchId)
            {
                checkFailed(strFmt("@SYS89866", "@SYS53635"), '', SysInfoAction_TableField::newBufferField(this, fieldNum(InventTrans, InventDimId)));
                if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)

                {
                    inventDim.inventBatchId = inventDimTransfer.inventBatchId;
                    inventDim = InventDim::findOrCreate(inventDim);
                    this.inventDimId = inventDim.inventDimId;
                    this.update();

                    _inventConsistencyCheck_Trans.updateCorrected();
                }
                else
                {
                    _inventConsistencyCheck_Trans.updateNotCorrected();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFixChildReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check and fix an orphan transaction's child reference if a related document no longer exists or posted
    /// </summary>
    /// <param name="_inventConsistencyCheck_Trans">
    ///     An instance of the <c>InventConsistencyCheck_Trans</c> class.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///     An origin of the transaction
    /// </param>
    [Hookable(false)]
    internal void checkFixChildReference(InventConsistencyCheck_Trans _inventConsistencyCheck_Trans,
                                         InventTransOrigin            _inventTransOrigin)
    {
        if (this.TransChildType == InventTransChildType::None || !this.TransChildRefId)
        {
            return;
        }

        if (this.hasOrphanChildReference())
        {
            checkFailed(strFmt("@SCM:OrphanChildReferenceDetected", _inventTransOrigin.InventTransId));
            if (_inventConsistencyCheck_Trans.checkFix() == CheckFix::Fix)
            {
                this.clearChildReference();
                _inventConsistencyCheck_Trans.updateCorrected();
            }
            else
            {
                _inventConsistencyCheck_Trans.updateNotCorrected();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearChildReference</Name>
				<Source><![CDATA[
    [Hookable(false), Wrappable(false)]
    public void clearChildReference()
    {
        this.TransChildType  = InventTransChildType::None;
        this.TransChildRefId = '';
        this.doUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasOrphanChildReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check if inventory transaction holds a child reference despite the fact that related document is deleted or posted.
    /// </summary>
    /// <returns>
    ///     True if a damaged child reference is found; otherwise false
    /// </returns>
    [Hookable(false)]
    public boolean hasOrphanChildReference()
    {
        boolean hasOrphanChildReference = false;

        switch (this.TransChildType)
        {
            case InventTransChildType::WMSOrder:
                WMSOrder wmsOrder = this.wmsOrder();

                if (!wmsOrder.RecId)
                {
                    hasOrphanChildReference = true;
                }
                else if (wmsOrder.status == WMSOrderStatus::Complete && 
						 this.isAllWMSOrderTransFinished())
                {
                    hasOrphanChildReference = true;
                }
                break;

            case InventTransChildType::ProdJournalBOM:
                ProdJournalBOM prodJournalBOM = this.prodJournalBOM();

                if (!prodJournalBOM.RecId)
                {
                    hasOrphanChildReference = true;
                }
                else
                {
                    ProdJournalTable prodJournalTable = ProdJournalTable::find(prodJournalBOM.JournalId);
                    if (prodJournalTable.Posted == NoYes::Yes)
                    {
                        hasOrphanChildReference = true;
                    }
                }
                break;

            case InventTransChildType::ProdJournalProd:
                ProdJournalProd prodJournalProd = this.prodJournalProd();

                if (!prodJournalProd.RecId)
                {
                    hasOrphanChildReference = true;
                }
                else
                {
                    ProdJournalTable prodJournalTable = ProdJournalTable::find(prodJournalProd.JournalId);
                    if (prodJournalTable.Posted == NoYes::Yes)
                    {
                        hasOrphanChildReference = true;
                    }
                }
                break;

            default:
                break;
        }

        return hasOrphanChildReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOrphanChildReferenceForOutputOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether there is an orphan child reference for output order.
    /// </summary>
    /// <returns>
    /// Return true if there is an orphan child reference; otherwise false.
    /// </returns>
    public boolean checkOrphanChildReferenceForOutputOrder()
    {
        if (this.TransChildType == InventTransChildType::WMSOrder && this.TransChildRefId != '')
        {
            return this.hasOrphanChildReference();
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory transaction quantity.
    /// </summary>
    /// <param name = "_mustAggregtateTransactions">Whether transactions must be aggregated.</param>
    /// <param name = "_qty">An inventory transaction quantity.</param>
    /// <param name = "_cwQty">An inventory transaction CW quantity.</param>
    public void updateQty(boolean _mustAggregateTransactions, InventQty _qty, PdsCWInventQty _cwQty)
    {
        if (_mustAggregateTransactions)
        {
            this.Qty += _qty;
        }
        else
        {
            this.Qty = _qty;
        }

        this.PdsCWQty = _cwQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventTransArchive</Name>
				<Source><![CDATA[
    public void initFromInventTransArchive(InventTransArchive _inventTransArchive)
    {
        this.Recid = _inventTransArchive.InventTrans;
        this.ActivityNumber = _inventTransArchive.ActivityNumber;
        this.CostAmountAdjustment = _inventTransArchive.CostAmountAdjustment;
        this.CostAmountOperations = _inventTransArchive.CostAmountOperations;
        this.CostAmountPhysical = _inventTransArchive.CostAmountPhysical;
        this.CostAmountPosted = _inventTransArchive.CostAmountPosted;
        this.CostAmountSecCurAdjustment_RU = _inventTransArchive.CostAmountSecCurAdjustment_RU;
        this.CostAmountSecCurPhysical_RU = _inventTransArchive.CostAmountSecCurPhysical_RU;
        this.CostAmountSecCurPosted_RU = _inventTransArchive.CostAmountSecCurPosted_RU;
        this.CostAmountSettled = _inventTransArchive.CostAmountSettled;
        this.CostAmountSettledSecCur_RU = _inventTransArchive.CostAmountSettledSecCur_RU;
        this.CostAmountStd = _inventTransArchive.CostAmountStd;
        this.CostAmountStdSecCur_RU = _inventTransArchive.CostAmountStdSecCur_RU;
        this.CurrencyCode = _inventTransArchive.CurrencyCode;
        this.DateClosed = _inventTransArchive.DateClosed;
        this.DateClosedSecCur_RU = _inventTransArchive.DateClosedSecCur_RU;
        this.DateExpected = _inventTransArchive.DateExpected;
        this.DateFinancial = _inventTransArchive.DateFinancial;
        this.DateInvent = _inventTransArchive.DateInvent;
        this.DatePhysical = _inventTransArchive.DatePhysical;
        this.DateStatus  = _inventTransArchive.DateStatus;
        this.GroupRefId_RU = _inventTransArchive.GroupRefId_RU;
        this.GroupRefType_RU = _inventTransArchive.GroupRefType_RU;
        this.InterCompanyInventDimTransferred = _inventTransArchive.InterCompanyInventDimTransferred;
        this.InventDimFixed = _inventTransArchive.InventDimFixed;
        this.InventDimId = _inventTransArchive.InventDimId;
        this.InventDimIdSales_RU = _inventTransArchive.InventDimIdSales_RU;
        this.InventTransOrigin = _inventTransArchive.InventTransOrigin;
        this.InventTransOriginDelivery_RU  = _inventTransArchive.InventTransOriginDelivery_RU;
        this.InventTransOriginSales_RU = _inventTransArchive.InventTransOriginSales_RU;
        this.InventTransOriginTransit_RU = _inventTransArchive.InventTransOriginTransit_RU;
        this.InvoiceId = _inventTransArchive.InvoiceId;
        this.InvoiceReturned = _inventTransArchive.InvoiceReturned;
        this.ItemId = _inventTransArchive.ItemId;
        this.MarkingRefInventTransOrigin = _inventTransArchive.MarkingRefInventTransOrigin;
        this.PackingSlipId = _inventTransArchive.PackingSlipId;
        this.PackingSlipReturned = _inventTransArchive.PackingSlipReturned;
        this.PdsCWQty = _inventTransArchive.PdsCWQty;
        this.PdsCWSettled = _inventTransArchive.PdsCWSettled;
        this.PickingRouteID = _inventTransArchive.PickingRouteID;
        this.ProjAdjustRefId = _inventTransArchive.ProjAdjustRefId;
        this.ProjCategoryId = _inventTransArchive.ProjCategoryId;
        this.ProjId = _inventTransArchive.ProjId;
        this.Qty = _inventTransArchive.Qty;
        this.QtySettled  = _inventTransArchive.QtySettled;
        this.QtySettledSecCur_RU = _inventTransArchive.QtySettledSecCur_RU;
        this.ReturnInventTransOrigin = _inventTransArchive.ReturnInventTransOrigin;
        this.RevenueAmountPhysical = _inventTransArchive.RevenueAmountPhysical;
        this.ShippingDateConfirmed = _inventTransArchive.ShippingDateConfirmed;
        this.ShippingDateRequested  = _inventTransArchive.ShippingDateRequested;
        this.StatusIssue = _inventTransArchive.StatusIssue;
        this.StatusReceipt = _inventTransArchive.StatusReceipt;
        this.Storno_RU = _inventTransArchive.Storno_RU;
        this.StornoPhysical_RU = _inventTransArchive.StornoPhysical_RU;
        this.TaxAmountPhysical = _inventTransArchive.TaxAmountPhysical;
        this.TimeExpected = _inventTransArchive.TimeExpected;
        this.TransChildRefId = _inventTransArchive.TransChildRefId;
        this.TransChildType = _inventTransArchive.TransChildType;
        this.ValueOpen = _inventTransArchive.ValueOpen;
        this.ValueOpenSecCur_RU = _inventTransArchive.ValueOpenSecCur_RU;
        this.Voucher  = _inventTransArchive.Voucher;
        this.VoucherPhysical = _inventTransArchive.VoucherPhysical;
        this.NonFinancialTransferInventClosing = _inventTransArchive.NonFinancialTransferInventClosing;
        this.LoadId = _inventTransArchive.LoadId;
        this.ReceiptId = _inventTransArchive.ReceiptId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFinancialInventDimUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prevent update of financial dimensions after cost has been calculated.
    /// </summary>
    private void validateFinancialInventDimUpdate()
    {
        if (CostInventTransFinancialInventDimUpdateValidationSkipSingleton::instance().parmSkip())
        {
            return;
        }

        InventTrans orig = this.orig();

        if (orig.StatusIssue <= StatusIssue::Deducted
            && orig.StatusReceipt <= StatusReceipt::Received
            && this.InventDimId != orig.InventDimId)
        {
            InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(this.ItemId);
            if (!InventDim::isInventDimEqualFinancialDim(inventDimGroupSetup, this.inventDim(), orig.inventDim()))
            {
                warning(strFmt("@SCM:MessageError_InventTransFinancialInventDimUpdate", this.RecId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowExceptionOnZeroDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if concurrent deletes should throw exception.
    /// </summary>
    /// <returns>true if exception should be thrown; otherwise false.</returns>
    [Hookable(false)]
    public boolean shouldThrowExceptionOnZeroDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllWMSOrderTransFinished</Name>
				<Source><![CDATA[
    private boolean isAllWMSOrderTransFinished()
    {
        if (this.TransChildType != InventTransChildType::WMSOrder || !this.TransChildRefId)
        {
            throw error("@SYS53719");
        }
        
        WMSOrderTrans     wmsOrderTrans;
        InventTransOrigin inventTransOrigin;
        select firstonly RecId from wmsOrderTrans
            where wmsOrderTrans.OrderId  == this.TransChildRefId
                && wmsOrderTrans.ExpeditionStatus != WMSExpeditionStatus::Complete
                && wmsOrderTrans.ExpeditionStatus != WMSExpeditionStatus::Cancelled
            exists join inventTransOrigin
            where inventTransOrigin.RecId == this.InventTransOrigin
               && inventTransOrigin.InventTransId == wmsOrderTrans.InventTransId;

        return wmsOrderTrans.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>FindPreSTDItemPrice</Name>
				<Source><![CDATA[
    public InventItemPrice FindPreSTDItemPrice()
    {
        InventItemPrice currentInventItemPrice = InventItemPrice::findCurrent(this.ItemId, CostingVersionPriceType::Cost, InventTable::priceInventDim(this.ItemId, this.inventDim()), dateMax());
        
        return InventItemPrice::stdCostFindPrev(this.ItemId,
                                                currentInventItemPrice.InventDimId,
                                                currentInventItemPrice.CreatedDateTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>SAFInventoryDocumentDate_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// DataWZ should be set to the packing slip document date, otherwise to the packing slip date (Condition: document date = null).
    /// DataPZ should be set to the product receipt document date, otherwise to the product receipt date (Condition: document date = null).
    /// </summary>
    /// <returns>
    /// Returns the document date node in Standard Audit File model mapping file.
    /// </returns>
    public DocumentDate SAFInventoryDocumentDate_PL()
    {
        InventTransOrigin inventTransOrigin = this.inventTransOrigin();
        DocumentDate documentDate;

        switch (inventTransOrigin.ReferenceCategory)
        {
            case InventTransType::Purch:
                VendPackingSlipJour vendPackingSlipJour = VendPackingSlipTrans::findInventTransId_RU(inventTransOrigin.InventTransId).vendPackingslipJour();
                documentDate = vendPackingSlipJour.DocumentDate ? vendPackingSlipJour.DocumentDate : this.DatePhysical;
                break;

            case InventTransType::Sales:
                CustPackingSlipJour custPackingSlipJour = CustPackingSlipTrans::findInventTransId_RU(inventTransOrigin.InventTransId).custPackingslipJour();
                documentDate = custPackingSlipJour.DocumentDate ? custPackingSlipJour.DocumentDate : this.DatePhysical;
                break;

            default:
                documentDate = dateNull();
        }
        return documentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>SAFInventoryInvocieDate_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// DataFaWZ should be set to the customer invoice journal document date, otherwise to the customer invoice date (Condition: document date = null).
    /// DataFaPZ should be set to the vendor invoice journal document date, otherwise to the vendor invoice date (Condition: document date = null).
    /// </summary>
    /// <returns>
    /// Returns the invoice date node in Standard Audit File model mapping file.
    /// </returns>
    public InvoiceDate SAFInventoryInvocieDate_PL()
    {
        InventTransOrigin inventTransOrigin = this.inventTransOrigin();
        InvoiceDate invoiceDate;

        switch (inventTransOrigin.ReferenceCategory)
        {
            case InventTransType::Purch:
                VendInvoiceJour vendInvoiceJour = VendInvoiceTrans::findInventTransId(inventTransOrigin.InventTransId).vendInvoiceJour();
                invoiceDate = vendInvoiceJour.DocumentDate ? vendInvoiceJour.DocumentDate : vendInvoiceJour.InvoiceDate;
                break;

            case InventTransType::Sales:
                CustInvoiceJour custInvoiceJour = CustInvoiceTrans::findInventTransid(inventTransOrigin.InventTransId).custInvoiceJour();
                invoiceDate = custInvoiceJour.DocumentDate ? custInvoiceJour.DocumentDate : custInvoiceJour.InvoiceDate;
                break;

            default:
                invoiceDate = dateNull();
        }
        return invoiceDate;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<ConfigurationKey>LogisticsBasic</ConfigurationKey>
	<DeveloperDocumentation>@SYS123850</DeveloperDocumentation>
	<FormRef>InventTrans</FormRef>
	<Label>@SYS1286</Label>
	<TableGroup>Transaction</TableGroup>
	<TitleField1>InventTransOrigin</TitleField1>
	<TitleField2>ItemId</TitleField2>
	<AllowRowVersionChangeTracking>Yes</AllowRowVersionChangeTracking>
	<ClusteredIndex>TransOriginIdx</ClusteredIndex>
	<DisableLockEscalation>Yes</DisableLockEscalation>
	<ModifiedDateTime>Yes</ModifiedDateTime>
	<Modules>Inventory</Modules>
	<PrimaryIndex>RecId</PrimaryIndex>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DatePhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateFinancial</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StatusReceipt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StatusIssue</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountPosted</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Delivery</Name>
			<Label>@SYS4508</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ShippingDateRequested</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShippingDateConfirmed</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>FinancialUpdate</Name>
			<Label>@SYS23900</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DateFinancial</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountPosted</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountAdjustment</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountSecCurPosted_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountSecCurAdjustment_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountOperations</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>unpostedInvoiceId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GoodsInRoute_RU</Name>
			<Label>@GLS114756</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventDimIdSales_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransOriginSales_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransOriginTransit_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransOriginDelivery_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>GroupRef_RU</Name>
			<Label>@GLS114976</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>GroupRefType_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GroupRefId_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Identification</Name>
			<Label>@SYS5711</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Inventory</Name>
			<Label>@SYS981</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>InventTransOrigin</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MarkingRefInventTransOrigin</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>inventDimId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Other</Name>
			<Label>@SYS1284</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>inventDimFixed</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransOrigin</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReturnInventTransOrigin</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MarkingRefInventTransOrigin</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>PhysicalUpdate</Name>
			<Label>@SYS23899</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DatePhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VoucherPhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PickingRouteID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PackingSlipId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountPhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountSecCurPhysical_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RevenueAmountPhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Posting</Name>
			<Label>@SYS12896</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>StatusReceipt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StatusIssue</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValueOpen</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValueOpenSecCur_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>inventUnit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateExpected</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateInvent</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>pdsCWUnitId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Project</Name>
			<Label>@SYS4534</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ActivityNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjCategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjAdjustRefId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Reference</Name>
			<Label>@SYS15217</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TransChildType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransChildRefId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>ReturnGroup</Name>
			<Label>@SYS21678</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>PackingSlipReturned</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceReturned</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReturnInventTransOrigin</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StornoPhysical_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Storno_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Settlement</Name>
			<Label>@SYS75148</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DateClosed</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWSettled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtySettled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountSettled</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>SettlementSecCur_RU</Name>
			<Label>@GLS101772</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DateClosedSecCur_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtySettledSecCur_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountSettledSecCur_RU</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>System</Name>
			<Label>@SYS4278</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>DateStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TimeExpected</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Tax</Name>
			<Label>@SYS5878</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>TaxAmountPhysical</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Transfer</Name>
			<Label>@SYS13891</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>isNonFinancialTransfer</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>transferInventTransId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Update</Name>
			<Label>@SYS2934</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountStd</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountStdSecCur_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjCategoryId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>InventoryArchiveFields</Name>
			<Label>@SCM:ArchivingFieldsGroup</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>ActivityNumber</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountAdjustment</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountOperations</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountPhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountPosted</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountSecCurAdjustment_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountSecCurPhysical_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountSecCurPosted_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountSettled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountSettledSecCur_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountStd</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CostAmountStdSecCur_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CurrencyCode</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateClosed</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateClosedSecCur_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateExpected</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateFinancial</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateInvent</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DatePhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>DateStatus</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GroupRefId_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>GroupRefType_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InterCompanyInventDimTransferred</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>inventDimFixed</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>inventDimId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventDimIdSales_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransOrigin</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransOriginDelivery_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransOriginSales_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InventTransOriginTransit_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>InvoiceReturned</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ItemId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>MarkingRefInventTransOrigin</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PackingSlipId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PackingSlipReturned</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWQty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PdsCWSettled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>PickingRouteID</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjAdjustRefId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjCategoryId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ProjId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Qty</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtySettled</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>QtySettledSecCur_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReturnInventTransOrigin</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>RevenueAmountPhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShippingDateConfirmed</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ShippingDateRequested</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StatusIssue</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StatusReceipt</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Storno_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>StornoPhysical_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TaxAmountPhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TimeExpected</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransChildRefId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>TransChildType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValueOpen</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValueOpenSecCur_RU</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>Voucher</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>VoucherPhysical</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>NonFinancialTransferInventClosing</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>LoadId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ReceiptId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ActivityNumber</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjActivityNumber</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountAdjustment</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmountAdjusted</ExtendedDataType>
			<GroupPrompt>@SYS596</GroupPrompt>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountOperations</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmount</ExtendedDataType>
			<Label>@SYS26340</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountPhysical</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmountPhysical</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountPosted</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmountPosted</ExtendedDataType>
			<GroupPrompt>@SYS3058</GroupPrompt>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountSecCurAdjustment_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmountAdjustedSecCur_RU</ExtendedDataType>
			<Label>@GLS101773</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountSecCurPhysical_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmountPhysicalSecCur_RU</ExtendedDataType>
			<Label>@GLS101828</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountSecCurPosted_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmountPostedSecCur_RU</ExtendedDataType>
			<Label>@GLS102311</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountSettled</Name>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmountSettled</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountSettledSecCur_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmountSettledSecCur_RU</ExtendedDataType>
			<Label>@GLS101771</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountStd</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmountStd</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>CostAmountStdSecCur_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CostAmountStdSecCur_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CurrencyCode</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>CurrencyCode</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DateClosed</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@SYS22519</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DateClosedSecCur_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>TransDate</ExtendedDataType>
			<Label>@GLS102391</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DateExpected</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DateExpected</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DateFinancial</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DateFinancial</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DateInvent</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DateInvent</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DatePhysical</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DatePhysical</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>DateStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>DateStatus</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>GroupRefId_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransGroupRefId_RU</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>GroupRefType_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>InventTransGroupRefType_RU</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InterCompanyInventDimTransferred</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InterCompanyInventDimTransferred</ExtendedDataType>
			<Visible>No</Visible>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt">
			<Name>inventDimFixed</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimFixed</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>inventDimId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventDimId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InventDimIdSales_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>InventDimId</ExtendedDataType>
			<Label>@GLS114779</Label>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InventTransOrigin</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransOriginId</ExtendedDataType>
			<Label>@SYS23057</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InventTransOriginDelivery_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>InventTransOriginId</ExtendedDataType>
			<Label>@GLS114739</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InventTransOriginSales_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>InventTransOriginId</ExtendedDataType>
			<Label>@GLS114741</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>InventTransOriginTransit_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>InventTransOriginId</ExtendedDataType>
			<Label>@GLS114743</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>InvoiceId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InvoiceId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>InvoiceReturned</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<GroupPrompt>@SYS12128</GroupPrompt>
			<Label>@SYS22324</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ItemId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ItemId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>MarkingRefInventTransOrigin</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransOriginIdMarked</ExtendedDataType>
			<Label>@SYS8567</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PackingSlipId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PackingSlipId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>PackingSlipReturned</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<GroupPrompt>@SYS11549</GroupPrompt>
			<Label>@SYS22323</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PdsCWQty</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsCWInventQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>PdsCWSettled</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>PdsCWSettled</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>PickingRouteID</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WMSRouteId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjAdjustRefId</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjAdjustRefId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjCategoryId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjCategoryId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ProjId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>ProjId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>Qty</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventQty</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>QtySettled</Name>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventQtySettled</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>QtySettledSecCur_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<ExtendedDataType>InventQtySettled</ExtendedDataType>
			<Label>@GLS101770</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>ReturnInventTransOrigin</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransOriginIdReturn</ExtendedDataType>
			<Label>@SYS50983</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>RevenueAmountPhysical</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>AmountMSTPhysicalRevenue</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ShippingDateConfirmed</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SalesShippingDateConfirmed</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldDate">
			<Name>ShippingDateRequested</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>SalesShippingDateRequested</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>StatusIssue</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>StatusIssue</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>StatusReceipt</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>StatusReceipt</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>Storno_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Storno_RU</ExtendedDataType>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>StornoPhysical_RU</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Storno_RU</ExtendedDataType>
			<Label>@GLS114774</Label>
			<EnumType>NoYes</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldReal">
			<Name>TaxAmountPhysical</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TaxAmount</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldTime">
			<Name>TimeExpected</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>TimeExpected</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>TransChildRefId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventTransChildRefId</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>TransChildType</Name>
			<AssetClassification>Customer Content</AssetClassification>
			<EnumType>InventTransChildType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ValueOpen</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<Label>@SYS11709</Label>
			<EnumType>InventTransOpen</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ValueOpenSecCur_RU</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<CountryRegionCodes>RU</CountryRegionCodes>
			<Label>@GLS101775</Label>
			<EnumType>InventTransOpen</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>Voucher</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>Voucher</ExtendedDataType>
			<Label>@SYS22518</Label>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>VoucherPhysical</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>VoucherPhysical</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>NonFinancialTransferInventClosing</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>InventClosingRefRecId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Visible>No</Visible>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>LoadId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WHSLoadId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ReceiptId</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<AssetClassification>Customer Content</AssetClassification>
			<ExtendedDataType>WhsLoadLineInventoryReceiptId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>TransOriginIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>inventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ItemIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DatePhysical</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>StatusItemIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>StatusReceipt</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>StatusIssue</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>TransChildType</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DimIdIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>inventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>OpenItemIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValueOpen</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>dataAreaId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Partition</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>MarkingRefInventTransOrigin</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ReturnInventTransOrigin</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CostAmountAdjustment</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Qty</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CostAmountPosted</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateStatus</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>StatusReceipt</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>StatusIssue</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DatePhysical</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateFinancial</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>inventDimId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>GoodsInRouteSalesIdx_RU</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSERussia</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransOriginSales_RU</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>GroupRefIdx_RU</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSERussia</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>GroupRefId_RU</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>GroupRefType_RU</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>OpenSecCurItemIdx_RU</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>InventClosingSecCur_RU</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>ValueOpenSecCur_RU</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>MarkingRefInventTransOrigin</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateStatus</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>StatusReceipt</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>StatusIssue</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DatePhysical</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateFinancial</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>inventDimId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ReturnInventTransOrigin</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>GoodsInRouteTransitIdx_RU</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSERussia</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransOriginTransit_RU</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>GoodsInRouteDeliveryIdx_RU</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<ConfigurationKey>CRSERussia</ConfigurationKey>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransOriginDelivery_RU</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ReturnInventTransOrigIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ReturnInventTransOrigin</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TransOriginPackingSlipIdInvoiceIdStatusIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PackingSlipId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InvoiceId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>StatusIssue</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>StatusReceipt</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DatePhysicalDimItemIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>DatePhysical</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Qty</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ItemIdDimIdDateFinancialIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateFinancial</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InvoiceReturnIdx</Name>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>InvoiceReturned</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>VoucherDateFinancialValueOpenIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>Voucher</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateFinancial</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValueOpen</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>DateStatusIssueItemIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>StatusReceipt</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>StatusIssue</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateStatus</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>RecId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>Qty</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>CostAmountPhysical</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventClosingUpdateFinancialViewIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>DateFinancial</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValueOpen</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PackingSlipReturned</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>InventClosingUpdatePhysicalViewIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>DatePhysical</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValueOpen</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>PackingSlipReturned</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>ProjIdDateFinancialValueOpenIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<AllowPageLocks>No</AllowPageLocks>
			<Fields>
				<AxTableIndexField>
					<DataField>ProjId</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DateFinancial</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ValueOpen</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>ItemId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventDimId</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>TransOriginDatePhysicalIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>InventTransOrigin</DataField>
				</AxTableIndexField>
				<AxTableIndexField>
					<DataField>DatePhysical</DataField>
					<IncludedColumn>Yes</IncludedColumn>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
		<AxTableIndex>
			<Name>PickingRouteIDIdx</Name>
			<AllowDuplicates>Yes</AllowDuplicates>
			<Fields>
				<AxTableIndexField>
					<DataField>PickingRouteID</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>Currency</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>Currency</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CurrencyCode</Name>
					<Field>CurrencyCode</Field>
					<RelatedField>CurrencyCode</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CurrencyCodeIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventBaileeCalcTable_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventBaileeCalcTable_RU</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintFixed">
					<Name>GroupRefType_RU</Name>
					<Field>GroupRefType_RU</Field>
					<ValueStr>InventTransGroupRefType_RU::InventBaileeCalc</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>GroupRefId_RU</Name>
					<Field>GroupRefId_RU</Field>
					<RelatedField>CalcId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventDim</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>inventDimId</Name>
					<Field>inventDimId</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>DimIdIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventDimSales</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EDTRelation>Yes</EDTRelation>
			<RelatedTable>InventDim</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventDimSales</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>InventTrans</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventDimIdSales_RU</Name>
					<SourceEDT>InventDimId</SourceEDT>
					<Field>InventDimIdSales_RU</Field>
					<RelatedField>inventDimId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventOnHands</Name>
			<EntityRelationshipRole>@SYS123816</EntityRelationshipRole>
			<RelatedTable>InventSum</RelatedTable>
			<RelationshipType>Link</RelationshipType>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ItemId</Name>
					<Field>ItemId</Field>
					<RelatedField>ItemId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ItemIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTransferJour</Name>
			<EntityRelationshipRole>@SYS123858</EntityRelationshipRole>
			<RelatedTable>InventTransferJour</RelatedTable>
			<RelationshipType>Link</RelationshipType>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DateFinancial</Name>
					<Field>DateFinancial</Field>
					<RelatedField>TransDate</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Voucher</Name>
					<Field>Voucher</Field>
					<RelatedField>VoucherId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOrigin</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelatedTableRole>InventTransOrigin</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>InventTransOrigin_InventTrans</Role>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransOrigin</Name>
					<Field>InventTransOrigin</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOriginDelivery_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventTransOriginDelivery_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransOriginDelivery_RU</Name>
					<Field>InventTransOriginDelivery_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOriginSales_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventTransOriginSales_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransOriginSales_RU</Name>
					<Field>InventTransOriginSales_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>InventTransOriginTransit_RU</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventTransOriginTransit_RU</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransOriginTransit_RU</Name>
					<Field>InventTransOriginTransit_RU</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTransPostingFinancial</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123860</EntityRelationshipRole>
			<RelatedTable>InventTransPosting</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventTransPostingFinancial</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>InventTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>InventTransPostingType_Extern</Name>
					<RelatedField>InventTransPostingType</RelatedField>
					<ValueStr>InventTransPostingType::Financial</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransOrigin</Name>
					<Field>InventTransOrigin</Field>
					<RelatedField>InventTransOrigin</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Voucher</Name>
					<Field>Voucher</Field>
					<RelatedField>Voucher</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DateFinancial</Name>
					<Field>DateFinancial</Field>
					<RelatedField>TransDate</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventTransPostingPhysical</Name>
			<Cardinality>ZeroMore</Cardinality>
			<EntityRelationshipRole>@SYS123861</EntityRelationshipRole>
			<RelatedTable>InventTransPosting</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventTransPostingPhysical</RelatedTableRole>
			<RelationshipType>Aggregation</RelationshipType>
			<Role>InventTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>InventTransPostingType_Extern</Name>
					<RelatedField>InventTransPostingType</RelatedField>
					<ValueStr>InventTransPostingType::Physical</ValueStr>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>InventTransOrigin</Name>
					<Field>InventTransOrigin</Field>
					<RelatedField>InventTransOrigin</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VoucherPhysical</Name>
					<Field>VoucherPhysical</Field>
					<RelatedField>Voucher</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DatePhysical</Name>
					<Field>DatePhysical</Field>
					<RelatedField>TransDate</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>MarkingRefInventTransOrigin</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>MarkingRefInventTransOrigin</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>MarkingRefInventTransOrigin_InventTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>MarkingRefInventTransOrigin</Name>
					<Field>MarkingRefInventTransOrigin</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdJournalCalc</Name>
			<EntityRelationshipRole>@SYS123863</EntityRelationshipRole>
			<RelatedTable>ProdTableJour</RelatedTable>
			<RelationshipType>Link</RelationshipType>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DateFinancial</Name>
					<Field>DateFinancial</Field>
					<RelatedField>TransDate</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>Voucher</Name>
					<Field>Voucher</Field>
					<RelatedField>Voucher</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>JournalType_Extern</Name>
					<RelatedField>JournalType</RelatedField>
					<ValueStr>ProdJourType::HistoricalCost</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>ProdJournalIIP</Name>
			<EntityRelationshipRole>@SYS123863</EntityRelationshipRole>
			<RelatedTable>ProdTableJour</RelatedTable>
			<RelationshipType>Link</RelationshipType>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>VoucherPhysical</Name>
					<Field>VoucherPhysical</Field>
					<RelatedField>Voucher</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>DatePhysical</Name>
					<Field>DatePhysical</Field>
					<RelatedField>TransDate</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>JournalType_Extern</Name>
					<RelatedField>JournalType</RelatedField>
					<ValueStr>ProdJourType::Release</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjCategory</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjCategory</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjCategoryId</Name>
					<Field>ProjCategoryId</Field>
					<RelatedField>CategoryId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>CategoryIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>ProjTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>ProjTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ProjId</Name>
					<Field>ProjId</Field>
					<RelatedField>ProjId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ProjectIdx</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>returnInventTransOrigin</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventTransOrigin</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventTransOrigin_return</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>InventTransOrigin_return_InventTrans</Role>
			<UseDefaultRoleNames>No</UseDefaultRoleNames>
			<Validate>No</Validate>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ReturnInventTransOrigin</Name>
					<Field>ReturnInventTransOrigin</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>smmActivities</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>smmActivities</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>ActivityNumber</Name>
					<Field>ActivityNumber</Field>
					<RelatedField>ActivityNumber</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>ActivityNumberIdx</Index>
		</AxTableRelation>
		<AxTableRelation>
			<Name>InventClosing</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>InventClosing</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelatedTableRole>InventClosing</RelatedTableRole>
			<RelationshipType>Association</RelationshipType>
			<Role>InventClosing</Role>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>NonFinancialTransferInventClosing</Name>
					<Field>NonFinancialTransferInventClosing</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
		<AxTableRelation>
			<Name>WHSLoadTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<RelatedTable>WHSLoadTable</RelatedTable>
			<RelatedTableCardinality>ZeroOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>LoadId</Name>
					<Field>LoadId</Field>
					<RelatedField>LoadId</RelatedField>
				</AxTableRelationConstraint>
			</Constraints>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>