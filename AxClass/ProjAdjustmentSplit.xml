<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjAdjustmentSplit</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ProjAdjustmentSplit</c> class implements a dialog box.
/// </summary>
/// <remarks>
///  This class extends the <see cref="T:RunBase" />
///   to implement a dialog box. The dialog box expects the following fields to be filled-in by the user:
///  <list type="table">
///   <item>
///   <description><paramref name="dialogQty" /></description><description>The split in number of
///   lines.</description>
///   </item>
///   <item>
///   <description><paramref name="dialogProjId" /></description><description>This is the way the user
///   can indicate which project should be the target.</description>
///   </item>
///   <item>
///   <description><paramref name="dialogCategoryId" /></description><description>The category to which
///   to adjust.</description>
///   </item>
///   <item>
///   <description><paramref name="dialogLinePropertyId" /></description><description>The <paramref
///   name="LineProperty" /> to adjust.</description>
///   </item>
///  </list>
///  It only makes sense to use this class from the
///  <c>
///   ProjAdjustmentForm
///  </c>
///   class.
/// </remarks>
class   ProjAdjustmentSplit extends RunBase
{
    Counter                     projQty;
    Qty                         origQty;
    Qty                         counter;
    boolean                     isSubscription;
    boolean                     isIntegratedProject;

    ProjTransType               projTransType;

    ProjTransType               categoryType;

    NoYes                       updateLineProperty;
    NoYes                       updateHourCostPrice;
    NoYes                       updateSalesCurrency;
    NoYes                       updateFundingSource;
    ProjSalesPriceMarkup        updateSalesPrice;
    Percent                     updateMarkUpPct;
    NoYes                       updateTax;
    NoYes                       updateDimension;
    // <GEEU>
    LedgerCorrection            adjustCorrection;
    // </GEEU>

    TmpProjAdjustment           tmpProjAdjustment;
    TmpProjAdjustmentCost       tmpProjAdjustmentCost;
    TmpProjAdjustmentSale       tmpProjAdjustmentSale;
    TmpProjAdjustmentCreate     tmpProjAdjustmentCreate;
    TmpProjAdjustmentCreateCost tmpProjAdjustmentCreateCost;
    TmpProjAdjustmentCreateSale tmpProjAdjustmentCreateSale;
    FormDataSource              tmpProjAdjustmentDS;
	
    // <GIN>
    NoYes                       maxRetailPrice;
    // </GIN>

    Args                        args;

    Map                         updatedRecs;

    Set                         projTransIdSet;
    boolean                     bRecal;
    boolean                     m_bAdjustProjId;
    TSTimesheetTable            m_tTimecardTable;

    TmpProjAdjustmentSplit      tmpProjAdjustmentSplit;

    private Percent roundedPercentage;

    // <GIN>
    #ISOcountryRegionCodes
    // </GIN>

    #define.CurrentVersion(4)

    #localmacro.CurrentList
        projQty,
        UpdateLineProperty,
        UpdateHourCostPrice,
        UpdateSalesCurrency,
        UpdateSalesPrice,
        UpdateMarkUpPct,
        UpdateTax,
        UpdateDimension
        // <GIN>
        , maxRetailPrice
        // <GIN>
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate adjusted quantity.
    /// </summary>
    /// <param name="_qty">
    /// The quantity that needs to be adjusted.
    /// </param>
    /// <param name="_adjType">
    /// The adjustment type which affects calculated quantity precision.
    /// </param>
    /// <param name="_percent">
    /// The percent of the original quantity that should be calculated.
    /// </param>
    /// <returns>
    /// The adjusted quantity.
    /// </returns>
    /// <remarks>
    /// The default type for _adjType is Item which differs from Hour.
    /// </remarks>
    protected Qty calculateQty(Qty _qty, ProjAdjustmentType _adjType = ProjAdjustmentType::Item, Percent _percent = 0)
    {
        Qty calcQty;                

        if (origQty == 0)
        {
            calcQty = 1;
        }
        else
        {
            if (counter == projQty)  // last
            {
                calcQty = origQty;
            }
            else
            {
                RoundOff roundOff;

                if (_adjType == ProjAdjustmentType::Item)
                {
                    UnitOfMeasureDecimalPrecision decimalPrecision = UnitOfMeasure::findBySymbol(tmpProjAdjustment.SalesUnit).DecimalPrecision;

                    switch (decimalPrecision)
                    {
                        case 1:
                            roundOff = 0.1;
                            break;

                        case 2:
                            roundOff = 0.01;
                            break;

                        default:
                            roundOff = 1.0;
                    }
                }
                else
                {
                    roundOff = 0.01;
                }

                calcQty = round(_qty * _percent / 100, roundOff);

                if (calcQty == 0)
                {
                    // For item scenario as we cannot make fractional split.
                    if (_adjType != ProjAdjustmentType::Item)
                    {
                        calcQty = round(_qty * _percent, roundOff);
                    }
                    else
                    {
                        switch (roundOff)
                        {
                            case 1:
                                calcQty = 1.0;
                                break;

                            case 0.1:
                                calcQty = 0.1;
                                break;

                            default:
                                calcQty = 0.01;
                        }
                    }
                }

                origQty -= calcQty;
            }
        }
        return  calcQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOldTotalCostAmount</Name>
				<Source><![CDATA[
    protected AmountCur getOldTotalCostAmount(TmpProjAdjustmentSplit _tmpProjAdjustmentSplit)
    {
        Percent percent = this.getSplittedPercent(_tmpProjAdjustmentSplit);

        return TmpProjAdjustmentCreate::getTotalCostAmount(tmpProjAdjustment, percent);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewTotalCostAmount</Name>
				<Source><![CDATA[
    protected AmountCur getNewTotalCostAmount()
    {
        AmountCur elrCostPerHourSetupAmt = ProjHourCostPrice::findResourceRate(tmpProjAdjustmentCreate.Resource, tmpProjAdjustmentCreate.Transdate).CostPrice;

        if (elrCostPerHourSetupAmt)
        {
            ProjEmplTrans    emplTrans;
            CurrencyCode     currencyCode = CompanyInfoHelper::standardCurrency();

            PeriodRecId period = ResourceSetup::find(tmpProjAdjustmentCreate.Resource).Period;
            TransDate periodFrom = PeriodFacade::startDate(period, tmpProjAdjustmentCreate.Transdate);
            TransDate periodTo = PeriodFacade::endDate(period, tmpProjAdjustmentCreate.Transdate);

            select crossCompany sum(Qty), sum(TotalCostAmountCur) from emplTrans where
                    emplTrans.TransDate >= periodFrom &&
                    emplTrans.TransDate <= periodTo   &&
                    emplTrans.Resource  == tmpProjAdjustmentCreate.Resource;

            // Find the calendar to use
            CalendarRecId calendar = ResourceFacade::getCalendar(tmpProjAdjustmentCreate.Resource);

            // standard working hours for the week
            List dates = ResourceCalendarFacade::getDates(calendar, periodFrom, periodTo);
            ListEnumerator datesEnumerator = dates.getEnumerator();

            ProjQtyEmpl hoursExpectedInPeriod;
            while (datesEnumerator.moveNext())
            {
                date transDate = datesEnumerator.current();
                hoursExpectedInPeriod += WorkCalendarDate::calcDefinedHours(ProjElr::getCalendarId(tmpProjAdjustmentCreate.Resource), transDate, false);
            }

            if (hoursExpectedInPeriod == 0 || emplTrans.Qty == 0)
            {
                return 0;
            }

            AmountCur newCostPerHour;

            // ProjAdjustmentElrHourCostPriceCalculationFlight helps the customer to turn the new cost per hour calculation which mimics the cost calculation done in the Project Hour Journal and
            // timesheet posting. By default this flight is enabled.
            if (ProjAdjustmentElrHourCostPriceCalculationFlight::instance().isEnabled())
            {
                newCostPerHour = hoursExpectedInPeriod / emplTrans.Qty * elrCostPerHourSetupAmt;
            }
            else
            {
                // this is an incorrect and regressed calculation. we may need to remove this code once we have the ProjAdjustmentElrHourCostPriceCalculationFlight always enabled for our customers.
                newCostPerHour = hoursExpectedInPeriod / (emplTrans.Qty ? emplTrans.Qty * elrCostPerHourSetupAmt : elrCostPerHourSetupAmt);
            }

            return tmpProjAdjustmentCreate.priceQty() * CurrencyExchangeHelper::price(newCostPerHour, currencyCode);
        }
        else
        {
                return (tmpProjAdjustmentCreate.priceQty() * ProjHourCostPrice::findProjCostPrice(tmpProjAdjustmentCreate.ProjId,
                                                             tmpProjAdjustmentCreate.Resource,
                                                             tmpProjAdjustmentCreate.CategoryId,
                                                             tmpProjAdjustmentCreate.Transdate,
                                                             '',
                                                             '',
                                                             tmpProjAdjustmentCreate.ResourceCategory).CostPrice);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOldTotalSaleAmount</Name>
				<Source><![CDATA[
    protected AmountCur getOldTotalSaleAmount(TmpProjAdjustmentSplit _tmpProjAdjustmentSplit)
    {
        Percent percent = this.getSplittedPercent(_tmpProjAdjustmentSplit);

        return TmpProjAdjustmentCreate::getTotalSalesAmount(tmpProjAdjustment, percent);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewTotalSaleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the new sales amount.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentSplit">
    ///     A <c>TmpProjAdjustmentSplit</c> table buffer.
    /// </param>
    /// <returns>
    ///     New sales amount.
    /// </returns>
    protected AmountCur getNewTotalSaleAmount(TmpProjAdjustmentSplit _tmpProjAdjustmentSplit)
    {
        AmountCur   createTotalCostAmount;
        AmountCur   revenueTotalSaleAmount;

        if (updateHourCostPrice && tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Hour))
        {
            if (tmpProjAdjustment.IsIntercompany)
            {
                createTotalCostAmount = this.getOldTotalCostAmount(_tmpProjAdjustmentSplit);
            }
            else
            {
                createTotalCostAmount = this.getNewTotalCostAmount();
            }
        }
        else
        {
            createTotalCostAmount = this.getOldTotalCostAmount(_tmpProjAdjustmentSplit);
        }

        if (this.isSubscription())
        {
            revenueTotalSaleAmount = TmpProjAdjustment::totalCostAmount(tmpProjAdjustment.TransId, tmpProjAdjustment, tmpProjAdjustmentCost);
        }
        else
        {
            revenueTotalSaleAmount = 0.00;
        }

        TmpProjAdjustmentCreateSalesPriceParameters tmpProjAdjustmentCreateSalesPriceParameters =
                this.initializeTmpProjAdjustmentCreateSalesPriceParameters(
                    tmpProjAdjustmentCreate,
                    createTotalCostAmount,
                    revenueTotalSaleAmount,
                    updateSalesPrice,
                    updateMarkUpPct);

        return (tmpProjAdjustmentCreate.priceQty() * TmpProjAdjustmentCreate::retrieveSalesPrice(tmpProjAdjustmentCreateSalesPriceParameters));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTmpProjAdjustmentCreateSalesPriceParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c>TmpProjAdjustmentCreateSalesPriceParameters</c>.
    /// </summary>
    /// <param name="_tmpProjAdjustmentCreate">
    /// The TmpProjAdjustmentCreate table.
    /// </param>
    /// <param name="_totalCostAmount">
    /// Cost price to search with.
    /// </param>
    /// <param name="_revenueTotalSaleAmount">
    /// Revenue for sales price calculation.
    /// </param>
    /// <param name="_salesPriceMarkup">
    /// Sales price markup for sales price calculation.
    /// </param>
    /// <param name="_markUpPct">
    /// Markup percentage for sales price calculation.
    /// </param>
    /// <returns>
    /// An instance of the <c>TmpProjAdjustmentCreateSalesPriceParameters</c> class.
    /// </returns>
    protected TmpProjAdjustmentCreateSalesPriceParameters initializeTmpProjAdjustmentCreateSalesPriceParameters(
        TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
        AmountCur                   _totalCostAmount,
        AmountCur                   _revenueTotalSaleAmount,
        ProjSalesPriceMarkup        _salesPriceMarkup   = ProjSalesPriceMarkup::Yes,
        Percent                     _markUpPct          = 0)
    {
        TmpProjAdjustmentCreateSalesPriceParameters tmpProjAdjustmentCreateSalesPriceParameters;
        tmpProjAdjustmentCreateSalesPriceParameters = TmpProjAdjustmentCreateSalesPriceParameters::construct();
        tmpProjAdjustmentCreateSalesPriceParameters.initializeParameters(
            _tmpProjAdjustmentCreate,
            _totalCostAmount,
            _revenueTotalSaleAmount,
            _salesPriceMarkup,
            _markUpPct);
        return tmpProjAdjustmentCreateSalesPriceParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTrxAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the sale and cost amount.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentSplit">
    ///     A <c>TmpProjAdjustmentSplit</c> table buffer.
    /// </param>
    protected void createTrxAmounts(TmpProjAdjustmentSplit _tmpProjAdjustmentSplit)
    {
        AmountCur   totalCostAmount;
        AmountCur   totalSaleAmount;
        tmpProjAdjustmentSplit tmpProjAdjSplit;

        if (updateHourCostPrice && tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Hour))
        {
            if (tmpProjAdjustment.IsIntercompany)
            {
                totalCostAmount = this.getOldTotalCostAmount(_tmpProjAdjustmentSplit);
            }
            else
            {
                totalCostAmount = this.getNewTotalCostAmount();
            }
        }
        else
        {
            // Rounding should take place only if a transaction is split into two or more transactions.
            // cost amounts are rounded for all split transactions but it will be corrected for any rounding errors
            // in correctSplitTotals method.
            tmpProjAdjSplit.linkPhysicalTableInstance(tmpProjAdjustmentSplit);
            select count(RecId) from tmpProjAdjSplit;
   
            if (tmpProjAdjSplit.RecId > 1)
            {
                totalCostAmount = CurrencyExchangeHelper::amount(this.getOldTotalCostAmount(_tmpProjAdjustmentSplit), tmpProjAdjustmentCreate.CurrencyIdCost);
            }
            else
            {
                totalCostAmount = this.getOldTotalCostAmount(_tmpProjAdjustmentSplit);
            }
        }

        // For "Fee", we split on the SalesPrice/LineAmount.
        if (tmpProjAdjustmentCreate.checkAdjustmentType(ProjAdjustmentType::Revenue) && !this.isSubscription())
        {
            if (updateSalesPrice)
            {
                AmountCur SalesPrice = this.getNewTotalSaleAmount(_tmpProjAdjustmentSplit);

                ProjFundingEngine projFundingEngine = ProjFundingEngine::construct(new ProjTransTmpProjAdjustmentCreate(tmpProjAdjustmentCreate), 0, SalesPrice);
                if ( projFundingEngine.allocate())
                {
                    Map saleDistributions = projFundingEngine.parmSaleDistributions();
                    MapEnumerator enumerateMap = new MapEnumerator(saleDistributions);
                    while (enumerateMap.moveNext())
                    {
                        totalSaleAmount += enumerateMap.currentValue() * (_tmpProjAdjustmentSplit.Percent / 100);
                    }
                }
            }
            else
            {

                while select tmpProjAdjustmentSale
                    where tmpProjAdjustmentSale.TransId == tmpProjAdjustment.TransId
                {
                    totalSaleAmount += tmpProjAdjustmentSale.SalesPrice * (_tmpProjAdjustmentSplit.Percent / 100);
                }
            }
        }
        else
        {
            if (updateSalesPrice)
            {
                totalSaleAmount = this.getNewTotalSaleAmount(_tmpProjAdjustmentSplit);
            }
            else
            {
                totalSaleAmount = CurrencyExchangeHelper::amount(this.getOldTotalSaleAmount(_tmpProjAdjustmentSplit), tmpProjAdjustmentCreate.CurrencyId);
            }
        }

        if (tmpProjAdjustmentCreate.PSAIndirectComponentGroup)
        {
            boolean mustUpdateFundingSource = TmpProjAdjustmentCreate::mustUpdateFundingSource(tmpProjAdjustment, tmpProjAdjustmentSale, tmpProjAdjustmentCreate);

            if (!mustUpdateFundingSource)
            {
                tmpProjAdjustmentCreate.PSAIndirectComponentGroup = tmpProjAdjustment.PSAIndirectComponentGroup;
            }

            AmountCur costPrice = totalCostAmount / (tmpProjAdjustmentCreate.priceQty() ? tmpProjAdjustmentCreate.priceQty() : 1);
            AmountCur salesPrice = totalSaleAmount / (tmpProjAdjustmentCreate.priceQty() ? tmpProjAdjustmentCreate.priceQty() : 1);
            tmpProjAdjustmentCreate.setIndirectCosts(costPrice);
            tmpProjAdjustmentCreate.setIndirectSales(salesPrice);
        }

        tmpProjAdjustmentCreate.salesPriceMarkup = this.parmUpdateSalesPrice();
        tmpProjAdjustmentCreate.UpdateHourCost = this.parmUpdateHourCostPrice();
        tmpProjAdjustmentCreate.FromSplitForm = NoYes::Yes;

        TmpProjAdjustmentCreate::createTrxAmounts(tmpProjAdjustment,
												  tmpProjAdjustmentCost,
												  tmpProjAdjustmentSale,
												  tmpProjAdjustmentCreate,
												  tmpProjAdjustmentCreateCost,
												  tmpProjAdjustmentCreateSale,
												  totalCostAmount,
												  totalSaleAmount);
        //Need to reset this as after splitting the record will always come from Adjustment form
        tmpProjAdjustmentCreate.FromSplitForm = NoYes::No;

        ttsbegin;
        // Rounding based on the currency setting here is necessary to avoiding rounding issues later. Any rounding offset will be taken care in <c>correctSplitTotals()</c>
        // method of this class.
        tmpProjAdjustmentCreate.TotalCostAmountCur = totalCostAmount;
        tmpProjAdjustmentCreate.TotalSalesAmountCur = totalSaleAmount;

        tmpProjAdjustmentCreate.setNewTotalCostAmount();
        tmpProjAdjustmentCreate.setNewTotalSaleAmount();
        tmpProjAdjustmentCreate.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewTrans</Name>
				<Source><![CDATA[
    protected void createNewTrans(boolean _reverseTrans = false, TmpProjAdjustmentSplit _tmpProjAdjustmentSplit = null)
    {
        tmpProjAdjustmentCreate.clear();

        this.initializeTmpProjAdjustmentCreate(_reverseTrans, _tmpProjAdjustmentSplit);
        tmpProjAdjustmentCreate.insert();

        // <GTE>
        if (TaxIntegrationUtils::isTaxInformationEnabled())
        {
            TransTaxInformationHelper::copyTransTaxInformation(tmpProjAdjustment, tmpProjAdjustmentCreate);

            if (tmpProjAdjustmentCreate.CategoryId != tmpProjAdjustment.CategoryId)
            {
                TransTaxInformation transTaxInformation;
                TransitDocumentTransTaxInfoRelation_IN transitDocumentTransTaxInfoRelation_IN;

                select firstonly transTaxInformation
                    join RecId from transitDocumentTransTaxInfoRelation_IN
                        where transTaxInformation.RecId == transitDocumentTransTaxInfoRelation_IN.TransTaxInformationRecId
                            && transitDocumentTransTaxInfoRelation_IN.TransactionRecId == tmpProjAdjustmentCreate.RecId
                            && transitDocumentTransTaxInfoRelation_IN.TransactionTableId == tmpProjAdjustmentCreate.TableId;
                
                if (transTaxInformation)
                {
                    ttsbegin;
                    ProjCategory projCategory = ProjCategory::find(tmpProjAdjustmentCreate.CategoryId);

                    transTaxInformation.selectForUpdate(true);
                    transTaxInformation.ServiceAccountingCodeTable = projCategory.ServiceAccountingCodeTable_IN;
                    transTaxInformation.HSNCodeTable = 0;
                    transTaxInformation.TaxRateType = projCategory.TaxRateType;
                    transTaxInformation.update();
                    ttscommit;
                }
            }
        }
        // </GTE>

        /*
           When ProjUseFundingLimitTrackingForAdjustment flight is enabled,
           reversal records are created for hour,expense, revenue; otherwise they
           are only created for hours and revenue.
        */
        if (_reverseTrans)
        {
            while select tmpProjAdjustmentCost
                where tmpProjAdjustmentCost.TransId == tmpProjAdjustment.TransId
            {
                tmpProjAdjustmentCreateCost.clear();
                tmpProjAdjustmentCreateCost.RefRecId        = tmpProjAdjustmentCreate.RecId;
                tmpProjAdjustmentCreateCost.CostRefRecId    = tmpProjAdjustmentCost.CostRefRecId;
                tmpProjAdjustmentCreateCost.FundingSource   = tmpProjAdjustmentCost.FundingSource;
                tmpProjAdjustmentCreateCost.CostPrice       = tmpProjAdjustmentCost.CostPrice;
                tmpProjAdjustmentCreateCost.LineAmount      = -tmpProjAdjustmentCost.LineAmount;
                tmpProjAdjustmentCreateCost.DefaultDimension = tmpProjAdjustmentCost.DefaultDimension;
                tmpProjAdjustmentCreateCost.insert();
            }

            while select tmpProjAdjustmentSale
                where tmpProjAdjustmentSale.TransId == tmpProjAdjustment.TransId
            {
                tmpProjAdjustmentCreateSale.clear();
                this.initializeTmpProjAdjustmentCreateSale();
                tmpProjAdjustmentCreateSale.insert();
 
				if (ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
				{
					// The insert method will handle if the tranasction is billable and the funding source allows
					// for billing.
                    ProjTrans projTrans = new ProjTransTmpProjAdjustmentCreate(tmpProjAdjustmentCreate);
					ProjFundingLimitTrackingManager::insertFundingLimitsTrackingByProjTran(
						projTrans,
						tmpProjAdjustmentCreateSale.FundingSource,
						tmpProjAdjustmentCreateSale.LineAmount + tmpProjAdjustmentCreateSale.PSAIndirectRevenue ,
                        tmpProjAdjustmentCreate.TmpTransId);
				}
           }
        }
        else
        {
			this.createTrxAmounts(_tmpProjAdjustmentSplit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTmpProjAdjustmentCreateSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TmpProjAdjustmentCreateSale</c> record.
    /// </summary>
    protected void initializeTmpProjAdjustmentCreateSale()
    {
        tmpProjAdjustmentCreateSale.RefRecId        = tmpProjAdjustmentCreate.RecId;
        tmpProjAdjustmentCreateSale.SaleRefRecId    = tmpProjAdjustmentSale.SaleRefRecId;
        tmpProjAdjustmentCreateSale.FundingSource   = tmpProjAdjustmentSale.FundingSource;
        tmpProjAdjustmentCreateSale.SalesPrice      = tmpProjAdjustmentSale.SalesPrice;
        tmpProjAdjustmentCreateSale.LineAmount      = -tmpProjAdjustmentSale.LineAmount;
        if (tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Revenue))
        {
            tmpProjAdjustmentCreateSale.SalesPrice  = -tmpProjAdjustmentSale.SalesPrice;
            tmpProjAdjustmentCreateSale.LineAmount  = -tmpProjAdjustmentSale.LineAmount;
        }
        tmpProjAdjustmentCreateSale.DefaultDimension = tmpProjAdjustmentSale.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTmpProjAdjustmentCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TmpProjAdjustmentCreate</c> record.
    /// </summary>
    /// <param name = "_reverseTrans">
    /// Specifies if the transaction is a reversal.
    /// </param>
    /// <param name = "_tmpProjAdjustmentSplit">
    /// A <c>TmpProjAdjustmentSplit</c> table buffer.
    /// </param>
    protected void initializeTmpProjAdjustmentCreate(boolean _reverseTrans, TmpProjAdjustmentSplit _tmpProjAdjustmentSplit)
    {
        tmpProjAdjustmentCreate.Transdate     = tmpProjAdjustment.TransDate;

        tmpProjAdjustmentCreate.Txt               = tmpProjAdjustment.Txt;

        tmpProjAdjustmentCreate.CurrencyIdCost              = tmpProjAdjustment.CurrencyIdCost;
        tmpProjAdjustmentCreate.QtyToBeInvoiced             = tmpProjAdjustment.QtyToBeInvoiced;
        tmpProjAdjustmentCreate.TransID                     = tmpProjAdjustment.TransId;
        tmpProjAdjustmentCreate.Resource                    = tmpProjAdjustment.Resource;
        tmpProjAdjustmentCreate.ResourceCategory            = tmpProjAdjustment.ResourceCategory;
        tmpProjAdjustmentCreate.AdjustmentType              = tmpProjAdjustment.AdjustmentType;
        tmpProjAdjustmentCreate.ItemId                      = tmpProjAdjustment.ItemId;
        tmpProjAdjustmentCreate.ProjIdentId                 = tmpProjAdjustment.ProjIdentId;
        tmpProjAdjustmentCreate.ProjIdentResource           = tmpProjAdjustment.ProjIdentResource;
        tmpProjAdjustmentCreate.SalesUnit                   = tmpProjAdjustment.SalesUnit;
        tmpProjAdjustmentCreate.ItemType                    = tmpProjAdjustment.ItemType;
        tmpProjAdjustmentCreate.InventTransId               = tmpProjAdjustment.InventTransId;
        tmpProjAdjustmentCreate.InventDimId                 = tmpProjAdjustment.InventDimid;
        tmpProjAdjustmentCreate.PackingSlipId               = tmpProjAdjustment.PackingSlipId;
        tmpProjAdjustmentCreate.ProjAdjustRefId             = tmpProjAdjustment.ProjAdjustRefid;
        tmpProjAdjustmentCreate.LedgerDimension             = tmpProjAdjustment.LedgerDimension;
        tmpProjAdjustmentCreate.ItemAdjustVersion           = tmpProjAdjustment.ItemAdjustVersion;
        tmpProjAdjustmentCreate.smaBasePrice                = tmpProjAdjustment.smaBasePrice;
        tmpProjAdjustmentCreate.smaEnddate                  = tmpProjAdjustment.smaEnddate;
        tmpProjAdjustmentCreate.smaIndex                    = tmpProjAdjustment.smaIndex;
        tmpProjAdjustmentCreate.smaStartDate                = tmpProjAdjustment.smaStartDate;
        tmpProjAdjustmentCreate.smaSubscriptionId           = tmpProjAdjustment.smaSubscriptionId;
        tmpProjAdjustmentCreate.smaSubscriptionPeriodType   = tmpProjAdjustment.smaSubscriptionPeriodType;
        tmpProjAdjustmentCreate.TotalCostAmountCur          = tmpProjAdjustment.TotalCostAmountCur;
        tmpProjAdjustmentCreate.TotalSalesAmountCur         = tmpProjAdjustment.TotalSalesAmountCur;
        // <GEEU>
        tmpProjAdjustmentCreate.AdjustCorrection            = adjustCorrection;
        // </GEEU>

        tmpProjAdjustmentCreate.NewTotalCostAmount = tmpProjAdjustment.TotalCostAmountCur;
        tmpProjAdjustmentCreate.NewTotalSaleAmount = tmpProjAdjustment.TotalSalesAmountCur;
        if (ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
        {
			// A unique TransId is need to track the changes.  The original implementation places the original
			// TransId in the new records as it's TransId. This relationship is used in the UI and cannot easily
			// be changed.
            tmpProjAdjustmentCreate.TmpTransId = tmpProjAdjustmentCreate.generateNewTemporaryTransId();
        }

        roundedPercentage = 0;
 
        if (_reverseTrans)
        {
            tmpProjAdjustmentCreate.ProjId              = tmpProjAdjustment.ProjId;
            tmpProjAdjustmentCreate.CategoryId          = tmpProjAdjustment.CategoryId;
            tmpProjAdjustmentCreate.LinePropertyId      = tmpProjAdjustment.LinePropertyId;
            tmpProjAdjustmentCreate.ActivityNumber      = tmpProjAdjustment.ActivityNumber;
            tmpProjAdjustmentCreate.CurrencyId          = tmpProjAdjustment.CurrencyId;
            tmpProjAdjustmentCreate.TaxgroupId          = tmpProjAdjustment.TaxGroupId;
            tmpProjAdjustmentCreate.TaxItemGroupId      = tmpProjAdjustment.TaxItemGroupId;
            tmpProjAdjustmentCreate.DefaultDimension    = tmpProjAdjustment.DefaultDimension;

            this.initializeTmpProjAdjustmentCreateByAdjustmentType();

            tmpProjAdjustmentCreate.AdjustOrig = NoYes::Yes;
        }
        else
        {
            if (this.isSubscription() || tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Revenue))
            {
                tmpProjAdjustmentCreate.Qty         = 1;
            }
            else
            {
                tmpProjAdjustmentCreate.Qty         = this.calculateQty(tmpProjAdjustment.Qty, tmpProjAdjustment.AdjustmentType, tmpProjAdjustmentSplit.Percent);

                // To round the percentage based on rounded qty
                if (frac(tmpProjAdjustmentSplit.Percent) > 0.00 || tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Item))
                {
                    this.parmRoundedPercent((tmpProjAdjustmentCreate.Qty/tmpProjAdjustment.Qty) * 100);
                }
            }

            tmpProjAdjustmentCreate.ProjId          = _tmpProjAdjustmentSplit.ProjId ? _tmpProjAdjustmentSplit.ProjId : tmpProjAdjustment.ProjId;
            tmpProjAdjustmentCreate.ActivityNumber  = _tmpProjAdjustmentSplit.ActivityNumber ? _tmpProjAdjustmentSplit.ActivityNumber : tmpProjAdjustment.ActivityNumber;

            // If there is no association between the ProjId and the Activity Number, then clear the Activity Number.
            // User can always manually set the Activity Number in the ProjAdjustment form, which will get validated before post.
            if (tmpProjAdjustmentCreate.ActivityNumber != '' &&
                smmActivityParentLinkTable::findByActivityAndParent(tmpProjAdjustmentCreate.ActivityNumber,
                                                 smmActivityParentType::Project,
                                                 ProjTable::find(tmpProjAdjustmentCreate.ProjId).RecId,
                                                 tableNum(ProjTable)).RecId == 0
               )
            {
                tmpProjAdjustmentCreate.ActivityNumber = '';
            }

            if (this.isSubscription())
            {
                ProjTable projTableLocal = ProjTable::find(_tmpProjAdjustmentSplit.projId);
                boolean projMultipleContractLinesForProjectFeatureEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

                if ((!projMultipleContractLinesForProjectFeatureEnabled && projTableLocal.Type != ProjType::TimeMaterial) ||
                    (projMultipleContractLinesForProjectFeatureEnabled && !ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(projTableLocal.ProjId, projTableLocal.ProjInvoiceProjId, ProjTransType::Revenue, ProjContractBillingMethod::TimeMaterial)))
                {
                    tmpProjAdjustmentCreate.ProjId = tmpProjAdjustment.ProjId;
                }
            }

            this.initializeProjAdjustmentCreateCategoryIdAndLinePropertyId(_tmpProjAdjustmentSplit);

            this.initializeProjAdjustmentCreateCurrencyId();

            this.initializeProjAdjustmentCreateDimension();
        }

        if (updateTax && !_reverseTrans)
        {
            tmpProjAdjustmentCreate.TaxgroupId = ProjParameters::taxGroupInvoice(tmpProjAdjustmentCreate.ProjId);
            if (tmpProjAdjustmentCreate.checkAdjustmentType(ProjAdjustmentType::Item))
            {
                tmpProjAdjustmentCreate.TaxItemGroupId = ProjParameters::taxItemGroupItem(tmpProjAdjustmentCreate.CategoryId,tmpProjAdjustmentCreate.ItemId);
            }
            else
            {
                tmpProjAdjustmentCreate.TaxItemGroupId = ProjCategory::find(tmpProjAdjustmentCreate.CategoryId).TaxItemGroupId;
            }
        }
        else
        {
            tmpProjAdjustmentCreate.TaxgroupId      = tmpProjAdjustment.TaxGroupId;
            tmpProjAdjustmentCreate.TaxItemGroupId  = tmpProjAdjustment.TaxItemGroupId;
        }

        tmpProjAdjustmentCreate.OriginCost          = tmpProjAdjustment.OriginCost;
        tmpProjAdjustmentCreate.Module              = tmpProjAdjustment.Module;

        tmpProjAdjustmentCreate.psaProjOrigTransId  = tmpProjAdjustment.TransId;

        // Indirect component is only applicable for Hour transaction type. 
        if(tmpProjAdjustmentCreate.AdjustmentType == ProjAdjustmentType::Hour)
        {
            tmpProjAdjustmentCreate.psaIndirectComponentGroup = PSAComponentGroupAssignment::findAssignment(tmpProjAdjustmentCreate.ProjId,
                                                                                                    tmpProjAdjustmentCreate.Resource,
                                                                                                    tmpProjAdjustmentCreate.CategoryId,
                                                                                                    tmpProjAdjustmentCreate.Transdate,
                                                                                                    '','').IndirectComponentGroup;
        }
        

        tmpProjAdjustmentCreate.ProjName = ProjTable::name(tmpProjAdjustmentCreate.ProjId); //Mapping project name to project ID when a new transaction is adjusted
        // <GIN>
        if (TaxParameters::checkTaxParameters_IN() || TaxWithholdParameters_IN::checkTaxParameters())
        {
            ProjQtyCost tmpProjAdjustCreateQty = tmpProjAdjustmentCreate.priceQty();
            ProjQtyCost tmpProjAdjustQty = tmpProjAdjustment.priceQty();
            tmpProjAdjustmentCreate.AssessableValue_IN = tmpProjAdjustment.AssessableValue_IN * ((tmpProjAdjustCreateQty ? tmpProjAdjustCreateQty : 1) / (tmpProjAdjustQty ?  tmpProjAdjustQty : 1));

            if (this.parmMaxRetailPrice()
                && tmpProjAdjustment.ItemId)
            {
                tmpProjAdjustmentCreate.MaximumRetailPrice_IN   = InventTableModule::find(tmpProjAdjustment.ItemId, ModuleInventPurchSales::Sales).MaximumRetailPrice_IN;
            }
            else
            {
                tmpProjAdjustmentCreate.MaximumRetailPrice_IN       = tmpProjAdjustment.MaximumRetailPrice_IN;
            }
            tmpProjAdjustmentCreate.tcsGroup_IN                     = tmpProjAdjustment.tcsGroup_IN;
            tmpProjAdjustmentCreate.tdsGroup_IN                     = tmpProjAdjustment.tdsGroup_IN;
        }
        // </GIN>

        if (updateFundingSource)
        {
            tmpProjAdjustmentCreate.fundingsource = NoYes::Yes;
        }
        else
        {
            tmpProjAdjustmentCreate.fundingsource = NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTmpProjAdjustmentCreateByAdjustmentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TmpProjAdjustmentCreate</c> record based on adjustment type.
    /// </summary>
    protected void initializeTmpProjAdjustmentCreateByAdjustmentType()
    {
        switch (tmpProjAdjustment.AdjustmentType)
        {
            case ProjAdjustmentType::Hour:
                tmpProjAdjustmentCreate.Qty         = -tmpProjAdjustment.Qty;
                tmpProjAdjustmentCreate.IndirectCost = -tmpProjAdjustment.IndirectCosts;
                tmpProjAdjustmentCreate.IndirectSales = -tmpProjAdjustment.IndirectSales;
                tmpProjAdjustmentCreate.TotalCostAmountCur = -tmpProjAdjustment.TotalCostAmountCur;
                tmpProjAdjustmentCreate.TotalSalesAmountCur = -tmpProjAdjustment.TotalSalesAmountCur;
                tmpProjAdjustmentCreate.NewTotalCostAmount = -tmpProjAdjustment.NewTotalCostAmount;
                tmpProjAdjustmentCreate.NewTotalSaleAmount = -tmpProjAdjustment.NewTotalSaleAmount;
                break;

            case ProjAdjustmentType::Cost:
                tmpProjAdjustmentCreate.Qty         = -tmpProjAdjustment.Qty;
                break;
 
            case ProjAdjustmentType::Revenue:
                tmpProjAdjustmentCreate.Qty         = tmpProjAdjustment.Qty;
                break;
       }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjAdjustmentCreateCategoryIdAndLinePropertyId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TmpProjAdjustmentCreate</c> record's category ID and line property ID.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentSplit">
    /// A <c>TmpProjAdjustmentSplit</c> table buffer.
    /// </param>
    protected void initializeProjAdjustmentCreateCategoryIdAndLinePropertyId(TmpProjAdjustmentSplit _tmpProjAdjustmentSplit)
    {
        tmpProjAdjustmentCreate.CategoryId      = tmpProjAdjustment.CategoryId;
        if (this.isSubscription())
        {
            if (_tmpProjAdjustmentSplit.CategoryId && ProjCategory::find(_tmpProjAdjustmentSplit.CategoryId).SetupSubscription == NoYes::Yes)
            {
                tmpProjAdjustmentCreate.CategoryId      = _tmpProjAdjustmentSplit.CategoryId;
            }

            tmpProjAdjustmentCreate.LinePropertyId  = '';
        }
        else
        {
            if (_tmpProjAdjustmentSplit.CategoryId)
            {
                categoryType = ProjCategory::categoryType2TransType(ProjCategory::find(_tmpProjAdjustmentSplit.CategoryId).CategoryType);

                if (categoryType == TmpProjAdjustment::adjustmentType2TransType(tmpProjAdjustment.AdjustmentType))
                {
                    tmpProjAdjustmentCreate.CategoryId  = _tmpProjAdjustmentSplit.CategoryId ;
                }
            }

            if (_tmpProjAdjustmentSplit.LinePropertyId)
            {
                tmpProjAdjustmentCreate.LinePropertyId  = _tmpProjAdjustmentSplit.LinePropertyId;
            }
            else
            {
                if (updateLineProperty)
                {
                    tmpProjAdjustmentCreate.LinePropertyId  = ProjLinePropertySetup::findLinePropertyId(tmpProjAdjustmentCreate.ProjId, tmpProjAdjustmentCreate.CategoryId);
                }
                else
                {
                    tmpProjAdjustmentCreate.LinePropertyId  = tmpProjAdjustment.LinePropertyId;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjAdjustmentCreateCurrencyId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TmpProjAdjustmentCreate</c> record's currency ID.
    /// </summary>
    protected void initializeProjAdjustmentCreateCurrencyId()
    {
        if (updateSalesCurrency)
        {
            tmpProjAdjustmentCreate.CurrencyId = ProjTable::find(tmpProjAdjustmentCreate.ProjId).currencyId();
            if (!tmpProjAdjustmentCreate.CurrencyId)
            {
                tmpProjAdjustmentCreate.CurrencyId = tmpProjAdjustment.CurrencyId;
            }
        }
        else
        {
            tmpProjAdjustmentCreate.CurrencyId = tmpProjAdjustment.CurrencyId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjAdjustmentCreateDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TmpProjAdjustmentCreate</c> record's default dimension.
    /// </summary>
    protected void initializeProjAdjustmentCreateDimension()
    {
        if (updateDimension)
        {
            tmpProjAdjustmentCreate.setDimension();
        }
        else
        {
            tmpProjAdjustmentCreate.DefaultDimension       = tmpProjAdjustment.DefaultDimension;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTransaction</Name>
				<Source><![CDATA[
    protected void deleteTransaction()
    {
        TmpProjAdjustmentCreate::deleteCreateAdjustment(
                                    tmpProjAdjustment,
                                    tmpProjAdjustmentCost,
                                    tmpProjAdjustmentSale,
                                    tmpProjAdjustmentCreate,
                                    tmpProjAdjustmentCreateCost,
                                    tmpProjAdjustmentCreateSale);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        FormRun dialogForm;
        Args formArgs = new Args(formstr(ProjAdjustmentSplit));

        formArgs.caller(this);

        dialogForm = classfactory.formRunClass(formArgs);
        dialogForm.init();

        return dialogForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjTransType</Name>
				<Source><![CDATA[
    public ProjTransType getProjTransType()
    {
        return ProjTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIntegratedProject</Name>
				<Source><![CDATA[
    boolean isIntegratedProject()
    {
        return isIntegratedProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSubscription</Name>
				<Source><![CDATA[
    boolean isSubscription(boolean _isSubscription  = isSubscription)
    {
        isSubscription  = _isSubscription;

        return isSubscription;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(
        TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
        TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
        TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
        TmpProjAdjustment           _tmpProjAdjustment,
        TmpProjAdjustmentCost       _tmpProjAdjustmentCost,
        TmpProjAdjustmentSale       _tmpProjAdjustmentSale)
    {
        tmpProjAdjustmentCreate = _tmpProjAdjustmentCreate;
        tmpProjAdjustmentCreateCost = _tmpProjAdjustmentCreateCost;
        tmpProjAdjustmentCreateSale = _tmpProjAdjustmentCreateSale;

        tmpProjAdjustment = _tmpProjAdjustment;
        tmpProjAdjustmentCost = _tmpProjAdjustmentCost;
        tmpProjAdjustmentSale = _tmpProjAdjustmentSale;

        // determine if it is a subscription
        this.isSubscription(tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Revenue) &&
                            ProjCategory::find(tmpProjAdjustment.CategoryId).SetupSubscription);

        projTransType           = TmpProjAdjustment::adjustmentType2TransType(tmpProjAdjustment.AdjustmentType);

        updatedRecs             = new Map(Types::Int64,Types::Record);

        if (LedgerParameters::isStornoEnabledEE())
        {
            adjustCorrection = ProjParameters::find().ProjectLedgerCorrection;

            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceEEU00015, funcName());
        }
        
        isIntegratedProject = Project::isProjectExternallyManaged(tmpProjAdjustment.ProjId);
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion,#CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerCorrection</Name>
				<Source><![CDATA[
    public LedgerCorrection parmLedgerCorrection(LedgerCorrection _ledgerCorrection = adjustCorrection)
    {
        adjustCorrection = _ledgerCorrection;
        return adjustCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMaxRetailPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///  passing the Max Retails Price
    /// </summary>
    /// <param name="_maxRetailPrice">
    /// _maxRetailPrice
    /// </param>
    /// <returns>
    /// maxretailprice
    /// </returns>
    public NoYes parmMaxRetailPrice(NoYes _maxRetailPrice = maxRetailPrice)
    {
        maxRetailPrice  = _maxRetailPrice;

        return maxRetailPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjQty</Name>
				<Source><![CDATA[
    public Counter parmProjQty(Counter _projQty = projQty)
    {
        int i;

        // Create [projQty] lines with equal distribution
        if (!prmisDefault(_projQty))
        {
            // Reset buffer
            TmpProjAdjustmentSplit = null;

            // Create temporary lines
            for (i = 1; i <= _projQty; i++)
            {
                TmpProjAdjustmentSplit.initValue();
                TmpProjAdjustmentSplit.insert();
            }

            // Distribute equally
            TmpProjAdjustmentSplit::distributeToAll(tmpProjAdjustmentSplit);
        }

        projQty = _projQty;

        return projQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransIdSet</Name>
				<Source><![CDATA[
    public Set parmProjTransIdSet(Set _projTransIdSet = projTransIdSet)
    {
        projTransIdSet = _projTransIdSet;

        return projTransIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpProjAdjustmentSplit</Name>
				<Source><![CDATA[
    public TmpProjAdjustmentSplit parmTmpProjAdjustmentSplit(TmpProjAdjustmentSplit _tmpProjAdjustmentSplit = tmpProjAdjustmentSplit)
    {
        tmpProjAdjustmentSplit = _tmpProjAdjustmentSplit;
        return tmpProjAdjustmentSplit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateDimension</Name>
				<Source><![CDATA[
    public NoYes parmUpdateDimension(NoYes _updateDimension = updateDimension)
    {
        updateDimension  = _updateDimension;

        return updateDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateFundingSource</Name>
				<Source><![CDATA[
    public NoYes parmUpdateFundingSource(NoYes _updateFundingSource = updateFundingSource)
    {
        updateFundingSource = _updateFundingSource;

        return updateFundingSource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateHourCostPrice</Name>
				<Source><![CDATA[
    public NoYes parmUpdateHourCostPrice(NoYes _updateHourCostPrice = updateHourCostPrice)
    {
        updateHourCostPrice  = _updateHourCostPrice;

        return updateHourCostPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateLineProperty</Name>
				<Source><![CDATA[
    public NoYes parmUpdateLineProperty(NoYes _updateLineProperty = updateLineProperty)
    {
        updateLineProperty  = _updateLineProperty;

        return updateLineProperty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateMarkUpPct</Name>
				<Source><![CDATA[
    public Percent parmUpdateMarkUpPct(Percent _updateMarkUpPct = updateMarkUpPct)
    {
        updateMarkUpPct  = _updateMarkUpPct;

        return updateMarkUpPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateSalesCurrency</Name>
				<Source><![CDATA[
    public NoYes parmUpdateSalesCurrency(NoYes _updateSalesCurrency = updateSalesCurrency)
    {
        updateSalesCurrency  = _updateSalesCurrency;

        return updateSalesCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateSalesPrice</Name>
				<Source><![CDATA[
    public ProjSalesPriceMarkup parmUpdateSalesPrice(ProjSalesPriceMarkup _updateSalesPrice = updateSalesPrice)
    {
        updateSalesPrice  = _updateSalesPrice;

        return updateSalesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateTax</Name>
				<Source><![CDATA[
    public NoYes parmUpdateTax(NoYes _updateTax = updateTax)
    {
        updateTax  = _updateTax;

        return updateTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaRecal</Name>
				<Source><![CDATA[
    public void psaRecal(boolean _bRecal)
    {
        bRecal = _bRecal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        #OCCRetryCount

        TmpProjAdjustmentCreate     tmpProjAdjustmentCreate_local;
        TmpProjAdjustmentCreateCost tmpProjAdjustmentCreateCost_local;
        TmpProjAdjustmentCreateSale tmpProjAdjustmentCreateSale_local;
        SetEnumerator               setEnumerator;
        Map                         map;
        List                        createList;
        List                        createCostList;
        List                        createSalesList;
        ListEnumerator              listEnumerator;

        void action()
        {
            ttsbegin;

            updatedRecs.insert(tmpProjAdjustment.RecId,tmpProjAdjustment);
            this.deleteTransaction();
            this.splitTransaction();

            ttscommit;
        }

        try
        {
            select count(RecId) from tmpProjAdjustmentSplit;
            projQty = int642int(tmpProjAdjustmentSplit.RecId);

            if (!projQty && (tmpProjAdjustment.Qty != 0 && !tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Revenue)))
            {
                // It is not possible to split in more lines than %1.
                throw error(strFmt("@SYS56447", tmpProjAdjustment.Qty));
            }

            if (tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Hour) && tmpProjAdjustment.IsIntercompany)
            {
                if (!Box::confirm("@SYS4000679"))
                {
                    return;
                }
            }

            if (!this.shouldProceedWithAdjustment())
            {
                return;
            }            

            createList = new List(Types::Record);
            while select tmpProjAdjustmentCreate
            {
                tmpProjAdjustmentCreate_local.clear();
				tmpProjAdjustmentCreate_local.data(tmpProjAdjustmentCreate);
                createList.addEnd(tmpProjAdjustmentCreate_local);
            }

            createCostList = new List(Types::Record);
            while select tmpProjAdjustmentCreateCost
            {
                tmpProjAdjustmentCreateCost_local.clear();
                tmpProjAdjustmentCreateCost_local.data(tmpProjAdjustmentCreateCost);
                createCostList.addEnd(tmpProjAdjustmentCreateCost_local);
            }

            createSalesList = new List(Types::Record);
            while select tmpProjAdjustmentCreateSale
            {
                tmpProjAdjustmentCreateSale_local.clear();
                tmpProjAdjustmentCreateSale_local.data(tmpProjAdjustmentCreateSale);
                createSalesList.addEnd(tmpProjAdjustmentCreateSale_local);
            }

            ttsbegin;

            if (this.parmProjTransIdSet())
            {
                setEnumerator = this.parmProjTransIdSet().getEnumerator();
                while (setEnumerator.moveNext())
                {
                    select tmpProjAdjustment where tmpProjAdjustment.TransId == setEnumerator.current();
                    if (tmpProjAdjustment)
                    {
                        action();
                    }
                }
            }
            else
            {
                while select tmpProjAdjustment
                {
                    action();
                }
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }

        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }

        catch (Exception::Error)
        {
			if (createList)
            {
                ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(ProjAdjustmentSplit));
                using (var activityContext = logger.projOpsFinActivity().projDeleteFundingLimitTrackingContext())
                {
                    if (ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
                    {
                        // Remove the tracking records
                        ProjFundingLimitTracking projFundingLimitTracking;
                        delete_from projFundingLimitTracking
                            exists join tmpProjAdjustmentCreate
                                where projFundingLimitTracking.TransId == tmpProjAdjustmentCreate.TmpTransId
                                    && tmpProjAdjustmentCreate.TmpTransId != '';

                        select firstOnly tmpProjAdjustmentCreate
                            where tmpProjAdjustmentCreate.TmpTransId == '';
                        if (tmpProjAdjustmentCreate)
                        {
                            str callStack =  ProjOpsInstrumentationLogger::getCallStack(xSession::xppCallStack());

                            logger.logInformation(strFmt("Callstack: %1, ProjId: %2, AdjRefTransId: %3", callStack, tmpProjAdjustmentCreate.ProjId, tmpProjAdjustmentCreate.ProjAdjustRefId));
                        }
                    }

                    delete_from tmpProjAdjustmentCreate;

                    map = new Map(Types::Int64, Types::Int64);
                    listEnumerator = createList.getEnumerator();
                    while (listEnumerator.moveNext())
                    {
                        tmpProjAdjustmentCreate_local.clear();
                        tmpProjAdjustmentCreate_local = listEnumerator.current();

                        tmpProjAdjustmentCreate.clear();
                        tmpProjAdjustmentCreate.data(tmpProjAdjustmentCreate_local);
                        tmpProjAdjustmentCreate.insert();

                        map.insert(tmpProjAdjustmentCreate_local.RecId, tmpProjAdjustmentCreate.RecId);
                    }

                    delete_from tmpProjAdjustmentCreateCost;

                    listEnumerator = createCostList.getEnumerator();
                    while (listEnumerator.moveNext())
                    {
                        tmpProjAdjustmentCreateCost_local.clear();
                        tmpProjAdjustmentCreateCost_local = listEnumerator.current();

                        tmpProjAdjustmentCreateCost.clear();
                        tmpProjAdjustmentCreateCost.data(tmpProjAdjustmentCreateCost_local);
                        tmpProjAdjustmentCreateCost.RefRecId = map.lookup(tmpProjAdjustmentCreateCost_local.RefRecId);
                        tmpProjAdjustmentCreateCost.insert();
                    }

                    delete_from tmpProjAdjustmentCreateSale;

                    listEnumerator = createSalesList.getEnumerator();
                    while (listEnumerator.moveNext())
                    {
                        tmpProjAdjustmentCreateSale_local.clear();
                        tmpProjAdjustmentCreateSale_local = listEnumerator.current();

                        tmpProjAdjustmentCreateSale.clear();
                        tmpProjAdjustmentCreateSale.data(tmpProjAdjustmentCreateSale_local);
                        tmpProjAdjustmentCreateSale.RefRecId = map.lookup(tmpProjAdjustmentCreateSale_local.RefRecId);
                        tmpProjAdjustmentCreateSale.insert();
                    }

                    if (FormDataUtil::getFormDataSource(tmpProjAdjustment))
                    {
                        FormDataUtil::getFormDataSource(tmpProjAdjustment).research();
                        FormDataUtil::getFormDataSource(tmpProjAdjustment).refresh();
                    }
                }
            }

            // Update has been canceled.
            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProceedWithAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the adjustment should proceed.
    /// </summary>
    /// <returns>
    /// true.
    /// </returns>
    protected boolean shouldProceedWithAdjustment()
    {
        // This method is used for extensibility.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPriceSelectionChange</Name>
				<Source><![CDATA[
    public int salesPriceSelectionChange(FormComboBoxControl  _salesPriceComboControl)
    {
        int ret;

        ret = _salesPriceComboControl.selectionChange();
        this.dialogSelectCtrl();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitTransaction</Name>
				<Source><![CDATA[
    protected void splitTransaction()
    {
        boolean     stop    = false;

        counter     = 1;
        origQty     = tmpProjAdjustment.Qty;

        ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(ProjAdjustmentSplit));
        using (var activityContext = logger.projOpsFinActivity().projAdjustmentSplitTransContext())
        {
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::ActionProperty, ProjOpsFinancialsInstrumentationActivites::ActionAdjustingTransaction);
           
            logger.logInformation(strFmt("@Proj:adjTransTelemetry",
                tmpProjAdjustment.ProjId, tmpProjAdjustmentSale.LineAmount, tmpProjAdjustmentSale.TransId,
                tmpProjAdjustmentSale.FundingSource, tmpProjAdjustment.CategoryId, ProjOpsFinancialsInstrumentationActivites::ActionAdjustingTransaction));

            //  Check whether the reverse of original transaction must be created using a tmpProjAdjustmentCreate record or using a Journal
            if (TmpProjAdjustment::createReverseTrans(tmpProjAdjustment.AdjustmentType))
            {
                this.createNewTrans(true);
            }

            this.isSubscription(false);
            if (tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Revenue) &&
                ProjCategory::find(tmpProjAdjustment.CategoryId).SetupSubscription)
            {
                //  subscription can only be split to one record
                this.isSubscription(true);
            }

            //Sets the tmpProjAdjustmentCost and tmpProjAdjustmentSale buffers record corresponding to current transaction.
            //which is passed as an argument to TmpProjAdjustmentCreate::createTrxAmounts
            //Useful when multiple transactions are adjusted at the same time
            select firstonly tmpProjAdjustmentCost where tmpProjAdjustmentCost.TransId == tmpProjAdjustment.TransId;
            select firstonly tmpProjAdjustmentSale where tmpProjAdjustmentSale.TransId == tmpProjAdjustment.TransId;

            if (!ProjFlightStateHelper::isProjUseFundingLimitTrackingForAdjustmentsFlightEnabled())
            {
                TmpProjAdjustment::updateFundingLimits(tmpProjAdjustment, tmpProjAdjustmentSale, false);
            }

            while select tmpProjAdjustmentSplit
                order by Percent
            {
				this.createNewTrans(false, tmpProjAdjustmentSplit);
                counter += 1;
                if (this.isSubscription())
                {
                    break;
                }
            }

            // Correct rounding error if transaction was split into multiple transactions
            if (counter > 2)
            {
				this.correctSplitTotals();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpProjAdjustmentCreate</Name>
				<Source><![CDATA[
    TmpProjAdjustmentCreate tmpProjAdjustmentCreate()
    {
        return tmpProjAdjustmentCreate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer     version     = conPeek(packedClass,1);

        switch (version)
        {
            case #CurrentVersion :
                [version,#CurrentList] = packedClass;
                break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatedPacks</Name>
				<Source><![CDATA[
    container updatedPacks()
    {
        return updatedRecs.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
    {
        boolean ret;

        ret = super(_calledFrom);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS70720";
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctSplitTotals</Name>
				<Source><![CDATA[
    private void correctSplitTotals()
    {
        AmountCur totalCostAmountSum;
        AmountCur totalSalesAmountSum;
        AmountCur costDifference;
        AmountCur salesDifference;
        RecId     lastRecId;

        while select RecId, TotalCostAmountCur, TotalSalesAmountCur, ProjId, ActivityNumber, CategoryId, AdjustmentType from tmpProjAdjustmentCreate
            where tmpProjAdjustmentCreate.TransId == tmpProjAdjustment.TransId 
            && tmpProjAdjustmentCreate.AdjustOrig == NoYes::No
        {
            totalCostAmountSum += tmpProjAdjustmentCreate.TotalCostAmountCur;
            totalSalesAmountSum += tmpProjAdjustmentCreate.TotalSalesAmountCur;
            lastRecId = tmpProjAdjustmentCreate.RecId;
        }

        costDifference  = tmpProjAdjustment.TotalCostAmountCur - totalCostAmountSum;
        salesDifference = tmpProjAdjustment.TotalSalesAmountCur - totalSalesAmountSum;

        // If the TotalCostAmountCur is different from the old total, but Cost price has NOT been adjusted,
        // we have a small rounding difference. We should add this difference to the the last distribution.
        if (costDifference
            && (!updateHourCostPrice || !tmpProjAdjustment.checkAdjustmentType(ProjAdjustmentType::Hour) || tmpProjAdjustment.IsIntercompany))
        {
            select firstonly forupdate tmpProjAdjustmentCreate
                join tmpProjAdjustmentCreateCost
                where tmpProjAdjustmentCreate.RecId == lastRecId
                    && tmpProjAdjustmentCreateCost.RefRecId == lastRecId;

            tmpProjAdjustmentCreate.TotalCostAmountCur += costDifference;
            tmpProjAdjustmentCreate.NewTotalCostAmount += costDifference;
            tmpProjAdjustmentCreateCost.LineAmount += costDifference;
            tmpProjAdjustmentCreateCost.CostPrice = tmpProjAdjustmentCreateCost.LineAmount / (tmpProjAdjustmentCreate.Qty ? tmpProjAdjustmentCreate.Qty : 1);
            tmpProjAdjustmentCreate.update();
            tmpProjAdjustmentCreateCost.update();
        }

        // If the TotalSalesAmountCur is different from the old total, but Sales price has NOT been adjusted,
        // we have a small rounding difference. We should add this difference to the the last distribution.
        if (salesDifference && !updateSalesPrice)
        {
            select firstonly forupdate tmpProjAdjustmentCreate
                join tmpProjAdjustmentCreateSale
                where tmpProjAdjustmentCreate.RecId == lastRecId
                    && tmpProjAdjustmentCreateSale.RefRecId == lastRecId;

            tmpProjAdjustmentCreate.TotalSalesAmountCur += salesDifference;
            tmpProjAdjustmentCreate.NewTotalSaleAmount += salesDifference;
            tmpProjAdjustmentCreateSale.LineAmount += salesDifference;
            tmpProjAdjustmentCreate.update();
            tmpProjAdjustmentCreateSale.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceTotals</Name>
				<Source><![CDATA[
    internal static void balanceTotals(
        TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
        TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
        TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
        TmpProjAdjustment           _tmpProjAdjustment,
        NoYes _updateHourCostPrice,
        ProjSalesPriceMarkup _updateSalesPrice)
    {
        TmpProjAdjustmentCreate tmpProjAdjustmentCreate_local;
        tmpProjAdjustmentCreate_local.linkPhysicalTableInstance(_tmpProjAdjustmentCreate);

        select count(RecId), sum(Qty) from tmpProjAdjustmentCreate_local
            where tmpProjAdjustmentCreate_local.TransId == _tmpProjAdjustment.TransId &&
                tmpProjAdjustmentCreate_local.AdjustOrig == NoYes::No;

        // Return without processing if there aren't 2 or more records in the _tmpProjAdjustmentCreate table
        if (tmpProjAdjustmentCreate_local.RecId < 2)
        {
            return;
        }

        // Return without processing if the quantity is not fully distributed
        if (tmpProjAdjustmentCreate_local.Qty != _tmpProjAdjustment.Qty)
        {
            return;
        }

        ProjAdjustmentSplit prodAdjustmentSplit = new ProjAdjustmentSplit(tmpProjAdjustmentCreate_local, _tmpProjAdjustmentCreateCost, _tmpProjAdjustmentCreateSale, _tmpProjAdjustment, null, null);

        prodAdjustmentSplit.parmUpdateHourCostPrice(_updateHourCostPrice);
        prodAdjustmentSplit.parmUpdateSalesPrice(_updateSalesPrice);

        ttsbegin;
        prodAdjustmentSplit.correctSplitTotals();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the project id of the currently highligted row
    /// </summary>
    /// <returns>Project Id</returns>
    public ProjId getProjId()
    {
        return tmpProjAdjustment.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the resource RecId of the currently highlighted row
    /// </summary>
    /// <returns>Resource RecId</returns>
    public ResourceRecId getResource()
    {
        return TmpProjAdjustment.Resource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRoundedPercent</Name>
				<Source><![CDATA[
    internal Percent parmRoundedPercent(Percent _roundedPercentage = roundedPercentage)
    {
        roundedPercentage = _roundedPercentage;

        return roundedPercentage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplittedPercent</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the splitted percentage with or without rounding.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentSplit">
    ///     A <c>TmpProjAdjustmentSplit</c> table buffer.
    /// </param>
    /// <returns>
    ///     Splitted percentage with or without rounding.
    /// </returns>
    private Percent getSplittedPercent(TmpProjAdjustmentSplit _tmpProjAdjustmentSplit)
    {
        Percent percent;

        if (this.parmRoundedPercent())
        {
            percent = _tmpProjAdjustmentSplit ? this.parmRoundedPercent() : 100;
        }
        else
        {
            percent = _tmpProjAdjustmentSplit ? _tmpProjAdjustmentSplit.Percent : 100;
        }

        return percent;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>