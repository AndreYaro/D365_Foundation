<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjectCommitmentFacade</Name>
	<SourceCode>
		<Declaration><![CDATA[
[SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProductRequisition), SourceDocumentLine_ProductRequisition::PurchaseRequisitionLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProductOrder), SourceDocumentLine_ProductOrder::PurchaseOrderLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_VendorInvoice), SourceDocumentLine_VendorInvoice::VendorInvoiceLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ExpenseReport), SourceDocumentLine_ExpenseReport::ExpenseReportLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProjectTimesheets), SourceDocumentLine_ProjectTimesheets::TimesheetTrans),
SourceDocumentEnumLiteralExtension(enumStr(BudgetReservation_SourceDocumentLine_PSN), enumLiteralStr(BudgetReservation_SourceDocumentLine_PSN, BudgetReservationLine)),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_TravelRequisition), SourceDocumentLine_TravelRequisition::TravelRequisitionLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProjAdvancedJournal), SourceDocumentLine_ProjAdvancedJournal::ProjAdvancedJournalLine)]
public class ProjectCommitmentFacade
{
    #localmacro.declareContainerVariablesMacro
        RecId                               sourceDocumentLineId;
        selectableDataArea                  projectDataAreaId;
        ProjId                              projectId;
        ProjCategoryId                      categoryId;
        smmActivityNumber                   activityNumber;
        LedgerDimensionAccount              ledgerDimension;
        Qty                                 quantity;
        CurrencyCode                        transactionCostCurrency;
        AmountCur                           transactionCurrencyCostAmount;
        AmountMST                           accountingCurrencyCostAmount;
        CurrencyCode                        transactionSalesCurrency;
        AmountMST                           accountingCurrencySalesAmount;
        boolean multiLineDistribution;
    #endmacro

    #localmacro.containerMacro
        [
        sourceDocumentLineId,
        projectDataAreaId,
        projectId,
        categoryId,
        activityNumber,
        ledgerDimension,
        quantity,
        transactionCostCurrency,
        transactionCurrencyCostAmount,
        accountingCurrencyCostAmount,
        transactionSalesCurrency,
        accountingCurrencySalesAmount,
        multiLineDistribution
        ]
    #endmacro

    #localmacro.clearContainerMacro
        sourceDocumentLineId = 0;
        projectDataAreaId = '';
        projectId = '';
        categoryId = '';
        activityNumber = '';
        ledgerDimension = 0;
        quantity = 0;
        transactionCostCurrency = '';
        transactionCurrencyCostAmount = 0;
        accountingCurrencyCostAmount = 0;
        transactionSalesCurrency = '';
        accountingCurrencySalesAmount = 0;
        multiLineDistribution = false;
    #endmacro

    private static ProjOpsInstrumentationLogger logger = ProjOpsInstrumentationLogger::createLogger(classStr(ProjectCommitmentFacade));
                
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>alwaysUpdateProjectCommitments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to project commitments will always be updated for the source document line item.
    /// </summary>
    /// <param name="_sourceDocumentLineItem">
    /// The source document line item.
    /// </param>
    /// <returns>
    /// true if project commitments will always be updated for the source document line item; otherwise,
    /// false.
    /// </returns>
    public static boolean alwaysUpdateProjectCommitments(
        SourceDocumentLineItem  _sourceDocumentLineItem
    )
    {
        boolean                         alwaysUpdateProjectCommitments;
        AccountingDistribution          accountingDistribution;
        AccountingDistribution          referencedAccountingDistribution;
        CostControlTransCommittedCost   costControlTransCommittedCost;
        SourceDocumentLineRecId         sourceDocumentLineRecId;

        if (_sourceDocumentLineItem &&
            ProjectSourceDocumentLineItemHelper::hasProject(_sourceDocumentLineItem) &&
            ProjectCommitmentFacade::parmCanSupportCommitments(_sourceDocumentLineItem))
        {
            sourceDocumentLineRecId = _sourceDocumentLineItem.parmSourceDocumentLine().RecId;

            select firstonly RecId, ReferenceDistribution, SourceDocumentLine, ParentDistribution from accountingDistribution
                where accountingDistribution.SourceDocumentLine == sourceDocumentLineRecId;

            if (_sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem &&
                !accountingDistribution.ReferenceDistribution)
            {
                if (ProjectCommitmentFacade::isProjectSalesItemReqPO(_sourceDocumentLineItem))
                {
                    SalesLine salesLine = PurchLine::findBySourceDocumentLine(sourceDocumentLineRecId).salesLine();
 
                    if (salesLine)
                    {
                        select firstonly RecId from costControlTransCommittedCost
                            where costControlTransCommittedCost.SourceDocumentLine == salesLine.SourceDocumentLine;
                        if (costControlTransCommittedCost.RecId)
                        {
                            // Purchase order commitments created from item req can be updated.
                            alwaysUpdateProjectCommitments = true;
                        }
                    }
                }
                else
                {
                    select firstonly RecId from costControlTransCommittedCost
                        where costControlTransCommittedCost.SourceDocumentLine == accountingDistribution.SourceDocumentLine;

                    if (costControlTransCommittedCost.RecId)
                    {
                        alwaysUpdateProjectCommitments = true;
                    }
                }
            }
            else if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem &&
                        ProjectCommitmentFacade::isProjectSalesItemReqPO(_sourceDocumentLineItem) &&
                        ProjectCommitmentFacade::isProjectBudgetControlEnabled(_sourceDocumentLineItem, true))
            {
                SalesLine salesLine = VendInvoiceInfoLine::findSourceDocumentLine(sourceDocumentLineRecId).purchLine().salesLine();

                if (salesLine)
                {
                    select firstonly RecId from costControlTransCommittedCost
                        where costControlTransCommittedCost.SourceDocumentLine == salesLine.SourceDocumentLine;

                    if (costControlTransCommittedCost.RecId)
                    {
                        alwaysUpdateProjectCommitments = true;
                    }
                }
            }
            else if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                        && !accountingDistribution.ReferenceDistribution
                        && accountingDistribution.ParentDistribution)
            {
                // Fetches reference distribution record from parent distribution record if the available distribution record is child
                // and allows to update the commitments if committed cost records exist for the fetched reference distribution record.
                AccountingDistribution parentAccountingDistribution;
                select firstonly RecId from referencedAccountingDistribution
                    where referencedAccountingDistribution.RecId == parentAccountingDistribution.ReferenceDistribution
                         && referencedAccountingDistribution.SourceDocumentLine != sourceDocumentLineRecId
                exists join parentAccountingDistribution
                    where parentAccountingDistribution.RecId == accountingDistribution.ParentDistribution
                exists join costControlTransCommittedCost
                    where costControlTransCommittedCost.SourceDocumentLine == referencedAccountingDistribution.SourceDocumentLine;
                if (referencedAccountingDistribution.RecId)
                {
                    alwaysUpdateProjectCommitments = true;
                }
            }
            else
            {
                select firstonly RecId from referencedAccountingDistribution
                    where referencedAccountingDistribution.RecId == accountingDistribution.ReferenceDistribution &&
                        referencedAccountingDistribution.SourceDocumentLine != sourceDocumentLineRecId
                exists join costControlTransCommittedCost
                    where costControlTransCommittedCost.SourceDocumentLine == referencedAccountingDistribution.SourceDocumentLine;

                if (referencedAccountingDistribution.RecId)
                {
                    alwaysUpdateProjectCommitments = true;
                }
            }
        }

        return alwaysUpdateProjectCommitments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCheckProjectBudget</Name>
				<Source><![CDATA[
    private static boolean canCheckProjectBudget(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        boolean                             canCheckProjectBudget = true;
        TrvExpTransSourceDocLineItem        trvExpTransSourceDocLineItem;
        SourceDocumentLineImplementation    sourceDocumentLineImplementation;
        PurchLine                           purchLine;
        VendInvoiceInfoLine                 vendInvoiceInfoLine;
        VendInvoiceSaveStatus               vendInvoiceSaveStatus;

        if (_sourceDocumentLineItem is TrvExpTransSourceDocLineItem)
        {
            trvExpTransSourceDocLineItem = _sourceDocumentLineItem;
            canCheckProjectBudget = trvExpTransSourceDocLineItem.parmExpenseLine().isBudgetCheckRequired();
        }
        else if (_sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            sourceDocumentLineImplementation = _sourceDocumentLineItem.parmSourceDocumentLine().getSourceDocumentLineImplementation();
            if (sourceDocumentLineImplementation && sourceDocumentLineImplementation.TableId == tableNum(PurchLine))
            {
                purchLine = sourceDocumentLineImplementation;
                if (purchLine.PurchaseType == PurchaseType::Journal)
                {
                    // Purchase orders of type journal should never be checked for project budget
                    canCheckProjectBudget = false;
                }
            }
            else if (ProjectCommitmentFacade::isProjectSalesItemReqPO(_sourceDocumentLineItem))
            {
                // Purchase orders created from item req should never be checked for project budget.
                canCheckProjectBudget = false;
            }
        }
        else if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
        {
            sourceDocumentLineImplementation = _sourceDocumentLineItem.parmSourceDocumentLine().getSourceDocumentLineImplementation();
            if (sourceDocumentLineImplementation && sourceDocumentLineImplementation.TableId == tableNum(VendInvoiceInfoLine))
            {
                vendInvoiceInfoLine = sourceDocumentLineImplementation;
                vendInvoiceSaveStatus = VendInvoiceInfoTable::findSourceDocumentHeader(_sourceDocumentLineItem.parmSourceDocumentLine().SourceDocumentHeader).VendInvoiceSaveStatus;
                if (!vendInvoiceInfoLine.ParmId && vendInvoiceSaveStatus != VendInvoiceSaveStatus::Pending)
                {
                    canCheckProjectBudget = false;
                }
            }
        }

        return canCheckProjectBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateProjectCommitment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether an existing project commitment must be updated.
    /// </summary>
    /// <param name="_costControlTransCommittedCost">
    /// An existing record of the <c>CostControlTransCommittedCost</c> table.
    /// </param>
    /// <param name="_sourceDocumentLineItem">
    /// An instance of the <c>SourceDocumentLineItem</c> class.
    /// </param>
    /// <param name="_projectId">
    /// The new project ID value.
    /// </param>
    /// <param name="_categoryId">
    /// The new category ID value.
    /// </param>
    /// <param name="_activityNumber">
    /// The new activity number value.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The new ledger dimension value.
    /// </param>
    /// <param name="_quantity">
    /// The new quantity value.
    /// </param>
    /// <param name="_transactionCostCurrency">
    /// The new transaction cost currency value.
    /// </param>
    /// <param name="_transactionCurrencyCostAmount">
    /// The new transaction currency cost amount value.
    /// </param>
    /// <param name="_accountingCurrencyCostAmount">
    /// The new accounting currency cost amount value.
    /// </param>
    /// <param name="_accountingCurrencySalesAmount">
    /// The new accounting currency sales amount value.
    /// </param>
    /// <returns>
    /// true if existing project commitment can be updated; otherwise, false.
    /// </returns>
    protected static boolean canUpdateProjectCommitment(
        CostControlTransCommittedCost       _costControlTransCommittedCost,
        SourceDocumentLineItem              _sourceDocumentLineItem,
        ProjId                              _projectId,
        ProjCategoryId                      _categoryId,
        smmActivityNumber                   _activityNumber,
        LedgerDimensionAccount              _ledgerDimension,
        Qty                                 _quantity,
        CurrencyCode                        _transactionCostCurrency,
        AmountCur                           _transactionCurrencyCostAmount,
        AmountMST                           _accountingCurrencyCostAmount,
        AmountMST                           _accountingCurrencySalesAmount,
        SourceDocumentLineRecId             _deletedSourceDocumentLine = 0)
    {
        boolean                             ret;
        ProjBudgetReductionHistory          projBudgetReductionHistory;
        SourceDocument                      sourceDocument;
        SourceDocumentLineItemIProject      sourceDocumentLineItemIProject;
        SourceDocumentLineItemIProduct      sourceDocumentLineItemIProduct;
        SourceDocumentLineItemIInventory    sourceDocumentLineItemIInventory;
        CustVendAC                          vendAccount;

        if (!_costControlTransCommittedCost ||
            !_sourceDocumentLineItem ||
            !_projectId ||
            !_categoryId ||
            !_transactionCostCurrency)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        if (
            (_costControlTransCommittedCost.SourceDocumentLine != _sourceDocumentLineItem.parmSourceDocumentLine().RecId) ||
            //Summarization fields from accounting distribution table
            (_costControlTransCommittedCost.CurrencyCode != _transactionCostCurrency) ||
            (_costControlTransCommittedCost.LedgerDimension != _ledgerDimension) ||
            //Summarization fields from project accounting distribution table
            (_costControlTransCommittedCost.ProjId != _projectId) ||
            (_costControlTransCommittedCost.CategoryId != _categoryId) ||
            (_costControlTransCommittedCost.ActivityNumber != _activityNumber)
        )
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        sourceDocument = _sourceDocumentLineItem.parmSourceDocument();
        sourceDocumentLineItemIProject = _sourceDocumentLineItem as SourceDocumentLineItemIProject;
        if (_sourceDocumentLineItem is SourceDocumentLineItemIProduct)
        {
            sourceDocumentLineItemIProduct = _sourceDocumentLineItem as SourceDocumentLineItemIProduct;
        }
        if (_sourceDocumentLineItem is SourceDocumentLineItemIInventory)
        {
            sourceDocumentLineItemIInventory = _sourceDocumentLineItem as SourceDocumentLineItemIInventory;
        }
        vendAccount = ProjectSourceDocumentLineItemHelper::vendAccount(_sourceDocumentLineItem);

        if (
            (_costControlTransCommittedCost.ProjType != ProjTable::find(_costControlTransCommittedCost.ProjId).Type) ||
            (_costControlTransCommittedCost.ProjTransType != ProjectSourceDocumentLineItemHelper::projTransType(_sourceDocumentLineItem)) ||
            (_costControlTransCommittedCost.CommittedCostOrig != ProjectSourceDocumentLineItemHelper::committedCostOrig(_sourceDocumentLineItem)) ||
            ((ProjectSourceDocumentLineItemHelper::projTransType(_sourceDocumentLineItem) == ProjTransType::Item) &&
                (sourceDocumentLineItemIProduct) &&
                (_costControlTransCommittedCost.EmplItemId != sourceDocumentLineItemIProduct.parmItemId()))
        )
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (
            ((ProjectSourceDocumentLineItemHelper::projTransType(_sourceDocumentLineItem) != ProjTransType::Item) &&
            ((_costControlTransCommittedCost.Resource != sourceDocumentLineItemIProject.parmProjectResourceRecId()) ||
            (_costControlTransCommittedCost.ResourceCategory != sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId()))) ||
            (_costControlTransCommittedCost.VendAccount != vendAccount) ||
            (_costControlTransCommittedCost.Qty != _quantity) ||
            (_costControlTransCommittedCost.Amount != _transactionCurrencyCostAmount) ||
            (_costControlTransCommittedCost.AmountMst != _accountingCurrencyCostAmount)
        )
        {
            ret = true;
        }

        if (!ret)
        {
            select projBudgetReductionHistory where projBudgetReductionHistory.ProjTransId == _costControlTransCommittedCost.ProjTransId;
            if (projBudgetReductionHistory)
            {
                if (projBudgetReductionHistory.SalesAmountReduced != _accountingCurrencySalesAmount)
                {
                    ret = true;
                }
            }
        }

        if (_deletedSourceDocumentLine
            && _sourceDocumentLineItem.parmSourceDocumentLine().SourceRelationType   == tableNum(BudgetReservationLine_PSN)
            && SourceDocumentLine::find(_deletedSourceDocumentLine).AccountingStatus == SourceDocumentLineAccountingStatus::Finalized)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>carryForwardBudget</Name>
				<Source><![CDATA[
    //jdeguzma: 3
    public static void carryForwardBudget(
        List        _listCarryForward,
        TransDate   _openingDate)
    {
        ListEnumerator              listEnumerator;
        RefRecId                    projBudgetAllocationLineIdRecId;
        AmountMST                   amountReduced;
        ProjBudgetAllocationLine    projBudgetAllocationLine;
        RefRecId                    carryForwardTo;

        listEnumerator = _listCarryForward.getEnumerator();
        while (listEnumerator.moveNext())
        {
            [projBudgetAllocationLineIdRecId, amountReduced] = listEnumerator.current();

            projBudgetAllocationLine = ProjBudgetAllocationLine::find(projBudgetAllocationLineIdRecId);

            if (projBudgetAllocationLine)
            {
                carryForwardTo = ProjectCommitmentFacade::updateCarryForwardBudget(
                    projBudgetAllocationLine.ProjBudgetLine,
                    _openingDate,
                    amountReduced);

                if (!carryForwardTo)
                {
                    throw error("@SYS6144");
                }

                if (projBudgetAllocationLine.CarryForwardTo &&
                    projBudgetAllocationLine.CarryForwardTo != carryForwardTo)
                {
                    projBudgetAllocationLine = ProjBudgetAllocationLine::find(projBudgetAllocationLine.CarryForwardTo);

                    if (!projBudgetAllocationLine)
                    {
                        throw error("@SYS6144");
                    }
                }

                projBudgetAllocationLine.selectForUpdate(true);
                projBudgetAllocationLine.TotalAllocationAmount -= amountReduced;
                projBudgetAllocationLine.CarryForwardAmount += amountReduced;
                projBudgetAllocationLine.CarryForwardTo = carryForwardTo;
                projBudgetAllocationLine.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjectBudgets</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a project budget check for the accounting distributions for the given source document line.
    /// </summary>
    /// <param name="_sourceDocumentLineItem">
    /// A <c>SourceDocumentLineItem</c> object.
    /// </param>
    /// <param name="_suppressMessages">
    /// A Boolean value that indicates whether to suppress the over budget messages; optional.
    /// </param>
    /// <param name="_trackBudgetStatus">
    /// A Boolean value that indicates whether to track the budget status of the transactions; optional.
    /// </param>
    /// <returns>
    /// true to if the project budget check succeeded; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method will not perform reservation of project budgets.
    /// </remarks>
    public static boolean checkProjectBudgets(SourceDocumentLineItem _sourceDocumentLineItem, boolean _suppressMessages = false, boolean _trackBudgetStatus = false)
    {
        Map     projectCommitmentsMap;
        boolean ret = true;

        if (_sourceDocumentLineItem &&
            ProjectSourceDocumentLineItemHelper::hasProject(_sourceDocumentLineItem) &&
            ProjectCommitmentFacade::canCheckProjectBudget(_sourceDocumentLineItem))
        {
            if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem &&
                    ProjectCommitmentFacade::isProjectSalesItemReqPO(_sourceDocumentLineItem) &&
                    ProjectCommitmentFacade::isProjectBudgetControlEnabled(_sourceDocumentLineItem, true))
            {
                SalesLine salesLine = VendInvoiceInfoLine::findSourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId).purchLine().salesLine();

                // If item consumption is already done, budget check is not required.
                if (salesLine.SalesStatus == SalesStatus::Invoiced)
                {
                    ret = false;
                }
            }

            if (ret)
            {
                // Get project commitments map
                projectCommitmentsMap = new Map(Types::String, Types::Container);
                ProjectCommitmentFacade::updateProjectCommitmentsMap(projectCommitmentsMap, _sourceDocumentLineItem, null, 0, true);

                // Perform project budget check
                ret = ProjectCommitmentFacade::performProjectBudgetCheck(_sourceDocumentLineItem, projectCommitmentsMap, _suppressMessages, _trackBudgetStatus);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSourceDocumentLineImplementation</Name>
				<Source><![CDATA[
    private static boolean checkSourceDocumentLineImplementation(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        boolean checkSourceDocumentLineImplementation;

        checkSourceDocumentLineImplementation = ProjectCommitmentFacade::canCheckProjectBudget(_sourceDocumentLineItem);

        return checkSourceDocumentLineImplementation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteProjectCommitments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates reversing project commitment entries for the existing project commitments of the given source
    /// document line.  This method will also handle liquidation of project budgets if project budgeting is
    /// enabled.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    /// The ID of the <c>SourceDocumentLine</c> record.
    /// </param>
    /// <param name="_carryForward">
    /// A Boolean value that determines whether carry forward process will be run; optional.
    /// </param>
    /// <param name="_openingDate">
    /// Opening date for the next fiscal period.
    /// </param>
    /// <remarks>
    /// Use this method when the source document line is to be deleted or cancelled.
    /// </remarks>
    public static void deleteProjectCommitments(RefRecId _sourceDocumentLine, boolean _carryForward = false, TransDate _openingDate = dateNull())
    {
        ProjOpsBudgetingInstrumentationActivites activities = ProjOpsBudgetingInstrumentationActivites::construct(logger);
        using (SysInstrumentationActivityContext activityContext = activities.activityContext(ProjOpsBudgetingInstrumentationActivites::DeleteProjCommitments))
        {
            activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::SourceDocumentLineProperty, any2Str(_sourceDocumentLine));
            activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::CarryForwardProperty, any2Str(_carryForward));
            activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::OpeningDateProperty, any2Str(_openingDate));
            if (_sourceDocumentLine)
            {
                ttsbegin;
                ProjectCommitmentFacade::performDeleteProjectCommitments(_sourceDocumentLine, '', _carryForward, _openingDate);
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteProjectCommitmentsForDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates reversing project commitment entries for the existing project commitments of the given source
    /// document line.  This method will also handle liquidation of project budgets if project budgeting is
    /// enabled.
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    /// The ID of the <c>SourceDocumentHeader</c> record.
    /// </param>
    /// <param name="_voucher">
    /// The voucher of the project actual transaction.
    /// </param>
    /// <param name="_carryForward">
    /// A Boolean value that determines whether carry forward process will be run; optional.
    /// </param>
    /// <param name="_openingDate">
    /// Opening date for the next fiscal period.
    /// </param>
    /// <remarks>
    /// Use this method when the source document header is to be deleted or cancelled.
    /// </remarks>
    public static void deleteProjectCommitmentsForDocument(
        RefRecId    _sourceDocumentHeader,
        Voucher     _voucher = '',
        boolean     _carryForward = false,
        TransDate   _openingDate = dateNull()
    )
    {
        
        ProjOpsBudgetingInstrumentationActivites activity = ProjOpsBudgetingInstrumentationActivites::construct(logger);
        using (SysInstrumentationActivityContext activityContext = activity.instrumentSourceDocumentHeader(ProjOpsBudgetingInstrumentationActivites::DeleteProjCommitments, _sourceDocumentHeader))
        {
            SourceDocumentLine      sourceDocumentLine;

            if (_sourceDocumentHeader)
            {
                ttsbegin;
                while select RecId from sourceDocumentLine
                    where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeader
                {
                    activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::SourceDocumentLineProperty + ProjOpsBudgetingInstrumentationActivites::RecIdProperty, any2Str(sourceDocumentLine.RecId));
                    activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::CarryForwardProperty, any2Str(_carryForward));
                    activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::OpeningDateProperty, any2Str(_openingDate));
                    activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::VoucherProperty, any2Str(_voucher));
                    ProjectCommitmentFacade::performDeleteProjectCommitments(sourceDocumentLine.RecId, _voucher, _carryForward, _openingDate);
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doUpdateProjectCommitments</Name>
				<Source><![CDATA[
    private static void doUpdateProjectCommitments(SourceDocumentLineItem _sourceDocumentLineItem, boolean _skipCommittedCostParameter = false, boolean _supressMessages = false, boolean _trackBudgetStatus = false, SourceDocumentLineItem _relievingSourceDocumentLineItem = null, RefRecId _deletedSourceDocumentLine = 0, boolean _reverseCurrentCommitment = false)
    {
        #declareContainerVariablesMacro

        CostControlPostingSourceDocumentLine    costControlPostingSourceDocumentLine;
        str                                     key;
        Map                                     projectCommitmentsMap;
        MapEnumerator                           mapEnumerator;
        Map                                     relieveCommitmentsMap;
        CostControlTransCommittedCost           costControlTransCommittedCost;
        ProjTransIdBase                         transactionId;
        SourceDocumentLineRecId                 sourceDocumentLineRecId;
        PurchReqSourceDocLineItem               purchReqSourceDocLineItem;
        
        SourceDocumentLineRecId                 relievingsourceDocumentLineRecId;
        boolean                                 projectCommitmentsUpdated;
        PurchLine                               purchLine;
        BudgetReservationSourceDocumentLineItem_PSN budgetReservationSourceDocumentLineItem;

        void updateExistingProjCommitments(RefRecId     _sourceDocumentLineRecId)
        {
            //Update existing project commitments
            while select costControlTransCommittedCost
                 where costControlTransCommittedCost.SourceDocumentLine == _sourceDocumentLineRecId &&
                       costControlTransCommittedCost.Open == NoYes::Yes
            {
                key = ProjectCommitmentFacade::keyFromProjectCommitment(costControlTransCommittedCost);

                //Key for existing project commitment doesn't exist in the new list of project commitments being recreated
                if (!projectCommitmentsMap.exists(key))
                {
                    //Relieve existing project commitment
                    costControlPostingSourceDocumentLine =  CostControlPostingSourceDocumentLine::construct(
                                                        _sourceDocumentLineItem,
                                                        costControlTransCommittedCost.ProjTransId,
                                                        costControlTransCommittedCost.ProjId,
                                                        costControlTransCommittedCost.CategoryId,
                                                        costControlTransCommittedCost.ActivityNumber,
                                                        costControlTransCommittedCost.LedgerDimension,
                                                        0,
                                                        costControlTransCommittedCost.CurrencyCode,
                                                        0,
                                                        0,
                                                        0);
                    costControlPostingSourceDocumentLine.parmSupressMessages(_supressMessages);
                    costControlPostingSourceDocumentLine.run(ProjCommittedCostUpdateAction::Delete);
                    projectCommitmentsUpdated = true;
                }
                else
                {
                    #containerMacro = projectCommitmentsMap.lookup(key);
                    transactionId = costControlTransCommittedCost.ProjTransId;

                    projectCommitmentsMap.remove(key);

                    if (
                        // If all amounts are zero, it shouldn't matter what the quantity number is.
                        // Without this check, the system will add an open cost commitment record with amount = 0.
                        (FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance()) || !quantity) &&
                        !transactionCurrencyCostAmount &&
                        !accountingCurrencyCostAmount &&
                        !accountingCurrencySalesAmount)
                    {
                        //Relieve existing project commitment and then create a new project commitment
                        costControlPostingSourceDocumentLine = CostControlPostingSourceDocumentLine::construct(
                                                                                                    _sourceDocumentLineItem,
                                                                                                    transactionId,
                                                                                                    projectId,
                                                                                                    categoryId,
                                                                                                    activityNumber,
                                                                                                    ledgerDimension,
                                                                                                    0,
                                                                                                    transactionCostCurrency,
                                                                                                    0,
                                                                                                    0,
                                                                                                    0);

                        costControlPostingSourceDocumentLine.parmSupressMessages(_supressMessages);
                        costControlPostingSourceDocumentLine.run(ProjCommittedCostUpdateAction::Delete);
                        projectCommitmentsUpdated = true;
                    }
                    else if (ProjectCommitmentFacade::canUpdateProjectCommitment(
                        costControlTransCommittedCost,
                        _sourceDocumentLineItem,
                        projectId,
                        categoryId,
                        activityNumber,
                        ledgerDimension,
                        quantity,
                        transactionCostCurrency,
                        transactionCurrencyCostAmount,
                        accountingCurrencyCostAmount,
                        accountingCurrencySalesAmount,
                        _deletedSourceDocumentLine))
                    {
                        //Relieve existing project commitment and then create a new project commitment
                        costControlPostingSourceDocumentLine = CostControlPostingSourceDocumentLine::construct(
                                                                                                    _sourceDocumentLineItem,
                                                                                                    transactionId,
                                                                                                    projectId,
                                                                                                    categoryId,
                                                                                                    activityNumber,
                                                                                                    ledgerDimension,
                                                                                                    quantity,
                                                                                                    transactionCostCurrency,
                                                                                                    transactionCurrencyCostAmount,
                                                                                                    accountingCurrencyCostAmount,
                                                                                                    accountingCurrencySalesAmount);

                        costControlPostingSourceDocumentLine.parmSupressMessages(_supressMessages);
                        costControlPostingSourceDocumentLine.parmTrackBudgetStatus(_trackBudgetStatus);

                        costControlPostingSourceDocumentLine.run(ProjCommittedCostUpdateAction::UpdateReverse);
                        projectCommitmentsUpdated = true;
                    }
                }
            }
        }

        sourceDocumentLineRecId                 = _sourceDocumentLineItem.parmSourceDocumentLine().RecId;

        //Get project commitments map
        projectCommitmentsMap = new Map(Types::String, Types::Container);
        ProjectCommitmentFacade::updateProjectCommitmentsMap(projectCommitmentsMap, _sourceDocumentLineItem, _relievingSourceDocumentLineItem, _deletedSourceDocumentLine);

        //If purchase order line is canceled or not confirmed, project commitments should not be created.
        if (_sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            changeCompany (_sourceDocumentLineItem.parmSourceDocumentLineImplementation().company())
            {
                purchLine =  purchLine::findBySourceDocumentLine(sourceDocumentLineRecId);

                if (!purchLine)
                {
                    return;
                }

                if (purchLine.PurchStatus == PurchStatus::Canceled)
                {
                    ProjectCommitmentFacade::deleteProjectCommitments(sourceDocumentLineRecId);
                    return;
                }

                if (!(purchLine.purchTable().DocumentState == VersioningDocumentState::Confirmed))
                {
                    updateExistingProjCommitments(sourceDocumentLineRecId);
                    
                    if (!projectCommitmentsUpdated)
                    {
                        // Performs budget check only if the related PR is closed.
                        if (purchLine.PurchReqLineRefId)
                        {
                            PurchReqLine purchReqLine;
                            select firstonly RequisitionStatus from purchReqLine
                                where purchReqLine.LineRefId == purchLine.PurchReqLineRefId;
                            if (purchReqLine.RequisitionStatus == PurchReqRequisitionStatus::Closed)
                            {
                                ProjectCommitmentFacade::checkProjectBudgets(_sourceDocumentLineItem, ProjectCommitmentFacade::suppressMessages(_sourceDocumentLineItem), true);
                            }
                        }
                        else
                        {
                            ProjectCommitmentFacade::checkProjectBudgets(_sourceDocumentLineItem, ProjectCommitmentFacade::suppressMessages(_sourceDocumentLineItem), true);
                        }
                    }
                    return;
                }
            }
        }

        updateExistingProjCommitments(sourceDocumentLineRecId);

        //If purchase requisition is closed, project commitments should not be created.
        purchReqSourceDocLineItem = _sourceDocumentLineItem as PurchReqSourceDocLineItem;
        if (purchReqSourceDocLineItem)
        {
            changeCompany (purchReqSourceDocLineItem.parmSourceDocumentLineImplementation().company())
            {
                if (PurchReqLine::find(purchReqSourceDocLineItem.parmSourceDocumentLineImplementation().RecId).RequisitionStatus == PurchReqRequisitionStatus::Closed)
                {
                    ProjectCommitmentFacade::deleteProjectCommitments(sourceDocumentLineRecId);

                    return;
                }
            }
        }

        // If the Budget reservation line is finalized or canceled, project commitments should not be created.
        budgetReservationSourceDocumentLineItem = _sourceDocumentLineItem as BudgetReservationSourceDocumentLineItem_PSN;

        if (budgetReservationSourceDocumentLineItem
            && (budgetReservationSourceDocumentLineItem.parmSourceDocumentLine().AccountingStatus == SourceDocumentLineAccountingStatus::Finalized
                || budgetReservationSourceDocumentLineItem.parmSourceDocumentLine().AccountingStatus == SourceDocumentLineAccountingStatus::Canceled)
            && PublicSectorUtils::isBudgetReservationEnabled())
        {
            return;
        }

        // When we're trying to relieved an SDL and there's an existing open commitment for the current document line
        // we need to reverse that existing open commitment first so we can update the budget to the correct amount
        if (_reverseCurrentCommitment)
        {
            relieveCommitmentsMap = new Map(Types::String, Types::Container);
            ProjectCommitmentFacade::updateProjectCommitmentsMap(relieveCommitmentsMap, _relievingSourceDocumentLineItem);

            while select costControlTransCommittedCost
                    where costControlTransCommittedCost.SourceDocumentLine == _relievingSourceDocumentLineItem.parmSourceDocumentLine().RecId
                       && costControlTransCommittedCost.Open == NoYes::Yes
            {
                changecompany (costControlTransCommittedCost.company())
                {
                    key = ProjectCommitmentFacade::keyFromProjectCommitment(costControlTransCommittedCost);

                    if (relieveCommitmentsMap.exists(key))
                    {
                        #containerMacro = relieveCommitmentsMap.lookup(key);
                        transactionId = costControlTransCommittedCost.ProjTransId;

                        relieveCommitmentsMap.remove(key);

                        if (ProjectCommitmentFacade::canUpdateProjectCommitment(
                            costControlTransCommittedCost,
                            _relievingSourceDocumentLineItem,
                            projectId,
                            categoryId,
                            activityNumber,
                            ledgerDimension,
                            quantity,
                            transactionCostCurrency,
                            transactionCurrencyCostAmount,
                            accountingCurrencyCostAmount,
                            accountingCurrencySalesAmount))
                        {
                            //Relieve existing project commitment and then create a new project commitment
                            costControlPostingSourceDocumentLine = CostControlPostingSourceDocumentLine::construct(
                                                                                                        _relievingSourceDocumentLineItem,
                                                                                                        transactionId,
                                                                                                        projectId,
                                                                                                        categoryId,
                                                                                                        activityNumber,
                                                                                                        ledgerDimension,
                                                                                                        quantity,
                                                                                                        transactionCostCurrency,
                                                                                                        transactionCurrencyCostAmount,
                                                                                                        accountingCurrencyCostAmount,
                                                                                                        accountingCurrencySalesAmount);

                            costControlPostingSourceDocumentLine.run(ProjCommittedCostUpdateAction::UpdateReverse);
                        }
                    }
                }
            }
        }

        //Create new project commitments
        mapEnumerator = projectCommitmentsMap.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            #containerMacro = mapEnumerator.currentValue();

            if (multiLineDistribution
                && _sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
            {
                if (!purchLine)
                {
                    purchLine = PurchLine::findBySourceDocumentLine(sourceDocumentLineRecId);
                }
                
                // Default the value to the delivery remainder quantity when there is purchase quantity equals delivery remainder quantity and there is no invoice or packingslip defined.
                // While confirming the PO when we have multiple distributions i.e. when we split the quantity with percentage in distributions,
                // it is considering latest quantity from map <c>_projectCommitmentsMap</c> In order to resolve this issue, updating the quantity from <c>purchLine.RemainPurchPhysical</c>.
                if (quantity != purchLine.RemainPurchPhysical && purchLine.PurchQty == purchLine.RemainPurchPhysical && !purchLine.receivedInTotalServer())
                {
                    quantity = purchLine.RemainPurchPhysical;
                }

            }

            if (!projectCommitmentsUpdated &&
                _sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem &&
                _relievingSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem &&
                !CostControlTransCommittedCost::existOpenBySourceDocumentLine(sourceDocumentLineRecId) &&
                quantity)
            {
                relievingsourceDocumentLineRecId = _relievingSourceDocumentLineItem.parmSourceDocumentLine().RecId;
                updateExistingProjCommitments(relievingsourceDocumentLineRecId);
            }

            changecompany (projectDataAreaId)
            {
                select firstonly ProjTransId
                from costControlTransCommittedCost
                where costControlTransCommittedCost.SourceDocumentLine == sourceDocumentLineRecId &&
                    costControlTransCommittedCost.CurrencyCode == transactionCostCurrency &&
                    costControlTransCommittedCost.LedgerDimension == ledgerDimension &&
                    costControlTransCommittedCost.ProjId == projectId &&
                    costControlTransCommittedCost.CategoryId == categoryId &&
                    costControlTransCommittedCost.ActivityNumber == activityNumber;

                transactionId = costControlTransCommittedCost.ProjTransId;

                if (!transactionId)
                {
                    transactionId = ProjParameters::newTransId();
                }

                costControlPostingSourceDocumentLine = CostControlPostingSourceDocumentLine::construct(
                                                                                            _sourceDocumentLineItem,
                                                                                            transactionId,
                                                                                            projectId,
                                                                                            categoryId,
                                                                                            activityNumber,
                                                                                            ledgerDimension,
                                                                                            quantity,
                                                                                            transactionCostCurrency,
                                                                                            transactionCurrencyCostAmount,
                                                                                            accountingCurrencyCostAmount,
                                                                                            accountingCurrencySalesAmount);
                costControlPostingSourceDocumentLine.parmSupressMessages(_supressMessages);
                costControlPostingSourceDocumentLine.parmTrackBudgetStatus(_trackBudgetStatus);
                costControlPostingSourceDocumentLine.parmSkipCommittedCostParameter(_skipCommittedCostParameter);
                costControlPostingSourceDocumentLine.run(ProjCommittedCostUpdateAction::Create);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjectBudgetControlEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether project budget control is enabled for the source document line item.
    /// </summary>
    /// <param name="_sourceDocumentLineItem">
    /// The source document line item.
    /// </param>
    /// <param name="_isOnDemandBudgetCheck">
    /// A Boolean value that indicates whether to perform an on-demand project budget check.
    /// </param>
    /// <returns>
    /// true if project budget control is enabled for the source document line item; otherwise, false.
    /// </returns>
    public static boolean isProjectBudgetControlEnabled(
        SourceDocumentLineItem  _sourceDocumentLineItem,
        boolean                 _isOnDemandBudgetCheck
    )
    {
        boolean isProjectBudgetControlEnabled;
        boolean validateLineEntryConfiguration;
        SourceDocumentLineItemITimesheets iTimesheets;
        CompanyInfo companyInfo;
        boolean     isIntercompany = false;

        if (_sourceDocumentLineItem &&
            ProjectSourceDocumentLineItemHelper::hasProject(_sourceDocumentLineItem))
        {
            isProjectBudgetControlEnabled = true;

            validateLineEntryConfiguration = !_isOnDemandBudgetCheck;
            if (validateLineEntryConfiguration)
            {
                if (_sourceDocumentLineItem is SourceDocumentLineItemITimesheets)
                {
                    iTimesheets = _sourceDocumentLineItem as SourceDocumentLineItemITimesheets;
                    companyInfo = CompanyInfo::findRecId(iTimesheets.parmProjectLegalEntity());
                    isIntercompany = companyInfo.DataArea != curext();
                }
                else if (_sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
                {
                    ProjAdvancedJournalSourceDocumentLineItem projAdvancedJournalSourceDocumentLineItem = _sourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
                    isIntercompany = projAdvancedJournalSourceDocumentLineItem.parmProjectDataAreaId() != curext();
                }
                else
                {
                    if (_sourceDocumentLineItem.parmLegalEntityRecId())
                    {
                        companyInfo = CompanyInfo::findRecId(_sourceDocumentLineItem.parmLegalEntityRecId());
                        isIntercompany = true;
                    }
                }

                SourceDocumentLineItemIProject sourceDocumentLineItemIProject = _sourceDocumentLineItem as SourceDocumentLineItemIProject;

                if (sourceDocumentLineItemIProject != null)
                {
                    ProjTable proj = ProjTable::find(sourceDocumentLineItemIProject.parmProjectId());
                    isProjectBudgetControlEnabled = (proj.UseBudgeting == NoYes::Yes);
                }

                if (isIntercompany)
                {
                    changecompany (companyInfo.DataArea)
                    {
                        isProjectBudgetControlEnabled = isProjectBudgetControlEnabled && (ProjParameters::find().EnableBudgetCheckOnLineSave == NoYes::Yes);
                    }
                }
                else
                {
                    isProjectBudgetControlEnabled = isProjectBudgetControlEnabled && (ProjParameters::find().EnableBudgetCheckOnLineSave == NoYes::Yes);
                }
            }
        }

        return isProjectBudgetControlEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjectSalesItemReqPO</Name>
				<Source><![CDATA[
    private static boolean isProjectSalesItemReqPO(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        boolean isProjectSalesItemReqPO;
        PurchTable purchTable;
        PurchLine purchLine;

        SourceDocumentLineImplementation sourceDocumentLineImplementation = _sourceDocumentLineItem.parmSourceDocumentLine().getSourceDocumentLineImplementation();
        if (sourceDocumentLineImplementation)
        {
            VendInvoiceInfoLine vendInvoiceInfoLine;

            switch (sourceDocumentLineImplementation.TableId)
            {
                case tableNum(PurchLine):
                    purchLine = sourceDocumentLineImplementation;
                    purchTable = purchLine.purchTable();
                    if (purchTable)
                    {
                        isProjectSalesItemReqPO = purchTable.isProjectSalesItemReqPO();
                    }
                    if (!isProjectSalesItemReqPO)
                    {
                        isProjectSalesItemReqPO = purchLine.getProjCreditNoteSource().purchTable().isProjectSalesItemReqPO();
                    }
                    break;
                case tableNum(VendInvoiceInfoLine):
                    vendInvoiceInfoLine = sourceDocumentLineImplementation;
                    if (!vendInvoiceInfoLine.isNonPO())
                    {
                        purchLine = vendInvoiceInfoLine.purchLine();
                        if (purchLine)
                        {
                            purchTable = purchLine.purchTable();
                            if (purchTable)
                            {
                                isProjectSalesItemReqPO = purchTable.isProjectSalesItemReqPO();
                            }
                            if (!isProjectSalesItemReqPO)
                            {
                                isProjectSalesItemReqPO = purchLine.getProjCreditNoteSource().purchTable().isProjectSalesItemReqPO();
                            }
                        }
                    }
                    break;
                case tableNum(VendInvoiceTrans):
                    VendInvoiceTrans vendInvoiceTrans = sourceDocumentLineImplementation;
                    if (!vendInvoiceTrans.isNonPO())
                    {
                        purchLine = vendInvoiceTrans.purchLine();
                        if (purchLine)
                        {
                            purchTable = purchLine.purchTable();
                            if (purchTable)
                            {
                                isProjectSalesItemReqPO = purchTable.isProjectSalesItemReqPO();
                            }
                            if (!isProjectSalesItemReqPO)
                            {
                                isProjectSalesItemReqPO = purchLine.getProjCreditNoteSource().purchTable().isProjectSalesItemReqPO();
                            }
                        }
                    }
                    break;
            }
        }
        else
        {
            if (enumName2Id(_sourceDocumentLineItem.parmSourceDocument().parmSourceDocumentHeader().TypeEnumName) == enumNum(SourceDocument_ProductOrder) &&
                _sourceDocumentLineItem.parmSourceDocument().parmSourceDocumentHeader().TypeEnumValue == SourceDocument_ProductOrder::PurchaseOrder)
            {
                purchTable = PurchTable::findSourceDocumentHeader(_sourceDocumentLineItem.parmSourceDocument().parmSourceDocumentHeader().RecId);
                if (purchTable)
                {
                    isProjectSalesItemReqPO = purchTable.isProjectSalesItemReqPO();
                }

                if (isProjectSalesItemReqPO)
                {
                    purchLine = PurchLine::findBySourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                }
            }
            else if (enumName2Id(_sourceDocumentLineItem.parmSourceDocument().parmSourceDocumentHeader().TypeEnumName) == enumNum(SourceDocument_VendorInvoice) &&
                _sourceDocumentLineItem.parmSourceDocument().parmSourceDocumentHeader().TypeEnumValue == SourceDocument_VendorInvoice::VendorInvoice)
            {
                VendInvoiceInfoTable vendInvoiceInfoTable = VendInvoiceInfoTable::findSourceDocumentHeader(_sourceDocumentLineItem.parmSourceDocument().parmSourceDocumentHeader().RecId);
                if (vendInvoiceInfoTable)
                {
                    purchTable = vendInvoiceInfoTable.purchTable();
                    if (purchTable)
                    {
                        isProjectSalesItemReqPO = purchTable.isProjectSalesItemReqPO();
                    }
                }

                if (isProjectSalesItemReqPO)
                {
                    purchLine = VendInvoiceInfoLine::findSourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId).purchLine();
                }
            }
        }

        // If the item requirement or sales order line is not linked to purchase order for non-stocked items then the commitments should be created.
        if (isProjectSalesItemReqPO
            && purchLine
            && !purchLine.isStocked()
            && !purchline.salesLine())
        {
            isProjectSalesItemReqPO = false;
        }

        return isProjectSalesItemReqPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyFromAccountingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Concatenates the accounting distribution values that are used as a map key when summarizing
    /// accounting distribution values.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    /// A record in the <c>SourceDocumentLine</c> table.
    /// </param>
    /// <param name="_accountingDistribution">
    /// A record in the <c>AccountingDistribution</c> table.
    /// </param>
    /// <param name="_projectAccountingDistribution">
    /// A record in the <c>ProjectAccountingDistribution</c> table.
    /// </param>
    /// <returns>
    /// A concatenated string that is used as a map key when summarizing accounting distribution values.
    /// </returns>
    private static str keyFromAccountingDistribution(
        SourceDocumentLine              _sourceDocumentLine,
        AccountingDistribution          _accountingDistribution,
        ProjectAccountingDistribution   _projectAccountingDistribution)
    {
        str key;

        key = //Summarization fields from accounting distribution table
            int642str(_sourceDocumentLine.RecId) + '#' +
            _accountingDistribution.TransactionCurrency + '#' +
            int642str(_accountingDistribution.LedgerDimension) + '#' +
            //Summarization values from project accounting distribution
            CompanyInfo::findRecId(_accountingDistribution.AccountingLegalEntity).DataArea + '#' +
            int642str(_projectAccountingDistribution.ProjTable) + '#' +
            int642str(_projectAccountingDistribution.ProjCategory) + '#' +
            int642str(_projectAccountingDistribution.SmmActivities);

        return key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingDistributionCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the count of unique records for the accounting distribution query by key map fields.
    /// </summary>
    /// <param name="_sourceDocumentLine">
    /// A record in the <c>SourceDocumentLine</c> table.
    /// </param>
    /// <param name="_accountingDistribution">
    /// A record in the <c>AccountingDistribution</c> table.
    /// </param>
    /// <param name="_projectAccountingDistribution">
    /// A record in the <c>ProjectAccountingDistribution</c> table.
    /// </param>
    /// <returns>
    /// The count records for the accounting distribution map key.
    /// </returns>
    private static int getAccountingDistributionCount(
        SourceDocumentLine _sourceDocumentLine,
        AccountingDistribution _accountingDistribution,
        ProjectAccountingDistribution  _projectAccountingDistribution)
    {
        AccountingDistribution accountingDistribution;
        ProjectAccountingDistribution projectAccountingDistribution;

        select count(RecId) from accountingDistribution
            where accountingDistribution.SourceDocumentLine == _sourceDocumentLine.RecId &&
                accountingDistribution.TransactionCurrency == _accountingDistribution.TransactionCurrency &&
                accountingDistribution.LedgerDimension == _accountingDistribution.LedgerDimension &&
                accountingDistribution.AccountingLegalEntity == _accountingDistribution.AccountingLegalEntity &&
                accountingDistribution.MonetaryAmount == _accountingDistribution.MonetaryAmount
        exists join projectAccountingDistribution
            where projectAccountingDistribution.AccountingDistribution == accountingDistribution.RecId &&
                projectAccountingDistribution.ProjTable == _projectAccountingDistribution.ProjTable &&
                projectAccountingDistribution.ProjCategory == _projectAccountingDistribution.ProjCategory &&
                projectAccountingDistribution.smmActivities == _projectAccountingDistribution.smmActivities;

        return int642int(accountingDistribution.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyFromProjectCommitment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Concatenates project commitment values that are used as a map key.
    /// </summary>
    /// <param name="_costControlTransCommittedCost">
    /// A record in the <c>CostControlTransCommittedCost</c> table.
    /// </param>
    /// <returns>
    /// A concatenated string that is used as a map key.
    /// </returns>
    private static str keyFromProjectCommitment(CostControlTransCommittedCost _costControlTransCommittedCost)
    {
        ProjTable       projTable = ProjTable::find(_costControlTransCommittedCost.ProjId);
        ProjCategory    projCategory = ProjCategory::find(_costControlTransCommittedCost.CategoryId);
        smmActivities   smmActivities = smmActivities::find(_costControlTransCommittedCost.ActivityNumber);
        str             key;

        key = //Summarization fields from accounting distribution table
            int642str(_costControlTransCommittedCost.SourceDocumentLine) + '#' +
            _costControlTransCommittedCost.CurrencyCode + '#' +
            int642str(_costControlTransCommittedCost.LedgerDimension) + '#' +
            //Summarization fields from project accounting distribution table
            _costControlTransCommittedCost.DataAreaId + '#' +
            int642str(projTable.RecId) + '#' +
            int642str(projCategory.RecId) + '#' +
            int642str(smmActivities.RecId);

        return key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanBookCommitments</Name>
				<Source><![CDATA[
    public static boolean parmCanBookCommitments(SourceDocumentLineItem _sourceDocumentLineItem, SelectableDataArea _dataArea)
    {
        boolean canBookCommitments;

        if (_sourceDocumentLineItem && _dataArea)
        {
            canBookCommitments = ProjectCommitmentFacade::parmCanSupportCommitments(_sourceDocumentLineItem) &&
                ProjectCommitmentFacade::parmIsCommitmentsEnabled(_sourceDocumentLineItem.parmSourceDocumentLine(), _dataArea);
        }

        return canBookCommitments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanSupportCommitments</Name>
				<Source><![CDATA[
    private static boolean parmCanSupportCommitments(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        boolean                             canSupportCommitments;
        UnknownNoYes                        canSupportCommitmentsCache;

        if (ProjectSourceDocumentLineItemHelper::hasProject(_sourceDocumentLineItem))
        {
            canSupportCommitmentsCache = SysTransactionScopeCache::get(funcName(), _sourceDocumentLineItem);

            if (canSupportCommitmentsCache == UnknownNoYes::Unknown)
            {
                canSupportCommitmentsCache = UnknownNoYes::No;

                List listEnumsFromAttributes = SourceDocumentExtensionUtil::getEnumValuesFromAttributes(classStr(ProjectCommitmentFacade));
                ListEnumerator listEnumsFromAttributesEnumerator = listEnumsFromAttributes.getEnumerator();

                SourceDocumentLine sourceDocumentLine = _sourceDocumentLineItem.parmSourceDocumentLine();

                while (listEnumsFromAttributesEnumerator.moveNext())
                {
                    container conEnumValue = listEnumsFromAttributesEnumerator.current();

                    if (sourceDocumentLine.TypeEnumName == enumId2Name(conPeek(conEnumValue, 1)) &&
                        sourceDocumentLine.TypeEnumValue == conPeek(conEnumValue, 2))
                    {
                        canSupportCommitmentsCache = UnknownNoYes::Yes;
                        break;
                    }
                }

                if (canSupportCommitmentsCache == UnknownNoYes::Yes)
                {
                    canSupportCommitmentsCache = ProjectCommitmentFacade::checkSourceDocumentLineImplementation(_sourceDocumentLineItem) +1;
                }

                SysTransactionScopeCache::set(funcName(), _sourceDocumentLineItem, canSupportCommitmentsCache);
            }

            canSupportCommitments = (canSupportCommitmentsCache == UnknownNoYes::Yes);
        }

        return canSupportCommitments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCommitmentsEnabled</Name>
				<Source><![CDATA[
    private static boolean parmIsCommitmentsEnabled(SourceDocumentLine _sourceDocumentLine, SelectableDataArea _dataArea)
    {
        boolean isCommitmentsEnabled;

        if (enumName2Id(_sourceDocumentLine.TypeEnumName) == enumNum(SourceDocumentLine_ProductRequisition) &&
            _sourceDocumentLine.TypeEnumValue == SourceDocumentLine_ProductRequisition::PurchaseRequisitionLine)
        {
            changecompany (_dataArea)
            {
                isCommitmentsEnabled = (ProjParameters::find().TrackCommittedCostPurchaseRequisition == NoYes::Yes ? true : false);
            }
        }
        else if (enumName2Id(_sourceDocumentLine.TypeEnumName) == enumNum(SourceDocumentLine_ProductOrder) &&
            _sourceDocumentLine.TypeEnumValue == SourceDocumentLine_ProductOrder::PurchaseOrderLine)
        {
            changecompany (_dataArea)
            {
                isCommitmentsEnabled = (ProjParameters::find().TrackCommittedCostPurchaseOrder == NoYes::Yes ? true : false);
            }
        }
        else if (enumName2Id(_sourceDocumentLine.TypeEnumName) == enumNum(SourceDocumentLine_VendorInvoice) &&
            _sourceDocumentLine.TypeEnumValue == SourceDocumentLine_VendorInvoice::VendorInvoiceLine)
        {
            changecompany (_dataArea)
            {
                isCommitmentsEnabled = (ProjParameters::find().TrackCommittedCostVendInvoice == NoYes::Yes ? true : false);
            }
        }
        else if (enumName2Id(_sourceDocumentLine.TypeEnumName) == enumNum(SourceDocumentLine_TravelRequisition) &&
            _sourceDocumentLine.TypeEnumValue == SourceDocumentLine_TravelRequisition::TravelRequisitionLine)
        {
            changecompany (_dataArea)
            {
                isCommitmentsEnabled = (ProjParameters::find().TrackCommittedCostTravelRequisition == NoYes::Yes ? true : false);
            }
        }
        else if (enumName2Id(_sourceDocumentLine.TypeEnumName) == enumNum(SourceDocumentLine_ExpenseReport) &&
            _sourceDocumentLine.TypeEnumValue == SourceDocumentLine_ExpenseReport::ExpenseReportLine)
        {
            changecompany (_dataArea)
            {
                isCommitmentsEnabled = (ProjParameters::find().TrackCommittedCostExpenseManagement == NoYes::Yes ? true : false);
            }
        }
        else if (enumName2Id(_sourceDocumentLine.TypeEnumName) == enumNum(SourceDocumentLine_ProjectTimesheets) &&
            _sourceDocumentLine.TypeEnumValue == SourceDocumentLine_ProjectTimesheets::TimesheetTrans)
        {
            changecompany (_dataArea)
            {
                isCommitmentsEnabled = (ProjParameters::find().TrackCommittedCostTimesheets == NoYes::Yes ? true : false);
            }
        }
        else if (enumName2Id(_sourceDocumentLine.TypeEnumName) == enumNum(SourceDocumentLine_ProjAdvancedJournal) &&
            _sourceDocumentLine.TypeEnumValue == SourceDocumentLine_ProjAdvancedJournal::ProjAdvancedJournalLine)
        {
            changecompany (_dataArea)
            {
                isCommitmentsEnabled = (ProjParameters::find().TrackCommittedCostAdvancedJournal == NoYes::Yes ? true : false);
            }
        }
        else if (enumName2Id(_sourceDocumentLine.TypeEnumName) == enumNum(BudgetReservation_SourceDocumentLine_PSN) &&
            _sourceDocumentLine.TypeEnumValue == enum2int(BudgetReservation_SourceDocumentLine_PSN::BudgetReservationLine))
        {
            changecompany (_dataArea)
            {
                isCommitmentsEnabled = ProjParameters::find().TrackCommittedCostBudgetReservation_PSN == NoYes::Yes;
            }
        }

        return isCommitmentsEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performDeleteProjectCommitments</Name>
				<Source><![CDATA[
    private static void performDeleteProjectCommitments(
        RefRecId            _sourceDocumentLine,
        Voucher             _voucher = '',
        boolean             _carryForward = false,
        TransDate           _openingDate = dateNull(),
        boolean             _skipRelievingSourceDocumentLine = false
    )
    {
        CostControlTransCommittedCost               costControlTransCommittedCost;
        ProjBudgetStatus                            projBudgetStatus;
        ProjBudgetStatus                            deleteProjBudgetStatus;
        ProjectAccountingDistributionRepository     projectAccountingDistributionRepository;
        Set                                         relievingSourceDocumentLines;
        SetEnumerator                               setEnumerator;
        SourceDocumentLineItem                      relievedSourceDocumentLineItem;
        SourceDocumentLineItem                      sourceDocumentLineItem;

        List                                        listCarrryForward;
        ProjBudgetReductionHistory                  projBudgetReductionHistory;

        boolean hasProject()
        {
            boolean                         hasProject;
            AccountingDistribution          accountingDistribution;
            ProjectAccountingDistribution   projectAccountingDistribution;

            select firstonly RecId from accountingDistribution
                where accountingDistribution.SourceDocumentLine == _sourceDocumentLine
                    join RecId from projectAccountingDistribution
                        where projectAccountingDistribution.AccountingDistribution == accountingDistribution.RecId;

            if (accountingDistribution.RecId)
            {
                hasProject = true;
            }

            return hasProject;
        }

        ProjOpsBudgetingInstrumentationActivites activity = ProjOpsBudgetingInstrumentationActivites::construct(logger);
        using (SysInstrumentationActivityContext activityContext = activity.instrumentSourceDocumentLine(ProjOpsBudgetingInstrumentationActivites::PerformDeleteProjCommitments, _sourceDocumentLine))
        {
            activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::CarryForwardProperty, any2Str(_carryForward));
            activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::OpeningDateProperty, any2Str(_openingDate));
            activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::VoucherProperty, any2Str(_voucher));
            
            if (_sourceDocumentLine)
            {
                boolean _hasProject = hasProject();
                activityContext.addCustomProperty(ProjOpsBudgetingInstrumentationActivites::HasProjectProperty, any2Str(_hasProject));
                if (_hasProject)
                {
                    if (_carryForward)
                    {
                        listCarrryForward = new List(Types::Container);
                    }
                    while select ProjTransId, ProjId, CategoryId, ActivityNumber, LedgerDimension, CurrencyCode, SourceDocumentLine
                    from costControlTransCommittedCost
                    where costControlTransCommittedCost.SourceDocumentLine == _sourceDocumentLine &&
                        costControlTransCommittedCost.Open == NoYes::Yes
                    {
                        activity.instrumentCostControlTransCommittedCostForContext(activityContext, costControlTransCommittedCost);
                        if (_carryForward)
                        {
                            projBudgetReductionHistory = ProjBudgetReductionHistory::findByProjTransId(costControlTransCommittedCost.ProjTransId);
                            if (projBudgetReductionHistory)
                            {
                                if (projBudgetReductionHistory.ProjBudgetAllocationLineIdCost)
                                {
                                    listCarrryForward.addEnd([projBudgetReductionHistory.ProjBudgetAllocationLineIdCost, projBudgetReductionHistory.CostAmountReduced]);
                                }
                                if (projBudgetReductionHistory.ProjBudgetAllocationLineIdSales)
                                {
                                    listCarrryForward.addEnd([projBudgetReductionHistory.ProjBudgetAllocationLineIdSales, projBudgetReductionHistory.SalesAmountReduced]);
                                }
                            }
                        }

                        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(costControlTransCommittedCost.SourceDocumentLine));
                        //Relieve project commitment
                        CostControlPostingSourceDocumentLine::construct(
                        sourceDocumentLineItem,
                        costControlTransCommittedCost.ProjTransId,
                        costControlTransCommittedCost.ProjId,
                        costControlTransCommittedCost.CategoryId,
                        costControlTransCommittedCost.ActivityNumber,
                        costControlTransCommittedCost.LedgerDimension,
                        0,
                        costControlTransCommittedCost.CurrencyCode,
                        0,
                        0,
                        0,
                        _voucher,
                        (_voucher ? sourceDocumentLineItem.parmAccountingDate() : dateNull())).run(ProjCommittedCostUpdateAction::Delete);
                    }

                    if (_carryForward)
                    {
                        ProjectCommitmentFacade::carryForwardBudget(listCarrryForward, _openingDate);
                    }

                    while select RecId from projBudgetStatus
                    where projBudgetStatus.SourceDocumentLine == _sourceDocumentLine
                    {
                        deleteProjBudgetStatus = null;
                        delete_from deleteProjBudgetStatus where deleteProjBudgetStatus.RecId == projBudgetStatus.RecId;
                    }

                    if (!_voucher && !_skipRelievingSourceDocumentLine)
                    {
                        projectAccountingDistributionRepository = ProjectAccountingDistributionRepository::newFromSourceDocument(null);
                        relievingSourceDocumentLines = projectAccountingDistributionRepository.relievedSourceDocumentLines(_sourceDocumentLine);
                        if (relievingSourceDocumentLines)
                        {
                            setEnumerator = relievingSourceDocumentLines.getEnumerator();
                            while (setEnumerator.moveNext())
                            {
                                relievedSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(setEnumerator.current()));
                            
                                if (trvExpTrans::existsSourceDocumentLine(_sourceDocumentLine))
                                {
                                    ProjectCommitmentFacade::doUpdateProjectCommitments(relievedSourceDocumentLineItem, false, false, false, null, 0);
                                }
                                else
                                {
                                    ProjectCommitmentFacade::doUpdateProjectCommitments(relievedSourceDocumentLineItem, false, false, false, null, _sourceDocumentLine);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performProjectBudgetCheck</Name>
				<Source><![CDATA[
    private static boolean performProjectBudgetCheck(SourceDocumentLineItem _sourceDocumentLineItem, Map _projectCommitmentsMap, boolean _supressMessages, boolean _trackBudgetStatus)
    {
        #declareContainerVariablesMacro

        MapEnumerator                   mapEnumerator;
        SourceDocumentLineItemIProject  sourceDocumentLineItemIProject;
        Map                             projBudgetTransactionMap;
        ProjBudgetTransaction           projBudgetTransaction;
        ProjBudgetTransactionLine       projBudgetTransactionLine;
        ProjBudgetTransactionManager    projBudgetTransactionManager;
        SelectableDataArea              projBudgetTransactionDataAreaId;
        boolean                         ret = true;

        if (_projectCommitmentsMap && _projectCommitmentsMap.elements())
        {
            projBudgetTransactionMap = new Map(Types::String, Types::Class);

            mapEnumerator = _projectCommitmentsMap.getEnumerator();
            while (mapEnumerator.moveNext())
            {
                #containerMacro = mapEnumerator.currentValue();

                if (projBudgetTransactionMap.exists(projectDataAreaId))
                {
                    projBudgetTransaction = projBudgetTransactionMap.lookup(projectDataAreaId);
                    projBudgetTransactionMap.remove(projectDataAreaId);
                }
                else
                {
                    projBudgetTransaction = new ProjBudgetTransaction();
                }

                sourceDocumentLineItemIProject = _sourceDocumentLineItem as SourceDocumentLineItemIProject;

                ProjTransIdBase projTransId;
                CostControlTransCommittedCost costControlTransCommittedCost;

                select firstonly ProjTransId from costControlTransCommittedCost
                    where costControlTransCommittedCost.SourceDocumentLine == _sourceDocumentLineItem.parmSourceDocumentLine().RecId &&
                          costControlTransCommittedCost.Open == NoYes::Yes;

                if (costControlTransCommittedCost.ProjTransId)
                {
                    projTransId = costControlTransCommittedCost.ProjTransId;
                }
                else
                {
                    projTransId = sourceDocumentLineItemIProject.parmProjectTransactionId();
                }

                CostAmount purchReqCommittedCostAmount = 0;
                if (_sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem
                    && FeatureStateProvider::isFeatureEnabled(ProjCommittedCostPRToPOFeature::instance()))
                {
                    RefRecId sourceDocumentLineRecId = _sourceDocumentLineItem.parmSourceDocumentLine().RecId;
                    PurchLine purchLine = purchLine::findBySourceDocumentLine(sourceDocumentLineRecId);
                    if (purchLine.PurchReqLineRefId && !(purchLine.purchTable().DocumentState == VersioningDocumentState::Confirmed))
                    {
                        purchReqCommittedCostAmount = ProjectCommitmentFacade::getPurchaseRequisitionLineCommittedCost(purchLine.PurchReqLineRefId, transactionCostCurrency);
                    }
                }

                projBudgetTransactionLine = ProjBudgetTransactionLine_Virtual::construct(
                                                ProjectSourceDocumentLineItemHelper::projTransType(_sourceDocumentLineItem),
                                                _sourceDocumentLineItem.parmAccountingDate(),
                                                projTransId,
                                                projectId,
                                                categoryId,
                                                quantity,
                                                transactionCostCurrency,
                                                transactionCurrencyCostAmount - purchReqCommittedCostAmount,
                                                transactionSalesCurrency,
                                                accountingCurrencySalesAmount,
                                                _sourceDocumentLineItem.parmSourceDocumentLine().RecId,
                                                activityNumber,
                                                sourceDocumentLineItemIProject.parmProjectLineProperty());

                projBudgetTransaction.addBudgetTransactionLine(projBudgetTransactionLine);

                projBudgetTransactionMap.insert(projectDataAreaId, projBudgetTransaction);
            }

            mapEnumerator = projBudgetTransactionMap.getEnumerator();
            while (mapEnumerator.moveNext())
            {
                projBudgetTransactionDataAreaId = mapEnumerator.currentKey();
                projBudgetTransaction = mapEnumerator.currentValue();
                projBudgetTransactionManager = ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction);
                changecompany (projBudgetTransactionDataAreaId)
                {
                    projBudgetTransactionManager.parmSupressMessages(_supressMessages);
                    projBudgetTransactionManager.parmTrackBudgetStatus(_trackBudgetStatus);
                    ret = projBudgetTransactionManager.validateBudget();
                }

                if (!ret)
                {
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performUpdateProjectCommitments</Name>
				<Source><![CDATA[
    private static void performUpdateProjectCommitments(SourceDocumentLineItem _sourceDocumentLineItem, boolean _skipCommittedCostParameter, boolean _supressMessages, boolean _trackBudgetStatus)
    {
        ProjectAccountingDistributionRepository     projectAccountingDistributionRepository;
        Set                                         relievingSourceDocumentLines;
        SetEnumerator                               setEnumerator;
        SourceDocumentLineItem                      relievedSourceDocumentLineItem;

        if (_sourceDocumentLineItem)
        {
            SourceDocumentLineRecId sourceDocumentLineRecId = _sourceDocumentLineItem.parmSourceDocumentLine().RecId;
            boolean isProjectSalesItemReqPO = ProjectCommitmentFacade::isProjectSalesItemReqPO(_sourceDocumentLineItem);

            if (!isProjectSalesItemReqPO &&
                ProjectCommitmentFacade::parmCanSupportCommitments(_sourceDocumentLineItem))
            {
                projectAccountingDistributionRepository = ProjectAccountingDistributionRepository::newFromSourceDocument(_sourceDocumentLineItem.parmSourceDocument());
                relievingSourceDocumentLines = projectAccountingDistributionRepository.relievedSourceDocumentLines(sourceDocumentLineRecId);

                // Deletes vendor invoice related commitments first to avoid inconsistency in remaining budget.
                if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                {
                    ProjectCommitmentFacade::performDeleteProjectCommitments(sourceDocumentLineRecId, '', false, dateNull(), true);
                }

                if (relievingSourceDocumentLines)
                {
                    setEnumerator = relievingSourceDocumentLines.getEnumerator();
                    while (setEnumerator.moveNext())
                    {
                        relievedSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(setEnumerator.current()));
                        ProjectCommitmentFacade::doUpdateProjectCommitments(relievedSourceDocumentLineItem, _skipCommittedCostParameter, _supressMessages, _trackBudgetStatus, _sourceDocumentLineItem, 0, true);
                    }
                }

                ProjectCommitmentFacade::doUpdateProjectCommitments(_sourceDocumentLineItem, _skipCommittedCostParameter, _supressMessages, _trackBudgetStatus);
            }
            else if (isProjectSalesItemReqPO &&
                        ProjectSourceDocumentLineItemHelper::hasProject(_sourceDocumentLineItem) &&
                        ProjectCommitmentFacade::isProjectBudgetControlEnabled(_sourceDocumentLineItem, true))
            {
                if (_sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                {
                    ProjectCommitmentFacade::updateSalesLineCommittedCost(_sourceDocumentLineItem);
                }
                else if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                {
                    PurchLine purchLine = VendInvoiceInfoLine::findSourceDocumentLine(sourceDocumentLineRecId).purchLine();
                    SalesLine salesLine = purchLine.salesLine();

                    if (salesLine && salesLine.ProjTransId && salesLine.SalesStatus != SalesStatus::Invoiced)
                    {
                        // Do not delete commitment when item consumption is partially completed for linked sales order.
                        CustPackingSlipTrans custPackingSlipTrans;
                        select firstonly Remain, RecId from custPackingSlipTrans order by RecId desc
                            where custPackingSlipTrans.InventTransId == salesLine.InventTransId;
                        
                        if (custPackingSlipTrans.RecId && custPackingSlipTrans.Remain != salesLine.RemainSalesPhysical && CostControlTransCommittedCost::findOpenedByProjTransID(salesLine.ProjTransId).RecId)
                        {
                            InventMovement inventMov_Sales = InventMovement::construct(salesLine);
                            if (inventMov_Sales.mustBeCostControlled())
                            {
                                CostControlPostingItem costControlPostingItem= CostControlPosting::newCostControlPostingItem(inventMov_Sales);
                                costControlPostingItem.run(ProjCommittedCostUpdateAction::Delete);
                            }

                            ProjectCommitmentFacade::doUpdateProjectCommitments(_sourceDocumentLineItem, _skipCommittedCostParameter, _supressMessages, _trackBudgetStatus);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>suppressMessages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to suppress the over budget messages for a source document line item.
    /// </summary>
    /// <param name="_sourceDocumentLineItem">
    /// The source document line item.
    /// </param>
    /// <returns>
    /// True when over budget messages will be suppressed; otherwise, false.
    /// </returns>
    public static boolean suppressMessages(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        boolean suppressMessages = false;

        if ((_sourceDocumentLineItem is TrvExpTransSourceDocLineItem) ||
            (_sourceDocumentLineItem is TrvRequisitionLineSourceDocLineItem))
        {
            suppressMessages = true;
        }

        return suppressMessages;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCarryForwardBudget</Name>
				<Source><![CDATA[
    //jdeguzma: 4
    private static RecId updateCarryForwardBudget(
        RefRecId            _projBudgetLine,
        TransDate           _openingDate,
        AmountCur           _allocationAmount
    )
    {
        ProjBudgetLine                  projBudgetLine;
        FiscalCalendarRecId             fiscalCalendarRecId;
        FiscalCalendarYear              fiscalCalendarYear;
        FiscalCalendarPeriodRecId       fiscalPeriodRecId;
        ProjBudgetAllocationLine        projBudgetAllocationLine;
        RecId                           carryForwardTo;

        void updateBudgetAllocation(AmountCur allocationAmount)
        {
            projBudgetAllocationLine.ProjBudgetLine = projBudgetLine.RecId;
            projBudgetAllocationLine.TotalAllocationAmount += allocationAmount;
            if (!projBudgetAllocationLine)
            {
                projBudgetAllocationLine.insert();
                carryForwardTo = projBudgetAllocationLine.RecId;
            }
            else
            {
                projBudgetAllocationLine.update();
                carryForwardTo = projBudgetAllocationLine.RecId;
            }
        }

        projBudgetLine = ProjBudgetLine::find(_projBudgetLine);
        if (projBudgetLine)
        {
            fiscalCalendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(fiscalCalendarRecId, _openingDate);
            if (!fiscalCalendarYear)
            {
                throw error("@SYS6144");
            }

            fiscalPeriodRecId = LedgerFiscalCalendar::findFirstOpenPeriodInYear(
                                        fiscalCalendarRecId,
                                        fiscalCalendarYear.StartDate).RecId;
            if (!fiscalPeriodRecId)
            {
                throw error("@SYS6144");
            }

            switch (projBudgetLine.ProjAllocationMethod)
            {
                case ProjAllocationMethod::Periods :
                        if (fiscalPeriodRecId)
                    {
                        select forupdate firstonly projBudgetAllocationLine
                                    where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId &&
                                            projBudgetAllocationLine.FiscalCalendarPeriod == fiscalPeriodRecId;

                        projBudgetAllocationLine.FiscalCalendarPeriod = fiscalPeriodRecId;
                        updateBudgetAllocation(_allocationAmount);
                    }
                    break;

                case ProjAllocationMethod::Quarter :
                        if (fiscalCalendarYear.RecId)
                    {
                        select forupdate firstonly projBudgetAllocationLine
                                    where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId &&
                                            projBudgetAllocationLine.Quarter == FiscalQuarter::Q1 &&
                                            projBudgetAllocationLine.FiscalCalendarYear == fiscalCalendarYear.RecId;

                        projBudgetAllocationLine.Quarter = FiscalQuarter::Q1;
                        projBudgetAllocationLine.FiscalCalendarYear = fiscalCalendarYear.RecId;
                        updateBudgetAllocation(_allocationAmount);
                    }
                    break;

                case ProjAllocationMethod::Yearly :
                        if (fiscalCalendarYear.RecId)
                    {
                        select forupdate firstonly projBudgetAllocationLine
                                    where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId &&
                                            projBudgetAllocationLine.FiscalCalendarYear == fiscalCalendarYear.RecId;

                        projBudgetAllocationLine.FiscalCalendarYear = fiscalCalendarYear.RecId;
                        updateBudgetAllocation(_allocationAmount);
                    }
                    break;
            }

            ProjYearEndProcess::createForecastRecord(
                        projBudgetLine,
                        FiscalCalendarPeriod::find(fiscalPeriodRecId).StartDate,
                        _allocationAmount);
        }

        return carryForwardTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectCommitments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Brings up to date the project commitments, depending on information from accounting distributions
    /// for the given source document line.
    /// </summary>
    /// <param name="_sourceDocumentLineItem">
    /// A <c>SourceDocumentLineItem</c> object.
    /// </param>
    /// <param name="_skipCommittedCostParameter">
    /// A Boolean value that indicates whether to skip the committed cost parameter set in the
    /// <c>ProjParameters</c> table.
    /// </param>
    /// <param name="_suppressMessages">
    /// A Boolean value that indicates whether to suppress the over budget messages; optional.
    /// </param>
    /// <param name="_trackBudgetStatus">
    /// A Boolean value that indicates whether to track the budget status of the transactions; optional.
    /// </param>
    /// <remarks>
    /// If a project commitment does not exist, a new project commitment will be created based on
    /// information from the accounting distributions.If a project commitment already exists, a reversing
    /// project commitment entry will be created based on the existing project commitment. A new project
    /// commitment will then be created based on the new information from the accounting distributions.If
    /// project budgeting is enabled, creating a reversing project commitment will also liquidate project
    /// budgets and creating a new project commitment will also reserve project budgets.This method will
    /// also handle reservation and liquidation of project budgets for the project commitments if project
    /// budgeting is enabled.
    /// </remarks>
    public static void updateProjectCommitments(SourceDocumentLineItem _sourceDocumentLineItem, boolean _skipCommittedCostParameter = false, boolean _suppressMessages = false, boolean _trackBudgetStatus = false)
    {
        if (_sourceDocumentLineItem)
        {
            ttsbegin;
            SourceDocumentLineItemIProject sourceDocumentLineItemIProject = _sourceDocumentLineItem as SourceDocumentLineItemIProject;

            if (sourceDocumentLineItemIProject != null &&
                _sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem &&
                ProjTable::find(sourceDocumentLineItemIProject.parmProjectId()).UseBudgeting)
            {
                _trackBudgetStatus = true;
            }

            ProjectCommitmentFacade::performUpdateProjectCommitments(_sourceDocumentLineItem, _skipCommittedCostParameter, _suppressMessages, _trackBudgetStatus);
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectCommitmentsMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Summarizes accounting distribution values that will be used to create project commitments
    /// </summary>
    /// <param name="_projectCommitmentsMap">
    /// Map that will be updated with the project commitment values
    /// </param>
    /// <param name="_sourceDocumentLineItem">
    /// An instance of the <c>SourceDocumentLineItem</c> class.
    /// </param>
    /// <param name="_relievingSourceDocumentLineItem">
    /// An instance of the <c>SourceDocumentLineItem</c> class.
    /// </param>
    /// <param name="_deletedSourceDocumentLine">
    /// The source document line that is being deleted which will be excluded in processing commitments
    /// </param>
    /// <param name="_excludeMarkedUpDistributions">
    /// true if marked up distributions should be excluded; otherwise, false.
    /// </param>
    public static void updateProjectCommitmentsMap(Map _projectCommitmentsMap, SourceDocumentLineItem _sourceDocumentLineItem, SourceDocumentLineItem _relievingSourceDocumentLineItem = null, RefRecId _deletedSourceDocumentLine = 0, boolean _excludeMarkedUpDistributions = false)
    {
        #declareContainerVariablesMacro
        #define.PositiveFactor(1.0)
        #define.NegativeFactor(-1.0)

        ProjectAccountingDistributionRepository     projectAccountingDistributionRepository;
        Map                                         distributionsForCommitment;
        Map                                         projectCommitmentsRecordCountMap;
        Map                                         projectCommitmentsProcessCountMap;
        MapEnumerator                               distributionsForCommitmentEnumerator;
        List                                        relievingDistributionsList;
        ListEnumerator                              relievingDistributionsListEnumerator;
        AccountingDistribution                      accountingDistribution;
        ProjectAccountingDistribution               projectAccountingDistribution;
        AccountingDistribution                      relievingAccountingDistribution;
        ProjectAccountingDistribution               relievingProjectAccountingDistribution;
        SourceDocumentLineItem                      relievingSourceDocumentLineItem;
        str                                         key;
        boolean                                     isAmountBased;
        boolean                                     relieveByQuantity;
        Qty                                         totalRelievingQuantity;
        AmountCur                                   totalRelievingTransactionCurrencyCostAmount;
        AmountMST                                   totalRelievingAccountingCurrencyCostAmount;
        AmountMST                                   totalRelievingAccountingCurrencySalesAmount;
        AmountCur                                   relievingTransactionCurrencyCostAmount;
        AmountMST                                   relievingAccountingCurrencyCostAmount;
        AmountMST                                   relievingAccountingCurrencySalesAmount;
        Qty                                         accountingDistributionQuantity;
        Qty                                         relievingAccountingDistributionQuantity;
        boolean                                     fullyRelieved;
        SourceDocumentLineItemITimesheets           sourceDocumentLineItemITimesheets;
        SourceDocumentLine                          sourceDocumentLine;
        boolean                                     willRelieveTravelRequisition;
        boolean                                     isNotCompleted;
        boolean                                     isExpenseReportLine;
        boolean                                     isCommitmentCostCreated;
        boolean                                     isTimesheetLine;

        Amount calculateAmount(Amount _amount, CurrencyCode _currencyCode)
        {
            AmountCur ret;

            if (accountingDistributionQuantity)
            {
                ret = CurrencyExchangeHelper::amount(_amount * relievingAccountingDistributionQuantity / accountingDistributionQuantity, _currencyCode);
            }

            return ret;
        }

        boolean relievesTravelRequisition(AccountingDistribution _accountingDistribution)
        {
            boolean ret;
            TrvRequisitionLine      trvRequisitionLine;
            AccountingDistribution  trvAccountingDistribution;

            if (_accountingDistribution.ReferenceDistribution)
            {
                select firstOnly trvRequisitionLine
                    join trvAccountingDistribution
                    where trvRequisitionLine.SourceDocumentLine == trvAccountingDistribution.SourceDocumentLine &&
                        trvAccountingDistribution.RecId == _accountingDistribution.ReferenceDistribution;
                if (trvRequisitionLine)
                {
                    ret = true;
                }
            }

            return ret;
        }

        if (_sourceDocumentLineItem &&
            ProjectSourceDocumentLineItemHelper::hasProject(_sourceDocumentLineItem) &&
            _projectCommitmentsMap)
        {
            projectCommitmentsRecordCountMap = new Map(Types::String, Types::Integer);
            projectCommitmentsProcessCountMap = new Map(Types::String, Types::Integer);
            sourceDocumentLine = _sourceDocumentLineItem.parmSourceDocumentLine();
            isTimesheetLine = sourceDocumentLine.SourceRelationType == tableNum(TSTimesheetTrans);
            boolean streamLinePricesFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance());
            boolean vendorInvoiceRetentionCalcFeature = ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled();

            if (isTimesheetLine)
            {
                isCommitmentCostCreated = TSTimesheetTrans::isCommitmentCostCreated(sourceDocumentLine.RecId);
            }

            isNotCompleted = sourceDocumentLine.AccountingStatus < SourceDocumentLineAccountingStatus::Completed;
            isExpenseReportLine = sourceDocumentLine.SourceRelationType == tableNum(TrvExpTrans);
            projectAccountingDistributionRepository = ProjectAccountingDistributionRepository::newFromSourceDocument(_sourceDocumentLineItem.parmSourceDocument());
            distributionsForCommitment = projectAccountingDistributionRepository.distributionsForCommitment(sourceDocumentLine.RecId, _relievingSourceDocumentLineItem, _deletedSourceDocumentLine);
            if (distributionsForCommitment)
            {
                isAmountBased = ProjectSourceDocumentLineItemHelper::isAmountBased(_sourceDocumentLineItem);
                boolean isDeliveryRemainderUpdated = false;
                boolean isDeliveryRemainderQtyDeducted = false;
                boolean isDeliveryRemainderCostPriceDeducted = false;
                boolean isPurchLine = sourceDocumentLine.RecId && sourceDocumentLine.SourceRelationType == tableNum(PurchLine);
                
                distributionsForCommitmentEnumerator = distributionsForCommitment.getEnumerator();
                while (distributionsForCommitmentEnumerator.moveNext())
                {
                    accountingDistribution = distributionsForCommitmentEnumerator.currentKey();

                    if (streamLinePricesFeature)
                    {
                        if (!(ProjectCommitmentFacade::isValidCommitment(
                                accountingDistribution, _sourceDocumentLineItem, vendorInvoiceRetentionCalcFeature)
                                && (accountingDistribution.MonetaryAmount != MonetaryAmount::TaxNonRecoverable 
                                    || ProjectCommitmentFacade::includeNonRecoverableTax(accountingDistribution, _sourceDocumentLineItem)))
                            || ProjectCommitmentFacade::isAccountingDistributionQuantityZero(accountingDistribution, _sourceDocumentLineItem))
                        {
                            continue;
                        }
                    }
                    else
                    {
                        if ((!ProjectCommitmentFacade::isValidCommitment(
                            accountingDistribution, _sourceDocumentLineItem, vendorInvoiceRetentionCalcFeature)
                                && !ProjectCommitmentFacade::includeNonRecoverableTax(accountingDistribution, _sourceDocumentLineItem))
                            || ProjectCommitmentFacade::isAccountingDistributionQuantityZero(accountingDistribution, _sourceDocumentLineItem))
                        {
                            continue;
                        }
                    }

                    relievingDistributionsList = distributionsForCommitmentEnumerator.currentValue();
                    projectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(accountingDistribution.RecId);
                    if (_excludeMarkedUpDistributions && isExpenseReportLine && isNotCompleted)
                    {
                        willRelieveTravelRequisition = relievesTravelRequisition(accountingDistribution);
                    }
                    else
                    {
                        willRelieveTravelRequisition = false;
                    }

                    if (projectAccountingDistribution)
                    {
                        accountingDistributionQuantity = ProjectAccountingDistribution::quantity(accountingDistribution, _sourceDocumentLineItem);
                            
                        key = ProjectCommitmentFacade::keyFromAccountingDistribution(sourceDocumentLine, accountingDistribution, projectAccountingDistribution);

                        int distributionsCount = ProjectCommitmentFacade::getAccountingDistributionCount(sourceDocumentLine, accountingDistribution, projectAccountingDistribution);

                        // Get the record count for this key and store it in the record count map.
                        if (!projectCommitmentsRecordCountMap.exists(key))
                        {
                            projectCommitmentsRecordCountMap.insert(key, distributionsCount);
                        }

                        // Get the process count for the key and increment the process count map.
                        int processCount;
                        if (projectCommitmentsProcessCountMap.exists(key))
                        {
                            processCount = projectCommitmentsProcessCountMap.lookup(key);
                        }
                        projectCommitmentsProcessCountMap.insert(key, processCount + 1);

                        if (_projectCommitmentsMap.exists(key))
                        {
                            #containerMacro = _projectCommitmentsMap.lookup(key);
                            _projectCommitmentsMap.remove(key);
                        }
                        else
                        {
                            #clearContainerMacro
                        }

                        sourceDocumentLineId = sourceDocumentLine.RecId;

                        if (_sourceDocumentLineItem is SourceDocumentLineItemITimesheets)
                        {
                            sourceDocumentLineItemITimesheets = _sourceDocumentLineItem as SourceDocumentLineItemITimesheets;
                            projectDataAreaId = CompanyInfo::findRecId(sourceDocumentLineItemITimesheets.parmProjectLegalEntity()).DataArea;
                        }
                        else if (_sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
                        {
                            ProjAdvancedJournalSourceDocumentLineItem projAdvancedJournalSourceDocumentLineItem = _sourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
                            projectDataAreaId = projAdvancedJournalSourceDocumentLineItem.parmProjectDataAreaId();
                        }
                        else
                        {
                            projectDataAreaId = CompanyInfo::findRecId(accountingDistribution.AccountingLegalEntity).DataArea;
                        }

                        ledgerDimension = accountingDistribution.LedgerDimension;
                        transactionCostCurrency = ProjectAccountingDistribution::transactionCostCurrency(accountingDistribution, projectAccountingDistribution, _sourceDocumentLineItem);

                        boolean isCommitmentForNotAdjusting = (accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                                                               && accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Adjusting);

                        // If multiple distribution records for commitment are exists then reset quantity to zero to avoid unnecessary quantity calculation.
                        if (isPurchLine
                            && isCommitmentForNotAdjusting)
                        {
                            quantity = 0;
                        }

                        changecompany (projectDataAreaId)
                        {
                            projectId = ProjectCommitmentFacade::projIDForProjectCommitment(projectAccountingDistribution);
                            categoryId = ProjCategory::findRecId(projectAccountingDistribution.ProjCategory).CategoryId;
                            activityNumber = ProjectCommitmentFacade::activityNumberForProjectCommitment(projectAccountingDistribution);
                            transactionSalesCurrency = Ledger::accountingCurrency(CompanyInfo::current());
                        }

                        if (accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId &&
                            accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice)
                        {
                            if (isAmountBased)
                            {
                                quantity += ((accountingDistributionQuantity < 0) ?
                                    -accountingDistribution.AllocationFactor :
                                    accountingDistribution.AllocationFactor);
                            }
                            else if (accountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Adjusting)
                            {
                                quantity += (accountingDistributionQuantity * #NegativeFactor);
                            }
                            else
                            {
                                quantity += (accountingDistributionQuantity * #PositiveFactor);
                            }
                        }

                        if (!willRelieveTravelRequisition && !isCommitmentCostCreated)
                        {
                            transactionCurrencyCostAmount += (ProjectAccountingDistribution::transactionCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, _sourceDocumentLineItem) * #PositiveFactor);
                        }
                        changecompany (projectDataAreaId)
                        {
                            if (!willRelieveTravelRequisition && !isCommitmentCostCreated)
                            {
                                accountingCurrencyCostAmount += (ProjectAccountingDistribution::accountingCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, _sourceDocumentLineItem) * #PositiveFactor);
                            }
                            accountingCurrencySalesAmount += (ProjectAccountingDistribution::accountingCurrencySalesAmount(accountingDistribution, projectAccountingDistribution, _sourceDocumentLineItem) * #PositiveFactor);
                        }

                        if (relievingDistributionsList && !willRelieveTravelRequisition)
                        {
                            totalRelievingQuantity = 0;
                            totalRelievingTransactionCurrencyCostAmount = 0;
                            totalRelievingAccountingCurrencyCostAmount = 0;
                            totalRelievingAccountingCurrencySalesAmount = 0;
                            fullyRelieved = false;
                            boolean skipUpdatingRelievingQty;

                            relievingDistributionsListEnumerator = relievingDistributionsList.getEnumerator();

                            while (relievingDistributionsListEnumerator.moveNext() && !fullyRelieved)
                            {
                                relievingAccountingDistribution = relievingDistributionsListEnumerator.current();

                                // Commitment will not process non recoverable tax for purchase order and vendor invoice.
                                if (!ProjectCommitmentFacade::isValidCommitment(relievingAccountingDistribution, _relievingSourceDocumentLineItem, vendorInvoiceRetentionCalcFeature))
                                {
                                    continue;
                                }

                                relievingProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(relievingAccountingDistribution.RecId);
                                if (relievingProjectAccountingDistribution)
                                {
                                    relievingSourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(relievingAccountingDistribution.SourceDocumentLine);
                                    relieveByQuantity = (relievingAccountingDistribution.SourceDocumentLine == relievingSourceDocumentLineItem.parmSourceDocumentLine().RecId &&
                                        relievingAccountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice ? true : false) && !isAmountBased;
                                    
                                    AmountCur orgTransactionCurrencyCostAmount = ProjectAccountingDistribution::transactionCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, _sourceDocumentLineItem);
                                    AmountCur orgAccountingCurrencyCostAmount = ProjectAccountingDistribution::accountingCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, _sourceDocumentLineItem);
                                    AmountCur orgAccountingCurrencySalesAmount = ProjectAccountingDistribution::accountingCurrencySalesAmount(accountingDistribution, projectAccountingDistribution, _sourceDocumentLineItem);

                                    AmountCur orgRelivingAccountingCurrencySalesAmount = ProjectAccountingDistribution::accountingCurrencySalesAmount(relievingAccountingDistribution, relievingProjectAccountingDistribution, _sourceDocumentLineItem);
                                    AmountCur orgRelievingTransactionCurrencyCostAmount;
                                    AmountCur orgRelievingAccountingCurrencyCostAmount;
                                    VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = relievingSourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
                                    
                                    if (relievingSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                                    {
                                        // Calculate the amount if this invoice has vendor payment retention terms.
                                        orgRelievingTransactionCurrencyCostAmount = ProjectSourceDocumentLineItemHelper::getAmountWithDiscount(vendorInvoiceLineSourceDocLineItem,
                                            relievingAccountingDistribution.TransactionCurrencyAmount);

                                        orgRelievingTransactionCurrencyCostAmount = vendorInvoiceLineSourceDocLineItem.calcTransactionAmountForProjectVendorInvoiceRetention(
                                            relievingAccountingDistribution, orgRelievingTransactionCurrencyCostAmount);

                                        orgRelievingAccountingCurrencyCostAmount = orgRelievingTransactionCurrencyCostAmount;
                                    }
                                    else
                                    {
                                        orgRelievingTransactionCurrencyCostAmount = ProjectAccountingDistribution::transactionCurrencyCostAmount(relievingAccountingDistribution, relievingProjectAccountingDistribution, _sourceDocumentLineItem);
                                        orgRelievingAccountingCurrencyCostAmount = ProjectAccountingDistribution::accountingCurrencyCostAmount(relievingAccountingDistribution, relievingProjectAccountingDistribution, _sourceDocumentLineItem);
                                    }

                                    if (relieveByQuantity)
                                    {
                                        // Calculates the relieving quantity.
                                        relievingAccountingDistributionQuantity = ProjectCommitmentFacade::getRelievingQuantity(
                                            relievingAccountingDistribution, relievingProjectAccountingDistribution,
                                            _sourceDocumentLineItem, sourceDocumentLine,
                                            vendorInvoiceLineSourceDocLineItem, streamLinePricesFeature);

                                        changecompany (projectDataAreaId)
                                        {
                                            if (accountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Adjusting)
                                            {
                                                relievingTransactionCurrencyCostAmount = orgRelievingTransactionCurrencyCostAmount;
                                                relievingAccountingCurrencyCostAmount = orgRelievingAccountingCurrencyCostAmount;
                                                relievingAccountingCurrencySalesAmount = orgRelivingAccountingCurrencySalesAmount;
                                            }
                                            else if ((accountingDistributionQuantity < 0 && (totalRelievingQuantity + relievingAccountingDistributionQuantity) <= accountingDistributionQuantity) ||
                                                    (accountingDistributionQuantity > 0 && (totalRelievingQuantity + relievingAccountingDistributionQuantity) >= accountingDistributionQuantity))
                                            {
                                                relievingTransactionCurrencyCostAmount = orgTransactionCurrencyCostAmount - totalRelievingTransactionCurrencyCostAmount;
                                                relievingAccountingCurrencyCostAmount = orgAccountingCurrencyCostAmount - totalRelievingAccountingCurrencyCostAmount;
                                                relievingAccountingCurrencySalesAmount = orgAccountingCurrencySalesAmount - totalRelievingAccountingCurrencySalesAmount;
                                                relievingAccountingDistributionQuantity = accountingDistributionQuantity - totalRelievingQuantity;
                                                fullyRelieved = true;
                                            }
                                            else
                                            {
                                                relievingTransactionCurrencyCostAmount = calculateAmount(orgTransactionCurrencyCostAmount, transactionCostCurrency);
                                                relievingAccountingCurrencyCostAmount = calculateAmount(orgAccountingCurrencyCostAmount, Ledger::accountingCurrency(CompanyInfo::current()));
                                                relievingAccountingCurrencySalesAmount = calculateAmount(orgAccountingCurrencySalesAmount, transactionSalesCurrency);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if ((orgTransactionCurrencyCostAmount < 0 &&
                                            ((totalRelievingTransactionCurrencyCostAmount + orgRelievingTransactionCurrencyCostAmount) <= orgTransactionCurrencyCostAmount)) ||
                                            (orgTransactionCurrencyCostAmount > 0 &&
                                            ((totalRelievingTransactionCurrencyCostAmount + orgRelievingTransactionCurrencyCostAmount) >= orgTransactionCurrencyCostAmount)))
                                        {
                                            relievingTransactionCurrencyCostAmount = orgTransactionCurrencyCostAmount - totalRelievingTransactionCurrencyCostAmount;
                                            relievingAccountingCurrencyCostAmount = orgAccountingCurrencyCostAmount - totalRelievingAccountingCurrencyCostAmount;
                                            relievingAccountingCurrencySalesAmount = orgAccountingCurrencySalesAmount - totalRelievingAccountingCurrencySalesAmount;
                                            fullyRelieved = true;
                                        }
                                        else
                                        {
                                            relievingTransactionCurrencyCostAmount = orgRelievingTransactionCurrencyCostAmount;
                                            relievingAccountingCurrencyCostAmount = orgRelievingAccountingCurrencyCostAmount;
                                            relievingAccountingCurrencySalesAmount = orgRelivingAccountingCurrencySalesAmount;
                                        }
                                    }

                                    // Incase of updating delivery remainder after posting the invoice, reduce the cancelled quantity from total quantity
                                    // and calculates the cost and sales prices with cancelled delivery remainder quantity.
                                    AmountCur delRemainTransCostAmountCur;
                                    AmountCur delRemainAccCostAmountCur;
                                    AmountCur delRemainAccSalesAmountCur;
                                    if (isPurchLine && !isDeliveryRemainderQtyDeducted)
                                    {
                                        // The cancelled delivery remainder quantity which is equal to purch qty - (prodcut Receipt qty + direct invoiced qty + remain purch physical qty).
                                        PurchLine purchLine = PurchLine::findBySourceDocumentLine(sourceDocumentLineId);
                                        PurchQty deliveryRemainderQty = purchLine.PurchQty - (purchLine.receivedInTotalServer() + purchLine.RemainPurchPhysical);

                                        if (deliveryRemainderQty)
                                        {
                                            isDeliveryRemainderQtyDeducted = true;
                                            quantity += (deliveryRemainderQty * #NegativeFactor);

                                            if (accountingDistributionQuantity)
                                            {
                                                delRemainTransCostAmountCur = CurrencyExchangeHelper::amount(transactionCurrencyCostAmount * deliveryRemainderQty / accountingDistributionQuantity, transactionCostCurrency);
                                                delRemainAccCostAmountCur = CurrencyExchangeHelper::amount(accountingCurrencyCostAmount * deliveryRemainderQty / accountingDistributionQuantity, transactionCostCurrency);
                                                delRemainAccSalesAmountCur = CurrencyExchangeHelper::amount(accountingCurrencySalesAmount * deliveryRemainderQty / accountingDistributionQuantity, transactionSalesCurrency);
                                            }
                                        }
                                    }

                                    if (relieveByQuantity && !skipUpdatingRelievingQty)
                                    {
                                        quantity += (relievingAccountingDistributionQuantity * #NegativeFactor);

                                        if (ProjRelievingQuantityPrecisionFlight::instance().isEnabled())
                                        {
                                            if (isPurchLine)
                                            {
                                                PurchLine purchLine = PurchLine::findBySourceDocumentLine(sourceDocumentLineId);
                                                {
                                                    // In the case of vendor retention which cost is being retained when
                                                    // posting to project subledger, then the committed cost is needed
                                                    // to show the retained amount. In that case, we need to skip decimal rounding.
                                                    boolean skipQuantityRounding;
                                                    if (streamLinePricesFeature
                                                        && purchLine.PSARetainScheduleId != ''
                                                        && _relievingSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                                                        && !ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                                                            vendorInvoiceRetentionCalcFeature,
                                                            _relievingSourceDocumentLineItem))
                                                    {
                                                        VendInvoiceInfoLine vendInvInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(
                                                            _relievingSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                                                        if (vendInvInfoLine && (vendInvInfoLine.LineAmount == 0 || vendInvInfoLine.PSAIsFinal))
                                                        {
                                                            skipQuantityRounding = true;
                                                        }
                                                    }
                                                        
                                                    if (!skipQuantityRounding)
                                                    {
                                                        quantity = decRound(
                                                            quantity,
                                                            UnitOfMeasure::findBySymbol(purchLine.PurchUnit).DecimalPrecision);
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    // Reduce the cost and sales prices from total cost and sales prices when delivery remainder quantity is updated.
                                    if (isDeliveryRemainderQtyDeducted && !isDeliveryRemainderCostPriceDeducted)
                                    {
                                        isDeliveryRemainderCostPriceDeducted = true;
                                        transactionCurrencyCostAmount += (relievingTransactionCurrencyCostAmount * #NegativeFactor) - delRemainTransCostAmountCur;
                                        accountingCurrencyCostAmount += (relievingAccountingCurrencyCostAmount * #NegativeFactor) - delRemainAccCostAmountCur;
                                        accountingCurrencySalesAmount += (relievingAccountingCurrencySalesAmount * #NegativeFactor) - delRemainAccSalesAmountCur;
                                    }
                                    else
                                    {
                                        transactionCurrencyCostAmount += (relievingTransactionCurrencyCostAmount * #NegativeFactor);
                                        accountingCurrencyCostAmount += (relievingAccountingCurrencyCostAmount * #NegativeFactor);
                                        accountingCurrencySalesAmount += (relievingAccountingCurrencySalesAmount * #NegativeFactor);
                                    }

                                    if (relieveByQuantity)
                                    {
                                        totalRelievingQuantity += relievingAccountingDistributionQuantity;
                                    }
                                    totalRelievingTransactionCurrencyCostAmount += relievingTransactionCurrencyCostAmount;
                                    totalRelievingAccountingCurrencyCostAmount += relievingAccountingCurrencyCostAmount;
                                    totalRelievingAccountingCurrencySalesAmount += relievingAccountingCurrencySalesAmount;
                                }
                            }
                        }

                        // At the time of PO confirmation as there is no reference distribution, updating the commitments when delivery remainder is updated.
                        if (isPurchLine
                            && !isDeliveryRemainderUpdated
                            && !relievingAccountingDistribution
                            && !_relievingSourceDocumentLineItem)
                        {
                            PurchLine purchLine = PurchLine::findBySourceDocumentLine(sourceDocumentLineId);
                            if (purchLine.RemainPurchPhysical && purchLine.PurchQty != purchLine.RemainPurchPhysical && !purchLine.receivedInTotalServer())
                            {
                                isDeliveryRemainderUpdated = true;
                                quantity = purchLine.RemainPurchPhysical;
                            }

                            // When delivery remainder quantity is cancelled, update commitment quantity with <c>RemainPurchFinancial</c> which is already received.
                            if (purchLine.RemainPurchPhysical == 0 && purchLine.RemainPurchFinancial
                                && ProjUpdCommitmentForDeliveryRemainderCanceledFlight::instance().isEnabled())
                            {
                                quantity = purchLine.RemainPurchFinancial;
                            }

                            // calculates the cost and sales prices with updated delivery remainder quantity when record is not for adjusting purpose.
                            if (accountingDistributionQuantity
                                && isCommitmentForNotAdjusting)
                            {
                                transactionCurrencyCostAmount = CurrencyExchangeHelper::amount(transactionCurrencyCostAmount * quantity / accountingDistributionQuantity, transactionCostCurrency);
                                accountingCurrencyCostAmount = CurrencyExchangeHelper::amount(accountingCurrencyCostAmount * quantity / accountingDistributionQuantity, transactionCostCurrency);
                                accountingCurrencySalesAmount = CurrencyExchangeHelper::amount(accountingCurrencySalesAmount * quantity / accountingDistributionQuantity, transactionSalesCurrency);
                            }

                            if (distributionsCount > 1)
                            {
                                multiLineDistribution = true;
                            }
                        }

                        // If the number of records for this key have all been processed, then calculate the tax amount.
                        if (!streamLinePricesFeature)
                        {
                            int recordCount = projectCommitmentsRecordCountMap.lookup(key);
                            if (recordCount != 0 && recordCount == projectCommitmentsProcessCountMap.lookup(key))
                            {
                                // Add tax to cost and sales amount for vendor invoice
                                AmountCur accountingCurrencyCostTaxAmount = ProjectCommitmentFacade::calcUncommittedTaxCostPrice(
                                    accountingDistribution, _sourceDocumentLineItem, accountingCurrencyCostAmount);

                                AmountCur accountingCurrencySalesTaxAmount;
                                boolean calculateTotalSalesPriceWithoutRetention = ProjSalesPriceWithoutRetentionFeatureHelper::isFeatureEnabled();

                                if (calculateTotalSalesPriceWithoutRetention)
                                {
                                    // Calculates the sales tax amount without tax cost price when the Sales price calculated without retained cost price feature is enabled.
                                    accountingCurrencySalesTaxAmount = ProjectCommitmentFacade::calcUncommittedTaxPriceRate(accountingDistribution, _sourceDocumentLineItem) * accountingCurrencySalesAmount;
                                }
                                else
                                {
                                    accountingCurrencySalesTaxAmount = ProjectCommitmentFacade::calcUncommittedTaxSalesPrice(accountingDistribution, _sourceDocumentLineItem, accountingCurrencyCostTaxAmount);
                                }
                            
                                accountingCurrencySalesAmount = accountingCurrencySalesAmount + accountingCurrencySalesTaxAmount;
                                AmountCur transactionCurrencyCostTaxAmount = ProjectCommitmentFacade::calcUncommittedTaxCostPrice(
                                    accountingDistribution, _sourceDocumentLineItem, transactionCurrencyCostAmount);
                                transactionCurrencyCostAmount = transactionCurrencyCostAmount + transactionCurrencyCostTaxAmount;
                                accountingCurrencyCostAmount = accountingCurrencyCostAmount + accountingCurrencyCostTaxAmount;
                            }
                        }
                        _projectCommitmentsMap.insert(key, #containerMacro);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIncludeNonRecoverableTax</Name>
				<Source><![CDATA[
    private static boolean processIncludeNonRecoverableTax(AccountingDistribution _accountingDistribution, boolean _streamLinePricesFeature)
    {
        boolean processIncludeNonRecoverableTax = true;

        if (_streamLinePricesFeature)
        {
            processIncludeNonRecoverableTax = _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable; 
        }
        
        return processIncludeNonRecoverableTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeNonRecoverableTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to include non-recoverable tax in the transaction currency amount
    /// when sales tax group useTax is checked on the sales tax code.
    /// </summary>
    /// <param name="_accountingDistribution">
    /// An instance of the <c>AccountingDistribution</c> class.
    /// </param>
    /// <param name="_sourceDocumentLineItem">
    /// An instance of the <c>SourceDocumentLineItem</c> class.
    /// </param>
    /// <returns>
    /// true if non-recoverable tax should be included; otherwise, false.
    /// </returns>
    /// <remarks>
    /// When <c>ProjEnableStreamlineCostAndSalesPriceCalcFeature</c> is enabled, even if the sales tax group
    /// UseTax is checked or not, the non-recoverable tax should be included.
    ///
    /// On the other hand, if <c>ProjEnableStreamlineCostAndSalesPriceCalcFeature</c> is not enabled, then
    /// non-recoverable tax should not be included.
    /// </remarks>
    public static boolean includeNonRecoverableTax(AccountingDistribution _accountingDistribution, SourceDocumentLineItem _sourceDocumentLineItem)
    {
        boolean includeNonRecoverableTax;
        boolean streamLinePricesFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance());

        if (ProjectCommitmentFacade::processIncludeNonRecoverableTax(_accountingDistribution, streamLinePricesFeature))
        {
            TaxGroup salesTaxGroup;
            VendInvoiceInfoLine vendInvoiceInfoLine;
            if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
            {
                vendInvoiceInfoLine = VendInvoiceInfoline::findSourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                if (vendInvoiceInfoLine)
                {
                    salesTaxGroup = vendInvoiceInfoLine.TaxGroup;
                }
            }

            PurchLine purchLine;
            if (!vendInvoiceInfoLine && _sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
            {
                purchLine = PurchLine::findBySourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                if (purchLine)
                {
                    salesTaxGroup = purchLine.TaxGroup;
                }
            }

            PurchReqLine purchReqLine;
            if (_sourceDocumentLineItem is PurchReqSourceDocLineItem && ProjStreamLinePricesForPurchReqFlight::instance().isEnabled())
            {
                purchReqLine = PurchReqLine::findBySourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                if(purchReqLine)
                {
                    salesTaxGroup = purchReqLine.TaxGroup;
                }
            }

            if (salesTaxGroup)
            {
                if (streamLinePricesFeature)
                {
                    if (ProjectCommitmentFacade::checkIfNonRecoverableTaxExists(vendInvoiceInfoLine, purchLine, purchReqLine))
                    {
                        includeNonRecoverableTax = true;
                    }
                }
                else
                {
                    TaxGroupData taxGroupData;
                    select firstonly UseTax from taxGroupData
                    where taxGroupData.TaxGroup == salesTaxGroup
                        && taxGroupData.DataAreaId == curExt();

                    includeNonRecoverableTax = !taxGroupData.UseTax && _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable && !ProjParameters::find().ExcludeTaxForNonStockItem;
                }
            }
        }
         
        return includeNonRecoverableTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfNonRecoverableTaxExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if non-deductible tax can be considered.
    /// </summary>
    /// <param name="_vendInvoiceInfoLine">
    /// A record of <c>VendInvoiceInfoLine</c> table.
    /// </param>
    /// <param name="_purchLine">
    /// A record of <c>PurchLine</c> table.
    /// </param>
    /// <param name="_purchReqLine">
    /// A record of <c>PurchReqLine</c> table.
    /// </param>
    /// <returns>
    /// true if non-deductible tax exists; otherwise, false.
    /// </returns>
    internal static boolean checkIfNonRecoverableTaxExists(VendInvoiceInfoLine _vendInvoiceInfoLine, PurchLine _purchLine, PurchReqLine _purchReqLine = null)
    {
        TaxData taxData;
        TaxGroup salesTaxGroup;
        TaxItemGroup itemSalesTaxGroup;

        if (_vendInvoiceInfoLine)
        {
            salesTaxGroup = _vendInvoiceInfoLine.TaxGroup;
            itemSalesTaxGroup = _vendInvoiceInfoLine.TaxItemGroup;
        }
        else if (_purchLine)
        {
            salesTaxGroup = _purchLine.TaxGroup;
            itemSalesTaxGroup = _purchLine.TaxItemGroup;
        }
        else if (_purchReqLine && ProjStreamLinePricesForPurchReqFlight::instance().isEnabled())
        {
            salesTaxGroup = _purchReqLine.TaxGroup;
            itemSalesTaxGroup = _purchReqLine.TaxItemGroup;
        }
            
        if (salesTaxGroup && itemSalesTaxGroup)
        {
            TransDate transDate = ProjectCommitmentFacade::getPurchaseOrderPostingDate(_vendInvoiceInfoLine, _purchLine, _purchReqLine);

            if (transDate)
            {
                if (FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance()))
                {
                    boolean applySalesTax = TaxParameters::find().PurchTaxOnOperations == NoYes::Yes ? true : false;

                    TaxGroupData taxGroupTable;
                    TaxOnItem taxOnItem;
                    select firstonly RecId from taxData
                           where taxData.TaxValue != 0
                               && (applySalesTax || taxData.VATExemptPct != 0)
                               && ((taxData.TaxFromDate == dateNull() && taxData.TaxToDate == dateNull())
                                   || (taxData.TaxFromDate <= transDate && taxData.TaxToDate >= transDate))
                           exists join taxGroupTable
                               where taxGroupTable.TaxCode == taxData.TaxCode
                                   && taxGroupTable.TaxGroup == salesTaxGroup
                                   && taxGroupTable.DataAreaId == taxData.DataAreaId
                           exists join taxOnItem
                               where taxOnItem.TaxCode == taxData.TaxCode
                                   && taxOnItem.TaxItemGroup == itemSalesTaxGroup
                                   && taxOnItem.DataAreaId == taxData.DataAreaId;
                }
                else
                {
                    TaxGroupData taxGroupTable;
                    TaxOnItem taxOnItem;
                    select firstonly RecId from taxData
                           where taxData.TaxValue != 0
                               && taxData.VATExemptPct != 0
                               && ((taxData.TaxFromDate == dateNull() && taxData.TaxToDate == dateNull())
                               || (taxData.TaxFromDate <= transDate && taxData.TaxToDate >= transDate))
                           exists join taxGroupTable
                               where taxGroupTable.TaxCode == taxData.TaxCode
                                   && taxGroupTable.TaxGroup == salesTaxGroup
                                   && taxGroupTable.DataAreaId == taxData.DataAreaId
                           exists join taxOnItem
                               where taxOnItem.TaxCode == taxData.TaxCode
                                   && taxOnItem.TaxItemGroup == itemSalesTaxGroup
                                   && taxOnItem.DataAreaId == taxData.DataAreaId;
                }
            }
        }
        
        return taxData.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projIDForProjectCommitment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the value of Project ID for project commitment.
    /// </summary>
    /// <param name = "_projectAccountingDistribution">
    ///     Project accounting distribution table buffer.
    /// </param>
    /// <returns>
    ///     Project ID.
    /// </returns>
    protected static ProjId projIDForProjectCommitment(ProjectAccountingDistribution _projectAccountingDistribution)
    {
        return ProjTable::findRecId(_projectAccountingDistribution.ProjTable).ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityNumberForProjectCommitment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the value of activity number for project commitment.
    /// </summary>
    /// <param name = "_projectAccountingDistribution">
    ///     Project accounting distribution table buffer.
    /// </param>
    /// <returns>
    ///     An activity number.
    /// </returns>
    protected static smmActivityNumber activityNumberForProjectCommitment(ProjectAccountingDistribution _projectAccountingDistribution)
    {
        return smmActivities::findWithRecId(_projectAccountingDistribution.SmmActivities).ActivityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLineCommittedCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new sales line committed costs if budget is enabled and
    /// if the current sales line is marked with project purchase order.
    /// </summary>
    /// <param name="_sourceDocumentLineItem">
    /// An instance of the <c>SourceDocumentLineItem</c> class.
    /// </param>
    private static void updateSalesLineCommittedCost(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        SourceDocumentLineImplementation sourceDocumentLineImplementation = _sourceDocumentLineItem.parmSourceDocumentLine().getSourceDocumentLineImplementation();
        if (sourceDocumentLineImplementation && sourceDocumentLineImplementation.TableId == tableNum(PurchLine))
        {
            PurchLine purchLine = sourceDocumentLineImplementation;
                        
            if (purchLine.projId &&
                purchLine.purchTable().isProjectSalesItemReqPO() &&
                purchLine.isStocked() &&
                purchLine.purchTable().DocumentState == VersioningDocumentState::Confirmed &&
                (purchLine.isOpenOrder()))
            {
                if (!CostControlTransCommittedCost::findOpenedByProjTransID(purchLine.salesLine().ProjTransId).RecId)
                {
                    InventMovement inventMov_Sales = InventMovement::construct(purchLine.salesLine());
                    if (inventMov_Sales.mustBeCostControlled())
                    {
                        CostControlPostingItem costControlPostingItem= CostControlPosting::newCostControlPostingItem(inventMov_Sales);
                        costControlPostingItem.run(ProjCommittedCostUpdateAction::Create);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjectBudgetForPurchReq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the project budget for purchase requisition
    /// if project budget is defined.
    /// </summary>
    /// <param name="_purchReqTable">
    /// A record in the Purchase requisition line.
    /// </param>
    /// <returns>
    /// true if the project budget check succeeded; otherwise, false.
    /// </returns>
    public static void checkProjectBudgetForPurchReq(Common _purchReqTable)
    {
        if (_purchReqTable.TableId == tableNum(PurchReqTable))
        {
            PurchReqTable purchReqTable = _purchReqTable;

            ProjBudget projBudget;
            ProjBudgetLine projBudgetLine;
            PurchReqLine purchReqLine;

            while select ProjId, ProjCategoryId, ActivityNumber from purchReqLine
                group by ProjId, ProjCategoryId, ActivityNumber
                where purchReqLine.PurchReqTable == purchReqTable.RecId
                exists join projBudgetLine
                    where projBudgetLine.ProjId == purchReqLine.ProjId &&
                          projBudgetLine.CategoryId == purchReqLine.ProjCategoryId &&
                          ((projBudgetLine.ActivityNumber && projBudgetLine.ActivityNumber == purchReqLine.ActivityNumber) ||
                          !projBudgetLine.ActivityNumber)
                exists join projBudget
                    where projBudgetLine.ProjBudget == projBudget.RecId &&
                          projBudget.BudgetWorkflowStatus == ProjBudgetWorkflowStatus::Approved
            {
                Map projectCommitmentsMap = new Map(Types::String, Types::Container);

                PurchReqLine purchReqLineLoc;
                SourceDocumentLineItem  sourceDocumentLineItem;
                                  
                while select purchReqLineLoc
                    where purchReqLineLoc.PurchReqTable == purchReqTable.RecId &&
                    purchReqLineLoc.RequisitionStatus != PurchReqRequisitionStatus::Cancelled &&
                    purchReqLineLoc.ProjId == purchReqLine.ProjId &&
                    purchReqLineLoc.ProjCategoryId == purchReqLine.ProjCategoryId &&
                    purchReqLineLoc.ActivityNumber == purchReqLine.ActivityNumber
                {
                    sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLineImplementation(purchReqLineLoc);
                    ProjectCommitmentFacade::updateProjectCommitmentsMap(projectCommitmentsMap, sourceDocumentLineItem, null, 0, true);
                }

                ProjectCommitmentFacade::performProjectBudgetCheck(sourceDocumentLineItem, projectCommitmentsMap, ProjectCommitmentFacade::suppressMessages(sourceDocumentLineItem), true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidCommitment</Name>
				<Source><![CDATA[
    private static boolean isValidCommitment(AccountingDistribution _accountingDistribution,
        SourceDocumentLineItem _accDistSourceDocumentLineItem,
        boolean _vendorInvoiceRetentionCalcFeature)
    {
        boolean validCommitment = true;
        boolean streamLinePricesFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance());

        // Commitment will not consider non recoverable tax.
        SourceDocumentLineItem accDistSourceDocumentLineItem = _accDistSourceDocumentLineItem;
        if (!_accDistSourceDocumentLineItem)
        {
            SourceDocumentLine relievingSourceDocumentLine = SourceDocumentLine::find(_accountingDistribution.SourceDocumentLine);
            accDistSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(relievingSourceDocumentLine);
        }

        if (accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem ||
            accDistSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem ||
            accDistSourceDocumentLineItem is TrvExpTransSourceDocLineItem)
        {
            accDistSourceDocumentLineItem = _accDistSourceDocumentLineItem &&
                _accDistSourceDocumentLineItem.parmSourceDocumentLine().RecId == _accountingDistribution.SourceDocumentLine ? _accDistSourceDocumentLineItem : null;
                
            // For vendor retention case which the ProjVendorInvoiceRetentionCalcFeature has enabled,
            // then TaxNonRecoverableVariance should will not be valid.
            if (streamLinePricesFeature
                && _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance
                && _accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                && ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                    _vendorInvoiceRetentionCalcFeature,
                    _accDistSourceDocumentLineItem))
            {
                validCommitment = false;
            }
            else if (_accountingDistribution.MonetaryAmount == MonetaryAmount::Tax
                || (!streamLinePricesFeature && _accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable)
                || (!streamLinePricesFeature &&_accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)
                || (!streamLinePricesFeature && _accountingDistribution.MonetaryAmount == MonetaryAmount::Discount)
                || (!streamLinePricesFeature && _accountingDistribution.MonetaryAmount == MonetaryAmount::PriceAdjustment))
            {
                validCommitment = false;
            }
        }

        return validCommitment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAccountingDistributionQuantityZero</Name>
				<Source><![CDATA[
    private static boolean isAccountingDistributionQuantityZero(AccountingDistribution _accountingDistribution, SourceDocumentLineItem _accDistSourceDocumentLineItem = null)
    {
        boolean isQuantityZero;

        SourceDocumentLineItem accDistSourceDocumentLineItem = _accDistSourceDocumentLineItem;
        if (!_accDistSourceDocumentLineItem)
        {
            SourceDocumentLine relievingSourceDocumentLine = SourceDocumentLine::find(_accountingDistribution.SourceDocumentLine);
            accDistSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(relievingSourceDocumentLine);
        }

        if (accDistSourceDocumentLineItem is SourceDocumentLineItemIProductQuantity)
        {
            SourceDocumentLineItemIProductQuantity sourceDocumentLineItemIProductQuantity = accDistSourceDocumentLineItem as SourceDocumentLineItemIProductQuantity;
            Qty productQuantity = sourceDocumentLineItemIProductQuantity.parmQuantity();

            if (productQuantity == 0 &&
                accDistSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem &&
                _accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice)
            {
                VendInvoiceInfoLine vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(accDistSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                // Determined if this invoice is associated with vendor payment retention terms.
                boolean isRetainScheduleInvoice = vendInvoiceInfoLine.hasRetentionTerms();
                if (isRetainScheduleInvoice)
                {
                    isQuantityZero = true;
                }
            }
        }

        return isQuantityZero;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseOrderPostingDate</Name>
				<Source><![CDATA[
    private static TransDate getPurchaseOrderPostingDate(VendInvoiceInfoLine _vendInvoiceInfoLine, PurchLine _purchLine, PurchReqLine _purchReqLine = null)
    {
        TransDate transDate;

        // Get the posting date.
        if (_vendInvoiceInfoLine)
        {
            VendInvoiceInfoTable vendInvoiceInfoTable;
            select firstonly TransDate from vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == _vendInvoiceInfoLine.ParmId;
            transDate = vendInvoiceInfoTable.TransDate;
        }
        else if(_purchLine)
        {
            transDate = _purchLine.DeliveryDate;
        }
        else if(_purchReqLine && ProjStreamLinePricesForPurchReqFlight::instance().isEnabled())
        {
            transDate = _purchReqLine.TransDate;
        }

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUncommittedTaxPriceOperationRate</Name>
				<Source><![CDATA[
    private static real calcUncommittedTaxPriceOperationRate(DataAreaId _docDataAreaId, TaxGroup _taxGroup, TaxItemGroup _taxItemGroup, TransDate _transDate)
    {
        real taxRate;
        
        if (_taxGroup && _taxItemGroup)
        {
            // For the case of this code running by workflow, it will lose the context of company and hence running with crosscompany is necessary.
            changecompany(_docDataAreaId)
            {
                boolean streamLinePricesFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance());
                boolean applySalesTax = TaxParameters::find().PurchTaxOnOperations == NoYes::Yes ? true : false;
                boolean validateVATExemptPct = streamLinePricesFeature && !applySalesTax;

                TaxData taxData;
                TaxGroupData taxGroupTable;
                TaxOnItem taxOnItem;
                select sum(TaxValue), sum(VATExemptPct) from taxData
                where taxData.TaxValue != 0
                    && ((streamLinePricesFeature && applySalesTax)
                        || (!streamLinePricesFeature && taxData.VATExemptPct != 0)
                        || (validateVATExemptPct && taxData.VATExemptPct != 0))
                    && ((taxData.TaxFromDate == dateNull() && taxData.TaxToDate == dateNull())
                        || (taxData.TaxFromDate <= _transDate && taxData.TaxToDate >= _transDate))
                exists join taxGroupTable
                    where taxGroupTable.DataAreaId == taxData.DataAreaId
                        && taxGroupTable.TaxCode == taxData.TaxCode
                        && taxGroupTable.TaxGroup == _taxGroup
                exists join taxOnItem
                    where taxOnItem.DataAreaId == taxData.DataAreaId
                        && taxOnItem.TaxCode == taxData.TaxCode
                        && taxOnItem.TaxItemGroup == _taxItemGroup;

                if (taxData.TaxValue)
                {
                    if (applySalesTax)
                    {
                        taxRate = (taxData.TaxValue / 100);
                    }
                    else
                    {
                        taxRate = (taxData.TaxValue / 100) * (taxData.VATExemptPct / 100);
                    }
                }
            }
        }
        return taxRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUncommittedTaxPriceRate</Name>
				<Source><![CDATA[
    private static real calcUncommittedTaxPriceRate(AccountingDistribution _accountingDistribution,
        SourceDocumentLineItem _sourceDocumentLineItem)
    {
        TransDate transDate;
        TaxGroup taxGroup;
        DataAreaId docDataArea;
        TaxItemGroup taxItemGroup;
        
        if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
        {
            VendInvoiceInfoLine vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId);

            taxGroup = vendInvoiceInfoLine.TaxGroup;
            taxItemGroup = vendInvoiceInfoLine.TaxItemGroup;
            transDate = vendInvoiceInfoLine.vendInvoiceInfoTable().TransDate;
            docDataArea = vendInvoiceInfoLine.DataAreaId;
        }
        else if (_sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            PurchLine purchLine = PurchLine::findBySourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId);
            VendInvoiceInfoLine vendInvoiceInfoLine = VendInvoiceInfoLine::findByPurchLineRefRecId(purchLine.RecId);

            taxGroup = purchLine.TaxGroup;
            taxItemGroup = purchLine.TaxItemGroup;
            transDate = ProjectCommitmentFacade::getPurchaseOrderPostingDate(vendInvoiceInfoLine, purchLine);
            docDataArea = purchLine.DataAreaId;
        }
        else if (_sourceDocumentLineItem is TrvExpTransSourceDocLineItem)
        {
            TrvExpTransSourceDocLineItem trvExpTransSourceLineItem = _sourceDocumentLineItem as TrvExpTransSourceDocLineItem;
            TrvExpTrans trvExpTrans = trvExpTransSourceLineItem.parmExpenseLine() as TrvExpTrans;
            transDate = trvExpTrans.TransDate;
            taxGroup = trvExpTrans.TaxGroup;
            taxItemGroup = trvExpTrans.TaxItemGroup;
            docDataArea = trvExpTrans.ReferenceDataAreaId;
        }
         
        return ProjectCommitmentFacade::calcUncommittedTaxPriceOperationRate(docDataArea, taxGroup, taxItemGroup, transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUncommittedTaxCostPrice</Name>
				<Source><![CDATA[
    private static AmountCur calcUncommittedTaxCostPrice(AccountingDistribution _accountingDistribution,SourceDocumentLineItem _sourceDocumentLineItem, AmountCur _costAmount)
    {
        AmountCur taxCostPrice;
        AmountCur taxPriceRate = ProjectCommitmentFacade::calcUncommittedTaxPriceRate(_accountingDistribution, _sourceDocumentLineItem);
        if (taxPriceRate)
        {
            taxCostPrice = _costAmount * taxPriceRate;
        }
        taxCostPrice = CurrencyExchangeHelper::price(taxCostPrice, _accountingDistribution.TransactionCurrency);
        return taxCostPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUncommittedTaxSalesPrice</Name>
				<Source><![CDATA[
    private static AmountCur calcUncommittedTaxSalesPrice(AccountingDistribution _accountingDistribution,
        SourceDocumentLineItem _sourceDocumentLineItem, AmountCur _taxCostAmount)
    {
        AmountCur taxSalesAmount = _taxCostAmount;
        AmountCur costAmount;
        AmountCur salesAmount;

        if (_taxCostAmount)
        {
            if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem ||
                _sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
            {
                VendInvoiceInfoLine vendInvoiceInfoLine;
                PurchLine purchLine;
                if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                {
                    vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                
                }
                else if (_sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                {
                    purchLine = PurchLine::findBySourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                    vendInvoiceInfoLine = VendInvoiceInfoLine::findByPurchLineRefRecId(purchLine.RecId);
                }

                if (vendInvoiceInfoLine)
                {
                    VendInvoiceInfoLine_Project projVendInvoiceLine = VendInvoiceInfoLine_Project::findByVendInvoiceInfoLineRefRecId(vendInvoiceInfoLine.RecId);

                    if (vendInvoiceInfoLine.PurchPrice)
                    {
                        costAmount = ProjectSourceDocumentLineItemHelper::getCostPriceWithDiscountApplied(vendInvoiceInfoLine.PurchPrice, vendInvoiceInfoLine.LineDisc, vendInvoiceInfoLine.LinePercent);
                        salesAmount = projVendInvoiceLine.ProjSalesPrice;
                    }
                }
                else if (purchLine)
                {
                    costAmount = ProjectSourceDocumentLineItemHelper::getCostPriceWithDiscountApplied(purchLine.PurchPrice, purchLine.LineDisc, purchLine.LinePercent);
                    salesAmount = purchLine.ProjSalesPrice;
                }
            }
            else if (_sourceDocumentLineItem is TrvExpTransSourceDocLineItem)
            {
                TrvExpTransSourceDocLineItem trvExpTransSourceLineItem = _sourceDocumentLineItem as TrvExpTransSourceDocLineItem;
                salesAmount = trvExpTransSourceLineItem.parmProjectSalesPrice();
                TrvExpTrans trvExpTrans = trvExpTransSourceLineItem.parmExpenseLine() as TrvExpTrans;
                costAmount = trvExpTrans.NetTransactionAmount;
            }

            // Calculate the tax sales price by sales markup ratio.
            if (costAmount)
            {
                taxSalesAmount = _taxCostAmount / costAmount * salesAmount;
                taxSalesAmount = CurrencyExchangeHelper::price(taxSalesAmount, _accountingDistribution.TransactionCurrency);
            }
        }

        return taxSalesAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesAmount</Name>
				<Source><![CDATA[
    private static Amount getSalesAmount(Amount _costAmount, Amount _costPrice, PurchLineDisc _discountAmount
        , PurchLinePercent _discountPercentage, Amount _salesPrice, CurrencyCode _currencyId)
    {
        // Calculate the project revenue amount by the specified cost amount.
        Amount salesAmount;

        if (_costAmount)
        {
            Amount costPrice = _costPrice;
            if (_discountAmount)
            {
                costPrice = _costPrice - _discountAmount;
            }

            if (_discountPercentage)
            {
                costPrice = _costPrice * (1 - _discountPercentage / 100);
            }

            if (costPrice)
            {            
                salesAmount = CurrencyExchangeHelper::amount(_costAmount / costPrice * _salesPrice, _currencyId);
            }
        }
        
        return salesAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRelievingQuantity</Name>
				<Source><![CDATA[
    private static Qty getRelievingQuantity(AccountingDistribution _accountingDistribution,
        ProjectAccountingDistribution _projectAccountintDistribution,
        SourceDocumentLineItem _sourceDocumentLineItem,
        SourceDocumentLine _sourceDocumentLine,
        VendorInvoiceLineSourceDocLineItem _vendorInvoiceLineSourceDocLineItem,
        boolean _streamLinePricesFeature)
    {
        Qty quantity;

        // Calculates the quantity from project accounting distribution.
        if (_accountingDistribution.TransactionCurrencyAmount && _projectAccountintDistribution.TransactionCurrencyPrice)
        {
            // Reason why quantity is calculates from sales price instead of cost price is because 
            // when vendor retention is enabled, calculates quantity from the AccountingDistribution.TransactionCurrencyAmount is not reliable.
            // Hence the logic has to use ProjectAccountingDistribution.TransactionCurrencyAmount.
            Amount transactionCurrencyAmount = _projectAccountintDistribution.TransactionCurrencyAmount;

            if (_vendorInvoiceLineSourceDocLineItem)
            {
                boolean vendorInvoiceRetentionCalcFeature = ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled();
                VendInvoiceInfoLine vendInvInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(_vendorInvoiceLineSourceDocLineItem.parmSourceDocumentLine().RecId);
                if (vendInvInfoLine && (vendInvInfoLine.PSARetainagePercent || vendInvInfoLine.PSAReleaseAmount)
                    && ProjSalesPriceWithoutRetentionFeatureHelper::isFeatureEnabled()
                    && !ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                        vendorInvoiceRetentionCalcFeature,
                        _vendorInvoiceLineSourceDocLineItem))
                {
                    transactionCurrencyAmount = AccDistProcessorProjectExtension::calcTransCurrencyAmountWithRetention(_vendorInvoiceLineSourceDocLineItem, vendInvInfoLine, _accountingDistribution, _vendorInvoiceLineSourceDocLineItem);
                }
            
                if (_streamLinePricesFeature
                    && vendInvInfoLine
                    && _accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                    && _vendorInvoiceLineSourceDocLineItem.parmIsTaxInChargeInputAmountIncluded())
                {
                    // Add the NonRecoverable tax sales amount
                    AccountingDistribution childNonRecoverableTaxAccDist;
                    ProjectAccountingDistribution childNonRecoverableTaxProjAccDist;

                    select sum(TransactionCurrencyAmount) from childNonRecoverableTaxProjAccDist
                        join RecId from childNonRecoverableTaxAccDist
                            where childNonRecoverableTaxAccDist.RecId == childNonRecoverableTaxProjAccDist.AccountingDistribution
                                && childNonRecoverableTaxAccDist.ParentDistribution == _accountingDistribution.RecId
                                && childNonRecoverableTaxAccDist.MonetaryAmount == MonetaryAmount::TaxNonRecoverable;

                    transactionCurrencyAmount += childNonRecoverableTaxProjAccDist.TransactionCurrencyAmount;

                    if (TaxParameters::find().PurchTaxOnOperations == NoYes::No)
                    {
                        AccountingDistribution childNonRecoverableVarianceTaxAccDist;
                        select sum(TransactionCurrencyAmount) from childNonRecoverableVarianceTaxAccDist
                            where childNonRecoverableVarianceTaxAccDist.ParentDistribution == _accountingDistribution.RecId
                                && childNonRecoverableVarianceTaxAccDist.MonetaryAmount == MonetaryAmount::Tax;

                        if (childNonRecoverableVarianceTaxAccDist.TransactionCurrencyAmount)
                        {
                            if (vendInvInfoLine.PurchPrice)
                            {
                                VendInvoiceInfoLine_Project vendInvInfoLineProj = VendInvoiceInfoLine_Project::findByVendInvoiceInfoLineRefRecId(vendInvInfoLine.RecId);

                                // Calculate the sales amount from cost amount becauuse there is no ProjectAccountingDistribution.TransactionCurrencyAmount stores
                                // in the table field for MonetaryAmount::TaxNonRecoverableVariance
                                Amount nonRecoverableVarianceTaxSalesAmt = ProjectCommitmentFacade::getSalesAmount(childNonRecoverableVarianceTaxAccDist.TransactionCurrencyAmount
                                    , vendInvInfoLine.PurchPrice, vendInvInfoLine.LineDisc, vendInvInfoLine.LinePercent
                                    , vendInvInfoLineProj.ProjSalesPrice, vendInvInfoLineProj.ProjSalesCurrencyId);

                                transactionCurrencyAmount += nonRecoverableVarianceTaxSalesAmt;
                            }
                        }
                    }
                }
            }

            quantity = round(transactionCurrencyAmount / _projectAccountintDistribution.TransactionCurrencyPrice,
                AccountingDistributionConstants::AllocationFactorRoundingPrecision);

        }
        else if (_sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            // In the case of purchase line cost or sales price is 0.00, the project accounting currency price will be 0.00.
            // Then quantity will have to be queried from the invoiced related source document line table.
            SourceDocumentLine sourceDocumentLine;

            select TermQuantity from sourceDocumentLine
                where sourceDocumentLine.RecId == _accountingDistribution.SourceDocumentLine;
                
            quantity = sourceDocumentLine.TermQuantity;
        }
        else
        {
            quantity = _sourceDocumentLine.TermQuantity;
        }

        return quantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseRequisitionLineCommittedCost</Name>
				<Source><![CDATA[
    private static CostAmount getPurchaseRequisitionLineCommittedCost(PurchReqLineRefId _purchReqLineRefId, CurrencyCode _transactionCostCurrency)
    {
        CostAmount purchReqCostAmount;

        if (_purchReqLineRefId)
        {
            PurchReqLine purchReqLine;
            CostControlTransCommittedCost purchReqCommittedCost;

            select firstonly CurrencyCode, Amount, CommittedDate
                from purchReqCommittedCost
                    where purchReqCommittedCost.Open == NoYes::Yes
                exists join purchReqLine
                    where purchReqLine.LineRefId == _purchReqLineRefId
                    && purchReqCommittedCost.SourceDocumentLine == purchReqLine.SourceDocumentLine;

            if (purchReqCommittedCost)
            {
                purchReqCostAmount = purchReqCommittedCost.Amount;
                if (purchReqCommittedCost.CurrencyCode != _transactionCostCurrency)
                {
                    // Committed cost is in different currency
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(purchReqCommittedCost.company()).RecId),
                        purchReqCommittedCost.CommittedDate);
                    purchReqCostAmount = currencyExchangeHelper.calculateAccountingToTransaction(_transactionCostCurrency, purchReqCostAmount, true);
                }
            }
        }

        return purchReqCostAmount;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>