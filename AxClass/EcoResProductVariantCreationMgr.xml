<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>EcoResProductVariantCreationMgr</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>EcoResProductVariantCreationMgr</c> class is used to create product variants based on a
///    generic product model.
/// </summary>
public class EcoResProductVariantCreationMgr extends RunBase
{
    const str  								KeyFormat = "@SYS332074";
    const int								ContainerIndexForDimTableFieldId = 3;
    const int								ContainerIndexForProductDimensionAttributeRecId = 4;

    EcoResTmpProductVariantSuggestion       ecoResTmpProductVariantSuggestion;
    RefRecId                                productMaster;        //reference to the product master
    int                                     numOfSuggestedVariants;
    int                                     numOfCreatedVariants;
    Set                                     activeProductDimAttributeTableIds;
    Map                                     dimAttributeMap;
    RefRecId                                productDimensionAttribute;
    RefRecId                                dimensionValue;
    Map                                     productDimensionValueFilterCriteriaMap;
    
    private EcoResInstrumentationLogger     logger;
    private EcoResProductMaster             currProductMaster;
    private Map                             dimensionValueNameTranslationMap;
    private Set                             selectedProductVariantSuggestions;

    #DEFINE.CurrentVersion(1)
    #LOCALMACRO.CurrentList
        productMaster,
        numOfSuggestedVariants,
        numOfCreatedVariants,
        productDimensionAttribute,
        dimensionValue
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SCM:Caption_EcoResProductVariantCreationMgr";
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDimensionAttributeValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a container with the dimension attribute values.
    /// </summary>
    /// <param name="_ecoResTmpProductVariantSuggestion">
    ///    An <c>EcoResTmpProductVariantSuggestion</c> record that the dimension attribute values should be
    ///    based on.
    /// </param>
    /// <returns>
    ///    A container that contains the <c>dimensionAttributeRecordId</c>, <c>dimensionValueRecordId</c> and <c>dimensionValueRecordName</c>
    ///    values, where:
    ///         the <c>dimensionAttributeRecordId</c> value is the ID of a record in the <c>EcoResProductDimensionAttribute</c> table; 
    ///         the <c>dimensionValueRecordId</c> value is the ID of a record that stores the dimension value;
    ///         the <c>dimensionValueRecordName</c> value is the Name of a record that stores the dimension value name;
    ///         the <c>dimValueNameTranslation</c> value is the translated Name of a record that stores the dimension value name translation.
    /// </returns>
    protected container buildDimensionAttributeValues(EcoResTmpProductVariantSuggestion _ecoResTmpProductVariantSuggestion)
    {
        container       result;
        MapEnumerator   me = dimAttributeMap.getEnumerator();

        while (me.moveNext())
        {
            FieldId currTypeOfTable = EcoResTmpProductVariantSuggestion::modelAttrTable2variantFieldId(me.currentKey());
            RefRecId dimValueFieldId= _ecoResTmpProductVariantSuggestion.(currTypeOfTable);

            Name    dimValueName = EcoResTmpProductVariantSuggestion::productDimensionValueName(currTypeOfTable, _ecoResTmpProductVariantSuggestion);         
            Name    dimValueNameTranslation = this.getDimValueNameTranslation(me.currentValue(), dimValueFieldId);

            if (!dimValueNameTranslation)
            {
                dimValueNameTranslation = dimValueName;
            }

            result += [[me.currentValue(), dimValueFieldId, dimValueName, dimValueNameTranslation]];
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimValueNameTranslation</Name>
				<Source><![CDATA[
    private Name getDimValueNameTranslation(RefRecId _productDimensionAttributeRecId, RefRecId _dimValueFieldId)
    {
        Name dimValueNameTranslation;
        str  mapKey = strFmt("%1_%2", _dimValueFieldId, _productDimensionAttributeRecId);

        if (!dimensionValueNameTranslationMap.exists(mapKey))
        {
            dimValueNameTranslation = EcoResProductNumberBuilderVariant::getProductMasterDimValueNameTranslation(productMaster, _productDimensionAttributeRecId, _dimValueFieldId);
            dimensionValueNameTranslationMap.insert(mapKey, dimValueNameTranslation);
        }
        else
        {
            dimValueNameTranslation = dimensionValueNameTranslationMap.lookup(mapKey);
        }

        return dimValueNameTranslation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearExistingVariantSuggestions</Name>
				<Source><![CDATA[
    private void clearExistingVariantSuggestions()
    {
        delete_from ecoResTmpProductVariantSuggestion;
        numOfSuggestedVariants = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildVariantSuggestions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds the product variant suggestions.
    /// </summary>
    protected void buildVariantSuggestions()
    {
        TableId                                 dimensionTable, dimensionVariantTable;
        FieldId                                 genericModelRelationFieldId;
        FieldId                                 dimAttributeFieldId;
        FieldId                                 dimTableFieldId;
        Map                                     mapDimFieldQueryData                = new Map(Types::Integer,Types::Container);//key : dimFieldId, value container []
        Map                                     dimVariantMap						= new Map(Types::Integer,Types::Integer); //key : dimVariantTableId, dimVariantTableFieldId;
        EcoResProductDimensionGroupProduct      ecoResProductDimensionGroupProduct  = EcoResProductDimensionGroupProduct::findByProduct(productMaster);
        dimensionValueNameTranslationMap        = new Map(Types::String, Types::String);
        currProductMaster                       = EcoResProductMaster::find(this.parmProductMaster());

        List activeProductDimFields         = ecoResProductDimensionGroupProduct.activeProductDimensions(); //a list with the active product dimension for the productMaster
        ListEnumerator enumerator           = activeProductDimFields.getEnumerator();

        activeProductDimAttributeTableIds   = new Set(Types::Integer);
        dimAttributeMap                     = new Map(Types::Integer,Types::Int64);

        //    Loop the active product dimensions for the products dimension group to make sure dimension attributes exists
        //    and gather the required data to construct the queries used later on.
        using(var activityContext = logger.variants().suggestion())
        {
            this.clearExistingVariantSuggestions();

            while (enumerator.moveNext())
            {
                FieldId dimFieldId = enumerator.current();
                //get the dimension attribute id for the field id
                RefRecId productDimensionAttributeRecId = EcoResProductDimensionAttribute::inventDimFieldId2DimensionAttributeRecId(dimFieldId);
                EcoResProductDimensionAttribute ecoResProductDimensionAttribute = EcoResProductDimensionAttribute::find(productDimensionAttributeRecId);
                //find product model dimension table
                TableId dimensionModelTable = ecoResProductDimensionAttribute.getMasterDimensionTableId();

                //find dimension table
                dimensionTable = ecoResProductDimensionAttribute.getDimensionTableId();
                dimensionVariantTable = ecoResProductDimensionAttribute.getVariantDimensionTableId();

                //this is a container of the fields that will be used for the queries
                [genericModelRelationFieldId,dimAttributeFieldId,dimTableFieldId] = this.getFieldsForQuery(dimensionModelTable,dimensionTable);// get id to put range on generic product model
            
                //if no dimension attributes are defined variants can't be created
                if (!this.existProductMasterAttributeValue(
                                                        dimensionModelTable,
                                                        genericModelRelationFieldId,
                                                        productMaster,
                                                        dimAttributeFieldId,
                                                        productDimensionAttributeRecId,
                                                        dimTableFieldId))
                {
                    return;
                }

                mapDimFieldQueryData.insert(dimensionModelTable,[genericModelRelationFieldId,dimAttributeFieldId,dimTableFieldId,productDimensionAttributeRecId,dimensionTable]);

                //insert into Set that is exposed to callers
                activeProductDimAttributeTableIds.add(dimensionModelTable);

                //store the values required by internally used method
                dimAttributeMap.insert(dimensionModelTable,productDimensionAttributeRecId);

                //retrieve dimensions mapping for the createdVariants query
                FieldId dimVariantTableFieldId = this.getDimVariantDimRelationFieldId(dimensionVariantTable, dimensionTable);
                dimVariantMap.insert(dimensionVariantTable, dimVariantTableFieldId);
            }
            
            // The following logic is based on retrieving the existing variants and then skip these while processing the suggestions.
            MapEnumerator meDimFieldQueryData = mapDimFieldQueryData.getEnumerator();
            Query existingVariants = this.buildCreatedVariantsQuery(mapDimFieldQueryData, dimVariantMap);
            Map existingVariantsMap = this.runExistingVariantsQueryAndGenerateMap(existingVariants, meDimFieldQueryData, dimVariantMap);

            Query query = this.buildVariantPosibilitiesQuery(mapDimFieldQueryData);
            QueryRun queryRun = new QueryRun(query);
            
            //based on the query start inserting variant suggestions for non-existing variants
            ttsbegin;
        
            while (queryRun.next())
            { 
                if (existingVariantsMap.empty() || !existingVariantsMap.exists(this.generateSuggestionVariantKey(queryRun, meDimFieldQueryData)))
                {
                    this.createVariantSuggestion(queryRun, mapDimFieldQueryData);
                }
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVariantSuggestion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a product variant suggestion.
    /// </summary>
    /// <param name = "_queryRun">A <c>QueryRun</c> that is used to retrieve combinations of dimension attribute values.</param>
    /// <param name = "_mapDimFieldQueryData">A map that contains field IDs used to create the product variant suggestion.</param>
    protected void createVariantSuggestion(QueryRun _queryRun, Map _mapDimFieldQueryData)
    {
        this.initVariantSuggestion(_queryRun, _mapDimFieldQueryData);

        if (this.canCreateProductVariantsDirectly())
        {
            container attributeValues = this.buildDimensionAttributeValues(ecoResTmpProductVariantSuggestion);

            // create distinct product variant directly
            this.createVariant( this.parmProductMaster(),
                                    ecoResTmpProductVariantSuggestion.Name,
                                    ecoResTmpProductVariantSuggestion.SearchName,
                                    attributeValues);
        }
        else
        {
            ecoResTmpProductVariantSuggestion.insert();
            numOfSuggestedVariants++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVariantSuggestion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a product variant suggestion.
    /// </summary>
    /// <param name = "_queryRun">A <c>QueryRun</c> that is used to retrieve combinations of dimension attribute values.</param>
    /// <param name = "_mapDimFieldQueryData">A map that contains field IDs used to create the product variant suggestion.</param>
    protected void initVariantSuggestion(QueryRun _queryRun, Map _mapDimFieldQueryData)
    {
        MapEnumerator meDimFieldQueryData = _mapDimFieldQueryData.getEnumerator();

        // loop the dimensions to populate the matching field of the EcoResTmpProductVariantSuggestion
        while (meDimFieldQueryData.moveNext())
        {
            FieldId dimTableFieldId = conPeek(meDimFieldQueryData.currentValue(), ContainerIndexForDimTableFieldId);

            Common buffer = _queryRun.get(meDimFieldQueryData.current());
            ecoResTmpProductVariantSuggestion.(EcoResTmpProductVariantSuggestion::modelAttrTable2variantFieldId(buffer.TableId)) = buffer.(dimTableFieldId);
        }

        container attributeValues = this.buildDimensionAttributeValues(ecoResTmpProductVariantSuggestion);

        ecoResTmpProductVariantSuggestion.ProductNumber = EcoResProductNumberBuilderVariant::buildFromProductMasterAndDimensions(
                                                                    currProductMaster,
                                                                    attributeValues);
        ecoResTmpProductVariantSuggestion.Name = EcoResProductNumberBuilderVariant::buildNameFromProductMasterAndDimensions(
                                                                    currProductMaster,
                                                                    attributeValues);
        ecoResTmpProductVariantSuggestion.SearchName = '';
        ecoResTmpProductVariantSuggestion.setSearchName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildVariantSuggestionsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a query that will retrieve combinations of dimensions attribute values.
    /// </summary>
    /// <param name="_mapDimFieldQueryData">
    ///    A map that contains field IDs that are required to build the query.
    /// </param>
    /// <returns>
    ///    A query that will retrieve combinations of dimension attribute values.
    /// </returns>
    [SysObsolete('This query have been extracted into 2 separate queries for improved performance', false, 31\03\2018)]
	protected Query buildVariantSuggestionsQuery(Map _mapDimFieldQueryData)
    {
        QueryBuildDataSource            qbdsTopMost, qbdsVariantDimensionTable;
        FieldId                         genericModelRelationFieldId;
        FieldId                         dimAttributeFieldId;
        TableId                         dimTableFieldId;
        TableId                         dimensionTable;
        RefRecId                        productDimensionAttributeRecId;
        Query                           query = new Query();

        MapEnumerator meDimFieldQueryData = _mapDimFieldQueryData.getEnumerator();

        //First part of query: loop through and start building the query which will result in the cartesian product of dimensions
        while (meDimFieldQueryData.moveNext())
        {
            [genericModelRelationFieldId,dimAttributeFieldId,dimTableFieldId,productDimensionAttributeRecId,dimensionTable] = meDimFieldQueryData.currentValue();

            if (!qbdsTopMost)
            {
                qbdsTopMost = query.addDataSource(meDimFieldQueryData.currentKey(),strFmt('%1',meDimFieldQueryData.currentKey()));
            }
            else
            {
                qbdsTopMost = qbdsTopMost.addDataSource(meDimFieldQueryData.currentKey(),strFmt('%1',meDimFieldQueryData.currentKey()));
                qbdsTopMost.joinMode(JoinMode::OuterJoin);
            }

            qbdsTopMost.addRange(genericModelRelationFieldId).value(queryValue(productMaster));
            qbdsTopMost.addRange(dimAttributeFieldId).value(queryValue(productDimensionAttributeRecId));

            if (this.parmProductDimensionAttribute() == productDimensionAttributeRecId && this.canCreateProductVariantsDirectly())
            {
                qbdsTopMost.addRange(dimTableFieldId).value(queryValue(this.parmDimensionValue()));
            }
        }

        if (!qbdsTopMost)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        //Second part of query: filter out the already existing variants
        QueryBuildDataSource qbdsProductVariant = qbdsTopMost.addDataSource(tableNum(EcoResDistinctProductVariant));
        qbdsProductVariant.joinMode(JoinMode::NoExistsJoin);
        qbdsProductVariant.addRange(fieldNum(EcoResDistinctProductVariant, ProductMaster)).value(queryValue(productMaster));

        //loop the product dimensions, e.g size,color,config and add them
        meDimFieldQueryData.reset();

        while (meDimFieldQueryData.moveNext())
        {
            [genericModelRelationFieldId,dimAttributeFieldId,dimTableFieldId,productDimensionAttributeRecId,dimensionTable] = meDimFieldQueryData.currentValue();

            //1. get variant dim table based on attribute id
            EcoResProductDimensionAttribute ecoResProductDimensionAttribute = EcoResProductDimensionAttribute::find(productDimensionAttributeRecId);
            TableId dimensionVariantTable = ecoResProductDimensionAttribute.getVariantDimensionTableId();
            //2. get field to put range on
            FieldId variantDimtoDimRelationField = EcoResProductVariantDimensionValue::dimensionForeignKeyFieldId(dimensionVariantTable);

            //add dimension value to query
            qbdsVariantDimensionTable = qbdsProductVariant.addDataSource(dimensionVariantTable);
            qbdsVariantDimensionTable.joinMode(JoinMode::ExistsJoin);
            qbdsVariantDimensionTable.relations(true);
            qbdsVariantDimensionTable.addRange(fieldNum(EcoResProductVariantDimensionValue, ProductDimensionAttribute)).value(queryValue(productDimensionAttributeRecId));
            qbdsVariantDimensionTable.addLink(dimTableFieldId,variantDimtoDimRelationField,strFmt('%1',meDimFieldQueryData.currentKey()));
        }

        // RLS is implicitly enabled when executing dynamically-built queries. RLS adds a filter to only return records
        // for the sub types that the user has access to. In this place we don't want a filtered result, so we need to disable RLS.
        query.recordLevelSecurity(false);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildVariantPosibilitiesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a query that will retrieve all combinations of dimensions attribute values.
    /// </summary>
    /// <param name="_mapDimFieldQueryData">
    ///    A map that contains field IDs that are required to build the query.
    /// </param>
    /// <returns>
    ///    A query that will retrieve all combinations of dimension attribute values.
    /// </returns>
	protected Query buildVariantPosibilitiesQuery(Map _mapDimFieldQueryData)
    {
        QueryBuildDataSource            qbdsTopMost;
        FieldId                         genericModelRelationFieldId;
        FieldId                         dimAttributeFieldId;
        TableId                         dimTableFieldId;
        TableId                         dimensionTable;
        RefRecId                        productDimensionAttributeRecId;
        
		Query                           query = new Query();
        MapEnumerator					meDimFieldQueryData = _mapDimFieldQueryData.getEnumerator();

        //loop through and start building the query which will result in the Cartesian product of dimensions
        while (meDimFieldQueryData.moveNext())
        {
            [genericModelRelationFieldId,dimAttributeFieldId,dimTableFieldId,productDimensionAttributeRecId,dimensionTable] = meDimFieldQueryData.currentValue();

            if (!qbdsTopMost)
            {
                qbdsTopMost = query.addDataSource(meDimFieldQueryData.currentKey(),strFmt('%1',meDimFieldQueryData.currentKey()));
            }
            else
            {
                qbdsTopMost = qbdsTopMost.addDataSource(meDimFieldQueryData.currentKey(),strFmt('%1',meDimFieldQueryData.currentKey()));
                qbdsTopMost.joinMode(JoinMode::OuterJoin);
            }

            qbdsTopMost.addRange(genericModelRelationFieldId).value(queryValue(productMaster));
            qbdsTopMost.addRange(dimAttributeFieldId).value(queryValue(productDimensionAttributeRecId));

            if (this.parmProductDimensionAttribute() == productDimensionAttributeRecId && this.canCreateProductVariantsDirectly())
            {
                qbdsTopMost.addRange(dimTableFieldId).value(queryValue(this.parmDimensionValue()));
            }
            else
            {
                this.addProductDimensionValueRanges(qbdsTopMost, meDimFieldQueryData.currentKey(), dimTableFieldId);
            }
        }

        if (!qbdsTopMost)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // RLS is implicitly enabled when executing dynamically-built queries. RLS adds a filter to only return records
        // for the sub types that the user has access to. In this place we don't want a filtered result, so we need to disable RLS.
        query.recordLevelSecurity(false);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addProductDimensionValueRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds product dimension filter values from the internal list as ranges to the given datasource.
    /// </summary>
    /// <param name = "_queryBuildDataSource">The datasource to add the ranges to.</param>
    /// <param name = "_dimensionModelTableId">The ID of the product master dimension table for the dimension to add the ranges for.</param>
    /// <param name = "_dimTableFieldId">The field ID on the given datasource for the dimension to add the ranges for.</param>
    private void addProductDimensionValueRanges(QueryBuildDataSource _queryBuildDataSource, TableId _dimensionModelTableId, FieldId _dimTableFieldId)
    {
        if (productDimensionValueFilterCriteriaMap
            && productDimensionValueFilterCriteriaMap.exists(_dimensionModelTableId))
        {
            List productDimensionValueFilterRecIdList = productDimensionValueFilterCriteriaMap.lookup(_dimensionModelTableId);

            if (productDimensionValueFilterRecIdList != null
                && productDimensionValueFilterRecIdList.elements() > 0)
            {
                ListEnumerator productDimensionValueFilterRecIdListEnumerator = productDimensionValueFilterRecIdList.getEnumerator();

                while (productDimensionValueFilterRecIdListEnumerator.moveNext())
                {
                    _queryBuildDataSource.addRange(_dimTableFieldId).value(queryValue(productDimensionValueFilterRecIdListEnumerator.current()));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCreatedVariantsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a query that will retrieve the created/existing variants of dimensions attribute values.
    /// </summary>
    /// <param name="_mapDimFieldQueryData">
    ///    A map that contains field IDs that are required to build the query.
    /// </param>
    /// <param name="_dimVariantMap">
    ///    A map that contains field IDs that are required to build the query.
    /// </param>
    /// <returns>
    ///    A query that will retrieve the created/existing variants of dimensions attribute values.
    /// </returns>
    protected Query buildCreatedVariantsQuery(Map _mapDimFieldQueryData, Map _dimVariantMap)
    {
        Query query = new Query();
        QueryBuildDataSource qbdsTopMost = query.addDataSource(tableNum(EcoResDistinctProductVariant));

        qbdsTopMost.addRange(fieldNum(EcoResDistinctProductVariant, ProductMaster)).value(queryValue(productMaster));
        
        //First part of query: loop through and start building the query which will result in the Cartesian product of dimensions
        MapEnumerator meDimFieldQueryData = _mapDimFieldQueryData.getEnumerator();
        while (meDimFieldQueryData.moveNext())
        {
            // loop the product dimensions, e.g size,color,config and add them
            RefRecId productDimensionAttributeRecId = conPeek(meDimFieldQueryData.currentValue(), ContainerIndexForProductDimensionAttributeRecId);

            //1. get variant dim table based on attribute id
            EcoResProductDimensionAttribute ecoResProductDimensionAttribute = EcoResProductDimensionAttribute::find(productDimensionAttributeRecId);
            TableId dimensionVariantTable = ecoResProductDimensionAttribute.getVariantDimensionTableId();
            //2. get field to put range on
            FieldId variantDimToDimRelationField = EcoResProductVariantDimensionValue::dimensionForeignKeyFieldId(dimensionVariantTable);

            QueryBuildDataSource qbdsDimvar = qbdsTopMost.addDataSource(dimensionVariantTable);
            var dimVariant = _dimVariantMap.lookup(dimensionVariantTable);
            qbdsDimvar.joinMode(JoinMode::InnerJoin);
            qbdsDimvar.fetchMode(QueryFetchMode::One2One);
            qbdsDimvar.addLink(fieldNum(EcoResDistinctProductVariant, RecId), variantDimToDimRelationField);
            qbdsDimvar.addSelectionField(dimVariant);
            qbdsDimvar.relations(true);

            // If we are creating variants only for a specific product dimension value we 
            // can restrict the existing variants check to only variants with that value.
            if (this.parmProductDimensionAttribute() == productDimensionAttributeRecId 
                && this.parmDimensionValue()) 
            {
                qbdsDimvar.addRange(dimVariant).value(queryValue(this.parmDimensionValue()));
            }
            else
            {
                this.addProductDimensionValueRanges(qbdsDimvar, meDimFieldQueryData.currentKey(), dimVariant);
            }

            qbdsDimvar.addRange(fieldNum(EcoResProductVariantDimensionValue, ProductDimensionAttribute)).value(queryValue(productDimensionAttributeRecId));
        }

		if (!qbdsTopMost)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runExistingVariantsQueryAndGenerateMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the query and generates a map with the results.
    /// </summary>
    /// <param name="_query">
    ///    A query containing dimensions specified in the _createdVariantFieldSourceMap parameter.
    /// </param>
    /// <param name="_meDimFieldQueryData">
    ///    A map that contains possibilities variants field IDs and data sources.
    /// </param>
    /// <param name="_createdVariantFieldSourceMap">
    ///    A map that contains existing variants field IDs and data sources.
    /// </param>
    /// <returns>
    ///    A map containing query that will retrieve the created/existing variants of dimensions attribute values.
    /// </returns>
    protected Map runExistingVariantsQueryAndGenerateMap(Query _query, MapEnumerator _meDimFieldQueryData, Map _createdVariantFieldSourceMap)
    {
        QueryRun queryRun = new QueryRun(_query);
        Map existingVariants = new Map(Types::String, Types::Integer);

        while(queryRun.next())
        {
            str key = this.generateExistingVariantKey(queryRun, _meDimFieldQueryData, _createdVariantFieldSourceMap);
			if(!key)
            {
                throw error("@SCM:EcoResProductVariantSuggestionMissingDimensions");
            }
            existingVariants.insert(key, 0);
        }

        return existingVariants;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateExistingVariantKey</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Generates a key based on the existingVariants query.
    /// </summary>
    /// <param name="_queryRun">
    ///    A query containing dimensions specified in the _createdVariantFieldSourceMap parameter.
    /// </param>
    /// <param name="_meDimFieldQueryData">
    ///    A mapEnumerator that contains possibilities variants field IDs and data sources.
    /// </param>
    /// <param name="_createdVariantFieldSourceMap">
    ///    A mapEnumerator that contains existing variants field IDs and data sources.
    /// </param>
    /// <returns>
    ///    A string representing the dimensions of the current QueryRun buffer.
    /// </returns>
    protected str generateExistingVariantKey(QueryRun _queryRun, MapEnumerator _meDimFieldQueryData, Map _createdVariantFieldSourceMap)
    {
        str key;
        _meDimFieldQueryData.reset();

        // loop the dimensions to populate the matching field of the EcoResTmpProductVariantSuggestion
        while (_meDimFieldQueryData.moveNext())
        {
            // loop the product dimensions, e.g size,color, config in original(possibilities) created map, to get the same ordering for the key.
            RefRecId productDimensionAttributeRecId = conPeek(_meDimFieldQueryData.currentValue(), ContainerIndexForProductDimensionAttributeRecId);
            EcoResProductDimensionAttribute ecoResProductDimensionAttribute = EcoResProductDimensionAttribute::find(productDimensionAttributeRecId);

            TableId dimensionVariantTable = ecoResProductDimensionAttribute.getVariantDimensionTableId();
            FieldId selectedField = _createdVariantFieldSourceMap.lookup(dimensionVariantTable);
            Common buffer = _queryRun.get(dimensionVariantTable);
            key = strFmt(KeyFormat, key, buffer.(selectedField));
        }
        return key;
	}

]]></Source>
			</Method>
			<Method>
				<Name>generateSuggestionVariantKey</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Generates a key based on the possibilities variants query.
    /// </summary>
    /// <param name="_queryRun">
    ///    A query containing dimensions specified in the _createdVariantFieldSourceMap parameter.
    /// </param>
    /// <param name="_meDimFieldQueryData">
    ///    A mapEnumerator that contains possibilities variants field IDs and data sources.
    /// </param>
    /// <returns>
    ///    A string representing the dimensions of the current QueryRun buffer.
    /// </returns>
    protected str generateSuggestionVariantKey(QueryRun _queryRun, MapEnumerator _meDimFieldQueryData)
    {
        str key;
        _meDimFieldQueryData.reset();
        // loop the dimensions to populate the matching field of the EcoResTmpProductVariantSuggestion
        while (_meDimFieldQueryData.moveNext())
        {
            FieldId dimTableFieldId = conPeek(_meDimFieldQueryData.currentValue(), ContainerIndexForDimTableFieldId);
            Common buffer = _queryRun.get(_meDimFieldQueryData.current());
            key = strFmt(KeyFormat, key, buffer.(dimTableFieldId));
        }
        return key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateProductVariantsDirectly</Name>
				<Source><![CDATA[
    protected boolean canCreateProductVariantsDirectly()
    {
        return productDimensionAttribute && dimensionValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVariant</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a product variant.
    /// </summary>
    /// <param name="_productMaster">
    ///    The ID of the generic product model that the product variant is based on.
    /// </param>
    /// <param name="_productName">
    ///    The product name that should be assigned to the product variant.
    /// </param>
    /// <param name="_searchName">
    ///    The product search name that should be assigned to the product variant.
    /// </param>
    /// <param name="_attributeValues">
    ///    A container that contains pairs in the form of <c>dimensionAttributeRecordId</c> and
    ///    <c>dimensionValueRecordId</c> values, where the <c>dimensionAttributeRecordId</c> value is the ID
    ///    of a record in the <c>EcoResProductDimensionAttribute</c> table and the
    ///    <c>dimensionValueRecordId</c> value is the ID of a record that stores the dimension value.
    /// </param>
    /// <param name="_productNumber">
    ///    The display product number to be used; optional.
    /// </param>
    /// <returns>
    ///    A reference record ID, which is the ID of the created product variant.
    /// </returns>
    /// <remarks>
    ///    The container specified by the <paramref name="_attributeValues" /> parameter should contain pairs
    ///    of <c>dimensionAttributeRecordId</c> and <c>dimensionValueRecordId</c> values. The
    ///    <c>dimensionAttributeRecordId</c> value is the ID of a record in the
    ///    <c>EcoResProductDimensionAttribute</c> table and the <c>dimensionValueRecordId</c> value is the ID
    ///    of a record that stores the dimension value.
    /// </remarks>
    protected RefRecId createVariant(
        RefRecId                            _productMaster,
        EcoResProductName                   _productName,
        EcoResProductSearchName             _searchName,
        container                           _attributeValues,
        EcoResProductDisplayProductNumber   _productNumber = '')
    {
        RefRecId productVariant = EcoResProductVariantManager::createProductVariant(_productMaster,
                                                                                    _searchName,
                                                                                    _attributeValues,
                                                                                    _productNumber);

        if (_productName)
        {
            if (EcoResProductVariantCreationMgrEnUsDescriptionFlight::instance().isEnabled())
            {
                // The description has already been added based on the product master description
                EcoResDescription productVariantDescription = EcoResProductTranslation::findByProductLanguage(productVariant, SystemParameters::getSystemLanguageId()).Description;

                // Update the product name
                EcoResProductTranslation::createOrUpdateTranslation(productVariant, _productName, productVariantDescription);
            }
            else
            {
                EcoResProductTranslation::createOrUpdateTranslation(productVariant, _productName, '');
            }
        }

        numOfCreatedVariants++;

        return productVariant;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVariantsFromDimensionValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates distinct product variants, depending on the specified product dimension value.
    /// </summary>
    /// <param name="_productDimensionAttribute">
    /// The record ID of a <c>EcoResProductDimensionAttribute</c> record.
    /// </param>
    /// <param name="_dimensionValue">
    /// The record ID of a record in a dimension table.
    /// </param>
    public void  createVariantsFromDimensionValue(
        RefRecId  _productDimensionAttribute,
        RefRecId  _dimensionValue)
    {
        this.parmProductDimensionAttribute(_productDimensionAttribute);
        this.parmDimensionValue(_dimensionValue);

        this.buildVariantSuggestions();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog(DialogRunbase _dialog = null, boolean _forceOnClient = false)
    {
        Args args = new Args();
        args.name(formStr(EcoResProductVariantSuggestionsEnhanced));
        args.caller(this);

        FormRun formRun = classfactory.formRunClass(args);
        formRun.init();
        return formRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existProductMasterAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a product dimension attribute value exists for the specified parameters.
    /// </summary>
    /// <param name="_dimensionModelTable">
    ///    The ID of the dimension attribute value table of the product master.
    /// </param>
    /// <param name="_masterRelationFieldId">
    ///    The ID of the field that has the relation to the <c>EcoResProductMaster</c> record.
    /// </param>
    /// <param name="_productMaster">
    ///    The ID of the product master.
    /// </param>
    /// <param name="_dimAttributeFieldId">
    ///    The ID of the dimension attribute ID field.
    /// </param>
    /// <param name="_dimensionAttributeId">
    ///    The ID of the dimension attribute.
    /// </param>
    /// <param name="_dimTableFieldId">
    ///    The field ID of the dimension table.
    /// </param>
    /// <returns>
    ///    true if a value exists; otherwise, false.
    /// </returns>
    protected boolean existProductMasterAttributeValue(
                                                    TableId     _dimensionModelTable,
                                                    FieldId     _masterRelationFieldId,
                                                    RefRecId    _productMaster,
                                                    FieldId     _dimAttributeFieldId,
                                                    RefRecId    _dimensionAttributeId,
                                                    FieldId     _dimTableFieldId)
    {
        Query                   query       = new Query();

        //build the query to determine if at least one dimension attribute value is specified
        QueryBuildDataSource qbdsDimModelTable = query.addDataSource(_dimensionModelTable);
        qbdsDimModelTable.firstOnly(true);
        qbdsDimModelTable.addRange(_masterRelationFieldId).value(queryValue(_productMaster));
        qbdsDimModelTable.addRange(_dimAttributeFieldId).value(queryValue(_dimensionAttributeId));

        if (this.parmProductDimensionAttribute() == _dimensionAttributeId && this.canCreateProductVariantsDirectly())
        {
            qbdsDimModelTable.addRange(_dimTableFieldId).value(queryValue(this.parmDimensionValue()));
        }
        QueryRun queryRun = new QueryRun(query);

        return queryRun.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveProductDimAttributeTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a container which is a packed set that contains the table IDs of the active product model
    ///    dimension attribute values.
    /// </summary>
    /// <returns>
    ///    A container.
    /// </returns>
    /// <remarks>
    ///    A packed set is retrieved so the set can be reconstructed on the client tier.An empty container is
    ///    retrieved if the internal class structures has not yet been constructed.
    /// </remarks>
    public container getActiveProductDimAttributeTableId()
    {
        if (!activeProductDimAttributeTableIds)
        {
            return conNull();
        }

        return activeProductDimAttributeTableIds.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initActiveProductDimAttributeTableIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the internal set of active product dimension attribute table IDs.
    /// </summary>
    internal void initActiveProductDimAttributeTableIds()
    {
        activeProductDimAttributeTableIds = new Set(Types::Integer);

        EcoResProductDimensionGroupProduct ecoResProductDimensionGroupProduct  = EcoResProductDimensionGroupProduct::findByProduct(productMaster);

        List activeProductDimFields = ecoResProductDimensionGroupProduct.activeProductDimensions(); //a list with the active product dimensions for the productMaster
        ListEnumerator enumerator = activeProductDimFields.getEnumerator();

        while (enumerator.moveNext())
        {
            FieldId dimFieldId = enumerator.current();

            //get the dimension attribute id for the field id
            RefRecId productDimensionAttributeRecId = EcoResProductDimensionAttribute::inventDimFieldId2DimensionAttributeRecId(dimFieldId);
            EcoResProductDimensionAttribute ecoResProductDimensionAttribute = EcoResProductDimensionAttribute::find(productDimensionAttributeRecId);

            //find product model dimension table
            TableId dimensionModelTable = ecoResProductDimensionAttribute.getMasterDimensionTableId();

            //insert into Set that is exposed to callers
            activeProductDimAttributeTableIds.add(dimensionModelTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldsForQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a container with field IDs of the fields that it required in order to build the query
    ///    that retrieves combinations of dimension attribute values.
    /// </summary>
    /// <param name="_dimModeltable">
    ///    The table ID of the table which is the relation between a generic product model and a dimension
    ///    attribute value table.
    /// </param>
    /// <param name="_dimTable">
    ///    The table ID of a dimension attribute value table.
    /// </param>
    /// <returns>
    ///    A container that contains the field ID of a generic product model ID, the field ID of a dimension
    ///    attribute ID, and the field ID of the field that is related to the dimension attribute value.
    /// </returns>
    protected container getFieldsForQuery(TableId _dimModeltable, TableId _dimTable)
    {
        SysDictTable    dictTable = new SysDictTable(_dimModeltable);
        FieldId         genericModelFieldId;
        FieldId         dimensionAttributeFieldId;
        FieldId         dimensionRelationFieldId;
        int             relationCounterTest;

        SetEnumerator relationsEnumerator = dictTable.relations().getEnumerator();

        while (relationsEnumerator.moveNext())
        {
            SysDictRelation sysDictRelation = relationsEnumerator.current();

            if (sysDictRelation.externTable() == tableNum(EcoResProductMaster))
            {
                genericModelFieldId = sysDictRelation.lineTableValue(1);
                relationCounterTest++;
            }

            if (sysDictRelation.externTable() == tableNum(EcoResProductDimensionAttribute))
            {
                dimensionAttributeFieldId = sysDictRelation.lineTableValue(1);
                relationCounterTest++;
            }

            //the field that is relation between the dimension attribute table and the product model dimensions table
            if (sysDictRelation.externTable() == _dimTable)
            {
                dimensionRelationFieldId = sysDictRelation.lineTableValue(1);
                relationCounterTest++;
            }
        }

        if (relationCounterTest != 3)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return [genericModelFieldId,dimensionAttributeFieldId,dimensionRelationFieldId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimVariantDimRelationFieldId</Name>
				<Source><![CDATA[
    protected FieldId getDimVariantDimRelationFieldId(TableId _dimVariantTable, TableId _dimTable)
    {
        SysDictTable    dictTable = new SysDictTable(_dimVariantTable);
        SetEnumerator relationsEnumerator = dictTable.relations().getEnumerator();

        while (relationsEnumerator.moveNext())
        {
            SysDictRelation sysDictRelation = relationsEnumerator.current();

            // The field that is relation between the dimension attribute table and the product model dimensions table
            if (sysDictRelation.externTable() == _dimTable)
            {
                FieldId dimensionRelationFieldId = sysDictRelation.lineTableValue(1);
                return dimensionRelationFieldId;
            }
        }

        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfCreatedVariants</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number of variants that were created.
    /// </summary>
    /// <returns>
    ///    The number of variants that were created.
    /// </returns>
    public int numberOfCreatedVariants()
    {
        return numOfCreatedVariants;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfSuggestedVariants</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number of variants that were suggested.
    /// </summary>
    /// <returns>
    ///    The number of variants that were suggested.
    /// </returns>
    public int numberOfSuggestedVariants()
    {
        return numOfSuggestedVariants;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDimensionValue</Name>
				<Source><![CDATA[
    public RefRecId parmDimensionValue(RefRecId _dimensionValue = dimensionValue)
    {
        dimensionValue = _dimensionValue;

        return dimensionValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEcoResTmpProductVariantSuggestion</Name>
				<Source><![CDATA[
    public EcoResTmpProductVariantSuggestion parmEcoResTmpProductVariantSuggestion(EcoResTmpProductVariantSuggestion _ecoResTmpProductVariantSuggestion = ecoResTmpProductVariantSuggestion)
    {
        ecoResTmpProductVariantSuggestion = _ecoResTmpProductVariantSuggestion;

        return ecoResTmpProductVariantSuggestion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProductDimensionAttribute</Name>
				<Source><![CDATA[
    public RefRecId parmProductDimensionAttribute(RefRecId _productDimensionAttribute = productDimensionAttribute)
    {
        productDimensionAttribute = _productDimensionAttribute;

        return productDimensionAttribute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProductMaster</Name>
				<Source><![CDATA[
    public RefRecId parmProductMaster(RefRecId _productMaster = productMaster)
    {
        productMaster = _productMaster;

        return productMaster;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProductMasterRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>EcoResProductMaster</c>
    /// </summary>
    /// <returns>An instance of the product master</returns>
    public EcoResProductMaster parmProductMasterRecord()
    {
        if (this.parmProductMaster() && currProductMaster.RecId != this.parmProductMaster())
        {
            currProductMaster = EcoResProductMaster::find(this.parmProductMaster());
        }

        return currProductMaster;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        using(var activityContext = logger.variants().generation())
        {
            this.creationProductVariantsFromSelectedVariantsSet();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>creationProductVariantsFromTemporaryTable</Name>
				<Source><![CDATA[
    private void creationProductVariantsFromTemporaryTable()
    {
        //loop the selected suggestions
        while select ecoResTmpProductVariantSuggestion
            where ecoResTmpProductVariantSuggestion.Selected == NoYes::Yes
        {
            this.createVariantFromSelectedVariantSuggestion(ecoResTmpProductVariantSuggestion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>creationProductVariantsFromSelectedVariantsSet</Name>
				<Source><![CDATA[
    private void creationProductVariantsFromSelectedVariantsSet()
    {
        //loop the selected suggestions
        SetEnumerator selectedProductVariantSuggestionsEnumerator = selectedProductVariantSuggestions.getEnumerator();

        while (selectedProductVariantSuggestionsEnumerator.moveNext())
        {
            EcoResTmpProductVariantSuggestion selectedProductVariantSuggestion = selectedProductVariantSuggestionsEnumerator.current();

            this.createVariantFromSelectedVariantSuggestion(selectedProductVariantSuggestion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVariantFromSelectedVariantSuggestion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the variant based on the variant suggestion
    /// </summary>
    /// <param name = "_selectedProductVariantSuggestion">The instance of the <c>EcoResTmpProductVariantSuggestion</c> for which the variant will be created</param>
    /// <returns>The record id of the created product variant</returns>
    protected EcoResDistinctProductVariantRecId createVariantFromSelectedVariantSuggestion(EcoResTmpProductVariantSuggestion _selectedProductVariantSuggestion)
    {
        if (this.validateSelectedVariantSuggestion(_selectedProductVariantSuggestion))
        {
            //build the structure of the dimensions
            container attributeValues = this.buildDimensionAttributeValues(_selectedProductVariantSuggestion);

            //checks for correct dimension are done by the method
            ttsbegin;
            EcoResDistinctProductVariantRecId productVariantRecId = this.createVariant(productMaster,
                               _selectedProductVariantSuggestion.Name,
                               _selectedProductVariantSuggestion.SearchName,
                               attributeValues,
                               _selectedProductVariantSuggestion.ProductNumber);
            ttscommit;

            return productVariantRecId;
        }
        else
        {
            error(strFmt("@SCM:EcoResVariantCreationValidationError", _selectedProductVariantSuggestion.ProductNumber));
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSelectedVariantSuggestion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the variant suggestion should be validated before creating the variant
    /// </summary>
    /// <param name = "_selectedProductVariantSuggestion">The instance of the <c>EcoResTmpProductVariantSuggestion</c> for which the variant will be created</param>
    /// <returns>True if the variant can be created, otherwise false</returns>
    protected boolean validateSelectedVariantSuggestion(EcoResTmpProductVariantSuggestion _selectedProductVariantSuggestion)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        int version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case #CurrentVersion:
                container packedSelectedProductVariantSuggestions;
                container packedDimAttributeMap;
                container packedDimensionValueNameTranslationMap;

                [version, #CurrentList, packedSelectedProductVariantSuggestions, packedDimAttributeMap, packedDimensionValueNameTranslationMap] = packedClass;

                if (packedSelectedProductVariantSuggestions != conNull())
                {
                    selectedProductVariantSuggestions = Set::create(packedSelectedProductVariantSuggestions);
                }

                if (packedDimAttributeMap != conNull())
                {
                    dimAttributeMap = Map::create(packedDimAttributeMap);
                }

                if (packedDimensionValueNameTranslationMap != conNull())
                {
                    dimensionValueNameTranslationMap = Map::create(packedDimensionValueNameTranslationMap);
                }

                return true;
            default :
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion,
            #CurrentList,
            selectedProductVariantSuggestions ? selectedProductVariantSuggestions.pack() : conNull(),
            dimAttributeMap ? dimAttributeMap.pack() : conNull(),
            dimensionValueNameTranslationMap ? dimensionValueNameTranslationMap.pack() : conNull()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    protected static EcoResProductVariantCreationMgr construct()
    {
        return new EcoResProductVariantCreationMgr();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();
        logger = EcoResInstrumentationLogger::createLogger(classStr(EcoResProductVariantCreationMgr));
        selectedProductVariantSuggestions = new Set(Types::Record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateVariantSuggestions</Name>
				<Source><![CDATA[
    internal boolean generateVariantSuggestions(Map _productDimensionValueFilterCriteriaMap = null)
    {
        productDimensionValueFilterCriteriaMap = _productDimensionValueFilterCriteriaMap;

        this.validateProductDimensionValueFilterCriteriaMap();

        this.buildVariantSuggestions();
        
        if (!this.numberOfSuggestedVariants())
        {
            warning(strFmt("@SYS135737", EcoResProductMaster::find(this.parmProductMaster()).productNumber()));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxSupportedNumberOfProductDimensionValueFilterCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the limit of supported product dimension value filter criteria.
    /// </summary>
    /// <returns>The maximum number of filter criteria.</returns>
    /// <remarks>
    /// This limit is used to prevent "Binding operation failed to allocate buffer space" errors occurring if too many ranges/parameters are added to the queries.
    /// </remarks>
    protected int getMaxSupportedNumberOfProductDimensionValueFilterCriteria()
    {
        return 2000;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProductDimensionValueFilterCriteriaMap</Name>
				<Source><![CDATA[
    private void validateProductDimensionValueFilterCriteriaMap()
    {
        if (productDimensionValueFilterCriteriaMap
            && productDimensionValueFilterCriteriaMap.elements() > 0)
        {
            int numberOfFilters;

            MapEnumerator productDimensionValueFilterCriteriaMapEnumerator = productDimensionValueFilterCriteriaMap.getEnumerator();
            while (productDimensionValueFilterCriteriaMapEnumerator.moveNext())
            {
                List productDimensionValueFilterCriteriaList = productDimensionValueFilterCriteriaMapEnumerator.currentValue();

                if (!productDimensionValueFilterCriteriaList)
                {
                    // A list of product dimension filter criteria is expected as map value
                    throw error(Error::wrongUseOfFunction(funcName()));
                }

                numberOfFilters += productDimensionValueFilterCriteriaList.elements();

                if (numberOfFilters > this.getMaxSupportedNumberOfProductDimensionValueFilterCriteria())
                {
                    throw error(strFmt("@SCM:Error_EcoResProductVariantCreationMgr_MaxNumberOfFilterCriteriaExceeded", this.getMaxSupportedNumberOfProductDimensionValueFilterCriteria(), "@SCM:Button_EcoResProductVariantSuggestionsEnhanced_SuggestAllButton"));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args _args)
    {
        EcoResProductVariantCreationMgr     productVariantCreationMgr = EcoResProductVariantCreationMgr::newFromArgs(_args);

        productVariantCreationMgr.saveLast();

        if (productVariantCreationMgr.prompt())
        {
            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(_args))
            {
                productVariantCreationMgr.buildSelectedProductVariantSuggestionsSetFromTemporaryTable();
                productVariantCreationMgr.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSelectedProductVariantSuggestionsSetFromTemporaryTable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void buildSelectedProductVariantSuggestionsSetFromTemporaryTable()
    {
        selectedProductVariantSuggestions = new Set(Types::Record);

        while select ecoResTmpProductVariantSuggestion
            where ecoResTmpProductVariantSuggestion.Selected == NoYes::Yes
        {
            selectedProductVariantSuggestions.add(ecoResTmpProductVariantSuggestion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>EcoResProductVariantCreationMgr</c> class.
    /// </summary>
    /// <param name="_args">
    /// The arguments for the new instance.
    /// </param>
    /// <returns>
    /// An instance of the <c>EcoResProductVariantCreationMgr</c> class.
    /// </returns>
    public static EcoResProductVariantCreationMgr newFromArgs(Args _args)
    {
        EcoResProductMaster                 productMaster = EcoResProductMaster::getProductMasterFromCaller(_args);
        EcoResProductVariantCreationMgr     productVariantCreationMgr;

        if (_args.parmEnumType() == enumNum(EcoResReleaseProductToCompany))
        {
            productVariantCreationMgr = EcoResProductVariantCreationMgr::newFromReleaseProductToCompanyEnum(_args.parmEnum());
        }
        else
        {
            productVariantCreationMgr = EcoResProductVariantCreationMgr::construct();
        }

        productVariantCreationMgr.parmProductMaster(productMaster.RecId);

        return productVariantCreationMgr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromReleaseProductToCompanyEnum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>EcoResProductVariantCreationMgr</c> class based on a
    /// <c>EcoResReleaseProductToCompany</c> enumeration value.
    /// </summary>
    /// <param name="_value">
    /// A <c>EcoResReleaseProductToCompany</c> enumeration value that defines which child sub class should
    /// be instantiated
    /// </param>
    /// <returns>
    /// An instance of the <c>EcoResProductVariantCreationMgr</c> class.
    /// </returns>
    protected static EcoResProductVariantCreationMgr newFromReleaseProductToCompanyEnum(EcoResReleaseProductToCompany _value)
    {
        EcoResProductVariantCreationMgr productVariantCreationMgr;

        if (_value == EcoResReleaseProductToCompany::Yes)
        {
            productVariantCreationMgr = EcoResProductVariantPerCompanyMgr::construct();
        }
        else
        {
            productVariantCreationMgr = EcoResProductVariantCreationMgr::construct();
        }

        return productVariantCreationMgr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>