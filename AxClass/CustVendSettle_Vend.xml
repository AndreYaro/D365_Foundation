<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendSettle_Vend</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>CustVendSettle_Vend</c> class is used upon settling a vendor transaction from Open
///    Transaction Editing.
/// </summary>
public class CustVendSettle_Vend extends CustVendSettle
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createSettlementPair</Name>
				<Source><![CDATA[
    protected void createSettlementPair()
    {
        settlementPair = new SettlementPair_Vend();
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountLossProfit</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsoleted. Use accountRealizedGainLossFromPostingProfile() instead', false, 01\12\2022)]
    LedgerDimensionDefaultAccount accountLossProfit(Amount _exchRateDiff, CurrencyCode _currencyCode)
    {
        LedgerDimensionDefaultAccount defaultAccount;
        CurrencyGainLossAccountType   accountType;

        if (_exchRateDiff > 0)
        {
            accountType = CurrencyGainLossAccountType::RealizedGain;
        }
        else
        {
            accountType = CurrencyGainLossAccountType::RealizedLoss;
        }

        defaultAccount = CurrencyLedgerGainLossAccount::ledgerDimension(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            _currencyCode,
            accountType);

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNonrealLossProfit</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsoleted. Use accountUnrealizedGainLossFromPostingProfile() instead', false, 01\12\2022)]
    LedgerDimensionDefaultAccount accountNonrealLossProfit(Amount _exchRateDiff, CurrencyCode _currencyCode)
    {
        LedgerDimensionDefaultAccount defaultAccount;
        CurrencyGainLossAccountType   accountType;

        if (_exchRateDiff < 0)
        {
            accountType = CurrencyGainLossAccountType::UnrealizedGain;
        }
        else
        {
            accountType = CurrencyGainLossAccountType::UnrealizedLoss;
        }

        defaultAccount = CurrencyLedgerGainLossAccount::ledgerDimension(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            _currencyCode,
            accountType);

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountRealizedGainLossFromPostingProfile</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountRealizedGainLossFromPostingProfile(Amount _exchRateDiff, CurrencyCode _currencyCode, AccountNum _accountNum)
    {
        CurrencyGainLossAccountType accountType = _exchRateDiff > 0 ? CurrencyGainLossAccountType::RealizedGain : CurrencyGainLossAccountType::RealizedLoss;

        return this.getDefaultLedgerDimensionFromPostingProfile(
            _accountNum,
            accountType,
            _currencyCode,
            LedgerExchAdjPostingModule::AccountsPayable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountUnrealizedGainLossFromPostingProfile</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountUnrealizedGainLossFromPostingProfile(Amount _exchRateDiff, CurrencyCode _currencyCode, AccountNum _accountNum)
    {
        CurrencyGainLossAccountType accountType = _exchRateDiff < 0 ? CurrencyGainLossAccountType::UnrealizedGain : CurrencyGainLossAccountType::UnrealizedLoss;

        return this.getDefaultLedgerDimensionFromPostingProfile(
            _accountNum,
            accountType,
            _currencyCode,
            LedgerExchAdjPostingModule::AccountsPayable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>approvalVoucherDate</Name>
				<Source><![CDATA[
    protected container approvalVoucherDate(CustVendTrans _custVendTrans)
    {
        LedgerJournalVoucherChanged ledgerJournalVoucherChangedLocal;
        VendTrans                   vendTrans = _custVendTrans.data();

        if (vendTrans.JournalNum)
        {
            ledgerJournalVoucherChangedLocal = LedgerJournalVoucherChanged::findFromVoucherSkippingAccrual(vendTrans.JournalNum, vendTrans.Voucher);

            if (ledgerJournalVoucherChangedLocal.RecId
                && (ledgerJournalVoucherChangedLocal.ToVoucher != vendTrans.Voucher
                    || ledgerJournalVoucherChangedLocal.ToDate != vendTrans.TransDate))
            {
                return [ledgerJournalVoucherChangedLocal.ToVoucher, ledgerJournalVoucherChangedLocal.ToDate];
            }
        }
        return super(_custVendTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscMethod</Name>
				<Source><![CDATA[
    UnspecificSpecific cashDiscMethod()
    {
        return  VendParameters::find().CashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscVat</Name>
				<Source><![CDATA[
    boolean cashDiscVat()
    {
        return TaxCashDiscountParametersHelper::cashDiscInclTax(ModuleCustVend::Vend);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfCanBeSettled_RU</Name>
				<Source><![CDATA[
    protected boolean checkIfCanBeSettled_RU(TransDate  _settlementDate)
    {
        boolean ret = super(_settlementDate);

        if (ret)
        {
            ret = VendTrans::checkIfCanBeSettled_RU(settlementPair.getCustVendTransDebit(),
                                                    settlementPair.getCustVendTransCredit(),
                                                    _settlementDate,
                                                    offsetVoucher.parmDimSettlementType_RU());
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>crossCompanyTxt</Name>
				<Source><![CDATA[
    protected LedgerTransTxt crossCompanyTxt()
    {
        return LedgerTransTxt::VendCrossCompanySettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discTxtCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>CustCashDiscCust</c> enumeration value or <c>VendCashDiscVend</c> enumeration value
    /// respectively.
    /// </summary>
    /// <returns>
    /// An enumeration value.
    /// </returns>
    /// <remarks>
    /// The method is overridden in the derived methods.
    /// </remarks>
    LedgerTransTxt discTxtCustVend()
    {
        return LedgerTransTxt::VendCashDiscVend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discTxtLedger</Name>
				<Source><![CDATA[
    LedgerTransTxt discTxtLedger()
    {
        return LedgerTransTxt::VendCashDiscLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchAdjTxt</Name>
				<Source><![CDATA[
    LedgerTransTxt exchAdjTxt(LedgerJournalACType _ledgerJournalACType = LedgerJournalACType::Vend)
    {
        LedgerTransTxt  ledgerTransTxt;

        switch (_ledgerJournalACType)
        {
            case LedgerJournalACType::Ledger :
                ledgerTransTxt = LedgerTransTxt::VendExchAdjLedger;
                break;

            default :
                ledgerTransTxt = LedgerTransTxt::VendExchAdjVend;
        }
        return ledgerTransTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInvoice</Name>
				<Source><![CDATA[
    CustVendInvoiceJour findInvoice(
        CustVendAC  _custVendAC,
        InvoiceId   _invoiceId,
        Voucher     _voucher,
        TransDate   _transDate)
    {
        return VendInvoiceJour::findFromVendTransVoucher(_invoiceId, _voucher, _transDate, _custVendAC);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fineLedgerDimension_BR</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount fineLedgerDimension_BR(
        CustVendTrans       _custVendTrans,
        CustVendTransOpen   _custVendTransOpen,
        AmountCur           _fineAmount = 0)
    {
        LedgerDimensionDefaultAccount   ledgerDimension;
        boolean         accountExists;

        if (_custVendTransOpen.FineAmount_BR || _fineAmount)
        {
            changecompany(_custVendTrans.company())
            {
                ledgerDimension = VendLedgerAccounts::findFineAccount_BR(_custVendTrans.AccountNum,
                                                                         _custVendTrans.PostingProfile);
                if (ledgerDimension)
                {
                    // check if ledger account exists in the chart of accounts
                    accountExists = MainAccount::exist(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).RecId);

                    if (accountExists)
                    {
                        return ledgerDimension;
                    }

                    // it doesn't exist in chart of accounts use the system account
                    return this.fineSystemAccount_BR();
                }
            }
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fineSystemAccount_BR</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount fineSystemAccount_BR()
    {
        return LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::VendFine_BR);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fineTxtCustVend_BR</Name>
				<Source><![CDATA[
    public LedgerTransTxt fineTxtCustVend_BR()
    {
        return LedgerTransTxt::VendFine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendName_BR</Name>
				<Source><![CDATA[
    public str getCustVendName_BR(CustVendAC _accountNum)
    {
        return VendTable::find(_accountNum).name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_Balance</Name>
				<Source><![CDATA[
    public LedgerPostingType getLedgerPostingType_Balance()
    {
        return LedgerPostingType::VendBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_CashDisc</Name>
				<Source><![CDATA[
    public LedgerPostingType getLedgerPostingType_CashDisc()
    {
        return LedgerPostingType::VendCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_ExchRate</Name>
				<Source><![CDATA[
    public LedgerPostingType getLedgerPostingType_ExchRate(Amount _exchRateDiff)
    {
        return (_exchRateDiff > 0 ? LedgerPostingType::ExchRateGain : LedgerPostingType::ExchRateLoss);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_Settlement</Name>
				<Source><![CDATA[
    public LedgerPostingType getLedgerPostingType_Settlement()
    {
        return LedgerPostingType::VendSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendSettlementBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates either a <c>CustSettlement</c> record or a <c>VendSettlement</c> record.
    /// </summary>
    /// <returns>
    /// The <c>CustSettlement</c> or <c>VendSettlement</c> record.
    /// </returns>
    /// <remarks>
    /// This method is overridden in the derived methods.
    /// </remarks>
    CustVendSettlement initCustVendSettlementBuffer()
    {
        VendSettlement  vendSettlementBuffer;

        return vendSettlementBuffer.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendSettlementOffsetVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates a <c>VendSettlementOffsetVoucher</c>.
    /// </summary>
    /// <returns>
    ///    The new <c>VendSettlementOffsetVoucher</c> instance.
    /// </returns>
    protected CustVendSettlementOffsetVoucher initCustVendSettlementOffsetVoucher()
    {
        VendSettlementOffsetVoucher vendSettlementOffsetVoucher;

        return vendSettlementOffsetVoucher.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTransBuffer</Name>
				<Source><![CDATA[
    protected CustVendTrans initCustVendTransBuffer()
    {
        VendTrans  vendTransBuffer;

        return vendTransBuffer.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTransOpenBuffer</Name>
				<Source><![CDATA[
    protected CustVendTransOpen initCustVendTransOpenBuffer()
    {
        VendTransOpen  vendTransOpenBuffer;

        return vendTransOpenBuffer.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalNumCashDisc</Name>
				<Source><![CDATA[
    void initJournalNumCashDisc(CustVendTrans _custVendTrans)
    {
        VendTrans   vendTrans = _custVendTrans;
        vendTrans.JournalNum = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestLedgerDimension_BR</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount interestLedgerDimension_BR(
                                                CustVendTrans       _custVendTrans,
                                                CustVendTransOpen   _custVendTransOpen,
                                                AmountCur           _finInterestAmount = 0)
    {
        LedgerDimensionDefaultAccount ledgerDimension;
        boolean accountExists;

        if (_custVendTransOpen.InterestAmount_BR
                || _finInterestAmount)
        {
            changecompany(_custVendTrans.company())
            {
                ledgerDimension = VendLedgerAccounts::findInterestAccount_BR(_custVendTrans.AccountNum,
                                                                             _custVendTrans.PostingProfile);
                if (ledgerDimension)
                {
                    // check if ledger account exists in the chart of accounts
                    accountExists = MainAccount::exist(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).RecId);

                    if (accountExists)
                    {
                        return ledgerDimension;
                    }

                    // it doesn't exist in chart of accounts use the system account
                    return this.interestSystemAccount_BR();
                }
            }
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestSystemAccount_BR</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount interestSystemAccount_BR()
    {
        return LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::VendInterest);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestTxtCustVend_BR</Name>
				<Source><![CDATA[
    public LedgerTransTxt interestTxtCustVend_BR()
    {
        return LedgerTransTxt::VendInterest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSumAdjustOnAmountDiff_RU</Name>
				<Source><![CDATA[
    public void inventSumAdjustOnAmountDiff_RU(VendInvoiceTrans              _vendInvoiceTrans,
                                               AmountMST                     _amount,
                                               AmountMSTSecondary            _amountSec,
                                               Voucher                       _voucher,
                                               Voucher                       _invoiceVoucher,
                                               LedgerPostingType             _operationsPosting = LedgerPostingType::None,
                                               LedgerDimensionDefaultAccount _operationDefaultAccount = 0,
                                               LedgerVoucher                 _ledgerVoucher = null)
    {
        InventTransAdjust           inventTransAdjust       = InventTransAdjust::construct(max(settlementPair.getTransactionDate(), _vendInvoiceTrans.InventDate), _voucher);
        InventTransAdjustSecCur_RU  inventTransAdjustSecCur = InventTransAdjust::construct(max(settlementPair.getTransactionDate(), _vendInvoiceTrans.InventDate),
                                                                                           _voucher,
                                                                                           false,
                                                                                           InventTransCurrency_RU::SecondaryCur);
        InventAdjustAllocate        inventAdjustAllocate, inventAdjustAllocateSecCur;
        InventQty                   qty;
        InventTrans                 inventTrans;
        NoYes                       adjustInSecCur       = _vendInvoiceTrans.inventTable().modelGroup().PostOnhandFinancialSecCur_RU;
        InventTransOriginId         inventTransOriginId  = InventTransOrigin::findByInventTransId(_vendInvoiceTrans.InventTransId).RecId;

        qty = InventTransInvoice::qtyPurchased(inventTransOriginId,
                                               _vendInvoiceTrans.InvoiceId,
                                               _vendInvoiceTrans.InventDate);

        inventAdjustAllocate       = new InventAdjustAllocate(qty, - _amount);
        inventAdjustAllocateSecCur = new InventAdjustAllocate(qty, - _amountSec);

        while select forupdate inventTrans
            where  inventTrans.InventTransOrigin        == inventTransOriginId           &&
                   inventTrans.InvoiceId                == _vendInvoiceTrans.InvoiceId   &&
                   inventTrans.DateFinancial            == _vendInvoiceTrans.InventDate  &&
                   inventTrans.Voucher                  == _invoiceVoucher               &&
                   inventTrans.StatusReceipt            == StatusReceipt::Purchased      &&
                   inventTrans.StatusIssue              == StatusIssue::None             &&
                   inventTrans.PackingSlipReturned      == 0                             &&
                  ((_amount && !inventAdjustAllocate.isAllocated()) ||
                  (adjustInSecCur && _amountSec && !inventAdjustAllocateSecCur.isAllocated()))
        {
            if (_amount && !inventAdjustAllocate.isAllocated())
            {
                inventTransAdjust.updateNow(inventTrans,
                                            NoYes::No,
                                            NoYes::No,
                                            inventAdjustAllocate.calcAdjustment(inventTrans),
                                            true,
                                            _operationsPosting,
                                            LedgerDimensionFacade::serviceCreateLedgerDimension(_operationDefaultAccount),
                                            false,
                                            0,
                                            0,
                                            true,
                                            _ledgerVoucher);
            }

            if (_amountSec && adjustInSecCur && !inventAdjustAllocateSecCur.isAllocated())
            {
                inventTransAdjustSecCur.updateNow(inventTrans,
                                                  NoYes::No,
                                                  NoYes::No,
                                                  inventAdjustAllocateSecCur.calcAdjustment(inventTrans),
                                                  true,
                                                  _operationsPosting,
                                                  LedgerDimensionFacade::serviceCreateLedgerDimension(_operationDefaultAccount),
                                                  false,
                                                  0,
                                                  0,
                                                  true,
                                                  _ledgerVoucher);
            }
        }

        if ((_amount && !inventAdjustAllocate.isAllocated()) || (_amountSec && adjustInSecCur && !inventAdjustAllocateSecCur.isAllocated()))
        {
            throw error("@SYS15814");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalACType</Name>
				<Source><![CDATA[
    LedgerJournalACType ledgerJournalACType()
    {
        return LedgerJournalACType::Vend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerPostingType_W</Name>
				<Source><![CDATA[
    public LedgerPostingType ledgerPostingType_W()
    {
        return LedgerPostingType::VendPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxMSTDiff</Name>
				<Source><![CDATA[
    AmountCur maxMSTDiff()
    {
        return VendParameters::find().MaxMSTDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxPennyDiff</Name>
				<Source><![CDATA[
    AmountMST maxPennyDiff()
    {
        VendParameters   vendParameters;

        select firstonly MaxMSTDiff from vendParameters;

        return vendParameters.MaxMSTDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleCustVend</Name>
				<Source><![CDATA[
    protected ModuleCustVend moduleCustVend()
    {
        return ModuleCustVend::Vend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mstDiffTxtLedger</Name>
				<Source><![CDATA[
    LedgerTransTxt mstDiffTxtLedger()
    {
        return LedgerTransTxt::VendMSTDiffLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pennyDiffTxt</Name>
				<Source><![CDATA[
    LedgerTransTxt pennyDiffTxt()
    {
        return LedgerTransTxt::VendMSTDiffVend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postClosing</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates <c>LedgerTrans</c> records when the posting profile has a close profile.
    /// </summary>
    /// <param name="_vendTrans">
    ///    The <c>VendTrans</c> record that is used to create the records.
    /// </param>
    /// <param name="_postingDate">
    ///    The date the transaction was settled.
    /// </param>
    protected void postClosing(
        CustVendTrans _vendTrans,
        TransDate _postingDate)
    {
        VendTrans           vendTrans = _vendTrans;
        LedgerVoucher       ledgerVoucher;
        VendPostingProfile  postingProfileClose;

        LedgerDimensionDefaultAccount       fromLedgerDimension;
        LedgerDimensionDefaultAccount       toLedgerDimension;
        LedgerVoucherTransObject            ledgerVoucherTransObject;

        LedgerVoucherObject         ledgerVoucherObject;
        CurrencyExchangeHelper      exchangeRateHelper;
        LedgerDimensionAccount      mergedLedgerDimension;

        Debug::assert(vendTrans.company() == curext());

        postingProfileClose = VendLedger::find(vendTrans.PostingProfile).PostingProfileClose;

        if (postingProfileClose != '' && postingProfileClose != vendTrans.PostingProfile)
        {
            this.reverseAmounts(vendTrans);

            fromLedgerDimension     = VendLedgerAccounts::summaryLedgerDimension(vendTrans.AccountNum, vendTrans.PostingProfile);
            toLedgerDimension       = VendLedgerAccounts::summaryLedgerDimension(vendTrans.AccountNum, postingProfileClose);

            vendTrans.PostingProfileClose = postingProfileClose;

            if (fromLedgerDimension != toLedgerDimension)
            {
                ledgerVoucher = settlementPair.findOrCreateLedgerVoucherByCompany(vendTrans.company());
                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(fromLedgerDimension, vendTrans.DefaultDimension);

                exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                    Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                    ledgerVoucherObject.parmAccountingDate());

                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                        ledgerVoucher.findLedgerVoucherObject(),
                        LedgerPostingType::VendBalance,
                        mergedLedgerDimension,
                        vendTrans.CurrencyCode,
                        -vendTrans.AmountCur,
                        exchangeRateHelper);

                ledgerVoucherTransObject.parmSourceRecId(vendTrans.RecId);
                ledgerVoucherTransObject.parmSourceTableId(vendTrans.TableId);
                ledgerVoucherTransObject.parmTransTxt('');
                ledgerVoucherTransObject.parmDiscardLastTransTxt(true);

                ledgerVoucher.addTrans(ledgerVoucherTransObject);

                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(toLedgerDimension, vendTrans.DefaultDimension);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                        ledgerVoucher.findLedgerVoucherObject(),
                        LedgerPostingType::VendBalance,
                        mergedLedgerDimension,
                        vendTrans.CurrencyCode,
                        vendTrans.AmountCur,
                        exchangeRateHelper);

                ledgerVoucherTransObject.parmSourceRecId(vendTrans.RecId);
                ledgerVoucherTransObject.parmSourceTableId(vendTrans.TableId);
                ledgerVoucherTransObject.parmTransTxt('');
                ledgerVoucherTransObject.parmDiscardLastTransTxt(true);

                ledgerVoucher.addTrans(ledgerVoucherTransObject);

                // <GEERU>
                if (_vendTrans.AmountCur)
                {
                    ledgerVoucher.bondLast2_RU();
                }
                // </GEERU>
                vendTrans.PostingChangeVoucher = ledgerVoucher.lastVoucher();
                vendTrans.Closed = CustVendTransData::construct(vendTrans).maxSettlementDate(_postingDate);
            }
            this.reverseAmounts(vendTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeFine_BR</Name>
				<Source><![CDATA[
    public  LedgerPostingType postingTypeFine_BR()
    {
        return LedgerPostingType::VendFine_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeInterest_BR</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeInterest_BR()
    {
        return LedgerPostingType::VendInterest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVATTransit_RU</Name>
				<Source><![CDATA[
    protected Voucher postVATTransit_RU(
        AmountMST           _settleAmountAccounting,
        AmountCur           _settleAmountTransaction,
        AmountMSTSecondary  _settleAmountReporting,
        CustVendTrans       _trans,
        NoYes               _correction = NoYes::No)
    {
        Voucher ret;

        if (TaxParameters::find().IncomingVATPayment_RU)
        {
            this.reverseAmounts(_trans);

            ret = super(
                -_settleAmountAccounting,
                -_settleAmountTransaction,
                -_settleAmountReporting,
                _trans,
                _correction);

            this.reverseAmounts(_trans);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVATTransitAmountDiff_RU</Name>
				<Source><![CDATA[
    public void postVATTransitAmountDiff_RU(CustVendTrans _custVendTrans,
                                            boolean       _useSourceRecId  = true,
                                            LedgerVoucher _ledgerVoucher   = settlementPair.findLedgerVoucherByCompany(_custVendTrans.company()))
    {
        VendSettleVATTransit_AmountDiff_RU transit;

        if (TaxParameters::find().IncomingVATPayment_RU)
        {
            transit = VendSettleVATTransit_AmountDiff_RU::construct();
            this.reverseAmounts(_custVendTrans);

            transit.initFromSettlement(_custVendTrans,
                                       _ledgerVoucher.findLedgerVoucherObject(),
                                       _custVendTrans.AmountMST,
                                       _custVendTrans.AmountCur,
                                       _custVendTrans.ReportingCurrencyAmount,
                                       this);

            transit.calcAndPostTaxes(_useSourceRecId);

            this.reverseAmounts(_custVendTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseAmounts</Name>
				<Source><![CDATA[
    void reverseAmounts(CustVendTrans _vendTrans)
    {
        SettlementUtility::reverseTransAmounts(_vendTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTransOpenAmounts</Name>
				<Source><![CDATA[
    void reverseTransOpenAmounts(CustVendTransOpen _vendTransOpen)
    {
        SettlementUtility::reverseTransOpenAmounts(_vendTransOpen);
    }

]]></Source>
			</Method>
			<Method>
				<Name>settlementControl</Name>
				<Source><![CDATA[
    protected void settlementControl()
    {
        VendTrans   vendTrans;
        boolean overSettlementFound;
        Voucher overSettlementVoucher;

        while (custVendTransSettlementControl.next(vendTrans))
        {
            if (vendTrans.AmountCur > 0)
            {
                if ((vendTrans.SettleAmountCur < 0) ||
                    (vendTrans.SettleAmountCur > vendTrans.AmountCur))
                {
                    overSettlementFound = true;
                    overSettlementVoucher = vendTrans.Voucher;
                    break;
                }
            }

            if (vendTrans.AmountCur < 0)
            {
                if ((vendTrans.SettleAmountCur > 0) ||
                    (vendTrans.SettleAmountCur < vendTrans.AmountCur))
                {
                    overSettlementFound = true;
                    overSettlementVoucher = vendTrans.Voucher;
                    break;
                }
            }
        }

        if (overSettlementFound)
        {
            throw error(strFmt("@SYS119352", overSettlementVoucher));
        }

        this.validateDiffVendAccount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDiffVendAccount</Name>
				<Source><![CDATA[
    private void validateDiffVendAccount()
    {
        VendTrans vendTrans;
        AccountNum settleAccountNum;
        DataAreaId settleDataAreaId;
        Voucher settleVoucher;
        boolean diffAccountNumFound;

        boolean found = custVendTransSettlementControl.first(vendTrans);
        while (found)
        {
            if (!settleAccountNum)
            {
                settleAccountNum = vendTrans.AccountNum;
                settleDataAreaId = vendTrans.DataAreaId;
                settleVoucher = vendTrans.Voucher;
            }
            else if (settleAccountNum != vendTrans.AccountNum && !VendTable::isSameVendor(settleAccountNum, settleDataAreaId, vendTrans.AccountNum, vendTrans.dataAreaId))
            {
                diffAccountNumFound = true;
                break;
            }

            found = custVendTransSettlementControl.next(vendTrans);
        }

        if (diffAccountNumFound)
        {
            throw error(strfmt("@CashManagement:DiffAccountNumSettleError", vendTrans.AccountNum, vendTrans.Voucher, settleAccountNum, settleVoucher));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAdvanceDefinition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the <c>PurchPrepayTable</c> table to update advance application remaining.
    /// </summary>
    /// <param name="_custVendTrans">
    /// A <c>CustVendTrans</c> record.
    /// </param>
    /// <param name="settleAmountCur">
    /// An amount to update in advance application remaining amount.
    /// </param>
    protected void updateAdvanceDefinition(CustVendTrans  _custVendTrans, AmountCur settleAmountCur)
    {
        PurchPrepayTable::updateAdvanceApplicationRemaining(_custVendTrans, settleAmountCur);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>CashDiscDate</c> field on the <c>VendTransOpen</c> records that will be settled.
    /// </summary>
    /// <param name="_company">
    ///    The spec company of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_tableId">
    ///    The spec table ID of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_recId">
    ///    The spec record ID of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <remarks>
    ///    This method sets the <c>CashDiscDate</c> field to the <c>DueDate</c> field when the
    ///    <c>PossibleCashDiscount</c> field is zero and <c>AmountCur</c> field is greater than zero.
    /// </remarks>
    protected void updateCashDiscDate(
        CompanyId _company,
        tableId _tableId,
        recId _recId)
    {
        SpecTrans specTrans;

        while select crossCompany RefCompany from specTrans group by RefCompany
            where specTrans.SpecCompany == _company
                && specTrans.SpecTableId == _tableId
                && specTrans.SpecRecId == _recId
        {
            changecompany(specTrans.RefCompany)
            {
                SpecTrans refCompanySpecTrans;

                VendTransOpen vendTransOpenLocal;
                vendTransOpenLocal.skipDatabaseLog(true);
                vendTransOpenLocal.skipDataMethods(true);
                vendTransOpenLocal.skipEvents(true);

                update_recordset vendTransOpenLocal
                    setting CashDiscDate = vendTransOpenLocal.DueDate
                        where vendTransOpenLocal.AmountCur < 0
                           && vendTransOpenLocal.PossibleCashDisc == 0
                           && vendTransOpenLocal.CashDiscDate != vendTransOpenLocal.DueDate
                   exists join refCompanySpecTrans
                        where  refCompanySpecTrans.SpecCompany == _company
                           && refCompanySpecTrans.SpecTableId == _tableId
                           && refCompanySpecTrans.SpecRecId == _recId
                           && vendTransOpenLocal.TableId == refCompanySpecTrans.RefTableId
                           && vendTransOpenLocal.RecId == refCompanySpecTrans.RefRecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransaction_W</Name>
				<Source><![CDATA[
    public CustVendSettlement updateTransaction_W(
        CustVendTrans     _vendTrans,
        CustVendTransOpen _vendTransOpen,
        DiscAmount        _utilizedCashDisc   = 0,
        PennyDiff         _pennyDiff          = 0,
        NoYes             _canBeReversed      = NoYes::No,
        boolean           _setOffsetRecId     = false,
        boolean           _update             = false,
        Voucher           _taxVoucher         = '',
        boolean           _isGroupSettlement  = true,
        RecId             _offsetRecID        = 0)
    {
        CustVendSettlement  custVendSettlement;
        VendTransData       vendTransData;

        changecompany(_vendTrans.company())
        {
            this.reverseAmounts(_vendTrans);
            _utilizedCashDisc = - _utilizedCashDisc;

            vendTransData = _vendTrans.transData();
            vendTransData.parmIsGroupSettlement_W(_isGroupSettlement);

            custVendSettlement = vendTransData.updateSettlement(_vendTransOpen,
                                                                _utilizedCashDisc,
                                                                _pennyDiff,
                                                                _canBeReversed,
                                                                _setOffsetRecId,
                                                                _update,
                                                                _vendTrans.DefaultDimension,
                                                                max(_vendTrans.TransDate, _vendTrans.LastExchAdj),
                                                                _taxVoucher,
                                                                _offsetRecID);

            this.updateTransOpen(_vendTrans, _vendTransOpen);
            _vendTrans.update();
            this.reverseAmounts(_vendTrans);
        }

        return custVendSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionProject</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsolete. Use updateTransactionProjectV2() instead.', false, 01\06\2022)]
    void updateTransactionProject(CustVendTrans _vendTrans, AmountMST _remainDebitCur, AmountMST _settleAmountCur)
    {
        this.updateTransactionProjectV2(_vendTrans, _remainDebitCur, _settleAmountCur);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionProjectV2</Name>
				<Source><![CDATA[
    public void updateTransactionProjectV2(CustVendTrans _vendTrans, AmountCur _remainDebitCur, AmountCur _settleAmountCur)
    {
        // If from Project
        if (_vendTrans.InvoiceProject == NoYes::Yes)
        {
            VendInvoiceJour vendInvoiceJour = vendInvoiceJour::findFromVendTransVoucher(_vendTrans.Invoice,
                                                                        _vendTrans.Voucher,
                                                                        _vendTrans.TransDate,
                                                                        _vendTrans.AccountNum);

            // Compare the amount
            if (_remainDebitCur != _settleAmountCur)
            {
                real percentagePayment;
                // In multiple settlement case, amount should be fetched from <c>ProjTransPosting</c> to get the correct remaining amount.
                ProjTransPosting projTransPosting;
                select firstonly RecId, AmountMST from projTransPosting
                    where projTransPosting.Voucher == _VendTrans.Voucher
                        && projTransPosting.PaymentStatus == ProjPaymentStatus::ExpectedPayment;
                                           
                if (projTransPosting.RecId && projTransPosting.AmountMst != 0)
                {
                    Amount remainDebitAmount = projTransPosting.AmountMst;

                    if (_VendTrans.CurrencyCode != Ledger::accountingCurrency())
                    {
                        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), systemDateGet());
                        remainDebitAmount = currencyExchangeHelper.calculateAccountingToTransaction(_VendTrans.CurrencyCode, remainDebitAmount, true);
                    }

                    percentagePayment = _settleAmountCur/remainDebitAmount;
                }

                if (percentagePayment < 1)
                {
                    // partial payment
                    CustVoucher::updateProjTransPosting(_vendTrans.LastSettleDate, _vendTrans.Voucher,
                                ProjPaymentStatus::Paid, true, percentagePayment);

                    // Some transactions have cost voucher instead of vendor voucher
                    if (vendInvoiceJour
                        && vendInvoiceJour.CostLedgerVoucher
                        && vendInvoiceJour.CostLedgerVoucher != _vendTrans.Voucher)
                    {
                        CustVoucher::updateProjTransPosting(_vendTrans.LastSettleDate, vendInvoiceJour.CostLedgerVoucher,
                                ProjPaymentStatus::Paid, true, percentagePayment);
                    }
                }
                else
                {
                    // full payment. update the ProjTransposting payment date and payment status
                    CustVoucher::updateProjTransPosting(_vendTrans.LastSettleDate, _vendTrans.Voucher, ProjPaymentStatus::Paid);

                    if (vendInvoiceJour
                        && vendInvoiceJour.CostLedgerVoucher
                        && vendInvoiceJour.CostLedgerVoucher != _vendTrans.Voucher)
                    {
                        CustVoucher::updateProjTransPosting(_vendTrans.LastSettleDate, vendInvoiceJour.CostLedgerVoucher, ProjPaymentStatus::Paid);
                    }
                }
            }
            else
            {
                // full payment. update the ProjTransposting payment date and payment status
                CustVoucher::updateProjTransPosting(_vendTrans.LastSettleDate, _vendTrans.Voucher, ProjPaymentStatus::Paid);

                if (vendInvoiceJour
                    && vendInvoiceJour.CostLedgerVoucher
                    && vendInvoiceJour.CostLedgerVoucher != _vendTrans.Voucher)
                {
                    CustVoucher::updateProjTransPosting(_vendTrans.LastSettleDate, vendInvoiceJour.CostLedgerVoucher, ProjPaymentStatus::Paid);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionReverseExchAdj_W</Name>
				<Source><![CDATA[
    public CustVendSettlement updateTransactionReverseExchAdj_W(
        CustVendTrans      _vendTrans,
        CustVendTransOpen  _vendTransOpen,
        DiscAmount         _utilizedCashDisc  = 0,
        boolean            _isGroupSettlement = true)
    {
        CustVendSettlement  custVendSettlement;
        VendTrans           vendTrans                   = _vendTrans;
        AmountMST           tmpSettleAmountMst          = vendTrans.SettleAmountMST;
        AmountCur           tmpSettleAmountCur          = vendTrans.SettleAmountCur;
        AmountMSTSecondary  tmpSettleAmountMSTSec       = vendTrans.SettleAmountReporting;
        VendTrans           tmpVendTrans                = vendTrans.orig().data();
        TransDate           tmpLastExchAdj              = vendTrans.LastExchAdj;
        VendTransData       vendTransData               = vendTrans.transData();

        this.reverseAmounts(vendTrans);

        vendTrans.SettleAmountMST          = tmpVendTrans.SettleAmountMST;
        vendTrans.SettleAmountCur          = tmpVendTrans.SettleAmountCur;
        vendTrans.SettleAmountReporting    = tmpVendTrans.SettleAmountReporting;
        vendTrans.LastExchAdj              = settlementPair.getTransactionDate();

        _utilizedCashDisc = - _utilizedCashDisc;

        vendTransData.parmIsGroupSettlement_W(_isGroupSettlement);
        custVendSettlement = vendTransData.updateSettlement(_vendTransOpen, _utilizedCashDisc);
        this.updateTransOpen(vendTrans, _vendTransOpen);

        vendTrans.LastExchAdj = tmpLastExchAdj;
        vendTrans.update();

        this.reverseAmounts(vendTrans);

        vendTrans.SettleAmountMST          = tmpSettleAmountMst;
        vendTrans.SettleAmountCur          = tmpSettleAmountCur;
        vendTrans.SettleAmountReporting    = tmpSettleAmountMSTSec;

        return custVendSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransFor1099</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the 1099 tax amount fields on the debit and credit transaction.
    /// </summary>
    /// <param name="_invoiceAmountCurDebit">
    ///    The original amount on the invoice.
    /// </param>
    /// <param name="_settleAmountCurDebit">
    ///    The calculated settlement debit amount for this transaction.
    /// </param>
    /// <param name="_discountAmountCurDebit">
    ///    The calculated settlement debit discount amount for this transaction.
    /// </param>
    protected void updateTransFor1099(  AmountCur _invoiceAmountCurDebit,
                                        AmountCur _settleAmountCurDebit,
                                        AmountCur _discountAmountCurDebit)
    {
        boolean lateReporting;
        #define.LateReportingDays(30)

        // Check is 1099 vendor
        if (settlementPair.getCustVendTransDebit().Tax1099Fields != 0)
        {
            // If the settlement date is 30 days past the invoice date
            if ((settlementPair.getCustVendTransDebit().TransDate + #LateReportingDays) < settlementPair.getTransactionDate())
            {
                // Set late reporting only if Tax1099Type is OID
                if (Tax1099Fields::find(settlementPair.getCustVendTransDebit().Tax1099Fields).Tax1099Type == Tax1099Type::F1099OID)
                {
                    lateReporting = true;
                }
            }

            vendTax1099Manager.calcSettleTax1099Amount(
                _invoiceAmountCurDebit,
                _settleAmountCurDebit,
                _discountAmountCurDebit,
                settlementPair.getExchRate().getPaymentToInvoice(),
                lateReporting);

            settlementPair.getCustVendTransCredit().SettleTax1099Amount += vendTax1099Manager.parmCreditTax1099Amount();            // update total settled credit amount for 1099
            settlementPair.getCustVendTransCredit().SettleTax1099StateAmount += vendTax1099Manager.parmCreditTax1099StateAmount();  // update total settled credit amount for 1099

            settlementPair.getCustVendTransOpenCredit().Tax1099Amount += vendTax1099Manager.parmCreditTax1099Amount();              // Total open credits
            settlementPair.getCustVendTransOpenCredit().Tax1099StateAmount += vendTax1099Manager.parmCreditTax1099StateAmount();    // Total open credits

            settlementPair.getCustVendTransDebit().SettleTax1099Amount -= vendTax1099Manager.parmDebitTax1099Amount();              // update total settled debit amount for 1099
            settlementPair.getCustVendTransDebit().SettleTax1099StateAmount -= vendTax1099Manager.parmDebitTax1099StateAmount();    // update total settled debit amount for 1099

            settlementPair.getCustVendTransOpenDebit().Tax1099Amount += vendTax1099Manager.parmDebitTax1099Amount();                // Total open debits
            settlementPair.getCustVendTransOpenDebit().Tax1099StateAmount += vendTax1099Manager.parmDebitTax1099StateAmount();      // Total open debits
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>CustVendTransOpen</c> table in the database for the specified data.
    /// </summary>
    /// <param name="_custVendTrans">
    ///    The <c>CustVendTrans</c> record associated with the <c>CustVendTransOpen</c> record.
    /// </param>
    /// <param name="_custVendTransOpen">
    ///    The <c>CustVendTransOpen</c> record to update.
    /// </param>
    public void updateTransOpen(CustVendTrans _custVendTrans, CustVendTransOpen _custVendTransOpen)
    {
        boolean recordDeleted;
        VendTransOpen custTransOpenToDelete;
        boolean countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);

        if ((!countryRegion_RUCZ && _custVendTransOpen.RecId) ||
             (countryRegion_RUCZ && VendTransOpen::exist(_custVendTransOpen.RecId)))
        {
            this.reverseTransOpenAmounts(_custVendTransOpen);

            _custVendTransOpen.update();

            if (_custVendTransOpen.AmountCur == 0 && _custVendTransOpen.AmountMST == 0)
            {
                // Balance is zero, the custVendTransSettlement manager will delete the transaction open record when
                // the post method is called.  Don't want to do the delete at this point because the CustVendTransCashDisc
                // records associated with the custTransOpen have to be moved to the settlement record and the settlement
                // record isn't created until the post method is called.
                recordDeleted = custVendTransSettlement.markCustVendTransOpenForDelete(_custVendTransOpen.RecId, _custVendTrans, settlementGroupPlaceHolder);

                if (!recordDeleted)
                {
                    // This will handle case where there isn't a settlement for record to be
                    // deleted, so just delete it here.
                    select firstonly RecId from custTransOpenToDelete
                        where custTransOpenToDelete.TableId == _custVendTransOpen.TableId
                           && custTransOpenToDelete.RecId == _custVendTransOpen.RecId;

                    if (custTransOpenToDelete.RecId)
                    {
                        _custVendTransOpen.delete();
                    }
                }
            }
            this.reverseTransOpenAmounts(_custVendTransOpen);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendSettlementTax1099</Name>
				<Source><![CDATA[
    protected void updateVendSettlementTax1099(AmountCur _settleAmountCur, ExchRate _paymToInvoiceRate)
    {
        /*  The purpose of this method is to record the payments per invoice line for 1099 purposes.  The reason is that Axapta
            allows you to specify a different box per line and now you can also specify a different amount for 1099 versus the line
            amount.  Therefore, we need to record for each payment the date and amount per invoice to get an accurate amount to report
            to the IRS.

            This method calculate the line amount by using the following formula:
            Federal:  Invoice 1099 line amount / (Total amount for the invoice / payment amount)
            State:  Invoice 1099 state line amount / (Total amount for the invoice / payment amount)
        */

        Debug::assert(settlementPair.getDebitCompany() == curext());

        this.reverseAmounts(settlementPair.getCustVendTransDebit());
        this.reverseAmounts(settlementPair.getCustVendTransCredit());

        vendTax1099Manager.updateVendSettlementTax1099(_settleAmountCur, settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransCredit(), _paymToInvoiceRate);

        this.reverseAmounts(settlementPair.getCustVendTransDebit());
        this.reverseAmounts(settlementPair.getCustVendTransCredit());
    }

]]></Source>
			</Method>
			<Method>
				<Name>useInvoiceLineAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to use the invoice line account or
    /// cash discount account for discount posting.
    /// </summary>
    /// <param name="_cashDiscCode">
    /// The cash discount code used in the invoice.
    /// </param>
    /// <returns>
    /// true if the invoice line account should be used; otherwise, false.
    /// </returns>
    protected boolean useInvoiceLineAccount(CashDiscCode _cashDiscCode)
    {
        CashDisc cashDisc = CashDisc::find(_cashDiscCode);

        return (cashDisc.DiscountOffsetMethod_PSN == DiscountOffsetMethod::InvoiceAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAmountsToReverseForLastSettlement_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount and tax base amount to be reversed for other settled transactions in the same settled group.
    /// </summary>
    /// <param name="_custVendSettlementLatest">
    /// Latest settlement record.
    /// </param>
    /// <param name="_custVendTransDebit">
    /// Invoice transactions (VendTrans - Invoices).
    /// </param>
    /// <param name="_voucher">
    /// Voucher number to fetch the tax transaction record.
    /// </param>
    /// <param name="_transDate">
    /// Trans date to fetch the tax transaction record.
    /// </param>
    /// <returns>
    /// A container with tax amount and tax base amount to be reversed.
    /// </returns>
    protected container getAmountsToReverseForLastSettlement_TH(CustVendSettlement _custVendSettlementLatest,  CustVendTrans _custVendTransDebit, Voucher _voucher, TransDate _transDate)
    {
        VendSettlement vendSettlement;
        VendTrans vendTrans;
        DiscAmount discount;
        TaxTrans taxTrans;
        TaxWithholdTrans taxWithholdTrans;
        TaxAmountCur taxAmountToBeReversed;
        TaxBaseCur taxBaseAmountToBeReversed;        

        vendTrans = _custVendTransDebit;
        discount = vendTrans.displayDiscountUsed();

        taxTrans = TaxTrans::find(_voucher, _transDate);

        while select SettleAmountCur from vendSettlement
            where vendSettlement.offsetRecId == _custVendSettlementLatest.offsetRecId
               && vendSettlement.RecId !=  _custVendSettlementLatest.RecId
            notExists join taxWithholdTrans
            where taxWithholdTrans.SettlementVoucher == vendSettlement.SettlementVoucher
        {
            taxAmountToBeReversed += CurrencyExchangeHelper::amount(vendSettlement.SettleAmountCur / abs(_custVendTransDebit.AmountCur - discount) * taxTrans.totalTaxAmountCur());

            //To calculate the taxBase amount based on what percent of invoice amount is getting settled through this settlement transaction.
            //we are using the below approach.
            //(CurrentSettlementFactor - originalSettledPercent * taxBaseAmount)
            taxBaseAmountToBeReversed += CurrencyExchangeHelper::amount(((_custVendTransDebit.SettleAmountCur / _custVendTransDebit.AmountCur)-
                ((_custVendTransDebit.SettleAmountCur - discount + vendSettlement.SettleAmountCur) /
                (_custVendTransDebit.AmountCur - discount))) * taxTrans.SourceBaseAmountCur);
        }

        return [taxAmountToBeReversed, taxBaseAmountToBeReversed];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLatestSettlement_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the given settlement is the last settlement.
    /// </summary>
    /// <param name="_vendSettlement">
    /// Current settlement record.
    /// </param>
    /// <returns>
    /// true if the current record is the lastest settlement; otherwise, false.
    /// </returns>
    protected boolean isLatestSettlement_TH(VendSettlement _vendSettlement)
    {
        VendSettlement  vendSettlementLocal;

        select firstOnly RecId from vendSettlementLocal
           order by RecId desc
            where vendSettlementLocal.OffsetRecid == _vendSettlement.OffsetRecid;

        return vendSettlementLocal.RecId == _vendSettlement.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustOffsetOriginalSummaryDistributions</Name>
				<Source><![CDATA[
    protected boolean mustOffsetOriginalSummaryDistributions(boolean _debitHasMultipleSummaryEntries, boolean _creditHasMultipleSummaryEntries)
    {
        // Do not create a correction for summary distributions when one side is an invoice pool
        // In that case, we know they are different, but will be fixed by the final invoice
        LedgerJournalTable invoicePoolJournal = LedgerJournalTable::findVendorInvoicePool(false);
        VendTrans vendTransCredit = settlementPair.getCustVendTransCredit();
        VendTrans vendTransDebit = settlementPair.getCustVendTransDebit();

        if (invoicePoolJournal && ((vendTransCredit.JournalNum == invoicePoolJournal.JournalNum) || (vendTransDebit.JournalNum == invoicePoolJournal.JournalNum)))
        {
            return false;
        }

        return super(_debitHasMultipleSummaryEntries, _creditHasMultipleSummaryEntries);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>