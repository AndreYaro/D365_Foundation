<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>EcoResStorageDimGroupSetupCache</Name>
	<SourceCode>
		<Declaration><![CDATA[
class EcoResStorageDimGroupSetupCache
{
    #Define.ActiveKey('Active')
    #Define.ConsistentKey('Consistent')
    #Define.MandatoryKey('Mandatory')
    #Define.PrimaryKey('Primary')
    #Define.FinancialInventoryKey('FinancialInventory')
    #Define.PhysicalInventoryKey('PhysicalInventory')
    #Define.CoveragePlanByDimensionKey('CoveragePlanByDimension')
    #Define.PurchPriceKey('PurchPrice')
    #Define.SalesPriceKey('SalesPrice')
    #Define.ActiveAllGroupKey('ActiveAllGroup')
    #Define.ActivePhysicalAllGroupKey('ActivePhysicalAllGroup')
    #Define.AllPriceDiscKey('AllPriceDisc')
    #Define.AllCovKey('AllCovDisc')
    #Define.AllMandatoryKey('AllMandatoryDisc')
    #define.NotAllowBlankReceipt('NotAllowBlankReceipt')
    #define.NotAllowBlankIssue('NotAllowBlankIssue')
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
        protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>active</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    A value that specifies the storage dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm active(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#ActiveKey, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>classScope</Name>
				<Source><![CDATA[
        private static GlobalObjectCacheScope classScope()
    {
        return classStr(EcoResStorageDimGroupSetupCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCache</Name>
				<Source><![CDATA[
        public static void clearCache()
    {
        if (xGlobal::hasClient())
        {
            EcoResStorageDimGroupSetupCache::clearCacheClient();
        }
        EcoResStorageDimGroupSetupCache::clearCacheServer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheClient</Name>
				<Source><![CDATA[
        private static void clearCacheClient()
    {
        classfactory.globalObjectCache().clear(EcoResStorageDimGroupSetupCache::classScope());
        InventDimGroupSetup::clearCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheServer</Name>
				<Source><![CDATA[
        private static void clearCacheServer()
    {
        classfactory.globalObjectCache().clear(EcoResStorageDimGroupSetupCache::classScope());
        InventDimGroupSetup::clearCache();
        SalesPurchLineInterface::flushPriceDiscCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>consistent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and to be considered as consistent
    ///    dimensions.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    A value that specifies the storage dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm consistent(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#ConsistentKey, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
        public static EcoResStorageDimGroupSetupCache construct()
    {
        return new EcoResStorageDimGroupSetupCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>coveragePlanByDimensionEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about the dimensions that are active and marked to be included when doing
    ///    master planning.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    Specifies the storage dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm coveragePlanByDimensionEnabled(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#CoveragePlanByDimensionKey, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialInventoryEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and marked as being part of financial
    ///    inventory.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    Specifies the storage dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm financialInventoryEnabled(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#FinancialInventoryKey, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCachedInventDimParm</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a cached record.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    The storage dimension group for which to get the record.
    /// </param>
    /// <param name="_key">
    ///    The key into the global cache.
    /// </param>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer.
    /// </returns>
    static protected InventDimParm getCachedInventDimParm(
        EcoResStorageDimensionGroupRecId    _storageDimensionGroup,
        container                           _key)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResStorageDimGroupSetupCache::classScope();
        container               packedRecordCache       = conNull();
        InventDimParm           inventDimParm;

        if (!_storageDimensionGroup)
        {
            return inventDimParm;
        }

        while (packedRecordCache == conNull())
        {
            packedRecordCache = sysGlobalObjectCache.find(classScope , _key);
            if (!packedRecordCache || conLen(packedRecordCache) == 0)
            { // Not cached yet
                EcoResStorageDimGroupSetupCache::initStorageDimGroupCache(_storageDimensionGroup);  // This will always initialize the cache.
                packedRecordCache = sysGlobalObjectCache.find(classScope , _key);                   // but the cache could be cleared by other processes, so finding an entry isn't guaranteed.
            }
        }

        [inventDimParm] = packedRecordCache;
        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldSetup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds an instance of the <c>InventDimGroupFieldSetup</c> class that matches the specified dimension field.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    Specifies the storage dimension group for which information is to be retrieved.
    /// </param>
    /// <param name="_dimFieldId">
    ///    The field ID of the inventory dimension field.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventDimGroupFieldSetup</c> class.
    /// </returns>
    static public InventDimGroupFieldSetup getFieldSetup(
        EcoResStorageDimensionGroupRecId    _storageDimensionGroup,
        FieldId                             _dimFieldId)
    {
        if (!_dimFieldId || !_storageDimensionGroup || !InventDim::isFieldIdStorageDimension(_dimFieldId))
        {
            return InventDimGroupFieldSetup::newNoValidField();
        }

        EcoResStorageDimensionGroupFldSetup ecoResStorageDimensionGroupFldSetup = EcoResStorageDimensionGroupFldSetup::findByDimensionGroupFieldId(_storageDimensionGroup, _dimFieldId);
        ecoResStorageDimensionGroupFldSetup.DimensionFieldId = _dimFieldId; // Ensure that dimension field is still specified even if not found
        return InventDimGroupFieldSetup::newEcoResStorageDimensionGroupFldSetup(ecoResStorageDimensionGroupFldSetup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllActiveDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about the dimensions that are active.
    /// </summary>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value for active
    ///    dimension.
    /// </returns>
    /// <remarks>
    ///    Information is gathered from all storage dimensions in the system. It is enough that a dimension is
    ///    active in just one storage dimension group to be returned as active dimension.
    /// </remarks>
    static protected InventDimParm initInventDimParmInitAllActiveDim()
    {
        EcoResStorageDimensionGroup             ecoResStorageDimensionGroup;
        InventDimParm                           inventDimParmInitAllActiveDim;

        while select RecId from ecoResStorageDimensionGroup
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResStorageDimGroupSetup::newDimensionGroup(ecoResStorageDimensionGroup.RecId).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

                if (inventDimGroupFieldSetup.isActive())
                {
                    FieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                    FieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                    inventDimParmInitAllActiveDim.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        return inventDimParmInitAllActiveDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllActivePhysDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about the dimensions that are active and physical.
    /// </summary>
    /// <returns>
    ///     A <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value
    ///     for active and physical storage dimension.
    /// </returns>
    /// <remarks>
    ///    Information is gathered from all storage dimension groups in the system. It is enough that a
    ///    dimension is active and physical in just one storage dimension group to be returned as active and physical.
    /// </remarks>
    static protected InventDimParm initInventDimParmInitAllActivePhysDim()
    {
        EcoResStorageDimensionGroup             ecoResStorageDimensionGroup;
        InventDimParm                           inventDimParmInitAllActivePhysDim;

        while select RecId from ecoResStorageDimensionGroup
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResStorageDimGroupSetup::newDimensionGroup(ecoResStorageDimensionGroup.RecId).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

                if (inventDimGroupFieldSetup.isActive() && inventDimGroupFieldSetup.isPhysicalInventoryEnabled())
                {
                    FieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                    FieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                    inventDimParmInitAllActivePhysDim.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        return inventDimParmInitAllActivePhysDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllCovDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about the dimensions that are marked as part of master planning.
    /// </summary>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value for
    ///    dimensions with master planning is enabled.
    /// </returns>
    /// <remarks>
    ///     Information is gathered from all storage dimensions in the system. It is enough that a dimension
    ///    is active and have the dimension marked in just one storage dimension group.
    /// </remarks>
    static protected InventDimParm initInventDimParmInitAllCovDim()
    {
        EcoResStorageDimensionGroup             ecoResStorageDimensionGroup;
        InventDimParm                           inventDimParmInitAllCovDim;

        while select RecId from ecoResStorageDimensionGroup
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResStorageDimGroupSetup::newDimensionGroup(ecoResStorageDimensionGroup.RecId).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

                if (inventDimGroupFieldSetup.isActive() && inventDimGroupFieldSetup.isCoveragePlanByDimensionEnabled())
                {
                    FieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                    FieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                    inventDimParmInitAllCovDim.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        return inventDimParmInitAllCovDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllMandatoryDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are marked as mandatory dimensions.Information is gathered
    ///    from all storage dimension groups in the system. It is enough that a dimension is active and marked
    ///    as mandatory in just one storage dimension group to be returned as Mandatory enabled.
    /// </summary>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value for
    ///    dimensions with the <c>Mandatory</c> field enabled.
    /// </returns>
    static protected InventDimParm initInventDimParmInitAllMandatoryDim()
    {
        EcoResStorageDimensionGroup             ecoResStorageDimensionGroup;
        InventDimParm                           inventDimParmInitAllMandatoryDim;

        inventDimParmInitAllMandatoryDim.clear();
        inventDimParmInitAllMandatoryDim.InventSiteIdFlag   = NoYes::Yes;   // Site is always active and mandatory

        select firstonly RecId from ecoResStorageDimensionGroup
            where ecoResStorageDimensionGroup.IsWarehouseMandatoryEnabled   == NoYes::Yes;
        if (ecoResStorageDimensionGroup.RecId)
        { // Warehouse is always active
            inventDimParmInitAllMandatoryDim.InventLocationIdFlag = NoYes::Yes;
        }

        return inventDimParmInitAllMandatoryDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmInitAllPriceDiscDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are marked as part of purchase or sales order price search.
    /// </summary>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value for
    ///    dimensions with price search enabled.
    /// </returns>
    /// <remarks>
    ///    Information is gathered from all storage dimensions in the system. It is enough that a dimension is
    ///    active and is part of price search in just one storage dimension group.
    /// </remarks>
    static protected InventDimParm initInventDimParmInitAllPriceDiscDim()
    {
        EcoResStorageDimensionGroup             ecoResStorageDimensionGroup;
        InventDimParm                           inventDimParmInitAllPriceDiscDim;

        while select RecId from ecoResStorageDimensionGroup
        {
            InventDimGroupFieldSetupEnumerator enumerator = EcoResStorageDimGroupSetup::newDimensionGroup(ecoResStorageDimensionGroup.RecId).getFieldSetupEnumerator();
            while (enumerator.moveNext())
            {
                InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

                if (inventDimGroupFieldSetup.isActive() && (inventDimGroupFieldSetup.isSalesPriceSearchEnabled() || inventDimGroupFieldSetup.isPurchPriceSearchEnabled()))
                {
                    FieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                    FieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);
                    inventDimParmInitAllPriceDiscDim.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        return inventDimParmInitAllPriceDiscDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initStorageDimGroupCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal cache.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    A value that specifies a storage dimension group for which the cache is to be initialized.
    /// </param>
    static protected void initStorageDimGroupCache(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        SysGlobalObjectCache    sysGlobalObjectCache            = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope                      = EcoResStorageDimGroupSetupCache::classScope();
        container               activeKey                       = [#ActiveKey, _storageDimensionGroup];
        container               consistentKey                   = [#ConsistentKey, _storageDimensionGroup];
        container               mandatoryKey                    = [#MandatoryKey, _storageDimensionGroup];
        container               primaryKey                      = [#PrimaryKey, _storageDimensionGroup];
        container               financialInventoryKey           = [#FinancialInventoryKey, _storageDimensionGroup];
        container               physicalInventoryKey            = [#PhysicalInventoryKey, _storageDimensionGroup];
        container               coveragePlanByDimensionKey      = [#CoveragePlanByDimensionKey, _storageDimensionGroup];
        container               purchPriceKey                   = [#PurchPriceKey, _storageDimensionGroup];
        container               salesPriceKey                   = [#SalesPriceKey, _storageDimensionGroup];
        container               notAllowBlankReceiptKey         = [#NotAllowBlankReceipt, _storageDimensionGroup];
        container               notAllowBlankIssueKey           = [#NotAllowBlankIssue, _storageDimensionGroup];

        InventDimParm   isActive;
        InventDimParm   isMandatory;
        InventDimParm   isConsistent;
        InventDimParm   financialInventoryEnabled;
        InventDimParm   physicalInventoryEnabled;
        InventDimParm   primaryStockingEnabled;
        InventDimParm   purchPriceSearchEnabled;
        InventDimParm   salesPriceSearchEnabled;
        InventDimParm   coveragePlanByDimensionEnabled;
        InventDimParm   notAllowBlankReceipt;
        InventDimParm   notAllowBlankIssue;

        if (! _storageDimensionGroup)
        {
            return;
        }

        purchPriceSearchEnabled.clear();
        salesPriceSearchEnabled.clear();
        coveragePlanByDimensionEnabled.clear();
        coveragePlanByDimensionEnabled.ItemIdFlag   = NoYes::Yes;
        isActive.clear();
        financialInventoryEnabled.clear();
        financialInventoryEnabled.ItemIdFlag        = NoYes::Yes;
        physicalInventoryEnabled.clear();
        primaryStockingEnabled.clear();
        isMandatory.clear();
        isConsistent.clear();
        notAllowBlankReceipt.clear();
        notAllowBlankIssue.clear();

        InventDimGroupFieldSetupEnumerator enumerator = EcoResStorageDimGroupSetup::newDimensionGroup(_storageDimensionGroup).getFieldSetupEnumerator();
        while (enumerator.moveNext())
        {
            InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

            if (inventDimGroupFieldSetup.isActive())
            {
                FieldId inventDimFieldId = inventDimGroupFieldSetup.dimFieldId();
                FieldId dimParmFieldId = InventDim::dim2dimParm(inventDimFieldId);

                isActive.(dimParmFieldId) = NoYes::Yes;

                if (inventDimGroupFieldSetup.isPurchPriceSearchEnabled())
                {
                    purchPriceSearchEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isSalesPriceSearchEnabled())
                {
                    salesPriceSearchEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isCoveragePlanByDimensionEnabled())
                {
                    coveragePlanByDimensionEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isFinancialInventoryEnabled())
                {
                    financialInventoryEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isPhysicalInventoryEnabled())
                {
                    physicalInventoryEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isPrimaryStockingEnabled())
                {
                    primaryStockingEnabled.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isMandatory())
                {
                    isMandatory.(dimParmFieldId) = NoYes::Yes;
                }

                if (inventDimGroupFieldSetup.isConsistent())
                {
                    isConsistent.(dimParmFieldId) = NoYes::Yes;
                }

                if (!inventDimGroupFieldSetup.isAllowBlankReceiptEnabled())
                {
                    notAllowBlankReceipt.(dimParmFieldId) = NoYes::Yes;
                }

                if (!inventDimGroupFieldSetup.isAllowBlankIssueEnabled())
                {
                    notAllowBlankIssue.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        sysGlobalObjectCache.insert(classScope, activeKey, [isActive]);
        sysGlobalObjectCache.insert(classScope, consistentKey, [isConsistent]);
        sysGlobalObjectCache.insert(classScope, mandatoryKey, [isMandatory]);
        sysGlobalObjectCache.insert(classScope, primaryKey, [primaryStockingEnabled]);
        sysGlobalObjectCache.insert(classScope, financialInventoryKey, [financialInventoryEnabled]);
        sysGlobalObjectCache.insert(classScope, physicalInventoryKey, [physicalInventoryEnabled]);

        sysGlobalObjectCache.insert(classScope, coveragePlanByDimensionKey, [coveragePlanByDimensionEnabled]);
        sysGlobalObjectCache.insert(classScope, purchPriceKey, [purchPriceSearchEnabled]);
        sysGlobalObjectCache.insert(classScope, salesPriceKey, [salesPriceSearchEnabled]);
        sysGlobalObjectCache.insert(classScope, notAllowBlankReceiptKey, [notAllowBlankReceipt]);
        sysGlobalObjectCache.insert(classScope, notAllowBlankIssueKey, [notAllowBlankIssue]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParm2InventDimParm</Name>
				<Source><![CDATA[
        static protected void inventDimParm2InventDimParm(
        InventDimParm   _toInventDimParm,
        InventDimParm   _fromInventDimParm)
    {
        ListEnumerator          dimFieldList = EcoResStorageDimGroupSetup::dimFields().getEnumerator();

        while (dimFieldList.moveNext())
        {
            FieldId dimParmFieldId = InventDim::dim2dimParm(dimFieldList.current());
            if (_fromInventDimParm.(dimParmFieldId))
            {
                _toInventDimParm.(dimParmFieldId) = _fromInventDimParm.(dimParmFieldId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllActiveDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about the dimensions that are active.
    /// </summary>
    /// <param name="_inventDimParmInitAllActiveDim">
    ///    A <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value upon return
    ///    for active storage dimension.
    /// </param>
    /// <remarks>
    ///    Information is gathered from all storage dimension groups in the system. It is enough that a
    ///    dimension is active in just one storage dimension group to be returned as active.
    /// </remarks>
    static public void inventDimParmInitAllActiveDim(InventDimParm _inventDimParmInitAllActiveDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResStorageDimGroupSetupCache::classScope();
        container               key                     = [#ActiveAllGroupKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conLen(packedRecordCache) == 0)
        {
            recordCache = EcoResStorageDimGroupSetupCache::initInventDimParmInitAllActiveDim();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResStorageDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllActiveDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllActivePhysicalDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about the dimensions that are active and physical.
    /// </summary>
    /// <param name="_inventDimParmInitAllActivePhysicalDim">
    ///    A <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value upon return
    ///    for active and physical storage dimension.
    /// </param>
    /// <remarks>
    ///    Information is gathered from all storage dimension groups in the system. It is enough that a
    ///    dimension is active and physical in just one storage dimension group to be returned as active and physical.
    /// </remarks>
    static public void inventDimParmInitAllActivePhysicalDim(InventDimParm _inventDimParmInitAllActivePhysicalDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResStorageDimGroupSetupCache::classScope();
        container               key                     = [#ActivePhysicalAllGroupKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conLen(packedRecordCache) == 0)
        {
            recordCache = EcoResStorageDimGroupSetupCache::initInventDimParmInitAllActivePhysDim();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResStorageDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllActivePhysicalDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllConsistentDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about the dimensions that are consistent.
    /// </summary>
    /// <param name="_inventDimParmInitAllConsistentDim">
    ///    A <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value upon return
    ///    for consistent dimensions.
    /// </param>
    /// <remarks>
    ///    Information is gathered from all storage dimensions in the system. It is enough that a dimension is
    ///    active and consistent in just one storage dimension group to be returned as consistent.
    /// </remarks>
    static public void inventDimParmInitAllConsistentDim(InventDimParm _inventDimParmInitAllConsistentDim)
    {
        // Site is always active and is the only consistent storage dimension, so no need to read any record
        _inventDimParmInitAllConsistentDim.InventSiteIdFlag = NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllCovDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about the dimensions that are marked as part of master planning.
    /// </summary>
    /// <param name="_inventDimParmInitAllCovDim">
    ///    An <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value upon return
    ///    for dimensions which are part of master planning.
    /// </param>
    /// <remarks>
    ///    Information is gathered from all storage dimension groups in the system. It is enough that a
    ///    dimension is active and marked as part of master planning in just one storage dimension group.
    /// </remarks>
    static public void inventDimParmInitAllCovDim(InventDimParm _inventDimParmInitAllCovDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResStorageDimGroupSetupCache::classScope();
        container               key                     = [#AllCovKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conLen(packedRecordCache) == 0)
        {
            recordCache = EcoResStorageDimGroupSetupCache::initInventDimParmInitAllCovDim();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResStorageDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllCovDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllMandatoryDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are marked as mandatory.
    /// </summary>
    /// <param name="_inventDimParmInitAllMandatoryDim">
    ///    An <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value upon return
    ///    for dimensions which are marked as mandatory.
    /// </param>
    /// <remarks>
    ///    Information is gathered from all storage dimension group in the system. It is enough that a
    ///    dimension is active and are marked as mandatory in just one storage dimension group to be returned
    ///    as mandatory.
    /// </remarks>
    static public void inventDimParmInitAllMandatoryDim(InventDimParm _inventDimParmInitAllMandatoryDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResStorageDimGroupSetupCache::classScope();
        container               key                     = [#AllMandatoryKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conLen(packedRecordCache) == 0)
        {
            recordCache = EcoResStorageDimGroupSetupCache::initInventDimParmInitAllMandatoryDim();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResStorageDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllMandatoryDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllPriceDiscDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are marked as part of purchase or sales order price search.
    /// </summary>
    /// <param name="_inventDimParmInitAllPriceDiscDim">
    ///    An <c>InventDimParm</c> buffer with fields set to a <c>NoYes::Yes</c> enumeration value upon return
    ///    for dimensions which are part of price searches.
    /// </param>
    /// <remarks>
    ///    Information is gathered from all storage dimensions in the system. It is enough that a dimension is
    ///    active and is part of price search in just one storage dimension group.
    /// </remarks>
    static public void inventDimParmInitAllPriceDiscDim(InventDimParm _inventDimParmInitAllPriceDiscDim)
    {
        SysGlobalObjectCache    sysGlobalObjectCache    = classfactory.globalObjectCache();
        GlobalObjectCacheScope  classScope              = EcoResStorageDimGroupSetupCache::classScope();
        container               key                     = [#AllPriceDiscKey];
        InventDimParm           recordCache;

        container packedRecordCache = sysGlobalObjectCache.find(classScope , key);
        if (!packedRecordCache || conLen(packedRecordCache) == 0)
        {
            recordCache = EcoResStorageDimGroupSetupCache::initInventDimParmInitAllPriceDiscDim();
            sysGlobalObjectCache.insert(classScope, key, [recordCache]);
        }
        else
        {
            [recordCache] = packedRecordCache;
        }

        EcoResStorageDimGroupSetupCache::inventDimParm2InventDimParm(_inventDimParmInitAllPriceDiscDim, recordCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mandatory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about the dimensions that are active and marked as mandatory.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    A value that specifies the storage dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm mandatory(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#MandatoryKey, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>notAllowBlankIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active and where a blank issue value is not
    /// allowed.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    /// Specifies the storage dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm notAllowBlankIssue(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#NotAllowBlankIssue, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>notAllowBlankReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active and where a blank receipt value is not
    /// allowed.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    /// Specifies the storage dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm notAllowBlankReceipt(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#NotAllowBlankReceipt, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalInventoryEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about the dimensions that are active and marked as part of physical inventory.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    A value that specifies the storage dimension group for which the information is to be retrieved.
    /// </param>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm physicalInventoryEnabled(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#PhysicalInventoryKey, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>primaryStockingEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about the dimensions that are active and marked as primary stocking
    ///    dimensions.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    A value that specifies the storage dimension group for which the information is to be retrieved.
    /// </param>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer that contains requested information.
    /// </returns>
    static public InventDimParm primaryStockingEnabled(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#PrimaryKey, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchPriceSearchEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and marked to be included when you search
    ///    for purchase price.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    A value that specifies the storage dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm purchPriceSearchEnabled(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#PurchPriceKey, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPriceSearchEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about the dimensions that are active and marked to be included when you
    ///    search for sales price.
    /// </summary>
    /// <param name="_storageDimensionGroup">
    ///    Specifies the storage dimension group for which information is to be retrieved.
    /// </param>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer that contains the requested information.
    /// </returns>
    static public InventDimParm salesPriceSearchEnabled(EcoResStorageDimensionGroupRecId _storageDimensionGroup)
    {
        container   key     = [#SalesPriceKey, _storageDimensionGroup];

        return EcoResStorageDimGroupSetupCache::getCachedInventDimParm(_storageDimensionGroup, key);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>
