<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventTransWMS_Pick</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventTransWMS</c> class is used by the simple picking form.
/// </summary>
public class InventTransWMS_Pick extends InventTransWMS
{
    Query   baseQueryInventTrans;
    Map     mapQtyByItemInventDimId;                        //[item,inventDimId]      -> selectedQty
    Map     mapItemInventDimAvailableQty;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds inventory transactions to pending records.
    /// </summary>
    /// <param name="_tmpInventTransWMS">
    /// A <c>TmpInventTransWMS</c> record.
    /// </param>
    /// <param name="_qtyRemain">
    /// The quantity to add; optional.
    /// </param>
    /// <param name="_qtyRemainCW">
    /// The catch weight quantity to add; optional.
    /// </param>
    /// <returns>
    /// true if the expected quantity was added; otherwise, false.
    /// </returns>
    protected boolean addInventTrans(
        TmpInventTransWMS _tmpInventTransWMS,
        InventQty         _qtyRemain    = _tmpInventTransWMS.InventQty,
        PdsCWInventQty    _qtyRemainCW  = _tmpInventTransWMS.PdsCWQty)
    {
        InventQty                   inventQty;
        InventQty                   inventQtyAvailable;
        InventQty                   qtyNow;
        InventQty                   qtyRemain = -(abs(_qtyRemain));
        boolean                     result    = true;
        PdsCWInventQty              inventQtyCW;
        PdsCWInventQty              inventQtyAvailableCW;
        PdsCWInventQty              qtyNowCW;
        PdsCWInventQty              qtyRemainCW = -(abs(_qtyRemainCW));
        boolean                     isCWItem;
        boolean                     cwWmsTransCWValid    = true;
        boolean                     cwInventTransCWValid = true;

        if (qtyRemain || qtyRemainCW)
        {
            boolean beginTmpInventTransWMS = this.beginTmpInventTransWMS(_tmpInventTransWMS);

            Query query = this.queryInventTrans(_tmpInventTransWMS);
            QueryRun queryRun = new QueryRun(query);

            while (queryRun.next() && (qtyRemain || qtyRemainCW))
            {
                InventTrans inventTrans = queryRun.get(tableNum(InventTrans));
                isCWItem = PdsGlobal::pdsIsCWItem(inventTrans.ItemId);
                //determine available quantity
                if (this.isInventTransSelected(inventTrans.RecId))
                {
                    inventQtyAvailable = inventTrans.Qty + abs(conPeek(mapQtyByInventTrans.lookup(inventTrans.RecId),#InventQtyIdx));
                    inventQtyAvailableCW = inventTrans.PdsCWQty + abs(conPeek(mapQtyByInventTrans.lookup(inventTrans.RecId),#InventQtyCWIdx));
                }
                else
                {
                    inventQtyAvailable = inventTrans.Qty;
                    inventQtyAvailableCW = inventTrans.PdsCWQty;
                }
                if ((!isCWItem && inventQtyAvailable < 0) || (isCWItem && inventQtyAvailableCW < 0))
                {
                    //qtyRemain is always negative
                    if (isCWItem)
                    {
                        cwWmsTransCWValid = PdsCatchWeightItem::pdsCWIsValidQty(
                            inventTrans.ItemId,
                            qtyRemain,
                            qtyRemainCW);

                        cwInventTransCWValid = PdsCatchWeightItem::pdsCWIsValidQty(
                            inventTrans.ItemId,
                            inventQtyAvailable,
                            inventQtyAvailableCW);
                    }

                    if ((!isCWItem   && inventQtyAvailable < qtyRemain)
                        || (isCWItem && ((inventQtyAvailableCW <qtyRemainCW) || (!cwInventTransCWValid && cwWmsTransCWValid))))
                    {
                        qtyNow = qtyRemain;
                        qtyNowCW = qtyRemainCW;
                    }
                    else
                    {
                        qtyNow = inventQtyAvailable;
                        qtyNowCW = inventQtyAvailableCW;
                    }

                    //set sign
                    if (inventTrans.StatusIssue == StatusIssue::Picked)
                    {
                        inventQty = qtyNow;
                        inventQtyCW = qtyNowCW;
                    }
                    else
                    {
                        inventQty = -qtyNow;
                        inventQtyCW = -qtyNowCW;
                    }

                    //validate and update internal maps
                    if (this.setSelectedQty(_tmpInventTransWMS, inventTrans, null, inventQty, false, inventQtyCW))
                    {
                        qtyRemain -= qtyNow;
                        qtyRemainCW -= qtyNowCW;
                    }
                }
            }
            if ((!isCWItem && qtyRemain) || (isCWItem && qtyRemainCW))
            {
                if (isCWItem)
                {
                    result = checkFailed(strFmt("@SYS324606",-qtyRemainCW));
                }
                else
                {
                    result = checkFailed(strFmt("@SYS324606",-qtyRemain));
                }

                if (beginTmpInventTransWMS)
                {
                    this.abortTmpInventTransWMS();
                }
            }
            else
            {
                this.writeTmp(_tmpInventTransWMS);

                if (beginTmpInventTransWMS)
                {
                    this.commitTmpInventTransWMS();
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>availableQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the available quantity for a given inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// A <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventDimId">
    /// A inventory dimension identifier.
    /// </param>
    /// <returns>
    /// The available quantity.
    /// </returns>
    public InventQtyAvailPhysical availableQuantity(
        InventTrans _inventTrans,
        InventDimId _inventDimId = _inventTrans.InventDimId)
    {
        InventQtyAvailPhysical  inventQty;
        str                     mapKey = strFmt('%1#%2',_inventTrans.ItemId,_inventDimId);

        switch (_inventTrans.StatusIssue)
        {
            case StatusIssue::None:
            case StatusIssue::Picked:
                inventQty = 0;
                break;
            case StatusIssue::ReservPhysical:
                inventQty = -_inventTrans.Qty;
                break;
            default:
                if (mapItemInventDimAvailableQty.exists(mapKey))
                {
                    inventQty = mapItemInventDimAvailableQty.lookup(mapKey);
                }
                else
                {
                    InventDim inventDimLocal = InventDim::find(_inventDimId);
                    InventIAvailability availability = InventAvailabilityProvider::findByItemIdDim(_inventTrans.ItemId,inventDimLocal).parmInventAvailability();
                    inventQty = availability.availPhysical();
                    mapItemInventDimAvailableQty.insert(mapKey,inventQty);
                }
                break;
        }

        return inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromHandlingUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates records in the pending records table that is based on a handling unit selection.
    /// </summary>
    /// <param name="_inventTransPickHandlingUnit">
    /// A <c>InventTransPickHandlingUnit</c> enumeration value.
    /// </param>
    /// <param name="_handlingUnit">
    /// A handling unit value.
    /// </param>
    /// <returns>
    /// true if no errors occurred during validation and processing; otherwise, false.
    /// </returns>
    /// Creates records in the pending records table based on a handling unit selection.
    public boolean createFromHandlingUnit(
        InventTransPickHandlingUnit _inventTransPickHandlingUnit,
        InventBatchSerialId         _handlingUnit)
    {
        #define.mapKey('\%1#\%2\%3')
        InventTrans             inventTrans;
        InventDim               inventDim;
        InventDim               inventDimProductDimension;
        InventDim               inventDimMerged;
        InventDimParm           inventDimParmActivePhysical;
        InventDimParm           inventDimParmProductDimension;
        Kanban                  kanban;
        InventTransOriginId     inventTransOriginIdRelatedReceipt;
        InventQty               inventQty;
        InventQty               inventQtyAdded;
        InventQty               inventQtyRelatedReceipt;
        FieldId                 fieldIdHandlingUnit;
        MapEnumerator           me;
        Map                     mapInventTrans                 = new Map(Types::String,Types::Container);
        Map                     mapInventDimMergedQty          = new Map(Types::String,Types::Container);
        PdsCWInventQty          inventQtyCW;
        PdsCWInventQty          inventQtyAddedCW;
        Map                     mapInventDimInventTransSkipped = new Map(Types::String,Types::Record);
        boolean                 result                         = true;

        if (_inventTransPickHandlingUnit != InventTransPickHandlingUnit::None && _handlingUnit)
        {
            //build query for inventory dimensions. Looking for physically available inventory that meets the filter criteria specified in the handling unit field.
            Query queryHandlingUnit = new Query();
            QueryBuildDataSource qbdsInventDimHandlingUnit = queryHandlingUnit.addDataSource(tableNum(InventDim));

            //validate and add range for specific inventory dimension if required
            QueryBuildRange qbR = null;
            switch (_inventTransPickHandlingUnit)
            {
                case InventTransPickHandlingUnit::InventBatchId:
                    fieldIdHandlingUnit = fieldNum(InventDim,InventBatchId);
                    break;
                case InventTransPickHandlingUnit::InventSerialId:
                    fieldIdHandlingUnit = fieldNum(InventDim,InventSerialId);
                    break;
                case InventTransPickHandlingUnit::WMSLocationId:
                    fieldIdHandlingUnit = fieldNum(InventDim,wmsLocationId);
                    break;
                    // <GEERU>
                case InventTransPickHandlingUnit::InventGTDId:
                    fieldIdHandlingUnit = fieldNum(InventDim,InventGtdId_RU);
                    break;
                case InventTransPickHandlingUnit::InventOwnerId:
                    fieldIdHandlingUnit = fieldNum(InventDim,InventOwnerId_RU);
                    break;
                case InventTransPickHandlingUnit::InventProfileId:
                    fieldIdHandlingUnit = fieldNum(InventDim,InventProfileId_RU);
                    break;
                    // </GEERU>
                case InventTransPickHandlingUnit::KanbanCard:
                    if (!KanbanCard::existCardId(_handlingUnit))
                    {
                        result = checkFailed(strFmt("@SYS324592",_handlingUnit));
                    }
                    else
                    {
                        kanban = Kanban::findKanbanCardId(_handlingUnit);
                        if (!kanban || kanban.Status != LeanKanbanStatus::Received)
                        {
                            result = checkFailed(strFmt("@SYS324593",_handlingUnit));
                        }
                        inventTransOriginIdRelatedReceipt = kanban.lastKanbanJob().receiptInventTransOriginId();
                        inventQtyRelatedReceipt           = InventTransIdSum::newTransOriginId(inventTransOriginIdRelatedReceipt).physicalInvent();
                    }
                    break;
            }

            if (result)
            {
                //loop records shown in the upper grid of the form (the issue to pick)
                QueryRun queryRun = new QueryRun(baseQueryInventTrans);
                while (queryRun.next())
                {
                    inventTrans         = queryRun.get(tableNum(InventTrans));
                    boolean isPhyscalReserved = inventTrans.StatusIssue == StatusIssue::ReservPhysical;

                    inventDim           = queryRun.get(tableNum(InventDim));
                    InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(inventTrans.ItemId);

                    inventDimGroupSetup.inventDimParmActiveProductDimension(inventDimParmProductDimension);
                    inventDimGroupSetup.inventDimParmActivePhysicalInventory(inventDimParmActivePhysical);
                    inventDimProductDimension.copyDimParmDim(inventDimGroupSetup,inventDim,inventDimParmProductDimension);
                    inventDimProductDimension = InventDim::findOrCreate(inventDimProductDimension);

                    //records to be added to the lower grid must
                    // - not already be picked
                    // - have a blank inventory dimension value where the handling unit would go (in case a dimension was specified)
                    // - be for the same item as the kanban (in case a kanban card was specified)
                    if (   inventTrans.StatusIssue > StatusIssue::Picked
                        && ((inventDimGroupSetup.isDimensionActive(fieldNum(InventDim,InventBatchId))
                        &&   !inventDim.InventBatchId)
                        ||  _inventTransPickHandlingUnit != InventTransPickHandlingUnit::InventBatchId)
                        && ((inventDimGroupSetup.isDimensionActive(fieldNum(InventDim,InventSerialId))
                        &&   !inventDim.InventSerialId)
                        ||  _inventTransPickHandlingUnit != InventTransPickHandlingUnit::InventSerialId)
                        && ((inventDimGroupSetup.isDimensionActive(fieldNum(InventDim,wmsLocationId))
                        &&   !inventDim.wmsLocationId)
                        ||  _inventTransPickHandlingUnit != InventTransPickHandlingUnit::WMSLocationId)
                        && (inventTrans.ItemId           == kanban.ItemId
                        ||  _inventTransPickHandlingUnit != InventTransPickHandlingUnit::KanbanCard))
                    {
                        //run a query over inventory dimensions and get the available inventory in order to find if the issue record (item, dimension) should be added or not.

                        //set range: same product dimensions
                        ListEnumerator le = InventDim::dimProductDimFieldList().getEnumerator();
                        while (le.moveNext())
                        {
                            qbR = SysQuery::findOrCreateRange(qbdsInventDimHandlingUnit,le.current());
                            qbR.value(queryValue(inventDim.(le.current())));
                        }

                        le = InventDim::dimFieldsList().getEnumerator();
                        while (le.moveNext())
                        {
                            //set range: always require a match with the handling unit
                            if (fieldIdHandlingUnit == le.current())
                            {
                                qbR = SysQuery::findOrCreateRange(qbdsInventDimHandlingUnit,le.current());
                                qbR.value(queryValue(_handlingUnit));
                            }
                            else
                            {
                                //set range: all dimensions that are not active for the current item must be blank
                                if (!inventDimParmActivePhysical.isFieldIdEnabled(le.current()))
                                {
                                    qbR = SysQuery::findOrCreateRange(qbdsInventDimHandlingUnit,le.current());
                                    qbR.value(queryValue(InventDim::emptyDimField(le.current())));
                                }
                            }
                        }

                        //set range: same site
                        qbR = SysQuery::findOrCreateRange(qbdsInventDimHandlingUnit,fieldNum(InventDim,InventSiteId));
                        qbR.value(queryValue(inventDim.InventSiteId));

                        //set range: same warehouse if present
                        if (inventDim.InventLocationId)
                        {
                            qbR = SysQuery::findOrCreateRange(qbdsInventDimHandlingUnit,fieldNum(InventDim,InventLocationId));
                            qbR.value(queryValue(inventDim.InventLocationId));
                        }

                        //run the query
                        QueryRun queryRunHandlingUnit = new QueryRun(queryHandlingUnit);
                        while (queryRunHandlingUnit.next())
                        {
                            InventDim inventDimHandlingUnit = queryRunHandlingUnit.get(tableNum(InventDim));
                            inventDimMerged = this.mergeInventDimHandlingUnit(inventDim,inventDimHandlingUnit);

                            //skip if the merged inventory dimension has already been added
                            if (!mapInventTrans.exists(strFmt(#mapKey,inventTrans.RecId,inventDimMerged.InventDimId, isPhyscalReserved)))
                            {
                                //lookup cache for item + merged inventory dimensions
                                if (mapInventDimMergedQty.exists(strFmt(#mapKey,inventTrans.ItemId,inventDimMerged.InventDimId, isPhyscalReserved)))
                                {
                                    inventQty = conPeek(mapInventDimMergedQty.lookup(strFmt(#mapKey,inventTrans.ItemId,inventDimMerged.InventDimId, isPhyscalReserved)), #InventQtyIdx);
                                    inventQtyCW = conPeek(mapInventDimMergedQty.lookup(strFmt(#mapKey,inventTrans.ItemId,inventDimMerged.InventDimId, isPhyscalReserved)), #InventQtyCWIdx);
                                }
                                else
                                {
                                    //available inventory minus lines already added
                                    InventSum inventSum = InventSum::findSumQty(inventTrans.ItemId,inventDimMerged,inventDimParmActivePhysical);
                                    InventAvailabilityByUnit inventAvailabilityByUnit = InventAvailabilityProvider::findByItemIdDim(inventTrans.ItemId,inventDimMerged);
                                    
                                    if (inventTrans.StatusIssue == StatusIssue::ReservPhysical)
                                    {
                                        inventQty = inventSum.physicalInventCalculated() + inventAvailabilityByUnit.parmInventAvailability().reservPhysical();
                                        inventQtyCW = inventSum.pdsCWPhysicalInventCalculated() + inventAvailabilityByUnit.parmPdsCWInventAvailability().pdsCWReservPhysical();
                                    }
                                    else
                                    {
                                        inventQty = inventAvailabilityByUnit.parmInventAvailability().availPhysical();
                                        inventQtyCW = inventSum.pdsCWAvailPhysicalCalculated();
                                    }

                                    if (mapQtyByItemInventDimId.exists([inventTrans.ItemId,inventDimMerged.InventDimId]))
                                    {
                                        inventQty   = max(0,inventQty - conPeek(mapQtyByItemInventDimId.lookup([inventTrans.ItemId,inventDimMerged.InventDimId, isPhyscalReserved]),#InventQtyIdx));
                                        inventQtyCW = max(0,inventQtyCW - conPeek(mapQtyByItemInventDimId.lookup([inventTrans.ItemId,inventDimMerged.InventDimId, isPhyscalReserved]),#InventQtyCWIdx));
                                    }

                                    //restrict to specific receipt origin
                                    if (inventTransOriginIdRelatedReceipt)
                                    {
                                        inventQty = max(0,min(inventQty, InventTransIdSum::newTransOriginIdDimension(inventTransOriginIdRelatedReceipt,
                                                        inventDimMerged,inventDimParmActivePhysical).physicalInvent()));
                                    }
                                    mapInventDimMergedQty.insert(strFmt(#mapKey,inventTrans.ItemId,inventDimMerged.InventDimId, isPhyscalReserved), [inventQty,inventQtyCW]);
                                }

                                //the map holds the max. (not final) quantity that can be used for the inventory transaction
                                mapInventTrans.insert(strFmt(#mapKey,inventTrans.RecId,inventDimMerged.InventDimId, isPhyscalReserved),
                                                      [inventQty,inventQtyCW,inventTrans,inventDimMerged]);
                            }
                        }
                    }
                }

                //iterate found records and add to lower grid
                if (mapInventTrans.elements())
                {
                    me = mapInventTrans.getEnumerator();
                    while (me.moveNext() && result)
                    {
                        [inventQty,inventQtyCW,inventTrans,inventDimMerged] = me.currentValue();

                        boolean isPhyscalReserved = inventTrans.StatusIssue == StatusIssue::ReservPhysical;

                        if (inventQty
                            || inventQtyCW
                            )
                        {
                            InventQty maxQtyRemainItemInventDimMerged     = conPeek(mapInventDimMergedQty.lookup(strFmt(#mapKey,inventTrans.ItemId,inventDimMerged.InventDimId, isPhyscalReserved)), #InventQtyIdx);
                            PdsCWInventQty maxQtyRemainItemInventDimMergedCW   = conPeek(mapInventDimMergedQty.lookup(strFmt(#mapKey,inventTrans.ItemId,inventDimMerged.InventDimId, isPhyscalReserved)), #InventQtyCWIdx);

                            //a positive or zero qty
                            //not more than the issue quantity
                            //not more than currently available at the merged dimension
                            inventQty = max(0,min(-inventTrans.Qty,maxQtyRemainItemInventDimMerged));
                            inventQtyCW = max(0,min(-inventTrans.PdsCWQty,maxQtyRemainItemInventDimMergedCW));

                            if (inventQty || inventQtyCW)
                            {
                                if (!this.isInventTransSelected(inventTrans.RecId))
                                {
                                    result = this.createPartialTmpFromInventTrans(inventTrans, -inventQty, -inventQtyCW, inventDimMerged.inventDimId);

                                    if (result)
                                    {
                                        inventQtyAdded                  += inventQty;
                                        maxQtyRemainItemInventDimMerged -= inventQty;
                                        inventQtyAddedCW                  += inventQtyCW;
                                        maxQtyRemainItemInventDimMergedCW -= inventQtyCW;
                                        mapInventDimMergedQty.insert(strFmt(#mapKey,inventTrans.ItemId,inventDimMerged.InventDimId, isPhyscalReserved), [maxQtyRemainItemInventDimMerged,maxQtyRemainItemInventDimMergedCW]);
                                    }
                                }
                                else
                                {
                                    mapInventDimInventTransSkipped.insert(strFmt(#mapKey,inventTrans.InventDimId,inventTrans.RecId, isPhyscalReserved), inventTrans);
                                }
                            }
                        }
                    }
                }

                // less than full quantity was matched
                if (inventQtyRelatedReceipt > inventQtyAdded)
                {
                    if (mapInventDimInventTransSkipped.elements())
                    {
                        // show skipped transactions in info log
                        me = mapInventDimInventTransSkipped.getEnumerator();
                        while (me.moveNext())
                        {
                            inventTrans = me.currentValue();
                            inventDim   = inventTrans.inventDim();

                            setPrefix(inventDim.preFix());
                            info(strFmtLB(strFmt("@SYS331339",inventTrans.inventTransOrigin().InventTransId,inventTrans.Qty)));
                        }
                    }

                    warning(strFmt("@SYS324594",_handlingUnit));
                }
            }
        }

        return inventQtyAdded != 0 || inventQtyAddedCW != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new record in the pending records table that is based on an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    ///    An <c>InventTrans</c> record.
    /// </param>
    /// <returns>
    ///    true if the record was created successfully; otherwise, false.
    /// </returns>
    public boolean createFromInventTrans(InventTrans _inventTrans)
    {
        if (WHSReservationHierarchyElementPolicyProvider::singleton().isReservationOnDemandOrderEnabled(InventTable::find(_inventTrans.ItemId).whsReservationHierarchy(), fieldNum(InventDim, inventBatchId)))
        {
            InventQty remainQty = _inventTrans.Qty;
            remainQty = this.createTmpFlexibleFromInventTrans(_inventTrans);
            if (remainQty)
            {
                return this.createTmpFromInventTrans(_inventTrans, true, remainQty, _inventTrans.PdsCWQty, _inventTrans.inventDimId);
            }
            else
            {
                return true;
            }
        }

        return this.createSingleTmpFromInventTrans(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpFlexibleFromInventTrans</Name>
				<Source><![CDATA[
    private InventQty createTmpFlexibleFromInventTrans(InventTrans _inventTrans)
    {
        InventQty remainQty = _inventTrans.Qty;

        var committingOriginInventTransId = _inventTrans.inventTransOrigin().InventTransId;
        WHSOrderCommittedReservation orderCommittedReservation = WHSOrderCommittedReservation::findByCommittingOriginInventTransId(committingOriginInventTransId);

        if (orderCommittedReservation && remainQty < 0)
        {
            Map dimAndQtyMap = WHSOrderCommittedReservationFacade::createOrderCommittedReservationMap(committingOriginInventTransId);
            MapEnumerator me = dimAndQtyMap.getEnumerator();

            while (remainQty && me.moveNext())
            {
                InventQty createdQty = max(-me.currentValue(), remainQty);
                if (this.createTmpFromInventTrans(_inventTrans, true, createdQty, 0, me.currentKey()))
                {
                    remainQty -= createdQty;
                }
            }
        }
        return remainQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromInventTransInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new record in the pending records table based on an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// A <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventQty">
    /// The quantity of the record to insert with inverted sign; optional.
    /// </param>
    /// <param name="_inventDimHandlingUnit">
    /// A <c>InventDim</c> record to initialize the <c>TmpInventTransWMS</c> record from; optional.
    /// </param>
    /// <param name="_allowIfInventTransSelected">
    /// A Boolean value that indicates whether a record can be added multiple times; optional.
    /// </param>
    /// <param name="_inventQtyCW">
    /// The catch weight quantity of the record to insert with inverted sign; optional.
    /// </param>
    /// <returns>
    /// true if the operation was completed successfully; otherwise, false.
    /// </returns>
    [SysObsolete('Use createSingleTmpFromInventTrans or createPartialTmpFromInventTrans instead.', false, 31\03\2018)]
    final protected boolean createFromInventTransInternal(
        InventTrans     _inventTrans,
        InventQty       _inventQty                  = _inventTrans.Qty,
        InventDim       _inventDimHandlingUnit      = null,
        boolean         _allowIfInventTransSelected = false,
        PdsCWInventQty  _inventQtyCW                = _inventTrans.PdsCWQty
        )
    {
        return this.createTmpFromInventTrans(_inventTrans, _allowIfInventTransSelected, _inventQty, _inventQtyCW, prmisDefault(_inventDimHandlingUnit) ? _inventTrans.inventDimId : _inventDimHandlingUnit.inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSingleTmpFromInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a single new record in the pending records table based on an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// A <c>InventTrans</c> record.
    /// </param>
    /// <returns>
    /// true if the operation was completed successfully; otherwise, false.
    /// </returns>
    final protected boolean createSingleTmpFromInventTrans(InventTrans _inventTrans)
    {
        return this.createTmpFromInventTrans(_inventTrans, false, _inventTrans.Qty, _inventTrans.PdsCWQty, _inventTrans.inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPartialTmpFromInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new record in the pending records table based on the partial quantity from an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// A <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventQty">
    /// The quantity of the record to insert with inverted sign.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity of the record to insert with inverted sign.
    /// </param>
    /// <param name="_handlingUnitInventDimId">
    /// A <c>InventDimId</c> to initialize the <c>TmpInventTransWMS</c> record from.
    /// </param>
    /// <returns>
    /// true if the operation was completed successfully; otherwise, false.
    /// </returns>
    final protected boolean createPartialTmpFromInventTrans(
        InventTrans     _inventTrans,
        InventQty       _inventQty,
        PdsCWInventQty  _cwQty,
        InventDimId     _handlingUnitInventDimId)
    {
        return this.createTmpFromInventTrans(_inventTrans, true, _inventQty, _cwQty, _handlingUnitInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpFromInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new record in the pending records table based on an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// A <c>InventTrans</c> record.
    /// </param>
    /// <param name="_allowMultipleTransactionReferences">
    /// A Boolean value that indicates whether a record can be added multiple times.
    /// </param>
    /// <param name="_inventQty">
    /// The quantity of the record to insert with inverted sign.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity of the record to insert with inverted sign.
    /// </param>
    /// <param name="_handlingUnitInventDimId">
    /// A <c>InventDimId</c> to initialize the <c>TmpInventTransWMS</c> record from.
    /// </param>
    /// <returns>
    /// true if the operation was completed successfully; otherwise, false.
    /// </returns>
    private boolean createTmpFromInventTrans(
        InventTrans     _inventTrans,
        boolean         _allowMultipleTransactionReferences,
        InventQty       _inventQty,
        PdsCWInventQty  _cwQty,
        InventDimId     _handlingUnitInventDimId
        )
    {
        boolean result;

        if (_allowMultipleTransactionReferences || !this.isInventTransSelected(_inventTrans.RecId))
        {
            TmpInventTransWMS tmpInventTransWMSLocal = this.initializeTmpFromInventTrans(_inventTrans, _inventQty, _cwQty, _handlingUnitInventDimId);

            if (tmpInventTransWMSLocal.InventQty != 0)
            {
                result = this.setSelectedQty(tmpInventTransWMSLocal, _inventTrans, null, tmpInventTransWMSLocal.InventQty, true, tmpInventTransWMSLocal.PdsCWQty);

                if (result)
                {
                    this.writeTmp(tmpInventTransWMSLocal);
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTmpFromInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>TmpInventTransWMS</c> record based on an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// An <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventQty">
    /// The quantity of the record to insert with inverted sign.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity of the record to insert with inverted sign.
    /// </param>
    /// <param name="_handlingUnitInventDimId">
    /// A <c>InventDimId</c> to initialize the <c>TmpInventTransWMS</c> record from.
    /// </param>
    /// <returns>
    /// The initialized <c>TmpInventTransWMS</c> record.
    /// </returns>
    protected TmpInventTransWMS initializeTmpFromInventTrans(
        InventTrans     _inventTrans,
        InventQty       _inventQty,
        PdsCWInventQty  _cwQty,
        InventDimId     _handlingUnitInventDimId)
    {
        TmpInventTransWMS tmpInventTransWMSLocal;

        tmpInventTransWMSLocal.initFromInventTrans(_inventTrans);
        tmpInventTransWMSLocal.initFromInventTransOrigin(_inventTrans.inventTransOrigin());

        tmpInventTransWMSLocal.initInventQty(_inventQty, _inventTrans.StatusReceipt, _inventTrans.StatusIssue);
        tmpInventTransWMSLocal.initPdsCWQty(_cwQty, _inventTrans.StatusReceipt, _inventTrans.StatusIssue);
        tmpInventTransWMSLocal.initInventDimId(_handlingUnitInventDimId);

        return tmpInventTransWMSLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBoxText</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides the correct text for the 'Delete all' box.
    /// </summary>
    /// <returns>
    ///    The correct text.
    /// </returns>
    protected str deleteBoxText()
    {
        return "@SYS54886";
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes internal variables.
    /// </summary>
    protected void init()
    {
        super();
        this.initSelectedQty();
        this.initAvailableQuantity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAvailableQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets the internal <c>Map</c> object that is used to store the available quantity.
    /// </summary>
    protected void initAvailableQuantity()
    {
        mapItemInventDimAvailableQty = new Map(Types::String,Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSelectedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the internal <c>Map</c> objects used to store selected quantities per movement.
    /// </summary>
    protected void initSelectedQty()
    {
        super();
        mapQtyByItemInventDimId = new Map(Types::Container,Types::Container);
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeTableEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes all records in the <c>TmpInventTransWMS</c> table and initializes internal variables.
    /// </summary>
    public void makeTableEmpty()
    {
        super();
        this.initAvailableQuantity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeInventDimHandlingUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Merges inventory dimensions so that the location, warehouse location, batch and serial
    /// numbers are filling in blanks in the original issue dimension.
    /// </summary>
    /// <param name="_inventDimIssue">
    /// An <c>InventDim</c> record.
    /// </param>
    /// <param name="_inventDimHandlingUnitReceipt">
    /// An <c>InventDim</c> record that is used in the merge.
    /// </param>
    /// <returns>
    /// The merged <c>InventDim</c> record.
    /// </returns>
    /// <remarks>
    /// Only location, warehouse location, batch and serial numbers are merged. Site and warehouse
    /// must be identical.
    /// </remarks>
    protected InventDim mergeInventDimHandlingUnit(
        InventDim _inventDimIssue,
        InventDim _inventDimHandlingUnitReceipt)
    {
        InventDim   inventDimMerged;

        #inventDimDevelop

        if (   (_inventDimIssue.InventSiteId == _inventDimHandlingUnitReceipt.InventSiteId
            ||  !_inventDimHandlingUnitReceipt.InventSiteId)
            && (_inventDimIssue.InventLocationId == _inventDimHandlingUnitReceipt.InventLocationId
            ||  !_inventDimIssue.InventLocationId))
        {
            //merge inventory dimensions, so that 'blanks' are filled in from the found receipt
            inventDimMerged.data(_inventDimIssue);

            if (!inventDimMerged.InventLocationId)
            {
                inventDimMerged.InventLocationId = _inventDimHandlingUnitReceipt.InventLocationId;
            }

            if (!inventDimMerged.wmsLocationId)
            {
                inventDimMerged.wmsLocationId = _inventDimHandlingUnitReceipt.wmsLocationId;
            }

            if (!inventDimMerged.InventBatchId)
            {
                inventDimMerged.InventBatchId = _inventDimHandlingUnitReceipt.InventBatchId;
            }

            if (!inventDimMerged.InventSerialId)
            {
                inventDimMerged.InventSerialId = _inventDimHandlingUnitReceipt.InventSerialId;
            }

            if (!inventDimMerged.LicensePlateId)
            {
                inventDimMerged.LicensePlateId = _inventDimHandlingUnitReceipt.LicensePlateId;
            }

            if (!inventDimMerged.InventStatusId)
            {
                inventDimMerged.InventStatusId = _inventDimHandlingUnitReceipt.InventStatusId;
            }

            inventDimMerged = InventDim::findOrCreate(inventDimMerged);
        }

        return inventDimMerged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>movement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the inventory movement for the specified record.
    /// </summary>
    /// <param name="_common">
    ///    A <c>Common</c> record buffer.
    /// </param>
    /// <returns>
    ///    An <c>InventMovement</c> object.
    /// </returns>
    protected InventMovement movement(Common _common)
    {
        return InventTransWMS_Pick::inventMovement(_common);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBaseQueryInventTrans</Name>
				<Source><![CDATA[
    public Query parmBaseQueryInventTrans(Query _baseQueryInventTrans = baseQueryInventTrans)
    {
        baseQueryInventTrans = _baseQueryInventTrans;
        return baseQueryInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickedQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates how much has already been picked by the specified movement for the specified dimensions.
    /// </summary>
    /// <param name="_movement">
    ///    The movement that is being picked.
    /// </param>
    /// <param name="_tmpInventTransWMS">
    ///    A <c>TmpInventTransWMS</c> record.
    /// </param>
    /// <returns>
    ///    An inventory quantity.
    /// </returns>
    protected InventQtyPicked pickedQty(
        InventMovement    _movement,
        TmpInventTransWMS _tmpInventTransWMS)
    {
        InventDimParm   inventDimParm;
        InventQtyPicked inventQtyPicked;

        if (_movement)
        {
            _movement.inventDimGroupSetup().inventDimParmActive(inventDimParm);

            inventQtyPicked = InventTransSum::newChildTypeInventDim().originPicked(
                    _movement.inventTransOriginId(), _movement.transChildType(), _movement.transChildRefId(), InventDim::find(_tmpInventTransWMS.InventDimId), inventDimParm);
        }

        return inventQtyPicked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickedQtyCW</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates how much has already been picked by the specified movement for the specified dimensions.
    /// </summary>
    /// <param name="_movement">
    /// The movement being picked.
    /// </param>
    /// <param name="_tmpInventTransWMS">
    /// A <c>TmpInventTransWMS</c> record.
    /// </param>
    /// <returns>
    /// A real value that represents a catch weight quantity.
    /// </returns>
    protected InventQtyPicked pickedQtyCW(
        InventMovement    _movement,
        TmpInventTransWMS _tmpInventTransWMS)
    {
        InventDimParm   inventDimParm;
        InventQtyPicked inventQtyPickedCW;

        if (_movement)
        {
            _movement.inventDimGroupSetup().inventDimParmActive(inventDimParm);

            inventQtyPickedCW = InventTransSum::newChildTypeInventDim().pdsCWidPicked(
                    _movement.inventTransOriginId(), _movement.transChildType(), _movement.transChildRefId(), InventDim::find(_tmpInventTransWMS.InventDimId), inventDimParm);
        }

        return inventQtyPickedCW;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickRemain</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the quantity that is not picked yet.
    /// </summary>
    /// <param name="_movement">
    ///    The inventory movement that is currently being picked.
    /// The inventory movement currently being picked.
    /// </param>
    /// <param name="_inventTransOriginId">
    /// The <c>InventTransOrigin</c> record ID related to the inventory movement.
    /// </param>
    /// <returns>
    ///    A quantity in the inventory unit of measure.
    /// </returns>
    protected InventQtyPickRemain pickRemain(
        InventMovement      _movement,
        InventTransOriginId _inventTransOriginId = 0)
    {
        InventTransOriginId inventTransOriginId = _inventTransOriginId;

        if (!_movement)
        {
            return 0;
        }

        if (!inventTransOriginId)
        {
            inventTransOriginId = _movement.inventTransOriginId();
        }

        return - _movement.transIdSum().onOrder()
               - _movement.transIdSum().reserveOrdered()
               - _movement.transIdSum().reservPhysical()
               - this.getSelectedQty(inventTransOriginId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickRemainCW</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the catch weight quantity that is not picked yet.
    /// </summary>
    /// <param name="_movement">
    /// The inventory movement that is currently being picked.
    /// </param>
    /// <param name="_inventTransOriginId">
    /// The <c>InventTransOrigin</c> record ID related to the inventory movement.
    /// </param>
    /// <returns>
    /// A real value that represents a catch weight quantity.
    /// </returns>
    protected PdsCWPickRemain pickRemainCW(
        InventMovement      _movement,
        InventTransOriginId _inventTransOriginId = 0)
    {
        InventTransOriginId inventTransOriginId = _inventTransOriginId;

        if (!_movement)
        {
            return 0;
        }

        if (!inventTransOriginId)
        {
            inventTransOriginId = _movement.inventTransOriginId();
        }

        InventTransIdSum inventTransIdSum = _movement.transIdSum();

        return - inventTransIdSum.pdsCWOnOrder()
               - inventTransIdSum.pdsCWReserveOrdered()
               - inventTransIdSum.pdsCWReservPhysical()
               - this.getSelectedQtyCW(inventTransOriginId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a <c>Query</c> object that can be used to find inventory transactions that can be added to
    ///    the pending records tables.
    /// </summary>
    /// <param name="_tmpInventTransWMS">
    ///    A <c>TmpInventTransWMS</c> record.
    /// </param>
    /// <returns>
    ///    A <c>Query</c> object.
    /// </returns>
    protected Query queryInventTrans(TmpInventTransWMS _tmpInventTransWMS)
    {
        QueryBuildRange             qbr;
        Query                       query = new Query(baseQueryInventTrans);

        //inventTransOrigin ranges
        QueryBuildDataSource qbds = query.dataSourceTable(tableNum(InventTransOrigin));

        if (_tmpInventTransWMS.ReferenceId)
        {
            qbr = qbds.addRange(fieldNum(InventTransOrigin,ReferenceId));
            qbr.value(queryValue(_tmpInventTransWMS.ReferenceId));
        }
        if (_tmpInventTransWMS.ItemId)
        {
            qbr = qbds.addRange(fieldNum(InventTransOrigin,ItemId));
            qbr.value(queryValue(_tmpInventTransWMS.ItemId));
        }

        //inventDim ranges
        //all given dimensions must either match or be blank. sort descending.
        if (_tmpInventTransWMS.InventDimId != InventDim::inventDimIdBlank())
        {
            InventDim inventDim = InventDim::find(_tmpInventTransWMS.InventDimId);
            qbds = query.dataSourceTable(tableNum(InventDim));
            List dimActiveFields = InventDimGroupSetup::newItemId(_tmpInventTransWMS.ItemId).activeFields();
            ListEnumerator enumerator = dimActiveFields.getEnumerator();

            while (enumerator.moveNext())
            {
                FieldId dimFieldId = enumerator.current();
                if (inventDim.(dimFieldId))
                {
                    qbr = qbds.addRange(dimFieldId);
                    qbr.value(queryValue(inventDim.(dimFieldId)));
                    qbr = qbds.addRange(dimFieldId);
                    qbr.value(queryValue(''));
                }
                qbds.addOrderByField(dimFieldId,SortOrder::Descending);
            }
        }

        //inventTrans ranges
        qbds = query.dataSourceTable(tableNum(InventTrans));
        qbds.addOrderByField(fieldNum(InventTrans,Qty),SortOrder::Descending);

        qbr = qbds.findRange(fieldNum(InventTrans,StatusIssue));
        while (qbr)
        {
            qbds.clearRange(fieldNum(InventTrans,StatusIssue));
            qbr = qbds.findRange(fieldNum(InventTrans,StatusIssue));
        }

        if (_tmpInventTransWMS.InventQty < 0)
        {
            qbr = qbds.addRange(fieldNum(InventTrans,StatusIssue));
            qbr.value(queryValue(StatusIssue::Picked));
        }
        else
        {
            qbr = qbds.addRange(fieldNum(InventTrans,StatusIssue));
            qbr.value(queryValue(StatusIssue::OnOrder));
            qbr = qbds.addRange(fieldNum(InventTrans,StatusIssue));
            qbr.value(queryValue(StatusIssue::ReservPhysical));
            qbr = qbds.addRange(fieldNum(InventTrans,StatusIssue));
            qbr.value(queryValue(StatusIssue::ReservOrdered));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSelectedQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets detail information for a pending record.
    /// </summary>
    /// <param name="_tmpInventTransWMS">
    /// A <c>TmpInventTransWMS</c> record.
    /// </param>
    /// <param name="_inventTrans">
    /// A <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventDim">
    /// The <c>InvenDim</c> record related to the inventory transaction.
    /// </param>
    /// <param name="_inventQty">
    /// The quantity to set.
    /// </param>
    /// <param name="_inventQtyIsDelta">
    /// A Boolean value that indicates whether the specified quantity is a delta or total quantity.
    /// </param>
    /// <param name="_inventQtyCW">
    /// The catch weight quantity to set.
    /// </param>
    /// <returns>
    /// true if the quantity was set successfully; otherwise, false.
    /// </returns>
    /// Sets detail information for a pending record.
    protected boolean setSelectedQty(
        TmpInventTransWMS _tmpInventTransWMS,
        InventTrans       _inventTrans,
        InventDim         _inventDim,
        InventQty         _inventQty,
        boolean           _inventQtyIsDelta = false,
        PdsCWInventQty    _inventQtyCW = 0)
    {
        InventQty   inventQtyDelta;
        InventQty   inventQtyOrig;

        PdsCWInventQty   inventQtyDeltaCW;
        PdsCWInventQty   inventQtyOrigCW;

        boolean result = super(_tmpInventTransWMS, _inventTrans, _inventDim, _inventQty, _inventQtyIsDelta, _inventQtyCW
        );

        if (result)
        {
            if (!_inventQtyIsDelta)
            {
                Map map = this.mapQtyByTmpInventTransWMSInventTrans(_tmpInventTransWMS.RecId);
                if (map && map.exists(_inventTrans.RecId))
                {
                    [inventQtyOrig,inventQtyOrigCW] = map.lookup(_inventTrans.RecId);
                }
                inventQtyDelta      = _inventQty - inventQtyOrig;
                inventQtyDeltaCW    = _inventQtyCW - inventQtyOrigCW;
            }
            else
            {
                inventQtyDelta      = _inventQty;
                inventQtyDeltaCW    = _inventQtyCW;
            }

            //total by item, inventDimId
            InventQty updatedInventQty = inventQtyDelta;
            PdsCWInventQty updatedInventQtyCW = inventQtyDeltaCW;
            if (mapQtyByItemInventDimId.exists([_inventTrans.ItemId,_tmpInventTransWMS.InventDimId]))
            {
                updatedInventQty += conPeek(mapQtyByItemInventDimId.lookup([_inventTrans.ItemId,_tmpInventTransWMS.InventDimId]),#InventQtyIdx);
                updatedInventQtyCW += conPeek(mapQtyByItemInventDimId.lookup([_inventTrans.ItemId,_tmpInventTransWMS.InventDimId]),#InventQtyCWIdx);
                if (!updatedInventQty && !updatedInventQtyCW)
                {
                    mapQtyByItemInventDimId.remove([_inventTrans.ItemId,_tmpInventTransWMS.InventDimId]);
                }
            }
            if (updatedInventQty || updatedInventQtyCW)
            {
                mapQtyByItemInventDimId.insert([_inventTrans.ItemId,_tmpInventTransWMS.InventDimId],[updatedInventQty,updatedInventQtyCW]);
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts the pending picking records to actual updates.
    /// </summary>
    /// <returns>
    ///    true if the update succeeded; otherwise, false.
    /// </returns>
    public boolean updateInvent()
    {
        boolean result = InventTransWMS_Pick::updateInventServer(tmpInventTransWMS,mapQtyByTmpInventTransWMS.pack(),mapInventTransInventTransOrigin.pack());

        this.initSelectedQty();
        this.initAvailableQuantity();

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the quantity of a pending record.
    /// </summary>
    /// <param name="_tmpInventTransWMS">
    /// A <c>TmpInventTransWMS</c> record.
    /// </param>
    /// <returns>
    /// true if the quantity was updated successfully; otherwise, false.
    /// </returns>
    protected boolean updateQuantity(TmpInventTransWMS _tmpInventTransWMS)
    {
        InventQty               inventQty;
        InventQty               qtyNow;
        boolean                 showWarning = true;
        boolean                 result      = true;

        PdsCWInventQty          inventQtyCW;
        PdsCWInventQty          qtyNowCW;

        if (_tmpInventTransWMS.orig())
        {
            InventQty qtyRemain = _tmpInventTransWMS.InventQty - _tmpInventTransWMS.orig().InventQty;

            PdsCWInventQty qtyRemainCW = _tmpInventTransWMS.PdsCWQty - _tmpInventTransWMS.orig().PdsCWQty;

            if (qtyRemain || qtyRemainCW)
            {
                this.beginTmpInventTransWMS(_tmpInventTransWMS);

                Map map = this.mapQtyByTmpInventTransWMSInventTrans(_tmpInventTransWMS.RecId,true);

                if (   map
                    && map.elements())
                {
                    MapEnumerator me = map.getEnumerator();
                    while (me.moveNext() && qtyRemain)
                    {
                        [inventQty, inventQtyCW] = me.currentValue();
                        InventTrans         inventTrans         = InventTrans::findRecId(me.currentKey());
                        InventMovement      inventMovement      = InventTransWMS_Pick::inventMovement(inventTrans);
                        InventTransOriginId inventTransOriginId = inventTrans.InventTransOrigin;

                        if (PdsGlobal::pdsIsCWItem(inventTrans.ItemId))
                        {
                            //pick
                            if (_tmpInventTransWMS.PdsCWQty > 0)
                            {
                                //pick more
                                if (qtyRemainCW > 0)
                                {
                                    qtyNowCW = min(this.pickRemainCW(inventMovement,inventTransOriginId),qtyRemainCW);
                                }
                                else
                                {
                                    //pick less
                                    qtyNowCW = max(-inventQtyCW,qtyRemainCW);
                                }
                            }
                            //reverse
                            else
                            {
                                //reverse more
                                if (qtyRemainCW < 0)
                                {
                                    qtyNowCW = max(this.pickedQtyCW(inventMovement,_tmpInventTransWMS.orig())-this.getSelectedQtyCW(inventTransOriginId),qtyRemainCW);
                                }
                                else
                                {
                                    //reverse less
                                    qtyNowCW = min(-inventQtyCW,qtyRemainCW);
                                }
                            }
                        }

                        //pick
                        if (_tmpInventTransWMS.InventQty > 0)
                        {
                            //pick more
                            if (qtyRemain > 0)
                            {
                                qtyNow = min(this.pickRemain(inventMovement,inventTransOriginId),qtyRemain);
                            }
                            else
                            {
                                //pick less
                                qtyNow = max(-inventQty,qtyRemain);
                            }
                        }
                        //reverse
                        else
                        {
                            //reverse more
                            if (qtyRemain < 0)
                            {
                                qtyNow = max(this.pickedQty(inventMovement,_tmpInventTransWMS.orig())-this.getSelectedQty(inventTransOriginId),qtyRemain);
                            }
                            else
                            {
                                //reverse less
                                qtyNow = min(-inventQty,qtyRemain);
                            }
                        }

                        if (qtyNow || qtyNowCW)
                        {
                            result = this.setSelectedQty(_tmpInventTransWMS, inventTrans, null, qtyNow,true, qtyNowCW);

                            if (result)
                            {
                                qtyRemain -= qtyNow;
                                qtyRemainCW -= qtyNowCW;
                            }
                        }
                    }
                }

                if (PdsGlobal::pdsIsCWItem(_tmpInventTransWMS.ItemId))
                {
                    if (   result
                        && ((qtyRemainCW && _tmpInventTransWMS.PdsCWQty * qtyRemainCW > 0)
                        ||  (qtyRemain && _tmpInventTransWMS.InventQty * qtyRemain > 0))
                        && !_tmpInventTransWMS.ReferenceId)
                    {
                        //try to add additional transactions
                        result      = this.addInventTrans(_tmpInventTransWMS,qtyRemain,qtyRemainCW);
                        showWarning = result;
                    }
                    else
                    {
                        result = result && qtyRemainCW == 0;
                    }
                }
                else
                {
                    if (   result
                        && qtyRemain
                        && (_tmpInventTransWMS.InventQty * qtyRemain) > 0   //pick or reverze more
                        && !_tmpInventTransWMS.ReferenceId)
                    {
                        //try to add additional transactions
                        result      = this.addInventTrans(_tmpInventTransWMS,qtyRemain);
                        showWarning = result;
                    }
                    else
                    {
                        result =    result
                                    && qtyRemain == 0;
                    }
                }

                if (!result)
                {
                    this.abortTmpInventTransWMS();
                    if (qtyRemainCW)
                    {
                        result = showWarning ? checkFailed(strFmt("@SYS324606",qtyRemainCW)) : false;
                    }
                    else
                    {
                        result = showWarning ? checkFailed(strFmt("@SYS324606",qtyRemain)) : false;
                    }
                }
                else
                {
                    this.commitTmpInventTransWMS();
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the proposed change to a pending record is valid.
    /// </summary>
    /// <param name="_inventQty">
    ///    The pending quantity.
    /// </param>
    /// <param name="_inventQtyOrig">
    ///    The original pending quantity.
    /// </param>
    /// <param name="_tmpInventTransWMS">
    ///    The pending record.
    /// </param>
    /// <param name="_movement">
    ///    The inventory movement related to the pending record.
    /// </param>
    /// <param name="_inventTransOriginId">
    ///    The <c>InventTransOrigin</c> record ID related to the movement.
    /// </param>
    /// <param name="_inventDim">
    ///    The inventory dimension related to the pending record.
    /// </param>
    /// <param name="_inventQtyCW">
    /// The pending catch weight quantity.
    /// </param>
    /// <param name="_inventQtyOrigCW">
    /// The original pending catch weight quantity.
    /// </param>
    /// <returns>
    ///    true if validation succeeds; otherwise, false.
    /// </returns>
    protected boolean validateTmp(
        InventQty               _inventQty,
        InventQty               _inventQtyOrig,
        TmpInventTransWMS       _tmpInventTransWMS,
        InventMovement          _movement,
        InventTransOriginId     _inventTransOriginId = _movement.inventTransOriginId(),
        InventDim               _inventDim           = null,
        PdsCWInventQty          _inventQtyCW     = 0,
        PdsCWInventQty          _inventQtyOrigCW = 0)
    {
        if (PdsGlobal::pdsIsCWItem(_movement.itemId()))
        {
            PdsCWInventQty addQtyCw = _inventQtyCW - _inventQtyOrigCW;

            if (addQtyCw > 0 && !PdsCatchWeightItem::pdsCWIsValidQty(_movement.itemId(),_inventQty, _inventQtyCW))
            {
                return checkFailed(PdsCatchWeightItem::pdsCWErrorMsg(_movement.itemId(), _inventQtyCW));
            }

            if (_inventQtyCW * _inventQtyOrigCW < 0)
            {
                return checkFailed(strFmt("@SYS324605",_inventQtyOrigCW));
            }

            if (!_movement.overDeliveryPct())
            {
                if (addQtyCw > this.pickRemainCW(_movement,_inventTransOriginId))
                {
                    return checkFailed(strFmt("@SYS54880", this.pickRemainCW(_movement,_inventTransOriginId)));
                }
            }

            if (addQtyCw < 0)
            {
                if (this.getSelectedQtyCW(_inventTransOriginId) + addQtyCw < _movement.transIdSum().pdsCWPicked())
                {
                    return checkFailed(strFmt("@SYS53751", _movement.transIdSum().pdsCWPicked()));
                }
            }

            if (_inventQtyCW < 0)
            {
                if (-this.pickedQtyCW(_movement,_tmpInventTransWMS) + _inventQtyCW < 0)
                {
                    return checkFailed(strFmt("@SYS54887",-this.pickedQtyCW(_movement,_tmpInventTransWMS),-_inventQtyCW));
                }
            }
        }
        else
        {
            if (_inventQty * _inventQtyOrig < 0)
            {
                return checkFailed(strFmt("@SYS324605",_inventQtyOrig));
            }

            InventQty addQty = _inventQty - _inventQtyOrig;

            if (!_movement.overDeliveryPct())
            {
                if (addQty > this.pickRemain(_movement,_inventTransOriginId))
                {
                    return checkFailed(strFmt("@SYS54880", this.pickRemain(_movement,_inventTransOriginId)));
                }
            }

            if (addQty < 0)
            {
                if (this.getSelectedQty(_inventTransOriginId) + addQty < _movement.transIdSum().picked())
                {
                    return checkFailed(strFmt("@SYS53751", _movement.transIdSum().picked()));
                }
            }

            if (_inventQty < 0)
            {
                if (-this.pickedQty(_movement,_tmpInventTransWMS) + _inventQty < 0)
                {
                    return checkFailed(strFmt("@SYS54887",-this.pickedQty(_movement,_tmpInventTransWMS),-_inventQty));
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeTmpInventTransWMS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a record writes to the pending records table.
    /// </summary>
    /// <param name="_tmpInventTransWMS">
    /// A <c>TmpInventTransWMS</c> record.
    /// </param>
    /// <returns>
    /// true if the record was written successfully; otherwise, false .
    /// </returns>
    public boolean writeTmpInventTransWMS(TmpInventTransWMS _tmpInventTransWMS)
    {
        boolean         result = true;

        result = _tmpInventTransWMS.validateWrite();

        if (result)
        {
            //manually added line can span multiple movements
            if (!_tmpInventTransWMS.ReferenceId && !_tmpInventTransWMS.RecId)
            {
                result = this.addInventTrans(_tmpInventTransWMS);
            }
            else
            {
                if (_tmpInventTransWMS.RecId)
                {
                    result = this.updateQuantity(_tmpInventTransWMS);
                }
                else
                {
                    InventTrans inventTrans = InventTrans::findRecId(_tmpInventTransWMS.InventTrans);
                    result = inventTrans.RecId != 0
                                  && this.setSelectedQty(_tmpInventTransWMS, inventTrans, inventTrans.inventDim(), _tmpInventTransWMS.InventQty, false, _tmpInventTransWMS.PdsCWQty);
                }

                if (result)
                {
                    this.writeTmp(_tmpInventTransWMS);
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static InventTransWMS_Pick construct()
    {
        return new InventTransWMS_Pick();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the inventory movement that is currently being picked.
    /// </summary>
    /// <param name="_movementRecord">
    /// The record that is used when the picking form is called.
    /// </param>
    /// <returns>
    /// An inventory movement.
    /// </returns>
    public static InventMovement inventMovement(Common _movementRecord)
    {
        InventMovement              movement;
        Common                      movementRecord;

        switch (_movementRecord.TableId)
        {
            case tableNum(InventTrans):
                InventTrans inventTrans = _movementRecord;
                InventTransOrigin inventTransOrigin = inventTrans.inventTransOrigin();
                movementRecord = inventTransOrigin.originator();
                movement = inventTrans.inventMovementChild();
                break;
            case tableNum(InventTransOrigin):
                inventTransOrigin           = _movementRecord;
                movementRecord              = inventTransOrigin.originator();
                break;
            default:
                movementRecord              = _movementRecord;
        }

        if (movementRecord is InventQuarantineOrder)
        {
            InventQuarantineOrder inventQuarantineOrder = movementRecord as InventQuarantineOrder;
            movement = InventMovement::construct(inventQuarantineOrder,inventQuarantineOrder.getInventMovSubType(InventDirection::Issue));
        }

        if (!movement)
        {
            movement = InventMovement::construct(movementRecord);
        }

        return movement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>listCallerTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a list of movement originator records based on the form data source.
    /// </summary>
    /// <param name="_args">
    ///    An <c>Args</c> object.
    /// </param>
    /// <returns>
    ///    A <c>List</c> object that contains all movement originator records that must be shown in the form.
    /// </returns>
    /// <remarks>
    ///    In case the form data source is a <c>kanbanBoardTmpProcessJob</c> table, we show all related
    ///    picking list lines.
    /// </remarks>
    public static List listCallerTable(Args _args)
    {
        Common                      callerTable;
        KanbanJobPickingList        kanbanJobPickingList;
        List                        list = new List(Types::Record);

        if (_args)
        {
            if (   _args.record()
                && FormDataUtil::getFormDataSource(_args.record()))
            {
                // get list of records from form datasource
                FormDataSource formDataSource = FormDataUtil::getFormDataSource(_args.record());

                for (callerTable = formDataSource.getFirst(true) ? formDataSource.getFirst(true) : formDataSource.cursor();
                     callerTable;
                     callerTable = formDataSource.getNext())
                {
                    if (callerTable is KanbanBoardTmpProcessJob)
                    {
                        KanbanBoardTmpProcessJob kanbanBoardTmpProcessJob = callerTable as KanbanBoardTmpProcessJob;

                        while select kanbanJobPickingList
                            where kanbanJobPickingList.Job           == kanbanBoardTmpProcessJob.Job
                               && kanbanJobPickingList.InventTransId != ''
                        {
                            list.addEnd(kanbanJobPickingList);
                        }
                    }
                    else
                    {
                        list.addEnd(callerTable);
                    }
                }
            }
            else
            {
                if (_args.caller())
                {
                    // check if caller is a class and has a packListInventTransPick() method
                    // if so, get list of records from class
                    SysDictClass sysDictClass = new SysDictClass(classIdGet(_args.caller()));

                    if (sysDictClass && sysDictClass.hasObjectMethod(identifierStr(packedList)))
                    {
                        container packedList = _args.caller().packedList();
                        list = List::create(packedList);
                    }
                }
            }
        }

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newStandard</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates a new <c>InventTransWMS_Pick</c> object.
    /// </summary>
    /// <param name="_tmpInventTransWMS">
    ///    A handle for the temporary table that holds pending records.
    /// </param>
    /// <param name="_baseQueryInventTrans">
    ///    A <c>Query</c> object.
    /// </param>
    /// <returns>
    ///    A <c>InventTransWMS_Pick</c> object.
    /// </returns>
    public static InventTransWMS_Pick newStandard(
        TmpInventTransWMS       _tmpInventTransWMS,
        Query                   _baseQueryInventTrans)
    {
        InventTransWMS_Pick inventTransWMS_Pick = InventTransWMS_Pick::construct();

        inventTransWMS_Pick.parmTmpInventTransWMS(_tmpInventTransWMS);
        inventTransWMS_Pick.parmBaseQueryInventTrans(_baseQueryInventTrans);
        inventTransWMS_Pick.init();

        return inventTransWMS_Pick;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the pending picking records to actual updates.
    /// </summary>
    /// <param name="_tmpInventTransWMS">
    /// The <c>TmpInventTransWMS</c> table containing pending changes to temporary table.
    /// </param>
    /// <param name="_mapQtyByTmpInventTransWMSPacked">
    /// A packed map that contains detail information to the pending records.
    /// </param>
    /// <param name="_mapInventTransInventTransOriginPacked">
    /// A packed map that contains inventory transaction to origin mapping.
    /// </param>
    /// <returns>
    /// true if the update succeeded; otherwise, false.
    /// </returns>
    protected static boolean updateInventServer(
        TmpInventTransWMS       _tmpInventTransWMS,
        container               _mapQtyByTmpInventTransWMSPacked,
        container               _mapInventTransInventTransOriginPacked)
    {
        boolean             result = false;        
        TmpInventTransWMS   tmpInventTransWMS;

        try
        {            
            tmpInventTransWMS.setTmpData(_tmpInventTransWMS);

            ttsbegin;
            tmpInventTransWMS.ttsbegin();

            List pickList = new List(Types::Container);

            if (InventTransWMS::prepareUpdateInvent(_tmpInventTransWMS,_mapQtyByTmpInventTransWMSPacked,_mapInventTransInventTransOriginPacked))
            {
                //pick / unpick
                InventTrans inventTrans;
                while select tmpInventTransWMS
                    order by InventTransOrigin, InventQty
                    join inventTrans
                        where inventTrans.RecId == tmpInventTransWMS.InventTrans
                {
                    pickList.addEnd([tmpInventTransWMS, inventTrans]);
                }

                boolean             throwWarning        = false;
                ListEnumerator      pickListEnumerator  = pickList.getEnumerator();
                TmpInventTransWMS   tmpInventTransWMSRecord;                

                // Remove order committed reservations with mandatory flexible inventory dimensions that match the picking lines dimensions.
                // Instead of doing it before each picking line, do it for all picking lines at once.
                // This is necessary to avoid stock shortages if the reservation is cancelled and picking is done line by line.
                while (pickListEnumerator.moveNext())
                {
                    [tmpInventTransWMSRecord, inventTrans] = pickListEnumerator.current();

                    InventTransWMS_Pick::removeOrderCommittedReservation(tmpInventTransWMSRecord, inventTrans, true, false);
                }

                pickListEnumerator.reset();

                while (pickListEnumerator.moveNext())
                {
                    [tmpInventTransWMSRecord, inventTrans] = pickListEnumerator.current();

                    // There is a possibility that a picking update may recreate related InventTrans records. In that case select again.
                    // e.g. this can happen when triggering adjustment logic on CW items
                    InventTrans inventTransRecord;
                    if (!InventTrans::existRecId(inventTrans.RecId))
                    {
                        // The selection criteria is a minimal criteria to create a valid movement object.
                        select firstOnly inventTransRecord where
                            inventTransRecord.StatusIssue >= StatusIssue::ReservPhysical &&
                            inventTransRecord.TransChildRefId == inventTrans.TransChildRefId &&
                            inventTransRecord.TransChildType == inventTrans.TransChildType &&
                            inventTransRecord.InventTransOrigin == inventTrans.InventTransOrigin;
                    }
                    else
                    {
                        inventTransRecord = inventTrans;
                    }

                    InventMovement movement;
                    InventDimParm  inventDimParm;
                    if (!movement ||
                        movement.inventTransOriginId() != inventTransRecord.InventTransOrigin ||
                        movement.transChildRefId() != inventTransRecord.TransChildRefId ||
                        movement.transChildType() != inventTransRecord.TransChildType)
                    {
                        movement = InventTransWMS_Pick::inventMovement(inventTransRecord);
                        movement.inventDimGroupSetup().inventDimParmActive(inventDimParm);
                    }
                    // Remove order committed reservation with mandatory flexible inventory dimensions that do not match the picking line dimensions
                    InventTransWMS_Pick::removeOrderCommittedReservation(tmpInventTransWMSRecord, inventTrans, false);

                    InventTransWMS_Pick::updateInventoryPicked(tmpInventTransWMSRecord, movement, inventDimParm);

                    InventTrans         cwOnhandAdjustInventTrans;
                    InventTransOrigin   cwOnhandAdjustInventTransOrigin;                    
                    if (!throwWarning
                        &&  tmpInventTransWMSRecord.PdsCWQty < 0)
                    {
                        select firstOnly RecId from cwOnhandAdjustInventTrans
                        where cwOnhandAdjustInventTrans.PdsCWQty == 0
                            && cwOnhandAdjustInventTrans.Qty > 0
                            // On-hand adjustment transaction of catch weight should have the same inventory dimension as previous picked transaction
                            && cwOnhandAdjustInventTrans.inventDimId   == inventTransRecord.InventDimId
                            && cwOnhandAdjustInventTrans.StatusReceipt == StatusReceipt::Purchased
                            && cwOnhandAdjustInventTrans.StatusIssue   == StatusIssue::None
                            && cwOnhandAdjustInventTrans.ItemId        == tmpInventTransWMSRecord.ItemId
                        exists join cwOnhandAdjustInventTransOrigin
                            where cwOnhandAdjustInventTransOrigin.RecId             == cwOnhandAdjustInventTrans.InventTransOrigin
                               && cwOnhandAdjustInventTransOrigin.ReferenceCategory == InventTransType::InventTransaction;

                        throwWarning = cwOnhandAdjustInventTrans.RecId != 0;
                        if (throwWarning)
                        {
                            warning("@SCM:ReservedPickOfCWItem");
                        }
                    }
                }

                result = true;
            }

            tmpInventTransWMS.ttscommit();
            ttscommit;
        }
        catch (Exception::Error)
        {
            tmpInventTransWMS.ttsabort();
        }

        TmpInventTransWMS::makeTableEmpty(tmpInventTransWMS);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeOrderCommittedReservation</Name>
				<Source><![CDATA[
    private static void removeOrderCommittedReservation(
        TmpInventTransWMS _tmpInventTransWMSRecord, 
        InventTrans _inventTrans, 
        boolean _removeForGivenDimensions = true,
        boolean _removeForOtherDimensions = true)
    {
        if (WHSReservationHierarchyElementPolicyProvider::singleton().isReservationOnDemandOrderEnabled(InventTable::find(_tmpInventTransWMSRecord.ItemId).whsReservationHierarchy(), fieldNum(InventDim, inventBatchId)))
        {
            var committingOriginInventTransId = _inventTrans.inventTransOrigin().InventTransId;
            WHSOrderCommittedReservation orderCommittedReservation = WHSOrderCommittedReservation::findByCommittingOriginInventTransId(committingOriginInventTransId);

            if (orderCommittedReservation && _tmpInventTransWMSRecord.InventQty > 0)
            {
                Map dimAndQtyMap = WHSOrderCommittedReservationFacade::createOrderCommittedReservationMap(committingOriginInventTransId);
                Map dimAndQtyMapNotPickDimensions = new Map(extendedTypeId2Type(extendedTypeNum(InventDimId)), extendedTypeId2Type(extendedTypeNum(InventQty)));

                InventQty remainQty = _tmpInventTransWMSRecord.InventQty;
                InventQty orderCommittedForOtherDimensions, orderCommittedForCurrentDim;
                InventDimId mandatoryOrderCommittedInventDimId, mandatoryPickInventDimId;

                MapEnumerator me = dimAndQtyMap.getEnumerator();

                mandatoryPickInventDimId = WHSOrderCommittedReservationFacade::extractMandatoryInventoryDimensions(_tmpInventTransWMSRecord.ItemId, _tmpInventTransWMSRecord.InventDimId);
                
                while (remainQty && me.moveNext())
                {
                    mandatoryOrderCommittedInventDimId = WHSOrderCommittedReservationFacade::extractMandatoryInventoryDimensions(_tmpInventTransWMSRecord.ItemId, me.currentKey());

                    if (mandatoryOrderCommittedInventDimId == mandatoryPickInventDimId)
                    {
                        if (_removeForGivenDimensions)
                        {
                            var qtyToAdjust = min(me.currentValue(), remainQty);

                            InventTransWMS_Pick::updateOrderCommittedReservationAndTransferred(
                                            committingOriginInventTransId,
                                            mandatoryOrderCommittedInventDimId,
                                            -qtyToAdjust,
                                            orderCommittedReservation.RecId);

                            remainQty -= qtyToAdjust;
                            orderCommittedForCurrentDim += qtyToAdjust;
                        }
                    }
                    else 
                    {
                        if (_removeForOtherDimensions)
                        {
                            orderCommittedForOtherDimensions += me.currentValue();

                            InventQty committedForMandatoryDimensions = me.currentValue();

                            if (dimAndQtyMapNotPickDimensions.exists(mandatoryOrderCommittedInventDimId))
                            {
                                committedForMandatoryDimensions += dimAndQtyMapNotPickDimensions.lookup(mandatoryOrderCommittedInventDimId);
                            }

                            dimAndQtyMapNotPickDimensions.insert(mandatoryOrderCommittedInventDimId, committedForMandatoryDimensions);
                        }
                    }
                }

                if (_removeForOtherDimensions && remainQty)
                {
                    InventTrans sourceLineInventTrans;
                    InventTransOrigin sourceLineInventTransOrigin;

                    select sum(Qty) from sourceLineInventTrans
                        where sourceLineInventTrans.StatusIssue == StatusIssue::OnOrder
                           || sourceLineInventTrans.StatusIssue == StatusIssue::ReservPhysical
                        exists join sourceLineInventTransOrigin
                            where sourceLineInventTransOrigin.InventTransId == committingOriginInventTransId
                               && sourceLineInventTransOrigin.RecId == sourceLineInventTrans.InventTransOrigin;

                    InventQty qtyLeftUnpicked = -sourceLineInventTrans.Qty - remainQty - orderCommittedForCurrentDim;
                    if (qtyLeftUnpicked < orderCommittedForOtherDimensions)
                    {
                        InventQty orderCommittedQtyToRemove = orderCommittedForOtherDimensions - qtyLeftUnpicked;

                        me = dimAndQtyMapNotPickDimensions.getEnumerator();
                        while (me.moveNext())
                        {
                            if (orderCommittedQtyToRemove && me.currentKey() != mandatoryPickInventDimId)
                            {
                                var qtyToAdjust = min(me.currentValue(), orderCommittedQtyToRemove);

                                InventTransWMS_Pick::updateOrderCommittedReservationAndTransferred(
                                    committingOriginInventTransId,
                                    me.currentKey(),
                                    -qtyToAdjust, 
                                    orderCommittedReservation.RecId);

                                orderCommittedQtyToRemove -= qtyToAdjust;
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrderCommittedReservationAndTransferred</Name>
				<Source><![CDATA[
    private static void updateOrderCommittedReservationAndTransferred(InventTransId _committingOriginInventTransId, InventDimId _inventDimId, InventQty _qty, RefRecId _orderCommittedRecId)
    {
        WHSOrderCommittedReservationFacade::updateOrderCommittedReservation(
                                            _committingOriginInventTransId,
                                            _inventDimId,
                                            _qty,
                                            WHSOrderCommittedReservationFacade::ExecuteNow,
                                            WHSOrderCommittedReservationFacade::DoNotAllowReserveReduction);

        WHSOrderCommittedReservationFacade::updateTransferReservation(
                                                _orderCommittedRecId,
                                                _qty,
                                                _inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryPicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the picked inventory.
    /// </summary>
    /// <param name = "_tmpInventTransWMSRecord">An instance of the <c>TmpInventTransWMS</c> record.</param>
    /// <param name = "_movement">An instance of the <c>InventMovement</c> record.</param>
    /// <param name = "_inventDimParm">An instance of the <c>InventDimParm</c> record.</param>
    protected static void updateInventoryPicked(
        TmpInventTransWMS   _tmpInventTransWMSRecord,
        InventMovement      _movement,
        InventDimParm       _inventDimParm)
    {
        InventDim inventDim = InventDim::find(_tmpInventTransWMSRecord.InventDimId);

        setPrefix(inventDim.preFix());

        InventUpd_Picked picked = InventUpd_Picked::newParameters(
                        _movement,
                        inventDim,
                        _inventDimParm,
                        inventDim,
                        _inventDimParm,
                        -_tmpInventTransWMSRecord.InventQty,
                        '',
                        -_tmpInventTransWMSRecord.PdsCWQty);

        picked.updateNow();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>