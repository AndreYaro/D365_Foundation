<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustAccountStatementExtController</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>CustAccountStatementExtController</c> class is the controller class for the
///    <c>CustAccountStatementExt</c> report.
/// </summary>
public class CustAccountStatementExtController extends GiroPrintMgmtFormLetterController implements BatchRetryable, ERIDestinationAwareController
{
    #define.currencyCHF('CHF')
    #define.currencyEUR('EUR')

    //Dialog
    NoYes batchMultiThread;
    DialogField fieldBatchMultiThreading;

    CustAccountStatementExtTmp custAccountStatementExtTmp;
    CustAccountStatementExtContract contract;
    CreatedTransactionId createdTransactionId;

    // dialog related
    boolean printAmountOnGiro;
    boolean onlyOpen;
    boolean includeReversed;
    boolean printNotZero;
    boolean insertSpecifyDueDate;
    boolean insertCompanyLogo;
    boolean includeCompanyLogo;
    boolean cleanUpData;

    PaymentStub printGiro;

    TransDate specifyDueToDate;
    private boolean singleCurrencyReport;

    boolean printPaymentSchedule;

    // <GCN>
    #ISOCountryRegionCodes

    boolean isTaxIntegrateEnable_CN;
    // </GCN>

    //
    //  AGING FIELDS
    //
    // NOTE: Only one of the following can be TRUE: either manually or predefined aging, never both but possibly neither
    boolean showAging; // Is any aging shown at all?

    NoYes useAgingDefinition; // use predefined aging else use manually defined aging

    CustVendAgingBucketLookUp agingDefinition; // predefined aging definition name
    boolean showAgingDescription; // print the aging period description?

    PositiveDays manualAgingInterval;
    DayMonth manualAgingDayMonth;
    ForwardBackwardPrinting manualAgingDirection;

    // global tables
    CustTrans currentTrans;
    CustTable currentCust;
    CustName currentCustName;
    LogisticsAddressing currentCustAddress;
    CustTable currentStatementCust;
    CompanyInfo statementCompanyInfo;
    TmpCustVendTrans tmpCustVendTrans;
    TmpCustVendTransOpen tmpCustVendTransOpen;
    CustTmpAccountSum custSummary;

    // Giro
    PaymMoneyTransferSlip moneyTransferSlip;
    PaymMoneyTransferSlip_CH moneyTransferSlip_CH;
    PaymMoneyTransferSlip_BE moneyTransferSlip_BE;
    ReportSection giro_Section;

    // global classes
    CustBalanceList custBalanceList;

    boolean haveNonStatementCust;
    boolean isTransactionHeaderPrinted;
    boolean markForPaymentSchedulePrinted;
    AmountMST balanceMST;
    int numberOfTransOpen;
    CompanyId statementCompany;

    TransDate statementStartDate;
    TransDate statementEndDate;

    // customer specific
    container custCurrencyList;
    AmountCur custBalanceCur[];
    AmountCur openingBalance;
    AmountCur closingBalance;
    int64 custTransCount;

    // statement specific
    container statementCurrencyList;
    AmountCur statementBalanceCur[];

    boolean transHeading;
    boolean cust_Trans;
    boolean custPre;
    boolean vendTransOpen;
    boolean openBal;
    boolean multiCompany;
    boolean closeBal;
    boolean agingHead;
    boolean printAgingDescription;
    boolean summary;
    boolean initialPreRunValidate;
    LanguageId languageId;

    private CBDDestinationsController cbdDestinationsController = CBDDestinationsController::tryCreateInstance();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>batchParentQuery</Name>
				<Source><![CDATA[
    protected Query batchParentQuery()
    {
        Query parentQuery = super();
        parentQuery.allowCrossCompany(false);
        return parentQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canMultithread</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets <c>UseMultithread</c> value of the <c>CustAccountStatementExtContract</c> class.
    /// </summary>
    /// <returns>A boolean value which contains user input on whether the report printing should run in multiple threads for the current run.</returns>
    protected boolean canMultithread()
    {
        return this.parmContract().parmUseMultithread();
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNo2_CH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>AcrcountNo2_CH</c> value of the <c>PaymMoneyTransferSlilp_CH</c> class.
    /// </summary>
    /// <returns>
    /// A String that contains the <c>AccountNo2_CH</c> value.
    /// </returns>
    private str accountNo2_CH()
    {
        if (moneyTransferSlip_CH.ocr_AccountNo2())
        {
            return moneyTransferSlip_CH.ocr_AccountNo2() + '>';
        }
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountCheckId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>AmountCheckId</c> value of the <c>PaymMoneyTransferSlip</c> class.
    /// </summary>
    /// <returns>
    /// A String that contains the <c>AmountCheckId</c> value.
    /// </returns>
    private str amountCheckId()
    {
        if (printAmountOnGiro && currentCust.Currency == Ledger::accountingCurrency(statementCompanyInfo.RecId))
        {
            return moneyTransferSlip.amountCheckId(balanceMST);
        }
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountCurCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the credit portion of the <c>AmountCur</c> value.
    /// </summary>
    /// <returns>
    ///    The credit portion of the <c>AmountCur</c> value.
    /// </returns>
    private AmountCur amountCurCredit()
    {
        AmountCur amount = onlyOpen ? currentTrans.remainAmountCur() : currentTrans.AmountCur;

        return amount < 0 ? amount : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountCurDebit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the debit portion of the <c>AmountCur</c> value.
    /// </summary>
    /// <returns>
    ///    The debit portion of the <c>AmountCur</c> value.
    /// </returns>
    private AmountCur amountCurDebit()
    {
        AmountCur amount = onlyOpen ? currentTrans.remainAmountCur() : currentTrans.AmountCur;

        return amount > 0 ? amount : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountDecimals_CH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the credit portion of the <c>invoiceAmountDecimals</c> value.
    /// </summary>
    /// <returns>
    /// A String that contains the <c>invoiceAmountDecimals</c> value.
    /// </returns>
    private str amountDecimals_CH()
    {
        if (printAmountOnGiro && conLen(custCurrencyList) <= 1)
        {
            if (currentCust.Currency != Ledger::accountingCurrency(statementCompanyInfo.RecId) || balanceMST < 0)
            {
                return 'XX';
            }
            else
            {
                return this.invoiceAmountDecimals();
            }
        }
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountNoDecimals_CH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the credit portion of the <c>invoiceAmountNoDecimals</c> value.
    /// </summary>
    /// <returns>
    /// A String that contains the <c>invoiceAmountDecimals</c> value.
    /// </returns>
    private str amountNoDecimals_CH()
    {
        if (currentCust.Currency == Ledger::accountingCurrency(statementCompanyInfo.RecId))
        {
            return this.invoiceAmountNoDecimals();
        }
        return strRep('x', 8);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankGroupIdName_CH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the name value of the <c>BankAccountTable</c> table.
    /// </summary>
    /// <returns>
    ///     The name value of the <c>BankAccountTable</c> table.
    /// </returns>
    protected Name bankGroupIdName_CH()
    {
        return printGiro == PaymentStub::ESR_red_bank ? BankAccountTable::find(currentCust.BankAccount).Name : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankZipCode_CH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the bank postal address zipcode value.
    /// </summary>
    /// <returns>
    ///     The bank postal address zipcode value.
    /// </returns>
    protected AddressZipCodeId bankZipCode_CH()
    {
        return printGiro == PaymentStub::ESR_red_bank ?
                BankAccountTable::find(currentCust.BankAccount).postalAddress().ZipCode : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>canShowInvoiceAmount</Name>
				<Source><![CDATA[
    protected boolean canShowInvoiceAmount()
    {
        return printAmountOnGiro &&
                conLen(statementCurrencyList) == 1 &&
                currentCust.Currency == Ledger::accountingCurrency(statementCompanyInfo.RecId) &&
                conFind(statementCurrencyList, currentCust.Currency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCurrency</Name>
				<Source><![CDATA[
    public boolean checkCurrency()
    {
        CustTable custTableLoc = this.parmArgs().record();
        container currencyList = custTableLoc.getCurrenciesForAllTrans(this.parmContract().parmFromDate(), this.parmContract().parmToDate(), this.parmContract().parmIncludeReversed());
        int i;

        for (i = 1; i <= conLen(currencyList); i++)
        {
            if (conPeek(currencyList, i) != 'DKK')
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMultipleCurrency</Name>
				<Source><![CDATA[
    private boolean checkMultipleCurrency()
    {
        CustTable custTableLoc = this.parmArgs().record();
        container currencyList = custTableLoc.getCurrenciesForAllTrans(this.parmContract().parmFromDate(), this.parmContract().parmToDate(), this.parmContract().parmIncludeReversed());
        CurrencyCode currencyCode = conPeek(currencyList, 1);
        int i;

        for (i = 2; i <= conLen(currencyList); i++)
        {
            if (currencyCode != conPeek(currencyList, i))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMergeCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a list of the unique items from the specified lists.
    /// </summary>
    /// <param name="_firstList">
    /// The first list.
    /// </param>
    /// <param name="_secondList">
    /// The second list.
    /// </param>
    /// <returns>
    /// A list of unique items.
    /// </returns>
    /// <remarks>
    /// The returned list has no duplicate items. The list that is specified in the <paramref
    /// name="_firstList" /> parameter is assumed to be the larger list.
    /// </remarks>
    private container createMergeCurrency(container _firstList, container _secondList)
    {
        container mergedList = _firstList;
        CurrencyCode item;
        int i;

        for (i = 1; i <= conLen(_secondList); i++)
        {
            item = conPeek(_secondList, i);

            if (conFind(_firstList, item) == 0)
            {
                mergedList += item;
            }
        }

        return mergedList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditAvailable</Name>
				<Source><![CDATA[
    private AmountMST creditAvailable()
    {
        if (currentCust.CreditMax != 0)
        {
            return currentCust.CreditMax - currentCust.balanceMST(dateNull(), statementEndDate);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    private CurrencyCode currencyCode(int _custCurrencyIndex)
    {
        return conPeek(custCurrencyList, _custCurrencyIndex);
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCodeISO_CH</Name>
				<Source><![CDATA[
    private CurrencyCodeISO currencyCodeISO_CH()
    {
        if (moneyTransferSlip_CH.parmIsCHF())
        {
            return #currencyCHF;
        }
        else if (moneyTransferSlip_CH.parmIsEUR())
        {
            return #currencyEUR;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>custBalance</Name>
				<Source><![CDATA[
    private AmountCur custBalance(CurrencyCode _currencyCode)
    {
        int currencyPosition = conFind(custCurrencyList, _currencyCode);

        return currencyPosition == 0 ? 0 : custBalanceCur[currencyPosition];
    }

]]></Source>
			</Method>
			<Method>
				<Name>custCompanyName</Name>
				<Source><![CDATA[
    private CompanyName custCompanyName(SelectableDataArea _company)
    {
        changecompany(_company)
        {
            return CompanyInfo::find().name();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fiCreditorId</Name>
				<Source><![CDATA[
    private str fiCreditorId()
    {
        CompanyInfoHelper::checkFICreditorIDEmpty(statementCompanyInfo.fiCreditorID_DK);
        return statementCompanyInfo.fiCreditorID_DK;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatDate</Name>
				<Source><![CDATA[
    protected str formatDate(TransDate _date)
    {
        System.Globalization.CultureInfo cultureInfo;
        System.DateTime dateLocalized;
        str formattedDateStr;

        if (_date != dateNull())
        {
            dateLocalized = _date;
            cultureInfo = new System.Globalization.CultureInfo(languageId);
            formattedDateStr = dateLocalized.ToString('d', cultureInfo);
        }

        return formattedDateStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDescription</Name>
				<Source><![CDATA[
    private str getDescription(Counter _col)
    {
        return custBalanceList.getDescription(_col);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGiroType</Name>
				<Source><![CDATA[
    public PaymentStub getGiroType()
    {
        return this.parmContract().parmPrintGiro();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHeaderEnd</Name>
				<Source><![CDATA[
    protected str getHeaderEnd(Counter _col)
    {
        StatRepInterval statRepInterval;

        boolean isForward()
        {
            return useAgingDefinition && statRepInterval.PrintDirection == ForwardBackwardPrinting::Forward;
        }

        boolean isBackward()
        {
            return useAgingDefinition && statRepInterval.PrintDirection == ForwardBackwardPrinting::Backward;
        }

        if (useAgingDefinition)
        {
            statRepInterval = StatRepInterval::find(agingDefinition);
        }

        if (_col == 1)
        {
            // Balance date
            return this.formatDate(statementEndDate);
        }
        else if (_col == 2 && isForward() && custBalanceList.startdate(_col) == dateNull())
        {
            return this.formatDate(custBalanceList.startdate(_col + 1));
        }
        else if (_col >= 3 && isForward() && custBalanceList.enddate(_col) >= dateMax())
        {
            return this.formatDate(custBalanceList.enddate(_col - 1));
        }
        else if ((_col == 2 && !useAgingDefinition) ||
                (_col == 2 && isBackward() && custBalanceList.enddate(_col) >= dateMax()))
        {
            return this.formatDate(custBalanceList.enddate(_col + 1));
        }
        else if ((_col == 7 && !useAgingDefinition) ||
                (_col >= 3 && isBackward() &&
                    custBalanceList.startdate(_col) == dateNull() &&
                    custBalanceList.enddate(_col) != dateNull()))
        {
            return this.formatDate(custBalanceList.startdate(_col - 1));
        }

        // End date
        return this.formatDate(custBalanceList.enddate(_col));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHeaderStart</Name>
				<Source><![CDATA[
    protected str getHeaderStart(Counter _col)
    {
        StatRepInterval statRepInterval;

        boolean isForward()
        {
            return useAgingDefinition && statRepInterval.PrintDirection == ForwardBackwardPrinting::Forward;
        }

        boolean isBackward()
        {
            return useAgingDefinition && statRepInterval.PrintDirection == ForwardBackwardPrinting::Backward;
        }

        if (useAgingDefinition)
        {
            statRepInterval = StatRepInterval::find(agingDefinition);
        }

        if (_col == 1 || (_col == 2 && isForward() && custBalanceList.enddate(_col) >= dateMax()))
        {
            return SysLabel::labelId2String(literalStr("@SYS5804"), languageId);
        }
        else if ((_col == 2 && isForward() && custBalanceList.startdate(_col) == dateNull()) ||
                (_col >= 3 && isBackward() &&
                    custBalanceList.startdate(_col) == dateNull() &&
                    custBalanceList.enddate(_col) != dateNull()) ||
                (_col == 7 && !useAgingDefinition))
        {
            return SysLabel::labelId2String(literalStr("@SYS4244"), languageId); // 'Before'
        }
        else if ((_col >= 3 && isForward() && custBalanceList.enddate(_col) >= dateMax()) ||
                (_col == 2 && isBackward() && custBalanceList.enddate(_col) >= dateMax()) ||
                (_col == 2 && !useAgingDefinition))
        {
            return SysLabel::labelId2String(literalStr("@SYS22816"), languageId); // 'After'
        }

        // Start date
        return this.formatDate(custBalanceList.startdate(_col));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextItemFromDiffList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the first item from the full list that is not in the excluded list.
    /// </summary>
    /// <param name="_fullList">
    /// The list of all items.
    /// </param>
    /// <param name="_excludedList">
    /// The list of excluded items.
    /// </param>
    /// <returns>
    /// The first item.
    /// </returns>
    /// <remarks>
    /// The lists are not updated.
    /// </remarks>
    private anytype getNextItemFromDiffList(container _fullList, container _excludedList)
    {
        anytype empty;
        anytype item;
        int i;

        for (i = 1; i <= conLen(_fullList); i++)
        {
            item = conPeek(_fullList, i);

            if (conFind(_excludedList, item) == 0)
            {
                return item;
            }
        }

        return empty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeOnStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified transaction should be included on the statement.
    /// </summary>
    /// <param name="_trans">
    /// The transaction.
    /// </param>
    /// <returns>
    /// true if the transaction should be included on the statement; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method relies on the transactions amounts being adjusted for the statement end date.
    /// </remarks>
    protected boolean includeOnStatement(CustTrans _trans)
    {
        return onlyOpen ? _trans.remainAmountCur() != 0 : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeAgingBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the aging balances.
    /// </summary>
    protected void initializeAgingBalances()
    {
        custBalanceList = CustVendBalanceList::construct(
                SysModule::Cust,
                DateTransactionDuedate::DueDate,
                this.parmContract().parmInterval(),
                statementEndDate,
                statementEndDate,
                NoYes::No,
                this.parmContract().parmDayMonth(),
                useAgingDefinition ? StatRepInterval::find(agingDefinition).PrintDirection : this.parmContract().parmPrintingDirection(),
                useAgingDefinition ? agingDefinition : '',
                includeReversed,
                NoYes::No);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFormLetterReport</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the form letter report.
    /// </summary>
    protected void initFormLetterReport()
    {
        formLetterReport = FormLetterReport::construct(PrintMgmtDocumentType::CustAccountStatement);
        formLetterReport.parmPrintType(PrintCopyOriginal::OriginalPrint);
        formLetterReport.parmReportRun().parmCheckScreenOutput(true);

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMoneyTransferSlip</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>PaymMoneyTransferSlip</c> class.
    /// </summary>
    protected void initMoneyTransferSlip()
    {
        if (printGiro !=PaymentStub::None && printGiro !=PaymentStub::Finnish)
        {
            moneyTransferSlip = PaymMoneyTransferSlip::construct(printGiro);
            moneyTransferSlip.init(printGiro);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePaymentSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes payment slips to use in Giro.
    /// </summary>
    protected void initializePaymentSlip()
    {
        this.initMoneyTransferSlip();

        this.populateMoneyTransferSlip();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateMoneyTransferSlip</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populate payment slips to use in giro.
    /// </summary>
    protected void populateMoneyTransferSlip()
    {
        switch (printGiro)
        {
            case PaymentStub::ESR_orange:
            case PaymentStub::ESR_red_bank:
                moneyTransferSlip_CH = moneyTransferSlip;
                if (printAmountOnGiro)
                {
                    int currencyPosition = conFind(statementCurrencyList, currentStatementCust.Currency);
                    if (currencyPosition == 1 && conLen(statementCurrencyList) == 1 &&
                            currentStatementCust.Currency == Ledger::accountingCurrency(statementCompanyInfo.RecId) &&
                            currentStatementCust.PaymSched == '' &&
                            statementBalanceCur[currencyPosition] >= 0)
                    {
                        moneyTransferSlip_CH.initOCRLineAccountStatement_CH(currentStatementCust, printGiro, abs(statementBalanceCur[currencyPosition]));
                    }
                }
                break;
            case PaymentStub::FIK752:
                moneyTransferSlip.bankAccountId(currentStatementCust.BankAccount);
                break;
            case PaymentStub::BelSMS101:
            case PaymentStub::BelSMS102:
                moneyTransferSlip_BE = moneyTransferSlip;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCustAccountStatementExtTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the core fields on the <c>CustAccountStatementExtTmp</c> buffer in preparation for insert.
    /// </summary>
    /// <param name = "_custCurrencyIndex">The customer currency index.</param>
    protected void populateCustAccountStatementExtTmp(int _custCurrencyIndex)
    {
        statementCompanyInfo = CompanyInfo::find();

        this.initializePaymentSlip();
        custAccountStatementExtTmp.FlagMainData = 0;

        // CustTable
        if (custPre)
        {
            // Buffer is guaranteed clear before adding new customer to the table.
            custAccountStatementExtTmp.clear();

            custAccountStatementExtTmp.FlagMainData = 16;
            custAccountStatementExtTmp.CustTable_Name = currentCust.name();
            custAccountStatementExtTmp.Contactperson = ContactPerson::find(currentCust.ContactPersonId).personName();
            custAccountStatementExtTmp.CustTable_Address = DirUtility::replaceAddressTokenLanguage(currentCust.statementAddress(), currentCust.languageId());
            custAccountStatementExtTmp.CustTable_AccountNum = currentCust.AccountNum;
            custAccountStatementExtTmp.PaymentTxt = PaymTerm::txt(currentCust.PaymTermId, currentCust.languageId());
            custAccountStatementExtTmp.CustTable_Currency = currentCust.Currency;
            custAccountStatementExtTmp.CreditLimit = currentCust.CreditMax;
            custAccountStatementExtTmp.CreditAvailable = this.creditAvailable();
        }

        if (currentCust)
        {
            custAccountStatementExtTmp.AccountNum = currentCust.AccountNum;
        }

        if (conLen(custCurrencyList) <= 1)
        {
            custAccountStatementExtTmp.ShowBalance = NoYes::Yes;
        }
        else
        {
            custAccountStatementExtTmp.ShowBalance = NoYes::No;
        }

        // MultiCompanyCust
        if (haveNonStatementCust)
        {
            custAccountStatementExtTmp.Flag = 8;
            custAccountStatementExtTmp.MultiCompanyCustName = this.custCompanyName(currentCust.company());
            custAccountStatementExtTmp.MultiCompanyCustPaymTermDesc = currentCust.paymName();
            custAccountStatementExtTmp.MultiCompanyCustCreditLimit = currentCust.CreditMax;
            custAccountStatementExtTmp.MultiCompanyCustCreditAvailable = this.creditAvailable();
        }

        // OpeningBalance
        custAccountStatementExtTmp.Currency = this.currencyCode(_custCurrencyIndex);

        if (openBal)
        {
            custAccountStatementExtTmp.FlagMainData = 17;
            custAccountStatementExtTmp.OpeningBalance = openingBalance;
        }

        // ClosingBalance
        custAccountStatementExtTmp.ClosingCurrency = this.currencyCode(_custCurrencyIndex);

        if (closeBal)
        {
            custAccountStatementExtTmp.FlagMainData = 18;
            custAccountStatementExtTmp.ClosingBalance = closingBalance;
        }

        // AgingHeadlinesDescription
        if (printAgingDescription)
        {
            custAccountStatementExtTmp.Flag = 7;
            custAccountStatementExtTmp.Heading01 = this.getDescription(1);
            custAccountStatementExtTmp.Heading02 = this.getDescription(2);
            custAccountStatementExtTmp.Heading03 = this.getDescription(3);
            custAccountStatementExtTmp.Heading04 = this.getDescription(4);
            custAccountStatementExtTmp.Heading05 = this.getDescription(5);
            custAccountStatementExtTmp.Heading06 = this.getDescription(6);
            custAccountStatementExtTmp.Heading07 = this.getDescription(7);
        }

        // AgingHeadlines
        if (agingHead)
        {
            custAccountStatementExtTmp.Flag = 4;
            custAccountStatementExtTmp.Heading011 = this.getHeaderStart(1);
            custAccountStatementExtTmp.Heading021 = this.getHeaderStart(2);
            custAccountStatementExtTmp.Heading031 = this.getHeaderStart(3);
            custAccountStatementExtTmp.Heading041 = this.getHeaderStart(4);
            custAccountStatementExtTmp.Heading051 = this.getHeaderStart(5);
            custAccountStatementExtTmp.Heading061 = this.getHeaderStart(6);
            custAccountStatementExtTmp.Heading071 = this.getHeaderStart(7);
            custAccountStatementExtTmp.Heading012 = this.getHeaderEnd(1);
            custAccountStatementExtTmp.Heading022 = this.getHeaderEnd(2);
            custAccountStatementExtTmp.Heading032 = this.getHeaderEnd(3);
            custAccountStatementExtTmp.Heading042 = this.getHeaderEnd(4);
            custAccountStatementExtTmp.Heading052 = this.getHeaderEnd(5);
            custAccountStatementExtTmp.Heading062 = this.getHeaderEnd(6);
            custAccountStatementExtTmp.Heading072 = this.getHeaderEnd(7);
        }

        // CustTmpAccountSum - AgingBodyLines
        if (summary)
        {
            custAccountStatementExtTmp.Flag = 3;
            custAccountStatementExtTmp.BalanceCurrencyCode = custSummary.CurrencyCode;
            custAccountStatementExtTmp.Balance01 = custSummary.Balance01Cur;
            custAccountStatementExtTmp.Balance02 = custSummary.Balance02Cur;
            custAccountStatementExtTmp.Balance03 = custSummary.Balance03Cur;
            custAccountStatementExtTmp.Balance04 = custSummary.Balance04Cur;
            custAccountStatementExtTmp.Balance05 = custSummary.Balance05Cur;
            custAccountStatementExtTmp.Balance06 = custSummary.Balance06Cur;
            custAccountStatementExtTmp.Balance07 = custSummary.Balance07Cur;
        }

        // Heading_transaction
        if (transHeading)
        {
            custAccountStatementExtTmp.Header_TransDate = currentTrans.TransDate;
            custAccountStatementExtTmp.Header_Invoice = currentTrans.Invoice;
            custAccountStatementExtTmp.Header_Txt = currentTrans.Txt;
            custAccountStatementExtTmp.Header_Duedate = currentTrans.DueDate;
            custAccountStatementExtTmp.Header_CurrencyCode = currentTrans.CurrencyCode;
            custAccountStatementExtTmp.Header_Debit = currentTrans.AmountCur;
            custAccountStatementExtTmp.Header_Credit = currentTrans.AmountCur;
            custAccountStatementExtTmp.Header_Balance = currentTrans.AmountCur;
        }

        if (markForPaymentSchedulePrinted)
        {
            custAccountStatementExtTmp.Flag = 10;
        }

        // CustTrans - Transactions
        if (cust_Trans)
        {
            custAccountStatementExtTmp.FlagMainData = 19;
            custAccountStatementExtTmp.CustTrans_TransDate = currentTrans.TransDate;
            custAccountStatementExtTmp.CustTrans_Invoice = currentTrans.Invoice;
            custAccountStatementExtTmp.CustTrans_Voucher = currentTrans.Voucher;
            custAccountStatementExtTmp.CustTrans_DataAreaId = currentTrans.DataAreaId;
            custAccountStatementExtTmp.CustTrans_Txt = currentTrans.Txt;
            custAccountStatementExtTmp.CustTrans_DueDate = tmpCustVendTransOpen.DueDate;
            custAccountStatementExtTmp.DueDateTxt = syslabel::labelId2String(literalStr("@SYS78137"),languageId);
            custAccountStatementExtTmp.CustTrans_markForPaymentSchedule = this.markForPaymentSchedule();
            custAccountStatementExtTmp.CustTrans_CurrencyCode = currentTrans.CurrencyCode;
            custAccountStatementExtTmp.CustTrans_Debit = this.amountCurDebit();
            custAccountStatementExtTmp.CustTrans_Credit = this.amountCurCredit();
            custAccountStatementExtTmp.CustTrans_Balance = this.custBalance(this.singleCurrencyReport ? Ledger::accountingCurrency(CompanyInfo::current()) : currentTrans.CurrencyCode);
        }

        // TmpCustVendTransOpen - OpenTransactions
        if (vendTransOpen)
        {
            custAccountStatementExtTmp.FlagMainData = 20;
            custAccountStatementExtTmp.CustTransOpen_DueDate = tmpCustVendTransOpen.DueDate;
            custAccountStatementExtTmp.CustTransOpen_AmountCur = tmpCustVendTransOpen.AmountCur;
        }

        // FormLetterRemarks
        custAccountStatementExtTmp.FormLetterRemarks_Txt = FormLetterRemarks::find(currentCust.languageId(), FormTextType::CustACStatementExt).Txt;

        // TmpCustVendTrans - SpecifyDueToDate
        if (specifyDueToDate && insertSpecifyDueDate)
        {
            custAccountStatementExtTmp.Flag = 25;
            custAccountStatementExtTmp.Tmp_DueDate = tmpCustVendTrans.DueDate;
            custAccountStatementExtTmp.Tmp_TransDate = tmpCustVendTrans.TransDate;
            custAccountStatementExtTmp.Tmp_Invoice = tmpCustVendTrans.Invoice;
            custAccountStatementExtTmp.Tmp_Currency = tmpCustVendTrans.CurrencyCode;
            custAccountStatementExtTmp.Tmp_Amount = tmpCustVendTrans.AmountCur;
        }

        custAccountStatementExtTmp.PaymReference = moneyTransferSlip_BE ?
            moneyTransferSlip_BE.paymentIdReport(currentTrans.PaymReference):
            '';

        if (!closeBal)
        {
            this.insertGiro();
        }

        this.setCommonData();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustAccountStatementExtTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the data population and insertion of <c>CustAccountStatementExtTmp</c> record(s).
    /// </summary>
    /// <param name = "_custCurrencyIndex">The customer currency index.</param>
    protected void insertCustAccountStatementExtTmp(int _custCurrencyIndex)
    {
        this.populateCustAccountStatementExtTmp(_custCurrencyIndex);

        // <GCN>
        // Insert multi invoice id and transaction amount when showing tax integration number.
        if (isTaxIntegrateEnable_CN)
        {
            this.insertCustAccountStatementExtTmp_CN();
        }
        else
        {
            custAccountStatementExtTmp.insert();
        }

        createdTransactionId = custAccountStatementExtTmp.CreatedTransactionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustAccountStatementExtTmp_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the data population and insertion of <c>CustAccountStatementExtTmp</c> record(s) for CN functionality.
    /// </summary>
    protected void insertCustAccountStatementExtTmp_CN()
    {
        // <GCN>
        TaxIntgrExportDocumentOperationView_CN taxIntgrExportDocumentOperationView_CN;
        List externalInvoiceIdList_CN = new List(Types::String);

        #characters
        // </GCN>

        // CustTrans - Transactions
        if (cust_Trans)
        {
            while select ExternalInvoiceId from taxIntgrExportDocumentOperationView_CN
                    where taxIntgrExportDocumentOperationView_CN.InvoiceId == currentTrans.Invoice
            {
                if (taxIntgrExportDocumentOperationView_CN.ExternalInvoiceId)
                {
                    externalInvoiceIdList_CN.addEnd(taxIntgrExportDocumentOperationView_CN.ExternalInvoiceId);
                }
            }
        }

        if (externalInvoiceIdList_CN && externalInvoiceIdList_CN.elements())
        {
            ListEnumerator externalInvoiceListEnumerator = externalInvoiceIdList_CN.getEnumerator();
            while (externalInvoiceListEnumerator.moveNext())
            {
                int invoiceIdcount = 0;
                TaxMultiInvoiceId_CN taxMultiInvoiceId_CN = '';

                custAccountStatementExtTmp.TaxExternalInvoiceId_CN = externalInvoiceListEnumerator.current();

                while select InvoiceId from taxIntgrExportDocumentOperationView_CN
                        where taxIntgrExportDocumentOperationView_CN.ExternalInvoiceId == custAccountStatementExtTmp.TaxExternalInvoiceId_CN
                {
                    if (invoiceIdcount)
                    {
                        taxMultiInvoiceId_CN += #comma;
                    }

                    taxMultiInvoiceId_CN += taxIntgrExportDocumentOperationView_CN.InvoiceId;

                    invoiceIdcount++;
                }

                custAccountStatementExtTmp.CustTrans_MultiInvoiceId_CN = taxMultiInvoiceId_CN;

                select firstonly TransactionCurrencyAmount, InvoiceId from taxIntgrExportDocumentOperationView_CN
                         order by taxIntgrExportDocumentOperationView_CN.InvoiceDate desc
                         where taxIntgrExportDocumentOperationView_CN.ExternalInvoiceId == custAccountStatementExtTmp.TaxExternalInvoiceId_CN &&
                             taxIntgrExportDocumentOperationView_CN.InvoiceDate >= custAccountStatementExtTmp.FromDate &&
                             taxIntgrExportDocumentOperationView_CN.InvoiceDate <= custAccountStatementExtTmp.ToDate;

                if (taxIntgrExportDocumentOperationView_CN.InvoiceId)
                {
                    if (taxIntgrExportDocumentOperationView_CN.TransactionCurrencyAmount > 0)
                    {
                        custAccountStatementExtTmp.CustTrans_Debit = taxIntgrExportDocumentOperationView_CN.TransactionCurrencyAmount;
                        custAccountStatementExtTmp.CustTrans_Credit = 0;
                    }
                    else
                    {
                        custAccountStatementExtTmp.CustTrans_Credit = taxIntgrExportDocumentOperationView_CN.TransactionCurrencyAmount;
                        custAccountStatementExtTmp.CustTrans_Debit = 0;
                    }

                    if (taxIntgrExportDocumentOperationView_CN.InvoiceId == currentTrans.Invoice)
                    {
                        custAccountStatementExtTmp.insert();
                    }
                    custAccountStatementExtTmp.TaxExternalInvoiceId_CN = '';
                }
            }
        }
        else
        {
            custAccountStatementExtTmp.CustTrans_MultiInvoiceId_CN = currentTrans.Invoice;
            custAccountStatementExtTmp.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertGiro</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts Giro information into the <c>custAccountStatementExtTmp</c> temporary table.
    /// </summary>
    private void insertGiro()
    {
        custAccountStatementExtTmp.GiroType = printGiro;

        // See if current name is cached and only look it up if not
        // cached since the lookup causes an RPC
        if (currentCustName == '')
        {
            currentCustName = currentCust.name();
        }
        custAccountStatementExtTmp.CustName_CH = currentCustName;

        // See if current address is cached and only look it up if not
        // cached since the lookup causes an RPC
        if (currentCustAddress == '')
        {
            currentCustAddress = currentCust.postalAddress().Address;
        }
        custAccountStatementExtTmp.CustAddress_CH = currentCustAddress;

        if (printAmountOnGiro)
        {
            custAccountStatementExtTmp.InvoiceAmountNODecimals = this.invoiceAmountNoDecimals();
            custAccountStatementExtTmp.InvoiceAmountDecimals = this.invoiceAmountDecimals();
            custAccountStatementExtTmp.InvoiceAmount = this.invoiceAmount();
            if (printGiro == PaymentStub::ESR_orange || printGiro == PaymentStub::ESR_red_bank)
            {
                custAccountStatementExtTmp.InvoiceAmountNODecimals = this.amountNoDecimals_CH();
                custAccountStatementExtTmp.InvoiceAmountDecimals = this.amountDecimals_CH();
            }
        }
        
        this.populateGiro();

        custAccountStatementExtTmp.IsInvoiceAmount = this.canShowInvoiceAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateGiro</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates Giro information into the <c>custAccountStatementExtTmp</c> temporary table.
    /// </summary>
    protected void populateGiro()
    {
        switch (printGiro)
        {
            case PaymentStub::FIK751:
            case PaymentStub::FIK752:
                custAccountStatementExtTmp.ocrField = moneyTransferSlip.ocrField(currentCust.AccountNum, '',
                                            strLen(int2str(NumberSeq::highest(SalesParameters::numRefInvoiceId().NumberSequenceId))));
                custAccountStatementExtTmp.fiCreditorId = this.fiCreditorId();

                if (printGiro == PaymentStub::FIK752 && Ledger::accountingCurrency(statementCompanyInfo.RecId) != 'DKK')
                {
                    printGiro = PaymentStub::FIK751;
                    custAccountStatementExtTmp.GiroType = PaymentStub::FIK751;
                }
                break;

            case PaymentStub::BBS:
                custAccountStatementExtTmp.CompanyGiro = statementCompanyInfo.Giro;
                custAccountStatementExtTmp.ocrField = '';
                custAccountStatementExtTmp.AmountCheckId = this.amountCheckId();
                break;

            case PaymentStub::ESR_red_bank:
                custAccountStatementExtTmp.BankGroupIdName_CH = this.bankGroupIdName_CH();
                custAccountStatementExtTmp.BankZipCode_CH = this.bankZipCode_CH();
                if (printAmountOnGiro && moneyTransferSlip_CH.ocr_paymentRef2()!='')
                {
                    custAccountStatementExtTmp.Description_CH = "@SYS12128";
                    custAccountStatementExtTmp.PaymentRef1_CH = moneyTransferSlip_CH.ocr_paymentRef1();
                    custAccountStatementExtTmp.PaymentRef2_CH = moneyTransferSlip_CH.ocr_paymentRef2();
                    custAccountStatementExtTmp.BankAccountTable_AccountNum_CH = hasFieldAccess(tableNum(BankAccountTable), fieldNum(BankAccountTable, AccountNum)) ?
                                                                                    moneyTransferSlip_CH.bankAccountNum() : "@AccountsReceivable:FiveAsterisk";
                    custAccountStatementExtTmp.BankAccountTable_Clearing_CH = moneyTransferSlip_CH.bankAccountTable().RegistrationNum;
                    custAccountStatementExtTmp.AccountNo1_CH = moneyTransferSlip_CH.ocr_AccountNo1();
                    custAccountStatementExtTmp.PaymentId2_PaymentId3_CH = moneyTransferSlip_CH.ocr_PaymentId2() + ' ' + moneyTransferSlip_CH.ocr_PaymentId3();
                    custAccountStatementExtTmp.LayoutCode_CH = moneyTransferSlip_CH.layoutCode();
                    custAccountStatementExtTmp.OcrLine_CH = moneyTransferSlip_CH.ocrLine();
                    custAccountStatementExtTmp.AccountNo2_CH = this.accountNo2_CH();
                }
                break;

            case PaymentStub::ESR_orange:
                custAccountStatementExtTmp.CurrencyCodeISO_CH = this.currencyCodeISO_CH();
                custAccountStatementExtTmp.AccountNo1_CH = moneyTransferSlip_CH.ocr_AccountNo1();
                custAccountStatementExtTmp.PaymentId2_PaymentId3_CH = moneyTransferSlip_CH.ocr_PaymentId2() + ' ' + moneyTransferSlip_CH.ocr_PaymentId3();
                custAccountStatementExtTmp.LayoutCode_CH = moneyTransferSlip_CH.layoutCode();
                custAccountStatementExtTmp.OcrLine_CH = moneyTransferSlip_CH.ocrLine();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAmount</Name>
				<Source><![CDATA[
    private AmountCur invoiceAmount()
    {
        AmountCur balanceCur;

        if (this.canShowInvoiceAmount() && !currentCust.PaymSched)
        {
            balanceCur = statementBalanceCur[conFind(statementCurrencyList, currentCust.Currency)];
            if (balanceCur >= 0)
            {
                return balanceCur;
            }
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAmountDecimals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the invoice amount details.
    /// </summary>
    /// <returns>
    /// A String that contains the invoice amount details.
    /// </returns>
    private str invoiceAmountDecimals()
    {
        AmountCur amount;

        if (this.canShowInvoiceAmount())
        {
            amount = statementBalanceCur[conFind(statementCurrencyList, currentCust.Currency)];
            if (amount >= 0 && !currentCust.PaymSched)
            {
                return strReplace(num2str(frac(amount) * 100, 2, 0, 0, 0), ' ', '0');
            }
            return 'XX';
        }
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAmountNoDecimals</Name>
				<Source><![CDATA[
    private str invoiceAmountNoDecimals()
    {
        AmountCur amount;

        if (this.canShowInvoiceAmount())
        {
            amount = statementBalanceCur[conFind(statementCurrencyList, currentCust.Currency)];
            if (amount >= 0)
            {
                return num2str(trunc(amount), 1, 0, 0, 0);
            }
            return strRep('X', 6);
        }
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>markForPaymentSchedule</Name>
				<Source><![CDATA[
    private str markForPaymentSchedule()
    {
        if (numberOfTransOpen > 1 && !printPaymentSchedule)
        {
            markForPaymentSchedulePrinted = true;
            return '*';
        }
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>outputReport</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the report for the print management setting that is currently loaded.
    /// </summary>
    /// <remarks>
    ///    The <c>outReports</c> method loops over print management settings and calls this method for each
    ///    print management setting that is loaded.DO override this method to modify parameters for each print
    ///    settings.For example, if you want to provide different footer text for each print settings that is
    ///    loaded for a given report.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The print management object has not been initialized.
    /// </exception>
    protected void outputReport()
    {
        this.parmContract().parmPrintType(SysLabel::labelId2String(
                formLetterReport.getCurrentPrintSetting().parmType() == PrintMgmtDocInstanceType::Copy ? literalStr("@SYS108914") : literalStr("@SYS108913"), languageId));
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>outputReports</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads and iterates through print settings for the specified record.
    /// </summary>
    /// <remarks>Method overload added for extensibility.</remarks>
    protected void outputReports()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContract</Name>
				<Source><![CDATA[
    protected CustAccountStatementExtContract parmContract()
    {
        if (!contract)
        {
            contract = this.parmReportContract().parmRdpContract() as CustAccountStatementExtContract;
        }
        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custTransQueryForOtherCust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a query for the non-statement customers and transactions of the specified party ID and list
    /// of companies.
    /// </summary>
    /// <param name="_party">
    /// The party ID of the customer to include.
    /// </param>
    /// <param name="_selectedCompanyList">
    /// The list of selected companies.
    /// </param>
    /// <param name="_statementCompanyList">
    /// The list of companies processed to find the statement customer.
    /// </param>
    /// <returns>
    /// A query for non-statement customers and their transactions.
    /// </returns>
    protected Query custTransQueryForOtherCust(DirPartyRecId _party, container _selectedCompanyList, container _statementCompanyList)
    {
        return CustAccountStatementExtController::createCustTransQueryForOtherCust(_party, _selectedCompanyList, _statementCompanyList, statementStartDate, statementEndDate, includeReversed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>preprocessParty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the specified party ID to get information for printing the statement.
    /// </summary>
    /// <param name="_party">
    /// The party ID.
    /// </param>
    /// <param name="_selectedCompanyList">
    /// The list of selected companies.
    /// </param>
    /// <param name="_statementCompanyList">
    /// The list of companies processed to find the statement customer.
    /// </param>
    /// <remarks>
    /// This method performs look-ahead processing.
    /// </remarks>
    protected void preprocessParty(
            DirPartyRecId _party,
            container _selectedCompanyList,
            container _statementCompanyList)
    {
        CustTable cust;
        Query q;
        QueryRun run;
        CompanyId currentCompany;
        boolean isCustChanged;

        Debug::assert(conLen(_statementCompanyList) > 0);

        Debug::assert(conFind(_statementCompanyList, statementCompany) != 0);

        if (conLen(_statementCompanyList) > 1)
        {
            // having more than one company in this list means the
            // statement customer isn't in the statement company
            haveNonStatementCust = true;
        }
        else
        {
            q = this.custTransQueryForOtherCust(_party, _selectedCompanyList, _statementCompanyList);

            if (q == null)
            {
                haveNonStatementCust = false;
            }
            else
            {
                currentCompany = '';

                run = new QueryRun(q);

                while (run.next())
                {
                    cust = run.get(tableNum(CustTable));

                    // Check the company because changed() doesn't include it for fan out. See also bug 47368.
                    isCustChanged = SysReportRun::changed(run, tableNum(CustTable)) || cust.company() != currentCompany;
                    currentCompany = cust.company();

                    if (isCustChanged)
                    {
                        changecompany(cust.company())
                        {
                            // check whether the customer will be on the statement
                            haveNonStatementCust = this.hasCustomerStatement(cust);

                            if (haveNonStatementCust)
                            {
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCustomerStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a customer will be on the statement.
    /// </summary>
    /// <param name = "_custTable">
    /// The customer record to be checked.
    /// </param>
    /// <returns>
    /// true if a customer will be on the statement; otherwise, false.
    /// </returns>
    protected boolean hasCustomerStatement(CustTable _custTable)
    {
        return !(printNotZero && _custTable.balancePerDate(statementEndDate) == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>prePromptModifyContract</Name>
				<Source><![CDATA[
    protected void prePromptModifyContract()
    {
        this.applyQueryRange(query);

        if (this.parmArgs() && this.parmArgs().record() && this.parmArgs().record().TableId == tableNum(CustTable))
        {
            FormDataSource formDataSource = FormDataUtil::getFormDataSource(this.parmArgs().record());

            if (!formDataSource || formDataSource.recordsMarked().lastIndex() <= 1)
            {
                CustTable custTable;
                custTable = CustTable::findRecId(this.parmArgs().record().RecId);
                this.parmContract().parmPrintGiro(custTable.GiroTypeAccountStatement);
            }

            if (cbdDestinationsController)
            {
                this.parmContract().parmHideSSRSDestination(cbdDestinationsController.getHideSSRSDestinationTab());
            }
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>preRunValidate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates prior to running the report.
    /// </summary>
    /// <returns>
    /// A container that contains two items.
    /// </returns>
    /// <remarks>
    ///  Override this method to perform validation before running a report. A common use of this method is
    ///  to validate whether the time taken to run the report is acceptable.The following are common
    ///  scenarios for which to use this method:
    ///  <list type="bullet">
    ///   <item>
    ///   <description>Return a warning if the number of records processed is large enough to affect the user
    ///   experience if the report is printed to the screen.</description>
    ///   </item>
    ///   <item>
    ///   <description>Return an error if the number of records processed is large enough that the report
    ///   could timeout.</description>
    ///   </item>
    ///  </list>
    ///   The default behavior is to run the report.
    /// </remarks>
    protected container preRunValidate()
    {
        container validateResult = super();
        Query firstQuery;
        int custStatementCount;

        // Only show warning if not printing to screen, since when printing to
        // screen the user will get a different ok/cancel dialog after 5 reports
        // anyway. Also only validate prior to starting to run all reports, as
        // opposed to validating each report (controlled by the initialPreRunValidate
        // variable).
        if (initialPreRunValidate && this.parmReportContract().parmPrintSettings().printMediumType() != SRSPrintMediumType::Screen)
        {
            // The time to print is based primarily on the number of customer statements
            // being printed. Since each statement is very quick to print, the overall
            // SRS timeout will not be hit. Just check for the number of statements being
            // printed and warn if it is over 5 (including cross-company customers).
            firstQuery = this.getFirstQuery();
            custStatementCount = QueryRun::getQueryRowCount(firstQuery, 6);
            if (custStatementCount > 5)
            {
                validateResult = [SrsReportPreRunState::Warning];
            }
        }

        return validateResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInstance</Name>
				<Source><![CDATA[
    protected SrsPrintMgmtController newInstance()
    {
        return new CustAccountStatementExtController();
    }

]]></Source>
			</Method>
			<Method>
				<Name>printAgingBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints the aging balance details.
    /// </summary>
    /// <param name="_agingCompanyCustomer">
    /// A map of which customer to include from each selected company.
    /// </param>
    /// <remarks>
    /// The information is printed after the customer and transaction detail.
    /// </remarks>
    protected void printAgingBalance(Map _agingCompanyCustomer)
    {
        if (showAging)
        {
            this.printAgingBalances(_agingCompanyCustomer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printAgingBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints the aging balances on the customer statement.
    /// </summary>
    /// <param name="_agingCompanyCustomer">
    /// A map of which customer to include from each selected company.
    /// </param>
    protected void printAgingBalances(Map _agingCompanyCustomer)
    {
        MapEnumerator agingCompanyCustomerEnum = _agingCompanyCustomer.getEnumerator();

        // Calculate aging across all company/customers
        this.initializeAgingBalances();

        while (agingCompanyCustomerEnum.moveNext())
        {
            DataAreaId company = agingCompanyCustomerEnum.currentKey();
            changeCompany(company)
            {
                custBalanceList.calculateDetailsCurAsAlternateCust(custTable::find(agingCompanyCustomerEnum.currentValue()), currentStatementCust);
            }
        }

        if (showAgingDescription)
        {
            printAgingDescription = true;
            this.insertCustAccountStatementExtTmp(1);
            printAgingDescription = false;
        }

        agingHead = true;
        this.insertCustAccountStatementExtTmp(1);
        agingHead = false;

        custSummary = custBalanceList.initTmpAccountSum();

        select firstonly custSummary;

        // Print aged balances for each currency
        summary = true;
        if (custSummary)
        {
            while select custSummary order by custSummary.CurrencyCode
                where custSummary.CurrencyCode != ''
            {
                this.insertCustAccountStatementExtTmp(1);
            }
        }
        else
        {
            // aging amounts will be zero for all the currencies
            for (int i = 1; i <= conLen(statementCurrencyList); i++)
            {
                custSummary.CurrencyCode = conPeek(statementCurrencyList, i);
                this.insertCustAccountStatementExtTmp(1);
            }
        }
        summary = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printClosingBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prints the closing balances on the customer statement.
    /// </summary>
    protected void printClosingBalance()
    {
        int i;

        for (i = 1; i <= conLen(custCurrencyList); i++)
        {
            closingBalance = custBalanceCur[i];

            closeBal = true;
            this.insertCustAccountStatementExtTmp(i);
            closeBal = false;
        }

        closingBalance = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCustPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the specified customer after all transactions have been printed.
    /// </summary>
    /// <param name="_cust">
    /// The customer to process.
    /// </param>
    /// <param name="_statementCust">
    /// The statement customer.
    /// </param>
    protected void processCustPost(CustTable _cust, CustTable _statementCust)
    {
        changecompany(_cust.company())
        {
            if (conLen(custCurrencyList) == 0)
            {
                // show the customer currency balances if no transactions were found
                this.addCustCurrency(_cust.Currency);
            }

            this.printClosingBalance();

            if (specifyDueToDate)
            {
                insertSpecifyDueDate = true;

                while select tmpCustVendTrans
                    order by DueDate
                    where specifyDueToDate >= tmpCustVendTrans.DueDate
                {
                    this.insertCustAccountStatementExtTmp(0);
                }

                insertSpecifyDueDate = false;
                delete_from tmpCustVendTrans;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCustPre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the specified customer before any transactions have been printed.
    /// </summary>
    /// <param name="_cust">
    /// The customer to process.
    /// </param>
    /// <param name="_numberOfCustProcessed">
    /// The number of customers on the statement that have been processed to this point.
    /// </param>
    /// <returns>
    /// true if the customer is processed; otherwise, false.
    /// </returns>
    protected boolean processCustPre(CustTable _cust, int _numberOfCustProcessed)
    {
        custTransCount = 0;
        isTransactionHeaderPrinted = false;

        changecompany(_cust.company())
        {
            if (printNotZero && _cust.balancePerDate(statementEndDate) == 0)
            {
                // the customer has a zero balance and will be excluded
                return false;
            }

            // clear out this customer's currency list
            custCurrencyList = conNull();

            // clear the entire balance arrray
            custBalanceCur[0] = 0;

            balanceMST = _cust.balanceMST(statementStartDate, statementEndDate);

            markForPaymentSchedulePrinted = false;
            this.setCurrentCust(_cust);

            // put the customer on the report
            if (_cust)
            {
                custPre = true;
                this.insertCustAccountStatementExtTmp(0);
                custPre = false;
            }
            else
            {
                // return failure because the cust failed to print
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processParty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the customers for the specified party ID.
    /// </summary>
    /// <param name="_query">
    /// The query with user criteria.
    /// </param>
    /// <param name="_party">
    /// The party ID whose customers will be processed.
    /// </param>
    /// <param name="_selectedCompanyList">
    /// The list of selected companies.
    /// </param>
    /// <remarks>
    /// A company contains at most one customer for a specific party ID.
    /// </remarks>
    protected void processParty(Query _query, DirPartyRecId _party, container _selectedCompanyList)
    {
        CustTable cust;
        CustTable prevCust;
        CustTrans trans;
        Query custTransQuery;
        QueryRun custTransRun;
        boolean haveStatementCust;
        boolean isCustChanged;
        boolean isCustPostProcessingNeeded = false;
        boolean printSpaceAfterCust = false;
        boolean wasCustProcessed;
        container statementCompanyList = conNull();
        int numberOfCustPrinted = 0;
        CompanyId company;
        CompanyId currentCompany;
        Map agingCompanyCustomer = new Map(Types::String, Types::String); // Map of customers to include in aging: Key=Company(DataAreaId), Value=Customer(AccountNum)

        moneyTransferSlip = null;

        // clear entire array
        statementBalanceCur[0] = 0;

        // try to find a statement customer
        haveStatementCust = false;
        insertCompanyLogo = true;

        while (!haveStatementCust)
        {
            if (conLen(statementCompanyList) == 0)
            {
                // try the statement company first
                company = statementCompany;
            }
            else
            {
                company = this.getNextItemFromDiffList(_selectedCompanyList, statementCompanyList);
            }

            if (company == '')
            {
                // could not find a statement customer
                break;
            }
            else
            {
                // check if the customer from this company will be on the statement
                statementCompanyList += company;

                custTransQuery = this.createCustTransQueryForStatementCust(_query, _party, company, _selectedCompanyList, statementStartDate, statementEndDate, includeReversed, printGiro);

                if (custTransQuery != null)
                {
                    custTransRun = new QueryRun(custTransQuery);

                    if (custTransRun.next())
                    {
                        cust = custTransRun.get(tableNum(CustTable));

                        changecompany(cust.company())
                        {
                            if (this.hasCustomerStatement(cust))
                            {
                                // this customer will be on the statement
                                haveStatementCust = true;
                            }
                        }
                    }
                }
            }
        }

        if (haveStatementCust)
        {
            this.preprocessParty(_party, _selectedCompanyList, statementCompanyList);
            currentCompany = '';
        }

        while (haveStatementCust)
        {
            cust = custTransRun.get(tableNum(CustTable));

            // Check the company because changed() doesn't include it for fan out. See also bug 47368.
            isCustChanged = SysReportRun::changed(custTransRun, tableNum(CustTable)) || cust.company() != currentCompany;
            currentCompany = cust.company();

            if (isCustChanged && isCustPostProcessingNeeded)
            {
                // update the global customer
                this.setCurrentCust(prevCust);

                // uses "previous" customer
                this.processCustPost(prevCust, currentStatementCust);
                agingCompanyCustomer.insert(prevCust.company(), prevCust.AccountNum);
                isCustPostProcessingNeeded = false;
            }

            if (isCustChanged)
            {
                cust = custTransRun.get(tableNum(CustTable));

                // direct references to the cust variable are cleared by the last call to QueryRun.Next
                prevCust.data(cust);

                if (currentStatementCust == null)
                {
                    // this initialization is performed one time for each statement
                    currentStatementCust.data(cust);
                }

                // update the global customer
                this.setCurrentCust(cust);

                wasCustProcessed = this.processCustPre(cust, numberOfCustPrinted);

                if (wasCustProcessed)
                {
                    numberOfCustPrinted++;
                    printSpaceAfterCust = true;
                    isCustPostProcessingNeeded = true;
                }
            }

            if (wasCustProcessed)
            {
                trans = custTransRun.get(tableNum(CustTrans));

                if (trans.RecId != 0)
                {
                    this.processTrans(trans);
                    transHeading = false;
                }
            }

            haveStatementCust = custTransRun.next();
        }

        if (isCustPostProcessingNeeded)
        {
            // update the global customer
            this.setCurrentCust(prevCust);

            // uses "previous" customer
            this.processCustPost(prevCust, currentStatementCust);
            agingCompanyCustomer.insert(prevCust.company(), prevCust.AccountNum);
            isCustPostProcessingNeeded = false;
        }

        custTransQuery = this.custTransQueryForOtherCust(_party, _selectedCompanyList, statementCompanyList);

        if (custTransQuery != null)
        {
            currentCompany = '';

            if (CustAccStmtPrintMultiLETransCentralizedPaymFlight::instance().isEnabled())
            {
                QueryBuildDataSource qbdsCustTrans  = _query.dataSourceTable(tableNum(CustTrans));

                if (qbdsCustTrans != null)
                {
                    int rangeCount = qbdsCustTrans.rangeCount();
                    QueryBuildDataSource custTransDataSource = custTransQuery.dataSourceTable(tableNum(CustTrans));
                    for (int i = 1; i <= rangeCount; i++)
                    {
                        QueryBuildRange range = custTransDataSource.addRange(qbdsCustTrans.range(i).field());
                        range.value(qbdsCustTrans.range(i).value());
                    }
                }
            }

            // print any other customers second
            custTransRun = new QueryRun(custTransQuery);

            while (custTransRun.next())
            {
                cust = custTransRun.get(tableNum(CustTable));

                // Check the company because changed() doesn't include it for fan out. See also bug 47368.
                isCustChanged = SysReportRun::changed(custTransRun, tableNum(CustTable)) || cust.company() != currentCompany;
                currentCompany = cust.company();

                if (isCustChanged && isCustPostProcessingNeeded)
                {
                    // update the global customer
                    this.setCurrentCust(prevCust);

                    // uses "previous" customer
                    this.processCustPost(prevCust, currentStatementCust);
                    agingCompanyCustomer.insert(prevCust.company(), prevCust.AccountNum);
                    isCustPostProcessingNeeded = false;
                }

                if (isCustChanged && printSpaceAfterCust)
                {
                    printSpaceAfterCust = false;
                }

                if (isCustChanged)
                {
                    cust = custTransRun.get(tableNum(CustTable));

                    // references to the cust variable are cleared by the last call to QueryRun.Next
                    prevCust.data(cust);

                    // update the global customer
                    this.setCurrentCust(cust);

                    wasCustProcessed = this.processCustPre(cust, numberOfCustPrinted);

                    if (wasCustProcessed)
                    {
                        numberOfCustPrinted++;
                        printSpaceAfterCust = true;
                        isCustPostProcessingNeeded = true;
                    }
                }

                if (wasCustProcessed)
                {
                    trans = custTransRun.get(tableNum(CustTrans));

                    if (trans.RecId != 0)
                    {
                        this.processTrans(trans);
                        transHeading = false;
                    }
                }
            }
        }

        if (isCustPostProcessingNeeded)
        {
            // update the global customer
            this.setCurrentCust(prevCust);

            // uses "previous" customer
            this.processCustPost(prevCust, currentStatementCust);
            agingCompanyCustomer.insert(prevCust.company(), prevCust.AccountNum);
            isCustPostProcessingNeeded = false;
        }

        if (prevCust)
        {
            this.printAgingBalance(agingCompanyCustomer);
        }

        // make the statement cust global
        currentCust.data(currentStatementCust);

        // Clear the cached current cust address and name
        currentCustAddress = '';
        currentCustName = '';

        if (printSpaceAfterCust)
        {
            printSpaceAfterCust = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the specified transaction.
    /// </summary>
    /// <param name="_trans">
    /// The transaction to process.
    /// </param>
    protected void processTrans(CustTrans _trans)
    {
        AmountCur transAmount;
        int currencyIndex;

        changecompany(_trans.company())
        {
            _trans.resetAmountsToDate(statementEndDate);

            if (!this.includeOnStatement(_trans))
            {
                return;
            }

            custTransCount++;

            // update the global transaction
            currentTrans = _trans;

            // set up for the payment schedule
            tmpCustVendTransOpen = CustAccountStatementExtController::getTmpCustVendTransOpen(currentTrans, this.parmContract().parmToDate(), onlyOpen);

            select count(RecId), minOf(DueDate) from tmpCustVendTransOpen;
            numberOfTransOpen = int642int(tmpCustVendTransOpen.RecId);

            // Checking the number of open transactions and payment schedule parameter
            if (numberOfTransOpen == 1 || (numberOfTransOpen > 1 && !printPaymentSchedule))
            {
                // this seems to do nothing
                if (printPaymentSchedule)
                {
                    select firstonly tmpCustVendTransOpen;
                }
                else
                {
                    select minOf(DueDate) from tmpCustVendTransOpen;
                }

                transHeading = true;
            }

            // Open transactions
            if (onlyOpen)
            {
                transAmount = _trans.remainAmountCur();
            }
            else
            {
                // Set the transaction amount to the MST currency amount if single currency report
                if(!this.singleCurrencyReport)
                {
                    transAmount = _trans.AmountCur;
                }
                else
                {
                    transAmount = _trans.AmountMST;
                }
            }

            // add to the cust balance
            currencyIndex = conFind(custCurrencyList, this.singleCurrencyReport ? Ledger::accountingCurrency(CompanyInfo::current()) : _trans.CurrencyCode);

            // If the currency does not exist and we are dealing with multiple currency reports
            if (currencyIndex == 0)
            {
                currencyIndex = this.singleCurrencyReport ? this.addCustCurrency(Ledger::accountingCurrency(CompanyInfo::current())) : this.addCustCurrency(_trans.CurrencyCode);
            }

            // Sets the current balence to the currency
            this.setCustBalanceCur(currencyIndex, transAmount);
            // If we have a single currency report, all summations must be done using the client default currency
            if (this.singleCurrencyReport)
            {
                statementBalanceCur[currencyIndex] += transAmount;
            }
            else 
            {
                
                // add to the statement balance
                currencyIndex = conFind(statementCurrencyList, _trans.CurrencyCode);
                Debug::assert(currencyIndex != 0);
                statementBalanceCur[currencyIndex] += transAmount;
            }

            // put the transaction on the report
            cust_Trans = true;
            this.insertCustAccountStatementExtTmp(0);
            cust_Trans = false;

            if (numberOfTransOpen > 1 && printPaymentSchedule)
            {
                // print multiple transactions for the payment schedule
                while select tmpCustVendTransOpen
                    order by DueDate
                {
                    vendTransOpen = true;
                    this.insertCustAccountStatementExtTmp(0);
                    vendTransOpen = false;

                    if (specifyDueToDate)
                    {
                        this.tmpCustVendTransDetail();
                    }
                }
            }
            else if (specifyDueToDate)
            {
                if (numberOfTransOpen > 1)
                {
                    while select tmpCustVendTransOpen
                        order by DueDate
                    {
                        this.tmpCustVendTransDetail();
                    }
                }
                else if (_trans.remainAmountCur() != 0) // this seems to do nothing
                {
                    // Show only open trans as due per
                    this.tmpCustVendTrans();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustBalanceCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the transaction amount by currency in an array storing customer balances in accounting currency.
    /// </summary>
    /// <param name = "_currencyIndex">
    /// Integer type variable which defines the index of the currency.
    /// </param>
    /// <param name = "_transAmount">
    /// Amount to be set.
    /// </param>
    protected void setCustBalanceCur(int _currencyIndex, AmountCur _transAmount)
    {
        custBalanceCur[_currencyIndex] += _transAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preRunPrintMgmt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Pre runs the print report.
    /// </summary>
    protected void preRunPrintMgmt()
    {
        switch (this.getGiroType())
        {
            case PaymentStub::ESR_red_bank:
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceCH00007, funcName());
                break;
            case PaymentStub::ESR_orange:
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceCH00008, funcName());
                break;
            case PaymentStub::FIK751:
            case PaymentStub::FIK752:
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceDK00007, funcName());
                break;
            case PaymentStub::BBS:
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceNO00004, funcName());
                break;
            case PaymentStub::Finnish:
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceFI00002, funcName());
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPrintMgmt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Runs the print report.
    /// </summary>
    protected void runPrintMgmt()
    {
        DateCode dateCode = this.parmContract().parmDateCode();

        // When <C>CustAccountStatementDateCodeRecurrenceExecutionFlight<C> is enabled and date interval is specified then populate date from date interval parameters.
        // When <C>CustAccountStatementDateCodeRecurrenceExecutionFlight<C> is disabled and from date and to date are empty, but date interval is specified then populate dates from date interval parameters.
        if ((CustAccountStatementDateCodeRecurrenceExecutionFlight::instance().isEnabled() && dateCode)
            || (!CustAccountStatementDateCodeRecurrenceExecutionFlight::instance().isEnabled() && dateCode && !this.parmContract().parmFromDate() && !this.parmContract().parmToDate()))
        {
            LedgerPeriodCode ledgerPeriodCode = LedgerPeriodCode::find(dateCode);

            if (ledgerPeriodCode)
            {
                this.parmContract().parmFromDate(ledgerPeriodCode.fromDate());
                this.parmContract().parmToDate(ledgerPeriodCode.toDate());
            }
        }
        
        this.preRunPrintMgmt();

        // <GCN>
        isTaxIntegrateEnable_CN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCN]) && CustParameters::find().TaxIntegrationSystem_CN;
        // </GCN>

        // Pre-validate the number of reports that will be printed
        initialPreRunValidate = true;
        var preRunValidateState = this.processPreRunValidate();
        initialPreRunValidate = false;
        if (preRunValidateState != SrsReportPreRunState::Run)
        {
            return;
        }

        // Report Parameters
        statementStartDate = this.parmContract().parmFromDate();
        statementEndDate = this.parmContract().parmToDate() == dateNull() ? maxDate() : this.parmContract().parmToDate();
        onlyOpen = this.parmContract().parmOnlyOpen();
        includeReversed = this.parmContract().parmIncludeReversed();
        printGiro = this.parmContract().parmPrintGiro();
        printNotZero = this.parmContract().parmPrintNonZero();
        printAmountOnGiro = this.parmContract().parmPrintAmountGiro();
        printPaymentSchedule = this.parmContract().parmPrintPaymentSchedule();
        specifyDueToDate = this.parmContract().parmSpecifyDueToDate();
        singleCurrencyReport = this.parmContract().parmSingleCurrencyReport();

        if (CustAccountStatementExtIncludeLogoDialogFlight::instance().isEnabled())
        {
            includeCompanyLogo = this.parmContract().parmIncludeCompanyLogo();
        }

        // This variable 'cleanUpData' needs to be set true in the event of the removal of CustAccountStatementExtCleanTmpTableDialogFlight.
        if (CustAccountStatementExtCleanTmpTableFlight::instance().isEnabled())
        {
            cleanUpData = this.parmContract().parmCleanUpData();
        }

        showAging = this.parmContract().parmPrintAging(); // Controls whether any aging is shown
        if (showAging)
        {
            useAgingDefinition = this.parmContract().parmAgingPeriod(); // predefined or manually defined aging periods?
            if (useAgingDefinition)
            {
                agingDefinition = this.parmContract().parmAgingBucket(); // If using predefined aging, this is the aging definition name
                showAgingDescription = this.parmContract().parmAgingBucketPrintDescription() == NoYesCombo::Yes;
            }
            else
            {
                manualAgingInterval = this.parmContract().parmInterval();
                manualAgingDayMonth = this.parmContract().parmDayMonth();
                manualAgingDirection = this.parmContract().parmPrintingDirection();
            }
        }

        statementCompany = curext();

        if (this.getGiroType() != PaymentStub::None)
        {
            SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(CustTable)), fieldNum(CustTable, GiroTypeAccountStatement)).value(strFmt('%1', this.getGiroType()));
        }

        this.initializePrintManagementSettingDetail();

        // Company list
        var selectedCompanyList = CustAccountStatementExtController::getSelectedCompanyList(query, curext());

        if (this.getGiroType() == PaymentStub::FIK752 && (Ledger::accountingCurrency(CompanyInfo::current()) != 'DKK' || this.checkCurrency()))
        {
            info("@SYS343346");
        }

        if (this.getGiroType() == PaymentStub::ESR_red_bank && this.checkMultipleCurrency())
        {
            throw info("@SYS344476");
        }

        // Checking start date and end date
        if (statementStartDate == dateNull() || statementEndDate == dateMax())
        {
            showAging = false;
        }

        if (conLen(selectedCompanyList) != 0)
        {
            var customerList = new Set(Types::Int64);

            query.allowCrossCompany(false);
            var customerQueryRun = new QueryRun(query);
            boolean isEncounteredException = false;
            while (customerQueryRun.next() && !this.parmCancelRun())
            {
                try
                {
                    CustTable custTable = customerQueryRun.get(tableNum(CustTable));
    
                    // Do not run twice for the same customer
                    if (!customerList.in(custTable.RecId))
                    {
                        setPrefix(strFmt("@AccountsReceivable:CustAccountNumber", CustTable.AccountNum));
                        customerList.add(custTable.RecId);
    
                        createdTransactionId = 0;
    
                        // Reset this flag after printing each customer details.
                        custAccountStatementExtTmp.Flag = 0;
    
                        // If no customer language is specified use current user language
                        languageId = custTable.languageId() ? custTable.languageId() : infolog.language();
    
                        ttsbegin;
                        this.processParty(query, custTable.Party, selectedCompanyList);
                        ttscommit;
    
                        // only run the report if any data was inserted
                        if (createdTransactionId)
                        {
                            this.populateReportSettingsByCustomer(custTable);
    
                            this.outputReports();
                        }
                    }
                }            
                catch (Exception::Break)
                {
                    // This error has been thrown to terminate the process in case of session timeout.
                    if (CustAccountStatementExtBreakExceptionFlight::instance().isEnabled())
                    {
                        throw Error('');
                    }
                }
                catch
                {
                    isEncounteredException = true;
                }
                finally
                {
                    if (CustAccountStatementExtCleanTmpTableFlight::instance().isEnabled()
                        && cleanUpData)
                    {
                        delete_from custAccountStatementExtTmp;
                    }
                }
            }

            if (isEncounteredException)
            {
                //This error has been thrown just to fail the batch after processing all the customers and
                //later on this error message is overwritten by the framework generic message.
                throw Error('');
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePrintManagementSettingDetail</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes print management setting details.
    /// </summary>
    protected void initializePrintManagementSettingDetail()
    {
        formLetterReport.parmDefaultCopyPrintJobSettings(this.getReportContract().parmPrintSettings());
        formLetterReport.parmDefaultOriginalPrintJobSettings(this.getReportContract().parmPrintSettings());
        formLetterReport.parmUsePrintMgmtDestinations(this.parmContract().parmUsePrintManagement());
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateReportSettingsByCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the report settings.
    /// </summary>
    /// <param name = "_custTable">
    /// A customer record buffer.
    /// </param>
    protected void populateReportSettingsByCustomer(CustTable _custTable)
    {
        this.parmContract().parmRecordId(createdTransactionId);
        this.parmContract().parmCustAccount(_custTable.AccountNum);
        // Send the tmpTable's physical name to the RDP class
        this.parmContract().parmCustAccountStatementExtTmp(custAccountStatementExtTmp.getPhysicalTableName());

        this.parmReportContract().parmRdlContract().parmLanguageId(languageId);
        this.parmReportContract().parmRdlContract().parmLabelLanguageId(languageId);
        formLetterReport.loadPrintSettings(_custTable, _custTable, languageId, _custTable.AccountNum);

        if (!this.parmContract().parmUsePrintManagement() && cbdDestinationsController)
        {
            cbdDestinationsController.setERDestinationsInPrintSettings(formLetterReport.parmReportRun());
        }

        // <GCN>
        if (isTaxIntegrateEnable_CN)
        {
            if (formLetterReport.moveNextPrintSetting())
            {
                if (formLetterReport.getCurrentPrintSetting().parmSSRS() == PrintMgmtSSRS::SSRS)
                {
                    PrintMgmtPrintSettingDetail printSettingDetail = formLetterReport.getCurrentPrintSetting();
                    this.parmReportName(ssrsReportStr(CustAccountStatementExt, Report_CN));
                    printSettingDetail.parmReportFormatName(this.parmReportName());
                    formLetterReport.parmReportRun().loadSettingDetail(printSettingDetail);
                }
                else
                {
                    formLetterReport.loadPrintSettings(_custTable, _custTable, languageId, _custTable.AccountNum);
                }
            }
        }
        // </GCN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCommonData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets company information, logo and other common report header information to <c>CustAccountStatementExtTmp</c> table buffer.
    /// </summary>
    protected void setCommonData()
    {
        // Company Info
        custAccountStatementExtTmp.CompanyName = statementCompanyInfo.name();
        custAccountStatementExtTmp.CompanyAddress = statementCompanyInfo.postalAddress().Address;

        // Company logo
        if (CustAccountStatementExtIncludeLogoDialogFlight::instance().isEnabled())
        {
            if (includeCompanyLogo)
            {
                this.setCompanyLogo();
            }
            else
            {
                custAccountStatementExtTmp.PrintLogo = NoYes::No;
                custAccountStatementExtTmp.CompanyLogo = connull();
            }
        }
        else
        {
            this.setCompanyLogo();
        }

        if (statementCompanyInfo.PrintEnterpriseregister_NO)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceNO00011, funcName());
            custAccountStatementExtTmp.Enterpriseregister_NO = SysLabel::labelId2String(literalStr("@SYS4002065"),languageId);
        }

        custAccountStatementExtTmp.CompanyPhone = statementCompanyInfo.phone();
        custAccountStatementExtTmp.CompanyTeleFax = statementCompanyInfo.teleFax();
        custAccountStatementExtTmp.CompanyGiro = statementCompanyInfo.Giro;
        custAccountStatementExtTmp.CompanyCoRegNum = statementCompanyInfo.CoRegNum;
        custAccountStatementExtTmp.CompanyVATNum = TaxRegistration::getCompanyTaxRegNum_W(statementEndDate);
        custAccountStatementExtTmp.ShowCompanyVATNum = CustFormLetterParameters::find().PrintCustAccountStatementVATNum;
        custAccountStatementExtTmp.CompanyEnterpriseNumber = statementCompanyInfo.getPrimaryRegistrationNumber(TaxRegistrationTypesList::UID, statementenddate);

        // Period
        custAccountStatementExtTmp.FromDate = statementStartDate;
        custAccountStatementExtTmp.ToDate = statementEndDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCurrentCust</Name>
				<Source><![CDATA[
    private void setCurrentCust(CustTable _cust)
    {
        currentCust = _cust;

        // Clear out the cached address and name
        currentCustAddress = '';
        currentCustName = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes and inserts <c>TmpCustVendTrans</c> table record.
    /// </summary>
    private void tmpCustVendTrans()
    {
        this.initTmpCustVendTrans();

        tmpCustVendTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>TmpCustVendTrans</c> table buffer from <c>TmpCustVendTransOpen</c> table buffer.
    /// </summary>
    protected void initTmpCustVendTrans()
    {
        CustSettlement custSettlement;

        select sum (SettleAmountCur) from custSettlement
            where custSettlement.TransCompany == currentTrans.DataAreaId
            && custSettlement.TransRecId == currentTrans.RecId
            && custSettlement.AccountNum == currentTrans.AccountNum;

        custAccountStatementExtTmp.Flag = 2;
        tmpCustVendTrans.DueDate = tmpCustVendTransOpen.DueDate;
        tmpCustVendTrans.TransDate = currentTrans.TransDate;
        tmpCustVendTrans.Invoice = currentTrans.Invoice;
        tmpCustVendTrans.CurrencyCode = currentTrans.CurrencyCode;
        tmpCustVendTrans.AmountCur = currentTrans.AmountCur - custSettlement.SettleAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpCustVendTransDetail</Name>
				<Source><![CDATA[
    protected void tmpCustVendTransDetail()
    {
        tmpCustVendTrans.DueDate = tmpCustVendTransOpen.DueDate;
        tmpCustVendTrans.TransDate = tmpCustVendTransOpen.TransDate;
        tmpCustVendTrans.Invoice = currentTrans.Invoice;
        tmpCustVendTrans.CurrencyCode = currentTrans.CurrencyCode;
        tmpCustVendTrans.AmountCur = tmpCustVendTransOpen.AmountCur;
        tmpCustVendTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBaseCustTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the basic query for the customers and transactions with the specified party ID.
    /// </summary>
    /// <param name="_party">
    /// The party ID.
    /// </param>
    /// <param name="_statementStartDate">
    /// The statement from date.
    /// </param>
    /// <param name="_statementEndDate">
    /// The statement to date.
    /// </param>
    /// <param name="_includeReversed">
    /// A Boolean value that indicates whether to include reversed transactions.
    /// </param>
    /// <returns>
    /// A query for customers and their transactions.
    /// </returns>
    protected static Query createBaseCustTransQuery(DirPartyRecId _party, TransDate _statementStartDate, TransDate _statementEndDate, boolean _includeReversed)
    {
        Query custTransQuery = new Query();
        QueryBuildDataSource custDataSource;
        QueryBuildDataSource transDataSource;
        QueryBuildDataSource reversalTransDataSource;

        custDataSource = custTransQuery.addDataSource(tableNum(CustTable));
        custDataSource.addOrderByField(fieldNum(CustTable, DataAreaId));
        custDataSource.addRange(fieldNum(CustTable, Party)).value(SysQuery::value(_party));

        transDataSource = custDataSource.addDataSource(tableNum(CustTrans));
        transDataSource.addLink(fieldNum(CustTable, AccountNum), fieldNum(CustTrans, AccountNum));
        // use outer join because customers without transactions are included
        transDataSource.joinMode(JoinMode::OuterJoin);
        transDataSource.addRange(fieldNum(CustTrans, TransDate)).value(SysQuery::range(_statementStartDate, _statementEndDate));
        transDataSource.addRange(fieldNum(CustTrans, TransType)).value(strFmt('((%1 != %2) && (%1 != %3))',
                                                                                fieldStr(CustTrans, TransType),
                                                                                any2int(LedgerTransType::ExchAdjustment),
                                                                                any2int(LedgerTransType::Settlement)));
        transDataSource.addOrderByField(fieldNum(CustTrans, DataAreaId));
        transDataSource.addOrderByField(fieldNum(CustTrans, TransDate));
        transDataSource.addOrderByField(fieldNum(CustTrans, Voucher));

        if (!_includeReversed)
        {
            reversalTransDataSource = transDataSource.addDataSource(tableNum(TransactionReversalTrans));
            reversalTransDataSource.joinMode(JoinMode::NoExistsJoin);
            reversalTransDataSource.addLink(fieldNum(CustTrans, TableId), fieldNum(TransactionReversalTrans, RefTableId));
            reversalTransDataSource.addLink(fieldNum(CustTrans, RecId), fieldNum(TransactionReversalTrans, RefRecId));
            reversalTransDataSource.addRange(fieldNum(TransactionReversalTrans, Reversed)).value(enum2str(NoYes::Yes));
        }

        return custTransQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustTransQueryForOtherCust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a query for the non-statement customers and transactions of the specified party ID and list
    /// of companies.
    /// </summary>
    /// <param name="_party">
    /// The party ID of the customers to include.
    /// </param>
    /// <param name="_selectedCompanyList">
    /// The list of selected companies.
    /// </param>
    /// <param name="_statementCompanyList">
    /// The list of companies processed to find the statement customer.
    /// </param>
    /// <param name="_statementStartDate">
    /// The statement from date.
    /// </param>
    /// <param name="_statementEndDate">
    /// The statement to date.
    /// </param>
    /// <param name="_includeReversed">
    /// A Boolean value that indicates whether to include reversed transactions.
    /// </param>
    /// <returns>
    /// A query for non-statement customers and their transactions; otherwise, null.
    /// </returns>
    protected static Query createCustTransQueryForOtherCust(
            DirPartyRecId _party,
            container _selectedCompanyList,
            container _statementCompanyList,
            TransDate _statementStartDate,
            TransDate _statementEndDate,
            boolean _includeReversed)
    {
        Query q;
        CompanyId company;
        container companyList;
        int i;

        companyList = CustAccountStatementExtController::createDiffCompanies(_selectedCompanyList, _statementCompanyList);

        if (conLen(companyList) == 0)
        {
            // do nothing because there are no companies to process
            q = null;
        }
        else
        {
            q = CustAccountStatementExtController::createBaseCustTransQuery(_party, _statementStartDate, _statementEndDate, _includeReversed);

            q.allowCrossCompany(true);
            q.clearCompanyRange();

            for (i = 1; i <= conLen(companyList); i++)
            {
                company = conPeek(companyList, i);

                q.addCompanyRange(company);
            }
        }

        return q;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustTransQueryForStatementCust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a query for the statement customer and its transactions of the specified party ID and list
    /// of companies.
    /// </summary>
    /// <param name="_query">
    /// A query with user criteria.
    /// </param>
    /// <param name="_party">
    /// The party ID of the customers to include.
    /// </param>
    /// <param name="_statementCompany">
    /// The company to use as the statement company.
    /// </param>
    /// <param name="_selectedCompanyList">
    /// The list of selected companies.
    /// </param>
    /// <param name="_statementStartDate">
    /// The statement from date.
    /// </param>
    /// <param name="_statementEndDate">
    /// The statement to date.
    /// </param>
    /// <param name="_includeReversed">
    /// A Boolean value that indicates whether to include reversed transactions
    /// </param>
    /// <param name="_printGiro">
    /// A Boolean value that indicates whether to print the payment stub.
    /// </param>
    /// <returns>
    /// A query for the statement customer and its transactions; otherwise, null.
    /// </returns>
    protected Query createCustTransQueryForStatementCust(
        Query _query,
        DirPartyRecId _party,
        CompanyId _statementCompany,
        container _selectedCompanyList,
        TransDate _statementStartDate,
        TransDate _statementEndDate,
        boolean _includeReversed,
        PaymentStub _printGiro)
    {
        Query q;
        QueryBuildDataSource custDataSource;
        QueryBuildRange range;
        int rangeCount;
        int i;

        if (conFind(_selectedCompanyList, _statementCompany) == 0)
        {
            // do nothing because the statement company is not in the company list
            q = null;
        }
        else
        {
            q = CustAccountStatementExtController::createBaseCustTransQuery(_party, _statementStartDate, _statementEndDate, _includeReversed);

            q.allowCrossCompany(true);
            q.clearCompanyRange();
            q.addCompanyRange(_statementCompany);

            custDataSource = q.dataSourceTable(tableNum(CustTable));

            rangeCount = _query.dataSourceTable(tableNum(CustTable)).rangeCount();
            for (i = 1; i <= rangeCount; i++)
            {
                range = custDataSource.addRange(_query.dataSourceTable(tableNum(CustTable)).range(i).field());
                range.value(_query.dataSourceTable(tableNum(CustTable)).range(i).value());
            }

            QueryBuildDataSource qbdsCustTrans  = _query.dataSourceTable(tableNum(CustTrans));

            if (qbdsCustTrans != null)
            {
                rangeCount = _query.dataSourceTable(tableNum(CustTrans)).rangeCount();
                for (i = 1; i <= rangeCount; i++)
                {
                    if (_query.dataSourceTable(tableNum(CustTrans)).range(i).field() == fieldNum(CustTrans, TransType))
                    {
                        q.dataSourceTable(tableNum(CustTrans)).clearRange(fieldNum(CustTrans, TransType));
                    }

                    range = (q.dataSourceTable(tableNum(CustTrans))).addRange(_query.dataSourceTable(tableNum(CustTrans)).range(i).field());
                    range.value(_query.dataSourceTable(tableNum(CustTrans)).range(i).value());
                }
            }

            if (_printGiro != PaymentStub::None && _printGiro != PaymentStub::Finnish)
            {
                range = custDataSource.addRange(fieldNum(CustTable, GiroTypeAccountStatement));
                range.value(queryValue(_printGiro));
                range.status(RangeStatus::Locked);
            }
        }

        return q;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDiffCompanies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a list of the items from the full list that are not in the excluded list.
    /// </summary>
    /// <param name="_fullList">
    /// The list of all items.
    /// </param>
    /// <param name="_excludedList">
    /// The list of excluded items.
    /// </param>
    /// <returns>
    /// A list of items.
    /// </returns>
    /// <remarks>
    /// The lists are not updated.
    /// </remarks>
    private static container createDiffCompanies(container _fullList, container _excludedList)
    {
        container diffList = conNull();
        CompanyId item;
        int i;

        for (i = 1; i <= conLen(_fullList); i++)
        {
            item = conPeek(_fullList, i);

            if (conFind(_excludedList, item) == 0)
            {
                diffList += item;
            }
        }
        return diffList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSelectedCompanyList</Name>
				<Source><![CDATA[
    private static container getSelectedCompanyList(Query _query, CompanyId _company)
    {
        container queryCompanyRange;
        container queryCompanyRangeList;
        container selectedCompanyList = conNull();
        container sharedCompanyList;
        boolean isShared;
        int i;

        #Define.CompanyPosition(1)
        #Define.IsMarkedPosition(2)

        if (isConfigurationkeyEnabled(configurationKeyNum(CustCentralizedCustStatement)))
        {
            // this retrieves the company range specified by the user on the statement dialog
            queryCompanyRangeList = _query.getCompanyRange();

            sharedCompanyList = CustVendOpenTransManager::findSharedServiceCompanies(_company);

            // include only valid companies in the company list
            for (i = 1; i <= conLen(queryCompanyRangeList); i++)
            {
                queryCompanyRange = conPeek(queryCompanyRangeList, i);

                isShared = conFind(sharedCompanyList, conPeek(queryCompanyRange, #CompanyPosition)) != 0;

                if (conPeek(queryCompanyRange, #IsMarkedPosition) && isShared)
                {
                    selectedCompanyList += conPeek(queryCompanyRange, #CompanyPosition);
                }
            }
        }
        else
        {
            selectedCompanyList += _company;
        }

        return selectedCompanyList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpCustVendTransOpen</Name>
				<Source><![CDATA[
    private static TmpCustVendTransOpen getTmpCustVendTransOpen(CustTrans _custTrans, TransDate _transDate, boolean _onlyOpen)
    {
        CustVendTransDetails detail = new CustVendTransDetails(_custTrans, _transDate);
        TmpCustVendTransOpen tmpOpen = detail.tmpCustVendTransOpen(_onlyOpen);

        return tmpOpen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMultithreadable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the report printing supports multi-threading.
    /// </summary>
    /// <returns>A boolean value which specifies if printing of this report can be done in multiple threads. </returns>
    public boolean isMultithreadable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        SrsPrintMgmtFormLetterController controller = new CustAccountStatementExtController();
        controller.parmReportName(PrintMgmtDocType::construct(PrintMgmtDocumentType::CustAccountStatement).getDefaultReportFormat());
        controller.parmArgs(_args);
        CustAccountStatementExtController::startControllerOperation(controller, _args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>startControllerOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Starts the operation for the given <c>SrsPrintMgmtFormLetterController</c> class instance.
    /// </summary>
    /// <param name="_controller">
    /// <c>SrsPrintMgmtFormLetterController</c> class instance to be started.
    /// </param>
    /// <param name="_args">
    /// <c>Args</c> instance from the main.
    /// </param>
    protected static void startControllerOperation(SrsPrintMgmtFormLetterController _controller, Args _args)
    {
        _controller.startOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a currency to a customer specific currency code list.
    /// </summary>
    /// <param name="_currency">
    /// Currency code to be added.
    /// </param>
    /// <returns>
    /// The current index of the customer currency list.
    /// </returns>
    protected int addCustCurrency(CurrencyCode _currency)
    {
        // new currency found
        
        custCurrencyList = this.createMergeCurrency(custCurrencyList, [_currency]);
        statementCurrencyList = this.createMergeCurrency(statementCurrencyList, custCurrencyList);
        
        AmountCur balanceAmount;

        if (onlyOpen)
        {
            balanceAmount = currentCust.openBalanceCur(dateNull(), statementStartDate - 1, statementEndDate, _currency);
        }
        else
        {
            balanceAmount = currentCust.balanceCurPerDate(statementStartDate - 1, _currency);
        }

        int custCurrencyIndex = conFind(custCurrencyList, _currency);
        custBalanceCur[custCurrencyIndex] += balanceAmount;

        int statementCurrencyIndex = conFind(statementCurrencyList, _currency);
        Debug::assert(statementCurrencyIndex != 0);
        statementBalanceCur[statementCurrencyIndex] += balanceAmount;

        if (haveNonStatementCust)
        {
            // print the multi-company heading if the statement contains a customer not from
            // the statement company
            multiCompany = true;
        }

        openingBalance = custBalanceCur[custCurrencyIndex];
        openBal = true;
        this.insertCustAccountStatementExtTmp(custCurrencyIndex);
        openBal = false;
        openingBalance = 0;

        return custCurrencyIndex;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataContractInfoObjectsInternal</Name>
				<Source><![CDATA[
    protected Map getDataContractInfoObjectsInternal()
    {
        if (!dataContractInfoObjects)
        {
            super();

            if (cbdDestinationsController)
            {
                if (!formLetterReport)
                {
                    this.initFormLetterReport();
                }

                cbdDestinationsController.setHierarchyType(formLetterReport.parmReportRun().parmHierarchyType());
                cbdDestinationsController.setNodeType(formLetterReport.parmReportRun().parmNodeType());
                cbdDestinationsController.setDocumentType(formLetterReport.parmReportRun().parmDocType());
                cbdDestinationsController.setUseAllAvailablePrintSettingDetails(
                    !this.parmArgs()
                    || !this.parmArgs().record()
                    || this.parmArgs().record().TableId != tableNum(CustTable));

                Query queryLoc = this.applyQueryRange(new Query(this.getFirstQuery().pack()));
                queryLoc.allowCrossCompany(false);

                QueryBuildDataSource qbds = queryLoc.dataSourceTable(tableNum(CustTable));
                qbds.orderMode(OrderMode::GroupBy);
                qbds.addSortField(fieldNum(CustTable, RecId));

                cbdDestinationsController.initERFormatDestinations(queryLoc, dataContractInfoObjects);
            }
        }
        return dataContractInfoObjects;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showDestinationTab</Name>
				<Source><![CDATA[
    public boolean showDestinationTab(boolean _showDestinationTab = false)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDisplayFormatNameOnDestinationTab</Name>
				<Source><![CDATA[
    public boolean shouldDisplayFormatNameOnDestinationTab()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyQueryRange</Name>
				<Source><![CDATA[
    private Query applyQueryRange(Query _query)
    {
        QueryBuildDataSource qbds = _query.dataSourceTable(tableNum(CustTable));

        if (this.parmArgs() && this.parmArgs().record() && this.parmArgs().record().TableId == tableNum(CustTable))
        {
            FormDataSource formDataSource = FormDataUtil::getFormDataSource(this.parmArgs().record());
            str rangeStr;

            if (formDataSource && formDataSource.recordsMarked().lastIndex() > 1)
            {
                for (CustTable custTable = getFirstSelection(formDataSource); custTable; custTable = formDataSource.getNext())
                {
                    rangeStr += (rangeStr ? ',' : '') + queryValue(custTable.AccountNum);
                }
            }
            else
            {
                CustTable custTable = CustTable::findRecId(this.parmArgs().record().RecId);
                rangeStr = queryValue(custTable.AccountNum);
            }

            SysQuery::findOrCreateRange(qbds, fieldNum(CustTable, AccountNum)).value(rangeStr);
        }
        else
        {
            QueryBuildRange range = SysQuery::findOrCreateRange(qbds, fieldNum(CustTable, AccountNum));

            if (!range.value())
            {
                // Only when there is no syslastvalue for cusomer account number range.
                range.value(SysQuery::valueUnlimited());
            }
        }

        return _query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCompanyLogo</Name>
				<Source><![CDATA[
    private void setCompanyLogo()
    {
        if (conLen(FormLetter::companyLogo()) == 0)
        {
            custAccountStatementExtTmp.PrintLogo = NoYes::No;
        }
        else
        {
            custAccountStatementExtTmp.PrintLogo = NoYes::Yes;

            if (insertCompanyLogo)
            {
                custAccountStatementExtTmp.CompanyLogo = FormLetter::companyLogo();
                insertCompanyLogo = false;
            }
            else
            {
                custAccountStatementExtTmp.CompanyLogo = connull();
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>