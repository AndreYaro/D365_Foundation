<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjWorkBreakdownStructureHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// This class is used to perform WBS tasks add and delete methods.
/// </summary>
class ProjWorkBreakdownStructureHelper
{
    const str hierarchyLevelTemplateField = 'HierarchyLevel%1';

    private ProjPlanVersion parentTask;
    private LineNum siblingNumber;
    private str pathIdPrefix;
    private int hierarchyDepth;
    private ProjHierarchySorting hierarchySorting;
    private ProjPlanVersion previousTaskParent;
    private ProjPlanVersion updatedTaskParent;
    private LineNum aboveSiblingNumber;
    private LineNum newSiblingNumber;
    private LineNum previousSiblingNumber;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmParentTask</Name>
				<Source><![CDATA[
    protected ProjPlanVersion parmParentTask(ProjPlanVersion _parentTask = parentTask)
    {
        parentTask = _parentTask;
        return parentTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSiblingNumber</Name>
				<Source><![CDATA[
    protected LineNum parmSiblingNumber(LineNum _siblingNumber = siblingNumber)
    {
        siblingNumber = _siblingNumber;
        return siblingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPathIdPrefix</Name>
				<Source><![CDATA[
    protected str parmPathIdPrefix(str _pathIdPrefix = pathIdPrefix)
    {
        pathIdPrefix = _pathIdPrefix;
        return pathIdPrefix;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHierarchyDepth</Name>
				<Source><![CDATA[
    protected int parmHierarchyDepth(int _hierarchyDepth = hierarchyDepth)
    {
        hierarchyDepth = _hierarchyDepth;
        return hierarchyDepth;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHierarchySorting</Name>
				<Source><![CDATA[
    protected ProjHierarchySorting parmHierarchySorting(ProjHierarchySorting _hierarchySorting = hierarchySorting)
    {
        hierarchySorting = _hierarchySorting;
        return hierarchySorting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreviousTaskParent</Name>
				<Source><![CDATA[
    protected ProjPlanVersion parmPreviousTaskParent(ProjPlanVersion _previousTaskParent = previousTaskParent)
    {
        previousTaskParent = _previousTaskParent;
        return previousTaskParent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdatedTaskParent</Name>
				<Source><![CDATA[
    protected ProjPlanVersion parmUpdatedTaskParent(ProjPlanVersion _updatedTaskParent = updatedTaskParent)
    {
        updatedTaskParent = _updatedTaskParent;
        return updatedTaskParent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAboveSiblingNumber</Name>
				<Source><![CDATA[
    protected LineNum parmAboveSiblingNumber(LineNum _aboveSiblingNumber = aboveSiblingNumber)
    {
        aboveSiblingNumber = _aboveSiblingNumber;
        return aboveSiblingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNewSiblingNumber</Name>
				<Source><![CDATA[
    protected LineNum parmNewSiblingNumber(LineNum _newSiblingNumber = newSiblingNumber)
    {
        newSiblingNumber = _newSiblingNumber;
        return newSiblingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreviousSiblingNumber</Name>
				<Source><![CDATA[
    protected LineNum parmPreviousSiblingNumber(LineNum _previousSiblingNumber = previousSiblingNumber)
    {
        previousSiblingNumber = _previousSiblingNumber;
        return previousSiblingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipProjPlanVersionLogAndDataMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to skip <c>ProjPlanVersion</c> table logs and methods.
    /// </summary>
    /// <returns>true to skip <c>ProjPlanVersion</c> table logs and methods; otherwise, false.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected boolean skipProjPlanVersionLogAndDataMethods()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipPSAActivitySetupLogAndDataMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to skip <c>PSAActivitySetup</c> table logs and methods.
    /// </summary>
    /// <returns>true to skip <c>PSAActivitySetup</c> table logs and methods; otherwise, false.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected boolean skipPSAActivitySetupLogAndDataMethods()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipSmmActivitiesLogAndDataMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to skip <c>smmActivities</c> table logs and methods.
    /// </summary>
    /// <returns>true to skip <c>smmActivities</c> table logs and methods; otherwise, false.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected boolean skipSmmActivitiesLogAndDataMethods()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipHierarchyTreeTableLogAndDataMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to skip <c>HierarchyTreeTable</c> table logs and methods.
    /// </summary>
    /// <returns>true to skip <c>HierarchyTreeTable</c> table logs and methods; otherwise, false.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected boolean skipHierarchyTreeTableLogAndDataMethods()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipProjPlanVersionAssignmentLogAndDataMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to skip <c>ProjPlanVersionAssignment</c> table logs and methods.
    /// </summary>
    /// <returns>true to skip <c>ProjPlanVersionAssignment</c> table logs and methods; otherwise, false.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected boolean skipProjPlanVersionAssignmentLogAndDataMethods()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipPSAActivityEstimatesLogAndDataMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to skip <c>PSAActivityEstimates</c> table logs and methods.
    /// </summary>
    /// <returns>true to skip <c>PSAActivityEstimates</c> table logs and methods; otherwise, false.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected boolean skipPSAActivityEstimatesLogAndDataMethods()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipProjDependencyLogAndDataMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to skip <c>ProjDependency</c> table logs and methods.
    /// </summary>
    /// <returns>true to skip <c>ProjDependency</c> table logs and methods; otherwise, false.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected boolean skipProjDependencyLogAndDataMethods()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipProjHierarchySortingLogAndDataMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to skip <c>ProjHierarchySorting</c> table logs and methods.
    /// </summary>
    /// <returns>true to skip <c>ProjHierarchySorting</c> table logs and methods; otherwise, false.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected boolean skipProjHierarchySortingLogAndDataMethods()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowInitAddTaskParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to initialize parameters for add task parameters operation.
    /// </summary>
    /// <returns>true to initialize parameters for add task operation; otherwise, false.</returns>
    /// <remarks>
    /// This method is added for extensibility purpose.
    /// If user will change the return value to false, then user is necessary to set the following parameters in this method.
    /// this.parmParentTask()
    /// this.parmSiblingNumber()
    /// this.parmPathIdPrefix()
    /// this.parmHierarchyDepth()
    /// this.parmHierarchySorting()
    /// </remarks>
    protected boolean allowInitAddTaskParameters()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSyncEstimateLinesFromTaskForAddTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to skip the synchronize estimate lines from task operation.
    /// </summary>
    /// <returns>true to synchronize estimate lines from task operation; otherwise, false.</returns>
    /// <remarks>
    /// This method is added for extensibility purpose.
    /// </remarks>
    protected boolean allowSyncEstimateLinesFromTaskForAddTask()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowUpdateParentTasksPropertiesFromChildrenTaskForAddTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to update the parent tasks properties from children task for add task operation.
    /// </summary>
    /// <returns>true to update of parent tasks properties from children task; otherwise, false.</returns>
    /// <remarks>
    /// This method is added for extensibility purpose.
    /// </remarks>
    protected boolean allowUpdateParentTasksPropertiesFromChildrenTaskForAddTask()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowUpdateParentTasksPropertiesFromChildrenTaskForIndentTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to update the parent tasks properties from children task for indent task operation.
    /// </summary>
    /// <returns>true to update of parent tasks properties from children task; otherwise, false.</returns>
    /// <remarks>
    /// This method is added for extensibility purpose.
    /// </remarks>
    protected boolean allowUpdateParentTasksPropertiesFromChildrenTaskForIndentTask()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowUpdateParentTasksPropertiesFromChildrenTaskForOutdentTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to update the parent tasks properties from children task for outdent task operation.
    /// </summary>
    /// <returns>true to update of parent tasks properties from children task; otherwise, false.</returns>
    /// <remarks>
    /// This method is added for extensibility purpose.
    /// </remarks>
    protected boolean allowUpdateParentTasksPropertiesFromChildrenTaskForOutdentTask()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowUpdateParentTasksPropertiesFromChildrenTaskForDeleteTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether to update the parent tasks properties from children task for delete task operation.
    /// </summary>
    /// <returns>true to update of parent tasks properties from children task; otherwise, false.</returns>
    /// <remarks>
    /// This method is added for extensibility purpose.
    /// </remarks>
    protected boolean allowUpdateParentTasksPropertiesFromChildrenTaskForDeleteTask()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAddTaskParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize parameters for add task operation.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void initAddTaskParameters(ProjWorkBreakdownStructureContract _wbsContract)
    {
        if (_wbsContract.parmUpperSiblingTask())
        {
            ProjHierarchySorting sortingRecord;

            ProjPlanVersion upperSibling = _wbsContract.parmUpperSiblingTask();
            this.parmParentTask(ProjPlanVersion::findByHierarchyAndTaskId(
                _wbsContract.parmHierarchyId(), upperSibling.ParentHierarchyTaskId, true));
            this.parmSiblingNumber(upperSibling.TaskSiblingNumber + 1);
            this.parmPathIdPrefix(subStr(upperSibling.PathId, 0, strFind(upperSibling.PathId, '.', maxInt(), minInt())));
            this.parmHierarchyDepth(upperSibling.HierarchyLevel);
            sortingRecord.data(_wbsContract.parmUpperSiblingHierarchySorting());
            sortingRecord.setFieldValue(
                strFmt(hierarchyLevelTemplateField, this.parmHierarchyDepth()), 
                    real2Int(this.parmSiblingNumber()));
            this.parmHierarchySorting(sortingRecord);
            
            // Move lower siblings down
            ProjHierarchySorting parentSortingRecord =
                ProjWorkBreakdownStructureV2FormHelper::findProjHierarchySortingRecord(
                    _wbsContract.parmHierarchyId(), this.parmParentTask().HierarchyTaskId);
            this.moveTasks(_wbsContract.parmHierarchyId(), this.parmParentTask(), parentSortingRecord, this.parmSiblingNumber(), 1);
        }
        else
        {
            this.initAddTaskParametersWithNoUpperSiblingTask(_wbsContract);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAddTaskParametersWithNoUpperSiblingTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize add task operation parameters given that there is no uppoer sibling task.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void initAddTaskParametersWithNoUpperSiblingTask(ProjWorkBreakdownStructureContract _wbsContract)
    {
        ProjHierarchySorting sortingRecord;

        this.parmParentTask(ProjPlanVersion::getRootTask(_wbsContract.parmHierarchyId(), true));
        this.parmSiblingNumber(ProjPlanVersion::getChildTasksLastSiblingNumber(
            _wbsContract.parmHierarchyId(), parentTask.HierarchyTaskId) + 1);
        this.parmPathIdPrefix('');
        this.parmHierarchyDepth(1);
        sortingRecord.Type = ProjHierarchySortingType::ProjWBS;
        sortingRecord.RefId = _wbsContract.parmHierarchyId();
        sortingRecord.HierarchyLevel1 = real2Int(this.parmSiblingNumber());

        this.parmHierarchySorting(sortingRecord);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new task record and adds it as the next sibling of the given task (or a child of the root, if the given task is null).
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <returns><c>ProjPlanVersion</c> table buffer which was added.</returns>
    /// <remarks>
    ///
    /// These are the mandatroy parameters required for this API:
    /// ProjWorkBreakdownStructureContract.parmTargetTask()
    /// ProjWorkBreakdownStructureContract.parmHierarchyId()
    /// ProjWorkBreakdownStructureContract.parmWbsType()
    /// ProjWorkBreakdownStructureContract.parmAutoScheduling()
    ///
    /// This parameter is needed if this is a Project or Quotation WBS. But it's not needed for template WBS:
    /// ProjWorkBreakdownStructureContract.parmCalendarId()
    ///
    /// These parameters are optional:
    /// ProjWorkBreakdownStructureContract.parmUpperSiblingTask() Note: not specifing will cause task being added as the first sibling below the root task.
    /// ProjWorkBreakdownStructureContract.parmUpperSiblingHierarchySorting() Note: if parmUpperSiblingTask() is specified, this will be needed.
    /// ProjWorkBreakdownStructureContract.parmCalendarStandardWorkDayHours() Note: not specifing will require this value to be calculated in this method.
    ///
    /// This parameter is only needed to be set if this method is being called from ProjWorkbreakdownStructureV2 UI from:
    /// ProjWorkBreakdownStructureContract.parmUpdateTempTable(true)
    ///
    /// This parameter is only needed to be set if ProjWorkBreakdownStructureContract.parmUpdateTempTable() is set to true:
    /// ProjWorkBreakdownStructureContract.parmHierarchyTemp()
    ///
    /// </remarks>
    public ProjPlanVersion addTask(ProjWorkBreakdownStructureContract _wbsContract)
    {
        ProjPlanVersion newTask;
        if (_wbsContract.parmHierarchyId() && (_wbsContract.parmWbsType() == ProjWBSType::Template || _wbsContract.parmCalendarId()))
        {
            if (this.allowInitAddTaskParameters())
            {
                this.initAddTaskParameters(_wbsContract);
            }

            if (!_wbsContract.parmCalendarStandardWorkDayHours())
            {
                _wbsContract.parmCalendarStandardWorkDayHours(
                    ProjWorkBreakdownStructureV2FormHelper::getCalendarStandardWorkDayHours(_wbsContract.parmCalendarId()));
            }

            ttsbegin;
            // Add task record
            newTask = _wbsContract.parmTargetTask();
            newTask.HierarchyId = _wbsContract.parmHierarchyId();
            newTask.HierarchyTaskId = ProjPlanVersion::getNextTaskId(
                _wbsContract.parmHierarchyId(), _wbsContract.parmWbsType() == ProjWBSType::Project);
            newTask.ParentHierarchyTaskId = this.parmParentTask().HierarchyTaskId;
            newTask.TaskSiblingNumber = this.parmSiblingNumber();
            newTask.PathId = this.parmPathIdPrefix() + num2Str(this.parmSiblingNumber(), 0, 0, DecimalSeparator::Auto, ThousandSeparator::None);
            newTask.HierarchyLevel = this.parmHierarchyDepth();

            this.validateCircularReference(newTask);
            // If the hierarchy is a quotation, need to add related records.
            this.addQuotationRelatedRecordsForTask(newTask, this.parmParentTask(), _wbsContract);

            _wbsContract.parmTargetTask(newTask);
            newTask = this.specificFieldsToInsertForAddTask(_wbsContract);
            newTask.insert();
        
            // Add sorting record
            ProjHierarchySorting sortingRecord;
            sortingRecord.data(this.parmHierarchySorting());
            
            sortingRecord = this.addSortingTableRecord(newTask, sortingRecord, _wbsContract);
        
            // Add hierarchy temp table record.
            this.addHierarchyTempTableRecord(newTask, sortingRecord, _wbsContract);

            // Set task field defaults.
            ProjPlanVersion::setTaskDefaultsV2(_wbsContract.parmCalendarId(), _wbsContract.parmWBSType(), this.parmParentTask(),
                newTask, _wbsContract.parmAutoScheduling(), _wbsContract.parmCalendarStandardWorkDayHours());

            if (this.allowSyncEstimateLinesFromTaskForAddTask())
            {
                ProjEstimate::syncEstimateLinesFromTask(_wbsContract.parmHierarchyId(), newTask.HierarchyTaskId, _wbsContract.parmWBSType());
            }

            // Make sure the parent is a summary task
            ProjPlanVersion::setEndNodeStateV2(_wbsContract.parmCalendarId(), _wbsContract.parmWBSType(), this.parmParentTask(),
                FalseTrue::False, _wbsContract.parmCalendarStandardWorkDayHours());

            if (this.allowUpdateParentTasksPropertiesFromChildrenTaskForAddTask())
            {
                ProjPlanVersion::updateFromChildren(_wbsContract.parmCalendarId(), this.parmParentTask());
            }
        
            // Update parent scheduling status
            ProjActivityCapacity::updateSummaryTaskSchedulingStatus(this.parmParentTask());

            ttscommit;
        }
        return newTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSortingTableRecord</Name>
				<Source><![CDATA[
    private ProjHierarchySorting addSortingTableRecord(ProjPlanVersion _addedTask, ProjHierarchySorting _sortingRecord, ProjWorkBreakdownStructureContract _wbsContract)
    {
        // Add <c>ProjHierarchySorting</c> table record for each added task.
        _sortingRecord.RefNodeId = _addedTask.HierarchyTaskId;
        _sortingRecord.insert();

        return _sortingRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addHierarchyTempTableRecord</Name>
				<Source><![CDATA[
    private void addHierarchyTempTableRecord(ProjPlanVersion _addedTask, ProjHierarchySorting _sortingRecord, ProjWorkBreakdownStructureContract _wbsContract)
    {
        // Add <c>ProjHierarchyTemp</c> table record for each added task.
        if (_wbsContract.parmUpdateTempTable() && _wbsContract.parmHierarchyTemp())
        {
            ProjHierarchyTemp hierarchyTemp;
            hierarchyTemp.linkPhysicalTableInstance(_wbsContract.parmHierarchyTemp());
            hierarchyTemp.RefRecId = _addedTask.RecId;
            hierarchyTemp.RefSortRecId = _sortingRecord.RecId;
            hierarchyTemp.RefNodeId = _addedTask.HierarchyTaskId;
            hierarchyTemp.Visible = FalseTrue::True;
            hierarchyTemp.Expand = FalseTrue::False;
            hierarchyTemp.RefTableId = TableNum(ProjPlanVersion);
            hierarchyTemp.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addQuotationRelatedRecordsForTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add quotation related records for the specific added task.
    /// </summary>
    /// <param name = "_addedTask"><c>ProjPlanVersion</c> table buffer for the added task.</param>
    /// <param name = "_parentTask"><c>ProjPlanVersion</c> table buffer for the parent task of the added task.</param>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void addQuotationRelatedRecordsForTask(ProjPlanVersion _addedTask, ProjPlanVersion _parentTask, ProjWorkBreakdownStructureContract _wbsContract)
    {
        if (_wbsContract.parmWBSType() == ProjWBSType::ProjectQuotation)
        {
            ElementNumber parentTaskElementNumber = ProjWorkBreakdownStructureV2FormHelper::getCorrespondingTaskElementNumber(
                _wbsContract.parmHierarchyId(), _parentTask.HierarchyTaskId);
            _addedTask.HierarchyTreeTableRefRecId = ProjTaskNormalized::addTask(
                _wbsContract.parmHierarchyId(),
                parentTaskElementNumber,
                _addedTask.TaskName,
                _addedTask.TaskEffort,
                _addedTask.TaskStartDate,
                _addedTask.TaskFinishDate,
                _addedTask.TaskDuration,
                _addedTask.NumberOfResources);
            _wbsContract.parmTargetTask(_addedTask);
            _wbsContract.parmTargetTask(this.specificFieldsToUpdateForAddTask(_wbsContract));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>specificFieldsToInsertForAddTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specify <c>ProjPlanVersion</c> table buffer fields for add task before task is inserted.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <returns><c>ProjPlanVersion</c> table buffer.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected ProjPlanVersion specificFieldsToInsertForAddTask(ProjWorkBreakdownStructureContract _wbsContract)
    {
        return _wbsContract.parmTargetTask();
    }

]]></Source>
			</Method>
			<Method>
				<Name>specificFieldsToUpdateForAddTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specify <c>ProjPlanVersion</c> table buffer fields for add task before task is updated.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <returns><c>ProjPlanVersion</c> table buffer.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected ProjPlanVersion specificFieldsToUpdateForAddTask(ProjWorkBreakdownStructureContract _wbsContract)
    {
        return _wbsContract.parmTargetTask();
    }

]]></Source>
			</Method>
			<Method>
				<Name>specificFieldsToUpdateForIndentTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specify <c>ProjPlanVersion</c> table buffer fields for indent task before the task is updated.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <returns><c>ProjPlanVersion</c> table buffer.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected ProjPlanVersion specificFieldsToUpdateForIndentTask(ProjWorkBreakdownStructureContract _wbsContract)
    {
        return _wbsContract.parmTargetTask();
    }

]]></Source>
			</Method>
			<Method>
				<Name>specificFieldsToUpdateForOutdentTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specify <c>ProjPlanVersion</c> table buffer fields for outdent task before the task is updated.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <returns><c>ProjPlanVersion</c> table buffer.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected ProjPlanVersion specificFieldsToUpdateForOutdentTask(ProjWorkBreakdownStructureContract _wbsContract)
    {
        return _wbsContract.parmTargetTask();
    }

]]></Source>
			</Method>
			<Method>
				<Name>specificFieldsToUpdateForTargetSwappingTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specify <c>ProjPlanVersion</c> table buffer fields for the target swapping before the task is updated.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <returns><c>ProjPlanVersion</c> table buffer.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected ProjPlanVersion specificFieldsToUpdateForTargetSwappingTask(ProjWorkBreakdownStructureContract _wbsContract)
    {
        return _wbsContract.parmTargetTask();
    }

]]></Source>
			</Method>
			<Method>
				<Name>specificFieldsToUpdateForTaskToBeSwapped</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specify <c>ProjPlanVersion</c> table buffer fields for the task to be swapped before the task is updated.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <param name = "_swappedTask"><c>ProjPlanVersion</c> buffer for the task to be swapped.</param>
    /// <returns><c>ProjPlanVersion</c> table buffer for the task to be swapped.</returns>
    /// <remarks>This method is added for extensibility purpose.</remarks>
    protected ProjPlanVersion specificFieldsToUpdateForTaskToBeSwapped(ProjWorkBreakdownStructureContract _wbsContract, ProjPlanVersion _swappedTask)
    {
        return _swappedTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the given WBS tasks.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <remarks>
    ///
    /// These are the mandatroy parameters required for this API:
    /// ProjWorkBreakdownStructureContract.parmHierarchyId()
    /// ProjWorkBreakdownStructureContract.parmWbsType()
    /// ProjWorkBreakdownStructureContract.parmTaskToDeleteListEnum()
    ///
    /// This parameter is needed if this is a Project or Quotation WBS. But it's not needed for template WBS:
    /// ProjWorkBreakdownStructureContract.parmCalendarId()
    ///
    /// This parameter is optional:
    /// ProjWorkBreakdownStructureContract.parmCalendarStandardWorkDayHours() Note: not specifing will require this value to be calculated in this method.
    ///
    /// This parameter is only needed to be set if this method is being called from ProjWorkbreakdownStructureV2 UI from:
    /// ProjWorkBreakdownStructureContract.parmUpdateTempTable(true)
    ///
    /// This parameter is only needed to be set if ProjWorkBreakdownStructureContract.parmUpdateTempTable() is set to true:
    /// ProjWorkBreakdownStructureContract.parmHierarchyTemp()
    ///
    /// </remarks>
    public void deleteTasks(ProjWorkBreakdownStructureContract _wbsContract)
    {
        if (_wbsContract.parmTaskToDeleteListEnum())
        {
            // Pre-scan deletion list to see if it includes the root record. If so, delete all the tasks except the root and exit this function.
            while (_wbsContract.parmTaskToDeleteListEnum().moveNext())
            {
                ProjPlanVersion currentRecord = ProjPlanVersion::findByRecId(_wbsContract.parmTaskToDeleteListEnum().current(), true);
                if (currentRecord.isRoot())
                {
                    _wbsContract.parmTargetTask(currentRecord);
                    this.deleteAllWBSRecords(_wbsContract);
                    return;
                }
            }

            if (_wbsContract.parmHierarchyId() && (_wbsContract.parmWbsType() == ProjWBSType::Template || _wbsContract.parmCalendarId()))
            {
                // Delete the each record in the list.
                _wbsContract.parmTaskToDeleteListEnum().reset();
                this.deleteSpecificWBSRecords(_wbsContract);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSpecificWBSRecords</Name>
				<Source><![CDATA[
    private void deleteSpecificWBSRecords(ProjWorkBreakdownStructureContract _wbsContract)
    {
        if (!_wbsContract.parmCalendarStandardWorkDayHours())
        {
            _wbsContract.parmCalendarStandardWorkDayHours(ProjWorkBreakdownStructureV2FormHelper::getCalendarStandardWorkDayHours(
                _wbsContract.parmCalendarId()));
        }
        
        ttsbegin;
        while (_wbsContract.parmTaskToDeleteListEnum().moveNext())
        {
            // Only execute if this record still exists.
            ProjPlanVersion taskToDelete = ProjPlanVersion::findByRecId(_wbsContract.parmTaskToDeleteListEnum().current(), true);
            if (taskToDelete)
            {
                // If this task cannot be deleted, skip this task. Else if task has resource assigned to it, cancel resource assignment.
                if (!ProjWorkBreakdownStructureV2FormHelper::deleteTaskValidation(taskToDelete, _wbsContract.parmWBSType()))
                {
                    continue;
                }

                // Get the sorting record for the task to delete
                ProjHierarchySorting taskToDeleteSortingRecord = ProjWorkBreakdownStructureV2FormHelper::findProjHierarchySortingRecord(
                    _wbsContract.parmHierarchyId(), taskToDelete.HierarchyTaskId);
                LineNum taskToDeleteSiblingNumber = taskToDelete.TaskSiblingNumber;
                
                // Get records for the parent
                ProjPlanVersion parentRecord = ProjPlanVersion::findByHierarchyAndTaskId(_wbsContract.parmHierarchyId(),
                    taskToDelete.ParentHierarchyTaskId, true);
                ProjHierarchySorting parentSortingRecord = ProjWorkBreakdownStructureV2FormHelper::findProjHierarchySortingRecord(
                    _wbsContract.parmHierarchyId(), parentRecord.HierarchyTaskId);

                ProjHierarchyTemp parentTempRecord;
                if (_wbsContract.parmUpdateTempTable() && _wbsContract.parmHierarchyTemp())
                {
                    parentTempRecord = _wbsContract.parmHierarchyTemp().findByReferenceV2(parentRecord.RecId, true);
                }

                // If it is a quotation, then delete related records.
                this.deleteQuotationRelatedRecordsForDeletingSpecificTaskOperation(taskToDelete, _wbsContract);
                
                this.deleteTaskAndSubTasksForDeletingSpecificTaskOperation(taskToDelete, _wbsContract);
                
                this.deleteRelatedRecordsForDeletingSpecificTaskOperation(_wbsContract);

                // A WBS record can be imported via data entity that does not have a parent.
                // Because of this, we need to explicitly check for a parent and not do any of the normal "roll up" type work if there is no parent. 
                if (parentRecord)
                {
                    // If the parent is now a leaf task, make it so.
                    if (ProjPlanVersion::getMaxSiblingNumber(_wbsContract.parmHierarchyId(), parentRecord.HierarchyTaskId) == 0)
                    {
                        if (parentRecord.isRoot())
                        {
                            // Deleting last child of root should make it have 0 effort.
                            parentRecord.TaskFinishDate = parentRecord.TaskStartDate;
                            ProjPlanVersion::setEndNodeStateV2(_wbsContract.parmCalendarId(), _wbsContract.parmWBSType(),
                            parentRecord, FalseTrue::True, _wbsContract.parmCalendarStandardWorkDayHours(), 0.0);
                        }
                        else
                        {
                            ProjPlanVersion::setEndNodeStateV2(_wbsContract.parmCalendarId(), _wbsContract.parmWBSType(),
                            parentRecord, FalseTrue::True, _wbsContract.parmCalendarStandardWorkDayHours(), taskToDelete.TaskEffort);
                        }

                        if (parentTempRecord)
                        {
                            parentTempRecord.Expand = FalseTrue::False;
                            parentTempRecord.update();
                        }
                    }
                    else
                    {
                        // Move all lower siblings up.
                        this.moveTasks(_wbsContract.parmHierarchyId(), parentRecord, parentSortingRecord, taskToDeleteSiblingNumber, -1);

                        if (this.allowUpdateParentTasksPropertiesFromChildrenTaskForDeleteTask())
                        {
                            ProjPlanVersion::updateFromChildren(_wbsContract.parmCalendarId(), parentRecord);
                        }

                        // Update parent scheduling status.
                        ProjActivityCapacity::updateSummaryTaskSchedulingStatus(parentRecord);
                    }
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteQuotationRelatedRecordsForDeletingSpecificTaskOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete table records which are realated to the specific WBS quotation task to be deleted.
    /// </summary>
    /// <param name = "_taskToDelete"><c>ProjPlanVersion</c> table buffer with the WBS task to be deleted.</param>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void deleteQuotationRelatedRecordsForDeletingSpecificTaskOperation(ProjPlanVersion _taskToDelete, ProjWorkBreakdownStructureContract _wbsContract)
    {
        if (_wbsContract.parmWbsType() == ProjWBSType::ProjectQuotation)
        {
            ProjPlanVersion planVersion;

            PSAActivitySetup activitySetup;
            if (this.skipPSAActivitySetupLogAndDataMethods())
            {
                this.skipDatabaseLogAndEvent(activitySetup);
            }

            smmActivities smmActivities;
            if (this.skipSmmActivitiesLogAndDataMethods())
            {
                this.skipDatabaseLogAndEvent(smmActivities);
            }

            HierarchyTreeTable hierarchyTree;
            if (this.skipHierarchyTreeTableLogAndDataMethods())
            {
                this.skipDatabaseLogAndEvent(hierarchyTree);
            }

            // Delete all PSAActivitySetup records for the current task and sub-tasks.
            delete_from activitySetup
            exists join smmActivities
                where smmActivities.ActivityNumber == activitySetup.ActivityNumber
            exists join hierarchyTree
                where hierarchyTree.RefRecId == smmActivities.RecId
            exists join planVersion
                where planVersion.HierarchyTreeTableRefRecId == hierarchyTree.RecId
                    && planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                    && planVersion.PathId like _taskToDelete.PathId + '.*';

            delete_from activitySetup
            exists join smmActivities
                where smmActivities.ActivityNumber == activitySetup.ActivityNumber
            exists join hierarchyTree
                where hierarchyTree.RefRecId == smmActivities.RecId
            exists join planVersion
                where planVersion.HierarchyTreeTableRefRecId == hierarchyTree.RecId
                    && planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                    && planVersion.PathId == _taskToDelete.PathId;

            // Delete all smmActivities records for the current task and sub-tasks.
            delete_from smmActivities
            exists join hierarchyTree
                where hierarchyTree.RefRecId == smmActivities.RecId
            exists join planVersion
                where planVersion.HierarchyTreeTableRefRecId == hierarchyTree.RecId
                    && planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                    && planVersion.PathId like _taskToDelete.PathId + '.*';
                    
            delete_from smmActivities
            exists join hierarchyTree
                where hierarchyTree.RefRecId == smmActivities.RecId
            exists join planVersion
                where planVersion.HierarchyTreeTableRefRecId == hierarchyTree.RecId
                    && planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                    && planVersion.PathId == _taskToDelete.PathId;

            // Delete all HierarchyTreeTable records for the current task and sub-tasks.
            delete_from hierarchyTree
            exists join planVersion
                where planVersion.HierarchyTreeTableRefRecId == hierarchyTree.RecId
                    && planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                    && planVersion.PathId like _taskToDelete.PathId + '.*';

            delete_from hierarchyTree
            exists join planVersion
                where planVersion.HierarchyTreeTableRefRecId == hierarchyTree.RecId
                    && planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                    && planVersion.PathId == _taskToDelete.PathId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaskAndSubTasksForDeletingSpecificTaskOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete the specific WBS task and sub tasks.
    /// </summary>
    /// <param name = "_taskToDelete"><c>ProjPlanVersion</c> table buffer with the WBS task to be deleted.</param>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void deleteTaskAndSubTasksForDeletingSpecificTaskOperation(ProjPlanVersion _taskToDelete, ProjWorkBreakdownStructureContract _wbsContract)
    {
        ProjPlanVersion planVersion;
        if (this.skipProjPlanVersionLogAndDataMethods())
        {
            this.skipDatabaseLogAndEvent(planVersion);
        }

        // Delete all ProjPlanVersion records for the current task and sub-tasks.
        delete_from planVersion
            where planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                && planVersion.PathId like _taskToDelete.PathId + '.*';

        delete_from planVersion
            where planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                && planVersion.PathId == _taskToDelete.PathId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRelatedRecordsForDeletingSpecificTaskOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete table records which are realated to the specific task to be deleted.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void deleteRelatedRecordsForDeletingSpecificTaskOperation(ProjWorkBreakdownStructureContract _wbsContract)
    {
        ProjPlanVersion planVersion;
        
        // Delete ProjPlanAssignment records for the sub-tasks
        ProjPlanVersionAssignment projPlanVersionAssignment;
        if (this.skipProjPlanVersionAssignmentLogAndDataMethods())
        {
            this.skipDatabaseLogAndEvent(projPlanVersionAssignment);
        }

        delete_from projPlanVersionAssignment
            notexists join planVersion
                where planVersion.RecId == ProjPlanVersionAssignment.ProjPlanVersion;
                
        // Delete all PSAActivityEstimates records for the current task and sub-tasks.
        PSAActivityEstimates activityEstimates;
        if (this.skipPSAActivityEstimatesLogAndDataMethods())
        {
            this.skipDatabaseLogAndEvent(activityEstimates);
        }

        delete_from activityEstimates
            where activityEstimates.ProjPlanHierarchyId == _wbsContract.parmHierarchyId()
            notexists join planVersion
                where planVersion.HierarchyId == activityEstimates.ProjPlanHierarchyId
                    && planVersion.HierarchyTaskId == activityEstimates.ProjPlanHierarchyTaskId;

        // Delete all ProjDependency records where the successor has been deleted (predecessor case will be handled seperately below).
        ProjDependency projDependency;
        if (this.skipProjDependencyLogAndDataMethods())
        {
            this.skipDatabaseLogAndEvent(projDependency);
        }

        delete_from projDependency
            where projDependency.ProjPlanHierarchyId == _wbsContract.parmHierarchyId()
            notexists join planVersion
                where planVersion.HierarchyId == projDependency.ProjPlanHierarchyId
                    && planVersion.HierarchyTaskId == projDependency.SuccessorHierarchyTaskId;

        // Delete ProjHierarchySorting records for all deleted tasks and estimates.
        ProjHierarchySorting sortingRecord;
        if (this.skipProjHierarchySortingLogAndDataMethods())
        {
            this.skipDatabaseLogAndEvent(sortingRecord);
        }

        delete_from sortingRecord
            where sortingRecord.RefId == _wbsContract.parmHierarchyId()
            notexists join planVersion
                where planVersion.HierarchyId == sortingRecord.RefId
                    && planVersion.HierarchyTaskId == sortingRecord.RefNodeId;

        // Get remaining tasks which need their start dates to be updated, since one of their predecessors was deleted.
        Set outdatedSuccessors = new Set(Types::Int64);
        {
            ProjPlanVersion existingSuccessor;
            ProjPlanVersion deletedPredecessor;
            ProjDependency invalidEdge;
            while select invalidEdge
                where invalidEdge.ProjPlanHierarchyId == _wbsContract.parmHierarchyId()
            notexists join deletedPredecessor
                where deletedPredecessor.HierarchyId == _wbsContract.parmHierarchyId()
                && deletedPredecessor.HierarchyTaskId == invalidEdge.PredecessorHierarchyTaskId
            exists join existingSuccessor
                where existingSuccessor.HierarchyId == _wbsContract.parmHierarchyId()
                && existingSuccessor.HierarchyTaskId == invalidEdge.SuccessorHierarchyTaskId
            {
                outdatedSuccessors.add(invalidEdge.SuccessorHierarchyTaskId);
            }
        }

        // Delete ProjDependency edges where the predecessor does not exist.
        delete_from projDependency
            where projDependency.ProjPlanHierarchyId == _wbsContract.parmHierarchyId()
            notexists join planVersion
                where planVersion.HierarchyId == projDependency.ProjPlanHierarchyId
                    && planVersion.HierarchyTaskId == projDependency.PredecessorHierarchyTaskId;

        if (_wbsContract.parmUpdateTempTable() && _wbsContract.parmHierarchyTemp())
        {
            // Delete all temp table records for all deleted tasks and estimates.
            ProjHierarchyTemp hierarchyTemp;
            hierarchyTemp.linkPhysicalTableInstance(_wbsContract.parmHierarchyTemp());

            delete_from hierarchyTemp
                where hierarchyTemp.RefTableId == planVersion.TableId
                notexists join planVersion
                    where planVersion.RecId == hierarchyTemp.RefRecId;
                        
        }
                
        // Update dates for successors.
        SetEnumerator outdatedSuccessorEnumerator = outdatedSuccessors.getEnumerator();
        while (outdatedSuccessorEnumerator.moveNext())
        {
            ProjPlanVersion task = ProjPlanVersion::findByHierarchyAndTaskId(_wbsContract.parmHierarchyId(),
                outdatedSuccessorEnumerator.current(), true);
            ProjPlanVersion::updateStartDateFromPredecessors(_wbsContract.parmCalendarId(), task);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAllWBSRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete all WBS records by hierarchy ID except the root.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void deleteAllWBSRecords(ProjWorkBreakdownStructureContract _wbsContract)
    {
        ttsbegin;
        ProjPlanVersion rootTask = _wbsContract.parmTargetTask();

        // Validate if all tasks in this WBS can be deleted.
        ProjPlanVersion taskToDelete;
        while select taskToDelete
            where taskToDelete.HierarchyId == _wbsContract.parmHierarchyId()
        {
            if (!ProjWorkBreakdownStructureV2FormHelper::deleteTaskValidation(taskToDelete, _wbsContract.parmWbsType()))
            {
                return;
            }
        }
        
        // Delete all quotation related records if this is a quotation WBS.
        this.deleteQuotationRelatedRecordsForDeletingAllTasksOperation(rootTask, _wbsContract);

        this.deleteAllTaskExceptTheRoot(rootTask, _wbsContract);

        this.deleteRelatedRecordsForDeletingAllTasksOperation(rootTask, _wbsContract);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteQuotationRelatedRecordsForDeletingAllTasksOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete quotation related records for deleting all tasks operation.
    /// </summary>
    /// <param name = "_rootTask"><c>ProjPlanVersion</c> table buffer for the root task.</param>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void deleteQuotationRelatedRecordsForDeletingAllTasksOperation(ProjPlanVersion _rootTask, ProjWorkBreakdownStructureContract _wbsContract)
    {
        ProjPlanVersion planVersion;

        // If it is a quotation, then delete related records.
        if (_wbsContract.parmWbsType() == ProjWBSType::ProjectQuotation)
        {
            PSAActivitySetup activitySetup;
            if (this.skipPSAActivitySetupLogAndDataMethods())
            {
                this.skipDatabaseLogAndEvent(activitySetup);
            }

            smmActivities smmActivities;
            if (this.skipSmmActivitiesLogAndDataMethods())
            {
                this.skipDatabaseLogAndEvent(smmActivities);
            }

            HierarchyTreeTable hierarchyTree;
            if (this.skipHierarchyTreeTableLogAndDataMethods())
            {
                this.skipDatabaseLogAndEvent(hierarchyTree);
            }

            // Delete all PSAActivitySetup records for the current task and sub-tasks.
            delete_from activitySetup
                exists join smmActivities
                    where smmActivities.ActivityNumber == activitySetup.ActivityNumber
                exists join hierarchyTree
                    where hierarchyTree.RefRecId == smmActivities.RecId
                exists join planVersion
                    where planVersion.HierarchyTreeTableRefRecId == hierarchyTree.RecId
                        && planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                        && planVersion.HierarchyTaskId != _rootTask.HierarchyTaskId;

            // Delete all smmActivities records for the current task and sub-tasks.
            delete_from smmActivities
                exists join hierarchyTree
                    where hierarchyTree.RefRecId == smmActivities.RecId
                exists join planVersion
                    where planVersion.HierarchyTreeTableRefRecId == hierarchyTree.RecId
                        && planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                        && planVersion.HierarchyTaskId != _rootTask.HierarchyTaskId;

            // Delete all HierarchyTreeTable records for the current task and sub-tasks.
            delete_from hierarchyTree
                exists join planVersion
                    where planVersion.HierarchyTreeTableRefRecId == hierarchyTree.RecId
                        && planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                        && planVersion.HierarchyTaskId != _rootTask.HierarchyTaskId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAllTaskExceptTheRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete all tasks except the specific <c>ProjPlanVersion</c> root task record.
    /// </summary>
    /// <param name = "_rootTask"><c>ProjPlanVersion</c> table buffer for the root task.</param>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void deleteAllTaskExceptTheRoot(ProjPlanVersion _rootTask, ProjWorkBreakdownStructureContract _wbsContract)
    {
        // Delete all tasks except the root
        ProjPlanVersion planVersion;
        if (this.skipProjPlanVersionLogAndDataMethods())
        {
            this.skipDatabaseLogAndEvent(planVersion);
        }

        delete_from planVersion
            where planVersion.HierarchyId == _wbsContract.parmHierarchyId()
                && planVersion.HierarchyTaskId != _rootTask.HierarchyTaskId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRelatedRecordsForDeletingAllTasksOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete table records for the specific root task WBS.
    /// </summary>
    /// <param name = "_rootTask"><c>ProjPlanVersion</c> table buffer for the root task.</param>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void deleteRelatedRecordsForDeletingAllTasksOperation(ProjPlanVersion _rootTask, ProjWorkBreakdownStructureContract _wbsContract)
    {
        // Delete all ProjHierarchySorting records except those for the root.
        ProjHierarchySorting sortingRecord;
        if (this.skipProjHierarchySortingLogAndDataMethods())
        {
            this.skipDatabaseLogAndEvent(sortingRecord);
        }

        delete_from sortingRecord
            where sortingRecord.Type == ProjHierarchySortingType::ProjWBS
                && sortingRecord.RefId == _wbsContract.parmHierarchyId()
                && sortingRecord.RefNodeId != _rootTask.HierarchyTaskId;

        PSAActivityEstimates activityEstimates;
        if (this.skipPSAActivityEstimatesLogAndDataMethods())
        {
            this.skipDatabaseLogAndEvent(activityEstimates);
        }

        delete_from activityEstimates
            where activityEstimates.ProjPlanHierarchyId == _wbsContract.parmHierarchyId();

        // Delete all ProjDependency records.
        ProjDependency projDependency;
        if (this.skipProjDependencyLogAndDataMethods())
        {
            this.skipDatabaseLogAndEvent(projDependency);
        }

        delete_from projDependency
            where projDependency.ProjPlanHierarchyId == _wbsContract.parmHierarchyId();
                    
        if (_wbsContract.parmUpdateTempTable() && _wbsContract.parmHierarchyTemp())
        {
            ProjHierarchyTemp hierarchyTemp;
            hierarchyTemp.linkPhysicalTableInstance(_wbsContract.parmHierarchyTemp());

            delete_from hierarchyTemp
               where hierarchyTemp.RefNodeId != _rootTask.HierarchyTaskId;

            // Get the temp table record for the root
            ProjHierarchyTemp rootTemp = hierarchyTemp.findByReferenceV2(_rootTask.RecId, true);

            // Make the root an end node
            ProjPlanVersion::setEndNodeStateV2(_wbsContract.parmCalendarId(), _wbsContract.parmWbsType(),
                _rootTask, FalseTrue::True, _wbsContract.parmCalendarStandardWorkDayHours());
            rootTemp.Expand = FalseTrue::False;
            rootTemp.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Move task operation for task is being added with sibiling being push down or task is being deleted to move sibliing up.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy identifier.</param>
    /// <param name = "_parentTaskRecord">Parent <c>ProjPlanVersion</c> record.</param>
    /// <param name = "_parentSortingRecord">Parent <c>ProjHierarchySorting</c> record.</param>
    /// <param name = "_minSiblingNumber">The smallest sibling number.</param>
    /// <param name = "_delta">The delta hierarchy level value.</param>
    protected void moveTasks(
        HierarchyIdBase _hierarchyId,
        ProjPlanVersion _parentTaskRecord,
        ProjHierarchySorting _parentSortingRecord,
        LineNum _minSiblingNumber,
        int _delta)
    {
        // Moves all tasks (and all sub-tasks and estimates) above the given sibling number by the given amount.
        // This DOES NOT account for any records that may be occupying the space the given records are moving to.

        str currentPartition = int642Str(getCurrentPartitionRecId());
        str currentCompany = curExt();
        int levelToUpdate = _parentTaskRecord.HierarchyLevel + 1;

        // Construct a query to increment PathId and TaskSiblingNumber for child records
        str updateTaskSQL = strFmt(@" UPDATE Task SET
                                        Task.PathId = dbo.%1(Task.PathId, '.', %2, %3),
                                        Task.TaskSiblingNumber = IIF(Task.ParentHierarchyTaskId = %4, Task.TaskSiblingNumber + %3, Task.TaskSiblingNumber)
                                    FROM ProjPlanVersion AS Task
                                    INNER JOIN ProjHierarchySorting AS Sort ON
                                        Sort.Partition = Task.Partition
                                        AND Sort.DataAreaId = Task.DataAreaId
                                        AND Sort.RefId = Task.HierarchyId
                                        AND Sort.RefNodeId = Task.HierarchyTaskId
                                    WHERE
                                        Task.Partition = %7 AND Task.DataAreaId = '%8'
                                        AND Task.HierarchyId = '%6'
                                        AND Sort.Type = %5
                                        AND Sort.HierarchyLevel%2 >= %9",
                                    ProjHierarchySQLObjects::getIncrementSubstringFuncName(),
                                    levelToUpdate,
                                    _delta,
                                    _parentTaskRecord.HierarchyTaskId,
                                    enum2int(ProjHierarchySortingType::ProjWBS),
                                    _hierarchyId,
                                    currentPartition,
                                    currentCompany,
                                    real2Int(_minSiblingNumber));

        // Construct a query to increment HierarchyLevelX fields for sub-tasks
        str updateSortSQL = strFmt(@" UPDATE Sort SET
                                        Sort.HierarchyLevel%1 = Sort.HierarchyLevel%1 + %2
                                    FROM ProjHierarchySorting AS Sort
                                    WHERE
                                        Sort.Partition = %3 AND Sort.DataAreaId = '%4'
                                        AND Sort.Type = %5
                                        AND Sort.RefId = '%6'
                                        AND Sort.HierarchyLevel%1 >= %7",
                                    levelToUpdate,
                                    _delta,
                                    currentPartition,
                                    currentCompany,
                                    enum2int(ProjHierarchySortingType::ProjWBS),
                                    _hierarchyId,
                                    real2Int(_minSiblingNumber));

        // Build up a common base predicate for the two queries
        str basePredicate = '';
        for (int i = 1; i < levelToUpdate; ++i)
        {
            basePredicate += strFmt(' AND Sort.HierarchyLevel%1 = %2', i, _parentSortingRecord.getFieldValue(strFmt('HierarchyLevel%1', i)));
        }

        // Build and execute full query
        str fullQuery = updateTaskSQL + basePredicate + ';\n';
        fullQuery += updateSortSQL + basePredicate + ';\n';
        this.executeSQLStatement(fullQuery);
    }

]]></Source>
			</Method>
			<Method>
				<Name>indentTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indents the given task records. Update all of their sub-tasks and estimates.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <returns>The next unique selection group after this operation has completed.</returns>
    /// <remarks>
    ///
    /// These are the mandatroy parameters required for this API:
    /// ProjWorkBreakdownStructureContract.parmHierarchyId()
    /// ProjWorkBreakdownStructureContract.parmWbsType()
    /// ProjWorkBreakdownStructureContract.parmTaskToIndentListEnum()
    ///
    /// This parameter is needed if this is a Project or Quotation WBS. But it's not needed for template WBS:
    /// ProjWorkBreakdownStructureContract.parmCalendarId()
    ///
    /// These parameters are optional:
    /// ProjWorkBreakdownStructureContract.parmCurrentHierarchyMaxLevel() - If specified, it does not need to be recalculated
    /// ProjWorkBreakdownStructureContract.parmCalendarStandardWorkDayHours() - If specified, it does not need to be recalculated
    ///
    /// These parameters are only needed to be set if this method is being called from ProjWorkbreakdownStructureV2 UI from:
    /// ProjWorkBreakdownStructureContract.parmUpdateTempTable(true)
    /// ProjWorkBreakdownStructureContract.parmNextSelectionGroup()
    ///
    /// This parameter is only needed to be set if ProjWorkBreakdownStructureContract.parmUpdateTempTable() is set to true:
    /// ProjWorkBreakdownStructureContract.parmHierarchyTemp()
    ///
    /// </remarks>
    public int indentTasks(ProjWorkBreakdownStructureContract _wbsContract)
    {
        if (_wbsContract.parmHierarchyId() && (_wbsContract.parmWbsType() == ProjWBSType::Template || _wbsContract.parmCalendarId())
            && _wbsContract.parmTaskToIndentListEnum())
        {
            if (!_wbsContract.parmNextSelectionGroup())
            {
                _wbsContract.parmNextSelectionGroup(1);
            }
            
            if (!_wbsContract.parmCurrentHierarchyMaxLevel())
            {
                _wbsContract.parmCurrentHierarchyMaxLevel(ProjPlanVersion::getMaxHierarchyLevel(_wbsContract.parmHierarchyId()));
            }

            if (!_wbsContract.parmCalendarStandardWorkDayHours())
            {
                _wbsContract.parmCalendarStandardWorkDayHours(
                    ProjWorkBreakdownStructureV2FormHelper::getCalendarStandardWorkDayHours(_wbsContract.parmCalendarId()));
            }
            
            ProjHierarchyTemp hierarchyTemp;
            this.initializeProjHierarchyTemp(_wbsContract, hierarchyTemp);
            
            int schemaMaxHierarchyLevel = ProjHierarchySorting::getSchemaMaxHierarchyLevel();

            while (_wbsContract.parmTaskToIndentListEnum().moveNext())
            {
                this.parmPreviousTaskParent(null);
                this.parmUpdatedTaskParent(null);
                this.parmAboveSiblingNumber(0);
                this.parmNewSiblingNumber(0);
                
                // Set task to indent record as parmTargetTask().
                _wbsContract.parmTargetTask(ProjPlanVersion::findByRecId(_wbsContract.parmTaskToIndentListEnum().current(), true));

                this.validateCircularReference(ProjPlanVersion::findByHierarchyAndTaskId(_wbsContract.parmHierarchyId(), _wbsContract.parmTargetTask().HierarchyTaskId));

                if (!this.indentTaskOperation(_wbsContract, hierarchyTemp, schemaMaxHierarchyLevel))
                {
                    continue;
                }

                // Perform additional updates
                ttsbegin;

                // Update indented task in hierarchy
                _wbsContract.parmTargetTask().ParentHierarchyTaskId = this.parmUpdatedTaskParent().HierarchyTaskId;
                _wbsContract.parmTargetTask().TaskSiblingNumber = this.parmNewSiblingNumber();
                _wbsContract.parmTargetTask(this.specificFieldsToUpdateForIndentTask(_wbsContract));
                _wbsContract.parmTargetTask().update();

                // Update the previous sibling to become a summary task.
                ProjPlanVersion::setEndNodeStateV2(_wbsContract.parmCalendarId(), _wbsContract.parmWbsType(),
                    this.parmUpdatedTaskParent(), FalseTrue::False, _wbsContract.parmCalendarStandardWorkDayHours());

                // Remove invalid predecessors from the task we're indenting (successors of the updated parent)
                Set invalidPredecessors = new Set(Types::Int64);
                invalidPredecessors.add(this.parmUpdatedTaskParent().HierarchyTaskId);
                ProjPlanVersion::constructSuccessorSet(this.parmUpdatedTaskParent(), invalidPredecessors);
                ProjPlanVersion::removePredecessors(_wbsContract.parmTargetTask().HierarchyId,
                    _wbsContract.parmTargetTask().HierarchyTaskId, invalidPredecessors.getEnumerator());
                ProjPlanVersion::updateStartDateFromPredecessors(_wbsContract.parmCalendarId(), _wbsContract.parmTargetTask());

                if (this.allowUpdateParentTasksPropertiesFromChildrenTaskForIndentTask())
                {
                    ProjPlanVersion::updateFromChildren(_wbsContract.parmCalendarId(), this.parmUpdatedTaskParent());
                    this.parmPreviousTaskParent().reread();
                    ProjPlanVersion::updateFromChildren(_wbsContract.parmCalendarId(), this.parmPreviousTaskParent());
                }

                // If the hierarchy is a quotation, need to updated related records
                this.updateQuotationRelatedRecordsForIndentTask(_wbsContract);

                // Update previous parent scheduling status
                ProjActivityCapacity::updateSummaryTaskSchedulingStatus(this.parmPreviousTaskParent());

                // Update new parent scheduling status
                ProjActivityCapacity::updateSummaryTaskSchedulingStatus(this.parmUpdatedTaskParent());
                ttscommit;
            
                // Expand the new parent
                ProjWorkBreakdownStructureV2FormHelper::findProjHierarchySortingRecord(_wbsContract.parmHierarchyId(),
                    this.parmUpdatedTaskParent().HierarchyTaskId);

                if (_wbsContract.parmUpdateTempTable())
                {
                    ProjWorkBreakdownStructureV2FormHelper::expandTaskV2(this.parmUpdatedTaskParent(),
                        hierarchyTemp.getPhysicalTableName(), false);
                }

                _wbsContract.parmCurrentHierarchyMaxLevel(ProjPlanVersion::getMaxHierarchyLevel(_wbsContract.parmHierarchyId()));
            }
        }
        return _wbsContract.parmNextSelectionGroup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjHierarchyTemp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert records for <c>ProjHierarchyTemp</c> table by hierarchy identifier.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <param name = "_projHierarchyTemp"><c>ProjHierarchyTemp</c> table buffer.</param>
    protected void initializeProjHierarchyTemp(ProjWorkBreakdownStructureContract _wbsContract, ProjHierarchyTemp _projHierarchyTemp)
    {
        if (!_wbsContract.parmHierarchyTemp())
        {
            // If parmHierarchyTemp() is not specified, then initialize this table buffer.
            ProjWorkBreakdownStructureV2FormHelper::initializeProjHierarchyTemp(_wbsContract.parmHierarchyId(), _projHierarchyTemp.getPhysicalTableName());
        }
        else
        {
            _projHierarchyTemp.linkPhysicalTableInstance(_wbsContract.parmHierarchyTemp());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>indentTaskOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update tasks properties due to the indentation of the specific task which is specify as _wbsContract.parmTargetTask() parameter.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <param name = "_projHierarchyTemp"><c>ProjHierarchyTemp</c> table buffer.</param>
    /// <param name = "_schemaMaxHierarchyLevel">The max work brekdown strucutre level for this _wbsContract.parmHierarchyId().</param>
    /// <returns>true if operation has been executed successfully; otherwise, false.</returns>
    protected boolean indentTaskOperation(ProjWorkBreakdownStructureContract _wbsContract, ProjHierarchyTemp _projHierarchyTemp, int _schemaMaxHierarchyLevel)
    {
        // Cannot indent the root
        if (_wbsContract.parmTargetTask().isRoot())
        {
            return false;
        }

        // Cannot indent the first child of a task
        if (_wbsContract.parmTargetTask().TaskSiblingNumber == 1)
        {
            return false;
        }

        // Cannot indent a task further than the maximum schema depth
        if (_wbsContract.parmTargetTask().HierarchyLevel >= _schemaMaxHierarchyLevel)
        {
            error(strFmt("@ProjPlan:TaskCannotBeIndentForNLevel", _schemaMaxHierarchyLevel));
            return false;
        }

        ProjHierarchySorting sortingRecord = ProjWorkBreakdownStructureV2FormHelper::findProjHierarchySortingRecord(_wbsContract.parmHierarchyId(), _wbsContract.parmTargetTask().HierarchyTaskId);

        // Get the new parent (previous sibling)
        this.parmPreviousTaskParent(ProjPlanVersion::findByHierarchyAndTaskId(_wbsContract.parmHierarchyId(),
            _wbsContract.parmTargetTask().ParentHierarchyTaskId, true));
        this.parmUpdatedTaskParent(ProjPlanVersion::findByParentTaskIdAndSiblingNumber(_wbsContract.parmHierarchyId(),
            _wbsContract.parmTargetTask().ParentHierarchyTaskId, _wbsContract.parmTargetTask().TaskSiblingNumber - 1, true));
        this.parmAboveSiblingNumber(_wbsContract.parmTargetTask().TaskSiblingNumber - 1);
        this.parmNewSiblingNumber(ProjPlanVersion::getNextSiblingNumber(_wbsContract.parmHierarchyId(),
            this.parmUpdatedTaskParent().HierarchyTaskId));
        ProjHierarchyPathId newPathId = this.parmUpdatedTaskParent().PathId + '.' + num2Str(
            this.parmNewSiblingNumber(), 0, 0, DecimalSeparator::Auto, ThousandSeparator::None);
            
        // Make sure that the new parent is not a leaf task with resources assigned
        if (ProjWorkBreakdownStructureV2FormHelper::taskHasResourcesAssigned(this.parmUpdatedTaskParent()))
        {
            error(strFmt("@ProjPlan:ResourcesAssignedForSummaryTaskError", this.parmUpdatedTaskParent().TaskName));
            return false;
        }

        // Need to organize nodes into two groups: Nodes to be indented (taskToIndent and all subchildren)
        // and nodes to be moved up (former lower-siblings of taskToIndent and all of their subchildren)
        int indentSelectionGroup = _wbsContract.parmNextSelectionGroup();
        int moveUpSelectionGroup = indentSelectionGroup + 1;
        _wbsContract.parmNextSelectionGroup(moveUpSelectionGroup + 1);
            
        // Construct predicate for selecting all records that need to be modified
        str selectionPredicate = '';
        for (int i = _wbsContract.parmTargetTask().HierarchyLevel - 1; i > 0; --i)
        {
            int sortingValue = sortingRecord.getFieldValue(strFmt('HierarchyLevel%1', i));
            selectionPredicate = strFmt('Sort.HierarchyLevel%1 = %2 AND ', i, sortingValue) + selectionPredicate;
        }
        selectionPredicate += strFmt('Sort.HierarchyLevel%1 >= %2',
            _wbsContract.parmTargetTask().HierarchyLevel, real2Int(_wbsContract.parmTargetTask().TaskSiblingNumber));

        // Construct the actual selection query
        str selectionSQL = this.getSetSelectionGroupSQLStatement(
            _projHierarchyTemp.getPhysicalTableName(),
            strFmt('IIF(Sort.HierarchyLevel%1 = %2, %3, %4)', _wbsContract.parmTargetTask().HierarchyLevel,
            real2Int(_wbsContract.parmTargetTask().TaskSiblingNumber), indentSelectionGroup, moveUpSelectionGroup),
            selectionPredicate);

        // Construct query to perform indentation for ProjHierarchySorting records in indentSelectionGroup
        str indentSortingSQL = this.getSortingRecordLevelInsertAndReplaceSQLStatement(
                _projHierarchyTemp.getPhysicalTableName(),
                min(_wbsContract.parmCurrentHierarchyMaxLevel() + 1, _schemaMaxHierarchyLevel),
                _wbsContract.parmTargetTask().HierarchyLevel,
                real2Int(_wbsContract.parmTargetTask().TaskSiblingNumber) - 1,
                real2Int(this.parmNewSiblingNumber()),
                indentSelectionGroup);

        // Construct a query to perform indentation for ProjPlanVersion records in indentSelectionGroup
        str indentTaskSQL = this.getTaskRecordUpdateSQLStatement(
                _projHierarchyTemp.getPhysicalTableName(),
                strFmt('Task.HierarchyLevel = Task.HierarchyLevel + 1, Task.PathId = dbo.%1(Task.PathId, \'.\', %2, \'%3\')',
                    ProjHierarchySQLObjects::getReplacePrefixFuncName(),
                    _wbsContract.parmTargetTask().HierarchyLevel,
                    newPathId),
                indentSelectionGroup);
   
        // Construct query to perform move-up for ProjHierarchySorting records in moveUpSelectionGroup
        str moveUpSortingSQL = this.getSortingRecordLevelDeltaSQLStatement(
                _projHierarchyTemp.getPhysicalTableName(),
                _wbsContract.parmTargetTask().HierarchyLevel,
                -1,
                moveUpSelectionGroup);

        // Construct query to perform move-up for ProjPlanVersion records in moveUpSelectionGroup
        str moveUpTaskSQL = this.getTaskRecordUpdateSQLStatement(
                _projHierarchyTemp.getPhysicalTableName(),
                strFmt('Task.PathId = dbo.%1(Task.PathId, \'.\', %2, -1), Task.TaskSiblingNumber = IIF(Task.ParentHierarchyTaskId = %3, Task.TaskSiblingNumber - 1, Task.TaskSiblingNumber)',
                ProjHierarchySQLObjects::getIncrementSubStringFuncName(),
                    _wbsContract.parmTargetTask().HierarchyLevel,
                    _wbsContract.parmTargetTask().ParentHierarchyTaskId),
                moveUpSelectionGroup);

        // Execute queries
        str fullSQL = selectionSQL + '; ' + indentSortingSQL + '; ' + indentTaskSQL + '; ' + moveUpSortingSQL + '; ' + moveUpTaskSQL;
        this.executeSQLStatement(fullSQL);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuotationRelatedRecordsForIndentTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update qutoation related records for indent task operation.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void updateQuotationRelatedRecordsForIndentTask(ProjWorkBreakdownStructureContract _wbsContract)
    {
        // If the hierarchy is a quotation, need to updated related records
        if (_wbsContract.parmWbsType() == ProjWBSType::ProjectQuotation)
        {
            ElementNumber taskElementNumber = ProjWorkBreakdownStructureV2FormHelper::getCorrespondingTaskElementNumber(
                _wbsContract.parmHierarchyId(), _wbsContract.parmTargetTask().HierarchyTaskId);
            ElementNumber aboveSiblingElementNumber = ProjWorkBreakdownStructureV2FormHelper::getCorrespondingTaskElementNumber(
                _wbsContract.parmHierarchyId(), ProjPlanVersion::findByParentTaskIdAndSiblingNumber(_wbsContract.parmTargetTask().HierarchyId,
                this.parmPreviousTaskParent().HierarchyTaskId, this.parmAboveSiblingNumber()).HierarchyTaskId);
            ProjTaskNormalized::indentTasks(_wbsContract.parmHierarchyId(), taskElementNumber,
                aboveSiblingElementNumber, this.parmNewSiblingNumber());

            // Clear out the task attributes if the parent tasks is a first time parent.
            if (ProjPlanVersion::getChildTasksLastSiblingNumber(_wbsContract.parmHierarchyId(), this.parmUpdatedTaskParent().HierarchyTaskId) == 1)
            {
                ProjTaskNormalized::clearTaskAttributesForNewlyCreatedParent(_wbsContract.parmHierarchyId(), aboveSiblingElementNumber);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>outdentTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Outdents the given task records, and all of their sub-tasks and estimates.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <returns>The next unique selection group after this operation has completed.</returns>
    /// <remarks>
    ///
    /// These are the mandatroy parameters required for this API:
    /// ProjWorkBreakdownStructureContract.parmHierarchyId()
    /// ProjWorkBreakdownStructureContract.parmWbsType()
    /// ProjWorkBreakdownStructureContract.parmTaskToOutdentListEnum()
    ///
    /// This parameter is needed if this is a Project or Quotation WBS. But it's not needed for template WBS:
    /// ProjWorkBreakdownStructureContract.parmCalendarId()
    ///
    /// These parameters are optional:
    /// ProjWorkBreakdownStructureContract.parmCurrentHierarchyMaxLevel() - If specified, it does not need to be recalculated
    /// ProjWorkBreakdownStructureContract.parmCalendarStandardWorkDayHours() - If specified, it does not need to be recalculated
    ///
    /// These parameters are only needed to be set if this method is being called from ProjWorkbreakdownStructureV2 UI from:
    /// ProjWorkBreakdownStructureContract.parmUpdateTempTable(true)
    /// ProjWorkBreakdownStructureContract.parmNextSelectionGroup()
    ///
    /// This parameter is only needed to be set if ProjWorkBreakdownStructureContract.parmUpdateTempTable() is set to true:
    /// ProjWorkBreakdownStructureContract.parmHierarchyTemp()
    ///
    /// </remarks>
    public int outdentTasks(ProjWorkBreakdownStructureContract _wbsContract)
    {
        if (_wbsContract.parmHierarchyId() && (_wbsContract.parmWbsType() == ProjWBSType::Template || _wbsContract.parmCalendarId())
            && _wbsContract.parmTaskToOutdentListEnum())
        {
            if (!_wbsContract.parmNextSelectionGroup())
            {
                _wbsContract.parmNextSelectionGroup(1);
            }
            
            if (!_wbsContract.parmCurrentHierarchyMaxLevel())
            {
                _wbsContract.parmCurrentHierarchyMaxLevel(ProjPlanVersion::getMaxHierarchyLevel(_wbsContract.parmHierarchyId()));
            }

            if (!_wbsContract.parmCalendarStandardWorkDayHours())
            {
                _wbsContract.parmCalendarStandardWorkDayHours(ProjWorkBreakdownStructureV2FormHelper::getCalendarStandardWorkDayHours(
                    _wbsContract.parmCalendarId()));
            }

            ProjHierarchyTemp hierarchyTemp;
            this.initializeProjHierarchyTemp(_wbsContract, hierarchyTemp);

            while (_wbsContract.parmTaskToOutdentListEnum().moveNext())
            {
                this.parmPreviousTaskParent(null);
                this.parmUpdatedTaskParent(null);
                this.parmNewSiblingNumber(0);

                // Set task to outdent record as parmTargetTask().
                _wbsContract.parmTargetTask(ProjPlanVersion::findByRecId(_wbsContract.parmTaskToOutdentListEnum().current(), true));

                this.validateCircularReference(ProjPlanVersion::findByHierarchyAndTaskId(_wbsContract.parmHierarchyId(), _wbsContract.parmTargetTask().HierarchyTaskId));

                this.parmPreviousSiblingNumber(_wbsContract.parmTargetTask().TaskSiblingNumber);

                if (!this.outdentTaskOperation(_wbsContract, hierarchyTemp))
                {
                    continue;
                }

                // Perform additional updates
                ttsbegin;

                _wbsContract.parmTargetTask().ParentHierarchyTaskId = this.parmUpdatedTaskParent().HierarchyTaskId;
                _wbsContract.parmTargetTask().TaskSiblingNumber = this.parmNewSiblingNumber();
                _wbsContract.parmTargetTask(this.specificFieldsToUpdateForOutdentTask(_wbsContract));
                _wbsContract.parmTargetTask().update();

                // Make the old parent a leaf node if it has no more children (outdented node was first child)
				if (this.parmPreviousSiblingNumber() == 1)
                {
                    ProjPlanVersion::setEndNodeStateV2(_wbsContract.parmCalendarId(), _wbsContract.parmWbsType(),
                        this.parmPreviousTaskParent(), FalseTrue::True, _wbsContract.parmCalendarStandardWorkDayHours());

                    if (_wbsContract.parmUpdateTempTable())
                    {
                        // Mark it as collapsed
                        // NOTE: Not doing a proper 'collapse' here since this task no longer has any visible children
                        ProjHierarchyTemp oldParentTemp = hierarchyTemp.findByReferenceV2(this.parmPreviousTaskParent().RecId, true);
                        oldParentTemp.Expand = FalseTrue::False;
                        oldParentTemp.update();
                    }
                }
                else if (this.allowUpdateParentTasksPropertiesFromChildrenTaskForOutdentTask())
                {
                    ProjPlanVersion::updateFromChildren(_wbsContract.parmCalendarId(), this.parmPreviousTaskParent());
                }

                // Make this outdented task a summary node if it has children.
                if (ProjPlanVersion::getMaxSiblingNumber(_wbsContract.parmHierarchyId(), _wbsContract.parmTargetTask().HierarchyTaskId) != 0)
                {
                    ProjPlanVersion::setEndNodeStateV2(_wbsContract.parmCalendarId(), _wbsContract.parmWbsType(),
                        _wbsContract.parmTargetTask(), FalseTrue::False, _wbsContract.parmCalendarStandardWorkDayHours());
                    if (this.allowUpdateParentTasksPropertiesFromChildrenTaskForOutdentTask())
                    {
                        ProjPlanVersion::updateFromChildren(_wbsContract.parmCalendarId(), _wbsContract.parmTargetTask());
                    }
                }
				
                // If the task is the first child, then it will have a new parent after outdent.
                if (this.parmPreviousSiblingNumber() == 1 && this.allowUpdateParentTasksPropertiesFromChildrenTaskForOutdentTask())
                {
                     this.parmUpdatedTaskParent().selectForUpdate(true);
                     ProjPlanVersion::updateFromChildren(_wbsContract.parmCalendarId(), this.parmUpdatedTaskParent());
                }

                // If the hierarchy is a quotation, need to updated related records
                this.updateQuotationRelatedRecordsForOutdentTask(_wbsContract);
                
                // Update previous parent scheduling status
                ProjActivityCapacity::updateSummaryTaskSchedulingStatus(this.parmPreviousTaskParent());

                // Update new parent scheduling status
                ProjActivityCapacity::updateSummaryTaskSchedulingStatus(this.parmUpdatedTaskParent());
                ttscommit;

                if (_wbsContract.parmUpdateTempTable())
                {
                    // Expand the outdented task (NOTE: 'allowEndNode' argument hardcoded to 'false' because assuming that hierarchy modifications are disallowed while estimates are visible...)
                    ProjWorkBreakdownStructureV2FormHelper::expandTaskV2(_wbsContract.parmTargetTask(),
                        hierarchyTemp.getPhysicalTableName(), false);
                }
            }
        }
        return _wbsContract.parmNextSelectionGroup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>outdentTaskOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update tasks properties due to the outdentation of the specific task which is specify as _wbsContract.parmTargetTask() parameter.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <param name = "_projHierarchyTemp"><c>ProjHierarchyTemp</c> table buffer.</param>
    /// <returns>true if operation has been executed successfully; otherwise, false.</returns>
    protected boolean outdentTaskOperation(ProjWorkBreakdownStructureContract _wbsContract, ProjHierarchyTemp _projHierarchyTemp)
    {
        // Make sure the user isn't trying to outdent a top-level task
        if (_wbsContract.parmTargetTask().HierarchyLevel <= 1)
        {
            error("@ProjPlan:OutdentTopLevelTaskError");
            return false;
        }

        // Get the old parent
        this.parmPreviousTaskParent(ProjPlanVersion::findByHierarchyAndTaskId(_wbsContract.parmHierarchyId(),
            _wbsContract.parmTargetTask().ParentHierarchyTaskId, true));
        
        // If this task is not the last child and it has resources assigned, block the outdent
        if (ProjWorkBreakdownStructureV2FormHelper::taskHasResourcesAssigned(_wbsContract.parmTargetTask())
            && _wbsContract.parmTargetTask().TaskSiblingNumber == ProjPlanVersion::getMaxSiblingNumber(
            _wbsContract.parmHierarchyId(), this.parmPreviousTaskParent().HierarchyTaskId))
        {
            error(strFmt("@ProjPlan:ResourcesAssignedForSummaryTaskError", _wbsContract.parmTargetTask().TaskName));
            return false;
        }

        ProjHierarchySorting taskToOutdentSorting = ProjWorkBreakdownStructureV2FormHelper::findProjHierarchySortingRecord(
            _wbsContract.parmHierarchyId(), _wbsContract.parmTargetTask().HierarchyTaskId);
        this.parmUpdatedTaskParent(ProjPlanVersion::findByHierarchyAndTaskId(_wbsContract.parmHierarchyId(),
            this.parmPreviousTaskParent().ParentHierarchyTaskId));
        int newHierarchyLevel = this.parmPreviousTaskParent().HierarchyLevel;
        this.parmNewSiblingNumber(real2Int(this.parmPreviousTaskParent().TaskSiblingNumber) + 1);
        str newPathId = this.parmUpdatedTaskParent().isRoot() ? num2Str(this.parmNewSiblingNumber(), 0, 0, DecimalSeparator::Auto, ThousandSeparator::None) : this.parmUpdatedTaskParent().PathId
            + '.' + num2Str(this.parmNewSiblingNumber(), 0, 0, DecimalSeparator::Auto, ThousandSeparator::None);
        int newChildLevelDelta = real2Int(ProjPlanVersion::getMaxSiblingNumber(_wbsContract.parmHierarchyId(),
            _wbsContract.parmTargetTask().HierarchyTaskId) - real2Int(_wbsContract.parmTargetTask().TaskSiblingNumber));
        str currentPartition = int642Str(getCurrentPartitionRecId());

        // Create a query for placing the hierarchy being outdented into a unique selection group
        int outdentHierarchyGroup = _wbsContract.parmNextSelectionGroup();
        _wbsContract.parmNextSelectionGroup(outdentHierarchyGroup + 1);
        str selectOutdentHierarchyGroupSQL = strFmt(@"UPDATE Temp SET
                                                            SelectionGroup = %1
                                                        FROM %2 AS Temp
                                                        INNER JOIN ProjHierarchySorting AS Sort ON
                                                            Sort.Partition = %3 AND Sort.RecId = Temp.RefSortRecId",
                                                        outdentHierarchyGroup,
                                                        _projHierarchyTemp.getPhysicalTableName(),
                                                        currentPartition);
        for (int i = 1; i <= _wbsContract.parmTargetTask().HierarchyLevel; ++i)
        {
            selectOutdentHierarchyGroupSQL += strFmt(' AND Sort.HierarchyLevel%1 = %2', i,
                taskToOutdentSorting.getFieldValue(strFmt('HierarchyLevel%1', i)));
        }

        // Create a query for placing new lower siblings (and sub-siblings) into unique selection groups
        int newLowerSiblingGroup = _wbsContract.parmNextSelectionGroup();
        int newLowerSubSiblingGroup = newLowerSiblingGroup + 1;
        _wbsContract.parmNextSelectionGroup(newLowerSubSiblingGroup + 1);

        str selectLowerSiblingGroupsSQL = strFmt(@"UPDATE Temp SET
                                                        SelectionGroup = IIF(Sort.HierarchyLevel%1 = 0, %2, %3)
                                                    FROM %4 AS Temp
                                                    INNER JOIN ProjHierarchySorting AS Sort ON
                                                        Sort.Partition = %5 AND Sort.RecId = Temp.RefSortRecId",
                                                    this.parmPreviousTaskParent().HierarchyLevel + 1,
                                                    newLowerSiblingGroup,
                                                    newLowerSubSiblingGroup,
                                                    _projHierarchyTemp.getPhysicalTableName(),
                                                    currentPartition);
        for (int i = 1; i < this.parmPreviousTaskParent().HierarchyLevel; ++i)
        {
            selectLowerSiblingGroupsSQL += strFmt(' AND Sort.HierarchyLevel%1 = %2', i, taskToOutdentSorting.getFieldValue(
                strFmt('HierarchyLevel%1', i)));
        }
        selectLowerSiblingGroupsSQL += strFmt(' AND Sort.HierarchyLevel%1 > %2', this.parmPreviousTaskParent().HierarchyLevel,
            real2Int(this.parmPreviousTaskParent().TaskSiblingNumber));

        // Create a query for placing new children (and sub-children) into unique selection groups
        int newChildrenGroup = _wbsContract.parmNextSelectionGroup();
        int newSubChildrenGroup = newChildrenGroup + 1;
        _wbsContract.parmNextSelectionGroup(newSubChildrenGroup + 1);

        str selectNewChildrenGroupsSQL = strFmt(@"UPDATE Temp SET
                                                        SelectionGroup = IIF(Sort.HierarchyLevel%1 = 0, %2, %3)
                                                    FROM %4 AS Temp
                                                    INNER JOIN ProjHierarchySorting AS Sort ON
                                                        Sort.Partition = %5 AND Sort.RecId = Temp.RefSortRecId",
                                                    _wbsContract.parmTargetTask().HierarchyLevel + 1,
                                                    newChildrenGroup,
                                                    newSubChildrenGroup,
                                                    _projHierarchyTemp.getPhysicalTableName(),
                                                    currentPartition);
        for (int i = 1; i < _wbsContract.parmTargetTask().HierarchyLevel; ++i)
        {
            selectNewChildrenGroupsSQL += strFmt(' AND Sort.HierarchyLevel%1 = %2', i, taskToOutdentSorting.getFieldValue(
                strFmt('HierarchyLevel%1', i)));
        }
        selectNewChildrenGroupsSQL += strFmt(' AND Sort.HierarchyLevel%1 > %2', _wbsContract.parmTargetTask().HierarchyLevel, real2Int(_wbsContract.parmTargetTask().TaskSiblingNumber));

        // Create a query to update the sorting record for the hierarchy to be outdented
        str outdentHierarchyGroupUpdateSortSQL = strFmt(@"UPDATE Sort SET
                                                                Sort.HierarchyLevel%1 = %2",
                                                            newHierarchyLevel,
                                                            real2Int(this.parmNewSiblingNumber()));
        for (int i = newHierarchyLevel + 1; i <= _wbsContract.parmCurrentHierarchyMaxLevel(); ++i)
        {
            outdentHierarchyGroupUpdateSortSQL += strFmt(', Sort.HierarchyLevel%1 = Sort.HierarchyLevel%2', i, i + 1);
        }
        outdentHierarchyGroupUpdateSortSQL += strFmt(@" FROM %1 AS Temp
                                                        INNER JOIN ProjHierarchySorting AS Sort ON
                                                            Sort.Partition = %2 AND Sort.RecId = Temp.RefSortRecId
                                                        WHERE
                                                            Temp.SelectionGroup = %3",
                                                        _projHierarchyTemp.getPhysicalTableName(),
                                                        currentPartition,
                                                        outdentHierarchyGroup);

        // Create a query to update the task record for the hierarchy to be outdented
        str outdentHierarchyGroupUpdateTaskSQL = strFmt(@"UPDATE Task SET
                                                                Task.PathId = dbo.ProjReplacePrefixByDelimeter(Task.PathId, '.', %1, '%2'),
                                                                Task.HierarchyLevel = Task.HierarchyLevel - 1
                                                            FROM %3 AS Temp
                                                            INNER JOIN ProjPlanVersion AS Task ON
                                                                Task.Partition = %4 AND Task.RecId = Temp.RefRecId
                                                            WHERE
                                                                Temp.SelectionGroup = %5",
                                                            _wbsContract.parmTargetTask().HierarchyLevel,
                                                            newPathId,
                                                            _projHierarchyTemp.getPhysicalTableName(),
                                                            currentPartition,
                                                            outdentHierarchyGroup);

        // Create a query for updating the sorting record for the new lower siblings and sub-siblings
        str newLowerSiblingGroupsUpdateSortSQL = strFmt(@"UPDATE Sort SET
                                                                Sort.HierarchyLevel%1 = Sort.HierarchyLevel%1 + 1
                                                            FROM %2 AS Temp
                                                            INNER JOIN ProjHierarchySorting AS Sort ON
                                                                Sort.Partition = %3 AND Sort.RecId = Temp.RefSortRecId
                                                            WHERE
                                                                Temp.SelectionGroup IN (%4, %5)",
                                                            newHierarchyLevel,
                                                            _projHierarchyTemp.getPhysicalTableName(),
                                                            currentPartition,
                                                            newLowerSiblingGroup,
                                                            newLowerSubSiblingGroup);

        // Create a query for updating the task record for the new lower siblings and sub-siblings
        str newLowerSiblingGroupsUpdateTaskSQL = strFmt(@"UPDATE Task SET
                                                                Task.PathId = dbo.%1(Task.PathId, '.', %2, 1),
                                                                Task.TaskSiblingNumber = IIF(Temp.SelectionGroup = %5, Task.TaskSiblingNumber + 1, Task.TaskSiblingNumber)
                                                            FROM %3 AS Temp
                                                            INNER JOIN ProjPlanVersion AS Task ON
                                                                Task.Partition = %4 AND Task.RecId = Temp.RefRecId
                                                            WHERE
                                                                Temp.SelectionGroup IN (%5, %6)",
                                                            ProjHierarchySQLObjects::getIncrementSubStringFuncName(),
                                                            newHierarchyLevel,
                                                            _projHierarchyTemp.getPhysicalTableName(),
                                                            currentPartition,
                                                            newLowerSiblingGroup,
                                                            newLowerSubSiblingGroup);

        // Create a query for updating the sorting record for the new children and sub-children
        str newChildrenGroupsUpdateSortSQL = strFmt(@"UPDATE Sort Set
                                                            Sort.HierarchyLevel%1 = %2,
                                                            Sort.HierarchyLevel%3 = Sort.HierarchyLevel%3 + %4
                                                        FROM %5 AS Temp
                                                        INNER JOIN ProjHierarchySorting AS Sort ON
                                                            Sort.Partition = %6 AND Sort.RecId = Temp.RefSortRecId
                                                        WHERE
                                                            Temp.SelectionGroup IN (%7, %8)",
                                                        newHierarchyLevel,
                                                        real2Int(this.parmNewSiblingNumber()),
                                                        newHierarchyLevel + 1,
                                                        newChildLevelDelta,
                                                        _projHierarchyTemp.getPhysicalTableName(),
                                                        currentPartition,
                                                        newChildrenGroup,
                                                        newSubChildrenGroup);

        // Create a query for updating the task record for the new children and sub-children
        str newChildrenGroupsUpdateTaskSQL = strFmt(@"UPDATE Task Set
                                                            Task.PathId = dbo.%1(
                                                                dbo.%2(Task.PathId, '.', %3, '%4'),
                                                                '.',
                                                                %5,
                                                                %6),
                                                            Task.TaskSiblingNumber = IIF(Temp.SelectionGroup = %10, Task.TaskSiblingNumber + %6, Task.TaskSiblingNumber),
                                                            Task.ParentHierarchyTaskId = IIF(Temp.SelectionGroup = %10, %7, Task.ParentHierarchyTaskId)
                                                        FROM %8 AS Temp
                                                        INNER JOIN ProjPlanVersion AS Task ON
                                                            Task.Partition = %9 AND Task.RecId = Temp.RefRecId
                                                        WHERE
                                                            Temp.SelectionGroup IN (%10, %11)",
                                                        ProjHierarchySQLObjects::getIncrementSubStringFuncName(),
                                                        ProjHierarchySQLObjects::getReplacePrefixFuncName(),
                                                        newHierarchyLevel,
                                                        newPathId,
                                                        _wbsContract.parmTargetTask().HierarchyLevel,
                                                        newChildLevelDelta,
                                                        _wbsContract.parmTargetTask().HierarchyTaskId,
                                                        _projHierarchyTemp.getPhysicalTableName(),
                                                        currentPartition,
                                                        newChildrenGroup,
                                                        newSubChildrenGroup);

        str fullSelectionQuery = selectOutdentHierarchyGroupSQL + ';\n' + selectLowerSiblingGroupsSQL + ';\n'
            + selectNewChildrenGroupsSQL + ';\n';
        str fullUpdateQuery = outdentHierarchyGroupUpdateSortSQL + ';\n' + outdentHierarchyGroupUpdateTaskSQL + ';\n';
        fullUpdateQuery += newLowerSiblingGroupsUpdateSortSQL + ';\n' + newLowerSiblingGroupsUpdateTaskSQL + ';\n';
        fullUpdateQuery += newChildrenGroupsUpdateSortSQL + ';\n' + newChildrenGroupsUpdateTaskSQL + ';\n';

        // Execute the query
        this.executeSQLStatement(fullSelectionQuery + fullUpdateQuery);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuotationRelatedRecordsForOutdentTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update qutoation related records for outdent task operation.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    protected void updateQuotationRelatedRecordsForOutdentTask(ProjWorkBreakdownStructureContract _wbsContract)
    {
        if (_wbsContract.parmWbsType() == ProjWBSType::ProjectQuotation)
        {
            ElementNumber taskElementNumber = ProjWorkBreakdownStructureV2FormHelper::getCorrespondingTaskElementNumber(
                _wbsContract.parmHierarchyId(), _wbsContract.parmTargetTask().HierarchyTaskId);
            ElementNumber oldparentElementNumber = ProjWorkBreakdownStructureV2FormHelper::getCorrespondingTaskElementNumber(
                _wbsContract.parmHierarchyId(), this.parmPreviousTaskParent().HierarchyTaskId);
            ElementNumber newParentElementNumber = ProjWorkBreakdownStructureV2FormHelper::getCorrespondingTaskElementNumber(
                _wbsContract.parmHierarchyId(), this.parmUpdatedTaskParent().HierarchyTaskId);
            ProjTaskNormalized::outdentTasks(_wbsContract.parmHierarchyId(), taskElementNumber,
                oldparentElementNumber, newParentElementNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>swapTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Swaps the position of a task (and all sub-tasks and estimates) with the sibling at the given offset.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <returns>The next unique selection group after this operation has completed.</returns>
    /// <remarks>
    ///
    /// These are the mandatroy parameters required for this API:
    /// ProjWorkBreakdownStructureContract.parmTargetTask()
    /// ProjWorkBreakdownStructureContract.parmWbsType()
    /// ProjWorkBreakdownStructureContract.parmMoveTaskDeltaPosition()
    ///
    /// </remarks>
    public void swapTasks(ProjWorkBreakdownStructureContract _wbsContract)
    {
        if (_wbsContract.parmTargetTask() && _wbsContract.parmMoveTaskDeltaPosition())
        {
            // Not allowed to move root task
            if (_wbsContract.parmTargetTask().isRoot())
            {
                return;
            }

            // Calculate new task sibling number
            this.parmNewSiblingNumber(_wbsContract.parmTargetTask().TaskSiblingNumber + _wbsContract.parmMoveTaskDeltaPosition());

            // Cannot move up past first child
            if (this.parmNewSiblingNumber() < 1)
            {
                return;
            }

            // Cannot move down past last child
            if (this.parmNewSiblingNumber() > ProjPlanVersion::getMaxSiblingNumber(_wbsContract.parmTargetTask().HierarchyId,
                _wbsContract.parmTargetTask().ParentHierarchyTaskId))
            {
                return;
            }

            // Get the task which will be swapping places with the target task.
            ProjPlanVersion swapTask = ProjPlanVersion::findByParentTaskIdAndSiblingNumber(_wbsContract.parmTargetTask().HierarchyId,
                _wbsContract.parmTargetTask().ParentHierarchyTaskId, this.parmNewSiblingNumber(), true);

            this.swapTaskOperation(_wbsContract);

            // Perform additional updates
            ttsbegin;
            swapTask.TaskSiblingNumber = _wbsContract.parmTargetTask().TaskSiblingNumber;
            this.specificFieldsToUpdateForTaskToBeSwapped(_wbsContract, swapTask);
            swapTask.update();
            _wbsContract.parmTargetTask().TaskSiblingNumber = this.parmNewSiblingNumber();
            this.specificFieldsToUpdateForTargetSwappingTask(_wbsContract);
            _wbsContract.parmTargetTask().update();
            ttscommit;

            // If the hierarchy is a quotation, need to updated related records
            this.updateQuotationRelatedRecordsForSwappingTask(_wbsContract, swapTask);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>swapTaskOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update tasks properties due to the swapping of the specific task which is specify as _wbsContract.parmTargetTask() parameter.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <returns>true if operation has been executed successfully; otherwise, false.</returns>
    protected void swapTaskOperation(ProjWorkBreakdownStructureContract _wbsContract)
    {
        str currentPartition = int642Str(getCurrentPartitionRecId());
        str currentCompany = curExt();

        // Get the sorting record for this task
        ProjHierarchySorting sortingRecord = ProjWorkBreakdownStructureV2FormHelper::findProjHierarchySortingRecord(
            _wbsContract.parmTargetTask().HierarchyId, _wbsContract.parmTargetTask().HierarchyTaskId);

        // Construct a query for swapping PathId prefixes
        str updateTaskSQL = strFmt(@"UPDATE Task SET
                                        Task.PathId = dbo.%1(Task.PathId, '.', %2, IIF(Sort.HierarchyLevel%2 = %3, %4, %5))
                                    FROM ProjPlanVersion AS Task
                                    INNER JOIN ProjHierarchySorting AS Sort ON
                                        Sort.Type = %6 AND Sort.RefId = '%7' AND Sort.RefNodeId = Task.HierarchyTaskId
                                    WHERE
                                        Task.Partition = %8 AND Task.DataAreaId = '%9'
                                        AND Sort.Partition = %8 AND Sort.DataAreaId = '%9'
                                        AND Task.HierarchyId = '%7' AND Sort.HierarchyLevel%2 IN (%10, %11)",
                                    ProjHierarchySQLObjects::getIncrementSubStringFuncName(),
                                    _wbsContract.parmTargetTask().HierarchyLevel,
                                    real2int(_wbsContract.parmTargetTask().TaskSiblingNumber),
                                    _wbsContract.parmMoveTaskDeltaPosition(),
                                    _wbsContract.parmMoveTaskDeltaPosition() * -1,
                                    enum2int(ProjHierarchySortingType::ProjWBS),
                                    _wbsContract.parmTargetTask().HierarchyId,
                                    currentPartition,
                                    currentCompany,
                                    real2Int(_wbsContract.parmTargetTask().TaskSiblingNumber),
                                    real2Int(this.parmNewSiblingNumber()));

        // Construct a query for swapping HierarchyLevel fields
        str updateSortSQL = strFmt(@"UPDATE Sort SET
                                        Sort.HierarchyLevel%1 = IIF(Sort.HierarchyLevel%1 = %2, %3, %2)
                                    FROM %4 AS Sort
                                    WHERE
                                        Sort.Partition = %5 AND Sort.DataAreaId = '%6'
                                        AND Sort.RefId = '%7'
                                        AND Sort.HierarchyLevel%1 IN (%2, %3)",
                                    _wbsContract.parmTargetTask().HierarchyLevel,
                                    real2Int(_wbsContract.parmTargetTask().TaskSiblingNumber),
                                    real2Int(this.parmNewSiblingNumber()),
                                    tableStr(ProjHierarchySorting),
                                    currentPartition,
                                    currentCompany,
                                    _wbsContract.parmTargetTask().HierarchyId);

        // Build base selection predicate
        str basePredicate = '';
        for (int i = 1; i < _wbsContract.parmTargetTask().HierarchyLevel; ++i)
        {
            basePredicate += strFmt(' AND Sort.HierarchyLevel%1 = %2', i, sortingRecord.getFieldValue(strFmt('HierarchyLevel%1', i)));
        }
   
        // Build and execute full query
        str fullQuery = updateTaskSQL + basePredicate + '; ' + updateSortSQL + basePredicate;
        this.executeSQLStatement(fullQuery);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuotationRelatedRecordsForSwappingTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update qutoation related records for swapping task operation.
    /// </summary>
    /// <param name = "_wbsContract"><c>ProjWorkBreakdownStructureContract</c> contract class to specify the parameters.</param>
    /// <param name = "_swapTask"><c>ProjPlanVersion</c> table buffer for the task which was swapped.</param>
    protected void updateQuotationRelatedRecordsForSwappingTask(ProjWorkBreakdownStructureContract _wbsContract, ProjPlanVersion _swappedTask)
    {
        if (_wbsContract.parmWbsType() == ProjWBSType::ProjectQuotation)
        {
            ElementNumber taskElementNumber = ProjWorkBreakdownStructureV2FormHelper::getCorrespondingTaskElementNumber(
                _wbsContract.parmTargetTask().HierarchyId, _wbsContract.parmTargetTask().HierarchyTaskId);
            ElementNumber swapTaskElementNumber = ProjWorkBreakdownStructureV2FormHelper::getCorrespondingTaskElementNumber(
                _wbsContract.parmTargetTask().HierarchyId, _swappedTask.HierarchyTaskId);
            ProjTaskNormalized::moveTaskDown(_wbsContract.parmTargetTask().HierarchyId, taskElementNumber,
                swapTaskElementNumber, _wbsContract.parmTargetTask().TaskSiblingNumber, _swappedTask.TaskSiblingNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSetSelectionGroupSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a SQL query to manipulate the selection group for the predicated temp table records.
    /// </summary>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table.</param>
    /// <param name = "_selectionGroupExpression">Expression to assign the selection group for the temp table records to.</param>
    /// <param name = "_predicate">Predicate to filter temp table records with. You may reference the sorting record associated with the temp table record via the name 'Sort'.</param>
    /// <returns>A string SQL query. This does not include a semicolon delimiter.</returns>
    private str getSetSelectionGroupSQLStatement(
        str _tempTablePhysicalName,
        str _selectionGroupExpression,
        str _predicate)
    {
        return ProjHierarchy::getSetSelectionGroupSQLStatementV2(
            _tempTablePhysicalName,
            fieldStr(ProjHierarchyTemp, RefSortRecId),
            fieldStr(ProjHierarchyTemp, SelectionGroup),
            tableStr(ProjHierarchySorting),
            _selectionGroupExpression,
            _predicate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSortingRecordLevelInsertAndReplaceSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a SQL query to perform an "Insert and replace" operation on all sorting records in the given selection group. This is analagous to the following javascript: sorting.splice(_levelIndex, 1, _insert, _replace).
    /// </summary>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table.</param>
    /// <param name = "_maxLevel">Max current depth of the hierarchy.</param>
    /// <param name = "_levelIndex">Sorting level index at which to perform the insert and replace.</param>
    /// <param name = "_insert">Value to insert at the index.</param>
    /// <param name = "_replace">Value to replace immediately after the index.</param>
    /// <param name = "_selectionGroup">Selection group to perform this on.</param>
    /// <returns>A string SQL query. This does not include a semicolon delimiter.</returns>
    private str getSortingRecordLevelInsertAndReplaceSQLStatement(
        str _tempTablePhysicalName,
        int _maxLevel,
        int _levelIndex,
        int _insert,
        int _replace,
        int _selectionGroup)
    {
        return ProjHierarchy::getSortingRecordLevelInsertAndReplaceSQLStatementV2(
            _tempTablePhysicalName,
            fieldStr(ProjHierarchyTemp, RefSortRecId),
            fieldStr(ProjHierarchyTemp, SelectionGroup),
            tableStr(ProjHierarchySorting),
            'HierarchyLevel',
            _maxLevel,
            _levelIndex,
            _insert,
            _replace,
            _selectionGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaskRecordUpdateSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a SQL query to update the associated ProjPlanVersion record for a temp table record in the given selection group.
    /// </summary>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table.</param>
    /// <param name = "_updateExpression">Expression to update the ProjPlanVersion record. You may reference the ProjPlanVersion record via 'Task', and the temp table record via 'Temp'.</param>
    /// <param name = "_selectionGroup">Selection group to perform this on.</param>
    /// <returns>A string SQL query. This does not include a semicolon delimiter.</returns>
    private str getTaskRecordUpdateSQLStatement(
        str _tempTablePhysicalName,
        str _updateExpression,
        int _selectionGroup)
    {
        // Constructs a query similar to:
        // UPDATE Task SET
        //		@_updateExpression
        // FROM @_tempTablePhysicalName AS Temp
        // INNER JOIN ProjPlanVersion AS Task ON
        //		Task.Partition = @currentPartition AND Task.RecId = Temp.RefRecId
        // WHERE
        //		Temp.SelectionGroup = @_selectionGroup

        str currentPartition = int642Str(GetCurrentPartitionRecId());

        return strFmt(@"UPDATE Task Set
                            %1
                        FROM %2 AS Temp
                        INNER JOIN ProjPlanVersion AS Task ON
                            Task.Partition = %3 AND Task.RecId = Temp.RefRecId
                        WHERE
                            Temp.SelectionGroup = %4",
                        _updateExpression,
                        _tempTablePhysicalName,
                        currentPartition,
                        _selectionGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSortingRecordLevelDeltaSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a SQL query to perform to increment/decrement a sorting record level by the given amount.
    /// </summary>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table.</param>
    /// <param name = "_levelIndex">Sorting level index at which to perform the increment/decrement.</param>
    /// <param name = "_delta">Amount to increment/decrement by.</param>
    /// <param name = "_selectionGroup">Selection group to perform this on.</param>
    /// <returns>A string SQL query. This does not include a semicolon delimiter.</returns>
    private str getSortingRecordLevelDeltaSQLStatement(
        str _tempTablePhysicalName,
        int _levelIndex,
        int _delta,
        int _selectionGroup)
    {
        return ProjHierarchy::getSortingRecordLevelDeltaSQLStatementV2(
            _tempTablePhysicalName,
            fieldStr(ProjHierarchyTemp, RefSortRecId),
            fieldStr(ProjHierarchyTemp, SelectionGroup),
            tableStr(ProjHierarchySorting),
            'HierarchyLevel',
            _levelIndex,
            _delta,
            _selectionGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the given string SQL statement.
    /// </summary>
    /// <param name = "_statement">SQL statement to execute.</param>
    private void executeSQLStatement(
        str _statement,
        Map _paramMap = null)
    {
        ttsbegin;
        Connection userConnection = new Connection();
        Statement stmt = userConnection.createStatement();
        new SqlStatementExecutePermission(_statement).assert();
        stmt.executeUpdateWithParameters(_statement, _paramMap);
        CodeAccessPermission::revertAssert();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipDatabaseLogAndEvent</Name>
				<Source><![CDATA[
    private void skipDatabaseLogAndEvent(Common _table)
    {
        // Skip database log and event to improve performance.
        _table.skipDatabaseLog(true);
        _table.skipEvents(true);
        _table.skipDataMethods(true);
        _table.skipDeleteMethod(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCircularReference</Name>
				<Source><![CDATA[
    private void validateCircularReference(ProjPlanVersion _node)
    {
        Set parentTaskIdSet = new Set(Types::Int64);
        ProjPlanVersion projPlanVersion = ProjPlanVersion::findByHierarchyAndTaskId(_node.HierarchyId, _node.ParentHierarchyTaskId);
        while (projPlanVersion)
        {
            if (!parentTaskIdSet.in(projPlanVersion.HierarchyTaskId))
            {
                parentTaskIdSet.add(projPlanVersion.HierarchyTaskId);
                projPlanVersion = ProjPlanVersion::findByHierarchyAndTaskId(projPlanVersion.HierarchyId, projPlanVersion.ParentHierarchyTaskId);
            }
            else
            {
                throw Error("@SYS132865");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxScheduledYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Maximum WBS task scheduling date interval in years to be considered for working days calculation.
    /// </summary>
    /// <returns>WBS task years period.</returns>
    public static Year getMaxScheduledYear()
    {
        return 20;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxTaskDurationDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Maximum WBS task scheduling days to be considered for working days calculation.
    /// </summary>
    /// <returns>WBS task duration in days period.</returns>
    public static Days getMaxTaskDurationDays()
    {
        return 1500;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxTaskEffortLengthInYears</Name>
				<Source><![CDATA[
    /// <summary>
    /// Limit of the WBS task scheduling date interval for effort hours calculation via Calendar API.
    /// </summary>
    /// <returns>Scheduling date interval in years period.</returns>
    public static Year getMaxTaskEffortLengthInYears()
    {
        return 5;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>