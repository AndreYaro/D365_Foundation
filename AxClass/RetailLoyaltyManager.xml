<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailLoyaltyManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Collections;
using Microsoft.Dynamics.Application.Instrumentation;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
/// <summary>
/// Manager class for loyalty
/// </summary>
public class RetailLoyaltyManager
{
    public static RetailLoyaltyManager_ExtendedParameters extendedParameters = RetailLoyaltyManager_ExtendedParameters::construct();
    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>CalculateActivityAmountOrQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount or quantity of the loyalty activity of the given sales order
    /// </summary>
    /// <param name="_salesTable">
    /// The sales table.
    /// </param>
    /// <param name="_earnSchemeLine">
    /// The earning rule.
    /// </param>
    /// <param name="_entryType">
    /// The entry type of the reward point.
    /// </param>
    /// <returns>
    /// The result amount or quantity.
    /// </returns>
    private static RetailLoyaltyActivityAmountQty CalculateActivityAmountOrQuantity(
        SalesTable _salesTable,
        RetailLoyaltyEarnSchemeLine _earnSchemeLine,
        RetailLoyaltyRewardPointEntryType _entryType)
    {
        RetailLoyaltyActivityAmountQty activityAmountQty;
        container packedMapContainer;

        // Calculate activity amount or quantity
        [activityAmountQty, packedMapContainer] =RetailLoyaltyManager::CalculateActivityAmountOrQuantityBySaleLines(_salesTable, _earnSchemeLine, _entryType);

        return activityAmountQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CalculateActivityAmountOrQuantityBySaleLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount or quantity of the loyalty activity of the given sales order
    /// and initializes all qualifying sales lines and their respective amount/quantity for this activity.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales table.
    /// </param>
    /// <param name="_earnSchemeLine">
    /// The earning rule.
    /// </param>
    /// <param name="_entryType">
    /// The entry type of the reward point.
    /// </param>
    /// <returns>
    /// A container having total amount/quantity from sales transaction (applible for this earn line)
    /// and a map of all qualifying sales lines contributing to that amount/quantity.
    /// </returns>
    private static container  CalculateActivityAmountOrQuantityBySaleLines(
        SalesTable _salesTable,
        RetailLoyaltyEarnSchemeLine _earnSchemeLine,
        RetailLoyaltyRewardPointEntryType _entryType)
    {
        Map qualifyingSaleLineAndAmountQty = new Map(Types:: real, Types::real);
        RetailGroupMemberLine groupMemberLine;
        SalesLine salesOrReturnLine;
        InventDimCombination inventDimCombination;
        InventTable inventTable;
        RetailAllProductCategories retailAllProductCategories;

        RetailLoyaltyActivityAmountQty activityAmountQty = 0;
        boolean isProductIndependent;
        boolean isSalesLineCountedForActivityAmountOrQuantity;
        real amountInSalesCurrency, amountInActivityCurrency;
        CurrencyExchangeHelper currencyExchangeHelper;
        RetailLoyaltyCardRewardPointTrans trans;
        RetailSharedParameters retailSharedParameters;
        retailSharedParameters = RetailSharedParameters::find(false);

        switch (_earnSchemeLine.FromActivityType)
        {
            case RetailLoyaltyActivityType::PurchaseProductByAmount:
            case RetailLoyaltyActivityType::PurchaseProductByQuantity:

                // Find sales lines or return lines
                if (_entryType == RetailLoyaltyRewardPointEntryType::Earn)
                {
                    select salesOrReturnLine
                        where salesOrReturnLine.SalesId == _salesTable.SalesId
                           && salesOrReturnLine.SalesType == SalesType::Sales
                           && salesOrReturnLine.SalesStatus == SalesStatus::Invoiced;
                }
                else if (_entryType == RetailLoyaltyRewardPointEntryType::ReturnEarned)
                {
                    select salesOrReturnLine
                        where salesOrReturnLine.SalesId == _salesTable.SalesId
                           && salesOrReturnLine.SalesType == SalesType::ReturnItem
                           && salesOrReturnLine.SalesStatus == SalesStatus::Invoiced;
                }

                // Find the GroupMemberLine of the earning rule
                groupMemberLine = RetailGroupMemberLine::find(_earnSchemeLine.FromActivityRetailGroupMemberLine);

                isProductIndependent = _earnSchemeLine.FromActivityRetailGroupMemberLine == 0
                                       || groupMemberLine.RecId == 0
                                       || (groupMemberLine.Category == 0
                                           && groupMemberLine.Product == 0
                                           && groupMemberLine.Variant == 0);

                // Check if the sales line should be counted into the activity amount or quantity
                while (salesOrReturnLine)
                {
                    isSalesLineCountedForActivityAmountOrQuantity = false;

                    if (isProductIndependent)
                    {
                        isSalesLineCountedForActivityAmountOrQuantity = true;
                    }
                    else if (groupMemberLine.Variant != 0)
                    {
                        if (salesOrReturnLine.RetailVariantId)
                        {
                            inventDimCombination = InventDimCombination::findVariantId(salesOrReturnLine.RetailVariantId);
                            isSalesLineCountedForActivityAmountOrQuantity = groupMemberLine.Variant == inventDimCombination.DistinctProductVariant;
                        }
                        else
                        {
                            isSalesLineCountedForActivityAmountOrQuantity = false;
                        }
                    }
                    else if (groupMemberLine.Product != 0)
                    {
                        inventTable = inventTable::find(salesOrReturnLine.ItemId);
                        isSalesLineCountedForActivityAmountOrQuantity = groupMemberLine.Product == inventTable.Product;
                    }
                    else if (groupMemberLine.Category != 0)
                    {
                        inventTable = inventTable::find(salesOrReturnLine.ItemId);

                        select firstonly Category, Product from retailAllProductCategories
                            where retailAllProductCategories.Category == groupMemberLine.Category
                               && retailAllProductCategories.Product == inventTable.Product;

                        isSalesLineCountedForActivityAmountOrQuantity = retailAllProductCategories.RecId != 0;
                    }

                    // Check the sales line counted into the activity amount or quantity.
                    if (isSalesLineCountedForActivityAmountOrQuantity)
                    {
                        // Check and calculate activityAmountQty when earnschemline's FromActivityType is PurchaseProductByAmount.
                        if (_earnSchemeLine.FromActivityType == RetailLoyaltyActivityType::PurchaseProductByAmount)
                        {
                            amountInSalesCurrency = salesOrReturnline.LineAmount;

                            if (salesOrReturnline.CurrencyCode == _earnSchemeLine.FromActivityAmountCurrency)
                            {
                                amountInActivityCurrency = amountInSalesCurrency;
                            }
                            else
                            {
                                if (currencyExchangeHelper == null)
                                {
                                    currencyExchangeHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
                                }

                                amountInActivityCurrency = currencyExchangeHelper.calculateCurrencyToCurrency(salesOrReturnline.CurrencyCode, _earnSchemeLine.FromActivityAmountCurrency, amountInSalesCurrency, true);
                            }

                            activityAmountQty += amountInActivityCurrency;
                            qualifyingSaleLineAndAmountQty.insert(salesOrReturnLine.LineNum, amountInActivityCurrency);
                        }
                        // Check and calculate activityAmountQty when earnschemline's FromActivityType is PurchaseProductByQuantity.
                        else if (_earnSchemeLine.FromActivityType == RetailLoyaltyActivityType::PurchaseProductByQuantity)
                        {
                            if (RetailLoyaltyPointsCalculationCheckToggle::instance().isEnabled())
                            {
                                activityAmountQty += salesOrReturnline.SalesQty;
                                qualifyingSaleLineAndAmountQty.insert(salesOrReturnLine.LineNum, salesOrReturnline.SalesQty);
                            }
                            else
                            {
                                activityAmountQty += salesOrReturnline.QtyOrdered;
                                qualifyingSaleLineAndAmountQty.insert(salesOrReturnLine.LineNum, salesOrReturnline.QtyOrdered);
                            }
                        }
                    }

                    next salesOrReturnLine;
                }
                break;

            case RetailLoyaltyActivityType::SalesTransactionCount:
                if (_salesTable.SalesType == SalesType::Sales)
                {
                    activityAmountQty = 1;
                }
                else
                {
                    activityAmountQty = 0;
                }
                break;
        }

        return [activityAmountQty, qualifyingSaleLineAndAmountQty.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>CalculateEarnedPointsBySchemeLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the earned points by applying the given earning rule.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales table.
    /// </param>
    /// <param name="_earnSchemeLine">
    /// The earning rule.
    /// </param>
    /// <param name="_rewardPoint">
    /// The reward point to earn.
    /// </param>
    /// <param name="_entryType">
    /// The entry type of the reward point.
    /// </param>
    /// <returns>
    /// The calculation result.
    /// </returns>
    public static RetailLoyaltyRewardPointAmountQty CalculateEarnedPointsBySchemeLine(
        SalesTable _salesTable,
        RetailLoyaltyEarnSchemeLine _earnSchemeLine,
        RetailLoyaltyRewardPoint _rewardPoint,
        RetailLoyaltyRewardPointEntryType _entryType)
    {
        RetailLoyaltyActivityAmountQty activityAmountQty;

        // Calculate activty amount or quantity
        activityAmountQty = RetailLoyaltyManager::CalculateActivityAmountOrQuantity(_salesTable, _earnSchemeLine, _entryType);

        // Calculate earned points
        return RetailLoyaltyManager::CheckThresholdAndCalculateEarnedPoints(_earnSchemeLine, _rewardPoint, activityAmountQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>CalculateEarnedPointsOnSalesLinesBySchemeLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the earned points on sales lines by applying the given earning rule.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales table.
    /// </param>
    /// <param name="_earnSchemeLine">
    /// The earning rule.
    /// </param>
    /// <param name="_rewardPoint">
    /// The reward point to earn.
    /// </param>
    /// <param name="_entryType">
    /// The entry type of the reward point.
    /// </param>
    /// <returns>
    /// The calculation result.
    /// </returns>
    private static Map CalculateEarnedPointsOnSalesLinesBySchemeLine(
        SalesTable _salesTable,
        RetailLoyaltyEarnSchemeLine _earnSchemeLine,
        RetailLoyaltyRewardPoint _rewardPoint,
        RetailLoyaltyRewardPointEntryType _entryType)
    {
        RetailLoyaltyActivityAmountQty activityAmountQty;
        container packedMapContainer;

        // Calculate activity amount or quantity
        [activityAmountQty, packedMapContainer] = RetailLoyaltyManager::CalculateActivityAmountOrQuantityBySaleLines(_salesTable, _earnSchemeLine, _entryType);
        Map qualifyingSaleLineAndAmountQty = Map::create(packedMapContainer);

        // Calculate earned points
        return RetailLoyaltyManager::CheckThresholdAndCalculateEarnedPointsOnSaleLines(_earnSchemeLine, _rewardPoint, activityAmountQty, qualifyingSaleLineAndAmountQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>CheckThresholdAndCalculateEarnedPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the threshold of the earning rule, and calculates the earned points.
    /// </summary>
    /// <param name="_earnSchemeLine">
    /// The earning rule.
    /// </param>
    /// <param name="_rewardPoint">
    /// The reward point.
    /// </param>
    /// <param name="_activityAmountQty">
    /// The amount or quantity of the loyalty activity.
    /// </param>
    /// <returns>
    /// The calculation result.
    /// </returns>
    private static RetailLoyaltyRewardPointAmountQty CheckThresholdAndCalculateEarnedPoints(
        RetailLoyaltyEarnSchemeLine _earnSchemeLine,
        RetailLoyaltyRewardPoint _rewardPoint,
        RetailLoyaltyActivityAmountQty _activityAmountQty)
    {
        RetailLoyaltyRewardPointAmountQty earnedPoints;
        real points = 0, division;

        // Check threshold
        if (abs(_activityAmountQty) >= abs(_earnSchemeLine.FromActivityAmountQty))
        {
            // Calculate earned points.
            earnedPoints = RetailLoyaltyManager::CalculateEarnedPoints(_earnSchemeLine, _rewardPoint, _activityAmountQty);
        }

        return earnedPoints;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CheckThresholdAndCalculateEarnedPointsOnSaleLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the threshold of the earning rule, and calculates the earned points on each sale line.
    /// </summary>
    /// <param name="_earnSchemeLine">
    /// The earning rule.
    /// </param>
    /// <param name="_rewardPoint">
    /// The reward point.
    /// </param>
    /// <param name="_activityAmountQty">
    /// The amount or quantity of the loyalty activity.
    /// </param>
    /// <param name="_qualifyingSaleLineAndAmountQty">
    /// Map of qualifying sale lines for loyalty and their amount/qty.
    /// </param>
    /// <returns>
    /// The calculation result.
    /// </returns>
    private static Map CheckThresholdAndCalculateEarnedPointsOnSaleLines(
        RetailLoyaltyEarnSchemeLine _earnSchemeLine,
        RetailLoyaltyRewardPoint _rewardPoint,
        RetailLoyaltyActivityAmountQty _activityAmountQty,
        Map _qualifyingSaleLineAndAmountQty)
    {
        if (_qualifyingSaleLineAndAmountQty == null || _qualifyingSaleLineAndAmountQty.empty())
        {
            return _qualifyingSaleLineAndAmountQty;
        }

        Map salesLineAndPoints = new Map(Types::Real, Types::Real);
        RetailLoyaltyRewardPointAmountQty earnedPoints;
        real division;

        // Check threshold
        if (abs(_activityAmountQty) >= abs(_earnSchemeLine.FromActivityAmountQty))
        {
            MapIterator salesLineMapIterator = new MapIterator(_qualifyingSaleLineAndAmountQty);

            while(salesLineMapIterator.more())
            {
                // Get amount/qty on sales line.
                RetailLoyaltyActivityAmountQty salesLineAmountOrQuantity = salesLineMapIterator.value();

                // Calculate earned points.
                earnedPoints = RetailLoyaltyManager::CalculateEarnedPoints(_earnSchemeLine, _rewardPoint, salesLineAmountOrQuantity);

                // Set earned reward points for line in map.
                salesLineAndPoints.insert(salesLineMapIterator.key(), earnedPoints);

                salesLineMapIterator.next();
            }
        }

        return salesLineAndPoints;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CalculateEarnedPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the earned points.
    /// </summary>
    /// <param name="_earnSchemeLine">
    /// The earning rule.
    /// </param>
    /// <param name="_rewardPoint">
    /// The reward point.
    /// </param>
    /// <param name="_amountQty">
    /// The amount or quantity of the loyalty activity.
    /// </param>
    /// <returns>
    /// The calculation result.
    /// </returns>
    private static RetailLoyaltyRewardPointAmountQty CalculateEarnedPoints(
        RetailLoyaltyEarnSchemeLine _earnSchemeLine,
        RetailLoyaltyRewardPoint _rewardPoint,
        RetailLoyaltyActivityAmountQty _amountQty)
    {
        RetailLoyaltyRewardPointAmountQty earnedPoints;
        real points = 0, division;

        // Calculte earned points
        if (_rewardPoint.RewardPointType == RetailLoyaltyRewardPointType::Quantity)
        {
            division = _amountQty / _earnSchemeLine.FromActivityAmountQty;
            points = division * _earnSchemeLine.ToRewardPointAmountQty;
        }
        else if (_rewardPoint.RewardPointType == RetailLoyaltyRewardPointType::Amount)
        {
            points = (_amountQty / _earnSchemeLine.FromActivityAmountQty) * _earnSchemeLine.ToRewardPointAmountQty;
        }

        // Round earned points
        earnedPoints = RetailLoyaltyManager::RoundRewardPoints(points, _rewardPoint);

        return earnedPoints;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyCardRewardPointTrans</Name>
				<Source><![CDATA[
    private static Map copyCardRewardPointTrans(RetailLoyaltyCard _sourceCard, RetailLoyaltyCard _destinationCard)
    {
        Map ret = new Map(Types::Int64, Types::Int64);
        int64 recCount, i;
        RetailLoyaltyCardRewardPointTrans rewardPointTrans, dupRewardPointTrans;
        RecId sourceTransRecId, newRecId;
        RecordInsertList recordInsertList = new RecordInsertList(tableNum(RetailLoyaltyCardRewardPointTrans));
        systemSequence sysSeq = new systemSequence();

        select count(RecId) from rewardPointTrans
                where rewardPointTrans.CardNumber == _sourceCard.CardNumber;

        recCount = rewardPointTrans.RecId;
        sysSeq.suspendRecIds(tableNum(RetailLoyaltyCardRewardPointTrans));
        newRecId = sysSeq.reserveValues(recCount, tableNum(RetailLoyaltyCardRewardPointTrans));
        i = 0;

        ttsBegin;

        while select rewardPointTrans
                where rewardPointTrans.CardNumber == _sourceCard.CardNumber
        {
            sourceTransRecId = rewardPointTrans.RecId;
            rewardPointTrans.CardNumber = _destinationCard.CardNumber;
            rewardPointTrans.RecId = newRecId + i;

            recordInsertList.add(rewardPointTrans);

            ret.insert(sourceTransRecId, rewardPointTrans.RecId);
            i++;
        }

        recordInsertList.insertDatabase();

        ttsCommit;

        sysSeq.removeRecIdSuspension(tableNum(RetailLoyaltyCardRewardPointTrans));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyLoyaltyCardTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copying transactions which are related to source loyalty card to destination loyalty card.
    /// Transactions of following tables will be copied: <c>RetailLoyaltyCardRewardPointTrans</c>, <c>RetailLoyaltyCardRewardPointDeduction</c>
    /// <c>RetailLoyaltyCardTier</c>
    /// </summary>
    /// <param name="_sourceCardNumber">
    /// Source loyalty card number
    /// </param>
    /// <param name="_destinationCardNumber">
    /// Destination loyalty card number
    /// </param>
    public static void copyLoyaltyCardTransactions(RetailLoyaltyCardNumber _sourceCardNumber, RetailLoyaltyCardNumber _destinationCardNumber)
    {
        Map matchingSourceAndDestinationRewardPointTrans;
        RetailLoyaltyCard sourceCard, destinationCard;
        sourceCard = RetailLoyaltyCard::findByCardNumber(_sourceCardNumber);
        destinationCard = RetailLoyaltyCard::findByCardNumber(_destinationCardNumber);

        ttsBegin;

        matchingSourceAndDestinationRewardPointTrans = RetailLoyaltyManager::copyCardRewardPointTrans(sourceCard, destinationCard);
        RetailLoyaltyManager::copyRewardPointDeduction(matchingSourceAndDestinationRewardPointTrans);
        RetailLoyaltyManager::mergeLoyaltyCardTier(sourceCard, destinationCard);

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyRewardPointDeduction</Name>
				<Source><![CDATA[
    private static void copyRewardPointDeduction(Map _matchingSourceAndDestinationRewardPointTrans)
    {
        MapIterator matchingPointTransIterator = new MapIterator(_matchingSourceAndDestinationRewardPointTrans);
        RetailLoyaltyCardRewardPointDeduction rewardPointDeduction;
        RecordInsertList recordInsertList = new RecordInsertList(tableNum(RetailLoyaltyCardRewardPointDeduction));

        ttsBegin;

        while (matchingPointTransIterator.more())
        {
            while select rewardPointDeduction
                where rewardPointDeduction.RewardPointSourceTrans == matchingPointTransIterator.key()
            {
                rewardPointDeduction.RewardPointSourceTrans = matchingPointTransIterator.value();
                rewardPointDeduction.RewardPointDeductTrans = _matchingSourceAndDestinationRewardPointTrans.lookup(rewardPointDeduction.RewardPointDeductTrans);

                recordInsertList.add(rewardPointDeduction);
            }
            matchingPointTransIterator.next();
        }

        recordInsertList.insertDatabase();

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateLoyaltyCardTier</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create/Update record of <c>RetailLoyaltyCardTier</c> based on the given parameters
    /// </summary>
    /// <param name="_affiliationId">
    /// the affiliation recId
    /// </param>
    /// <param name="_loyaltyTierId">
    /// the loyalty tier recId
    /// </param>
    /// <param name="_loyaltyCardId">
    /// the loyalty card recId
    /// </param>
    /// <param name="_validFrom">
    /// the valid from date
    /// </param>
    /// <param name="_validTo">
    /// the valid to date
    /// </param>
    /// <param name="_relatedRetailLoyaltyTierRuleId">
    /// the tier rule that tiggered the loyalty tier create/update.
    /// </param>
    /// <param name="_retailLoyaltyTierGrantDate">
    /// Date Granted.
    /// </param>
    /// <param name="_retailLoyaltyTierGrantTime">
    /// Time Granted.
    /// </param>
    /// <remarks>
    /// First check if record of <c>RetailLoyaltyCardTier</c> exist or not.
    /// If not, create a new record in <c>RetailLoyaltyCardTier</c>
    /// If exist, then validate the overLap and update the record of <c>RetailLoyaltyCardTier</c> accordingly.
    /// </remarks>
    private static void createOrUpdateLoyaltyCardTier(RefRecId _affiliationId, RefRecId _loyaltyTierId, RefRecId _loyaltyCardId, date _validFrom,
        date _validTo, RefRecId _relatedRetailLoyaltyTierRuleId, date _retailLoyaltyTierGrantDate, int _retailLoyaltyTierGrantTime)
    {
        RetailLoyaltyCardTier loyaltyCardTier;
        date minimumDate = DateTimeUtil::date(DateTimeUtil::minValue());
        date maximumDate = DateTimeUtil::date(DateTimeUtil::maxValue());

        boolean foundOverlap = false;

        //if exist check the duration overlap
        while select loyaltyCardTier
            where loyaltyCardTier.LoyaltyCard == _loyaltyCardId
            && loyaltyCardTier.Affiliation == _affiliationId
            && loyaltyCardTier.LoyaltyTier == _loyaltyTierId
        {
            //check overlap based on given from and to date
            if ((loyaltyCardTier.ValidTo == maximumDate || _validFrom == minimumDate || _validFrom <= loyaltyCardTier.ValidTo + 1)
                && (loyaltyCardTier.ValidFrom == minimumDate || _validTo == minimumDate || _validTo >= loyaltyCardTier.ValidFrom - 1))
            {
                foundOverlap = true;

                if (loyaltyCardTier.ValidFrom > min(_validFrom, loyaltyCardTier.ValidFrom)
                    || loyaltyCardTier.ValidTo < max(_validTo, loyaltyCardTier.ValidTo))
                {
                    loyaltyCardTier.selectForUpdate(true);
                    loyaltyCardTier.ValidFrom = min(_validFrom, loyaltyCardTier.ValidFrom);
                    loyaltyCardTier.ValidTo = max(_validTo, loyaltyCardTier.ValidTo);
                    loyaltyCardTier.update();
                }

                // Create/Update _loyaltyCardTier grant detail for card's new/existing tier.
                RetailLoyaltyManager::generateLoyaltyTierGrantDetailData(_affiliationId, _loyaltyTierId, _loyaltyCardId, loyaltyCardTier.RecId, _relatedRetailLoyaltyTierRuleId, _retailLoyaltyTierGrantDate, _retailLoyaltyTierGrantTime);

                break;
            }
        }

        // No overLap or no existing record then create a new record based on the given parameters
        if (!foundOverlap)
        {
            loyaltyCardTier.initValue();
            loyaltyCardTier.LoyaltyCard = _loyaltyCardId;
            loyaltyCardTier.Affiliation = _affiliationId;
            loyaltyCardTier.LoyaltyTier = _loyaltyTierId;
            loyaltyCardTier.ValidFrom = _validFrom;
            loyaltyCardTier.ValidTo = _validTo;
            loyaltyCardTier.insert();

            // Create/Update _loyaltyCardTier grant detail for card's new/existing tier.
            RetailLoyaltyManager::generateLoyaltyTierGrantDetailData(_affiliationId, _loyaltyTierId, _loyaltyCardId, loyaltyCardTier.RecId, _relatedRetailLoyaltyTierRuleId, _retailLoyaltyTierGrantDate, _retailLoyaltyTierGrantTime);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>DeductPositiveRemainings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Uses the returned points or the negative adjusted points of a transaction to deduct the positive balances of the previous transactions, if any.
    /// </summary>
    /// <param name="_retailLoyaltyCardRewardPointTransRecId">
    /// The record ID of the current <c>RetailLoyaltyCardRewardPointTrans</c> record.
    /// </param>
    /// <param name="_transDate">
    /// The entry date of the current <c>RetailLoyaltyCardRewardPointTrans</c> record.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_rewardPointRecid">
    /// The record ID of the reawrd point.
    /// </param>
    /// <param name="_points">
    /// The negative points.
    /// </param>
    /// <returns>
    /// The remaining points.
    /// </returns>
    private static RetailLoyaltyRewardPointAmountQty DeductPositiveRemainings(
        RefRecId _retailLoyaltyCardRewardPointTransRecId,
        date _transDate,
        RetailLoyaltyCardNumber _cardNumber,
        RefRecId _rewardPointRecid,
        RetailLoyaltyRewardPointAmountQty _points)
    {
        #OCCRetryCount

        RetailLoyaltyRewardPointAmountQty remainingPoints;

        if (_points < 0)
        {
            remainingPoints = _points;
        }
        else
        {
            return _points;
        }

        // Check feature status for RetailCalculationOfUnvestedLoyaltyPointsForReturnTransactionFeature.
        // If true will calculate unvested points earn during a sales transaction and revert them from loyalty card for return.
        if (FeatureStateProvider::isFeatureEnabled(RetailCalculationOfUnvestedLoyaltyPointsForReturnTransactionFeature::instance()))
        {
            // Check for Unvested points,revert the Unvested points first if any,
            // And then revert the Available points.
            RetailLoyaltyRewardPoint loyaltyRewardPoint;
            RetailLoyaltyRewardPointAmountQty unvestedPoints;
            RetailLoyaltyCard retailLoyaltyCard = RetailLoyaltyCard::findByCardNumber(_cardNumber);

            unvestedPoints = RetailLoyaltyCardRewardPointTrans::calcPoints(retailLoyaltyCard,_rewardPointRecid,RetailLoyaltyPointStatusTypeBase::Unvested);

            if (unvestedPoints)
            {
                // Deduct points from Unvested trans.
                remainingPoints = RetailLoyaltyManager::DeductUnvestedPositiveRemainings(_retailLoyaltyCardRewardPointTransRecId,_transDate,_cardNumber,_rewardPointRecid,remainingPoints);
            }
        }

        // Deduct points from Available points.
        if (remainingPoints)
        {
            try
            {
                remainingPoints = RetailLoyaltyManager::PerformPositiveRemainingsDeduction(_retailLoyaltyCardRewardPointTransRecId, _rewardPointRecid, _transDate, remainingPoints, _cardNumber);
            }
            catch (Exception::UpdateConflict)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWriteFailedToPostTransactionLoyaltyPoints(_retailLoyaltyCardRewardPointTransRecId);
                    //The attempt to deduct loyalty points failed due to update conflicts, and the retry limit was exceeded. Please retry the operation.
                    error("@Retail:LoyaltyPointsDeduction_ErrorUpdateRetryExceeded");
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
        }

        return remainingPoints;
    }

]]></Source>
			</Method>
			<Method>
				<Name>PerformPositiveRemainingsDeduction</Name>
				<Source><![CDATA[
    private static RetailLoyaltyRewardPointAmountQty PerformPositiveRemainingsDeduction(
        RefRecId _retailLoyaltyCardRewardPointTransRecId,
        RefRecId _rewardPointRecid,
        date _transDate,
        RetailLoyaltyRewardPointAmountQty _remainingPoints,
        RetailLoyaltyCardNumber _cardNumber)
    {
        RetailLoyaltyCardRewardPointTrans positiveRemainingTrans;
        RetailLoyaltyRewardPointAmountQty deductionPoints;
        RetailLoyaltyCardRewardPointDeduction deduction;

        // When the adjustment point is negative:
        // Deduct points from the previous trans, if any.
        // Deduct the points ordered by expiration date.
        while select forUpdate positiveRemainingTrans
                    order by positiveRemainingTrans.ExpirationDate, positiveRemainingTrans.RecId
                    where positiveRemainingTrans.CardNumber == _cardNumber
                        && positiveRemainingTrans.RewardPoint == _rewardPointRecid
                        && positiveRemainingTrans.Remaining > 0
                        && (positiveRemainingTrans.ExpirationDate >= _transDate || !positiveRemainingTrans.ExpirationDate)
        {
            boolean remainingTransHasSufficientRemainingPoints = false;

            if (positiveRemainingTrans.Remaining >= _remainingPoints * -1)
            {
                // The found trans has enough positive remaining points for deduction.
                deductionPoints = _remainingPoints * -1;
                positiveRemainingTrans.Remaining += _remainingPoints;
                _remainingPoints = 0;
                remainingTransHasSufficientRemainingPoints = true;
            }
            else
            {
                // The found trans does not have enough positive remaining points for deduction.
                // Deduct all and continue to find the next.
                deductionPoints = positiveRemainingTrans.Remaining;
                _remainingPoints += positiveRemainingTrans.Remaining;
                positiveRemainingTrans.Remaining = 0;
                remainingTransHasSufficientRemainingPoints = false;
            }

            // Update the Remaining of the negative remaining trans.
            positiveRemainingTrans.update();

            // Insert deduction line.
            deduction.initValue();
            deduction.RewardPointSourceTrans = positiveRemainingTrans.RecId;
            deduction.RewardPointDeductTrans = _retailLoyaltyCardRewardPointTransRecId;
            deduction.RewardPointAmountQty = deductionPoints;
            deduction.insert();

            eventSource.EventWriteDeductPositiveRemainingsOfLoyaltyCard(positiveRemainingTrans.RecId,
                                                                                deduction.RecId,
                                                                                deductionPoints,
                                                                                _remainingPoints,
                                                                                remainingTransHasSufficientRemainingPoints,
                                                                                _retailLoyaltyCardRewardPointTransRecId,
                                                                                _rewardPointRecid,
                                                                                _transDate);

            if (_remainingPoints == 0)
            {
                break;
            }
        }

        return _remainingPoints;
    }

]]></Source>
			</Method>
			<Method>
				<Name>EvaluateLoyaltyCardTiers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluate the card tiers for the given card.
    /// </summary>
    /// <param name="_cardNumber">
    /// The card number to evaluate.
    /// </param>
    /// <param name="_evaluatedDate">
    /// The date to evaluate. By default it's today (UTC).
    /// </param>
    public static void EvaluateLoyaltyCardTiers(RetailLoyaltyCardNumber _cardNumber, date _evaluatedDate = DateTimeUtil::date(DateTimeUtil::utcNow()))
    {
        RetailLoyaltyCard currentLoyaltyCard;
        RetailLoyaltyCard relatedLoyaltyCard;
        RetailLoyaltyCardTier loyaltyCardTier;
        RetailLoyaltyTier loyaltyTier;
        RetailLoyaltyTierRule loyaltyTierRule;
        RetailPeriodCode tierRuleDateInterval;
        RetailPeriodCode tierDateInterval;
        RetailAffiliation affiliation;

        Set affiliationSet, cardRecordSet;
        SetEnumerator affiliationEnumerator, cardRecordEnumerator;
        RecId partyId, affiliationId;
        RetailLoyaltyRewardPointAmountQty points;
        boolean isQualify;
        RefRecId relatedRetailLoyaltyTierRuleId;
        boolean breakAll = false;
        date evaluateFromDate, validFromDate;
        date evalulateToDate, validToDate;
        int  evaluateFromTime = 0;
        boolean evaluateFromDateUpdated = false;

        // Validate loyalty card number, if not found do nothing.
        currentLoyaltyCard = RetailLoyaltyCard::findByCardNumber(_cardNumber);
        if (currentLoyaltyCard && !currentLoyaltyCard.ReplacementCard)
        {
            affiliationSet = new Set(Types::Int64);
            cardRecordSet = new Set(Types::Record);

            cardRecordSet.add(currentLoyaltyCard);
            partyId = currentLoyaltyCard.Party;

            while select Affiliation from loyaltyCardTier
                group by loyaltyCardTier.Affiliation
                    where loyaltyCardTier.LoyaltyCard == currentLoyaltyCard.RecId
            {
                affiliationSet.add(loyaltyCardTier.Affiliation);
            }

            ttsBegin;

            //Find related card in the same party if partId != 0
            if (partyId)
            {
                while select relatedLoyaltyCard
                    where relatedLoyaltyCard.Party == partyId && relatedLoyaltyCard.CardNumber != _cardNumber && relatedLoyaltyCard.ReplacementCard == 0
                {
                    cardRecordSet.add(relatedLoyaltyCard);
                    while select Affiliation from loyaltyCardTier
                            group by loyaltyCardTier.Affiliation
                                where loyaltyCardTier.LoyaltyCard == relatedLoyaltyCard.RecId
                        join RecId, PoolRelatedCards from affiliation
                            where affiliation.RecId == loyaltyCardTier.Affiliation
                               && affiliation.PoolRelatedCards == NoYes::Yes
                    {
                        if (!affiliationSet.in(loyaltyCardTier.Affiliation))
                        {
                            affiliationSet.add(loyaltyCardTier.Affiliation);
                        }
                    }
                }
            }

            affiliationEnumerator = affiliationSet.getEnumerator();
            while (affiliationEnumerator.moveNext())
            {
                affiliationId = affiliationEnumerator.current();
                while select Affiliation from loyaltyTier
                    where loyaltyTier.Affiliation == affiliationId
                        join PoolRelatedCards from affiliation
                            where affiliation.RecId == affiliationId
                        join tierDateInterval
                            where tierDateInterval.Code == loyaltyTier.ValidDateInterval
                {
                    isQualify = false;
                    evaluateFromDateUpdated = false;
                    relatedRetailLoyaltyTierRuleId = 0;

                    // Evaluate all tier rule
                    while select RewardPoint, MinValue, RecID from loyaltyTierRule
                        where loyaltyTier.RecId ==  loyaltyTierRule.LoyaltyTier
                            join tierRuleDateInterval
                                where tierRuleDateInterval.Code == loyaltyTierRule.ValidationDateInterval
                    {
                        points = 0;
                        RetailLoyaltyCardTier cardTier;
                        RetailLoyaltyTierGrantDetail retailLoyaltyTierGrantDetail;

                        // Get evaludate dates based on evaluate date
                        evaluateFromDate = tierRuleDateInterval.fromDate(_evaluatedDate);
                        evalulateToDate = tierRuleDateInterval.toDate(_evaluatedDate);
                        if (!evalulateToDate)
                        {
                            evalulateToDate = maxDate();
                        }

                        // If affiliation's poolRelatedCard marked as yes, then need to calculate all cards.
                        if (affiliation.PoolRelatedCards)
                        {
                            cardRecordEnumerator = cardRecordSet.getEnumerator();
                            while (cardRecordEnumerator.moveNext())
                            {
                                relatedLoyaltyCard = cardRecordEnumerator.current();

                                // Find Loyalty card's tier grant detail.
                                select firstonly cardTier
                                    join retailLoyaltyTierGrantDetail
                                        where retailLoyaltyTierGrantDetail.LoyaltyCard == relatedLoyaltyCard.RecId
                                        && retailLoyaltyTierGrantDetail.Affiliation == affiliationId
                                        && retailLoyaltyTierGrantDetail.LoyaltyTier == loyaltyTier.RecId
                                        && retailLoyaltyTierGrantDetail.RelatedRetailLoyaltyTierRule == loyaltyTierRule.RecId
                                        && retailLoyaltyTierGrantDetail.RetailLoyaltyCardTier == cardTier.RecId;

                                // Set last evaluated date and time variable if loyalty tier is already granted, to filter data from RetailLoyaltyCardRewardPointTrans.
                                if (retailLoyaltyTierGrantDetail.RecId && (evaluateFromDate <= retailLoyaltyTierGrantDetail.RetailLoyaltyTierGrantDate))
                                {
                                    evaluateFromDate =  retailLoyaltyTierGrantDetail.RetailLoyaltyTierGrantDate;
                                    evaluateFromTime = retailLoyaltyTierGrantDetail.RetailLoyaltyTierGrantTime;
                                    evaluateFromDateUpdated = true;
                                }

                                points += RetailLoyaltyCardRewardPointTrans::getIssuedPointsForLoyaltyCard(relatedLoyaltyCard.CardNumber, loyaltyTierRule.RewardPoint, evaluateFromDate, evalulateToDate, evaluateFromTime, evaluateFromDateUpdated);
                            }
                        }
                        else
                        {
                            // Find Loyalty card's tier grant detail.
                            select firstonly cardTier
                                    join retailLoyaltyTierGrantDetail
                                        where retailLoyaltyTierGrantDetail.LoyaltyCard == currentLoyaltyCard.RecId
                                        && retailLoyaltyTierGrantDetail.Affiliation == affiliationId
                                        && retailLoyaltyTierGrantDetail.LoyaltyTier == loyaltyTier.RecId
                                        && retailLoyaltyTierGrantDetail.RelatedRetailLoyaltyTierRule == loyaltyTierRule.RecId
                                        && retailLoyaltyTierGrantDetail.RetailLoyaltyCardTier == cardTier.RecId;

                            // Set last evaluated date and time variable if loyalty tier is already granted, to filter data from RetailLoyaltyCardRewardPointTrans.
                            if (retailLoyaltyTierGrantDetail.RecId && (evaluateFromDate <= retailLoyaltyTierGrantDetail.RetailLoyaltyTierGrantDate))
                            {
                                evaluateFromDate =  retailLoyaltyTierGrantDetail.RetailLoyaltyTierGrantDate;
                                evaluateFromTime = retailLoyaltyTierGrantDetail.RetailLoyaltyTierGrantTime;
                                evaluateFromDateUpdated = true;
                            }

                            // Get issued points for current card.
                            points = RetailLoyaltyCardRewardPointTrans::getIssuedPointsForLoyaltyCard(currentLoyaltyCard.CardNumber, loyaltyTierRule.RewardPoint, evaluateFromDate, evalulateToDate, evaluateFromTime, evaluateFromDateUpdated);
                        }

                        if ( points >= loyaltyTierRule.MinValue)
                        {
                            isQualify = true;
                            relatedRetailLoyaltyTierRuleId = loyaltyTierRule.RecId;
                        }

                        if (isQualify)
                        {
                            // Get valid dates based on evaludateDate
                            validFromDate = tierDateInterval.fromDate(_evaluatedDate);
                            validToDate = tierDateInterval.toDate(_evaluatedDate);
                            if (!validToDate)
                            {
                                validToDate = maxDate();
                            }

                            if (affiliation.PoolRelatedCards)
                            {
                                cardRecordEnumerator = cardRecordSet.getEnumerator();
                                while (cardRecordEnumerator.moveNext())
                                {
                                    relatedLoyaltyCard = cardRecordEnumerator.current();
                                    // Check whether record exist based on cardId,TierId and Affiliation
                                    RetailLoyaltyManager::createOrUpdateLoyaltyCardTier(affiliationId, loyaltyTier.RecId, relatedLoyaltyCard.RecId, validFromDate, validToDate, relatedRetailLoyaltyTierRuleId, DateTimeUtil::date(DateTimeUtil::utcNow()), DateTimeUtil::time(DateTimeUtil::utcNow()));
                                }
                            }
                            else
                            {
                                // Check whether record exist based on cardId,TierId and Affiliation for current card
                                RetailLoyaltyManager::createOrUpdateLoyaltyCardTier(affiliationId, loyaltyTier.RecId, currentLoyaltyCard.RecId, validFromDate, validToDate, relatedRetailLoyaltyTierRuleId, DateTimeUtil::date(DateTimeUtil::utcNow()), DateTimeUtil::time(DateTimeUtil::utcNow()));
                            }
                        }
                    }
                }
            }

            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>FindLoyaltyEarnSchemeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the earning rules that applies to the given loyalty card.
    /// </summary>
    /// <param name="_channelOU">
    /// The record Id of the operating unit of the channel.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_date">
    /// The date.
    /// </param>
    /// <returns>
    /// The list of the <c>RetailLoyaltyEarnSchemeLine</c> records found.
    /// </returns>
    public static List FindLoyaltyEarnSchemeLines(RefRecId _channelOU, RetailLoyaltyCardNumber _cardNumber, date _date)
    {
        RetailLoyaltyCardTier cardTier;
        RetailLoyaltyEarnSchemeLine earnSchemeLineByLoyaltyTier;

        List earnSchemeLineList = new List(Types::Record);
        List maxCardTiers;
        ListEnumerator maxCardTierEnumerator;

        // Find the active loyalty card tiers
        maxCardTiers = RetailLoyaltyManager::FindMaxLoyaltyCardTiers(_cardNumber, _date);
        maxCardTierEnumerator = maxCardTiers.getEnumerator();

        // Collect the earning rules by card tiers
        while (maxCardTierEnumerator.moveNext())
        {
            cardTier = maxCardTierEnumerator.current();

            // Find the earning rules that are associated to the loyalty program without the tier specified
            earnSchemeLineByLoyaltyTier = RetailLoyaltyManager::FindLoyaltyEarnSchemeLinesByLoyaltyTier(_channelOU, cardTier.Affiliation, 0, _date);

            while (earnSchemeLineByLoyaltyTier)
            {
                earnSchemeLineByLoyaltyTier.LoyaltyTier = cardTier.LoyaltyTier;
                earnSchemeLineList.addEnd(earnSchemeLineByLoyaltyTier);
                next earnSchemeLineByLoyaltyTier;
            }

            // Find the earning rules that are associated to the specific loyalty tier
            if (cardTier.LoyaltyTier)
            {
                earnSchemeLineByLoyaltyTier = RetailLoyaltyManager::FindLoyaltyEarnSchemeLinesByLoyaltyTier(_channelOU, cardTier.Affiliation, cardTier.LoyaltyTier, _date);

                while (earnSchemeLineByLoyaltyTier)
                {
                    earnSchemeLineList.addEnd(earnSchemeLineByLoyaltyTier);
                    next earnSchemeLineByLoyaltyTier;
                }
            }
        }

        return earnSchemeLineList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>FindLoyaltyEarnSchemeLinesByLoyaltyTier</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the earning rules by the given loyalty tier.
    /// </summary>
    /// <param name="_channelOU">
    /// The record identifier of the operating unit of the channel.
    /// </param>
    /// <param name="_affiliation">
    /// The record identifier of the loyalty program.
    /// </param>
    /// <param name="_loyaltyTier">
    /// The record identifier of the loyalty tier. The value can be 0.
    /// </param>
    /// <param name="_date">
    /// The valid date of the earning rules.
    /// </param>
    /// <returns>
    /// The found rules.
    /// </returns>
    public static RetailLoyaltyEarnSchemeLine FindLoyaltyEarnSchemeLinesByLoyaltyTier(RefRecId _channelOU, RefRecId _affiliation, RefRecId _loyaltyTier, date _date)
    {
        RetailLoyaltyEarnSchemeLine earnSchemeLine;
        RetailLoyaltyScheme scheme;
        RetailLoyaltySchemeChannelExploded schemeChannelExploded;

        if (_channelOU && _affiliation)
        {
            select earnSchemeLine
                exists join scheme
                    where scheme.RecId == earnSchemeLine.LoyaltyScheme
                       && scheme.Affiliation == _affiliation
                exists join schemeChannelExploded
                    where schemeChannelExploded.LoyaltyScheme == scheme.RecId
                       && schemeChannelExploded.OMOperatingUnit == _channelOU
                       && earnSchemeLine.LoyaltyTier == _loyaltyTier
                       && (!earnSchemeLine.ValidFrom || earnSchemeLine.ValidFrom <= _date)
                       && (!earnSchemeLine.ValidTo || earnSchemeLine.ValidTo >= _date);
        }

        return earnSchemeLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>FindMaxLoyaltyCardTiers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the highest loyalty card tiers of the given loyalty card.
    /// </summary>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_date">
    /// The date.
    /// </param>
    /// <returns>
    /// The list of <c>RetailLoyaltyCardTier</c> records.
    /// </returns>
    public static List FindMaxLoyaltyCardTiers(RetailLoyaltyCardNumber _cardNumber, date _date)
    {
        RetailLoyaltyCard loyaltyCard;
        RetailLoyaltyCardTier cardTier, currentMaxCardTier;
        RetailLoyaltyTier higherLoyaltyTier;

        // Key: Affiliation recId, Value: RetailLoyaltyCardTier
        Map mapMaxLoyaltyCardTiers = new Map(Types::Real, Types::Record);

        MapEnumerator enumerator;
        List listMaxLoyaltyCardTiers =new List(Types::Record);

        // Loop through all effective card tiers,
        // Find the highest card tier per affiliation.
        while select LoyaltyCard, Affiliation, LoyaltyTier from cardTier
            group by cardTier.LoyaltyCard, cardTier.Affiliation, cardTier.LoyaltyTier
            where (!cardTier.ValidFrom || cardTier.ValidFrom <= _date)
               && (!cardTier.ValidTo || cardTier.ValidTo >= _date)
            exists join loyaltyCard
                where loyaltyCard.RecId == cardTier.LoyaltyCard
                   && loyaltyCard.CardNumber == _cardNumber
        {
            if (!mapMaxLoyaltyCardTiers.exists(cardTier.Affiliation))
            {
                mapMaxLoyaltyCardTiers.insert(cardTier.Affiliation, cardTier);
            }
            else
            {
                currentMaxCardTier = mapMaxLoyaltyCardTiers.lookup(cardTier.Affiliation);

                if (currentMaxCardTier.LoyaltyTier == 0 && cardTier.LoyaltyTier != 0)
                {
                    mapMaxLoyaltyCardTiers.insert(cardTier.Affiliation, cardTier);
                }
                else if (currentMaxCardTier.LoyaltyTier != 0 && cardTier.LoyaltyTier != 0)
                {
                    select firstOnly recid from higherLoyaltyTier
                        order by higherLoyaltyTier.TierLevel desc
                        where higherLoyaltyTier.Affiliation == cardTier.Affiliation
                           && (higherLoyaltyTier.RecId == cardTier.LoyaltyTier
                               || higherLoyaltyTier.RecId == currentMaxCardTier.LoyaltyTier);

                    if (cardTier.LoyaltyTier == higherLoyaltyTier.RecId)
                    {
                        mapMaxLoyaltyCardTiers.insert(cardTier.Affiliation, cardTier);
                    }
                }
            }
        }

        // Convert Map into a List
        enumerator = mapMaxLoyaltyCardTiers.getEnumerator();
        while (enumerator.moveNext())
        {
            listMaxLoyaltyCardTiers.addEnd(enumerator.currentValue());
        }

        return listMaxLoyaltyCardTiers;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateLoyaltyCardRewardPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reward points from a sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order.
    /// </param>
    /// <param name="_retailSalesTable">
    /// The retail sales order.
    /// </param>
    /// <param name="_earnSchemeLine">
    /// The earning rule.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_utcDateTime">
    /// The UTC date time.
    /// </param>
    /// <param name="_entryType">
    /// The reward point entry tppe.
    /// </param>
    /// <returns>
    /// The reward points on transaction and lines.
    /// </returns>
    private static Map GenerateLoyaltyCardRewardPoints(
        SalesTable _salesTable,
        RetailSalesTable _retailSalesTable,
        RetailLoyaltyEarnSchemeLine _earnSchemeLine,
        RetailLoyaltyCardNumber _cardNumber,
        utcdatetime _utcDateTime,
        RetailLoyaltyRewardPointEntryType _entryType)
    {
        // Initialize the map for sales line and their points.
        Map salesLineNumberAndPoints = new Map(Types::Real, Types:: real);

        // Find reward point
        RetailLoyaltyRewardPoint rewardPoint = RetailLoyaltyRewardPoint::find(_earnSchemeLine.ToRewardPoint);
        RetailSharedParameters retailSharedParameters = RetailSharedParameters::find(false);

        if (!retailSharedParameters.PostLoyaltyPointsPerSalesLine
            || _earnSchemeLine.FromActivityType == RetailLoyaltyActivityType::SalesTransactionCount)
        {
            // Calculate earned points on sales order by scheme line
            RetailLoyaltyRewardPointAmountQty points = RetailLoyaltyManager::CalculateEarnedPointsBySchemeLine(_salesTable, _earnSchemeLine, rewardPoint, _entryType);
            // Insert transaction header level points to map.
            salesLineNumberAndPoints.insert(0, points);
        }
        else
        {
            // Calculate earned points on sales each sales line by scheme line
            salesLineNumberAndPoints = RetailLoyaltyManager::CalculateEarnedPointsOnSalesLinesBySchemeLine(_salesTable, _earnSchemeLine, rewardPoint, _entryType);
        }

        return salesLineNumberAndPoints;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateLoyaltyCardRewardPointTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the loyalty reward points transactions from a sales order.
    /// </summary>
    /// <param name="_salesLineLineNum">
    /// The sales order line number.
    /// </param>
    /// <param name="_points">
    /// The loyalty points.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order.
    /// </param>
    /// <param name="_retailSalesTable">
    /// The retail sales order.
    /// </param>
    /// <param name="_earnSchemeLine">
    /// The earning rule.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_loyaltyTransLineNumber">
    /// The reward point line's number.
    /// </param>
    /// <param name="_utcDateTime">
    /// The UTC date time.
    /// </param>
    /// <param name="_entryType">
    /// The reward point entry type.
    /// </param>
    /// <returns>
    /// The reward point transaction.
    /// </returns>
    private static RetailLoyaltyCardRewardPointTrans GenerateLoyaltyCardRewardPointTrans(
        LineNumOptional _salesLineLineNum,
        RetailLoyaltyRewardPointAmountQty _points,
        SalesTable _salesTable,
        RetailSalesTable _retailSalesTable,
        RetailLoyaltyEarnSchemeLine _earnSchemeLine,
        RetailLoyaltyCardNumber _cardNumber,
        LineNumber _loyaltyTransLineNumber,
        utcdatetime _utcDateTime,
        RetailLoyaltyRewardPointEntryType _entryType)
    {
        RetailLoyaltyScheme scheme = RetailLoyaltyScheme::findByRecId(_earnSchemeLine.LoyaltyScheme);

        return RetailLoyaltyManager::GenerateLoyaltyCardRewardPointTransaction(_salesLineLineNum, _points, _salesTable,
            _retailSalesTable, _earnSchemeLine.ToRewardPoint, scheme.Affiliation, _earnSchemeLine.LoyaltyTier,
            _cardNumber, _loyaltyTransLineNumber, _utcDateTime, _entryType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateLoyaltyCardRewardPointTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the loyalty reward points transactions from a sales order.
    /// </summary>
    /// <param name="_salesLineLineNum">
    /// The sales order line number.
    /// </param>
    /// <param name="_points">
    /// The loyalty points.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order.
    /// </param>
    /// <param name="_retailSalesTable">
    /// The retail sales order.
    /// </param>
    /// <param name="_rewardPointRecId">
    /// The reward point rec id.
    /// </param>
    /// <param name="_affliation">
    /// The affiliation rec id.
    /// </param>
    /// <param name="_loyaltyTier">
    /// The loyalty tier rec id.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_loyaltyTransLineNumber">
    /// The reward point line's number.
    /// </param>
    /// <param name="_utcDateTime">
    /// The UTC date time.
    /// </param>
    /// <param name="_entryType">
    /// The reward point entry type.
    /// </param>
    /// <returns>
    /// The reward point transaction.
    /// </returns>
    private static RetailLoyaltyCardRewardPointTrans GenerateLoyaltyCardRewardPointTransaction(
        LineNumOptional _salesLineLineNum,
        RetailLoyaltyRewardPointAmountQty _points,
        SalesTable _salesTable,
        RetailSalesTable _retailSalesTable,
        RefRecId _rewardPointRecId,
        RefRecId _affliation,
        RefRecId _loyaltyTier,
        RetailLoyaltyCardNumber _cardNumber,
        LineNumber _loyaltyTransLineNumber,
        utcdatetime _utcDateTime,
        RetailLoyaltyRewardPointEntryType _entryType)
    {
        RetailLoyaltyCardRewardPointTrans trans;
        
        if (_points != 0)
        {
            // Find loyalty scheme
            RetailLoyaltyRewardPoint rewardPoint = RetailLoyaltyRewardPoint::find(_rewardPointRecId);

            // Generate loyalty reward point trans
            trans.initValue();
            trans.Affiliation = _affliation;
            trans.CardNumber = _cardNumber;
            trans.Channel = _retailSalesTable.RetailChannel;
            trans.CustAccount = _salesTable.CustAccount;
            trans.CustAccountDataAreaId = _salesTable.dataAreaId;
            trans.EntryDate = DateTimeUtil::date(_utcDateTime);
            trans.EntryTime = DateTimeUtil::time(_utcDateTime);

            if (_salesTable.SalesType == SalesType::Sales)
            {
                trans.ExpirationDate = rewardPoint.expirationDate(trans.EntryDate);
            }
            else if (_salesTable.SalesType == SalesType::ReturnItem)
            {
                trans.ExpirationDate = DateTimeUtil::date(DateTimeUtil::maxValue());
            }

            trans.LoyaltyTier = _loyaltyTier;
            trans.LoyaltyTransactionType = RetailLoyaltyTransactionType::SalesOrder;
            trans.loyaltyTransDataAreaId = _salesTable.dataAreaId;
            trans.LoyaltyTransLineNum = _loyaltyTransLineNumber;
            trans.ReceiptId = '';
            trans.Remaining = 0;
            trans.RewardPoint = _rewardPointRecId;
            trans.RewardPointAmountQty = _points;
            if (_salesTable.SalesType == SalesType::Sales && _points < 0 && _entryType == RetailLoyaltyRewardPointEntryType::Earn)
            {
                trans.EntryType = RetailLoyaltyRewardPointEntryType::ReturnEarned;
            }
            else
            {
                trans.EntryType = _entryType;
            }
            trans.StaffId = '';
            trans.storeId = _retailSalesTable.RetailStoreId;
            trans.terminalId = _retailSalesTable.RetailTerminalId;
            trans.SalesId = _salesTable.SalesId;
            trans.SalesLineLineNum = _salesLineLineNum;
        }

        return trans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLoyaltyPointStatus62</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates amount of active default loyalty points by card number.
    /// </summary>
    /// <param name="cardNumber">
    /// Loyalty card number.
    /// </param>
    /// <returns>
    /// <c>Container</c> with calculated active points.
    /// </returns>
    /// <remarks>
    /// Obsolete.
    /// </remarks>
    public static  container getLoyaltyPointStatus62(RetailLoyaltyCardNumber cardNumber)
    {
        RetailPointStatus   pointStatus = 0;
        RetailLoyaltyCard retailLoyaltyCard, card = RetailLoyaltyCard::findByCardNumber(cardNumber);
        RefrecId rewardPointId = 0;
        Container ret;

        date _calculateDate = DateTimeUtil::date(DateTimeUtil::utcNow());

        if (card.RecId)
        {
            rewardPointId = RetailLoyaltySchemeBackwardCompatibility::findByLoyaltyCard(card.recId).RewardPoint;

            switch (card.CardTenderType)
            {
                case RetailLoyaltyTenderTypeBase::AsCardTender:
                    if (rewardPointId)
                    {
                        pointStatus = RetailLoyaltyCardRewardPointTrans::calcPoints(card, rewardPointId, RetailLoyaltyPointStatusTypeBase::Active, _calculateDate);
                    }
                    ret = [true,"@RET4471",pointStatus,0];
                    break;
                case RetailLoyaltyTenderTypeBase::AsContactTender:
                    if (rewardPointId)
                    {
                        while select retailLoyaltyCard
                            where retailLoyaltyCard.CardTenderType != RetailLoyaltyTenderTypeBase::Blocked
                                && retailLoyaltyCard.Party == card.Party
                        {
                            pointStatus += RetailLoyaltyCardRewardPointTrans::calcPoints(retailLoyaltyCard, rewardPointId, RetailLoyaltyPointStatusTypeBase::Active, _calculateDate);
                        }
                    }
                    ret = [true,"@RET4470",pointStatus,1];
                    break;
                case RetailLoyaltyTenderTypeBase::Blocked:
                    ret = [false,"@RET4466",pointStatus,3];
                    break;
                case RetailLoyaltyTenderTypeBase::NoTender:
                    ret = [true,"@RET4469",pointStatus,2];
                    break;
            }
        }
        else
        {
            ret = [false, "@RET4467", 0, 3];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>IncreaseNegativeRemainings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Uses the earned points or the positive adjusted points of a transaction to cover the negative balances of the previous transactions, if any.
    /// </summary>
    /// <param name="_retailLoyaltyCardRewardPointTransRecId">
    /// The record ID of the current <c>RetailLoyaltyCardRewardPointTrans</c> record.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_rewardPointRecid">
    /// The record ID of the reawrd point.
    /// </param>
    /// <param name="_points">
    /// The positive points.
    /// </param>
    /// <returns>
    /// The remaining points.
    /// </returns>
    private static RetailLoyaltyRewardPointAmountQty IncreaseNegativeRemainings(
        RefRecId _retailLoyaltyCardRewardPointTransRecId,
        RetailLoyaltyCardNumber _cardNumber,
        RefRecId _rewardPointRecid,
        RetailLoyaltyRewardPointAmountQty _points)
    {
        RetailLoyaltyCardRewardPointTrans negativeRemainingTrans;
        RetailLoyaltyCardRewardPointDeduction deduction;

        RetailLoyaltyRewardPointAmountQty remainingPoints, deductionPoints;

        if (_points > 0)
        {
            remainingPoints = _points;
        }
        else
        {
            return _points;
        }

        // Use the earned points of this trans to cover the negative balances of the previous trans, if any.
        while select forUpdate negativeRemainingTrans
            order by negativeRemainingTrans.ExpirationDate, negativeRemainingTrans.RecId
            where negativeRemainingTrans.CardNumber == _cardNumber
                && negativeRemainingTrans.RewardPoint == _rewardPointRecid
                && negativeRemainingTrans.Remaining < 0
        {
            boolean remainingTransHasSufficientRemainingPoints = false;

            if (negativeRemainingTrans.Remaining * -1 > remainingPoints)
            {
                // The found trans has more negative remaining points than the earn trans can cover.
                deductionPoints = remainingPoints;
                negativeRemainingTrans.Remaining += remainingPoints;
                remainingPoints = 0;
                remainingTransHasSufficientRemainingPoints = false;
            }
            else
            {
                // Enough earned points to cover the negaive remaining of the found trans.
                deductionPoints = negativeRemainingTrans.Remaining * -1;
                remainingPoints += negativeRemainingTrans.Remaining;
                negativeRemainingTrans.Remaining = 0;
                remainingTransHasSufficientRemainingPoints = true;
            }

            // Update the Remaining of the negative remaining trans.
            negativeRemainingTrans.update();

            // Insert deduction line.
            deduction.initValue();
            deduction.RewardPointSourceTrans = _retailLoyaltyCardRewardPointTransRecId;
            deduction.RewardPointDeductTrans = negativeRemainingTrans.RecId;
            deduction.RewardPointAmountQty = deductionPoints;
            deduction.insert();

            eventSource.EventWriteIncreaseNegativeRemainingsOfLoyaltyCard(negativeRemainingTrans.RecId,
                                                                          deduction.RecId,
                                                                          deductionPoints,
                                                                          remainingPoints,
                                                                          remainingTransHasSufficientRemainingPoints,
                                                                          _retailLoyaltyCardRewardPointTransRecId,
                                                                          _rewardPointRecid);

            if (remainingPoints == 0)
            {
                break;
            }
        }

        return remainingPoints;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeLoyaltyCardTier</Name>
				<Source><![CDATA[
    private static void mergeLoyaltyCardTier(RetailLoyaltyCard _sourceCard, RetailLoyaltyCard _destinationCard)
    {
        RetailLoyaltyCardTier cardTier;
        RetailLoyaltyTierGrantDetail cardTierGrantDetail;

        ttsBegin;

        while select cardTier
                where cardTier.LoyaltyCard == _sourceCard.RecId
        {
            while select relatedRetailLoyaltyTierRule, retailLoyaltyTierGrantDate, retailLoyaltyTierGrantTime from cardTierGrantDetail
               where cardTierGrantDetail.RetailLoyaltyCardTier == cardTier.RecId
            {
                RetailLoyaltyManager::createOrUpdateLoyaltyCardTier(cardTier.Affiliation, cardTier.LoyaltyTier, _destinationCard.RecId,
                    cardTier.ValidFrom, cardTier.ValidTo, cardTierGrantDetail.relatedRetailLoyaltyTierRule, cardTierGrantDetail.retailLoyaltyTierGrantDate, cardTierGrantDetail.retailLoyaltyTierGrantTime);
            }
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostNonTransactionalLoyaltyPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts non-transactional loyalty points.
    /// </summary>
    /// <param name="_nonTransactionalActivity">
    /// The non-transactional activity.
    /// </param>
    /// <returns>
    /// A container containing a flag indicating whether the operation completed successfully and an error message, if any.
    /// </returns>
    public static container PostNonTransactionalLoyaltyPoints(RetailLoyaltyCardRewardPointNonTransactionalActivity _nonTransactionalActivity)
    {
        boolean isSuccess = false;
        str message;
        RetailChannelTable channel;
        List earnSchemeLineList;
        ListEnumerator earnSchemeLineListEnumerator;
        RetailLoyaltyEarnSchemeLine earnSchemeLine;
        RetailLoyaltyCardRewardPointTrans trans;
        utcDateTime currentUtcDateTime;
        date currentUtcDate;
        RetailLoyaltyCard card = RetailLoyaltyCard::findByCardNumber(_nonTransactionalActivity.CardNumber);
        CustTable custTable;

        try
        {
            select firstonly trans
                where trans.NonTransactionalActivityId == _nonTransactionalActivity.NonTransactionalActivityId;

            // Do not post activities that have already been posted.
            if (trans)
            {
                message = "@Retail:LoyaltyOtherActivityIdAlreadyExists";
                RetailLoyaltyManager::UpdateNonTransactionalActivityStatus(_nonTransactionalActivity, RetailLoyaltyCardRewardPointNonTransactionalActivityStatus::Error, message);
            }
            else if (card.CardTenderType == RetailLoyaltyTenderTypeBase::Blocked)
            {
                message = "@Retail:RetailLoyaltyCardBlockedError";
                RetailLoyaltyManager::UpdateNonTransactionalActivityStatus(_nonTransactionalActivity, RetailLoyaltyCardRewardPointNonTransactionalActivityStatus::Error, message);
            }
            else
            {
                select firstonly crossCompany custTable
                where custTable.Party == card.Party;

                ttsbegin;
                channel = RetailChannelTable::findByOperatingUnitId(_nonTransactionalActivity.OMOperatingUnitID);
                currentUtcDateTime = DateTimeUtil::utcNow();
                currentUtcDate = DateTimeUtil::date(currentUtcDateTime);

                // Find all applicable earn lines for the channel and loyalty card.
                earnSchemeLineList = RetailLoyaltyManager::FindLoyaltyEarnSchemeLines(channel.OMOperatingUnitID, _nonTransactionalActivity.CardNumber, currentUtcDate);

                earnSchemeLineListEnumerator = earnSchemeLineList.getEnumerator();
                while (earnSchemeLineListEnumerator.moveNext())
                {
                    earnSchemeLine = earnSchemeLineListEnumerator.current();
                    boolean isEarnLineApplicable;

                    // Verify that the earn line applicable for the non-transactional activity.
                    isEarnLineApplicable = RetailLoyaltyManager::validateForNonTransactionalActivity(earnSchemeLine, _nonTransactionalActivity.LoyaltyOtherActivityTypeId, _nonTransactionalActivity.RetailAffiliationId, custTable);
                    if (isEarnLineApplicable)
                    {
                        // Post the points
                        trans = RetailLoyaltyManager::GenerateLoyaltyCardRewardPointTransForNonTransactionalActivity(earnSchemeLine, _nonTransactionalActivity, custTable, currentUtcDateTime, channel);
                        if (trans.NonTransactionalActivityId)
                        {
                            RetailLoyaltyManager::PostLoyaltyCardRewardPointTrans(trans);
                            isSuccess = true;
                        }
                    }
                }

                ttscommit;

                if (isSuccess)
                {
                    RetailLoyaltyManager::UpdateNonTransactionalActivityStatus(_nonTransactionalActivity, RetailLoyaltyCardRewardPointNonTransactionalActivityStatus::Posted);
                }
                else
                {
                    message = "@Retail:NoApplicableLoyaltyEarnLines";
                    RetailLoyaltyManager::UpdateNonTransactionalActivityStatus(_nonTransactionalActivity, RetailLoyaltyCardRewardPointNonTransactionalActivityStatus::Error, message);
                }
            }

        }
        catch
        {
            ttsabort;
            message = "@Retail:FailedToPostNonTransactionalLoyaltyPoints";
            RetailLoyaltyManager::UpdateNonTransactionalActivityStatus(_nonTransactionalActivity, RetailLoyaltyCardRewardPointNonTransactionalActivityStatus::Error, message);
            eventSource.EventWriteFailedToPostNonTransactionalLoyaltyPoints(_nonTransactionalActivity.RecId);
            isSuccess = false;
        }

        return [isSuccess, message];
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateNonTransactionalActivityStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of a non-transactional loyalty activity.
    /// </summary>
    /// <param name="_nonTransactionalActivity">
    /// The non-transactional activity.
    /// </param>
    /// <param name="_status">
    /// The status to update the activity to.
    /// </param>
    /// <param name="_errorMessage">
    /// The optional error message.
    /// </param>
    private static void UpdateNonTransactionalActivityStatus(RetailLoyaltyCardRewardPointNonTransactionalActivity _nonTransactionalActivity, RetailLoyaltyCardRewardPointNonTransactionalActivityStatus _status, str _errorMessage = '')
    {
        RetailLoyaltyCardRewardPointNonTransactionalActivity nonTransactionalActivity;

        select firstonly forUpdate nonTransactionalActivity
                    where nonTransactionalActivity.NonTransactionalActivityId == _nonTransactionalActivity.NonTransactionalActivityId;

        if (nonTransactionalActivity)
        {
            ttsbegin;
            nonTransactionalActivity.Status = _status;

            if (_status == RetailLoyaltyCardRewardPointNonTransactionalActivityStatus::Error)
            {
                nonTransactionalActivity.ErrorLogs = strFmt('%1 %2', _errorMessage, _nonTransactionalActivity.ErrorLogs);
            }

            nonTransactionalActivity.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForNonTransactionalActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate that the earn line is applicable for the non-transactional loyalty activity.
    /// </summary>
    /// <param name="_earnLine">
    /// The loyalty earn line.
    /// </param>
    /// <param name="_activityTypeId">
    /// The identifier for non-transactional activity.
    /// </param>
    /// <param name="_affiliationId">
    /// The retail affiliation identifier associated with the activity.
    /// </param>
    /// <param name="_custTable">
    /// The customer table record.
    /// </param>
    /// <returns>
    /// True if it is a valid earn line; otherwise, false.
    /// </returns>
    private static boolean validateForNonTransactionalActivity(RetailLoyaltyEarnSchemeLine _earnLine, RetailLoyaltyOtherActivityTypeId _activityTypeId, RetailAffiliationId _affiliationId, CustTable _custTable)
    {
        RetailLoyaltyOtherActivityType otherActivityType;
        RetailLoyaltySchemeExcludedAffiliation excludedAffiliation;
        RetailLoyaltySchemeChannelExploded channelExploded;
        RetailCustAffiliation retailCustAffiliation;
        boolean requiredAffiliationSatisfied = false;

        // Verify that the earn scheme line is for the specified activity type.
        select firstonly RecId from otherActivityType
            where otherActivityType.LoyaltyOtherActivityTypeId == _activityTypeId;

        // Verify that the affiliation on the customer is not in the list of excluded affiliations.
        if (_custTable)
        {
            select excludedAffiliation
                join retailCustAffiliation
                    where excludedAffiliation.RetailAffiliationId == retailCustAffiliation.RetailAffiliationId
                        && retailCustAffiliation.CustAccountNum == _custTable.AccountNum
                        && retailCustAffiliation.DataAreaId == _custTable.DataAreaId
                        && excludedAffiliation.LoyaltySchemeId == _earnLine.LoyaltyScheme;
        }

        // Verify that affiliation passed into the method is not in the list of excluded afflilations.
        if (!excludedAffiliation)
        {
            select excludedAffiliation
                where excludedAffiliation.RetailAffiliationId == _affiliationId
                && excludedAffiliation.LoyaltySchemeId == _earnLine.LoyaltyScheme;
        }

        // Verify that the required affiliation is passed in as a parameter, or the customer has the affiliation.
        if (_earnLine.RetailAffiliationId)
        {
            if (_earnLine.RetailAffiliationId == _affiliationId)
            {
                requiredAffiliationSatisfied = true;
            }
            else
            {
                select firstonly retailCustAffiliation
                        where retailCustAffiliation.CustAccountNum == _custTable.AccountNum
                        && retailCustAffiliation.DataAreaId == _custTable.DataAreaId
                        && retailCustAffiliation.RetailAffiliationId == _earnLine.RetailAffiliationId;

                requiredAffiliationSatisfied = retailCustAffiliation ? true : false;
            }
        }
        else
        {
            // The earn scheme does not require an affiliation, so the condition is met.
            requiredAffiliationSatisfied = true;
        }

        return _earnLine.RetailFromOtherActivityTypeId == otherActivityType.RecId && !excludedAffiliation && requiredAffiliationSatisfied;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateLoyaltyCardRewardPointTransForNonTransactionalActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the loyalty reward points transaction from a non-transactional activity.
    /// </summary>
    /// <param name="_earnSchemeLine">
    /// The earning rule.
    /// </param>
    /// <param name="_nonTransactionalActivity">
    /// The record for the non-transactional activity.
    /// </param>
    /// <param name="_custTable">
    /// The customer record.
    /// </param>
    /// <param name="_utcDateTime">
    /// The UTC date time.
    /// </param>
    /// <param name="_channel">
    /// The channel.
    /// </param>
    /// <returns>
    /// The reward point transaction.
    /// </returns>
    private static RetailLoyaltyCardRewardPointTrans GenerateLoyaltyCardRewardPointTransForNonTransactionalActivity(
        RetailLoyaltyEarnSchemeLine _earnSchemeLine,
        RetailLoyaltyCardRewardPointNonTransactionalActivity _nonTransactionalActivity,
        CustTable _custTable,
        utcdatetime _utcDateTime,
        RetailChannelTable _channel)
    {
        RetailLoyaltyScheme scheme = RetailLoyaltyScheme::findByRecId(_earnSchemeLine.LoyaltyScheme);
        RetailLoyaltyCardRewardPointTrans trans;
        RetailLoyaltyOtherActivityType otherActivityType;

        select firstonly RecId from otherActivityType
            where otherActivityType.LoyaltyOtherActivityTypeId == _nonTransactionalActivity.LoyaltyOtherActivityTypeId;

        if (_earnSchemeLine.ToRewardPointAmountQty != 0)
        {
            // Find loyalty scheme
            RetailLoyaltyRewardPoint rewardPoint = RetailLoyaltyRewardPoint::find(_earnSchemeLine.ToRewardPoint);

            // Generate loyalty reward point trans
            trans.initValue();
            trans.Affiliation = scheme.Affiliation;
            trans.CardNumber = _nonTransactionalActivity.CardNumber;
            trans.Channel = _channel.RecId;
            if (_custTable)
            {
                trans.CustAccount = _custTable.AccountNum;
                trans.CustAccountDataAreaId = _custTable.DataAreaId;
            }

            // Use the entry date and time provided by the activity, otherwise default to the UTC time.
            trans.EntryDate = _nonTransactionalActivity.EntryDate ? _nonTransactionalActivity.EntryDate : DateTimeUtil::date(_utcDateTime);
            trans.EntryTime = _nonTransactionalActivity.EntryTime ? _nonTransactionalActivity.EntryTime : DateTimeUtil::time(_utcDateTime);
            trans.EntryType = RetailLoyaltyRewardPointEntryType::Earn;
            trans.ExpirationDate = rewardPoint.expirationDate(trans.EntryDate);
            trans.LoyaltyOtherActivityTypeId = otherActivityType.RecId;
            trans.LoyaltyTier = _earnSchemeLine.LoyaltyTier;
            trans.LoyaltyTransactionType = RetailLoyaltyTransactionType::NonTransactionalActivity;
            trans.loyaltyTransDataAreaId = _channel.inventLocationDataAreaId;
            trans.NonTransactionalActivityId = _nonTransactionalActivity.NonTransactionalActivityId;
            trans.ReceiptId = '';
            trans.Remaining = 0;
            trans.RewardPoint = _earnSchemeLine.ToRewardPoint;
            trans.RewardPointAmountQty = _earnSchemeLine.ToRewardPointAmountQty;
            trans.StaffId = '';
        }

        return trans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddRefundPointLines</Name>
				<Source><![CDATA[
    private static void AddRefundPointLines(SalesTable _salesTable, List _refundPointLines)
    {
        RetailLoyaltyCardRewardPointTrans rewardPointTrans;
        RetailLoyaltyCardRewardPointTrans rewardPointTransRefund;
        real alreadyRefundedLoyaltyPoints;
        utcDateTime dateTimeUTC = DateTimeUtil::utcNow();
        if (_salesTable.SalesStatus == SalesStatus::Canceled)
        {
            alreadyRefundedLoyaltyPoints =  RetailLoyaltyCardRewardPointTrans::GetRefundedRewardPoints(_salesTable.SalesId, _salesTable.DataAreaId, 0);
            eventSource.EventWriteAddRefundPointLinesForSalesOrderCanceled(_salesTable.RecId, _salesTable.SalesStatus);
           
            select firstonly *
            from rewardPointTrans
            where rewardPointTrans.LoyaltyTransactionType == RetailLoyaltyTransactionType::SalesOrder
            && rewardPointTrans.loyaltyTransDataAreaId == _salesTable.DataAreaId
            && rewardPointTrans.SalesId == _salesTable.SalesId
            && rewardPointTrans.SalesLineLineNum == 0
            && rewardPointTrans.EntryType == RetailLoyaltyRewardPointEntryType::Redeem;
            
            if (rewardPointTrans)
            {
                buf2Buf(rewardPointTrans,rewardPointTransRefund);
                rewardPointTransRefund.EntryDate = DateTimeUtil::date(dateTimeUTC);
                rewardPointTransRefund.EntryTime = DateTimeUtil::time(dateTimeUTC);
                rewardPointTransRefund.EntryType = RetailLoyaltyRewardPointEntryType::Refund;
                rewardPointTransRefund.RewardPointAmountQty = (rewardPointTransRefund.RewardPointAmountQty * -1) - alreadyRefundedLoyaltyPoints;
                // Add to record list.
                _refundPointLines.addEnd(rewardPointTransRefund);
            }
        }
        if (RetailLoyaltyCardRewardPointTrans::SalesOrderHasLineLevelPointsRecorded(_salesTable.SalesId, _salesTable.dataAreaId))
        {
            SalesLine salesLine;

            // Otherwise just use the pre-invoice amounts from the SalesLine table.
            while select salesLine
                where salesLine.SalesId == _salesTable.SalesId && salesLine.SalesStatus == SalesStatus::Canceled
            {
                alreadyRefundedLoyaltyPoints =  RetailLoyaltyCardRewardPointTrans::GetRefundedRewardPoints(_salesTable.SalesId, _salesTable.DataAreaId, salesLine.LineNum);

                while select  *
                    from rewardPointTrans
                    where rewardPointTrans.LoyaltyTransactionType == RetailLoyaltyTransactionType::SalesOrder
                    && rewardPointTrans.loyaltyTransDataAreaId == _salesTable.DataAreaId
                    && rewardPointTrans.SalesId == _salesTable.SalesId
                    && rewardPointTrans.SalesLineLineNum == salesLine.LineNum
                    && rewardPointTrans.EntryType == RetailLoyaltyRewardPointEntryType::Redeem
                {
                    real pointsToBeRefunded = (rewardPointTrans.RewardPointAmountQty * -1) - alreadyRefundedLoyaltyPoints;
                    if (pointsToBeRefunded > 0)
                    {
                        buf2Buf(rewardPointTrans,rewardPointTransRefund);
                        rewardPointTransRefund.EntryDate = DateTimeUtil::date(dateTimeUTC);
                        rewardPointTransRefund.EntryTime = DateTimeUtil::time(dateTimeUTC);
                        rewardPointTransRefund.EntryType = RetailLoyaltyRewardPointEntryType::Refund;
                        rewardPointTransRefund.RewardPointAmountQty = pointsToBeRefunded;
                        // Add to record list.
                        _refundPointLines.addEnd(rewardPointTransRefund);

                    }

                    eventSource.EventWriteCreateRewardPointTransRefundForRetailLoyaltyCardRewardPointTrans(rewardPointTrans.RecId);
                }

                eventSource.EventWriteGetSalesLineForCanceledSalesOrder(_salesTable.RecId, salesLine.RecId);
            }

            eventSource.EventWriteAddRefundPointLinesCalculationWhenSalesOrderHasLineLevelPointsRecorded(_salesTable.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddRefundPointLineForRemovedPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds all reedem transactions associated with payment and generates a refund line of the same amount.
    /// </summary>
    /// <param name = "_salesTable">
    /// The Sales Order associated with loyalty payment
    /// </param>
    /// <returns>
    /// List containing refund point lines.
    /// </returns>
    internal static List AddRefundPointLineForRemovedPayment(SalesTable _salesTable)
    {
        RetailLoyaltyCardRewardPointTrans rewardPointTrans;
        RetailLoyaltyCardRewardPointTrans rewardPointTransRefund;
        utcDateTime dateTimeUTC = DateTimeUtil::utcNow();
        MCRCustPaymTableRecID paymRecId = extendedParameters.parmMCRPaymRecId();
        List refundLines = new List(Types::Record);

        // Find LoyaltyCardRewardPointTrans records of type redeem for this sales order and with the same MCRCustPaymTableRecID
        // as the payment to be removed.
        while select * from rewardPointTrans
            where rewardPointTrans.LoyaltyTransactionType == RetailLoyaltyTransactionType::SalesOrder
            && rewardPointTrans.MCRPaymRecId == paymRecId
            && rewardPointTrans.SalesId == _salesTable.SalesId
            && rewardPointTrans.EntryType == RetailLoyaltyRewardPointEntryType::Redeem
        {
            if (rewardPointTrans)
            {
                buf2Buf(rewardPointTrans,rewardPointTransRefund);
                rewardPointTransRefund.EntryDate = DateTimeUtil::date(dateTimeUTC);
                rewardPointTransRefund.EntryTime = DateTimeUtil::time(dateTimeUTC);
                rewardPointTransRefund.EntryType = RetailLoyaltyRewardPointEntryType::Refund;
                rewardPointTransRefund.RewardPointAmountQty = (rewardPointTransRefund.RewardPointAmountQty * -1);
                refundLines.addEnd(rewardPointTransRefund);
            }
        }

        return refundLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostCardTransFromSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts loyalty card transactions from the completely invoiced sales order.
    /// </summary>
    /// <param name="_salesId">
    /// The sales ID.
    /// </param>
    public static void PostCardTransFromSalesTable(SalesIdBase _salesId)
    {
        SalesTable salesTable, originSalesTable;
        SalesLine returnSalesLine, originSalesLine, exchangeSalesLine;
        RetailSalesTable retailSalesTable, originRetailSalesTable;
        RetailChannelTable channel, originChannel;
        RetailLoyaltyCard loyaltyCard;
        RetailLoyaltyEarnSchemeLine earnSchemeLine;
        RetailLoyaltyCardRewardPointTrans trans;
        RetailSalesAffiliation retailSalesAffiliation;
        RetailAffiliation retailAffiliation;

        utcDateTime currentUTCDateTime;
        date utcDate;
        List earnSchemeLineList;
        ListEnumerator earnSchemeLineListEnumerator;
        LineNumber lineNumber;
        boolean isOrderPaidByLoyalty;
        RetailSharedParameters retailSharedParameters;

        // Find the sales order, retail sales order, retail channel and loyalty card.
        // Check whether the sales order is completely invoiced. Before that we don't earn/deduct any points.
        salesTable = salesTable::find(_salesId);
        retailSalesTable = salesTable.retailSalesTable();
        channel = RetailChannelTable::findByRecId(retailSalesTable.RetailChannel);
        loyaltyCard = RetailLoyaltyCard::find(retailSalesTable.RetailLoyaltyCard);
        retailSharedParameters = RetailSharedParameters::find(false);

        if (!salesTable
            || !retailSalesTable
            || !channel
            || !loyaltyCard
            || (salesTable.SalesStatus != SalesStatus::Invoiced && !retailSharedParameters.PostLoyaltyPointsPerSalesLine))
        {
            return;
        }

        // Get entry type
        RetailLoyaltyRewardPointEntryType entryType;
        if (salesTable.SalesType == SalesType::Sales)
        {
            entryType = RetailLoyaltyRewardPointEntryType::Earn;
        }
        else if (salesTable.SalesType == SalesType::ReturnItem)
        {
            entryType = RetailLoyaltyRewardPointEntryType::ReturnEarned;
        }
        else
        {
            // Exit if salestype is anything other than Sales or ReturnItem.
            return;
        }

        // Exit if we already posted loyalty points for this sales order at order level.
        select firstOnly RecId from trans
            where trans.SalesId == salesTable.SalesId
               && trans.CardNumber == loyaltyCard.CardNumber;

        if (RetailStatementFeatureControl::isLoyaltyPointsForSalesOrderInStatementEnabled() && (trans.RecId && retailSalesTable.StatementId))
        {
            return;
        }

        if (trans.RecId && !retailSharedParameters.PostLoyaltyPointsPerSalesLine)
        {
            return;
        }

        // Find the origin sales order if it is a return order
        if (salesTable.SalesType == SalesType::ReturnItem)
        {
            select firstOnly SalesId from originSalesLine
                exists join returnSalesLine
                    where returnSalesLine.InventTransIdReturn == originSalesLine.InventTransId
                        && returnSalesLine.InventTransIdReturn != ''
                        && returnSalesLine.SalesId == salesTable.SalesId;

            originSalesTable = salesTable::find(originSalesLine.SalesId);
            originRetailSalesTable = originSalesTable.retailSalesTable();
            originChannel = RetailChannelTable::findByRecId(originRetailSalesTable.RetailChannel);
            
            // Check whether the origin sales order was a Retail order
            if (originSalesTable)
            {
                // Check whether the origin sales order was completely invoiced, otherwise it hasn't earned any points.
                if (!originRetailSalesTable
                   || !originChannel
                   || originSalesTable.SalesStatus != SalesStatus::Invoiced)
                {
                    return;
                }

                // Get loyalty card from origin sales order.
                loyaltyCard = RetailLoyaltyCard::find(originRetailSalesTable.RetailLoyaltyCard);
            }

            // Check whether transaction has loyalty card.
            if (!loyaltyCard)
            {
                return;
            }

            isOrderPaidByLoyalty = RetailLoyaltyCardRewardPointTrans::IsSalesOrderPaidByLoyalty(originSalesTable.SalesId, originSalesTable.dataAreaId);
        }
        else
        {
            isOrderPaidByLoyalty = RetailLoyaltyCardRewardPointTrans::IsSalesOrderPaidByLoyalty(salesTable.SalesId, salesTable.dataAreaId);
        }

        if (!isOrderPaidByLoyalty)
        {
            currentUTCDateTime = DateTimeUtil::utcNow();
            utcDate = DateTimeUtil::date(currentUTCDateTime);

            // Flag indicating whether original order has any line level points.
            boolean originalOrderHadLineLevelPoints = salesTable.SalesType == SalesType::ReturnItem &&
                RetailLoyaltyCardRewardPointTrans::SalesOrderHasLineLevelPointsRecorded(originSalesTable.SalesId, originSalesTable.dataAreaId);

            // If there were any line level points and configuration to post points per line is TRUE, then return earn points from original transaction.
            if (originalOrderHadLineLevelPoints && retailSharedParameters.PostLoyaltyPointsPerSalesLine)
            {
                RetailLoyaltyManager::copyRewardPointsForReturnFromOriginalTrans(salesTable, originSalesTable, retailSalesTable, loyaltyCard, currentUTCDateTime);
            }
            else
            {
                // Get sales Affilitions.
                retailSalesAffiliation = RetailLoyaltyManager::getSalesAffiliation(salesTable.SalesId);

                // Find the applying earning rules
                earnSchemeLineList = RetailLoyaltyManager::FindLoyaltyEarnSchemeLines(channel.OMOperatingUnitID, loyaltyCard.CardNumber, utcDate);

                ttsBegin;
                
                SalesLine salesOrReturnLine;
                Map alreadyInvoicedEarnedPointsSalesLines = new Map(Types::Real, Types::Real);
                // Find sales lines that have already earned points after invoicing
                if (retailSharedParameters.PostLoyaltyPointsPerSalesLine)
                {
                    while select salesOrReturnLine
                            where salesOrReturnLine.SalesId == salesTable.SalesId
                            && salesOrReturnLine.SalesType == SalesType::Sales
                            && salesOrReturnLine.SalesStatus == SalesStatus::Invoiced
                    {
                        if (salesTable.SalesType == SalesType::Sales && RetailLoyaltyCardRewardPointTrans::SalesLineHasRewardPoints(salesTable.SalesId, salesTable.DataAreaId, salesOrReturnLine.LineNum, RetailLoyaltyRewardPointEntryType::Earn))
                        {
                            alreadyInvoicedEarnedPointsSalesLines.insert(salesOrReturnLine.LineNum, salesOrReturnLine.LineNum);
                        }
                        else if (salesTable.SalesType == SalesType::ReturnItem && RetailLoyaltyCardRewardPointTrans::SalesLineHasRewardPoints(salesTable.SalesId, salesTable.DataAreaId, salesOrReturnLine.LineNum, RetailLoyaltyRewardPointEntryType::ReturnEarned))
                        {
                            alreadyInvoicedEarnedPointsSalesLines.insert(salesOrReturnLine.LineNum, salesOrReturnLine.LineNum);
                        }
                    }
                }

                // Get the last line number and increment it.
                lineNumber = RetailLoyaltyCardRewardPointTrans::lastLineNum(retailSalesTable.RetailChannel,retailSalesTable.RetailStoreId,retailSalesTable.RetailTerminalId,
                                                            salesTable.DataAreaId,salesTable.SalesId,loyaltyCard.CardNumber,'','','') + 1.0;

                earnSchemeLineListEnumerator = earnSchemeLineList.getEnumerator();
                while (earnSchemeLineListEnumerator.moveNext())
                {
                    // Generate and post the reward point trans
                    earnSchemeLine = earnSchemeLineListEnumerator.current();
                    Map salesLineNumberAndPoints;
                    boolean isEarnLineForValidScheme;

                    // check if earn line is valid earn line.
                    isEarnLineForValidScheme = RetailLoyaltyManager::validateForExcludedScheme(earnSchemeLine, salesTable.SalesId,channel.OMOperatingUnitID);

                    if (isEarnLineForValidScheme)
                    {
                        if (!retailSalesAffiliation && earnSchemeLine.RetailAffiliationId == 0)
                        {
                            salesLineNumberAndPoints = RetailLoyaltyManager::GenerateLoyaltyCardRewardPoints(
                            salesTable,
                            retailSalesTable,
                            earnSchemeLine,
                            loyaltyCard.CardNumber,
                            currentUTCDateTime,
                            entryType);
                        }
                        else
                        {
                            while select retailSalesAffiliation
                                  join retailAffiliation
                                     where retailSalesAffiliation.Affiliation == retailAffiliation.RecId
                                       && retailAffiliation.AffiliationType == RetailAffiliationType::General
                                       && retailSalesAffiliation.SalesId == salesTable.SalesId
                                       && (retailSalesAffiliation.Affiliation == earnSchemeLine.RetailAffiliationId || earnSchemeLine.RetailAffiliationId == 0)
                            {
                                salesLineNumberAndPoints = RetailLoyaltyManager::GenerateLoyaltyCardRewardPoints(
                                salesTable,
                                retailSalesTable,
                                earnSchemeLine,
                                loyaltyCard.CardNumber,
                                currentUTCDateTime,
                                entryType);
                            }
                        }
                    }

                    container packedMapContainer;

                    if (salesLineNumberAndPoints != null)
                    {
                        MapEnumerator enumerator = new MapEnumerator(salesLineNumberAndPoints);
                        while (enumerator.moveNext())
                        {
                            if (alreadyInvoicedEarnedPointsSalesLines.exists(enumerator.currentKey()))
                            {
                                //do nothing for already invoiced and lines that have earned or returned points
                            }
                            else if (enumerator.currentKey() == 0 && salesTable.SalesStatus != SalesStatus::Invoiced)
                            {
                                // Do not process header level unless order is invoiced
                            }
                            else
                            {
                                trans = RetailLoyaltyManager::GenerateLoyaltyCardRewardPointTrans(
                                enumerator.currentKey(), // Sales line number ('0' for transaction header level)
                                enumerator.currentValue(), // loyalty points
                                salesTable,
                                retailSalesTable,
                                earnSchemeLine,
                                loyaltyCard.CardNumber,
                                lineNumber,
                                currentUTCDateTime,
                                entryType);
                            }
                            
                            // Generate and post the reward point trans
                            if (trans.SalesId)
                            {
                                RetailLoyaltyManager::PostLoyaltyCardRewardPointTrans(trans);
                            }

                            lineNumber++;
                        }
                    }
                }
                ttsCommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyRewardPointsForReturnFromOriginalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the reward points to return from original sales order's earn points.
    /// </summary>
    /// <param name = "_salesTable">
    /// The sales table (return).
    /// </param>
    /// <param name = "_originSalesTable">
    /// The original sales table record for return.
    /// </param>
    /// <param name = "_retailSalesTable">
    /// The retail sales table.
    /// </param>
    /// <param name = "_loyaltyCard">
    /// The loyalty card.
    /// </param>
    /// <param name = "_utcDateTime">
    /// The UTC date time.
    /// </param>
    private static void copyRewardPointsForReturnFromOriginalTrans(
        SalesTable _salesTable,
        SalesTable _originSalesTable,
        RetailSalesTable _retailSalesTable,
        RetailLoyaltyCard _loyaltyCard,
        utcDateTime _utcDateTime)
    {
        SalesLine returnSalesLine, originSalesLine;
        RetailLoyaltyCardRewardPointTrans trans, originalEarnTrans;

        ttsBegin;
        LineNumber lineNumber = 1;
        
        while select originalEarnTrans
            where originalEarnTrans.LoyaltyTransactionType == RetailLoyaltyTransactionType::SalesOrder
                && originalEarnTrans.EntryType == RetailLoyaltyRewardPointEntryType::Earn
                && originalEarnTrans.SalesLineLineNum != 0
                && originalEarnTrans.loyaltyTransDataAreaId == _originSalesTable.dataAreaId
                && originalEarnTrans.SalesId == _originSalesTable.SalesId
            join originSalesLine
                where originSalesLine.SalesId == _originSalesTable.SalesId
                && originSalesLine.LineNum == originalEarnTrans.SalesLineLineNum
            join returnSalesLine
                where returnSalesLine.InventTransIdReturn == originSalesLine.InventTransId
                && returnSalesLine.InventTransIdReturn != ''
                && returnSalesLine.SalesId == _salesTable.SalesId
        {
            RetailLoyaltyRewardPointAmountQty  RewardPointAmountQty = originalEarnTrans.RewardPointAmountQty;

            int rewardPointAmountQtyDecimalPrecision = new SysDictType(extendedTypeNum(RetailLoyaltyRewardPointAmountQty)).effectivePrecision();

            if (RetailLoyaltyPointsCalculationCheckToggle::instance().isEnabled())
            {
                if (originSalesLine.SalesQty != 0 && returnSalesLine.SalesQty != originSalesLine.SalesQty)
                {
                    RewardPointAmountQty = abs(returnSalesLine.SalesQty * decRound(originalEarnTrans.RewardPointAmountQty / originSalesLine.SalesQty,
                    rewardPointAmountQtyDecimalPrecision));
                }
            }
            else
            {
                if (originSalesLine.QtyOrdered != 0 && returnSalesLine.QtyOrdered != originSalesLine.QtyOrdered)
                {
                    RewardPointAmountQty = abs(returnSalesLine.QtyOrdered * decRound(originalEarnTrans.RewardPointAmountQty / originSalesLine.QtyOrdered,
                    rewardPointAmountQtyDecimalPrecision));
                }
            }

            trans = RetailLoyaltyManager::GenerateLoyaltyCardRewardPointTransaction(returnSalesLine.LineNum,
                -1 * RewardPointAmountQty,
                _salesTable,
                _retailSalesTable,
                originalEarnTrans.RewardPoint,
                originalEarnTrans.Affiliation,
                originalEarnTrans.LoyaltyTier,
                _loyaltyCard.CardNumber,
                lineNumber,
                _utcDateTime,
                RetailLoyaltyRewardPointEntryType::ReturnEarned);

            // Generate and post the reward point trans
            if (trans.SalesId)
            {
                RetailLoyaltyManager::PostLoyaltyCardRewardPointTrans(trans);
            }

            lineNumber++;
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesAffiliation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the affiliations associated with sales.
    /// </summary>
    /// <param name="_salesId">
    /// The record identifier for sales transaction.
    /// </param>
    /// <returns>
    /// The found rules.
    /// </returns>
    public static RetailSalesAffiliation getSalesAffiliation(SalesId _salesId)
    {
        RetailSalesAffiliation salesAffiliation;
        RetailAffiliation retailAffiliation;

        select salesAffiliation
              join retailAffiliation
                    where salesAffiliation.Affiliation == retailAffiliation.RecId
                       && retailAffiliation.AffiliationType == RetailAffiliationType::General
                       && salesAffiliation.SalesId == _salesId;

        return salesAffiliation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForExcludedScheme</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate earn line against excluded scheme.
    /// </summary>
    /// <param name="_earnLine">
    /// The loyalty earn line.
    /// </param>
    /// <param name="_salesId">
    /// The record identifier for sales transaction.
    /// </param>
    /// <param name="_channelOU">
    /// The record identifier for channel operating unit.
    /// </param>
    /// <returns>
    /// true if it is a valid earn line; otherwise, false.
    /// </returns>
    private static boolean validateForExcludedScheme(RetailLoyaltyEarnSchemeLine _earnLine, SalesId _salesId, RefrecId _channelOU)
    {
        RetailLoyaltySchemeExcludedAffiliation excludedAffiliation;
        RetailLoyaltySchemeChannelExploded channelExploded;
        RetailSalesAffiliation salesAffiliation, salesWithoutAffiliation;
        RetailAffiliation affiliation;

        select excludedAffiliation
            join channelExploded
                where excludedAffiliation.LoyaltySchemeId == channelExploded.LoyaltyScheme
            join salesAffiliation
                where excludedAffiliation.RetailAffiliationId == salesAffiliation.Affiliation
                    && channelExploded.OMOperatingUnit == _channelOU
                    && salesAffiliation.SalesId == _salesId
                    && excludedAffiliation.LoyaltySchemeId == _earnLine.LoyaltyScheme;

        select salesWithoutAffiliation
            join affiliation
                where salesWithoutAffiliation.Affiliation == affiliation.RecId
                    && affiliation.AffiliationType == RetailAffiliationType::General
                    && salesAffiliation.SalesId == _salesId;
          
        Return (!excludedAffiliation || !salesWithoutAffiliation);
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostLoyaltyCardRewardPointTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts reward points to the <c>PostLoyaltyCardRewardPointTrans</c> table.
    /// </summary>
    /// <param name="_trans">
    /// Reward point line
    /// </param>
    /// <param name="_isUpgrade">
    /// Flag whill be true for upgrade
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    public static container PostLoyaltyCardRewardPointTrans(
        RetailLoyaltyCardRewardPointTrans _trans,
        boolean _isUpgrade = false)
    {
        boolean showInfolog = extendedParameters.parmPostLoyaltyCardRewardPointTrans_ShowInfolog();
        RetailLoyaltyManager::getDefaultExtendedParameters(); // reset extendedPrameters back to default.

        return RetailLoyaltyManager::PostLoyaltyCardRewardPointTransExt(_trans, _isUpgrade, showInfolog);
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostLoyaltyCardRewardPointTransExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts reward points to the <c>PostLoyaltyCardRewardPointTrans</c> table (Extended).
    /// </summary>
    /// <param name="_trans">Reward point line.</param>
    /// <param name="_isUpgrade">Flag whill be true for upgrade.</param>
    /// <param name = "_showInfolog">A Boolean value that indicates whether to print the errors or informational messages in the Infolog; optional.</param>
    /// <returns>A container having the result.</returns>
    private static container PostLoyaltyCardRewardPointTransExt(
        RetailLoyaltyCardRewardPointTrans _trans,
        boolean _isUpgrade = false,
        boolean _showInfolog = false)
    {
        RetailLoyaltyCardRewardPointTrans trans = _trans;
        boolean isSuccess, validateResult;
        str message, validationMessage;

        // Validate the card trans
        [validateResult, validationMessage] = RetailLoyaltyManager::ValidateLoyaltyCardRewardPointTrans(trans, _isUpgrade);

        // Try to set or deduct Remaining points, and insert the card trans
        if (validateResult)
        {
            try
            {
                ttsBegin;

                switch (trans.EntryType)
                {
                    case RetailLoyaltyRewardPointEntryType::Earn:
                        RetailLoyaltyManager::PostLoyaltyCardTransEarn(trans, _isUpgrade, _showInfolog);
                        break;

                    case RetailLoyaltyRewardPointEntryType::Redeem:
                        RetailLoyaltyManager::PostLoyaltyCardTransRedeem(trans, _isUpgrade);
                        break;

                    case RetailLoyaltyRewardPointEntryType::ReturnEarned:
                        RetailLoyaltyManager::PostLoyaltyCardTransReturnEarned(trans);
                        break;

                    case RetailLoyaltyRewardPointEntryType::Adjust:
                        RetailLoyaltyManager::PostLoyaltyCardTransAdjust(trans, _isUpgrade, _showInfolog);
                        break;

                    case RetailLoyaltyRewardPointEntryType::Refund:
                        RetailLoyaltyManager::PostLoyaltyCardTransRefund(trans);
                        break;

                    default:
                        trans.Remaining = 0;
                        trans.insert();
                }

                isSuccess = true;
                message = "";

                ttsCommit;
            }
            catch
            {
                ttsAbort;
                message = strFmt("@REX4160632", trans.loyaltyTransDataAreaId, trans.transactionId, trans.LoyaltyTransLineNum);
                eventSource.EventWriteFailedToPostTransactionLoyaltyPoints(trans.RecId);
                isSuccess = false;
            }
        }
        else
        {
            isSuccess = false;
            message = validationMessage;
        }

        return [isSuccess, message];
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostLoyaltyCardTransAdjust</Name>
				<Source><![CDATA[
    private static void PostLoyaltyCardTransAdjust(RetailLoyaltyCardRewardPointTrans _trans, boolean _isUpgrade = false, boolean _showInfolog = false)
    {
        RetailLoyaltyCardRewardPointTrans trans = _trans;
        RetailLoyaltyCardRewardPointTrans earnTrans;
        RetailLoyaltyRewardPointAmountQty remainingPoints;

        if (trans.RewardPointAmountQty == 0)
        {
            return;
        }

        // Any adjustment postings should be effective immediately and ignore the vesting period. Ensure the start date is set.
        trans.StartDate = trans.EntryDate;

        if (RetailSharedParameters::find(false).RetailLoyaltyAdjustmentLimitToMax)
        {
            RetailLoyaltyManager::LimitRewardPointAmountQtyByMaximumLoyaltyRewardPoints(trans, RetailLoyaltyRewardPoint::find(trans.RewardPoint, false), _showInfolog);
        }

        // Insert the card trans
        trans.Remaining = trans.RewardPointAmountQty;
        trans.insert();

        if (trans.RewardPointAmountQty > 0)
        {
            // When the adjustment point is positive:
            // Use the earned points of this trans to cover the negative balances of the previous trans, if any.
            remainingPoints = RetailLoyaltyManager::IncreaseNegativeRemainings(trans.RecId, trans.CardNumber, trans.RewardPoint, trans.RewardPointAmountQty);
        }
        else if (trans.RewardPointAmountQty < 0)
        {
            // When the adjustment point is negative:
            // Deduct points from the previous trans, if any.
            remainingPoints = RetailLoyaltyManager::DeductPositiveRemainings(trans.RecId, trans.EntryDate, trans.CardNumber, trans.RewardPoint, trans.RewardPointAmountQty);
        }

        // When remainingPoints is changed, update the remaining field.
        if (trans.Remaining != remainingPoints)
        {
            select firstonly forUpdate earnTrans where earnTrans.RecId == trans.RecId;
            earnTrans.Remaining = remainingPoints;
            earnTrans.update();
        }

        if (!_isUpgrade)
        {
            RetailLoyaltyManager::EvaluateLoyaltyCardTiers(trans.CardNumber, trans.EntryDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>LimitRewardPointAmountQtyByMaximumLoyaltyRewardPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensures that the reward point maximum limit is enforced on the RewardPointAmountQty in the transaction. 
    /// </summary>
    /// <param name = "_trans">The retail loyalty card reward point transaction.</param>
    /// <param name = "_rewardPoint">The loyalty reward point that contains the limit value to be checked.</param>
    /// <param name = "_showInfolog">A Boolean value that indicates whether to print the errors or informational messages in the Infolog; optional.</param>
    private static void LimitRewardPointAmountQtyByMaximumLoyaltyRewardPoints(RetailLoyaltyCardRewardPointTrans _trans, RetailLoyaltyRewardPoint _rewardPoint, boolean _showInfolog = false)
    {
        if (_rewardPoint && _rewardPoint.MaximumLoyaltyRewardPoints != 0)
        {
            //  consider clamping to maximum loyalty rewared points when it is defined (and NOT zero).
            RetailLoyaltyRewardPointAmountQty points = _trans.RewardPointAmountQty;

            if (points > 0)
            {
                // We will only consider clamping points to maximum when it is positive (e.g. Earn, or positive adjustment)
                RetailLoyaltyCard card = RetailLoyaltyCard::findByCardNumber(_trans.CardNumber);
                RetailLoyaltyRewardPointAmountQty remainingPoints, totalPoints, unvestedPoints, activePoints;

                date _calculateDate = DateTimeUtil::date(DateTimeUtil::utcNow());

                // Total active points
                activePoints = RetailLoyaltyCardRewardPointTrans::calcPoints(card,_rewardPoint.RecId,RetailLoyaltyPointStatusTypeBase::Active, _calculateDate);

                // Total unvested points
                unvestedPoints = RetailLoyaltyCardRewardPointTrans::calcPoints(card,_rewardPoint.RecId,RetailLoyaltyPointStatusTypeBase::Unvested, _calculateDate);

                // Total points (total unvestedPoints + total activePoints)
                totalPoints = activePoints + unvestedPoints;

                // Validate the threshold limit and update the reward points if needed
                if (totalPoints >= _rewardPoint.MaximumLoyaltyRewardPoints)
                {
                    // No point will earn if existing point >= Maximum limit point (and MaximumLoyaltyRewardPoints is not zero).
                    _trans.RewardPointAmountQty = 0;

                    if (_showInfolog)
                    {
                        Global::info(strFmt("@Retail:RetailLoyaltyRewardPointAmountQtyLimited", _trans.RewardPointAmountQty, _rewardPoint.MaximumLoyaltyRewardPoints));
                    }
                }
                else if ((totalPoints + points) >= _rewardPoint.MaximumLoyaltyRewardPoints)
                {
                    // Clamp the reward points so that the maximum limit is not exceeded  (and MaximumLoyaltyRewardPoints is not zero).
                    _trans.RewardPointAmountQty = (_rewardPoint.MaximumLoyaltyRewardPoints - totalPoints);

                    if (_showInfolog)
                    {
                        Global::info(strFmt("@Retail:RetailLoyaltyRewardPointAmountQtyLimited", _trans.RewardPointAmountQty, _rewardPoint.MaximumLoyaltyRewardPoints));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostLoyaltyCardTransEarn</Name>
				<Source><![CDATA[
    private static void PostLoyaltyCardTransEarn(RetailLoyaltyCardRewardPointTrans _trans, boolean _isUpgrade = false, boolean _showInfolog = false)
    {
        RetailLoyaltyCardRewardPointTrans trans = _trans;
        RetailLoyaltyCardRewardPointTrans earnTrans;
        RetailLoyaltyRewardPoint rewardPoint;
        RetailLoyaltyOtherActivityType otherActivityType;
        RetailLoyaltyCard retailLoyaltyCardBlocked;
        boolean ignoreVestingPeriod = false;

        // The earned points must be positive. This should be already validated by the caller.
        if (trans.RewardPointAmountQty <= 0)
        {
            return;
        }

        // Skip loyalty points transaction calculation if loyalty card TenderType is Blocked.
        select firstonly retailLoyaltyCardBlocked
             where retailLoyaltyCardBlocked.CardNumber == trans.CardNumber
             && retailLoyaltyCardBlocked.CardTenderType == RetailLoyaltyTenderTypeBase::Blocked;

        if (retailLoyaltyCardBlocked)
        {
            eventSource.EventWriteLoyaltyCardBlockedForEarnTransaction(retailLoyaltyCardBlocked.RecId);
            return;
        }

        //Check if the vesting period should be ignored for non-transactional activities
        if (_trans.LoyaltyOtherActivityTypeId)
        {
            select firstonly IgnoreVestingPeriod from otherActivityType
                where otherActivityType.RecId == _trans.LoyaltyOtherActivityTypeId;

            if (otherActivityType && otherActivityType.IgnoreVestingPeriod)
            {
                ignoreVestingPeriod = true;
            }
        }

        // Adjust start and expiration dates based on reward point vesting period
        rewardPoint = RetailLoyaltyRewardPoint::find(trans.RewardPoint);
        trans.StartDate = ignoreVestingPeriod ? trans.EntryDate : rewardPoint.addVestingPeriod(trans.EntryDate);
        trans.ExpirationDate = rewardPoint.expirationDate(trans.StartDate);

        RetailLoyaltyManager::LimitRewardPointAmountQtyByMaximumLoyaltyRewardPoints(trans, rewardPoint, _showInfolog);

        // Insert the card trans
        trans.Remaining = trans.RewardPointAmountQty;
        trans.insert();

        // Don't deduct negative points from unvested points.
        if (trans.StartDate <= DateTimeUtil::date(DateTimeUtil::utcNow()))
        {
            // Use the earned points of this trans to cover the negative balances of the previous trans, if any.
            RetailLoyaltyRewardPointAmountQty remainingPoints = RetailLoyaltyManager::IncreaseNegativeRemainings(trans.RecId, trans.CardNumber, trans.RewardPoint, trans.RewardPointAmountQty);

            // When some earned points are used to cover negative balances, update the remaining field.
            if (trans.Remaining != remainingPoints)
            {
                select firstonly forUpdate earnTrans where earnTrans.RecId == trans.RecId;
                earnTrans.Remaining = remainingPoints;
                earnTrans.update();
            }
        }

        if (!_isUpgrade)
        {
            RetailLoyaltyManager::EvaluateLoyaltyCardTiers(trans.CardNumber, trans.EntryDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostLoyaltyCardTransRedeem</Name>
				<Source><![CDATA[
    private static void PostLoyaltyCardTransRedeem(RetailLoyaltyCardRewardPointTrans _trans, boolean _isUpgrade = false)
    {
        RetailLoyaltyCardRewardPointTrans trans = _trans, earnedTrans, adjustmentTrans, redeemTrans;
        RetailLoyaltyRewardPointAmountQty redeemPoints, deductionPoints;
        RetailLoyaltyCardRewardPointDeduction deduction;
        RetailLoyaltyCardRewardPointAdjustment adjustment;
        RetailLoyaltyCard card, transCard;

        boolean isContactTender;
        DirPartyRecId partyRecId;
        utcDateTime now = DateTimeUtil::utcNow();

        // Key: card number, Value: reward point trans for redeeem.
        Map mapCardNumberRedeemTrans = new Map(Types::String, Types::Record);

        // The redeemed points must be negative. This should be already validated by the caller.
        if (trans.RewardPointAmountQty >= 0)
        {
            return;
        }

        // Deduct points from Remaining field.
        redeemPoints = trans.RewardPointAmountQty * -1;
        transCard = RetailLoyaltyCard::findByCardNumber(trans.CardNumber);
        isContactTender = (transCard.CardTenderType == RetailLoyaltyTenderTypeBase::AsContactTender) && transCard.Party;
        partyRecId = transCard.Party;

        // Find the earliest-expiring points, redeem from the earned trans by reducing the Remaining field.
        // Deduct points from multiple cards if the tendering card is ContactTender.
        while select forUpdate earnedTrans
            join card
            order by earnedTrans.ExpirationDate, earnedTrans.RecId
            where card.CardNumber == earnedTrans.CardNumber
                && earnedTrans.RewardPoint == trans.RewardPoint
                && ((_isUpgrade && earnedTrans.CardNumber == trans.CardNumber)
                    || (!_isUpgrade && card.CardTenderType != RetailLoyaltyTenderTypeBase::Blocked
                                    && ((!isContactTender && earnedTrans.CardNumber == trans.CardNumber)
                                         || (isContactTender && card.Party == partyRecId))))
                && (earnedTrans.ExpirationDate >= trans.EntryDate || !earnedTrans.ExpirationDate)
                && earnedTrans.Remaining > 0
            && (earnedTrans.StartDate <= trans.EntryDate)  // only vested points can be redeemed
        {
            if (earnedTrans.Remaining < redeemPoints)
            {
                // The found earned transaction does not have enough active points for redeem
                // Redeem all the points in the earned trans, and continue to find more points.
                deductionPoints = earnedTrans.Remaining;

                if (RetailLoyaltyRoundRedeemablePointsForPostingFlight::instance().isEnabled())
                {
                    real roundedRemainingEarnedPoints = RetailLoyaltyManager::RoundPointsByChannelCurrency(trans.Channel, earnedTrans.Remaining);
                    redeemPoints -= roundedRemainingEarnedPoints;
                }
                else
                {
                    redeemPoints -= deductionPoints;
                }

                earnedTrans.Remaining = 0;
            }
            else
            {
                // Enough points redeemed.
                deductionPoints = redeemPoints;
                earnedTrans.Remaining -= redeemPoints;
                redeemPoints = 0;
            }

            // Update the Remaining of the earned trans.
            earnedTrans.update();

            // Insert or update redeem trans
            // In case of contact tendering, there could be multiple redeem trans.
            if (!mapCardNumberRedeemTrans.exists(earnedTrans.CardNumber))
            {
                redeemTrans.initValue();
                redeemTrans.AdjustmentId = trans.AdjustmentId;
                redeemTrans.Affiliation = trans.Affiliation;
                redeemTrans.CardNumber = earnedTrans.CardNumber;
                redeemTrans.Channel = trans.Channel;
                redeemTrans.CustAccount = trans.CustAccount;
                redeemTrans.CustAccountDataAreaId = trans.CustAccountDataAreaId;
                redeemTrans.EntryDate = DateTimeUtil::date(now);
                redeemTrans.EntryTime = DateTimeUtil::time(now);
                redeemTrans.EntryType = trans.EntryType;
                redeemTrans.StartDate = redeemTrans.EntryDate;
                redeemTrans.ExpirationDate = trans.ExpirationDate;
                redeemTrans.LoyaltyTier = trans.LoyaltyTier;
                redeemTrans.LoyaltyTransactionType = trans.LoyaltyTransactionType;
                redeemTrans.loyaltyTransDataAreaId = trans.loyaltyTransDataAreaId;
                redeemTrans.LoyaltyTransLineNum = trans.LoyaltyTransLineNum;
                redeemTrans.ReceiptId = trans.ReceiptId;
                redeemTrans.Remaining = 0;
                redeemTrans.RewardPoint = trans.RewardPoint;
                redeemTrans.RewardPointAmountQty = deductionPoints * -1;
                redeemTrans.SalesId = trans.SalesId;
                redeemTrans.SalesLineLineNum = trans.SalesLineLineNum;
                redeemTrans.StaffId = trans.StaffId;
                redeemTrans.storeId = trans.storeId;
                redeemTrans.terminalId = trans.terminalId;
                redeemTrans.transactionId = trans.transactionId;
                redeemTrans.RetailTransactionSalesTransLineNum = trans.RetailTransactionSalesTransLineNum;
                redeemTrans.MCRPaymRecId = trans.MCRPaymRecId;
                redeemTrans.insert();

                mapCardNumberRedeemTrans.insert(earnedTrans.CardNumber, redeemTrans);
            }
            else
            {
                redeemTrans = mapCardNumberRedeemTrans.lookup(earnedTrans.CardNumber);

                redeemTrans.RewardPointAmountQty -= deductionPoints;
                redeemTrans.update();

                mapCardNumberRedeemTrans.insert(earnedTrans.CardNumber, redeemTrans);
            }

            // Insert deduction line.
            deduction.initValue();
            deduction.RewardPointSourceTrans = earnedTrans.RecId;
            deduction.RewardPointDeductTrans = redeemTrans.RecId;
            deduction.RewardPointAmountQty = deductionPoints;
            deduction.insert();

            if (redeemPoints == 0)
            {
                break;
            }
        }

        // Not enough points to redeem, abort the whole posting unless it's upgrade.
        if (redeemPoints > 0)
        {
            if (_isUpgrade)
            {
                // If no redeem trans has been created on the current trans loyalty card
                // possbibly due to no earned trans (remaining > 0), create the redeem trans first
                if (!mapCardNumberRedeemTrans.exists(transCard.CardNumber))
                {
                    trans.RewardPointAmountQty = redeemPoints * -1;
                    trans.Remaining = 0;
                    trans.insert();

                    redeemTrans = trans;
                }
                else
                {
                    redeemTrans = mapCardNumberRedeemTrans.lookup(transCard.CardNumber);

                    redeemTrans.RewardPointAmountQty -= redeemPoints;
                    redeemTrans.update();
                }

                // Create a positive adjustment
                adjustment.initValue();
                adjustment.AdjustmentId = RetailLoyaltyBackwardCompatibility::getNextAdjustmentId();
                adjustment.Affiliation = redeemTrans.Affiliation;
                adjustment.LoyaltyCard = transCard.RecId;
                adjustment.RewardPoint = redeemTrans.RewardPoint;
                adjustment.RewardPointAmountQty = redeemPoints;
                adjustment.insert();

                // Post adjustment trans
                adjustmentTrans.LoyaltyTransactionType = RetailLoyaltyTransactionType::LoyaltyAdjustment;
                adjustmentTrans.EntryType = RetailLoyaltyRewardPointEntryType::Adjust;
                adjustmentTrans.AdjustmentId = adjustment.AdjustmentId;
                adjustmentTrans.LoyaltyTransLineNum = 1.0;
                adjustmentTrans.Affiliation = adjustment.Affiliation;
                adjustmentTrans.CardNumber = redeemTrans.CardNumber;
                adjustmentTrans.RewardPoint = adjustment.RewardPoint;
                adjustmentTrans.RewardPointAmountQty = adjustment.RewardPointAmountQty;
                adjustmentTrans.EntryDate = DateTimeUtil::date(now);
                adjustmentTrans.EntryTime = DateTimeUtil::time(now);
                adjustmentTrans.StartDate = adjustmentTrans.EntryDate;
                adjustmentTrans.Remaining = 0;
                adjustmentTrans.ExpirationDate = RetailLoyaltyRewardPoint::find(adjustment.RewardPoint).expirationDate(DateTimeUtil::date(now));
                adjustmentTrans.insert();

                // Update adjustment status
                adjustment.AdjustmentStatus = RetailLoyaltyAdjustmentStatusBase::Posted;
                adjustment.update();

                // Insert deduction line.
                deduction.initValue();
                deduction.RewardPointSourceTrans = adjustmentTrans.RecId;
                deduction.RewardPointDeductTrans = redeemTrans.RecId;
                deduction.RewardPointAmountQty = redeemPoints;
                deduction.insert();
            }
            else
            {
                throw error("@REX4160782");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>RoundPointsByChannelCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds a provide loyalty point amount based on the rounding rules setup for a provided channel currency.
    /// </summary>
    /// <param name = "_channelRecId">The channel record identifier who's currency rounding rules should be used.</param>
    /// <param name = "_amount">The amount to be rounded.</param>
    /// <returns>The rounded amount.</returns>
    [Hookable(false)]
    internal static RetailLoyaltyRewardPointAmountQty RoundPointsByChannelCurrency(int64 _channelRecId, RetailLoyaltyRewardPointAmountQty _amount)
    {
        RetailLoyaltyRewardPointAmountQty result = _amount;

        // Skip rounding if channel details are missing or the amount to be rounded is zero.
        if (_channelRecId == 0 || _amount == 0)
        {
            return result;
        }

        // Retrieve the channel currency.
        str channelCurrency = RetailChannelTable::findByRecId(_channelRecId).Currency;

        Currency currency = Currency::find(channelCurrency);
        real roundingUnit = currency.RoundOffPrice == 0 ? 0.01 :currency.RoundOffPrice;
        int decimalsInRoundingUnit = RetailLoyaltyManager::GetNumberOfDecimals(roundingUnit);

        real decimalValue = _amount / roundingUnit;
        real difference = System.Math::Abs(decimalValue) - System.Math::Abs(System.Math::Truncate(_amount / roundingUnit));

        // Check if special rounding rules are required.
        if (difference > 0)
        {
            int sign = _amount > 0 ? -1 : 1;
            switch(currency.RoundOffTypePrice)
            {
                case RoundOffType::RoundDown:
                    result = System.Math::Round(System.Math::Round((_amount / roundingUnit) + sign * 0.5, 0) * roundingUnit, decimalsInRoundingUnit);
                    break;
                case RoundOffType::RoundUp:
                    result = System.Math::Round(System.Math::Round((_amount / roundingUnit) - sign * 0.5, 0) * roundingUnit, decimalsInRoundingUnit);
                    break;
                case RoundOffType::Ordinary:
                default:
                    // Round to nearest.
                    result = System.Math::Round(System.Math::Round(_amount / roundingUnit, 0, System.MidpointRounding::AwayFromZero) * roundingUnit,
                                                decimalsInRoundingUnit,
                                                System.MidpointRounding::AwayFromZero);
                    break;
            }
        }
        else if (difference == 0)
        {
            // for scenarios like value == 69.9900000000, the unit == 0.01 and the difference == 0.000000000
            result = System.Math::Round(_amount, decimalsInRoundingUnit);
        }


        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetNumberOfDecimals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of decimals in a provided real number.
    /// </summary>
    /// <param name = "_value">The real number for which the number of decimals should be counted.</param>
    /// <returns>The number of decimals ina the provided value.</returns>
    [Hookable(false)]
    internal static int GetNumberOfDecimals(real _value)
    {
        int result = 0;
        if (_value < 1)
        {
            while (_value != 0)
            {
                _value = (_value * 10) mod 1.0;
                result++;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostLoyaltyCardTransRefund</Name>
				<Source><![CDATA[
    private static void PostLoyaltyCardTransRefund(RetailLoyaltyCardRewardPointTrans _trans)
    {
        RetailLoyaltyCardRewardPointTrans trans = _trans;
        RetailLoyaltyCardRewardPointTrans refundTrans;
        RetailLoyaltyRewardPointAmountQty remainingPoints;

        // The earned points must be positive. This should be already validated by the caller.
        if (trans.RewardPointAmountQty <= 0)
        {
            return;
        }

        // Insert the card trans
        trans.Remaining = trans.RewardPointAmountQty;
        trans.StartDate = trans.EntryDate;

        if (RetailLoyaltyCardRewardPointTransSetExpirationDateFlight::instance().isEnabled() && trans.ExpirationDate == maxDate())
        {
            RetailLoyaltyRewardPoint rewardPoint = RetailLoyaltyRewardPoint::find(trans.RewardPoint);
            trans.ExpirationDate = rewardPoint.expirationDate(trans.EntryDate);
        }

        trans.insert();

        // Use the refund points of this trans to cover the negative balances of the previous trans, if any.
        remainingPoints = RetailLoyaltyManager::IncreaseNegativeRemainings(trans.RecId, trans.CardNumber, trans.RewardPoint, trans.RewardPointAmountQty);

        // When some refund points are used to cover negative balances, update the remaining field.
        if (trans.Remaining != remainingPoints)
        {
            select firstonly forUpdate refundTrans where refundTrans.RecId == trans.RecId;
            refundTrans.Remaining = remainingPoints;
            refundTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostLoyaltyCardTransReturnEarned</Name>
				<Source><![CDATA[
    private static void PostLoyaltyCardTransReturnEarned(
        RetailLoyaltyCardRewardPointTrans _trans)
    {
        RetailLoyaltyCardRewardPointTrans trans = _trans;
        RetailLoyaltyCardRewardPointTrans returnTrans;
        RetailLoyaltyRewardPointAmountQty returnPoints;

        // The returned points must be negative. This should be already validated by the caller.
        if (trans.RewardPointAmountQty >= 0)
        {
            return;
        }

        // Insert the card trans
        trans.Remaining = 0;
        trans.StartDate = trans.EntryDate;

        if (RetailLoyaltyCardRewardPointTransSetExpirationDateFlight::instance().isEnabled() && trans.ExpirationDate == maxDate())
        {
            RetailLoyaltyRewardPoint rewardPoint = RetailLoyaltyRewardPoint::find(trans.RewardPoint);
            trans.ExpirationDate = rewardPoint.expirationDate(trans.EntryDate);
        }

        trans.insert();

        // 1. Try to deduct points from active points of the current loyalty card.
        returnPoints = RetailLoyaltyManager::DeductPositiveRemainings(trans.RecId, trans.EntryDate, trans.CardNumber, trans.RewardPoint, trans.RewardPointAmountQty);

        // 2. If there is not enough points,
        // We reduct the Remaining points of the return trans line to negative numbers,
        // so that the point balance is still correct.
        if (returnPoints < 0)
        {
            select firstonly forUpdate returnTrans where returnTrans.RecId == trans.RecId;
            returnTrans.Remaining = returnPoints;
            returnTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>RoundRewardPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the reward points based on the given reward point.
    /// </summary>
    /// <param name="points">
    /// The number of points before rounding.
    /// </param>
    /// <param name="_rewardPoint">
    /// The reward point.
    /// </param>
    /// <returns>
    /// The rounding result.
    /// </returns>
    public static RetailLoyaltyRewardPointAmountQty RoundRewardPoints(real points, RetailLoyaltyRewardPoint _rewardPoint)
    {
        RetailLoyaltyRewardPointAmountQty roundedPoints;
        RoundOff roundingPrecision;

        switch (_rewardPoint.RewardPointType)
        {
            case RetailLoyaltyRewardPointType::Amount:

                // Rounding based on currency
                roundingPrecision = Currency::find(_rewardPoint.RewardPointCurrency).RoundingPrecision;
                roundedPoints = round(points, roundingPrecision);
                break;

            case RetailLoyaltyRewardPointType::Quantity:

                // Rounding by cutting the decimal points
                if (points > 0)
                {
                    roundedPoints = System.Math::Floor(points);
                }
                else
                {
                    roundedPoints = System.Math::Ceiling(points);
                }

                break;
        }

        return roundedPoints;
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateRetailSalesAffiliationForLoyalty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates records in RetailSalesAffiliation table with loyalty groups records.
    /// </summary>
    /// <param name="_salesId">
    /// Sales id.
    /// </param>
    /// <param name="_loyaltyCardRecid">
    /// The record ID of loyalty card.
    /// </param>
    public static void UpdateRetailSalesAffiliationForLoyalty(SalesId _salesId, RefRecId _loyaltyCardRecid)
    {
        ttsbegin;

        // Remove existing loyalty programs and tiers from the order
        RetailSalesAffiliation retailSalesAffiliation;
        RetailAffiliation retailAffilation;

        delete_from retailSalesAffiliation
            where retailSalesAffiliation.SalesId == _salesId
            exists join retailAffilation
            where retailAffilation.RecId == retailSalesAffiliation.Affiliation
                && retailAffilation.AffiliationType == RetailAffiliationType::Loyalty;

        // Find and insert new loyalty programs and tiers to the order
        RetailLoyaltyCard loyaltyCard = RetailLoyaltyCard::find(_loyaltyCardRecid);

        if (loyaltyCard)
        {
            List loyaltyCardTierList = RetailLoyaltyManager::FindMaxLoyaltyCardTiers(loyaltyCard.CardNumber, DateTimeUtil::Date(DateTimeUtil::utcNow()));
            ListEnumerator loyaltyCardTierListEnumerator = loyaltyCardTierList.getEnumerator();

            while (loyaltyCardTierListEnumerator.moveNext())
            {
                RetailLoyaltyCardTier cardTier = loyaltyCardTierListEnumerator.current();

                retailSalesAffiliation.initValue();
                retailSalesAffiliation.Affiliation = cardTier.Affiliation;
                retailSalesAffiliation.LoyaltyTier = cardTier.LoyaltyTier;
                retailSalesAffiliation.SalesId = _salesId;
                retailSalesAffiliation.insert();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoyaltyIssuedPoints62</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates issued default loyalty points.
    /// </summary>
    /// <param name="_transactionId">
    /// Transaction id.
    /// </param>
    /// <param name="_lineNum">
    /// Line number.
    /// </param>
    /// <param name="_storeId">
    /// Store id.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id.
    /// </param>
    /// <param name="_cardNumber">
    /// Card number.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    /// <param name="_dateSequence">
    /// Date sequence.
    /// </param>
    /// <param name="_issuedPoints">
    /// Issued points.
    /// </param>
    /// <param name="_receiptId">
    /// Receipt id.
    /// </param>
    /// <param name="_staffId">
    /// Staff id.
    /// </param>
    /// <param name="_time">
    /// Time.
    /// </param>
    /// <returns>
    /// Container with success flag, and message.
    /// </returns>
    /// <remarks>
    /// Obsolete.
    /// </remarks>

    public static container updateLoyaltyIssuedPoints62(RetailTransactionId    _transactionId,
                                                    LineNum             _lineNum,
                                                    RetailStoreId          _storeId,
                                                    RetailTerminalId       _terminalId,
                                                    RetailLoyaltyCardNumber _cardNumber,
                                                    str                 _transDate,
                                                    int                 _dateSequence,
                                                    RetailLoyaltyPoints    _issuedPoints,
                                                    RetailReceiptId        _receiptId = "",
                                                    RetailStaffId          _staffId = "",
                                                    str                 _time = "")
    {
        RetailLoyaltyCard card = RetailLoyaltyCard::findByCardNumber(_cardNumber);
        RetailLoyaltyCardRewardPointTrans trans;
        RetailLoyaltySchemeBackwardCompatibility schemeMapping;
        RetailLoyaltyRewardPoint rewardPoint;

        boolean success = false;
        str message = '';
        container   ret;
        RetailStoreTable store = RetailStoreTable::find(_storeId);

        if (card)
        {
            if (card.CardTenderType == RetailLoyaltyTenderTypeBase::Blocked)
            {
                ret = [false,"@RET4466"];
            }
            else
            {
                schemeMapping = RetailLoyaltySchemeBackwardCompatibility::findByLoyaltyCard(card.recId);
                rewardPoint = RetailLoyaltyRewardPoint::find(schemeMapping.RewardPoint);

                trans.RewardPoint = schemeMapping.RewardPoint;
                trans.Affiliation = schemeMapping.LoyaltyGroup;
                trans.CardNumber = _cardNumber;
                trans.CustAccount = CustTable::findByPartyRecId(card.Party).AccountNum;
                trans.CustAccountDataAreaId = store.inventLocationDataAreaId;
                trans.EntryDate = str2Date(_transDate, _dateSequence);
                trans.EntryTime = str2time(_time);
                if (_issuedPoints >= 0)
                {
                    trans.EntryType = RetailLoyaltyRewardPointEntryType::Earn;
                    trans.ExpirationDate = rewardPoint.expirationDate(trans.EntryDate);
                }
                else
                {
                    trans.EntryType = RetailLoyaltyRewardPointEntryType::ReturnEarned;
                }
                trans.loyaltyTransDataAreaId = store.inventLocationDataAreaId;
                trans.LoyaltyTransLineNum = _lineNum;
                trans.ReceiptId = _receiptId;
                trans.RewardPointAmountQty = _issuedPoints;
                trans.StaffId = _staffId;
                trans.storeId = _storeId;
                trans.Channel = store.RecId;
                trans.terminalId = _terminalId;
                trans.transactionId = _transactionId;
                trans.LoyaltyTransactionType = RetailLoyaltyTransactionType::RetailTransaction;

                [success, message] = RetailLoyaltyManager::PostLoyaltyCardRewardPointTrans(trans, false);

                if (success)
                {
                    ret = [true,"@RET4690"];
                }
                else
                {
                    ret = [success, message];
                }
            }
        }
        else
        {
            ret = [false,"@RET4467"];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoyaltyUsedPoints62</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates used default loyalty points.
    /// </summary>
    /// <param name="_transactionId">
    /// Transaction id.
    /// </param>
    /// <param name="_lineNum">
    /// Line number.
    /// </param>
    /// <param name="_storeId">
    /// Store id.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id.
    /// </param>
    /// <param name="_cardNumber">
    /// Card number.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    /// <param name="_dateSequence">
    /// Date sequence.
    /// </param>
    /// <param name="_usedPoints">
    /// Used point amount.
    /// </param>
    /// <param name="_receiptId">
    /// Receipt id.
    /// </param>
    /// <param name="_staffId">
    /// Staff id.
    /// </param>
    /// <param name="_time">
    /// Time.
    /// </param>
    /// <returns>
    /// Container with success flag, and message.
    /// </returns>
    /// <remarks>
    /// Obsolete.
    /// </remarks>

    public static container updateLoyaltyUsedPoints62(RetailTransactionId    _transactionId,
                                                    LineNum             _lineNum,
                                                    RetailStoreId          _storeId,
                                                    RetailTerminalId       _terminalId,
                                                    RetailLoyaltyCardNumber _cardNumber,
                                                    str                 _transDate,
                                                    int                 _dateSequence,
                                                    RetailLoyaltyPoints    _usedPoints,
                                                    RetailReceiptId        _receiptId = "",
                                                    RetailStaffId          _staffId = "",
                                                    str                 _time = "")
    {
        RetailLoyaltyCard card = RetailLoyaltyCard::findByCardNumber(_cardNumber);
        RetailLoyaltySchemeBackwardCompatibility schemeMapping;
        RetailLoyaltyCardRewardPointTrans trans;
        RetailLoyaltyRewardPoint rewardPoint;

        boolean success = false;
        str message = '';
        container ret;
        RetailStoreTable store = RetailStoreTable::find(_storeId);

        if (card)
        {
            if (card.CardTenderType == RetailLoyaltyTenderTypeBase::Blocked)
            {
                ret = [false,"@RET4466"];
            }
            else if (card.CardTenderType == RetailLoyaltyTenderTypeBase::NoTender)
            {
                ret = [false,"@RET4473"];
            }
            else
            {
                schemeMapping = RetailLoyaltySchemeBackwardCompatibility::findByLoyaltyCard(card.recId);
                rewardPoint = RetailLoyaltyRewardPoint::find(schemeMapping.RewardPoint);

                trans.RewardPoint = schemeMapping.RewardPoint;
                trans.Affiliation = schemeMapping.LoyaltyGroup;
                trans.CardNumber = _cardNumber;
                trans.CustAccount = CustTable::findByPartyRecId(card.Party).AccountNum;
                trans.CustAccountDataAreaId = store.inventLocationDataAreaId;
                trans.Channel = store.RecId;
                trans.EntryDate = str2Date(_transDate, _dateSequence);
                trans.EntryTime = str2time(_time);
                if (_usedPoints >= 0)
                {
                    trans.EntryType = RetailLoyaltyRewardPointEntryType::Refund;
                    trans.ExpirationDate = rewardPoint.expirationDate(trans.EntryDate);
                }
                else
                {
                    trans.EntryType = RetailLoyaltyRewardPointEntryType::Redeem;
                }
                trans.loyaltyTransDataAreaId = store.inventLocationDataAreaId;
                trans.LoyaltyTransLineNum = _lineNum;
                trans.ReceiptId = _receiptId;
                trans.RewardPointAmountQty = _usedPoints;
                trans.StaffId = _staffId;
                trans.storeId = _storeId;
                trans.Channel = store.RecId;
                trans.terminalId = _terminalId;
                trans.transactionId = _transactionId;
                trans.LoyaltyTransactionType = RetailLoyaltyTransactionType::RetailTransaction;

                [success, message] = RetailLoyaltyManager::PostLoyaltyCardRewardPointTrans(trans, false);
                if (success)
                {
                    ret = [true,"@RET4690"];
                }
                else
                {
                    ret = [success, message];
                }
            }
        }
        else
        {
            ret = [false,"@RET4467"];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ValidateLoyaltyCardRewardPointTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a loyalty card transaction.
    /// </summary>
    /// <param name="_trans">
    /// A loyalty reward points transaction.
    /// </param>
    /// <param name="_isUpgrade">
    /// Flag whill be true for upgrade
    /// </param>
    /// <returns>
    /// A container with the result of the validation and the related message.
    /// </returns>
    public static container ValidateLoyaltyCardRewardPointTrans(RetailLoyaltyCardRewardPointTrans _trans, boolean _isUpgrade = false)
    {
        boolean validateResult = true;
        str validationMessage = '';
        str loyaltySourceId;

        // Validate transaction type
        switch (_trans.LoyaltyTransactionType)
        {
            case RetailLoyaltyTransactionType::RetailTransaction:
                if (!_trans.transactionId && !_isUpgrade)
                {
                    validateResult = false;
                    validationMessage = "@REX4520386";
                    eventSource.EventWriteFailedToValidateLoyaltyCardRewardPointTrans('Failed post reward point line for the transaction, because the transaction ID is missing', _trans.RecId);
                }
                else
                {
                    loyaltySourceId = _trans.transactionId;
                }
                break;

            case RetailLoyaltyTransactionType::SalesOrder:
                if (!_trans.SalesId)
                {
                    validateResult = false;
                    validationMessage = "@REX4520388";
                    eventSource.EventWriteFailedToValidateLoyaltyCardRewardPointTrans('Failed post reward point line for the transaction, because the sales ID is missing', _trans.RecId);
                }
                else
                {
                    loyaltySourceId = _trans.SalesId;
                }
                break;

            case RetailLoyaltyTransactionType::LoyaltyAdjustment:
                if (!_trans.AdjustmentId)
                {
                    validateResult = false;
                    validationMessage = "@REX4520389";
                    eventSource.EventWriteFailedToValidateLoyaltyCardRewardPointTrans('Failed post reward point line for the transaction, because the adjustment ID is missing', _trans.RecId);
                }
                else
                {
                    loyaltySourceId = _trans.SalesId;
                }
                break;

            case RetailLoyaltyTransactionType::NonTransactionalActivity:
                if (!_trans.NonTransactionalActivityId)
                {
                    validateResult = false;
                    validationMessage = "@Retail:NonTransactionalActivityErrorMessage";
                    eventSource.EventWriteFailedToValidateLoyaltyCardRewardPointTrans('Failed post reward point line for the transaction, because the NonTransactionalActivity ID is missing', _trans.RecId);
                }
                else
                {
                    loyaltySourceId = _trans.NonTransactionalActivityId;
                }
                break;

            default:
                validateResult = false;
                validationMessage = strFmt("@REX4520390", _trans.LoyaltyTransactionType);
                eventSource.EventWriteFailedToValidateLoyaltyCardRewardPointTrans(strFmt('The loyalty transaction type is not supported', _trans.LoyaltyTransactionType), _trans.RecId);
                break;
        }

        if (validateResult)
        {
            switch (_trans.EntryType)
            {
                case RetailLoyaltyRewardPointEntryType::Earn:
                    if (_trans.RewardPointAmountQty < 0)
                    {
                        validateResult = false;
                        validationMessage = strFmt("@REX4520023",
                                                    _trans.loyaltyTransDataAreaId,
                                                    loyaltySourceId,
                                                    _trans.LoyaltyTransLineNum);
                        eventSource.EventWriteFailedToValidateLoyaltyCardRewardPointTrans('Failed post reward point line for the transaction, earned points cannot be negative', _trans.RecId);
                    }
                    break;

                case RetailLoyaltyRewardPointEntryType::Redeem:
                    if (_trans.RewardPointAmountQty > 0)
                    {
                        validateResult = false;
                        validationMessage = strFmt("@REX4520024",
                                                    _trans.loyaltyTransDataAreaId,
                                                    loyaltySourceId,
                                                    _trans.LoyaltyTransLineNum);
                        eventSource.EventWriteFailedToValidateLoyaltyCardRewardPointTrans('Failed post reward point line for the transaction, redeemed points cannot be positive', _trans.RecId);
                    }
                    break;

                case RetailLoyaltyRewardPointEntryType::ReturnEarned:
                    if (_trans.RewardPointAmountQty > 0)
                    {
                        validateResult = false;
                        validationMessage = strFmt("@REX4520018",
                                                    _trans.loyaltyTransDataAreaId,
                                                    loyaltySourceId,
                                                    _trans.LoyaltyTransLineNum);
                        eventSource.EventWriteFailedToValidateLoyaltyCardRewardPointTrans('Failed post reward point line for the transaction, deducted points based on product return cannot be positive', _trans.RecId);
                    }
                    break;

                case RetailLoyaltyRewardPointEntryType::Adjust:
                    // Adjust can be either positive or negative.
                    break;

                case RetailLoyaltyRewardPointEntryType::Refund:
                    if (_trans.RewardPointAmountQty < 0)
                    {
                        validateResult = false;
                        validationMessage = strFmt("@REX4520333",
                                                    _trans.loyaltyTransDataAreaId,
                                                    loyaltySourceId,
                                                    _trans.LoyaltyTransLineNum);
                        eventSource.EventWriteFailedToValidateLoyaltyCardRewardPointTrans('Failed post reward point line for the transaction, refund points cannot be negative.', _trans.RecId);
                    }
                    break;

                default:
                // Nothing here
            }
        }

        // Check recid
        if (validateResult && _trans.RecId)
        {
            validateResult = false;
            validationMessage = strFmt("@REX4520391",
                                        _trans.loyaltyTransDataAreaId,
                                        _trans.transactionId,
                                        _trans.LoyaltyTransLineNum);
            eventSource.EventWriteFailedToValidateLoyaltyCardRewardPointTrans('Failed post reward point line for the transaction, transaction record is already inserted.', _trans.RecId);
        }

        return [validateResult, validationMessage];
    }

]]></Source>
			</Method>
			<Method>
				<Name>FillLoyaltyRewardPointLinesForXmlWithRetailTransactionSalesTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LoyaltyRewardPointLines to the xml document for RetailTransactionTable
    /// </summary>
    /// <param name = "transactionTable">target RetailTransactionTable</param>
    /// <param name = "xmldoc">target xmldoc</param>
    /// <returns>
    /// XML serialized string of the <c>LoyaltyRewardPointLines</c> table.
    /// * Members must be in order of the LoyaltyRewardPointLines DataContract
    /// Example:
    ///    <LoyaltyRewardPointLines>
    ///      <LoyaltyRewardPointLine>
    ///        <CustomerAccount />
    ///        <EntryDate />
    ///        <EntryTime />
    ///        <EntryTypeValue />
    ///        <ExpirationDate />
    ///        <LineNumber />
    ///        <LoyaltyCardNumber />
    ///        <LoyaltyGroupRecordId />
    ///        <LoyaltyTierRecordId />
    ///        <RewardPointAmountQuantity />
    ///        <RewardPointCurrency />
    ///        <RewardPointId />
    ///        <RewardPointIsRedeemable />
    ///        <RewardPointRecordId />
    ///        <RewardPointType />
    ///        <SalesId />
    ///        <StartDate />
    ///        <TransactionId />
    ///      </LoyaltyRewardPointLine>
    ///    </LoyaltyRewardPointLines>
    /// </returns>
    public static XmlElement FillLoyaltyRewardPointLinesForXmlWithRetailTransactionSalesTrans(RetailTransactionTable transactionTable, XmlDocument xmldoc)
    {
        return RetailLoyaltyManager::FillLoyaltyRewardPointTransLinesForXml(transactionTable.transactionId, xmldoc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>FillLoyaltyRewardPointLinesForXmlWithRetailTransactionSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LoyaltyRewardPointLines to the xml document for RetailTransactionSalesTrans
    /// </summary>
    /// <param name = "transactionTable">target RetailTransactionSalesTrans</param>
    /// <param name = "xmldoc">target xmldoc</param>
    /// <returns>
    /// XML serialized string of the <c>LoyaltyRewardPointLines</c> table.
    /// * Members must be in order of the LoyaltyRewardPointLines DataContract
    /// Example:
    ///    <LoyaltyRewardPointLines>
    ///      <LoyaltyRewardPointLine>
    ///        <CustomerAccount />
    ///        <EntryDate />
    ///        <EntryTime />
    ///        <EntryTypeValue />
    ///        <ExpirationDate />
    ///        <LineNumber />
    ///        <LoyaltyCardNumber />
    ///        <LoyaltyGroupRecordId />
    ///        <LoyaltyTierRecordId />
    ///        <RewardPointAmountQuantity />
    ///        <RewardPointCurrency />
    ///        <RewardPointId />
    ///        <RewardPointIsRedeemable />
    ///        <RewardPointRecordId />
    ///        <RewardPointType />
    ///        <SalesId />
    ///        <StartDate />
    ///        <TransactionId />
    ///      </LoyaltyRewardPointLine>
    ///    </LoyaltyRewardPointLines>
    /// </returns>
    public static XmlElement FillLoyaltyRewardPointLinesForXmlWithRetailTransactionSalesLine(RetailTransactionSalesTrans transactionTable, XmlDocument xmldoc)
    {
        return RetailLoyaltyManager::FillLoyaltyRewardPointTransLinesForXml(transactionTable.transactionId, xmldoc, transactionTable.lineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>FillLoyaltyRewardPointLinesForXmlWithSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LoyaltyRewardPointLines to the xml document for SalesTable
    /// </summary>
    /// <param name = "salesTable">target SalesTable</param>
    /// <param name = "xmldoc">target xmldoc</param>
    /// <returns>returns the generated LoyaltyRewardPointLines XmlElement</returns>
    public static XmlElement FillLoyaltyRewardPointLinesForXmlWithSalesTable(SalesTable salesTable, XmlDocument xmldoc)
    {
        return RetailLoyaltyManager::FillLoyaltyRewardPointTransLinesForXml(salesTable.SalesId, xmldoc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>FillLoyaltyRewardPointTransLinesForXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add LoyaltyRewardPointLines to the xml document for salesId or transactionId
    /// </summary>
    /// <param name = "transactionIdOrSalesId">target salesId or transactionId</param>
    /// <param name = "xmldoc">target xmldoc</param>
    /// <param name = "salesLineNumber">target salesLineNumber</param>
    /// <returns>returns the generated LoyaltyRewardPointLines XmlElement</returns>
    public static XmlElement FillLoyaltyRewardPointTransLinesForXml(str transactionIdOrSalesId, XmlDocument xmldoc, LineNum salesLineNumber = 0)
    {
        RetailLoyaltyCardRewardPointTrans   loyaltyRewardPoint;
        RetailLoyaltyRewardPoint            rewardPoint;
        str                                 error = '';
        boolean                             success = false;
        Counter                             infologline    = infolog.num();
        XmlElement                          xmlArrayOfLoyaltyRewardPointLine,xmlRecord,xmlSubElement;
        int                                 fromLine;

        try
        {
            fromLine = Global::infologLine();

            xmlArrayOfLoyaltyRewardPointLine = xmldoc.createElement('LoyaltyRewardPointLines');

            // query loyaltyRewardPoint with transactionId or salesId.
            while select loyaltyRewardPoint where (loyaltyRewardPoint.transactionId != '' && loyaltyRewardPoint.transactionId == transactionIdOrSalesId
                    && loyaltyRewardPoint.RetailTransactionSalesTransLineNum == salesLineNumber)
                || (loyaltyRewardPoint.SalesId != '' && loyaltyRewardPoint.SalesId == transactionIdOrSalesId
                && loyaltyRewardPoint.SalesLineLineNum == salesLineNumber)
            {
                select rewardPoint
                    where rewardPoint.RecId == loyaltyRewardPoint.RewardPoint;

                xmlRecord = xmldoc.createElement('LoyaltyRewardPointLine');

                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'CustomerAccount', loyaltyRewardPoint.CUSTACCOUNT);

                xmlSubElement = xmlDoc.createElement('EntryDate');
                xmlSubElement.setAttribute(RetailTransactionServiceTransactions::dateTimeOffsetXmlNsKey, RetailTransactionServiceTransactions::dateTimeOffsetXmlNsValue);
                xmlSubElement.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(loyaltyRewardPoint.ENTRYDATE));
                xmlRecord.appendChild(xmlSubElement);

                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'EntryTime', int642str(loyaltyRewardPoint.ENTRYTIME));
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'EntryTypeValue', int642str(enum2int(loyaltyRewardPoint.ENTRYTYPE)));

                xmlSubElement = xmlDoc.createElement('ExpirationDate');

                // If expiration date is not empty.
                if (loyaltyRewardPoint.EXPIRATIONDATE)
                {
                    xmlSubElement.setAttribute(RetailTransactionServiceTransactions::dateTimeOffsetXmlNsKey, RetailTransactionServiceTransactions::dateTimeOffsetXmlNsValue);
                    xmlSubElement.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(loyaltyRewardPoint.EXPIRATIONDATE));
                }
                else
                {
                    xmlSubElement.setAttribute(RetailTransactionServiceTransactions::schemaInstanceNSKey, RetailTransactionServiceTransactions::schemaInstanceNSUrl);
                    xmlSubElement.setAttribute2("nil", RetailTransactionServiceTransactions::schemaInstanceNSUrl, "true");
                }

                xmlRecord.appendChild(xmlSubElement);

                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'LineNumber', num2str(loyaltyRewardPoint.LOYALTYTRANSLINENUM,5,3,1,0));
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'LoyaltyCardNumber', loyaltyRewardPoint.CARDNUMBER);
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'LoyaltyGroupRecordId', int642str(loyaltyRewardPoint.AFFILIATION));
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'LoyaltyTierRecordId', int642str(loyaltyRewardPoint.LOYALTYTIER));
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'RewardPointAmountQuantity', num2str(loyaltyRewardPoint.REWARDPOINTAMOUNTQTY,5,3,1,0));
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'RewardPointCurrency', rewardPoint.REWARDPOINTCURRENCY);
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'RewardPointId', rewardPoint.REWARDPOINTID);
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'RewardPointIsRedeemable', int642str(enum2int(rewardPoint.REDEEMABLE)));
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'RewardPointRecordId', int642str(loyaltyRewardPoint.REWARDPOINT));
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'RewardPointType', enum2Symbol(enumNum(RetailLoyaltyRewardPointType),rewardPoint.REWARDPOINTTYPE));
                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'SalesId', loyaltyRewardPoint.SalesId);

                xmlSubElement = xmlDoc.createElement('StartDate');
                xmlSubElement.setAttribute(RetailTransactionServiceTransactions::dateTimeOffsetXmlNsKey, RetailTransactionServiceTransactions::dateTimeOffsetXmlNsValue);
                xmlSubElement.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(loyaltyRewardPoint.StartDate));
                xmlRecord.appendChild(xmlSubElement);

                RetailLoyaltyManager::createSubXmlElementLoyaltyRewardPointLines(xmldoc, xmlRecord, 'TransactionId', loyaltyRewardPoint.TRANSACTIONID);

                xmlArrayOfLoyaltyRewardPointLine.appendChild(xmlRecord);
            }
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWriteGeneralExceptionOnMethod(funcName(), error);
        }

        return xmlArrayOfLoyaltyRewardPointLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubXmlElementLoyaltyRewardPointLines</Name>
				<Source><![CDATA[
    private static void createSubXmlElementLoyaltyRewardPointLines(XmlDocument xmldoc, XmlElement xmlRecord, str elementName, str value)
    {
        XmlElement xmlSubElement;
        xmlSubElement = xmldoc.createElement(elementName);
        xmlSubElement.innerText(value);
        xmlRecord.appendChild(xmlSubElement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateAndPostRewardPointsForPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate reward point transactions from the given sales order, and post them.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order to evaluate.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number to generate points from.
    /// </param>
    /// <param name="_paymentAmount">
    /// The amount of payment that the points need to satisfy.
    /// </param>
    /// <remarks>
    /// This method uses the sales order to find applicable reward point schemes that can be used to pay for items on the order,
    /// then attempts to determine if there are enough points available to satisfy the requested payment amount.
    /// If enough points are found, then the resulting redeem-point transactions are posted and the card's point balance is updated.
    /// </remarks>
    public static void GenerateAndPostRewardPointsForPayment(
        SalesTable _salesTable,
        RetailLoyaltyCardNumber _cardNumber,
        real _paymentAmount)
    {
        boolean authorized;
        container packedRewardPointLinesContainer;

        [authorized, packedRewardPointLinesContainer] = RetailLoyaltyManager::AuthorizeRewardPointsForPayment(_salesTable, _cardNumber, _paymentAmount);

        // If not authrized, throw an error.
        if (!authorized)
        {
            eventSource.EventWriteAuthorizationFailedForRewardPointsForPayment(funcName());

            // The loyalty payment amount exceeds what is allowed for this loyalty card in this transaction.
            throw error("@Retail:PaymentExceedsLoyaltyCardBalance");
        }

        List redeemPoints = List::create(packedRewardPointLinesContainer);
       
        // If no reward lines then throw an error.
        if (redeemPoints.elements() <= 0)
        {
            eventSource.EventWriteNoRewardLinesForTransaction(funcName());

            // No points available that can be used to pay for the items in this transaction.
            throw error("@Retail:NoLoyaltyPointsAvailable");
        }
        else // Post the RedeemPointsTrans records
        {
            RetailLoyaltyCardRewardPointTrans retailLoyaltyCardRewardPointTrans;
            boolean isSuccess;
            str message;
            ListEnumerator enumerator = redeemPoints.getEnumerator();
            
            MCRCustPaymTableRecID paymRecId = extendedParameters.parmMCRPaymRecId();

            while (enumerator.moveNext())
            {
                retailLoyaltyCardRewardPointTrans = enumerator.current();

                retailLoyaltyCardRewardPointTrans.MCRPaymRecId = paymRecId;

                [isSuccess, message] = RetailLoyaltyManager::PostLoyaltyCardRewardPointTrans(retailLoyaltyCardRewardPointTrans);

                if(!isSuccess)
                {
                    eventSource.EventWriteFailureForPostRedeemPointsTransRecords(funcName());

                    // Throw an exception using the LoyaltyCardRewardPointTrans failure message.
                    throw error(message);
                }

                eventSource.EventWritePostRedeemPointsTransRecords(funcName(), retailLoyaltyCardRewardPointTrans.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateAndPostRewardPointsForRemovedPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate full refund reward points for a removed or deleted payment from a sales order, and post them.
    /// </summary>
    /// <param name = "_salesTable">
    /// The sales order to evaluate.
    /// </param>
    /// <param name = "_cardNumber">
    /// The card number to refund points to.
    /// </param>
    /// <remarks>
    /// This method uses the sales order to refund all reward points that were redeemed for a payment.
    /// </remarks>
    [Hookable(false)]
    internal static void GenerateAndPostRewardPointsForRemovedPayment(
        SalesTable _salesTable,
        RetailLoyaltyCardNumber _cardNumber)
    {
        boolean authorized;
        container packedRefundPointLinesContainer;

        [authorized, packedRefundPointLinesContainer] = RetailLoyaltyManager::AuthorizeRewardPointsForRemovedPayment(_salesTable, _cardNumber);
        
        if (!authorized)
        {
            // Refund point line was unable to be generated.
            throw error("@Retail:LoyaltyCardRefundInvalid");
        }
        else
        {
            List refundPoints = List::create(packedRefundPointLinesContainer);
            boolean isSuccess;
            str message;
            RetailLoyaltyCardRewardPointTrans refundTrans;
            ListEnumerator enumerator = refundPoints.getEnumerator();

            while(enumerator.moveNext())
            {    
                refundTrans = enumerator.current();

                [isSuccess, message] = RetailLoyaltyManager::PostLoyaltyCardRewardPointTrans(refundTrans);

                if (!isSuccess)
                {
                    // Throw an exception using the LoyaltyCardRewardPointTrans failure message.
                    throw error(message);
                }

                eventSource.EventWriteLoyaltyPaymentSalesOrderRemovedAndRefunded(refundTrans.SalesId, refundTrans.RecId, refundTrans.MCRPaymRecId, refundTrans.SalesLineLineNum);
            }  
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>AmountCoveredByLoyaltyPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns amount covered by loyalty points for a sales odrer given a card number and payment amount.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order to evaluate.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number to generate points from.
    /// </param>
    /// <param name="_paymentAmount">
    /// The amount of payment that the points need to satisfy.
    /// </param>
    /// <returns>The amount of payment that loyalty points will be able to cover.</returns>
    public static AmountCur AmountCoveredByLoyaltyPoints(
        SalesTable _salesTable,
        RetailLoyaltyCardNumber _cardNumber,
        AmountCur _paymentAmount
        )
    {
        // Validate sales table record.
        if (!SalesTable::find(_salesTable.SalesId).RecId)
        {
            return 0;
        }

        // Validate loyalty card.
        RetailLoyaltyManager::ValidateLoyaltyCard(_cardNumber);

        List rewardPoints = new List(Types::Record);
        real remainingPaymentAmount;

        // Redeem
        if (_paymentAmount > 0)
        {
            remainingPaymentAmount = RetailLoyaltyManager::FillInLoyaltyRewardPointLinesForPayment(
                _salesTable,
                _cardNumber,
                _paymentAmount,
                rewardPoints);
        }

        return remainingPaymentAmount == 0 ? _paymentamount: _paymentAmount - remainingPaymentAmount;
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>AuthorizeRewardPointsForRefundForSalesline</Name>
				<Source><![CDATA[
    /// <summary>
    /// Authorize loyalty the redemption of rewards points for sales order/call center payment.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales table to attempt to authorize redemption of points against.
    /// </param>
    /// <param name="_salesline">
    /// The sales line which should be used for calculating the refund points.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card to be used.
    /// </param>
    /// <param name="_paymentAmount">
    /// The amount of payment to authorize.
    /// </param>
    /// <returns>
    /// True if the requested amount of payment could be satisfied by reward points; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method uses the sales line to find applicable reward point schemes that can be used to proces refund for a particular sales line,
    /// then attempts to determine if there are enough points available to satisfy the requested payment amount.  No points are posted/reserved as part of this authorization.
    /// </remarks>
    public static container AuthorizeRewardPointsForRefundForSalesline(
        SalesTable _salesTable,
        SalesLine _salesline,
        RetailLoyaltyCardNumber _cardNumber,
        AmountCur _paymentAmount)
    {
        MCRCustPaymTable mcrCustPaymTable;
        boolean authorized = false;

        // Validate sales table record.
        if (!SalesTable::find(_salesTable.SalesId).RecId)
        {
            return [authorized, null];
        }

        // Validate loyalty card.
        RetailLoyaltyManager::ValidateLoyaltyCard(_cardNumber);

        List rewardPoints = new List(Types::Record);
        real remainingPaymentAmount;

        if (_paymentAmount >= 0)
        {
            return [authorized, null];
        }
        else // Refund
        {
            remainingPaymentAmount = RetailLoyaltyManager::FillInLoyaltyRewardPointLinesForRefund(
                _salesTable,
                _cardNumber,
                _paymentAmount,
                rewardPoints,
                _salesline);
        }

        authorized = remainingPaymentAmount == 0;

        eventSource.EventWriteLoyaltyCardAuthorized(authorized, _salesTable.RecId, true);

        return [authorized, rewardPoints.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>AuthorizeRewardPointsForPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Authorize loyalty the redepmption of rewards points for sales order/call center payment.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales table to attempt to authorize redemption of points against.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card to use as payment.
    /// </param>
    /// <param name="_paymentAmount">
    /// The amount of payment to authorize.
    /// </param>
    /// <returns>
    /// True if the requested amount of payment could be satisfied by reward points from the given card.  False otherwise.
    /// </returns>
    /// <remarks>
    /// This method uses the sales order to find applicable reward point schemes that can be used to pay for items on the order,
    /// then attempts to determine if there are enough points available to satisfy the requested payment amount.  No points are posted/reserved as part of this authorization.
    /// </remarks>
    public static container AuthorizeRewardPointsForPayment(
        SalesTable _salesTable,
        RetailLoyaltyCardNumber _cardNumber,
        AmountCur _paymentAmount)
    {
        boolean authorized = false;

        // Validate sales table record.
        if (!SalesTable::find(_salesTable.SalesId).RecId)
        {
            eventSource.EventWriteLoyaltyCardAuthorizationSalesRecordNotFound(false, _salesTable.SalesId, false);
            return [authorized, null];
        }

        // Validate loyalty card.
        RetailLoyaltyManager::ValidateLoyaltyCard(_cardNumber);

        List rewardPoints = new List(Types::Record);

        // If order is canceled just return the redeemed lines from DB and refund them
        if (_salesTable.SalesStatus ==  SalesStatus::Canceled)
        {
            RetailLoyaltyManager::AddRefundPointLines(_salesTable, rewardPoints);
            eventSource.EventWriteLoyaltyCardAuthorized(true, _salesTable.RecId, false);
            return [true, rewardPoints.pack()];
        }

        real remainingPaymentAmount;

        if (_paymentAmount == 0)
        {
            eventSource.EventWriteLoyaltyCardAuthorized(authorized, _salesTable.RecId, false);
            return [authorized, null];
        }

        // Redeem
        if (_paymentAmount > 0)
        {
            remainingPaymentAmount = RetailLoyaltyManager::FillInLoyaltyRewardPointLinesForPayment(
                _salesTable,
                _cardNumber,
                _paymentAmount,
                rewardPoints);
        }
        else // Refund
        {
            remainingPaymentAmount = RetailLoyaltyManager::FillInLoyaltyRewardPointLinesForRefund(
                _salesTable,
                _cardNumber,
                _paymentAmount,
                rewardPoints);
        }

        if (remainingPaymentAmount <= 0)
        {
            authorized = true;
        }
        eventSource.EventWriteLoyaltyCardAuthorized(authorized, _salesTable.RecId, _paymentAmount < 0 ? true : false);

        return [authorized, rewardPoints.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>AuthorizeRewardPointsForRemovedPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles refunding of loyalty reward points for a payment removed from a SalesOrder.
    /// </summary>
    /// <param name = "_salesTable">
    /// The Sales Order to evaluate.
    /// </param>
    /// <param name = "_cardNumber">
    /// The Loyalty Card number associated with payment.
    /// </param>
    /// <returns>Container with boolean indicating authorization sucess and RetailLoyaltyCardRewardPointTrans record containing the refund.</returns>
    internal static container AuthorizeRewardPointsForRemovedPayment(SalesTable _salesTable, RetailLoyaltyCardNumber _cardNumber)
    {
        boolean authorized = false;

        // Validate sales table record.
        if (!SalesTable::find(_salesTable.SalesId).RecId)
        {
            throw error("@Retail:LoyaltyCardSalesOrderNotFound");
        }

        // Validate loyalty card.
        RetailLoyaltyManager::ValidateLoyaltyCard(_cardNumber);
        
        // Creates RewardPointLine for refund amount.
        List refundLines  = RetailLoyaltyManager::AddRefundPointLineForRemovedPayment(_salesTable);
        
        if (refundLines.elements() > 0)
        {
            authorized = true;
        }
        else
        {
            eventSource.EventWriteLoyaltyPaymentRemovalNoRefundLinesAdded(_salesTable.RecId, extendedParameters.parmMCRPaymRecId());
        }

        eventSource.EventWriteLoyaltyPaymentAuthorizedForRemoval(authorized, _salesTable.RecId, extendedParameters.parmMCRPaymRecId());

        return [authorized, refundLines.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>RefundLoyaltyPointsForSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refund the loyalty points for a sales line paid by loyalty and create a payment record with status authorized.
    /// </summary>
    /// <param name = "_salestable">
    /// The sales order to which sales line belongs.
    /// </param>
    /// <param name = "_salesline">
    /// The sales line for which points have to be refunded.
    /// </param>
    /// <param name = "_refundAmount">
    /// The amount to be refunded for the given sales line.
    /// </param>
    public static void RefundLoyaltyPointsForSalesLine(SalesTable _salestable, SalesLine _salesline, AmountCur _refundAmount)
    {
        MCRCustPaymTable mcrCustPaymTable;
        MCRCustPaymTable mcrCustPaymTableAdjustment;
        boolean authorized;
        container packedRewardPointLinesContainer;

        if (RetailLoyaltyCardRewardPointTrans::IsSalesOrderPaidByLoyalty(_salesTable.SalesId, _salesTable.dataAreaId))
        {
            select sum(Amount) from  mcrCustPaymTable
             where mcrCustPaymTable.RefTableId == _salesTable.TableId
                && mcrCustPaymTable.RefRecId == _salesTable.RecId
                && mcrCustPaymTable.CustPaymType == MCRCustPaymType::LoyaltyCard;
       
            AmountCur salesLineMaxRefundAmount = min(mcrCustPaymTable.Amount, abs(_refundAmount));

            select firstonly mcrCustPaymTable
            where mcrCustPaymTable.RefTableId == _salesTable.TableId
                && mcrCustPaymTable.RefRecId == _salesTable.RecId
                && mcrCustPaymTable.CustPaymType == MCRCustPaymType::LoyaltyCard;

            RetailLoyaltyCardNumber _cardNumber = mcrCustPaymTable.getLoyaltyCardNumber();

            [authorized, packedRewardPointLinesContainer] = RetailLoyaltyManager::AuthorizeRewardPointsForRefundForSalesline(_salesTable, _salesline, _cardNumber, -salesLineMaxRefundAmount);

            if (authorized)
            {
                select firstonly mcrCustPaymTable
                 where mcrCustPaymTable.RefTableId == _salesTable.TableId
                    && mcrCustPaymTable.RefRecId == _salesTable.RecId
                    && mcrCustPaymTable.CustPaymType == MCRCustPaymType::LoyaltyCard
                    && mcrCustPaymTable.Amount > 0;

                mcrCustPaymTableAdjustment = MCRCustPaymTable::writePaymentAdjustmentSales(mcrCustPaymTable, -salesLineMaxRefundAmount, MCRPaymAdjustmentType::Refund);
                
                ttsbegin;
                mcrCustPaymTableAdjustment.Status =  MCRCustPaymStatus::Authorized;
                mcrCustPaymTableAdjustment.update();
                ttscommit;
                
                List redeemPoints = List::create(packedRewardPointLinesContainer);
                if (redeemPoints.elements() == 0)
                {
                    // No points available that can be used to pay for the items in this transaction.
                    throw error("@Retail:NoLoyaltyPointsAvailable");
                }
                else // Post the RedeemPointsTrans records
                {
                    RetailLoyaltyCardRewardPointTrans retailLoyaltyCardRewardPointTrans;
                    boolean isSuccess;
                    str message;
                    ListEnumerator enumerator = redeemPoints.getEnumerator();

                    while (enumerator.moveNext())
                    {
                        retailLoyaltyCardRewardPointTrans = enumerator.current();
                        [isSuccess, message] = RetailLoyaltyManager::PostLoyaltyCardRewardPointTrans(retailLoyaltyCardRewardPointTrans);

                        if (!isSuccess)
                        {
                            // Throw an exception using the LoyaltyCardRewardPointTrans failure message.
                            throw error(message);
                        }
                    }
                }
            }
            else
            {
                warning("@MCR11252");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ValidateLoyaltyCard</Name>
				<Source><![CDATA[
    private static void ValidateLoyaltyCard(RetailLoyaltyCardNumber _cardNumber)
    {
        RetailLoyaltyCard retailLoyaltyCard = RetailLoyaltyCard::findByCardNumber(_cardNumber);

        if (!retailLoyaltyCard.RecId)
        {
            eventSource.EventWriteLoyaltyCardNotFoundForLoyaltyPayment(funcName());
            throw error("@Retail:RetailLoyaltyCardNotExistsError");
        }
        else if (retailLoyaltyCard.CardTenderType == RetailLoyaltyTenderTypeBase::Blocked)
        {
            eventSource.EventWriteLoyaltyCardBlockedForLoyaltyPayment(retailLoyaltyCard.RecId);
            throw error("@Retail:RetailLoyaltyCardBlockedError");
        }
        else if (retailLoyaltyCard.CardTenderType == RetailLoyaltyTenderTypeBase::NoTender)
        {
            eventSource.EventWriteLoyaltyCardNotAllowedForTenderForLoyaltyPayment(retailLoyaltyCard.RecId);
            throw error("@Retail:LoyaltyCardNotAllowedForTender");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>FillInLoyaltyRewardPointLinesForPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given the sales order, loyalty card and requested payment amount, find the applicable schemes and available points, and then attempt to generate enough redeem point transactions.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_paymentAmount">
    /// The requested payment amount.
    /// </param>
    /// <param name="_rewardPointLines">
    /// The resulting redeem point lines.
    /// </param>
    /// <returns>
    /// The amount of the requested payment that is left over and that remains unsatisfied by available reward-points.
    /// </returns>
    /// <remarks>
    /// If the return value is greater-than-zero, then usually the requested payment should be considered "invalid" due to insufficient matching points.
    /// </remarks>
    private static AmountCur FillInLoyaltyRewardPointLinesForPayment(
        SalesTable _salesTable,
        RetailLoyaltyCardNumber _cardNumber,
        AmountCur _paymentAmount,
        List _rewardPointLines)
    {
        // Error out if _rewardPointLines list does not contain the correct types.
        if (_rewardPointLines.typeId() != Types::Record)
        {
            eventSource.EventWriteRewardPointLinesNotContainsCorrectTypesForRedeemPoints(_salesTable.RecId);
            error("@Retail:InvalidRewardPointLines");
        }

        RetailSalesTable retailSalesTable = RetailSalesTable::findSalesTable(_salesTable);
        utcDateTime dateTimeUTC = DateTimeUtil::utcNow();
        date dateUTC = DateTimeUtil::date(dateTimeUTC);

        // Holds an ordered list of containers with : [RewardPoints.RecId, availablePoints]
        List activePoints = RetailLoyaltyManager::GetLoyaltyCardActiveRedeemPoints(dateUTC, _cardNumber);

        // Build PayableLines Map (Key = LineNum, Value = AmountDue)
        Map payableLines = new Map(Types::Real, Types::Real);

        // Get the list of payable lines: each saleline (line amount + sum of line charges), plus an extra line for header charges.
        RetailLoyaltyManager::AddLoyaltyPayableLines(_salesTable, payableLines, false, _paymentAmount);

        //List(Types::Record), List of RetailLoyaltyRedeemSchemeLine
        List redeemLines;
        AmountCur redeemAmountLeft = _paymentAmount;

        RefRecId activeRedeemPointsRecId;

        ListEnumerator listEnumerator = activePoints.getEnumerator();
        while( listEnumerator.moveNext())
        {
            activeRedeemPointsRecId = conPeek(listEnumerator.current(), 1); //ActiveRedeemPoints.RecId

            // FindLoyaltyRedeemSchemeLines by RewardPoint.RecId
            redeemLines = RetailLoyaltyManager::FindLoyaltyRedeemSchemeLines(
                RetailChannelTable::findByRecId(retailSalesTable.RetailChannel).OMOperatingUnitID,
                _salesTable,
                _cardNumber,
                activeRedeemPointsRecId,
                dateUTC);

            if (redeemLines.elements() > 0)
            {
                // Generate reward point lines for the redeem lines.
                redeemAmountLeft = RetailLoyaltyManager::GenerateRewardPointLineForPayment(
                    _salesTable,
                    payableLines,
                    conPeek(listEnumerator.current(), 2), //ActiveRedeemPoints.AvailablePoints
                    redeemLines,
                    redeemAmountLeft,
                    _salesTable.CurrencyCode,
                    _cardNumber,
                    dateTimeUTC,
                    _rewardPointLines);

                eventSource.EventWriteGenerateRewardPointLinesForRedeemLines(activeRedeemPointsRecId);
            }

            if (redeemAmountLeft <= 0)
            {
                eventSource.EventWriteCheckRedeemAmountLeftForGenerateRewardPointLine(activeRedeemPointsRecId);

                break;
            }
        }

        // The resulting list of RewardPointLines have been added to _rewardPointLines, so just  return the amount of payment left over.
        // The caller is responsibe for reporting any errors related the amount left over being too high or too low.
        return redeemAmountLeft;
    }

]]></Source>
			</Method>
			<Method>
				<Name>FillInLoyaltyRewardPointLinesForRefund</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given the sales order, loyalty card and requested payment amount, find the applicable schemes and available points, and then attempt to generate enough refund point transactions.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_paymentAmount">
    /// The requested payment amount.
    /// </param>
    /// <param name="_rewardPointLines">
    /// The resulting reward point lines.
    /// </param>
    /// <param name="_salesLine">
    /// The sales line.
    /// </param>
    /// <returns>
    /// The amount of the requested payment that is left over and that remains unsatisfied by available reward-points.
    /// </returns>
    /// <remarks>
    /// If the return value is greater-than-zero, then usually the requested payment should be considered "invalid" due to insufficient matching points.
    /// </remarks>
    private static AmountCur FillInLoyaltyRewardPointLinesForRefund(
        SalesTable _salesTable,
        RetailLoyaltyCardNumber _cardNumber,
        AmountCur _paymentAmount,
        List _rewardPointLines,
        SalesLine _salesLine = null)
    {
        // Error out if _rewardPointLines list does not contain the correct type of records.
        if (_rewardPointLines.typeId() != Types::Record)
        {
            eventSource.EventWriteRewardPointLinesNotContainsCorrectTypesForRefundPoints(_salesTable.RecId);
            error("@Retail:InvalidRewardPointLines");
        }

        RetailSalesTable retailSalesTable = RetailSalesTable::findSalesTable(_salesTable);
        utcDateTime dateTimeUTC = DateTimeUtil::utcNow();
        date dateUTC = DateTimeUtil::date(dateTimeUTC);

        // Holds an ordered list of containers with : [RewardPoints.RecId, remainingPoints]
        List activePoints = RetailLoyaltyManager::GetLoyaltyCardActiveRedeemPoints(dateUTC, _cardNumber);

        // Build PayableLines Map (Key = LineNum, Value = AmountDue)
        Map payableLines = new Map(Types::Real, Types::Real);
     
        if (_salesLine)
        {
            payableLines.insert(_salesLine.LineNum, -_paymentAmount);
        }
        else
        {
            // Get the list of payable lines: for each return line.
            RetailLoyaltyManager::AddLoyaltyPayableLines(_salesTable, payableLines, true, _paymentAmount);
        }

        //List(Types::Record), List of RetailLoyaltyRedeemSchemeLine
        List redeemLines;
        AmountCur refundAmountLeft = -1 * _paymentAmount;

        RefRecId activeRedeemPointsRecId;

        ListEnumerator listEnumerator = activePoints.getEnumerator();
        while( listEnumerator.moveNext())
        {
            activeRedeemPointsRecId = conPeek(listEnumerator.current(), 1); //ActiveRedeemPoints.RecId

            // FindLoyaltyRedeemSchemeLines by RewardPoint.RecId
            redeemLines = RetailLoyaltyManager::FindLoyaltyRedeemSchemeLines(
                RetailChannelTable::findByRecId(retailSalesTable.RetailChannel).OMOperatingUnitID,
                _salesTable,
                _cardNumber,
                activeRedeemPointsRecId, //ActiveRedeemPoints.RecId
                dateUTC);

            if (redeemLines.elements() > 0)
            {
                // Generate reward point lines for the redeem lines.
                refundAmountLeft = RetailLoyaltyManager::GenerateRewardPointLineForRefund(
                    _salesTable,
                    payableLines,
                    redeemLines,
                    refundAmountLeft,
                    _salesTable.CurrencyCode,
                    _cardNumber,
                    dateTimeUTC,
                    _rewardPointLines);
            }

            if (refundAmountLeft <= 0)
            {
                eventSource.EventWriteCheckRefundAmountLeftForFillInLoyaltyRewardPointLinesForRefund(activeRedeemPointsRecId);

                break;
            }
        }

        if (refundAmountLeft > 0)
        {
            eventSource.EventWriteCheckRefundAmountLeftGreaterThanZero(activeRedeemPointsRecId);
            throw error("@Retail:PaymentExceedsLoyaltyCardBalance");
        }

        // The resulting list of RewardPointLines have been added to _rewardPointLines, so just  return the amount of payment left over.
        // The caller is responsibe for reporting any errors related the amount left over being too high or too low.
        return refundAmountLeft;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLoyaltyCardActiveRedeemPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the amount of points that can currently be redeemed for the given loyalty card.
    /// </summary>
    /// <param name="_utcDate">
    /// The date the this evaluation is being performed, in order to account for any expirations, etc.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <returns>
    /// A List of containers with the format [RetailLoyaltyRewardPoint.RecId = RecID, AmountOfPoints = Real].
    /// It holds the reward point id and available points as an ordered list.
    /// This list has been ordered (ascending order) based on the Redeem Ranking field on the table RetailLoyaltyRewardPoint.
    /// </returns>
    [Hookable(false)]
    internal static List GetLoyaltyCardActiveRedeemPoints(
        date _utcDate,
        RetailLoyaltyCardNumber _cardNumber)
    {
        RetailLoyaltyRewardPoint rewardPoint;
        RetailLoyaltySchemeRewardPointView schemeRewardPointView;
        RetailLoyaltyScheme scheme;
        RetailLoyaltyCardTier cardTier;

        // Map: [RewardPoints.RecId, remainingPoints]
        Map activePoints = new Map(Types::Int64, Types::Real);
        List activePointsEntryOrder = new List(Types::Int64);

        RetailLoyaltyCard loyaltyCard = RetailLoyaltyCard::findByCardNumber(_cardNumber);

        List cardNumberList = new List(Types::String);

        // Validate that the loyalty card is not 'Blocked' or 'NoTender' type.
        if (loyaltyCard.CardTenderType != RetailLoyaltyTenderTypeBase::Blocked
            && loyaltyCard.CardTenderType != RetailLoyaltyTenderTypeBase::NoTender)
        {
            // If loyalty card is 'ContactTender' type and is associated with a customer --> Consider all loyalty cards that:
            //      a) Are assigned to same customer.
            //      b) Are not 'Blocked'.
            if (loyaltyCard.CardTenderType == RetailLoyaltyTenderTypeBase::AsContactTender && loyaltyCard.Party)
            {
                RetailLoyaltyCard relatedCard;
                while select CardNumber from relatedCard
                    where relatedCard.Party == loyaltyCard.Party
                    && relatedCard.CardTenderType != RetailLoyaltyTenderTypeBase::Blocked
                {
                    cardNumberList.addEnd(relatedCard.CardNumber);
                    eventSource.EventWriteForGetRelatedLoyaltyCardForCustomer(loyaltyCard.Party, relatedCard.RecId);
                }
            }
            else // Card is of 'CardTender' type, so only consider current card and no related card can be considered.
            {
                cardNumberList.addEnd(loyaltyCard.CardNumber);
                eventSource.EventWriteForGetCurrentLoyaltyCardForCustomer(loyaltyCard.Party, loyaltyCard.RecId);
            }
        }

        // Iterate over list of all loyalty cards that could be used for redeeming points.
        if (cardNumberList != null && cardNumberList.elements() > 0)
        {
            RetailLoyaltyCardNumber cardNumber;
            RetailLoyaltyCard card;
            ListEnumerator loyaltyCardEnumerator = cardNumberList.getEnumerator();

            while (loyaltyCardEnumerator.moveNext())
            {
                cardNumber = loyaltyCardEnumerator.current();
                card = RetailLoyaltyCard::findByCardNumber(cardNumber);
                eventSource.EventWriteForGetLoyaltyCardFromListForCustomerToRedeemingPoints(card.RecId);

                if (card)
                {
                    // Get the status of the reward points that are associated to the loyalty card.
                    while select RecId, RewardPointId, RewardPointType, RewardPointCurrency, RedeemRanking from rewardPoint
                        where rewardPoint.Redeemable == NoYes::Yes
                    exists join schemeRewardPointView
                        where schemeRewardPointView.RewardPoint == rewardPoint.RecId
                    exists join scheme
                        where scheme.RecId == schemeRewardPointView.LoyaltyScheme
                    exists join cardTier
                    order by rewardPoint.RedeemRanking asc  // sort by RedeemRanking
                    where cardTier.Affiliation == scheme.Affiliation
                        && cardTier.LoyaltyCard == card.RecId
                    {
                        //Active points
                        RetailLoyaltyRewardPointAmountQty active = RetailLoyaltyCardRewardPointTrans::calcPoints(card, rewardPoint.RecId, RetailLoyaltyPointStatusTypeBase::Active, _utcDate);

                        // If reward point's RecId does not exist as one of the map keys, insert to map - [RecId, points].
                        if (!activePoints.exists(rewardPoint.RecId))
                        {
                            activePoints.insert(rewardPoint.RecId, active);
                            activePointsEntryOrder.addEnd(rewardPoint.RecId);
                            eventSource.EventWriteGetStatusOfRewardPointsAndInsertWhenRewardPointIsNotActivePoints(card.RecId, rewardPoint.RecId);
                        }
                        else
                        {
                            // If reward point's RecId exists as one of the map keys, update value associated with that key.
                            activePoints.insert(rewardPoint.RecId, activePoints.lookup(rewardPoint.RecId) + active);
                            eventSource.EventWriteGetStatusOfRewardPointsAndUpdateWhenRewardPointIsNotActivePoints(card.RecId, rewardPoint.RecId);
                        }
                    }
                }
            }
        }

        // Generate the results to be returned.
        List result = new List(Types::Container);
        int64 mapLookUpKey;
        ListEnumerator activePointsEntryOrderListEnumerator = activePointsEntryOrder.getEnumerator();

        while (activePointsEntryOrderListEnumerator.moveNext())
        {
            mapLookUpKey = activePointsEntryOrderListEnumerator.current();
            result.addEnd([mapLookUpKey, activePoints.lookup(mapLookUpKey)]);
        }

        //return list_of_point_records
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLoyaltyPayableLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add entries to summarize the extended amount, tax and charges for each sales line and header on the sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order to evaluate.
    /// </param>
    /// <param name="_payableLines">
    /// The map of payable entries in the form Map(SalesLine.LineNum, AmountCur).
    /// </param>
    /// <param name="_isReturn">
    /// If the sales is return.
    /// </param>
    /// <param name="_paymentAmount">
    /// The payment amount.
    /// </param>
    /// <remarks>
    /// Line Num 0.00 represents any header-level charges on the sales order.
    /// </remarks>
    private static void addLoyaltyPayableLines(
        SalesTable _salesTable,
        Map _payableLines,
        boolean _isReturn,
        AmountCur _paymentAmount)
    {
        CustInvoiceJour custInvoiceJour;
        AmountCur payableAmount;
        AmountCur totalPayableAmount;

        //Get the most recent journal
        select firstonly InvoiceId, RecId from custInvoiceJour
            order by custInvoiceJour.CreatedDateTime desc
            where custInvoiceJour.SalesId == _salesTable.SalesId;

        // If a Customer Invoice Journal exists, then use it to determine the line amounts.
        if (custInvoiceJour)
        {
            CustInvoiceTrans custInvoiceTrans;
            TaxTrans taxTrans;

            while select LineNum, LineAmount, InventTransId
                from custInvoiceTrans
                where custInvoiceTrans.InvoiceId == custInvoiceJour.InvoiceId
            {
                payableAmount = custInvoiceTrans.LineAmount;

                select sum(TaxAmount) from taxTrans
                    where taxTrans.InventTransId == custInvoiceTrans.InventTransId
                    && taxTrans.SourceRecId == custInvoiceTrans.RecId;

                payableAmount += (-1 * taxTrans.TaxAmount);

                if (_isReturn)
                {
                    payableAmount = -1 * payableAmount;
                }
                totalPayableAmount += payableAmount;
                _payableLines.insert(custInvoiceTrans.LineNum, payableAmount);

                eventSource.EventWriteCustInvoiceJourExistsCalculateLineAmount(custInvoiceTrans.RecId, custInvoiceJour.RecId);
            }

            eventSource.EventWriteCheckCustInvoiceJourExists(custInvoiceJour.RecId);
        }
        else
        {
            SalesLine salesLine;

            // Otherwise just use the pre-invoice amounts from the SalesLine table.
            while select salesLine
                where salesLine.SalesId == _salesTable.SalesId
            {
                if (_isReturn)
                {
                    if (salesLine.ExpectedRetQty != 0)
                    {
                        payableAmount = salesLine.calcLineAmount(salesLine.ExpectedRetQty);
                        MCRSalesTotals_OnlyLine mcrLineTotals = new MCRSalesTotals_OnlyLine(salesLine);
                        mcrLineTotals.prepareTotalAmountCalculation();
                        payableAmount += mcrLineTotals.totalTaxAmount();
                        payableAmount = -1 * payableAmount;
                        totalPayableAmount += payableAmount;
                        _payableLines.insert(salesLine.LineNum, payableAmount);
                    }
                }
                else
                {
                    payableAmount = salesLine.calcLineAmount();
                    MCRSalesTotals_OnlyLine mcrLineTotals = new MCRSalesTotals_OnlyLine(salesLine);
                    mcrLineTotals.prepareTotalAmountCalculation();
                    payableAmount += mcrLineTotals.totalTaxAmount();
                    payableAmount += mcrLineTotals.totalMarkup();
                    totalPayableAmount += payableAmount;
                    _payableLines.insert(salesLine.LineNum, payableAmount);
                }

                eventSource.EventWriteGetPreInvoiceAmountsForSalesOrder(_salesTable.recId, salesLine.recId);
            }
        }
 
        // Add remaining amount as PayableLine
        payableAmount = _paymentAmount - totalPayableAmount;
        if (_isReturn)
        {
            payableAmount = -1 * payableAmount;
        }

        _payableLines.insert(0, payableAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>FindLoyaltyRedeemSchemeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the redeeming rules that applies to the given loyalty card.
    /// </summary>
    /// <param name="_channelOU">
    /// The record Id of the operating unit of the channel.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_rewardPoint">
    /// The record identifier of the reward point.  The value can be 0.
    /// </param>
    /// <param name="_date">
    /// The date.
    /// </param>
    /// <returns>
    /// The list of the <c>RetailLoyaltyRedeemSchemeLine</c> records found.
    /// </returns>
    private static List FindLoyaltyRedeemSchemeLines(
        RefRecId _channelOU,
        SalesTable _salesTable,
        RetailLoyaltyCardNumber _cardNumber,
        RefRecId _rewardPoint,
        date _date)
    {
        List redeemSchemeLineList = new List(Types::Record);

        // Find the active loyalty card tiers
        List maxCardTiers = RetailLoyaltyManager::FindMaxLoyaltyCardTiers(_cardNumber, _date);
        ListEnumerator maxCardTierEnumerator = maxCardTiers.getEnumerator();

        RetailLoyaltyCardTier cardTier;
        RetailLoyaltyRedeemSchemeLine redeemSchemeLineByLoyaltyTier;

        // Collect the redeem rules by card tiers
        while (maxCardTierEnumerator.moveNext())
        {
            cardTier = maxCardTierEnumerator.current();

            // Find the earning rules that are associated to the loyalty program without the tier specified
            redeemSchemeLineList.appendList(RetailLoyaltyManager::FindLoyaltyRedeemSchemeLinesByTier(_channelOU, _salesTable ,cardTier.Affiliation, 0, cardTier.LoyaltyTier, _rewardPoint, _date));

            // Find the redeem rules that are associated to the specific loyalty tier
            if (cardTier.LoyaltyTier)
            {
                eventSource.EventWriteRedeemRulesAssociatedLoyaltyTier(cardTier.RecId, cardTier.LoyaltyTier);
                redeemSchemeLineList.appendList(RetailLoyaltyManager::FindLoyaltyRedeemSchemeLinesByTier(_channelOU, _salesTable, cardTier.Affiliation, cardTier.LoyaltyTier, cardTier.LoyaltyTier, _rewardPoint, _date));
            }

            eventSource.EventWriteLoyaltyRedeemSchemeLines(cardTier.RecId);
        }

        return redeemSchemeLineList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>FindLoyaltyRedeemSchemeLinesByTier</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the redeeming rules by the given loyalty tier.
    /// </summary>
    /// <param name="_channelOU">
    /// The record identifier of the operating unit of the channel.
    /// </param>
    /// <param name="_salesTable">
    /// The sales order.
    /// </param>
    /// <param name="_affiliation">
    /// The record identifier of the loyalty program.
    /// </param>
    /// <param name="_loyaltyTier">
    /// The record identifier of the loyalty tier. The value can be 0.
    /// </param>
    /// <param name="_loyaltyCardTier">
    /// The record identifier of the loyalty card tier. The value can be 0.
    /// </param>
    /// <param name="_rewardPoint">
    /// The record identifier of the reward point. The value can be 0.
    /// </param>
    /// <param name="_date">
    /// The valid date of the redeeming rules.
    /// </param>
    /// <returns>
    /// The list of the <c>RetailLoyaltyRedeemSchemeLine</c> records found.
    /// </returns>
    private static List FindLoyaltyRedeemSchemeLinesByTier(
        RefRecId _channelOU,
        SalesTable _salesTable,
        RefRecId _affiliation,
        RefRecId _loyaltyTier,
        RefRecId _loyaltyCardTier,
        RefRecId _rewardPoint,
        date _date)
    {
        List redeemSchemeLineList = new List(Types::Record);

        RetailLoyaltyRedeemSchemeLine redeemSchemeLine;
        RetailLoyaltyScheme scheme;
        RetailLoyaltySchemeChannelExploded schemeChannelExploded;
        RetailSalesAffiliation retailSalesAffiliation;
        RetailAffiliation retailAffiliation;

        if (_channelOU && _affiliation)
        {
            // Redeem lines indepndent of affiliations.
            select redeemSchemeLine
                exists join scheme
                    where scheme.RecId == redeemSchemeLine.LoyaltyScheme
                       && scheme.Affiliation == _affiliation
                exists join schemeChannelExploded
                    where schemeChannelExploded.LoyaltyScheme == scheme.RecId
                       && schemeChannelExploded.OMOperatingUnit == _channelOU
                       && redeemSchemeLine.LoyaltyTier == _loyaltyTier
                       && (!redeemSchemeLine.ValidFrom || redeemSchemeLine.ValidFrom <= _date)
                       && (!redeemSchemeLine.ValidTo || redeemSchemeLine.ValidTo >= _date)
                       && (redeemSchemeLine.ToRewardType == RetailLoyaltyRewardType::PaymentByAmount || redeemSchemeLine.ToRewardType == RetailLoyaltyRewardType::PaymentByQuantity)
                       && (_rewardPoint == 0 || redeemSchemeLine.FromRewardPoint == _rewardPoint);

            // Add to list.
            while(redeemSchemeLine)
            {
                if (!redeemSchemeLine.LoyaltyTier)
                {
                    redeemSchemeLine.LoyaltyTier = _loyaltyCardTier;
                }

                eventSource.EventWriteAddRedeemLines(redeemSchemeLine.RecId);
                redeemSchemeLineList.addEnd(redeemSchemeLine);
                next redeemSchemeLine;
            }

            // Redeem lines which are affiliation specific
            select redeemSchemeLine
                join retailSalesAffiliation
                    where (retailSalesAffiliation.SalesId == _salesTable.SalesId)
                    && (retailSalesAffiliation.Affiliation == redeemSchemeLine.RetailAffiliationId)
                exists join scheme
                    where scheme.RecId == redeemSchemeLine.LoyaltyScheme
                    && scheme.Affiliation == _affiliation
                exists join schemeChannelExploded
                    where schemeChannelExploded.LoyaltyScheme == scheme.RecId
                    && schemeChannelExploded.OMOperatingUnit == _channelOU
                    && redeemSchemeLine.LoyaltyTier == _loyaltyTier
                    && (!redeemSchemeLine.ValidFrom || redeemSchemeLine.ValidFrom <= _date)
                    && (!redeemSchemeLine.ValidTo || redeemSchemeLine.ValidTo >= _date)
                    && (redeemSchemeLine.ToRewardType == RetailLoyaltyRewardType::PaymentByAmount || redeemSchemeLine.ToRewardType == RetailLoyaltyRewardType::PaymentByQuantity)
                    && (_rewardPoint == 0 || redeemSchemeLine.FromRewardPoint == _rewardPoint);

            // Add to list.
            while (redeemSchemeLine)
            {
                eventSource.EventWriteAddAffiliationSpecificRedeemLines(redeemSchemeLine.RecId);
                redeemSchemeLineList.addEnd(redeemSchemeLine);
                next redeemSchemeLine;
            }
        }

        return redeemSchemeLineList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateRewardPointLineForPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given the sales order, a set of available redeem schemes for a loyalty card, attempt to generate a Redeem point transactions to satisfy the requested amount.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales table.
    /// </param>
    /// <param name="_payableLines">
    /// The list of "payable line" entries, which summarize the "total line amounts" needed for a given line to be considered "paid for".
    /// </param>
    /// <param name="_activePoints">
    /// The amount of active points available for redemption.
    /// </param>
    /// <param name="_availableRedeemSchemeLines">
    /// The list of Loyalty Scheme lines that are applicable to the sale lines and loyalty card.
    /// </param>
    /// <param name="_redeemAmountLeft">
    /// The amount of requested redemption payment that is remaining, and that still needs to be matched/satisfied by redeem points.
    /// </param>
    /// <param name="_redeemCurrency">
    /// The currency to be used.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_utcDateTime">
    /// The date/time used to stamp the redeem points transactions.
    /// </param>
    /// <param name="_rewardPointLines">
    /// The list of redeem points transactions to be added to.
    /// </param>
    /// <returns>
    /// The amount of requested payment that remains after generating all applicable redeem reward point transactions.
    /// </returns>
    private static AmountCur GenerateRewardPointLineForPayment(
        SalesTable _salesTable,
        Map _payableLines,
        real _activePoints,
        List _availableRedeemSchemeLines,
        AmountCur _redeemAmountLeft,
        str _redeemCurrency,
        RetailLoyaltyCardNumber _cardNumber,
        utcdatetime _utcDateTime,
        List _rewardPointLines)
    {
        // Return early if there are no points or schemelines available.
        if (_activePoints <= 0
            || _availableRedeemSchemeLines == null
            || _availableRedeemSchemeLines.elements() == 0
            || _redeemAmountLeft == 0)
        {
            eventSource.EventWriteNoPointsOrSchemelinesAvailable(_salesTable.recId);

            // No points or no scheme lines for redeem
            return _redeemAmountLeft;
        }

        RetailSharedParameters retailSharedParameters = RetailSharedParameters::find(false);

        SalesLine salesLine;
        real redeemPointsTotal, redeemPoints;
        RetailLoyaltyRedeemSchemeLine firstBestRedeemLine, bestRedeemLine;
        Map salesLineAndPoints = new Map(Types::Real, Types::Real);

        // 1)
        // Use the reward points to pay towards the transaction, product by product (because points may have restrictions on products)
        // For each sales line, we can only redeem at most the min of redeemAmountLeft and payablePerSalesLine.
        while select * from salesLine where salesLine.salesId == _salesTable.SalesId
        {
            if (_payableLines.exists(salesLine.LineNum) && _payableLines.lookup(salesLine.LineNum) != 0)
            {
                AmountCur salesLineMaxRedeemAmount = min(_payableLines.lookup(salesLine.LineNum), _redeemAmountLeft);

                // Find the best payment deal for the customer.
                bestRedeemLine = RetailLoyaltyManager::findBestRedeemLine(salesLine, _redeemCurrency, _availableRedeemSchemeLines);

                if (bestRedeemLine
                    && bestRedeemLine.FromRewardPointAmountQty > 0
                    && bestRedeemLine.ToRewardAmountQty > 0)
                {
                    if (!firstBestRedeemLine)
                    {
                        firstBestRedeemLine = bestRedeemLine;
                    }

                    [redeemPoints, _redeemAmountLeft] = RetailLoyaltyManager::CalculateRedeemPointsPerSalesLine(
                        _redeemAmountLeft,
                        _payableLines,
                        _activePoints,
                        _redeemCurrency,
                        salesLine,
                        salesLineMaxRedeemAmount,
                        bestRedeemLine);

                    _activePoints -= redeemPoints;

                    if (redeemPoints > 0)
                    {
                        redeemPointsTotal += redeemPoints;

                        if (retailSharedParameters.PostLoyaltyPointsPerSalesLine)
                        {
                            salesLineAndPoints.insert(salesLine.LineNum, redeemPoints);
                            eventSource.EventWriteRewardPointLineForSalesLinePaymentWhenRedeemPointsGreaterThanZero(salesLine.RecId, bestRedeemLine.RecId);
                        }
                    }
                }
            }

            if (_redeemAmountLeft <= 0 || _activePoints <= 0)
            {
                break;
            }

            eventSource.EventWriteRewardPointLineForRedeemSalesLine(salesLine.RecId);
        }

        // 2)
        // Use the reward points to pay towards the transaction-level charge lines
        // We can only redeem at most the min of redeemAmountLeft and transactionLevelTotalCharges.
        if (_redeemAmountLeft > 0
            && _activePoints > 0
            && _payableLines.exists(0)
            && _payableLines.lookup(0) > 0)
        {
            AmountCur maxRedeemAmount =  min(_payableLines.lookup(0), _redeemAmountLeft);
            salesLine.clear();
            bestRedeemLine = RetailLoyaltyManager::findBestRedeemLine(salesLine, _redeemCurrency, _availableRedeemSchemeLines);

            if (bestRedeemLine
                && bestRedeemLine.FromRewardPointAmountQty > 0
                && bestRedeemLine.ToRewardAmountQty > 0)
            {
                if (!firstBestRedeemLine)
                {
                    firstBestRedeemLine = bestRedeemLine;
                }

                //Calculate for the Header, aka, SalesLine.LineNum = 0
                salesLine.clear();
                [redeemPoints, _redeemAmountLeft] = RetailLoyaltyManager::CalculateRedeemPointsPerSalesLine(
                    _redeemAmountLeft,
                    _payableLines,
                    _activePoints,
                    _redeemCurrency,
                    salesLine,
                    maxRedeemAmount,
                    bestRedeemLine);

                _activePoints -= redeemPoints;

                if (redeemPoints > 0)
                {
                    redeemPointsTotal += redeemPoints;

                    if (retailSharedParameters.PostLoyaltyPointsPerSalesLine)
                    {
                        salesLineAndPoints.insert(0, redeemPoints);
                    }

                    eventSource.EventWriteRewardPointLinePaymentWhenRedeemPointsGreaterThanZero(bestRedeemLine.RecId);
                }
            }
        }

        // 3)
        // Generate a reward point line
        if (redeemPointsTotal != 0)
        {
            ListEnumerator listEnumerator = _availableRedeemSchemeLines.getEnumerator();
            listEnumerator.moveNext();
            RetailLoyaltyRedeemSchemeLine firstRedeemLine = listEnumerator.current();

            if (retailSharedParameters.postLoyaltyPointsPerSalesLine)
            {
                MapIterator salesLineMapIterator = new MapIterator(salesLineAndPoints);

                // Generate redeem lines by sales line.
                while(salesLineMapIterator.more())
                {
                    // Get sale line number and loyalty points to spend.
                    LineNum salesLineNumber = salesLineMapIterator.key();
                    RetailLoyaltyActivityAmountQty salesLineRedeemPoints = salesLineMapIterator.value();
                    RetailLoyaltyManager::GenerateAndAddLoyaltyPointRedeemOrRefundLine(_cardNumber, _salesTable, _utcDateTime, _rewardPointLines, firstBestRedeemLine, salesLineRedeemPoints, firstRedeemLine, RetailLoyaltyRewardPointEntryType::Redeem, salesLineNumber);
                    eventSource.EventWriteGenerateRedeemLinesForPerSalesLine(_salesTable.RecId);
                    salesLineMapIterator.next();
                }
            }
            else
            {
                // Generate a single redeem point line.
                RetailLoyaltyManager::GenerateAndAddLoyaltyPointRedeemOrRefundLine(_cardNumber, _salesTable, _utcDateTime, _rewardPointLines, firstBestRedeemLine, redeemPointsTotal, firstRedeemLine, RetailLoyaltyRewardPointEntryType::Redeem, 0);
                eventSource.EventWriteGenerateRedeemLinesForSingleRedeemPoitLine(_salesTable.RecId);
            }
        }

        return _redeemAmountLeft;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateRewardPointLineForRefund</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given the sales order, a set of available redeem schemes for a loyalty card, attempt to generate a Reward point transactions to satisfy the requested amount.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales table.
    /// </param>
    /// <param name="_payableLines">
    /// The list of "payable line" entries, which summarize the "total line amounts" needed for a given line to be considered "paid for".
    /// </param>
    /// <param name="_availableRedeemSchemeLines">
    /// The list of Loyalty Scheme lines that are applicable to the sale lines and loyalty card.
    /// </param>
    /// <param name="_refundAmountLeft">
    /// The amount of requested refund payment that is remaining, and that still needs to be matched/satisfied by redeem points.
    /// </param>
    /// <param name="_refundCurrency">
    /// The currency to be used.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_utcDateTime">
    /// The date/time used to stamp the redeem points transactions.
    /// </param>
    /// <param name="_rewardPointLines">
    /// The list of redeem points transactions to be added to.
    /// </param>
    /// <returns>
    /// The amount of requested payment that remains after generating all applicable refund reward point transactions.
    /// </returns>
    private static AmountCur GenerateRewardPointLineForRefund(
        SalesTable _salesTable,
        Map _payableLines,
        List _availableRedeemSchemeLines,
        AmountCur _refundAmountLeft,
        str _refundCurrency,
        RetailLoyaltyCardNumber _cardNumber,
        utcdatetime _utcDateTime,
        List _rewardPointLines)
    {
        // Return early if there are no schemelines available.
        if (_availableRedeemSchemeLines == null
            || _availableRedeemSchemeLines.elements() == 0
            || _refundAmountLeft == 0)
        {
            eventSource.EventWriteNoPointsOrSchemelinesAvailable(_salesTable.Recid);

            // No points or no scheme lines for redeem
            return _refundAmountLeft;
        }

        RetailSharedParameters retailSharedParameters = RetailSharedParameters::find(false);

        SalesLine salesLine;
        real refundPointsTotal;
        RetailLoyaltyRedeemSchemeLine firstBestRedeemLine, bestRedeemLine;
        Map salesLineAndPoints = new Map(Types::Real, Types::Real);

        // Use the reward points to refund towards the transaction, product by product (because points may have restrictions on products)
        // For each sales line, we can only refund at most the min of redeemAmountLeft and payablePerSalesLine.
        while select * from salesLine where salesLine.salesId == _salesTable.SalesId
        {
            if (_payableLines.exists(salesLine.LineNum) && _payableLines.lookup(salesLine.LineNum) != 0)
            {
                AmountCur salesLineMaxRefundAmount = min(_payableLines.lookup(salesLine.LineNum), _refundAmountLeft);

                // Find the best payment deal for the customer.
                bestRedeemLine = RetailLoyaltyManager::findBestRedeemLine(salesLine, _refundCurrency, _availableRedeemSchemeLines);

                if (bestRedeemLine
                    && bestRedeemLine.FromRewardPointAmountQty > 0
                    && bestRedeemLine.ToRewardAmountQty > 0)
                {
                    if (!firstBestRedeemLine)
                    {
                        firstBestRedeemLine = bestRedeemLine;
                    }

                    real refundPoints;
                    switch (bestRedeemLine.ToRewardType)
                    {
                        case RetailLoyaltyRewardType::PaymentByAmount:
                            refundPoints = (salesLineMaxRefundAmount / bestRedeemLine.ToRewardAmountQty) * bestRedeemLine.FromRewardPointAmountQty;
                            break;

                        case RetailLoyaltyRewardType::PaymentByQuantity:
                            real unitAmount = RetailLoyaltyPointsCalculationCheckToggle::instance().isEnabled() ? salesLine.LineAmount / salesLine.SalesQty : salesLine.LineAmount / salesLine.QtyOrdered;
                            real unitPoints = bestRedeemLine.FromRewardPointAmountQty / bestRedeemLine.ToRewardAmountQty;
                            refundPoints = (salesLineMaxRefundAmount / unitAmount) * unitPoints;
                            break;

                        default:
                            error(strFmt("@Retail:LoyaltyRewardPointNotSupported", bestRedeemLine.ToRewardType));
                            return _refundAmountLeft;
                    }

                    _refundAmountLeft -= salesLineMaxRefundAmount;
                    AmountCur payablePerSalesLineAmount = _payableLines.lookup(salesLine.LineNum) - salesLineMaxRefundAmount;
                    _payableLines.insert(salesLine.LineNum, payablePerSalesLineAmount);

                    if (refundPoints > 0)
                    {
                        refundPointsTotal += refundPoints;

                        if (retailSharedParameters.PostLoyaltyPointsPerSalesLine)
                        {
                            salesLineAndPoints.insert(salesLine.LineNum, refundPoints);
                        }

                        eventSource.EventWriteRewardPointLineForSalesLinePaymentWhenRefundPointsGreaterThanZero(salesLine.RecId, bestRedeemLine.RecId);
                    }
                }
            }

            if (_refundAmountLeft <= 0)
            {
                break;
            }

            eventSource.EventWriteRewardPointLineForRefundSalesLine(salesLine.RecId);
        }

        // Use the reward points to refund any remaining amount
        // We can only redeem at most the min of refundAmountLeft and amount eleigible for refund.
        if (_refundAmountLeft > 0
            && _payableLines.exists(0)
            && _payableLines.lookup(0) > 0)
        {
            AmountCur salesLineMaxRefundAmount =  min(_payableLines.lookup(0), _refundAmountLeft);
            salesLine.clear();
            bestRedeemLine = RetailLoyaltyManager::findBestRedeemLine(salesLine, _refundCurrency, _availableRedeemSchemeLines);

            if (bestRedeemLine
                && bestRedeemLine.FromRewardPointAmountQty > 0
                && bestRedeemLine.ToRewardAmountQty > 0)
            {
                if (!firstBestRedeemLine)
                {
                    firstBestRedeemLine = bestRedeemLine;
                }

                //Calculate for the Header, aka, SalesLine.LineNum = 0
                salesLine.clear();
                real refundPoints = (salesLineMaxRefundAmount / bestRedeemLine.ToRewardAmountQty) * bestRedeemLine.FromRewardPointAmountQty;
                _refundAmountLeft -= salesLineMaxRefundAmount;
                AmountCur payablePerSalesLineAmount = _payableLines.lookup(salesLine.LineNum) - salesLineMaxRefundAmount;
                _payableLines.insert(salesLine.LineNum, payablePerSalesLineAmount);

                if (refundPoints > 0)
                {
                    refundPointsTotal += refundPoints;

                    if (retailSharedParameters.PostLoyaltyPointsPerSalesLine)
                    {
                        salesLineAndPoints.insert(salesLine.LineNum, refundPoints);
                    }

                    eventSource.EventWriteRewardPointLinePaymentWhenRefundPointsGreaterThanZero(bestRedeemLine.RecId);
                }
            }
        }

        // Generate reward point refund line
        if (refundPointsTotal > 0)
        {
            ListEnumerator listEnumerator = _availableRedeemSchemeLines.getEnumerator();
            listEnumerator.moveNext();
            RetailLoyaltyRedeemSchemeLine firstRedeemLine = listEnumerator.current();

            if (retailSharedParameters.postLoyaltyPointsPerSalesLine)
            {
                MapIterator salesLineMapIterator = new MapIterator(salesLineAndPoints);

                // Generate refund lines by sales line.
                while(salesLineMapIterator.more())
                {
                    // Get sale line number and loyalty points to refund.
                    LineNum salesLineNumber = salesLineMapIterator.key();
                    RetailLoyaltyActivityAmountQty salesLineRefundPoints = salesLineMapIterator.value();
                    RetailLoyaltyManager::GenerateAndAddLoyaltyPointRedeemOrRefundLine(_cardNumber, _salesTable, _utcDateTime, _rewardPointLines, firstBestRedeemLine, salesLineRefundPoints, firstRedeemLine, RetailLoyaltyRewardPointEntryType::Refund, salesLineNumber);
                    eventSource.EventWriteGenerateRedeemLinesForRefundPerSalesLine(_salesTable.RecId);
                    salesLineMapIterator.next();
                }
            }
            else
            {
                // Generate a single refund point line.
                RetailLoyaltyManager::GenerateAndAddLoyaltyPointRedeemOrRefundLine(_cardNumber, _salesTable, _utcDateTime, _rewardPointLines, firstBestRedeemLine, refundPointsTotal, firstRedeemLine, RetailLoyaltyRewardPointEntryType::Refund, 0);
                eventSource.EventWriteGenerateRedeemLinesForSingleRefundPoitLine(_salesTable.RecId);
            }
        }

        return _refundAmountLeft;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateAndAddLoyaltyPointRedeemOrRefundLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates loyalty card reward point transaction and adds it to collection of reward point lines.
    /// </summary>
    /// <param name="_loyaltyCardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_salesTable">
    /// The customer account number.
    /// </param>
    /// <param name="_utcDateTime">
    /// The local date time of the channel.
    /// </param>
    /// <param name="_rewardPointLines">
    /// The list of reward point lines to collect the generated line.
    /// </param>
    /// <param name="_firstBestRedeemLine">
    /// The first best redeem line.
    /// </param>
    /// <param name="_loyaltyPoints">
    /// Loyalty points.
    /// </param>
    /// <param name="_firstRedeemLine">
    /// The first redeem line.
    /// </param>
    /// <param name="_entryType">
    /// The entry type for loyalty reward point.
    /// </param>
    /// <param name="_salesLineNumber">
    /// The sales line number.
    /// </param>
    private static void GenerateAndAddLoyaltyPointRedeemOrRefundLine(
        RetailLoyaltyCardNumber _loyaltyCardNumber,
        SalesTable _salesTable,
        utcDateTime _utcDateTime,
        List _rewardPointLines,
        RetailLoyaltyRedeemSchemeLine _firstBestRedeemLine,
        RetailLoyaltyActivityAmountQty _loyaltyPoints,
        RetailLoyaltyRedeemSchemeLine _firstRedeemLine,
        RetailLoyaltyRewardPointEntryType _entryType,
        LineNum _salesLineNumber)
    {
        if (_entryType == RetailLoyaltyRewardPointEntryType::Redeem)
        {
            _loyaltyPoints = _loyaltyPoints * -1;
        }

        _loyaltyPoints = RetailLoyaltyManager::RoundRewardPoints(_loyaltyPoints, RetailLoyaltyRewardPoint::find(_firstBestRedeemLine.FromRewardPoint));
        RetailLoyaltyCardRewardPointTrans rewardPointTrans;

        rewardPointTrans.clear();
        rewardPointTrans.Affiliation = RetailLoyaltyScheme::findByRecId(_firstBestRedeemLine.LoyaltyScheme).Affiliation;
        rewardPointTrans.CardNumber = _loyaltyCardNumber;
        rewardPointTrans.CustAccount = _salesTable.CustAccount;
        rewardPointTrans.CustAccountDataAreaId = _salesTable.dataAreaId;
        rewardPointTrans.Channel = RetailSalesTable::findSalesTable(_salesTable).RetailChannel;
        rewardPointTrans.EntryDate = DateTimeUtil::date(_utcDateTime);
        rewardPointTrans.EntryTime = DateTimeUtil::time(_utcDateTime);
        rewardPointTrans.EntryType = _entryType;
        rewardPointTrans.ExpirationDate = maxDate();
        rewardPointTrans.LoyaltyTier = _firstRedeemLine.LoyaltyTier;
        rewardPointTrans.LoyaltyTransactionType = RetailLoyaltyTransactionType::SalesOrder;
        rewardPointTrans.loyaltyTransDataAreaId = _salesTable.dataAreaId;
        
        str disableUsingRedeemLoyaltyLineNumAsRefundLoyaltyLineNumConfigKey = 'DisableUsingRedeemLoyaltyLineNumAsRefundLoyaltyLineNum';
        RetailSharedConfigurationParameters disableRedeemLineNumAsRefundLineNum = RetailSharedConfigurationParameters::findByName(disableUsingRedeemLoyaltyLineNumAsRefundLoyaltyLineNumConfigKey);
        if (disableRedeemLineNumAsRefundLineNum.Value != '1'
            && _entryType == RetailLoyaltyRewardPointEntryType::Refund
            && _salesTable.SalesId != ''
            && _salesLineNumber > 0)
        {
            RetailLoyaltyCardRewardPointTrans redeemLineTrans;
            select firstonly RecId, LoyaltyTransLineNum from redeemLineTrans
                where redeemLineTrans.SalesId == _salesTable.SalesId
                    && redeemLineTrans.SalesLineLineNum == _salesLineNumber
                    && redeemLineTrans.EntryType == RetailLoyaltyRewardPointEntryType::Redeem;
            if (redeemLineTrans.RecId != 0)
            {
                rewardPointTrans.LoyaltyTransLineNum = redeemLineTrans.LoyaltyTransLineNum;
            }
            else
            {
                rewardPointTrans.LoyaltyTransLineNum = _rewardPointLines.elements() + 1;
            }
        }
        else
        {
            rewardPointTrans.LoyaltyTransLineNum = _rewardPointLines.elements() + 1;
        }
        
        rewardPointTrans.RewardPoint = _firstBestRedeemLine.FromRewardPoint;
        rewardPointTrans.RewardPointAmountQty = _loyaltyPoints;
        rewardPointTrans.SalesId = _salesTable.SalesId;
        rewardPointTrans.SalesLineLineNum = _salesLineNumber;

        // Add to record list.
        _rewardPointLines.addEnd(rewardPointTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBestRedeemLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the best redeem line for the given sales line.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales line to evaluate.
    /// </param>
    /// <param name="_redeemCurrency">
    /// The currency used for evaluation (used to normalize Amount vs. Quantity points).
    /// </param>
    /// <param name="_availableRedeemLines">
    /// The list of available redeem-points lines.
    /// </param>
    /// <returns>
    /// Evaluates the list of available redeem-point lines and returns the "best" line.
    /// </returns>
    /// <remarks>
    /// Returns the redeem-points line that has the most favorable "rate" for the given sale line.
    /// </remarks>
    private static RetailLoyaltyRedeemSchemeLine findBestRedeemLine(
        SalesLine _salesLine,
        str _redeemCurrency,
        List _availableRedeemLines)
    {
        real bestRedeemRate;
        RetailLoyaltyRedeemSchemeLine bestRedeemLine;
        ListEnumerator enumerator = _availableRedeemLines.getEnumerator();
        CurrencyExchangeHelper currencyExchangeHelper;

        while (enumerator.moveNext())
        {
            RetailLoyaltyRedeemSchemeLine redeemLine = enumerator.current();

            if (redeemLine.FromRewardPointAmountQty > 0
                && redeemLine.ToRewardAmountQty > 0
                && ((redeemLine.ToRewardType == RetailLoyaltyRewardType::PaymentByAmount && redeemLine.ToRewardAmountCurrency)
                || redeemLine.ToRewardType == RetailLoyaltyRewardType::PaymentByQuantity))
            {
                // Check if the redeem line is eligible to the sales line.
                if (RetailLoyaltyManager::IsSalesLineEligibleForRedeemLine( _salesLine, redeemLine))
                {
                    eventSource.EventWriteRedeemLineIsEligibleForSalesLine(_salesLine.Recid, redeemLine.RecId);

                    // Calculates the redeem rate e.g. x points for 1 USD.
                    real redeemRateInRedeemCurrency = 0;

                    switch (redeemLine.ToRewardType)
                    {
                        case RetailLoyaltyRewardType::PaymentByAmount:
                            RetailLoyaltyRewardAmountQty toAmountQuantity;
                            if (redeemLine.ToRewardAmountCurrency == _redeemCurrency)
                            {
                                toAmountQuantity = redeemLine.ToRewardAmountQty;
                            }
                            else
                            {
                                // Convert to the redeem currency.
                                if (currencyExchangeHelper == null)
                                {
                                    currencyExchangeHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
                                }

                                toAmountQuantity = currencyExchangeHelper.calculateCurrencyToCurrency(redeemLine.ToRewardAmountCurrency, _redeemCurrency, redeemLine.ToRewardAmountQty, true);
                            }
                            redeemRateInRedeemCurrency = redeemLine.FromRewardPointAmountQty / toAmountQuantity;
                            break;

                        case RetailLoyaltyRewardType::PaymentByQuantity:
                            real amountPerUnit = RetailLoyaltyPointsCalculationCheckToggle::instance().isEnabled() ? _salesLine.LineAmount / _salesLine.SalesQty : _salesLine.LineAmount / _salesLine.QtyOrdered;
                            redeemRateInRedeemCurrency = redeemLine.FromRewardPointAmountQty / (redeemLine.ToRewardAmountQty * amountPerUnit);
                            break;
                    }

                    if (bestRedeemRate == 0 || redeemRateInRedeemCurrency < bestRedeemRate)
                    {
                        bestRedeemRate = redeemRateInRedeemCurrency;
                        bestRedeemLine = redeemLine;
                    }
                }
            }

            eventSource.EventWriteAvailableRedeemLines(redeemLine.RecId);
        }

        return bestRedeemLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CalculateRedeemPointsPerSalesLine</Name>
				<Source><![CDATA[
    private static container CalculateRedeemPointsPerSalesLine(
        AmountCur _redeemAmountLeft,
        Map _payablePerSalesLine,
        real _activePoints,
        str _redeemCurrency,
        SalesLine _salesLine,
        AmountCur _maxRedeemAmount,
        RetailLoyaltyRedeemSchemeLine _redeemLine)
    {
        real redeemPoints;
        real neededPoints;
        real unitAmount;
        real unitPoints;

        // Calculate needed points for this line.
        switch (_redeemLine.ToRewardType)
        {
            case RetailLoyaltyRewardType::PaymentByAmount:
                neededPoints = (_maxRedeemAmount / _redeemLine.ToRewardAmountQty) * _redeemLine.FromRewardPointAmountQty;
                break;

            case RetailLoyaltyRewardType::PaymentByQuantity:
                unitAmount = RetailLoyaltyPointsCalculationCheckToggle::instance().isEnabled() ? _salesLine.LineAmount / _salesLine.SalesQty : _salesLine.LineAmount / _salesLine.QtyOrdered;
                unitPoints = _redeemLine.FromRewardPointAmountQty / _redeemLine.ToRewardAmountQty;
                neededPoints = (_maxRedeemAmount / unitAmount) * unitPoints;
                break;

            default:
                error(strFmt("@Retail:LoyaltyRewardPointNotSupported", _redeemLine.ToRewardType));
                return [0, _redeemAmountLeft];
        }

        eventSource.EventWriteRedeemLineRewardType(_redeemLine.Recid, _redeemLine.ToRewardType);

        AmountCur payablePerSalesLineAmount;

        // Compare needed points with available points
        if (_activePoints < neededPoints)
        {
            // Spend all active points of the current point
            redeemPoints = _activePoints;

            AmountCur coveredAmount;
            // Calculate covered amount
            switch (_redeemLine.ToRewardType)
            {
                case RetailLoyaltyRewardType::PaymentByAmount:
                    coveredAmount = (redeemPoints / _redeemLine.FromRewardPointAmountQty) * _redeemLine.ToRewardAmountQty;
                    break;

                case RetailLoyaltyRewardType::PaymentByQuantity:
                    coveredAmount = (redeemPoints / unitPoints) * unitAmount;
                    break;

                default:
                    error(strFmt("@Retail:LoyaltyRewardPointNotSupported", _redeemLine.ToRewardType));
                    return [0, _redeemAmountLeft];
            }

            // Amount rounding based on currency
            coveredAmount = round(coveredAmount, Currency::find(_redeemCurrency).RoundingPrecision);
            _redeemAmountLeft -= coveredAmount;

            payablePerSalesLineAmount = _payablePerSalesLine.lookup(_salesLine.LineNum) - coveredAmount;
            _payablePerSalesLine.insert(_salesLine.LineNum, payablePerSalesLineAmount);

            eventSource.EventWriteWhenAvailablePointsLessThanNeededPoints(_redeemLine.Recid, neededPoints, _activePoints);
        }
        else
        {
            redeemPoints = neededPoints;
            _redeemAmountLeft -= _maxRedeemAmount;

            // SalesLine.LineNum is either a valid line number for a payable sales line, or 0 for header payables.
            payablePerSalesLineAmount = _payablePerSalesLine.lookup(_salesLine.LineNum) - _maxRedeemAmount;
            _payablePerSalesLine.insert(_salesLine.LineNum, payablePerSalesLineAmount);

            eventSource.EventWriteWhenAvailablePointsNotLessThanNeededPoints(_redeemLine.Recid, neededPoints, _activePoints);
        }

        // Return the points used and the remaining amount.
        return [redeemPoints, _redeemAmountLeft];
    }

]]></Source>
			</Method>
			<Method>
				<Name>IsSalesLineEligibleForRedeemLine</Name>
				<Source><![CDATA[
    private static boolean IsSalesLineEligibleForRedeemLine(
        SalesLine _salesLine,
        RetailLoyaltyRedeemSchemeLine _redeemLine)
    {
        // Transaction level charges.
        if (!_salesLine)
        {
            return _redeemLine.ToRewardType == RetailLoyaltyRewardType::PaymentByAmount;
        }

        RetailGroupMemberLine groupMemberLine = RetailGroupMemberLine::find(_redeemLine.ToRetailGroupMemberLine);
        RefRecId toCategoryRecordId = groupMemberLine.Category;
        RefRecId toProductRecordId = groupMemberLine.Product;
        RefRecId toVariantRecordId = groupMemberLine.Variant;

        boolean isProductIndependent = _redeemLine.ToRetailGroupMemberLine == 0
                                    || groupMemberLine.RecId == 0
                                    || (toCategoryRecordId == 0 && toProductRecordId == 0 && toVariantRecordId == 0);
        boolean accept = false;

        if (isProductIndependent)
        {
            accept = true;
        }
        else if (groupMemberLine.Variant != 0)
        {
            if (_salesLine.RetailVariantId)
            {
                InventDimCombination inventDimCombination = InventDimCombination::findVariantId(_salesLine.RetailVariantId);
                accept = groupMemberLine.Variant == inventDimCombination.DistinctProductVariant;
            }
            else
            {
                accept = false;
            }
        }
        else if (groupMemberLine.Product != 0)
        {
            InventTable inventTable = inventTable::find(_salesLine.ItemId);
            accept = groupMemberLine.Product == inventTable.Product;
        }
        else if (groupMemberLine.Category != 0)
        {
            InventTable inventTable = inventTable::find(_salesLine.ItemId);
            RetailAllProductCategories retailAllProductCategories;
            select firstonly Category, Product from retailAllProductCategories
            where retailAllProductCategories.Category == groupMemberLine.Category
                && retailAllProductCategories.Product == inventTable.Product;

            accept = retailAllProductCategories.RecId != 0;
        }

        return accept;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateLoyaltyTierGrantDetailData</Name>
				<Source><![CDATA[
    private static void generateLoyaltyTierGrantDetailData(RefRecId _affiliationId, RefRecId _loyaltyTierId, RefRecId _loyaltyCardId,
                                                           RefRecId _loyaltyCardTierId, RefRecId _relatedRetailLoyaltyTierRuleId,
                                                           date _retailLoyaltyTierGrantDate, int _retailLoyaltyTierGrantTime)
    {
        RetailLoyaltyTierGrantDetail loyaltyTierGrantDetail;

        // Find _loyaltyCardTier grant detail.
        select loyaltyTierGrantDetail
                where loyaltyTierGrantDetail.LoyaltyCard == _loyaltyCardId
                    && loyaltyTierGrantDetail.Affiliation == _affiliationId
                    && loyaltyTierGrantDetail.LoyaltyTier == _loyaltyTierId
                    && loyaltyTierGrantDetail.RelatedRetailLoyaltyTierRule == _relatedRetailLoyaltyTierRuleId
                    && loyaltyTierGrantDetail.RetailLoyaltyCardTier == _loyaltyCardTierId;

        // Create _loyaltyCardTier grant detail to capture card's new tier.
        if (!loyaltyTierGrantDetail.RecId && _relatedRetailLoyaltyTierRuleId != 0)
        {
            loyaltyTierGrantDetail.initValue();
            loyaltyTierGrantDetail.LoyaltyCard = _loyaltyCardId;
            loyaltyTierGrantDetail.Affiliation = _affiliationId;
            loyaltyTierGrantDetail.LoyaltyTier = _loyaltyTierId;
            loyaltyTierGrantDetail.RetailLoyaltyCardTier = _loyaltyCardTierId;
            loyaltyTierGrantDetail.RelatedRetailLoyaltyTierRule = _relatedRetailLoyaltyTierRuleId;
            loyaltyTierGrantDetail.RetailLoyaltyTierGrantDate = _retailLoyaltyTierGrantDate;
            loyaltyTierGrantDetail.RetailLoyaltyTierGrantTime = _retailLoyaltyTierGrantTime;
            loyaltyTierGrantDetail.insert();
        }
        else // Update _loyaltyCardTier grant detail for card's existing tier.
        {
            loyaltyTierGrantDetail.selectForUpdate(true);
            loyaltyTierGrantDetail.RelatedRetailLoyaltyTierRule = _relatedRetailLoyaltyTierRuleId;
            loyaltyTierGrantDetail.RetailLoyaltyTierGrantDate = _retailLoyaltyTierGrantDate;
            loyaltyTierGrantDetail.RetailLoyaltyTierGrantTime = _retailLoyaltyTierGrantTime;
            loyaltyTierGrantDetail.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>DeductUnvestedPositiveRemainings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Uses the returned points or the negative adjusted points of a transaction to deduct the positive Unvested balances of the previous transactions, if any.
    /// </summary>
    /// <param name="_retailLoyaltyCardRewardPointTransRecId">
    /// The record ID of the current <c>RetailLoyaltyCardRewardPointTrans</c> record.
    /// </param>
    /// <param name="_transDate">
    /// The entry date of the current <c>RetailLoyaltyCardRewardPointTrans</c> record.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_rewardPointRecid">
    /// The record ID of the reawrd point.
    /// </param>
    /// <param name="_points">
    /// The negative points.
    /// </param>
    /// <returns>
    /// The remaining points yet to be deducted, after deducting Unvested points.
    /// </returns>
    private static RetailLoyaltyRewardPointAmountQty DeductUnvestedPositiveRemainings(
        RefRecId _retailLoyaltyCardRewardPointTransRecId,
        date _transDate,
        RetailLoyaltyCardNumber _cardNumber,
        RefRecId _rewardPointRecid,
        RetailLoyaltyRewardPointAmountQty _points)
    {
        RetailLoyaltyCardRewardPointTrans positiveRemainingTrans;
        RetailLoyaltyRewardPointAmountQty remainingPoints, deductionPoints;
        RetailLoyaltyCardRewardPointDeduction deduction;

        remainingPoints = _points;

        if (remainingPoints < 0)
        {
            // When the adjustment point is negative:
            // Deduct points from the previous unvested trans, if any.
            // Deduct the points ordered by StartDate.
            while select forUpdate positiveRemainingTrans
                order by positiveRemainingTrans.StartDate desc
                where positiveRemainingTrans.CardNumber == _cardNumber
                    && positiveRemainingTrans.RewardPoint == _rewardPointRecid
                    && positiveRemainingTrans.Remaining > 0
                    && (positiveRemainingTrans.StartDate > _transDate)
            {
                boolean remainingTransHasSufficientRemainingPoints = false;

                if (positiveRemainingTrans.Remaining >= remainingPoints * -1)
                {
                    // The found trans has enough positive remaining points for deduction.
                    deductionPoints = remainingPoints * -1;
                    positiveRemainingTrans.Remaining += remainingPoints;
                    remainingPoints = 0;
                    remainingTransHasSufficientRemainingPoints = true;
                }
                else
                {
                    // The found trans does not have enough positive remaining points for deduction.
                    // Deduct all and continue to find the next.
                    deductionPoints = positiveRemainingTrans.Remaining;
                    remainingPoints += positiveRemainingTrans.Remaining;
                    positiveRemainingTrans.Remaining = 0;
                    remainingTransHasSufficientRemainingPoints = false;
                }

                // Update the Remaining of the negative remaining trans.
                positiveRemainingTrans.update();

                // Insert deduction line.
                deduction.initValue();
                deduction.RewardPointSourceTrans = positiveRemainingTrans.RecId;
                deduction.RewardPointDeductTrans = _retailLoyaltyCardRewardPointTransRecId;
                deduction.RewardPointAmountQty = deductionPoints;
                deduction.insert();

                eventSource.EventWriteUnvesterdPointsDeductedOfLoyaltyCard(positiveRemainingTrans.Recid,
                                                                           deduction.RecId,
                                                                           deductionPoints,
                                                                           remainingPoints,
                                                                           remainingTransHasSufficientRemainingPoints,
                                                                           _retailLoyaltyCardRewardPointTransRecId,
                                                                           _rewardPointRecid,
                                                                           _transDate);

                if (remainingPoints == 0)
                {
                    break;
                }
            }
        }

        return remainingPoints;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultExtendedParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets extendedParameters and returns a new object with default properties.
    /// This helps ensure that extendedParameters is not already dirty before using it.
    /// </summary>
    /// <returns>
    /// The newly instantiated extendedParameters with default properties.
    /// </returns>
    internal static RetailLoyaltyManager_ExtendedParameters getDefaultExtendedParameters()
    {
        extendedParameters = RetailLoyaltyManager_ExtendedParameters::construct();
        return extendedParameters;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>