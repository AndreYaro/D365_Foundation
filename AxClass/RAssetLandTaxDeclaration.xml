<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>rAssetLandTaxDeclaration</Name>
	<SourceCode>
		<Declaration><![CDATA[
class rAssetLandTaxDeclaration extends rAssetTaxDeclaration implements BatchRetryable
{
    RAssetLandTaxDeclarationLocation    taxDeclarationLocation;
    RTax25RegisterJournalTrans          landTaxJournalTrans;
    RTax25RegisterJournalTrans          landTaxCalcJourTrans;

    int                                 rcoadCount;
    int                                 section1Page;
    Map                                 section1Map;
    Map                                 section2Map;
    boolean                             isDetached;     // new data model of rTax25 register transactions

    #define.okatoPerPage(2)

    #define.RCOAD(1)
    #define.BudgetRevenueCode(2)
    #define.SalesTaxCode(3)
    #define.AssetId(4)
    #define.TaxAmount(28)

    #define.CurrentVersion(5)
    #localmacro.CurrentList
        employeeId,
        taxDeclarationLocation,
        reorganization,
        exportToER,
        reorganizationCode,
        reorganizationINN,
        reorganizationRRC
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>advancePaymentSum</Name>
				<Source><![CDATA[
    private RAssetNetBookValue advancePaymentSum(container _header, TransDate _quarterEndDate)
    {
        RTax25RegisterTrans                     rTax25RegTransAsset;
        RTax25RegisterTrans_LandTaxCalc         regTrans, nextTrans, regTransSum;
        RTax25RegisterJournalTrans              journalTrans, nextJournal, journalTransSum;
        RTax25RegisterJournalTable              regJournalTable;
        RAssetAssessedAmount                    ret;
        boolean                                 foundHeader;
        OKATO_RU                                okato;
        PaymentOrderBudgetReceiptClassCode_RU   kbk;
        TaxCode                                 taxCode;
        RAssetId                                assetId;
        ;
    
        select firstonly JournalNum, PeriodType, PeriodNum, FiscalYear from regJournalTable
            where regJournalTable.RegisterJournalType   == RTax25RegisterJournalType::Asset_RU
               && regJournalTable.EndDate               == _quarterEndDate;
    
        if (RTax25RegisterTrans::existAny(regJournalTable.JournalNum,
                                          landTaxCalcJourTrans.RegisterId,
                                          regJournalTable.PeriodType,
                                          regJournalTable.PeriodNum,
                                          regJournalTable.FiscalYear))
        {
            while select RegisterValues from rTax25RegTransAsset
                order by LineNumber
                where rTax25RegTransAsset.AssessedTaxRegisterType == RAssetAssessedTaxRegType::LandTaxCalc
                  &&  rTax25RegTransAsset.BlockType               == ReportBlockType::Body
                  &&  rTax25RegTransAsset.JournalNum              == regJournalTable.JournalNum
                  &&  rTax25RegTransAsset.PeriodNum               == regJournalTable.PeriodNum
                  &&  rTax25RegTransAsset.PeriodType              == regJournalTable.PeriodType
                  &&  rTax25RegTransAsset.FiscalYear              == regJournalTable.FiscalYear
            {
                [okato, kbk, taxCode, assetId] = rTax25RegTransAsset.RegisterValues;
    
                if (okato && kbk && taxCode)
                {
                    foundHeader = (okato == conpeek(_header, 1) && kbk == conpeek(_header, 2) && taxCode == conpeek(_header, 3));
                }
    
                if (foundHeader && assetId == conpeek(_header, 4))
                {
                    ret += conPeek(rTax25RegTransAsset.RegisterValues, 28);
                }
            }
        }
        else
        {
            [okato, kbk, taxCode, assetId] = _header;
    
            while select LineNumber, RCOAD, BudgetRevenueCode, SalesTaxCode from regTrans
                order by LineNumber
                where regTrans.BlockType         == ReportBlockType::Body &&
                      regTrans.RCOAD             == okato                 &&
                      regTrans.BudgetRevenueCode == kbk                   &&
                      regTrans.SalesTaxCode      == taxCode
            exists join journalTrans
                where journalTrans.RecId        == regTrans.JournalTransRefRecId   &&
                      journalTrans.RegisterId   == landTaxCalcJourTrans.RegisterId &&
                      journalTrans.JournalNum   == regJournalTable.JournalNum      &&
                      journalTrans.PeriodNum    == regJournalTable.PeriodNum       &&
                      journalTrans.PeriodType   == regJournalTable.PeriodType      &&
                      journalTrans.FiscalYear   == regJournalTable.FiscalYear      &&
                      ! journalTrans.Cancelled
            {
                select firstonly LineNumber from nextTrans
                    order by LineNumber
                    where nextTrans.LineNumber     >  regTrans.LineNumber        &&
                          nextTrans.BlockType      == ReportBlockType::Body      &&
                          nextTrans.RCOAD
                exists join nextJournal
                    where nextJournal.RecId        == nextTrans.JournalTransRefRecId  &&
                          nextJournal.RegisterId   == landTaxCalcJourTrans.RegisterId &&
                          nextJournal.JournalNum   == regJournalTable.JournalNum      &&
                          nextJournal.PeriodNum    == regJournalTable.PeriodNum       &&
                          nextJournal.PeriodType   == regJournalTable.PeriodType      &&
                          nextJournal.FiscalYear   == regJournalTable.FiscalYear      &&
                          ! nextJournal.Cancelled;
    
                select sum(TaxAmount) from regTransSum
                    where regTransSum.BlockType      == ReportBlockType::Body      &&
                          regTransSum.AssetId        == assetId                    &&
                          regTransSum.LineNumber     >  regTrans.LineNumber        &&
                          (regTransSum.LineNumber    <  nextTrans.LineNumber       ||
                           ! nextTrans.LineNumber)
                exists join journalTransSum
                    where journalTransSum.RecId        == regTransSum.JournalTransRefRecId &&
                          journalTransSum.RegisterId   == landTaxCalcJourTrans.RegisterId  &&
                          journalTransSum.JournalNum   == regJournalTable.JournalNum       &&
                          journalTransSum.PeriodNum    == regJournalTable.PeriodNum        &&
                          journalTransSum.PeriodType   == regJournalTable.PeriodType       &&
                          journalTransSum.FiscalYear   == regJournalTable.FiscalYear       &&
                          ! journalTransSum.Cancelled;
    
                ret += regTransSum.TaxAmount;
            }
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    public Description caption()
    {
        return RAssetLandTaxDeclaration::description();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRegisterTrans</Name>
				<Source><![CDATA[
    private boolean checkRegisterTrans(OKATO_RU   _okato,
                                       RefTableId _refTableId,
                                       RefRecId   _refRecId)
    {
        Branches_RU      branch;
        RAssetLocationId location;
    
        if (taxDeclarationLocation == RAssetLandTaxDeclarationLocation::ImmovableGroundArea ||
            taxDeclarationLocation == RAssetLandTaxDeclarationLocation::ImmovableSubsoilArea)
        {
            if (_refTableId == tableNum(RAssetTable))
            {
                location = RAssetTable::findrec(_refRecId).location(journalTable.EndDate);
                if (location)
                {
                    branch = Branches_RU::find(RAssetLocation::find(location).BranchId);
                    if (branch.VendAccount)
                        return branch.VendAccount == curVendAccount;
                }
                return !curVendAccount && _okato == curRCOAD;
            }
            return false;
        }
        return _okato == curRCOAD;
    }

]]></Source>
			</Method>
			<Method>
				<Name>create1To2Sections</Name>
				<Source><![CDATA[
    protected void create1To2Sections()
    {
        OKATO_RU                                okato;
        PaymentOrderBudgetReceiptClassCode_RU   kbk;
        MapEnumerator                           me;
    
        me = section1Map.getEnumerator();
        while (me.moveNext())
        {
            [kbk, okato] = me.currentValue();
            if (rcoadCount >= #okatoPerPage)
            {
                totalPages++;
                excelDocument.insertSheet(2, totalPages + 1);
                rcoadCount = 0;
                section1Page = totalPages;
            }
            this.fillSection1(section1Page + 2, rcoadCount, me.currentValue());
            this.createSection2(okato, kbk);
            rcoadCount++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSection2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reproduces copies and fills the third page of template report.
    /// </summary>
    /// <param name="_okato">
    /// Russian Classification of objects of administrative division.
    /// </param>
    /// <param name="_kbk">
    /// Budget revenue code.
    /// </param>
    protected void createSection2(OKATO_RU _okato, PaymentOrderBudgetReceiptClassCode_RU _kbk)
    {
        List                valuesList;
        ListEnumerator      le;
    
        if (!section2Map.exists(_kbk + _okato))
            return;
    
        valuesList = section2Map.lookup(_kbk + _okato);
    
        if (valuesList && valuesList.elements())
        {
            le = valuesList.getEnumerator();
            while (le.moveNext())
            {
                totalPages++;
                excelDocument.insertSheet(#Value3, totalPages + 1);
                this.fillSection2(totalPages + 2, _okato, _kbk, le.current());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillHeader</Name>
				<Source><![CDATA[
    protected void fillHeader()
    {
        #localMacro.ReportPeriodCode
            [3, 21, 51, 6, 22, 54, 9, 23, 55, 12, 34, 34]
        #endMacro
    
        this.fillCellsLeft(1, #X,  11, int2str(correctionNumber), 3, "@GLS109332");
        this.fillCellsLeft(1, #BV, 11, int2str(conPeek(#ReportPeriodCode, conFind(#ReportPeriodCode, mthOfYr(journalTable.EndDate)) + 1 + reorganization)));
        this.fillCellsLeft(1, #DE, 11, int2str(year(journalTable.EndDate)));
        this.fillCellsLeft(1, #DH, 13, int2str(taxDeclarationLocation + 200));
    
        if (reorganization)
        {
            this.fillCellsLeft(1, #AB, 27, int2str(reorganizationCode));
            this.fillCellsLeft(1, #BJ, 27, reorganizationINN);
            this.fillCellsLeft(1, #CP, 27, reorganizationRRC);
        }
    
        this.fillCellsLeft(1, #AY, 13, gniCode);
    
        this.fillCellsLeft(1, #A,  15, subStr(companyName, 1, 40), 40);
        this.fillCellsLeft(1, #A,  17, subStr(companyName, 41, 80), 40);
        this.fillCellsLeft(1, #A,  19, subStr(companyName, 81, 120), 40);
        this.fillCellsLeft(1, #A,  21, subStr(companyName, 121, 180), 40);
    
        this.fillCellsLeft(1, #CG, 24, subStr(okdp, 1, 2), 2);
        this.fillCellsLeft(1, #CP, 24, subStr(okdp, 4, 2), 2);
        this.fillCellsLeft(1, #CY, 24, subStr(okdp, 7, 2), 2);
    
        this.fillCellsLeft(1, #AK, 29, companyPhone);
    
        this.fillCellsLeft(1, #M,  37, taxPayerSing);
        this.fillCellsLeft(1, #A,  40, lastName);
        this.fillCellsLeft(1, #A,  43, firstName);
        this.fillCellsLeft(1, #A,  47, middleName);
    
        this.fillHeaderPage(totalPages, 1, 1, 80);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillHeaderPage</Name>
				<Source><![CDATA[
    #define.INNColumn(#AK)
    #define.INNRow(1)
    #define.KPPColumn(#AK)
    #define.KPPRow(4)
    private void fillHeaderPage(int _pageNumber, int _sheet, int _page, int _size, int _offset = 0)
    {
        this.fillCellsLeft(_sheet, #INNColumn, _offset + #INNRow + (_page - 1) * _size, inn, 12, "@GLS109332");
        this.fillCellsLeft(_sheet, #KPPColumn, _offset + #KPPRow + (_page - 1) * _size, kpp, 9);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSection1</Name>
				<Source><![CDATA[
    #define.Value15(15)
    #define.okatoDelta(17)
    protected void fillSection1(int _sheet, int _index, container _values)
    {
        str taxSum;
    
        this.fillCellsLeft(_sheet, #BI, 21 + _index * #okatoDelta, conPeek(_values, 1), 20);
        this.fillCellsLeft(_sheet, #BI, 23 + _index * #okatoDelta, conPeek(_values, #Value2), 11, "@SYS24272");
    
        taxSum = this.roundAmountStr(conPeek(_values, #Value4));
        this.fillCellsLeft(_sheet, #BI, 28 + _index * #okatoDelta, taxSum, #Value15, "@GLS101637");
    
        taxSum = this.roundAmountStr(conPeek(_values, #Value5));
        this.fillCellsLeft(_sheet, #BI, 30 + _index * #okatoDelta, taxSum, #Value15, "@GLS101637");
    
        taxSum = this.roundAmountStr(conPeek(_values, #Value6));
        this.fillCellsLeft(_sheet, #BI, 32 + _index * #okatoDelta, taxSum, #Value15, "@GLS101637");
    
        taxSum = this.roundAmountStr(conPeek(_values, #Value3));
        this.fillCellsLeft(_sheet, #BI, 25 + _index * #okatoDelta, taxSum, #Value15, "@GLS101637");
    
        taxSum = this.roundAmountStr(0);
        if (conPeek(_values, 3) - conPeek(_values, 4) - conPeek(_values, 5) - conPeek(_values, 6) > 0)
        {
            this.fillCellsLeft(_sheet, #BI, 36 + _index * #okatoDelta, taxSum, #Value15, "@GLS101637");
            taxSum = this.roundAmountStr(conPeek(_values, 3) - conPeek(_values, 4) - conPeek(_values, 5) - conPeek(_values, 6));
            this.fillCellsLeft(_sheet, #BI, 34 + _index * #okatoDelta, taxSum, #Value15, "@GLS101637");
        }
        else
        {
            this.fillCellsLeft(_sheet, #BI, 34 + _index * #okatoDelta, taxSum, #Value15, "@GLS101637");
            taxSum = this.roundAmountStr(conPeek(_values, 4) + conPeek(_values, 5) + conPeek(_values, 6) - conPeek(_values, 3));
            this.fillCellsLeft(_sheet, #BI, 36 + _index * #okatoDelta, taxSum, #Value15, "@GLS101637");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSection2</Name>
				<Source><![CDATA[
    #define.V("V")
    #define.CategoryID(5)
    #define.CadastralNumber(6)
    #define.DesignAndBuildingPeriod(7)
    #define.CadastralCost(8)
    #define.OwnedShare(9)
    #define.AllowanceBaseReduction387(10)
    #define.AllowanceAmount378(11)
    #define.AllowanceBaseReduction391(12)
    #define.AllowanceAmount391(13)
    #define.AllowanceNonTaxableShare(14)
    #define.NonTaxableAreaShare(15)
    #define.LandTaxExemption387(16)
    #define.ExemptionAmount387(17)
    #define.LandTaxExemption395(18)
    #define.ExemptionAmount395(19)
    #define.GracePeriod(20)
    #define.FactorK1(21)
    #define.TaxBase(22)
    #define.TaxValue(23)
    #define.FactorK2(24)
    #define.Tax(25)
    #define.AllowanceTaxReduction(26)
    #define.TaxAllowanceAmount378(27)
    protected void fillSection2(int _sheet, OKATO_RU _okato, PaymentOrderBudgetReceiptClassCode_RU _kbk, RTax25RegisterTransMap  _taxCalc)
    {
        str                 s;
        RAssetTaxAllowance  allowance;
        int                 row;
        Common    common  = _taxCalc;
        container fieldId = RTax25RegType::construct(RTax25RegisterType::AmountDifference, RAssetAssessedTaxRegType::LandTaxCalc, isDetached).fieldId();
    
        anytype getField(RTax25FieldId   _fieldId)
        {
            if (isDetached)
            {
                return common.(conpeek(fieldId, _fieldId));
            }
            return conpeek(_taxCalc.RegisterValues, _fieldId);
        }
    
        this.fillCellsLeft(_sheet, #A, 9, getField(#CadastralNumber));
        this.fillCellsLeft(_sheet, #BF, 15, _kbk, 20);
        this.fillCellsLeft(_sheet, #BF, 17, _okato, 11, "@SYS24272");
        this.fillCellsLeft(_sheet, #BF, 19, getField(#CategoryID));
    
        this.fillCellsLeft(_sheet, #BF, 21, getField(#DesignAndBuildingPeriod) == "@GLS117019" ? "@SYS24273" :
                                            getField(#DesignAndBuildingPeriod) == "@GLS117020" ? "@SYS24274" : "@GLS109332");
    
        this.fillCellsLeft(_sheet, #BF, 23, this.roundAmountStr(getField(#CadastralCost)), 15, "@GLS109332");
    
        row = strLen(getField(#OwnedShare));
        s = subStr(getField(#OwnedShare), 1, strFind(getField(#OwnedShare), "@SYS35673", 1, row)-1);
        this.fillCellsLeft(_sheet, #BF, 25, s, 10, "@GLS109332");
        s = subStr(getField(#OwnedShare), row ,-(row-strFind(getField(#OwnedShare), "@SYS35673", 1, row)));
        this.fillCellsLeft(_sheet, #CM, 25, s, 10, "@GLS109332");
    
        this.fillCellsLeft(_sheet, #BF, 27, getField(#AllowanceBaseReduction387));
        allowance = RAssetTaxAllowance::findByTaxAllowanceId(getField(#AllowanceBaseReduction387));
        if (allowance.ArticleNumber)
            this.fillCellsRight(_sheet, #CM, 27, allowance.ArticleNumber, 4, "@SYS24272");
        if (allowance.ArticleClause)
            this.fillCellsRight(_sheet, #CY, 27, allowance.ArticleClause, 4, "@SYS24272");
        if (allowance.ArticleSubClause)
            this.fillCellsRight(_sheet, #DK, 27, allowance.ArticleSubClause, 4, "@SYS24272");
        this.fillCellsLeft(_sheet, #BF, 29, this.roundAmountStr(getField(#AllowanceAmount378)), 15, "@GLS109332");
    
        this.fillCellsLeft(_sheet, #BF, 31, getField(#AllowanceBaseReduction391));
        this.fillCellsLeft(_sheet, #BF, 33, this.roundAmountStr(getField(#AllowanceAmount391)), 15, "@GLS109332");
    
        this.fillCellsLeft(_sheet, #BF, 35, getField(#AllowanceNonTaxableShare));
        allowance = RAssetTaxAllowance::findByTaxAllowanceId(getField(#AllowanceNonTaxableShare));
        if (allowance.ArticleNumber)
            this.fillCellsRight(_sheet, #CM, 35, allowance.ArticleNumber, 4, "@SYS24272");
        if (allowance.ArticleClause)
            this.fillCellsRight(_sheet, #CY, 35, allowance.ArticleClause, 4, "@SYS24272");
        if (allowance.ArticleSubClause)
            this.fillCellsRight(_sheet, #DK, 35, allowance.ArticleSubClause, 4, "@SYS24272");
    
        row = strLen(getField(#NonTaxableAreaShare));
        s = subStr(getField(#NonTaxableAreaShare), 1, strFind(getField(#NonTaxableAreaShare), "@SYS35673", 1, row)-1);
        this.fillCellsLeft(_sheet, #BF, 37, s, 10, "@GLS109332");
        s = subStr(getField(#NonTaxableAreaShare), row ,-(row-strFind(getField(#NonTaxableAreaShare), "@SYS35673", 1, row)));
        this.fillCellsLeft(_sheet, #CM, 37, s, 10, "@GLS109332");
    
        this.fillCellsLeft(_sheet, #BF, 39, this.roundAmountStr(getField(#TaxBase)), 15, "@GLS109332");
    
        s = num2str(trunc(getField(#TaxValue)), 0, 0, 1, 0);
        this.fillCellsLeft(_sheet, #BF, 41, subStr(s, 1, 1), 1, "@GLS109332");
        s = num2str(frac(getField(#TaxValue)), 0,
                    numOfDec(getField(#TaxValue)) ? numOfDec(getField(#TaxValue)) : 1, 1, 0);
        this.fillCellsLeft(_sheet, #BL, 41, subStr(s, 3, strLen(s)), 4, "@GLS109332");
    
        this.fillCellsLeft(_sheet, #BF, 43, this.roundAmountStr(this.round(getField(#FactorK2) *
                                  RTax25RegisterJournalTable::periodMthLength(landTaxCalcJourTrans.PeriodType))), 2, "@GLS109332");
    
        s = num2str(trunc(getField(#FactorK2)), 0, 0, 1, 0);
        this.fillCellsLeft(_sheet, #BF, 45, subStr(s, 1, 1), 1, "@GLS109332");
        s = num2str(frac(getField(#FactorK2)), 0,
                    numOfDec(getField(#FactorK2)) ? numOfDec(getField(#FactorK2)) : 1, 1, 0);
        this.fillCellsLeft(_sheet, #BL, 45, subStr(s, 3, strLen(s)), 4, "@GLS109332");
    
        this.fillCellsLeft(_sheet, #BF, 47, this.roundAmountStr(getField(#Tax)), 15, "@GLS109332");
    
        this.fillCellsLeft(_sheet, #BF, 49, this.roundAmountStr(getField(#GracePeriod)), 2, "@GLS109332");
    
        s = num2str(trunc(getField(#FactorK1)), 0, 0, 1, 0);
        this.fillCellsLeft(_sheet, #BF, 51, subStr(s, 1, 1), 1, "@GLS109332");
        s = num2str(frac(getField(#FactorK1)), 0,
                    numOfDec(getField(#FactorK1)) ? numOfDec(getField(#FactorK1)) : 1, 1, 0);
        this.fillCellsLeft(_sheet, #BL, 51, subStr(s, 3, strLen(s)), 4, "@GLS109332");
    
        this.fillCellsLeft(_sheet, #BF, 53, getField(#LandTaxExemption387));
        allowance = RAssetTaxAllowance::findByTaxAllowanceId(getField(#LandTaxExemption387));
        if (allowance.ArticleNumber)
            this.fillCellsRight(_sheet, #CM, 53, allowance.ArticleNumber, 4, "@SYS24272");
        if (allowance.ArticleClause)
            this.fillCellsRight(_sheet, #CY, 53, allowance.ArticleClause, 4, "@SYS24272");
        if (allowance.ArticleSubClause)
            this.fillCellsRight(_sheet, #DK, 53, allowance.ArticleSubClause, 4, "@SYS24272");
    
        this.fillCellsLeft(_sheet, #BF, 55, this.roundAmountStr(getField(#ExemptionAmount387)), 15, "@GLS109332");
    
        this.fillCellsLeft(_sheet, #BF, 57, getField(#LandTaxExemption395));
        this.fillCellsLeft(_sheet, #BF, 59, this.roundAmountStr(getField(#ExemptionAmount395)), 15, "@GLS109332");
    
        if (RAssetTaxAllowance::findByTaxAllowanceId(getField(#AllowanceTaxReduction)).TaxAllowanceType == RAssetTaxAllowanceType::TaxAmountReduction)
        {
            this.fillCellsLeft(_sheet, #BF, 61, getField(#AllowanceTaxReduction));
            allowance = RAssetTaxAllowance::findByTaxAllowanceId(getField(#AllowanceTaxReduction));
            if (allowance.ArticleNumber)
                this.fillCellsRight(_sheet, #CM, 61, allowance.ArticleNumber, 4, "@SYS24272");
            if (allowance.ArticleClause)
                this.fillCellsRight(_sheet, #CY, 61, allowance.ArticleClause, 4, "@SYS24272");
            if (allowance.ArticleSubClause)
                this.fillCellsRight(_sheet, #DK, 61, allowance.ArticleSubClause, 4, "@SYS24272");
            this.fillCellsLeft(_sheet, #BF, 63, this.roundAmountStr(getField(#TaxAllowanceAmount378)), 15, "@GLS109332");
        }
        else
        {
            this.fillCellsLeft(_sheet, #BF, 65, getField(#AllowanceTaxReduction));
            allowance = RAssetTaxAllowance::findByTaxAllowanceId(getField(#AllowanceTaxReduction));
            if (allowance.ArticleNumber)
                this.fillCellsRight(_sheet, #CM, 65, allowance.ArticleNumber, 4, "@SYS24272");
            if (allowance.ArticleClause)
                this.fillCellsRight(_sheet, #CY, 65, allowance.ArticleClause, 4, "@SYS24272");
            if (allowance.ArticleSubClause)
                this.fillCellsRight(_sheet, #DK, 65, allowance.ArticleSubClause, 4, "@SYS24272");
            this.fillCellsLeft(_sheet, #BF, 67, this.roundAmountStr(getField(#TaxAllowanceAmount378)), 15, "@GLS109332");
        }
    
        this.fillCellsLeft(_sheet, #BF, 69, this.roundAmountStr(getField(#TaxAmount)), 15, "@GLS109332");
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillTotalPages</Name>
				<Source><![CDATA[
    #define.PageNumberColumn(#BX)
    #define.KPPRow(4)
    protected void fillTotalPages()
    {
        int page;
    
        this.fillCellsRight(1, #K, 31, int2str(totalPages), 3, #0);
    
        excelDocument.deleteWorkSheet(#Value3);
        excelDocument.deleteWorkSheet(#Value2);
    
        for (page = totalPages; page >= 1; page--)
        {
            this.fillCellsRight(page, #PageNumberColumn, #KPPRow, int2str(page), 3, #0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupData</Name>
				<Source><![CDATA[
    #define.EndMarch(31)
    #define.EndJune(30)
    #define.EndSeptember(30)
    #define.MarchNum(03)
    #define.JuneNum(06)
    #define.SeptemberNum(09)
    private void groupData()
    {
        RTax25Query                           query = RTax25Query::newParameters(RTax25RegisterType::AmountDifference, landTaxCalcJourTrans, isDetached);
        str                                   mapKey;
        TaxCode                               taxCode;
        Amount                                advance1, advance2, advance3;
        Amount                                calcTax;
        List                                  valuesList;
        OKATO_RU                              okato;
        PaymentOrderBudgetReceiptClassCode_RU kbk;
    
        if (query.first())
        {
            do
            {
                if (query.getRecord().RefTableId)
                {
                    if (this.checkRegisterTrans(okato, query.getRecord().RefTableId, query.getRecord().RefRecId))
                    {
                        mapKey = kbk + okato;
    
                        if (section1Map.exists(mapKey))
                        {
                            [kbk, okato, calcTax, advance1, advance2, advance3]  = section1Map.lookup(mapKey);
                        }
                        else
                        {
                            [kbk, okato, calcTax, advance1, advance2, advance3]  = [kbk, okato, 0, 0, 0, 0];
                        }
    
                        if (section2Map.exists(mapKey))
                        {
                            valuesList  = section2Map.lookup(mapKey);
                        }
                        else
                        {
                            valuesList  = new List(Types::Record);
                        }
    
                        calcTax  += query.getField(#TaxAmount);
                        advance1 += this.advancePaymentSum([okato, kbk, taxCode, query.getField(#AssetId)],
                                                           mkDate(#EndMarch, #MarchNum, journalTable.FiscalYear));
                        advance2 += this.advancePaymentSum([okato, kbk, taxCode, query.getField(#AssetId)],
                                                           mkDate(#EndJune, #JuneNum, journalTable.FiscalYear));
                        advance3 += this.advancePaymentSum([okato, kbk, taxCode, query.getField(#AssetId)],
                                                           mkDate(#EndSeptember, #SeptemberNum, journalTable.FiscalYear));
    
                        valuesList.addEnd(query.getRecord());
    
                        section1Map.insert(mapKey, [kbk, okato, calcTax, advance1, advance2, advance3]);
                        section2Map.insert(mapKey, valuesList);
                    }
                }
                else
                {
                    okato   = query.getField(#RCOAD);
                    kbk     = query.getField(#BudgetRevenueCode);
                    taxCode = query.getField(#SalesTaxCode);
                }
            }
            while (query.next());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void initValue(Args _args)
    {
        super(_args);
        select firstonly landTaxJournalTrans
            where landTaxJournalTrans.JournalNum              == journalTable.JournalNum &&
                  landTaxJournalTrans.PeriodType              == journalTable.PeriodType &&
                  landTaxJournalTrans.PeriodNum               == journalTable.PeriodNum  &&
                  landTaxJournalTrans.FiscalYear              == journalTable.FiscalYear &&
                  landTaxJournalTrans.Cancelled               == NoYes::No               &&
                  landTaxJournalTrans.AssessedTaxRegisterType == RAssetAssessedTaxRegType::LandTax;
        select firstonly landTaxCalcJourTrans
            where landTaxCalcJourTrans.JournalNum              == journalTable.JournalNum &&
                  landTaxCalcJourTrans.PeriodType              == journalTable.PeriodType &&
                  landTaxCalcJourTrans.PeriodNum               == journalTable.PeriodNum  &&
                  landTaxCalcJourTrans.FiscalYear              == journalTable.FiscalYear &&
                  landTaxCalcJourTrans.Cancelled               == NoYes::No               &&
                  landTaxCalcJourTrans.AssessedTaxRegisterType == RAssetAssessedTaxRegType::LandTaxCalc;
    
        isDetached = ! RTax25RegisterTrans::existAny(journalTable.JournalNum,
                                                     landTaxCalcJourTrans.RegisterId,
                                                     journalTable.PeriodType,
                                                     journalTable.PeriodNum,
                                                     journalTable.FiscalYear);
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens an XMLExcelDocument to work with.
    /// </summary>
    /// <param name="_declarationFor">
    /// The name of printing declaration.
    /// </param>
    /// <returns>
    /// true, if the document was opened; otherwise, false.
    /// </returns>
    /// <remarks>
    /// File first copied to subfolder of current user temp path, if subfolder doesn't exist, it's created
    /// </remarks>
    protected boolean makeDocument(str _declarationFor)
    {    
        section1Map   = new Map(Types::String, Types::Container);
        section2Map   = new Map(Types::String, Types::Class);
        totalPages    = 1;
        excelDocument = new ComExcelDocument_RU();
    
        if (!excelDocument.newFile(TemplateProvider_RU::getFor(this).get(this.templateName()), false))
        {
            return false;
        }
    
        rcoadCount  = #okatoPerPage;
    
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList, ''];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxDeclarationLocation</Name>
				<Source><![CDATA[
    public RAssetLandTaxDeclarationLocation parmTaxDeclarationLocation(RAssetLandTaxDeclarationLocation  _taxDeclarationLocation = taxDeclarationLocation)
    {
        taxDeclarationLocation = _taxDeclarationLocation;
        return taxDeclarationLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printByAuthority</Name>
				<Source><![CDATA[
    private void printByAuthority()
    {
        SetEnumerator se;
        SetEnumerator rkoadSE;
    
        if(declarationSet && declarationSet.elements())
        {
            se = declarationSet.getEnumerator();
            while (se.moveNext())
            {
                rkoadSE = this.rcoadSet(se.current()).getEnumerator();
                if (rkoadSE.moveNext() && this.makeDocument(se.current()))
                {
                    totalPages  = 1;
                    gniCode     = (select GniCode_RU from taxAuthorityAddress where
                                        taxAuthorityAddress.TaxAuthority == se.current()).GniCode_RU;
                    this.fillHeader();
                    do
                    {
                        curRCOAD = rkoadSE.current();
                        this.create1To2Sections();
                    } while (rkoadSE.moveNext());
    
                    this.endDocument();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printByDetachedDepartment</Name>
				<Source><![CDATA[
    private void printByDetachedDepartment()
    {
        VendTable           vendTable;
        ContactPerson       contactPerson;
        Branches_RU         branch;
        RAssetLocationId    location;
        SetEnumerator       se;
        DirPersonName       dirPersonName;
        Set                 rcoadSet = this.rcoadSet();
        Set                 detachedSet = new Set(Types::String);
        boolean             findVendDirector = taxPayerSing == '1';
        RTax25Query         query = RTax25Query::newParameters(RTax25RegisterType::AmountDifference, landTaxCalcJourTrans, isDetached);
    
        if (query.first())
        {
            do
            {
                if (query.getRecord().RefTableId == tableNum(RAssetTable))
        {
                    location = RAssetTable::findRec(query.getRecord().RefRecId).location(journalTable.EndDate);
                    if (location)
            {
                        branch = Branches_RU::find(RAssetLocation::find(location).BranchId);
                if (declarationSet.in(branch.VendAccount))
                {
                    detachedSet.add(branch.VendAccount);
                }
            }
        }
            }
            while (query.next());
        }
    
        if (declarationSet.in(companyInfo.Name))
        {
            se = rcoadSet.getEnumerator();
            if (se.moveNext() && this.makeDocument(companyInfo.Name))
            {
                gniCode     = this.gniCode(CompanyInfoHelper::partyOKATOasOfDate_RU(companyInfo, journalTable.EndDate));
                this.fillHeader();
    
                do
                {
                    curRCOAD = se.current();
                    this.groupData();
                }
                while (se.moveNext());
                this.create1To2Sections();
    
                this.endDocument();
            }
        }
    
        taxPayerSing = '2';
        se = detachedSet.getEnumerator();
        while (se.moveNext())
        {
            curVendAccount  = se.current();
            vendTable       = VendTable::find(curVendAccount);
            inn             = vendTable.partyINNasOfDate_RU(journalTable.EndDate);
            kpp             = vendTable.partyKPPasOfDate_RU(journalTable.EndDate);
            okdp            = vendTable.partyOKDPasOfDate_RU(journalTable.EndDate);
            companyPhone    = vendTable.phone();
            curRCOAD        = vendTable.partyOKATOasOfDate_RU(journalTable.EndDate);
            gniCode         = this.gniCode(curRCOAD);
    
            if (findVendDirector)
            {
                select firstonly contactPerson
                    where contactPerson.ContactPersonId == vendTable.ContactPersonId;
    
                if (!contactPerson)
                {
                    select firstonly Party from contactPerson
                        where contactPerson.ContactForParty == vendTable.Party;
                }
    
                dirPersonName = DirPersonName::find(DirPerson::find(contactPerson.Party).RecId);
                firstName   = dirPersonName.FirstName;
                lastName    = dirPersonName.LastName;
                middleName  = dirPersonName.MiddleName;
            }
    
            if (this.makeDocument(curVendAccount))
            {
                this.fillHeader();
                this.groupData();
                this.create1To2Sections();
                this.endDocument();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printByMajorTaxPayer</Name>
				<Source><![CDATA[
    private void printByMajorTaxPayer()
    {
        SetEnumerator se = this.rcoadSet().getEnumerator();
    
        if (se.moveNext() && this.makeDocument(companyInfo.Name))
        {
            gniCode     = this.gniCode(CompanyInfoHelper::partyOKATOasOfDate_RU(companyInfo, journalTable.EndDate));
            this.fillHeader();
    
            do
            {
                curRCOAD = se.current();
                this.groupData();
            }
            while (se.moveNext());
                this.create1To2Sections();
    
            this.endDocument();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rcoadSet</Name>
				<Source><![CDATA[
    private Set rcoadSet(TaxAuthority _taxAuthority = '')
    {
        Set         registerSet = new Set(Types::String);
        RTax25Query query = RTax25Query::newParameters(RTax25RegisterType::AmountDifference, landTaxJournalTrans, isDetached);
    
        if (query.first(0, ReportBlockType::Footer))
        {
            do
            {
                registerSet.add(query.getField(#RCOAD));
            }
            while (query.next());
        }
    
        if (_taxAuthority && registerSet.elements())
        {
            return Set::intersection(registerSet, TaxAuthorityAddress::find(_taxAuthority).okatoSet_RU());
        }
    
        return registerSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundAmountStr</Name>
				<Source><![CDATA[
    protected str roundAmountStr(RAssetAmount _amount, str _dash = "")
    {
        return _amount ? num2str(_amount, 0, 0, 1, 0) : _dash;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        DirPartyTable leader;
        DirPersonName responsible,
                      leaderName;
    
        this.getLast();
    
        if (this.checkDocument())
        {
            leader          = DirPartyTable::findByName(OfficialsTable_RU::nameDirector());
            responsible     = DirPersonName::find(EmployeeTable_RU::findByEmployeeId(employeeId).worker().Person);
            leaderName      = DirPersonName::find(leader.RecId);
    
            inn             = companyInfo.partyINNasOfDate_RU(journalTable.EndDate);
            kpp             = companyInfo.partyKPPasOfDate_RU(journalTable.EndDate);
            okdp            = CompanyInfoHelper::partyOKDPasOfDate_RU(companyInfo, journalTable.EndDate);
            companyPhone    = companyInfo.phone();
            companyName     = companyInfo.Name;
    
            if (responsible.RecId)
            {
                taxPayerSing    = '2';
                firstName       = responsible.FirstName;
                lastName        = responsible.LastName;
                middleName      = responsible.MiddleName;
            }
            else if (leaderName.RecId)
            {
                taxPayerSing    = '1';
                firstName       = leaderName.FirstName;
                lastName        = leaderName.LastName;
                middleName      = leaderName.MiddleName;
            }
    
            try
            {
                if (taxDeclarationLocation == RAssetLandTaxDeclarationLocation::MajorTaxPayer ||
                    taxDeclarationLocation == RAssetLandTaxDeclarationLocation::AssigneeAccounting)
                {
                    this.printByMajorTaxPayer();
                }
                else // RAssetLandTaxDeclarationLocation::ImmovableGroundArea
                {    // RAssetLandTaxDeclarationLocation::ImmovableSubsoilArea
                    this.printByDetachedDepartment();
                }
            }
            catch (Exception::Error)
            {
                this.closeExcelDocument();
                throw error("@SYS18738");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxDeclarationType</Name>
				<Source><![CDATA[
    public RAssetAssessedTaxRegType taxDeclarationType()
    {
        return RAssetAssessedTaxRegType::LandTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateName</Name>
				<Source><![CDATA[
    protected str templateName()
    {
        return resourceStr(RAssetLandTaxDeclaration2011);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer          version  = conPeek(packedClass,1);
    
        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;
                break;
    
            default:
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@GLS117035";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        RAssetLandTaxDeclaration taxDeclaration = new RAssetLandTaxDeclaration();
    
        taxDeclaration.initValue(_args);
    
        if (taxDeclaration.prompt())
        {
            taxDeclaration.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		<Method><Name>isRetryable</Name><Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return false;
    }
]]></Source></Method></Methods>
	</SourceCode>
</AxClass>