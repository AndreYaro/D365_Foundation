<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendOpenTransEngine_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class CustVendOpenTransEngine_RU
{
    FormRun                     formRun;

    FormDataSource              debitCustVendTransOpen_ds;
    FormDataSource              debitCustVendTrans_ds;

    FormDataSource              creditCustVendTransOpen_ds;
    FormDataSource              creditCustVendTrans_ds;

    Common                      common;

    CustVendTable               custVendTable;
    TmpRecIDValue_RU            tmpRecIDValueDebit;
    TmpRecIDValue_RU            tmpRecIDValueCredit;

    CurrencyCode                currencyCode;
    CustVendAC                  custVendAC;
    DirPartyRecId               partyRecId;
    TransDate                   transactionDate;
    DiscGraceDays               discGraceDays;
    UnspecificSpecific          cashDiscUnspecificSpecific;

    QueryRun                    qrForCreateRslFactureJour;  //QueryRun for selected CustVendInvoiceJour

    //The Map keep RecIDs of CustVendTransOpen table selected for settlement and amounts are respective them
    Map                         mapSettlementTrans;

    RecordSortedList            rslFactureJour; //Keep records from FactureJour_RU table which need settlement

    Map                         mapCVTrans_FactureJourAmount; //Map of maps.
                                                               //   Key   -> CustVendTrans.recId
                                                               //   Value -> map:
                                                               //       Key   -> FactureJour_RU.FactureId
                                                               //       Value -> Struct containing amounts by invoice

    //ID tables are
    TableId                     custVendInvoiceJourID;
    TableId                     custVendInvoiceTransID;
    TableId                     custVendTableID;
    TableId                     custVendTransID;
    TableId                     custVendTransOpenID;

    KeepAmount_RU               debitAmount;
    KeepAmount_RU               creditAmount;

    //Datasources names are
    SysElementName              creditCustVendTransName;
    SysElementName              creditCustVendTransOpenName;
    SysElementName              debitCustVendTransName;
    SysElementName              debitCustVendTransOpenName;

    //Types filters are
    SettlementFilterType_RU     filterDebitType;
    SettlementFilterType_RU     filterCreditType;

    boolean                     needRefreshInvoiceTmpTable; //Do need all tempotrary table refresh binded with invoces calculate?

//Name fields of struct containing amounts by invoice
#define.amountNeedSettled('Need')           //Amount which need will settle
#define.amountAlreadySettled('Already')     //Amount which already settled
#define.AccountNum('AccountNum')
#define.RecId('RecId')
#define.RefRecId('RefRecId')
#define.AmountCur('AmountCur')
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createLookupForAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the agreements lookup.
    /// </summary>
    /// <param name="_ctrl">
    ///     The control for which lookup will be created.
    /// </param>
    /// <param name="_company">
    ///     The company account identifier; optional.
    /// </param>
    protected void createLookupForAgreement(
        FormStringControl   _ctrl,
        CompanyId           _company = curext())
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLookupForInvoice</Name>
				<Source><![CDATA[
    //Lookup creating for FactureJour_RU table
    protected void createLookupForInvoice(FormStringControl _ctrl)
    {
        FactureJour_RU::lookupFactureId(_ctrl, rslFactureJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMapCVTrans_FactureJourAmount</Name>
				<Source><![CDATA[
    protected Map createMapCVTrans_FactureJourAmount()
    {
        FactureCalcBalances_OnPayment_RU    factureCalcBalances;
        BookStructVATAmounts_RU     settledAmounts;

        FactureJour_RU      fJour;
        boolean             loop;
        Map                 map, mapRet;

        TransDate           settlementDate;
        RecId               transRecId, settlementRecId;

        MapIterator         it;
        Amount              amount;
        Struct              struct;

        Map                 tmpMap;

        //Get or create struct with date of invoice
        void getStruct()
        {
            settledAmounts = BookStructVATAmounts_RU::create(it.value());

            //Get map with data by "CustVendTrans.recID"
            if (mapRet.exists(transRecId))
                //Value exists
                map = mapRet.lookup(transRecId);
            else
            {//Value not exists
                map = new Map(Types::String, Types::Class);
                mapRet.insert(transRecId, map);
            }

            //Get struct
            if (map.exists(fJour.FactureId))
            {
                struct = map.lookup(fJour.FactureId);
                map.remove(fJour.FactureId);
            }
            else
                struct = new Struct(Types::Real, #amountNeedSettled, Types::Real, #amountAlreadySettled);
        }

        //--------------------------- start -----------------------------

        mapRet = new Map(extendedTypeId2Type(extendedTypeNum(RecId)), Types::Class);

        //Calculate amounts for selected FactureJour_Ru

        loop = rslFactureJour.first(fJour);

        while (loop)
        {
            factureCalcBalances = new FactureCalcBalances_OnPayment_RU(fJour);
            factureCalcBalances.calc();

            //Get MAp
            if (isAOS())
                //We work by AOs
                tmpMap = Map::create(factureCalcBalances.mapFactureAmounts().pack());
            else
                tmpMap = factureCalcBalances.mapFactureAmounts();

            it = new MapIterator(tmpMap);

            //Add amounts wich need will settle by invoice
            while (it.more())
            {
                transRecId = it.key();

                getStruct();  //Get or create struct with date of invoice

                //Calculate new amount
                amount = struct.value(#amountNeedSettled);
                amount += settledAmounts.amountInclVAT();

                struct.value(#amountNeedSettled, amount);

                map.insert(fJour.FactureId, struct);   //Save data

                it.next();
            }

            //Get MAp
            if (isAOS())
                //We work by AOs
                tmpMap = Map::create(factureCalcBalances.mapSettledAmounts().pack());
            else
                tmpMap = factureCalcBalances.mapSettledAmounts();

            it = new MapIterator(tmpMap);

            //Add amounts wich already settled by invoice
            while (it.more())
            {
                [settlementDate, settlementRecId, transRecId] = it.key();  // map always sorted by settlementDate

                getStruct();  //Get or create struct with date of invoice

                //Calculate new amount
                amount = struct.value(#amountAlreadySettled);
                amount += settledAmounts.amountInclVAT();

                struct.value(#amountAlreadySettled, amount);

                map.insert(fJour.FactureId, struct);   //Save data

                it.next();
            }

            loop = rslFactureJour.next(fJour);   //Next FactureJour_Ru
        }

        return mapRet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMapSettlementTrans</Name>
				<Source><![CDATA[
    protected void createMapSettlementTrans()
    {
        mapSettlementTrans = new Map(extendedTypeId2Type(extendedTypeNum(RecId)), Types::Enum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRslFactureJour</Name>
				<Source><![CDATA[
    //Return records from FactureJour_RU table which need settlement
    protected RecordSortedList createRslFactureJour()
    {
        RecordSortedList        rsl;
        CustVendInvoiceJour     custVendInvoiceJour;

        QueryRun                qr;
        QueryBuildDataSource    ds;
        QueryBuildRange         range;

        RecordSortedList    rslRet;

        FactureJour_RU      fJour;
        boolean             loop;

        rslRet = new RecordSortedList(tableNum(FactureJour_RU));

        rslRet.sortOrder(fieldNum(FactureJour_RU, FactureDate),
                          fieldNum(FactureJour_RU, FactureExternalId),
                          fieldNum(FactureJour_RU, ModifiedDateTime),
                          fieldNum(FactureJour_RU, RecId));

        //Create and initialize queryRun
        qr = this.qrForCreateRslFactureJour();

        ds = qr.query().dataSourceTable(custVendTransOpenID);

        range = findOrCreateRange_W(ds, fieldName2id(custVendTransOpenID, #AccountNum));
        range.value(custVendAC);

        qr.reset();

        //Create RecordSortedList with FactureJour_Ru
        while (qr.next())
        {
            custVendInvoiceJour = qr.get(custVendInvoiceJourID);

            //Get records FactureJour_RU table setlemented wich CustInvoiceJour
            rsl = custVendInvoiceJour.factureJourSortedList_RU();

            loop = rsl.first(fJour);

            while (loop)
            {
                //Add FactureJour_RU into rslRet if need
                if (! rslRet.find(fJour))
                    //Curent FactureJour_RU not exist into rslRet
                    rslRet.ins(fJour);

                loop = rsl.next(fJour);
            }
        }

        return rslRet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpRecIDGroupMap</Name>
				<Source><![CDATA[
    protected Map createTmpRecIDGroupMap(TmpRecIDValue_RU _tmpRecIDValue_RU, Query _query = null)
    {
        TmpRecIDValue_RU    tmpRecIDValue_RU;
        Map                 tmpRecIdGroupMap;

        QueryRun            queryRun;
        container           list;

        void processTmpRecIdValue()
        {
            if (tmpRecIdGroupMap.exists(tmpRecIDValue_RU.RefRecId))
            {
                list = tmpRecIdGroupMap.lookup(tmpRecIDValue_RU.RefRecId);
            }
            else
            {
                list = conNull();
            }

            list += tmpRecIDValue_RU.TempStr;

            tmpRecIdGroupMap.insert(tmpRecIDValue_RU.RefRecId, list);
        }

        tmpRecIdGroupMap = new Map(Types::Int64, Types::Container);
        tmpRecIDValue_RU.setTmpData(_tmpRecIDValue_RU);

        if (_query)
        {
            queryRun = new QueryRun(_query);
            queryRun.setCursor(_tmpRecIDValue_RU);

            while (queryRun.next())
            {
                tmpRecIDValue_RU = queryRun.get(tableNum(TmpRecIDValue_RU));
                processTmpRecIdValue();
            }
        }
        else
        {
            while select tmpRecIDValue_RU
            {
                processTmpRecIdValue();
            }
        }

        return tmpRecIdGroupMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpRecIDValue_RU</Name>
				<Source><![CDATA[
    //Create table with recIDs table VendTans are
    protected TmpRecIDValue_RU createTmpRecIDValue_RU()
    {
        TmpRecIDValue_RU    retTmpRecIDValue_RU;

        MapIterator         itTransRecID, itFactureJour;

        RecId               transRecID;
        FactureId_RU        factureID;

        retTmpRecIDValue_RU = TmpRecIDValue_RU::emptyTable();  //Temporary table must be create on server

        itTransRecID = new MapIterator(mapCVTrans_FactureJourAmount);

        while (itTransRecID.more())
        {
            transRecID = itTransRecID.key();

            itFactureJour = new MapIterator(itTransRecID.value());

            while (itFactureJour.more())
            {
                factureID = itFactureJour.key();

                retTmpRecIDValue_RU.clear();

                retTmpRecIDValue_RU.RefRecId = transRecID;
                retTmpRecIDValue_RU.TempStr  = factureID;
                retTmpRecIDValue_RU.insert();

                itFactureJour.next();
            }

            itTransRecID.next();
        }

        return retTmpRecIDValue_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode currencyCode(CurrencyCode _currencyCode = currencyCode)
    {
        currencyCode = _currencyCode;
        return currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendAC</Name>
				<Source><![CDATA[
    public CustVendAC custVendAC(CustVendAC _custVendAC = custVendAC)
    {
        custVendAC = _custVendAC;
        return custVendAC;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendTable</Name>
				<Source><![CDATA[
    public CustVendTable custVendTable(CustVendTable _custVendTable = custVendTable)
    {
        custVendTable = _custVendTable;
        return custVendTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFromCreditAmount</Name>
				<Source><![CDATA[
    public void deleteFromCreditAmount(RecId _recId)
    {
        creditAmount.delete(_recId);
        this.deleteFromMapSettlementTrans(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFromDebitAmount</Name>
				<Source><![CDATA[
    public void deleteFromDebitAmount(RecId _recId)
    {
        debitAmount.delete(_recId);
        this.deleteFromMapSettlementTrans(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFromMapSettlementTrans</Name>
				<Source><![CDATA[
    protected void deleteFromMapSettlementTrans(RecId _recId)
    {
        if (mapSettlementTrans.exists(_recId))
        {
            mapSettlementTrans.remove(_recId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSpecification</Name>
				<Source><![CDATA[
    private void deleteSpecification(Query _queryDebit, Query _queryCredit)
    {
        SetEnumerator               enumerator;
        CustVendOpenTransManager    custVendOpenTransManager;
        RefRecId                    refRecId;

        Set                         refRecIdSet;
        boolean                     showMsg;
        CustVendTransOpen           custVendTransOpen = new DictTable(custVendTransOpenID).makeRecord();

        refRecIdSet = new Set(Types::Int64);
        enumerator  = mapSettlementTrans.keySet().getEnumerator();

        while (enumerator.moveNext())
        {
            refRecId = enumerator.current();    //Get recID for CutVendTransOpen table from cache

            if (! this.findTransOpenRecIdFromQuery(_queryDebit, refRecId) &&
                ! this.findTransOpenRecIdFromQuery(_queryCredit, refRecId))
            {
                refRecIdSet.add(refRecId);
                showMsg = true;
            }
        }

        if (showMsg && Box::yesNo("@SYS24027", DialogButton::No, "@SYS17528", "@SYS29049") == DialogButton::Yes)
        {
            custVendOpenTransManager    = this.custVendOpenTransManager();
            enumerator          = refRecIdSet.getEnumerator();

            ttsbegin;

            while (enumerator.moveNext())
            {
                refRecId            = enumerator.current();

                select firstonly crosscompany custVendTransOpen
                    where custVendTransOpen.RecId == refRecId;

                custVendOpenTransManager.updateTransMarked(custVendTransOpen, NoYes::No);
                this.deleteFromMapSettlementTrans(refRecId);
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSpecificationFromDS</Name>
				<Source><![CDATA[
    protected void deleteSpecificationFromDS()
    {
        Query               queryDebit;
        Query               queryCredit;

        queryDebit = this.getQuery(debitCustVendTransOpen_ds);
        queryCredit = this.getQuery(creditCustVendTransOpen_ds);

        this.deleteSpecification(queryDebit, queryCredit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterLookup</Name>
				<Source><![CDATA[
    //Lookup creating for filter field
    public void filterLookup(SettlementFilterType_RU _settlementFilterType_RU,
                             FormStringControl       _cntr,
                             CompanyId               _company = curext())
    {
        switch (_settlementFilterType_RU)
        {
            case SettlementFilterType_RU::Agreement :
                //Lookup for Agreement
                this.createLookupForAgreement(_cntr, _company);
                break;

            case SettlementFilterType_RU::Invoice :
                //Lookup for Invoice
                this.createLookupForInvoice(_cntr);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransOpenRecIdFromQuery</Name>
				<Source><![CDATA[
    private boolean findTransOpenRecIdFromQuery(Query _query, RefRecId _refRecId)
    {
        Query                   q;
        QueryRun                qr;
        QueryBuildDataSource    ds;
        QueryBuildRange         range;
        CustVendTransOpen       localCustVendTransOpen;
        FieldId                 fieldId = fieldName2id(custVendTransOpenID, #RecID);

        //Create QueryRun
        q   = new Query(_query.pack());
        ds  = q.dataSourceTable(custVendTransOpenID);

       // Search recID of CutVendTransOpen table into selected of form records
        range = ds.addRange(fieldId);
        range.value(queryValue(_refRecId));

        qr  = new QueryRun(q);

        if (qr.next())
        {
            localCustVendTransOpen = qr.get(custVendTransOpenID);
        }

        return (localCustVendTransOpen.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCreditAmountCur</Name>
				<Source><![CDATA[
    public AmountMST getCreditAmountCur(RecId _recId)
    {
        return creditAmount.getAmountCur(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCreditAmountCurTranslate</Name>
				<Source><![CDATA[
    public AmountCur getCreditAmountCurTranslate(RecId _recId)
    {
        return creditAmount.getAmountCurTranslate(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCreditAmountMST</Name>
				<Source><![CDATA[
    public AmountMST getCreditAmountMST(RecId _recId)
    {
        return creditAmount.getAmountMST(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDebitAmountCur</Name>
				<Source><![CDATA[
    public AmountMST getDebitAmountCur(RecId _recId)
    {
        return debitAmount.getAmountCur(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDebitAmountCurTranslate</Name>
				<Source><![CDATA[
    public AmountCur getDebitAmountCurTranslate(RecId _recId)
    {
        return debitAmount.getAmountCurTranslate(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDebitAmountMST</Name>
				<Source><![CDATA[
    public AmountMST getDebitAmountMST(RecId _recId)
    {
        return debitAmount.getAmountMST(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQuery</Name>
				<Source><![CDATA[
    protected Query getQuery(FormDataSource _formDS)
    {
        if (_formDS.queryRun())
        {
            return _formDS.queryRun().query();
        }
        else
        {
            return _formDS.query();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainAmountCur</Name>
				<Source><![CDATA[
    public AmountCur getRemainAmountCur()
    {
        AmountCur           retAmount = 0;

        Set                 keySet;
        SetIterator         it;

        DebCredUnknown_RU   debCredUnknown;
        RecId               recId;

        keySet = mapSettlementTrans.keySet();

        it = new SetIterator(keySet);

        while (it.more())
        {
            recId = it.value();

            debCredUnknown = mapSettlementTrans.lookup(recId);

            switch (debCredUnknown)
            {
                case DebCredUnknown_RU::Credit :

                    retAmount  += creditAmount.getAmountCurTranslate(recId);
                    break;

                case DebCredUnknown_RU::Debit :

                    retAmount  += debitAmount.getAmountCurTranslate(recId);
                    break;

                case DebCredUnknown_RU::Unknown :
                    //Don't take into this branch
                    break;

                default :
                    throw error(Error::wrongUseOfFunction(funcName()));
            }

            it.next();
        }

        return retAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainAmountMST</Name>
				<Source><![CDATA[
    public AmountMST getRemainAmountMST()
    {
        AmountMST           retAmount = 0;

        Set                 keySet;
        SetIterator         it;

        DebCredUnknown_RU   debCredUnknown;
        RecId               recId;

        keySet = mapSettlementTrans.keySet();

        it = new SetIterator(keySet);

        while (it.more())
        {
            recId = it.value();

            debCredUnknown = mapSettlementTrans.lookup(recId);

            switch (debCredUnknown)
            {
                case DebCredUnknown_RU::Credit :

                    retAmount  += creditAmount.getAmountMST(recId);
                    break;

                case DebCredUnknown_RU::Debit :

                    retAmount  += debitAmount.getAmountMST(recId);
                    break;

                case DebCredUnknown_RU::Unknown :
                    //Don't take into this branch
                    break;

                default :
                    throw error(Error::wrongUseOfFunction(funcName()));
            }

            it.next();
        }

        return retAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDataSourceName</Name>
				<Source><![CDATA[
    protected void initDataSourceName()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFormDataSources</Name>
				<Source><![CDATA[
    protected void initFormDataSources()
    {
        int             dataSourceCount;
        int             cx;
        SysElementName  sysElementName;

        dataSourceCount = formRun.dataSourceCount();

        for (cx =1 ; cx <= dataSourceCount; cx++)
        {
            sysElementName = formRun.dataSource(cx).name();

            switch (sysElementName)
            {
                case creditCustVendTransName        :
                    creditCustVendTrans_ds = formRun.dataSource(cx);
                    break;
                case creditCustVendTransOpenName    :
                    creditCustVendTransOpen_ds = formRun.dataSource(cx);
                    break;
                case debitCustVendTransName         :
                    debitCustVendTrans_ds = formRun.dataSource(cx);
                    break;
                case debitCustVendTransOpenName     :
                    debitCustVendTransOpen_ds = formRun.dataSource(cx);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCommon</Name>
				<Source><![CDATA[
    //Initialization from common table [common == formRun.args().record()]
    protected void initFromCommon()
    {
        common  = formRun.args().record();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRemainAmount</Name>
				<Source><![CDATA[
    abstract public void initRemainAmount()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTableID</Name>
				<Source><![CDATA[
    //Initialize TableId
    abstract protected void initTableID()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoCreditAmount</Name>
				<Source><![CDATA[
    public void insertIntoCreditAmount( RecId               _recId,
                                        AmountCur           _amountCur,
                                        CurrencyCode        _currencyCode,
                                        DebCredUnknown_RU   _debCredUnknown = DebCredUnknown_RU::Unknown)
    {
        AmountMST       amountMST;
        AmountCur       amountCurTranslate;
        CurrencyCode    currencyCodeTranslate;

        currencyCodeTranslate = this.currencyCode();

        amountMST          = CurrencyExchangeHelper::mstAmount(_amountCur, _currencyCode);
        amountCurTranslate = CurrencyExchangeHelper::curAmount2CurAmount(_amountCur, _currencyCode, currencyCodeTranslate);

        creditAmount.insert( _recId,
                            _currencyCode,
                            _amountCur,
                            amountMST,
                            currencyCodeTranslate,
                            amountCurTranslate);

        //Marked this settlement amount
        if (_debCredUnknown != DebCredUnknown_RU::Unknown)
        {
            mapSettlementTrans.insert(_recId, _debCredUnknown);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoDebitAmount</Name>
				<Source><![CDATA[
    public void insertIntoDebitAmount(  RecId               _recId,
                                        AmountCur           _amountCur,
                                        CurrencyCode        _currencyCode,
                                        DebCredUnknown_RU   _debCredUnknown = DebCredUnknown_RU::Unknown)
    {
        AmountMST       amountMST;
        AmountCur       amountCurTranslate;
        CurrencyCode    currencyCodeTranslate;

        currencyCodeTranslate = this.currencyCode();

        amountMST          = CurrencyExchangeHelper::mstAmount(_amountCur, _currencyCode);
        amountCurTranslate = CurrencyExchangeHelper::curAmount2CurAmount(_amountCur, _currencyCode, currencyCodeTranslate);

        debitAmount.insert( _recId,
                            _currencyCode,
                            _amountCur,
                            amountMST,
                            currencyCodeTranslate,
                            amountCurTranslate);

        //Marked this settlement amount
        if (_debCredUnknown != DebCredUnknown_RU::Unknown)
        {
            mapSettlementTrans.insert(_recId, _debCredUnknown);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAmountForTrans</Name>
				<Source><![CDATA[
    //Get part amount of transaction for invoice
    public Amount invoiceAmountForTrans(RecId _transRecId, Range _strRange)
    {
        Amount                  amount;
        Set                     set;
        Map                     map;
        FactureId_RU            factureID;
        SetEnumerator           enumerator;
        Struct                  struct;

        if (mapCVTrans_FactureJourAmount.exists(_transRecId))
        {
            map = mapCVTrans_FactureJourAmount.lookup(_transRecId);
            set = this.strRangeFactureIdToSet(_transRecId, _strRange);

            enumerator = set.getEnumerator();

            while (enumerator.moveNext())
            {
                factureID = enumerator.current();

                if (map.exists(factureID))
                {
                    struct = map.lookup(factureID);

                    amount += struct.value(#amountNeedSettled) - struct.value(#amountAlreadySettled);
                }
            }
        }

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkActive</Name>
				<Source><![CDATA[
    public void linkActive(SettlementFilterType_RU  _filterDebitType, SettlementFilterType_RU  _filterCreditType)
    {
        this.initFromCommon();  //Initialization from common table

        needRefreshInvoiceTmpTable = true;

        this.createMapSettlementTrans();

        debitAmount.removeAll();
        creditAmount.removeAll();

        filterDebitType   = _filterDebitType;
        filterCreditType  = _filterCreditType;

        //Reset filters
        this.setQueryForDebitsDS();
        this.setQueryForCreditsDS();

        this.initRemainAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTransCredit</Name>
				<Source><![CDATA[
    public NoYes markTransCredit(boolean            _set,
                                 CustVendTransOpen  _custVendTransOpen,
                                 NoYes              _markTrans)
    {
        CustVendTrans   localCustVendTrans;
        TransDate       calcDiscDate = this.transactionDate();
        AmountCur       amountCur;
        NoYes           res = _markTrans;
        VendTransOpen   vendTransOpen;

        calcDiscDate =  CustVendTransOpenData::construct(_custVendTransOpen).calcDiscDate(this.transactionDate() - discGraceDays);

        localCustVendTrans.data(_custVendTransOpen.joinChild());

        if (_set)
        {
            if (_markTrans == NoYes::Yes)
            {
                if (this.paymentGroupEnabled(_custVendTransOpen, _markTrans))
                {
                    this.markTransPaymentGroup(_custVendTransOpen, _markTrans);
                }
                else
                {
                    if (! this.custVendOpenTransManager().getTransMarked(_custVendTransOpen))
                    {
                        amountCur = this.getCreditAmountCur(_custVendTransOpen.RecId);

                        if (! amountCur)
                        {
                            amountCur =  CustVendTransOpenData::construct(_custVendTransOpen).remainAmountCashDisc(calcDiscDate);

                            if (! amountCur)
                                amountCur =  _custVendTransOpen.AmountCur;

                            if (_custVendTransOpen.TableId == tableNum(VendTransOpen))
                            {
                                vendTransOpen = _custVendTransOpen;
                            }
                        }

                        this.custVendOpenTransManager().updateTransMarked(_custVendTransOpen, NoYes::Yes);

                        this.insertIntoCreditAmount(_custVendTransOpen.RecId,
                                                    amountCur,
                                                    localCustVendTrans.CurrencyCode,
                                                    DebCredUnknown_RU::Credit);
                    }
                    else
                    {
                        res = NoYes::No;
                        error("@SYS29065");
                    }
                }
            }
            else
            {
                if (this.paymentGroupEnabled(_custVendTransOpen, _markTrans))
                {
                    this.markTransPaymentGroup(_custVendTransOpen, _markTrans);
                }
                else
                {
                    this.custVendOpenTransManager().updateTransMarked(_custVendTransOpen, NoYes::No);

                    amountCur = CustVendTransOpenData::construct(_custVendTransOpen).remainAmountCashDisc(calcDiscDate);

                    if (_custVendTransOpen.TableId == tableNum(VendTransOpen))
                    {
                        vendTransOpen = _custVendTransOpen;
                    }

                    this.deleteFromCreditAmount(_custVendTransOpen.RecId);
                    this.insertIntoCreditAmount(_custVendTransOpen.RecId,
                                                amountCur,
                                                localCustVendTrans.CurrencyCode,
                                                DebCredUnknown_RU::Unknown);
                }
            }
        }
        else
        {
             res = (this.custVendOpenTransManager().getTransMarked(_custVendTransOpen) && !this.custVendOpenTransManager().getTransMarkedByOtherSpec(_custVendTransOpen));
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTransDebit</Name>
				<Source><![CDATA[
    public NoYes markTransDebit (boolean            _set,
                                 CustVendTransOpen  _custVendTransOpen,
                                 NoYes              _markTrans)
    {
        CustVendTrans   localCustVendTrans;
        TransDate       calcDiscDate = this.transactionDate();
        AmountCur       amountCur;
        NoYes           res = _markTrans;

        calcDiscDate =  CustVendTransOpenData::construct(_custVendTransOpen).calcDiscDate(this.transactionDate() - discGraceDays);

        localCustVendTrans.data(_custVendTransOpen.joinChild());

        if (_set)
        {
            if (_markTrans == NoYes::Yes)
            {
                if (this.paymentGroupEnabled(_custVendTransOpen, _markTrans))
                {
                    this.markTransPaymentGroup(_custVendTransOpen, _markTrans);
                }
                else
                {
                    if (! this.custVendOpenTransManager().getTransMarked(_custVendTransOpen))
                    {
                        amountCur = this.getDebitAmountCur(_custVendTransOpen.RecId);

                        if (! amountCur)
                        {
                            amountCur = CustVendTransOpenData::construct(_custVendTransOpen).remainAmountCashDisc(calcDiscDate);

                            if (! amountCur)
                                amountCur =  _custVendTransOpen.AmountCur;
                        }

                        this.custVendOpenTransManager().updateTransMarked(_custVendTransOpen, NoYes::Yes);

                        this.insertIntoDebitAmount(_custVendTransOpen.RecId,
                                                   amountCur,
                                                   localCustVendTrans.CurrencyCode,
                                                   DebCredUnknown_RU::Debit);
                    }
                    else
                    {
                        res = NoYes::No;
                        error("@SYS29065");
                    }
                }
            }
            else
            {
                if (this.paymentGroupEnabled(_custVendTransOpen, _markTrans))
                {
                    this.markTransPaymentGroup(_custVendTransOpen, _markTrans);
                }
                else
                {
                    this.custVendOpenTransManager().updateTransMarked(_custVendTransOpen, NoYes::No);

                    amountCur = CustVendTransOpenData::construct(_custVendTransOpen).remainAmountCashDisc(calcDiscDate);

                    this.deleteFromDebitAmount(_custVendTransOpen.RecId);
                    this.insertIntoDebitAmount(_custVendTransOpen.RecId,
                                                amountCur,
                                                localCustVendTrans.CurrencyCode,
                                                DebCredUnknown_RU::Unknown);
                }
            }
        }
        else
        {
            res = (this.custVendOpenTransManager().getTransMarked(_custVendTransOpen) && !this.custVendOpenTransManager().getTransMarkedByOtherSpec(_custVendTransOpen));
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTransPaymentGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs validation on the record to be marked or unmarked and then makes sure that any records
    ///    with a different payment group are unmarked and any with the same payment group are marked.
    /// </summary>
    /// <param name="_custVendTransOpen">
    ///     The record that will be marked or unmarked.
    /// </param>
    /// <param name="_markTrans">
    ///     Yes if the record is to be marked; otherwise, No.
    /// </param>
    protected void markTransPaymentGroup(
        CustVendTransOpen _custVendTransOpen,
        NoYes             _markTrans)
    {
        container dummy() // suppress BP deviation
        {
            return [ _custVendTransOpen, _markTrans ];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(FormRun _formRun)
    {
        if (!_formRun)
            throw error(Error::wrongUseOfFunction(funcName()));

        formRun = _formRun;

        common  = formRun.args().record();

        filterDebitType  = SettlementFilterType_RU::None;
        filterCreditType = SettlementFilterType_RU::None;

        needRefreshInvoiceTmpTable = true;

        this.createMapSettlementTrans();

        debitAmount     = new KeepAmount_RU();
        creditAmount    = new KeepAmount_RU();

        transactionDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        this.initTableID();             //Initialize TableId
        this.initDataSourceName();      //Initialize datasources
        this.initFormDataSources();     //Initialization are FormDataSources
        this.initFromCommon();          //Initialization from common table
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentGroupEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if grouping by payment group enabled
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// <c>CustVendTransOpen</c> record
    /// </param>
    /// <param name="_markTrans">
    /// Should transactions be marked
    /// </param>
    /// <returns>
    /// True if enabled; otherwise false
    /// </returns>
    public boolean paymentGroupEnabled(
        CustVendTransOpen _custVendTransOpen = null,
        NoYes             _markTrans         = NoYes::No)
    {
        container dummy() // suppress BP deviation
        {
            return [ _custVendTransOpen, _markTrans ];
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qrForCreateRslFactureJour</Name>
				<Source><![CDATA[
    protected QueryRun qrForCreateRslFactureJour()
    {
        Query                   q;
        QueryBuildDataSource    dsCutVendTransOpen, dsCutVendTrans, dsCustVendInvoiceJourID;

        if (!qrForCreateRslFactureJour)
        {
            q = new Query();

            dsCutVendTransOpen = q.addDataSource(custVendTransOpenID);

            dsCutVendTrans = dsCutVendTransOpen.addDataSource(custVendTransID);
            dsCutVendTrans.joinMode(JoinMode::InnerJoin);
            dsCutVendTrans.relations(true);

            dsCustVendInvoiceJourID = dsCutVendTrans.addDataSource(custVendInvoiceJourID);
            dsCustVendInvoiceJourID.joinMode(JoinMode::InnerJoin);
            dsCustVendInvoiceJourID.relations(true);

            qrForCreateRslFactureJour = new QueryRun(q);
        }

        return qrForCreateRslFactureJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshRslFactureJour</Name>
				<Source><![CDATA[
    //Refresh all data binded with invoces calculate
    final protected void refreshRslFactureJour()
    {
        MapIterator     itTransRecID;

        SetIterator     it;

        Map             map;
        Struct          struct;
        Amount          amountNeedSettled, amountAlreadySettled;

        FactureId_RU    factureID;

        if (! needRefreshInvoiceTmpTable)
            //Tables don't refresh
            return;

        needRefreshInvoiceTmpTable = false;

        //Create records from FactureJour_RU table which need settlement
        rslFactureJour = this.createRslFactureJour();

        mapCVTrans_FactureJourAmount = this.createMapCVTrans_FactureJourAmount();

        //Delete data for completely settled invoice
        itTransRecID = new MapIterator(mapCVTrans_FactureJourAmount);

        while (itTransRecID.more())
        {
            map = itTransRecID.value();

            it  = new SetIterator(map.keySet());

            while (it.more())
            {
                factureID = it.value();

                struct = map.lookup(factureID);

                amountNeedSettled    = struct.value(#amountNeedSettled);
                amountAlreadySettled = struct.value(#amountAlreadySettled);

                if ((amountNeedSettled == amountAlreadySettled) && (amountNeedSettled != 0))
                    //Delete data
                    map.remove(factureID);

                it.next();
            }

            itTransRecID.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCreditDefaultFilter</Name>
				<Source><![CDATA[
    protected void setCreditDefaultFilter(FormDataSource _formDataSource)
    {
        QueryBuildDataSource    dsCustVendTransOpen;
        QueryBuildRange         range;
        Query                   query;

        query               = this.getQuery(_formDataSource);
        dsCustVendTransOpen = query.dataSourceTable(custVendTransOpenID);

        range = findOrCreateRange_W(dsCustVendTransOpen, fieldName2id(custVendTransOpenID, #AmountCur));
        range.status(RangeStatus::Locked);
        range.value(strFmt('((%1 <= 0) || (%2 <= 0))', #AmountCur, #AmountCur));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDebitDefaultFilter</Name>
				<Source><![CDATA[
    protected void setDebitDefaultFilter(FormDataSource _formDataSource)
    {
        QueryBuildDataSource    dsCustVendTransOpen;
        QueryBuildRange         range;
        Query                   query;

        query               = this.getQuery(_formDataSource);
        dsCustVendTransOpen = query.dataSourceTable(custVendTransOpenID);

        range = findOrCreateRange_W(dsCustVendTransOpen, fieldName2id(custVendTransOpenID, #AmountCur));
        range.status(RangeStatus::Locked);
        range.value(strFmt('((%1 >= 0) || (%2 >= 0))', #AmountCur, #AmountCur));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFilterValue</Name>
				<Source><![CDATA[
    //Set filter value
    public void setFilterValue( SettlementFilterType_RU     _settlementFilterType_RU,
                                FormDataSource              _formDS,
                                Range                       _criteria1)
    {
        switch (_settlementFilterType_RU)
        {
            case SettlementFilterType_RU::Agreement :
                //Set value for Agreement filter
                this.setFilterValueForAgreement(_formDS, _criteria1);
                break;

            case SettlementFilterType_RU::Invoice :
                //Set value for Invoice filter
                this.setFilterValueForInvoice(_formDS, _criteria1);
                break;
        }

        this.deleteSpecificationFromDS(); //Delete specifications marked user but not selected into Ds

        _formDS.research();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFilterValueForAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the agreement filter value in the query.
    /// </summary>
    /// <param name="_formDS">
    ///     Datasource where filter value will be applied to.
    /// </param>
    /// <param name="_agreementId">
    ///     The filter value.
    /// </param>
    protected void setFilterValueForAgreement(FormDataSource _formDS, Range _agreementId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFilterValueForInvoice</Name>
				<Source><![CDATA[
    protected void setFilterValueForInvoice(FormDataSource _formDataSource, Range _criteria)
    {
        Query                   query;
        QueryBuildDataSource    qbds;
        QueryBuildRange         range;
        int                     occurence = 1;

        Map                     tmpRecIdGroupMap;
        MapEnumerator           enumerator;

        query   = new Query();
        qbds    = query.addDataSource(tableNum(TmpRecIDValue_RU));

        range   = findOrCreateRange_W(qbds, fieldNum(TmpRecIDValue_RU, TempStr));
        range.status(RangeStatus::Locked);
        range.value(_criteria);

        if (_formDataSource.name() == debitCustVendTransOpenName)
        {
            tmpRecIdGroupMap = this.createTmpRecIDGroupMap(tmpRecIDValueDebit, query);
        }
        else if (_formDataSource.name() == creditCustVendTransOpenName)
        {
            tmpRecIdGroupMap = this.createTmpRecIDGroupMap(tmpRecIDValueCredit, query);
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        query   = this.getQuery(_formDataSource);
        qbds    = query.dataSourceTable(custVendTransOpenID);

        enumerator = tmpRecIdGroupMap.getEnumerator();

        while (qbds.findRange(fieldName2id(custVendTransOpenID, #RefRecId), occurence))
        {
            range = qbds.findRange(fieldName2id(custVendTransOpenID, #RefRecId), occurence);
            if (enumerator.moveNext())
            {
                range.value(queryValue(enumerator.currentKey()));
            }
            else
            {
                range.value('');
            }
            occurence++;
        }

        while (enumerator.moveNext())
        {
            range = qbds.addRange(fieldName2id(custVendTransOpenID, #RefRecId));
            range.value(queryValue(enumerator.currentKey()));
            range.status(RangeStatus::Hidden);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPermanentFilterValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets permanent filter value.
    /// </summary>
    /// <param name="_formDataSource">
    ///     Datasource where filters will be applied to.
    /// </param>
    protected void setPermanentFilterValue(FormDataSource _formDataSource)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryClearFilter</Name>
				<Source><![CDATA[
    protected void setQueryClearFilter(FormDataSource _formDataSource)
    {
        QueryBuildDataSource    dsCustVendTrans;
        QueryBuildDataSource    dsCustVendTransOpen;
        Query                   query;

        query = this.getQuery(_formDataSource);
        SysQuery::clearDimensionRangesFromQuery(query);

        dsCustVendTrans     = query.dataSourceTable(custVendTransID);
        dsCustVendTransOpen = query.dataSourceTable(custVendTransOpenID);

        dsCustVendTrans.clearRanges();
        dsCustVendTransOpen.clearRanges();

        if (_formDataSource == debitCustVendTransOpen_ds)
        {
            this.setDebitDefaultFilter(_formDataSource);
        }
        else
        {
            this.setCreditDefaultFilter(_formDataSource);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryForCreditsDS</Name>
				<Source><![CDATA[
    public void setQueryForCreditsDS(SettlementFilterType_RU _settlementFilterType = filterCreditType)
    {
        filterCreditType = _settlementFilterType;

        this.setQueryIntoFilter(filterCreditType, creditCustVendTransOpen_ds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryForDebitsDS</Name>
				<Source><![CDATA[
    public void setQueryForDebitsDS(SettlementFilterType_RU _settlementFilterType = filterDebitType)
    {
        filterDebitType = _settlementFilterType;

        this.setQueryIntoFilter(filterDebitType, debitCustVendTransOpen_ds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryIntoAgreementFilter</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets agreement filter in the query.
    /// </summary>
    /// <param name="_formDataSource">
    ///     Datasource where filter will be applied to.
    /// </param>
    protected void setQueryIntoAgreementFilter(FormDataSource _formDataSource)
    {
        this.setQueryClearFilter(_formDataSource);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryIntoFilter</Name>
				<Source><![CDATA[
    protected void setQueryIntoFilter(SettlementFilterType_RU  _settlementFilterType_RU, FormDataSource _formDataSource)
    {
        switch (_settlementFilterType_RU)
        {
            case SettlementFilterType_RU::Agreement :
                this.setQueryIntoAgreementFilter(_formDataSource);
                break;
            case SettlementFilterType_RU::Invoice :
                this.setQueryIntoInvoiceFilter(_formDataSource);
                break;
            default :
                this.setQueryClearFilter(_formDataSource);
        }

        this.setPermanentFilterValue(_formDataSource);

        this.deleteSpecificationFromDS();

        _formDataSource.research();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQueryIntoInvoiceFilter</Name>
				<Source><![CDATA[
    protected void setQueryIntoInvoiceFilter(FormDataSource _formDataSource)
    {
        TmpRecIDValue_RU        tmpRecIDValue_RU;

        this.refreshRslFactureJour();

        this.setQueryClearFilter(_formDataSource);

        tmpRecIDValue_RU = this.createTmpRecIDValue_RU();

        if (_formDataSource.name() == debitCustVendTransOpenName)
        {
            tmpRecIDValueDebit.setTmpData(tmpRecIDValue_RU);
        }
        else if (_formDataSource.name() == creditCustVendTransOpenName)
        {
            tmpRecIDValueCredit.setTmpData(tmpRecIDValue_RU);
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleCredit</Name>
				<Source><![CDATA[
    public Amount settleCredit(
        boolean             set,
        CustVendTransOpen   _custVendTransOpen,
        Amount              u)
    {
        Amount          tmp;
        Amount          difference;
        CustVendTrans   localCustVendTrans;
        TransDate       calcDiscDate;
        AmountCur       amountCur;
        VendTransOpen   vendTransOpen;

        calcDiscDate =  CustVendTransOpenData::construct(_custVendTransOpen).calcDiscDate(this.transactionDate() - discGraceDays);
        localCustVendTrans.data(_custVendTransOpen.joinChild());

        if (set)
        {
            tmp = u;

            if (!tmp)
            {
                if (this.custVendOpenTransManager().getTransMarked(_custVendTransOpen))
                {
                    tmp = this.custVendOpenTransManager().parmSpecTransManager().findByRef(
                        _custVendTransOpen.company(),
                        _custVendTransOpen.TableId,
                        _custVendTransOpen.RecId).Balance01;
                }
            }
            else
            {
                tmp = CustVendTransOpenData::construct(_custVendTransOpen).findSettlementAmount(tmp, cashDiscUnspecificSpecific, calcDiscDate);
            }

            difference = this.getCreditAmountCur(_custVendTransOpen.RecId) - tmp;
            this.insertIntoCreditAmount(_custVendTransOpen.RecId, tmp, localCustVendTrans.CurrencyCode, DebCredUnknown_RU::Credit);

            if (this.custVendOpenTransManager().getTransMarked(_custVendTransOpen))
            {
                this.custVendOpenTransManager().updateSettleAmount(_custVendTransOpen,
                                                            this.getCreditAmountCur(_custVendTransOpen.RecId));
            }
        }
        else
        {
            if (_custVendTransOpen.RecId)
            {
                amountCur = this.getCreditAmountCur(_custVendTransOpen.RecId);

                if (! amountCur)
                {
                    if (this.custVendOpenTransManager().getTransMarked(_custVendTransOpen))
                    {
                        amountCur = this.custVendOpenTransManager().parmSpecTransManager().findByRef(
                            _custVendTransOpen.company(),
                            _custVendTransOpen.TableId,
                            _custVendTransOpen.RecId).Balance01;
                    }
                    else
                    {
                        amountCur = CustVendTransOpenData::construct(_custVendTransOpen).remainAmountCashDisc(calcDiscDate);
                        if (_custVendTransOpen.TableId == tableNum(VendTransOpen))
                        {
                            vendTransOpen = _custVendTransOpen;
                        }
                    }

                    this.insertIntoCreditAmount(_custVendTransOpen.RecId, amountCur, localCustVendTrans.CurrencyCode, DebCredUnknown_RU::Unknown);
                }
            }
        }

        return  _custVendTransOpen.RecId ? this.getCreditAmountCur(_custVendTransOpen.RecId) : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleDebit</Name>
				<Source><![CDATA[
    public Amount settleDebit(
        boolean             set,
        CustVendTransOpen   _custVendTransOpen,
        Amount              u)
    {
        Amount          tmp;
        Amount          difference;
        CustVendTrans   localCustVendTrans;
        TransDate       calcDiscDate;
        AmountCur       amountCur;

        calcDiscDate = CustVendTransOpenData::construct(_custVendTransOpen).calcDiscDate(transactionDate - discGraceDays);

        localCustVendTrans.data(_custVendTransOpen.joinChild());

        if (set)
        {
            tmp = u;

            if (! tmp)
            {
                if (this.custVendOpenTransManager().getTransMarked(_custVendTransOpen))
                {
                    tmp = this.custVendOpenTransManager().parmSpecTransManager().findByRef(
                        _custVendTransOpen.company(),
                        _custVendTransOpen.TableId,
                        _custVendTransOpen.RecId).Balance01;
                }
            }
            else
            {
                tmp = CustVendTransOpenData::construct(_custVendTransOpen).findSettlementAmount(tmp, cashDiscUnspecificSpecific, calcDiscDate);
            }

            difference = this.getDebitAmountCur(_custVendTransOpen.RecId) - tmp;
            this.insertIntoDebitAmount(_custVendTransOpen.RecId, tmp, localCustVendTrans.CurrencyCode, DebCredUnknown_RU::Debit);

            if (this.custVendOpenTransManager().getTransMarked(_custVendTransOpen))
            {
                this.custVendOpenTransManager().updateSettleAmount(_custVendTransOpen,
                                                            this.getDebitAmountCur(_custVendTransOpen.RecId));
            }
        }
        else
        {
            if (_custVendTransOpen.RecId)
            {
                if (! this.getDebitAmountCur(_custVendTransOpen.RecId))
                {
                    if (this.custVendOpenTransManager().getTransMarked(_custVendTransOpen))
                    {
                        amountCur = this.custVendOpenTransManager().parmSpecTransManager().findByRef(
                            _custVendTransOpen.company(),
                            _custVendTransOpen.TableId,
                            _custVendTransOpen.RecId).Balance01;
                    }
                    else
                    {
                        amountCur = CustVendTransOpenData::construct(_custVendTransOpen).remainAmountCashDisc(calcDiscDate);
                    }

                    this.insertIntoDebitAmount(_custVendTransOpen.RecId, amountCur, localCustVendTrans.CurrencyCode, DebCredUnknown_RU::Unknown);
                }
            }
        }

        return  _custVendTransOpen.RecId ? this.getDebitAmountCur(_custVendTransOpen.RecId) : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendOpenTransManager</Name>
				<Source><![CDATA[
    protected CustVendOpenTransManager custVendOpenTransManager()
    {
        Object object = formRun;

        return object.custVendTransOpenManager();
    }

]]></Source>
			</Method>
			<Method>
				<Name>strRangeFactureIdToSet</Name>
				<Source><![CDATA[
    protected Set strRangeFactureIdToSet(RecId _transRecId, Range _strRange)
    {
        Set     set, tmpSet;
        Map     map;

        FactureId_RU    factureId;
        SetIterator     it;

        set = new Set(Types::String);

        if (mapCVTrans_FactureJourAmount.exists(_transRecId))
        {
            map = mapCVTrans_FactureJourAmount.lookup(_transRecId);

            tmpSet = map.keySet();

            if (_strRange)
            {//There are fasctureIDs into conditions _strRange
                it  = new SetIterator(tmpSet);

                //Choose required fasctureIDs and add theirs into set
                while (it.more())
                {
                    factureId = it.value();

                    if (inRange(_strRange, factureId))
                        //Add factureId into set
                        set.add(factureId);

                    it.next();
                }
            }
            else
                //There aren't fasctureIDs into conditions _strRange. It equivalent that choosed all possible FactureIDs.
                set = Set::create(tmpSet.pack());
        }

        return  set;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionDate</Name>
				<Source><![CDATA[
    public TransDate transactionDate(TransDate _transactionDate = transactionDate)
    {
        transactionDate = _transactionDate;
        return transactionDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    public void updateNow()
    {
        debitAmount.removeAll();
        creditAmount.removeAll();

        this.createMapSettlementTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCompany</Name>
				<Source><![CDATA[
    protected CompanyId validateCompany(CompanyId _company)
    {
        DataArea dataArea;
        select firstonly Id from dataArea
            where dataArea.Id == _company;

        return dataArea.Id ? dataArea.Id : curext();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>