<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CzCustPostAdvanceInvoice</Name>
	<SourceCode>
		<Declaration><![CDATA[
final class CzCustPostAdvanceInvoice extends RunBase
{
    private const str LocalizationFeatureReference = 'EEU-00044';
    CzCustAdvanceInvoiceTable invoiceTable;

    boolean                   isPostingOK;
    TypeOfCreditmaxCheck      typeOfCreditmaxCheck;

    Voucher                   voucherNumber;
    RefRecId                  numberSequenceTableVoucher;
    JournalId                 journalNum;
    TransDate                 originalInvoiceDate;

    LedgerVoucherGroup        ledgerVoucherGroup;

    DialogField               fieldFiscalDocType;
    PlFiscalDocType           fiscalDocType;

    #ISOCountryRegionCodes

    #define.CurrentVersion(1)
    #localmacro.CurrentList
        fiscalDocType
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allocateNumAndVoucher</Name>
				<Source><![CDATA[
    private container allocateNumAndVoucher()
    {
        RefRecId                invoiceId, voucherId;
        Num                     invoiceNumber;
        RefRecId                scopeId = NumberSeqScopeFactory::createDefaultScope().getId();
        NumberSequenceReference numberSequenceReference;
        NumberSequenceReference voucherSequenceReference;
        boolean                 voucherEqualsNumber;

        if (invoiceTable.NumberSequenceGroup)
        {
            switch (invoiceTable.Type)
            {
                case AdvanceInvoiceType_W::Common               :
                    invoiceId = NumberSequenceGroupRef::findNaturalKey(
                                                                NumberSequenceDatatype::find(CustParameters::numRefAdvanceInvoiceID_W().NumberSequenceDatatype).RecId,
                                                                scopeId,
                                                                invoiceTable.NumberSequenceGroup).NumberSequenceId;
                    voucherId = NumberSequenceGroupRef::findNaturalKey(
                                                                NumberSequenceDatatype::find(CustParameters::numRefAdvanceInvoiceVoucher_W().NumberSequenceDatatype).RecId,
                                                                scopeId,
                                                                invoiceTable.NumberSequenceGroup).NumberSequenceId;
                    break;
                case AdvanceInvoiceType_W::CreditNote           :
                    invoiceId = NumberSequenceGroupRef::findNaturalKey(
                                                                NumberSequenceDatatype::find(CustParameters::numRefAdvanceInvoiceCreditNoteID_W().NumberSequenceDatatype).RecId,
                                                                scopeId,
                                                                invoiceTable.NumberSequenceGroup).NumberSequenceId;
                    voucherId = NumberSequenceGroupRef::findNaturalKey(
                                                                NumberSequenceDatatype::find(CustParameters::numRefAdvanceInvoiceCreditNoteVoucher_W().NumberSequenceDatatype).RecId,
                                                                scopeId,
                                                                invoiceTable.NumberSequenceGroup).NumberSequenceId;
                    break;
                case AdvanceInvoiceType_W::Reversal             :
                case AdvanceInvoiceType_W::ReversalCancellation :
                    invoiceId = NumberSequenceGroupRef::findNaturalKey(
                                                                NumberSequenceDatatype::find(CustParameters::numRefAdvanceInvoiceReversalID_W().NumberSequenceDatatype).RecId,
                                                                scopeId,
                                                                invoiceTable.NumberSequenceGroup).NumberSequenceId;
                    voucherId = NumberSequenceGroupRef::findNaturalKey(
                                                                NumberSequenceDatatype::find(CustParameters::numRefAdvanceInvoiceReversalVoucher_W().NumberSequenceDatatype).RecId,
                                                                scopeId,
                                                                invoiceTable.NumberSequenceGroup).NumberSequenceId;
                    break;
            }
        }

        if (! invoiceId)
        {
            switch (invoiceTable.Type)
            {
                case AdvanceInvoiceType_W::Common               :
                    numberSequenceReference = CustParameters::numRefAdvanceInvoiceID_W();
                    break;
                case AdvanceInvoiceType_W::CreditNote           :
                    numberSequenceReference = CustParameters::numRefAdvanceInvoiceCreditNoteID_W();
                    break;
                case AdvanceInvoiceType_W::Reversal             :
                case AdvanceInvoiceType_W::ReversalCancellation :
                    numberSequenceReference = CustParameters::numRefAdvanceInvoiceReversalID_W();
                    break;
            }

            invoiceId = numberSequenceReference.NumberSequenceId;
        }

        if (! voucherId)
        {
            switch (invoiceTable.Type)
            {
                case AdvanceInvoiceType_W::Common               :
                    voucherSequenceReference = CustParameters::numRefAdvanceInvoiceVoucher_W();
                    break;
                case AdvanceInvoiceType_W::CreditNote           :
                    voucherSequenceReference = CustParameters::numRefAdvanceInvoiceCreditNoteVoucher_W();
                    break;
                case AdvanceInvoiceType_W::Reversal             :
                case AdvanceInvoiceType_W::ReversalCancellation :
                    voucherSequenceReference = CustParameters::numRefAdvanceInvoiceReversalVoucher_W();
                    break;
            }

            voucherId = voucherSequenceReference.NumberSequenceId;
        }

        if (numberSequenceReference              &&
            voucherSequenceReference             &&
            voucherSequenceReference.AllowSameAs &&
            (NumberSequenceDatatype::find(numberSequenceReference.NumberSequenceDatatype).DatatypeId
                == NumberSequenceDatatype::find(voucherSequenceReference.NumberSequenceDatatype).DataTypeSameAsId))
        {
            voucherEqualsNumber = true;
            voucherNumber       = invoiceNumber;
        }

        if (invoiceTable.CustPostingProfile)
        {
            [invoiceNumber, voucherNumber] = NumberSeq::newGetNumAndVoucherFromId(invoiceId, voucherId, voucherEqualsNumber).numAndVoucher();
            numberSequenceTableVoucher  = NumberSequenceTable::find(voucherId).RecId;
        }
        else
        {
            invoiceNumber = NumberSeq::newGetNumFromId(invoiceId).num();
            voucherNumber = '';
        }

        return [invoiceNumber, voucherNumber];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDateAmountMismatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the date and amounts on the advance invoice match those on the linked sales order.
    /// </summary>
    /// <returns>
    /// true if the date and amounts are valid; otherwise, false.
    /// </returns>
    public boolean checkDateAmountMismatch()
    {
        CzCustAdvanceInvoiceLink     custVendLink;
        CustParameters               custParam = CustParameters::find();
        CustTrans                    custTrans;
        AmountMST                    paymentAmountMST;
        AmountCur                    paymentAmountCur;
        Set                          currencySet;
        boolean                      ret = true,
                                     isDateMismatch,
                                     checkAmountMismatch = (custParam.AdvInvAmount_W != ErrorTolerance::Accept);

        if (custParam.AdvInvDate_W == ErrorTolerance::Accept && !checkAmountMismatch)
        {
            return true;
        }

        currencySet = new Set(Types::String);

        while select crosscompany custVendLink
            where custVendLink.InvoiceCompany       == invoiceTable.company()
               && custVendLink.AdvanceInvoiceRecId  == invoiceTable.RecId
        {
            if (custVendLink.TransDate != invoiceTable.InvoiceDate)
            {
                isDateMismatch = true;
                if (!checkAmountMismatch)
                {
                    break;
                }
            }

            if (checkAmountMismatch)
            {
                custTrans = CustTrans::findVoucherDate(custVendLink.Voucher, custVendLink.TransDate);

                paymentAmountCur += custTrans.remainAmountCur();
                paymentAmountMST += custTrans.remainAmountMST();
                currencySet.add(custTrans.CurrencyCode);
            }
        }

        if (isDateMismatch &&
            custParam.AdvInvDate_W != ErrorTolerance::Accept)
        {
            if (custParam.AdvInvDate_W == ErrorTolerance::Error)
            {
                ret = checkFailed("@GLS114095");
                checkAmountMismatch = false;
            }
            else
            {
                ret = (Box::yesNo("@GLS114094", DialogButton::No) == DialogButton::Yes);
            }
        }

        if (checkAmountMismatch &&
            ((currencySet.elements() == 1 && invoiceTable.InvoiceAmount != -paymentAmountCur) ||
            (currencySet.elements() >  1 && invoiceTable.amountMST(invoiceTable.InvoiceAmount) != -paymentAmountMST)))
        {
            if (custParam.AdvInvAmount_W == ErrorTolerance::Error)
            {
                ret = checkFailed("@GLS114093");
            }
            else
            {
                ret = ret && (Box::yesNo("@GLS114092", DialogButton::No) == DialogButton::Yes);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    /// in the AOT.
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase ret = super();

        fieldFiscalDocType = ret.addFieldValue(enumStr(PlFiscalDocType), fiscalDocType);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLedgerVoucher</Name>
				<Source><![CDATA[
    private void endLedgerVoucher()
    {
        if (ledgerVoucherGroup)
        {
            ledgerVoucherGroup.end();
            ledgerVoucherGroup = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        boolean ret = super();

        fiscalDocType = fieldFiscalDocType.value();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInvoiceTable</Name>
				<Source><![CDATA[
    protected void initInvoiceTable()
    {
        invoiceTable = CzCustAdvanceInvoiceTable::findRecId(invoiceTable.RecId, true);
        invoiceTable.calcInvoiceAmount();

        if (! invoiceTable.CustPostingProfile)
        {
            invoiceTable.CustPostingProfile = CustParameters::find().AdvanceInvoicePostingProfile_W;
        }

        if (invoiceTable.CurrencyCode == CompanyInfoHelper::standardCurrency() || ! invoiceTable.ExchRate)
        {
            invoiceTable.ExchRate       = ExchangeRateHelper::exchRate(invoiceTable.CurrencyCode, invoiceTable.InvoiceDate, Currency::noYes2UnknownNoYes(invoiceTable.Triangulation));
            invoiceTable.ExchrateSecond = ExchangeRateHelper::exchRateSecond(invoiceTable.CurrencyCode, invoiceTable.InvoiceDate, Currency::noYes2UnknownNoYes(invoiceTable.Triangulation));
        }

        switch (invoiceTable.Type)
        {
            case AdvanceInvoiceType_W::Common :
                if (invoiceTable.creditNote())
                {
                    invoiceTable.Type = AdvanceInvoiceType_W::CreditNote;
                }
                else
                {
                    invoiceTable.Type = AdvanceInvoiceType_W::Common;
                }
                break;
            default                           :
                // leave as is
        }

        if (fiscalDocType == PlFiscalDocType::Invoice)
        {
            invoiceTable.FiscalDocState_PL = PlFiscalDocState::Invoice;
        }
        else
        {
            invoiceTable.FiscalDocState_PL = PlFiscalDocState::FiscalDocument;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerJournalTrans</Name>
				<Source><![CDATA[
    protected void initLedgerJournalTrans(
        LedgerJournalTrans          _ledgerJournalTrans,
        CzCustAdvanceInvoiceLine    _invoiceLine,
        LedgerJournalEngine         _ledgerJournalEngine)
    {
        CustTable custTable = invoiceTable.custTable_InvoiceAccount();

        _ledgerJournalTrans.clear();
        _ledgerJournalTrans.Voucher                 = invoiceTable.Voucher;
        _ledgerJournalTrans.TransDate               = invoiceTable.InvoiceDate;

        _ledgerJournalTrans.JournalNum              = journalNum;
        _ledgerJournalTrans.DocumentDate            = invoiceTable.DocumentDate;
        _ledgerJournalTrans.Txt                     = _invoiceLine.Description;
        _ledgerJournalTrans.Company                 = curext();

        _ledgerJournalTrans.TaxGroup                = _invoiceLine.TaxGroup;
        _ledgerJournalTrans.TaxItemGroup            = _invoiceLine.TaxItemGroup;

        _ledgerJournalTrans.VatDueDate_W            = invoiceTable.VatDueDate_W;

        _ledgerJournalTrans.TaxPeriodPaymentCode_PL = custTable.TaxPeriodPaymentCode_PL;

        if (TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(_ledgerJournalTrans.ledgerJournalTable().JournalType))
        {
            custTable.copyPrimaryRegistrationNumberToVATMap(_ledgerJournalTrans, invoiceTable.InvoiceDate);
        }
        else
        {
            _ledgerJournalTrans.vatNumJournal = custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, invoiceTable.InvoiceDate);
        }

        _ledgerJournalTrans.Addressing_PL           = custTable.address();
        _ledgerJournalTrans.CustVendName_PL         = custTable.name();
        _ledgerJournalTrans.CustVendAccount_PL      = '';

        _ledgerJournalTrans.OffsetAccountType       = LedgerJournalACType::Ledger;
        _ledgerJournalTrans.OffsetLedgerDimension   = LedgerDimensionFacade::serviceCreateLedgerDimension(_invoiceLine.OffsetLedgerDimension ? _invoiceLine.OffsetLedgerDimension : CustParameters::find().AdvanceInvoiceOffsetLedgerDimension_W, invoiceTable.DefaultDimension);
        _ledgerJournalTrans.AmountCurCredit         = _invoiceLine.AmountCur;

        _ledgerJournalTrans.OffsetDefaultDimension        = invoiceTable.DefaultDimension;

        _ledgerJournalTrans.CurrencyCode            = invoiceTable.CurrencyCode;
        _ledgerJournalEngine.currencyModified(_ledgerJournalTrans);
        _ledgerJournalTrans.ExchRate                = invoiceTable.ExchRate;
        _ledgerJournalTrans.ExchRateSecond          = invoiceTable.ExchrateSecond;
        _ledgerJournalTrans.Triangulation           = invoiceTable.Triangulation;

        _ledgerJournalTrans.Invoice                 = invoiceTable.InvoiceId;
        _ledgerJournalTrans.DelayTaxCalculation     = NoYes::Yes;

        _ledgerJournalTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
        GlobalizationInstrumentationHelper::featureRun(LocalizationFeatureReference, funcName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [ #CurrentVersion, #CurrentList ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceTable</Name>
				<Source><![CDATA[
    public CzCustAdvanceInvoiceTable parmInvoiceTable(CzCustAdvanceInvoiceTable _invoiceTable = invoiceTable)
    {
        invoiceTable = _invoiceTable;
        return invoiceTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOriginalInvoiceDate</Name>
				<Source><![CDATA[
    public TransDate parmOriginalInvoiceDate(TransDate _originalInvoiceDate = originalInvoiceDate)
    {
        originalInvoiceDate = _originalInvoiceDate;
        return originalInvoiceDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    protected void post()
    {
        LedgerVoucher               ledgerVoucher;
        LedgerVoucherObject         ledgerVoucherObject;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerPostingController ledgerPostingController;
        LedgerBondClient_RU         ledgerBondClient;
        LedgerBondId_RU             ledgerBondId;

        CzCustAdvanceInvoiceLine    invoiceLine;
        AmountCur                   lineAmountExclTax;
        CurrencyExchangeHelper      exchangeRateHelper;

        TaxVoucherService   taxVoucherService;
        LedgerJournalTable          ledgerJournalTable;
        LedgerJournalTrans          ledgerJournalTrans;
        LedgerJournalEngine         ledgerJournalEngine;
        Map                         ledgerJournalTransMap;

        CustVoucher     custVoucher;
        CustTrans       custTrans;

        if (! invoiceTable.CustPostingProfile)
        {
            return;
        }

        // init ledger voucher
        ledgerVoucherObject = LedgerVoucherObject::newVoucher(invoiceTable.Voucher,
                                                              invoiceTable.InvoiceDate,
                                                              SysModule::Cust,
                                                              LedgerTransType::Cust);
        ledgerVoucherObject.parmVoucherCheck(false);
        if (invoiceTable.InvoiceAmount < 0 &&
            (invoiceTable.Type == AdvanceInvoiceType_W::CreditNote && CustParameters::find().AdvanceInvoiceCreditCorrection_W) ||
            (invoiceTable.Type == AdvanceInvoiceType_W::Reversal   && CustParameters::find().AdvanceInvoiceReversalCorrection_W))
        {
            ledgerVoucherObject.parmIsCorrectionDefault(NoYes::Yes);
        }

        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary, SysModule::Cust, voucherNumber);
        ledgerVoucher.parmCompanyId(curext());
        ledgerVoucher.addVoucher(ledgerVoucherObject);

        ledgerVoucherGroup = LedgerVoucherGroup::construct();
        ledgerVoucherGroup.addLedgerVoucher(ledgerVoucher);

        ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }

        // create customer transactions
        custVoucher = CustVendVoucher::construct(SysModule::Cust,
                                                 invoiceTable.InvoiceAccount,
                                                 invoiceTable.InvoiceAmount,
                                                 invoiceTable.CurrencyCode,
                                                 LedgerTransTxt::CustInvoiceCust,
                                                 invoiceTable.DefaultDimension,
                                                 invoiceTable.CustPostingProfile,
                                                 LedgerPostingType::CustBalance,
                                                 invoiceTable.Payment,
                                                 SettlementType::None,
                                                 HcmWorker::userId2Worker(curUserId()),
                                                 NoYes::Yes,
                                                 '',
                                                 dateNull(),
                                                 0,
                                                 invoiceTable.DueDate,
                                                 invoiceTable);
        custVoucher.parmDocumentDate(invoiceTable.DocumentDate);
        custVoucher.parmTransTxt("@GLS107927");

        custVoucher.parmExchRate         (invoiceTable.ExchRate);
        custVoucher.parmExchRateSecondary(invoiceTable.ExchrateSecond);
        custVoucher.parmTriangulation    (invoiceTable.Triangulation);
        custVoucher.parmTypeOfCreditmaxCheck(CustParameters::find().CreditMaxCheck);

        custVoucher.setTransRef(CustTransRefType::Invoice, invoiceTable.Voucher);
        custVoucher.post(ledgerVoucher, custTrans);

        custTrans.Invoice = invoiceTable.InvoiceId;
        switch (invoiceTable.Type)
        {
            case AdvanceInvoiceType_W::Common               :
                custTrans.Txt = "@GLS107927";
                break;

            case AdvanceInvoiceType_W::CreditNote           :
                custTrans.Txt = "@GLS114116";
                break;

            case AdvanceInvoiceType_W::Reversal             :
                custTrans.Txt = "@GLS114123";
                break;

            case AdvanceInvoiceType_W::ReversalCancellation :
                custTrans.Txt = "@GLS114123" + ' ' + '(' + "@SYS108685" + ')';
                break;
        }
        custTrans.doUpdate();

        if (ledgerBondClient && invoiceTable.InvoiceAmount)
        {
            ledgerBondId = ledgerBondClient.lastVrefId();
        }

        journalNum = JournalTableData::newTable(ledgerJournalTable).nextJournalId();
        ledgerJournalTable.JournalNum = journalNum;
        ledgerJournalTable.JournalName = "@SYS60854";
        ledgerJournalTable.LedgerJournalInclTax = NoYes::Yes;
        ledgerJournalTable.NumberSequenceTable = numberSequenceTableVoucher;
        ledgerJournalTable.insert();

        ledgerJournalEngine = new LedgerJournalEngine(null);
        ledgerJournalEngine.newJournalActive(ledgerJournalTable);

        taxVoucherService = TaxVoucherService::construct(ledgerJournalTable);
        ledgerJournalTransMap = new Map(Types::Int64, Types::Int64);

        // Create LedgerJournalTrans records
        while select invoiceLine
            where invoiceLine.ParentRecId == invoiceTable.RecId
        {
            this.initLedgerJournalTrans(ledgerJournalTrans, invoiceLine, ledgerJournalEngine);
            ledgerJournalTransMap.insert(invoiceLine.RecId, ledgerJournalTrans.RecId);
        }

        this.clearTaxOnJournal();

        // Calculate taxes
        if ((invoiceTable.type == AdvanceInvoiceType_W::Reversal || invoiceTable.type == AdvanceInvoiceType_W::ReversalCancellation)
            && originalInvoiceDate)
        {
            LedgerJournalTrans::getTaxInstance(journalNum, invoiceTable.Voucher, invoiceTable.InvoiceId, true, null, false, dateNull(), originalInvoiceDate);
        }
        else
        {
            TaxVoucherService::calculateTaxForJournal(ledgerJournalTable.JournalNum);
        }

        // Add transactions to voucher
        while select TableId, RecId, AmountCur, OffsetLedgerDimension from invoiceLine
            where invoiceLine.ParentRecId == invoiceTable.RecId
        {
            ledgerJournalTrans = LedgerJournalTrans::findRecId(ledgerJournalTransMap.lookup(invoiceLine.RecId), false);

            Debug::assert(ledgerJournalTrans.RecId != 0);

            lineAmountExclTax = invoiceLine.AmountCur + taxVoucherService.getTransactionalTaxAmountForLine(ledgerJournalTrans);

            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucherObject.parmAccountingDate());
            exchangeRateHelper.parmExchangeRate1(ledgerJournalTrans.ExchRate);
            exchangeRateHelper.parmExchangeRate2(ledgerJournalTrans.ExchRateSecond);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                        ledgerVoucherObject,
                                                                        LedgerPostingType::CustBalance,
                                                                        ledgerJournalTrans.OffsetLedgerDimension,
                                                                        invoiceTable.CurrencyCode,
                                                                        - lineAmountExclTax,
                                                                        exchangeRateHelper);

            ledgerVoucherTransObject.parmTaxParentReferenceTableId(invoiceLine.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(invoiceLine.RecId);

            ledgerVoucherObject.addTrans(ledgerVoucherTransObject);
        }

        // post taxes
        ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);
        taxVoucherService.post(ledgerPostingController);

        if (ledgerBondClient)
        {
            // in PL corrective credit note case customer transaction amount can be zero, thus no ledger transaction is created
            if (ledgerBondId)
            {
                ledgerBondClient.bondVRef2Log(ledgerBondId);
            }

            ledgerBondClient.bondLog2Log();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prompt</Name>
				<Source><![CDATA[
    // PlFiscalDocType -based combo box is the only posting option on the dialog
    // if not in country context - previous behavior preserved, i.e. no prompt
    public boolean prompt()
    {
        boolean ret = ! SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]);

        return ret || super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSettleCreditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates settle credit note needed.
    /// </summary>
    /// <returns>True if settle credit note needed; otherwise false.</returns>
    [Replaceable]
    protected boolean canSettleCreditNote()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        Counter infoCounter = infologLine();
        LedgerJournalTable  ledgerJournalTable;

        isPostingOK = false;

        try
        {
            ttsbegin;

            this.initInvoiceTable();

            if (! this.validate())
                throw error("@SYS25904");

            [ invoiceTable.InvoiceId, invoiceTable.Voucher ] = this.allocateNumAndVoucher();

            invoiceTable.calcDue();

            // initializes ledgerVoucherGroup
            this.post();

            invoiceTable.Posted    = NoYes::Yes;
            invoiceTable.Log       = "";

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            {
                invoiceTable.createPlCustAdvanceInvoiceItems();
            }

            invoiceTable.update();

            if (this.canSettleCreditNote())
            {
                // uses ledgerVoucherGroup
                this.settleCreditNote();
            }

            // posts ledgerVoucherGroup
            this.endLedgerVoucher();

            // Workaround to avoid trying to delete uncommited tax for every line
            update_recordset ledgerJournalTable
                setting JournalType = ledgerJournalType::Assets
                where ledgerJournalTable.JournalNum == journalNum;

            // Remove ledger journal records used for posting
            LedgerJournalTrans::deleteLineAfterPosting(journalNum);

            this.clearTaxOnJournal();

            delete_from ledgerJournalTable
                where ledgerJournalTable.JournalNum == journalNum;

            ttscommit;

            if (invoiceTable.Type == AdvanceInvoiceType_W::Common ||
                invoiceTable.Type == AdvanceInvoiceType_W::CreditNote)
            {
                info(strFmt("@GLS108256", invoiceTable.InvoiceId));
            }

            isPostingOK = true;
        }

        catch (Exception::Deadlock)
        {
            retry;
        }

        catch (Exception::Error)
        {
            ttsbegin;

            invoiceTable     = CzCustAdvanceInvoiceTable::findRecId(invoiceTable.RecId, true);
            invoiceTable.Log = Info::infoCon2Str(infolog.copy(infoCounter + 1, infologLine()));
            invoiceTable.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleCreditNote</Name>
				<Source><![CDATA[
    protected void settleCreditNote()
    {
        CzCustAdvanceInvoiceTable origInvoiceTable;
        CzCustAdvanceInvoiceLine  origInvoiceLine, curInvoiceLine, correctiveLine;
        AmountCur                 origAmount, tmpSettleAmount;

        Map                       settlementMap = new Map(Types::Container, Types::Real);
        MapIterator               settlementMapIterator;

        CustTable                 custTable;
        CustTrans                 curCustTrans,     origCustTrans;
        CustTransOpen             curCustTransOpen, origCustTransOpen;
        CustSettlement            custSettlement;

        SpecTransManager          specTransManager;
        OffsetVoucher             offsetVoucher;
        CustVendSettle            custVendSettle;
        SettleDatePrinc           datePrinciple;
        TransDate                 datePrincipleSaveDate;

        Voucher                   origVoucher;
        TransDate                 oridTransDate;

        if (! invoiceTable.CustPostingProfile || invoiceTable.Type == AdvanceInvoiceType_W::Common)
            return;

        origAmount = invoiceTable.origInvoiceAmountCur();
        // positive corrective note; same sign - can not settle
        if (origAmount * invoiceTable.InvoiceAmount > 0)
            return;

        while select RecId, AmountCur from curInvoiceLine
            where curInvoiceLine.ParentRecId == invoiceTable.RecId
        join RecId from origInvoiceLine
            where origInvoiceLine.RecId      == curInvoiceLine.OrigAdvanceInvoiceLineRecId
        join Voucher, InvoiceDate from origInvoiceTable
            where origInvoiceTable.RecId     == origInvoiceLine.ParentRecId
        {
            select sum(AmountCur) from correctiveLine
            where correctiveLine.ParentRecId                   == invoiceTable.RecId &&
                  correctiveLine.AdvanceInvoiceLineInternalRef == curInvoiceLine.RecId &&
                  correctiveLine.RecId                         != curInvoiceLine.RecId;

            if (settlementMap.exists([ origInvoiceTable.Voucher, origInvoiceTable.InvoiceDate ]))
            {
                tmpSettleAmount = settlementMap.lookup([ origInvoiceTable.Voucher, origInvoiceTable.InvoiceDate ]);
            }
            else
            {
                tmpSettleAmount = 0;
            }

            settlementMap.insert([ origInvoiceTable.Voucher, origInvoiceTable.InvoiceDate ],
                                 tmpSettleAmount + curInvoiceLine.AmountCur + correctiveLine.AmountCur);
        }

        settlementMapIterator = new MapIterator(settlementMap);

        custVendSettle        = CustVendSettle::construct(SysModule::Cust);
        datePrinciple         = custVendSettle.datePrinciple();
        datePrincipleSaveDate = custVendSettle.saveDate();

        custTable             = CustTable::find(invoiceTable.InvoiceAccount);
        curCustTrans          = CustTrans::findVoucherDate(invoiceTable.Voucher, invoiceTable.InvoiceDate);
        curCustTransOpen      = curCustTrans.transOpen();

        while (settlementMapIterator.more() && curCustTransOpen)
        {
            [ origVoucher, oridTransDate ] = settlementMapIterator.key();
            tmpSettleAmount                = settlementMapIterator.value();

            if (tmpSettleAmount)
            {
                origCustTrans     = CustTrans::findVoucherDate(origVoucher, oridTransDate);
                origCustTransOpen = origCustTrans.transOpen();

                specTransManager  = SpecTransManager::newFromSpec(origCustTrans);
                if (specTransManager.getSpecTransCount())
                    throw error("@GLS101992");

                tmpSettleAmount = sign(tmpSettleAmount) * min(abs(tmpSettleAmount), abs(curCustTransOpen.AmountCur), abs(origCustTransOpen.AmountCur));

                specTransManager.insert(curCustTransOpen.company(),
                                        curCustTransOpen.TableId,
                                        curCustTransOpen.RecId,
                                        tmpSettleAmount,
                                        curCustTrans.CurrencyCode);
                specTransManager.insert(origCustTransOpen.company(),
                                        origCustTransOpen.TableId,
                                        origCustTransOpen.RecId,
                                        - tmpSettleAmount,
                                        origCustTrans.CurrencyCode);

                offsetVoucher = OffsetVoucher::construct(SysModule::Cust, SettlementType::SelectedTransact, origCustTrans);
                offsetVoucher.parmUseDatePrinciple_RU(false);

                custVendSettle = CustVendSettle::newOffsetVoucher(SysModule::Cust, offsetVoucher, ledgerVoucherGroup);
                custVendSettle.settleNow(origCustTrans.company(), origCustTrans.TableId, origCustTrans.RecId, true);

                while select forupdate custSettlement
                    where (custSettlement.TransCompany     == curCustTrans.DataAreaId &&
                           custSettlement.TransRecId       == curCustTrans.RecId      &&
                           custSettlement.AccountNum       == curCustTrans.AccountNum) ||
                          (custSettlement.OffsetCompany    == curCustTrans.DataAreaId &&
                           custSettlement.OffsetRecid      == curCustTrans.RecId      &&
                           custSettlement.OffsetAccountNum == curCustTrans.AccountNum)
                {
                    custSettlement.CanBeReversed = NoYes::No;
                    custSettlement.update();
                }
            }

            curCustTransOpen = curCustTrans.transOpen();

            settlementMapIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTaxOnJournal</Name>
				<Source><![CDATA[
    private void clearTaxOnJournal()
    {
        LedgerJournalTable ledgerJournalTable;

        select firstonly TableId, RecId from ledgerJournalTable
            where ledgerJournalTable.JournalNum == journalNum;
        
        TaxUncommitted::deleteForInvoice(
            ledgerJournalTable.TableId, 
            ledgerJournalTable.RecId,
            invoiceTable.Voucher,
            invoiceTable.InvoiceId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [ version, #CurrentList ] = _packedClass;
                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
    {
        boolean                  ok = super(_calledFrom);
        CustTable                custTable;

        CzCustAdvanceInvoiceLine invoiceLine;

        AmountCur                 amountOrigOpen;
        boolean                   oneCurrency;

        if (! invoiceTable)
        {
            throw error("@SYS26860");
        }
        if (invoiceTable.Posted)
        {
            ok = checkFailed("@GLS108255");
        }
        if (! CustTable::exist(invoiceTable.OrderAccount))
        {
            ok = checkFailed(strFmt(CustTable::txtNotExist(), invoiceTable.OrderAccount));
        }
        custTable = invoiceTable.custTable_InvoiceAccount();

        if (! custTable)
        {
            ok = checkFailed(strFmt(CustTable::txtNotExist(), invoiceTable.InvoiceAccount));
        }
        if (ok)
        {
            if (! custTable.checkAccountBlocked(invoiceTable.InvoiceAmount))
            {
                ok = false;
            }
        }

        if (!this.checkDateAmountMismatch())
        {
            ok = false;
        }

        select count(RecId)
        from invoiceLine
            where invoiceLine.ParentRecId == invoiceTable.RecId;

        if (! invoiceLine.RecId)
            ok = checkFailed("@SYS69823");

        if (invoiceTable.CustPostingProfile || CustParameters::find().AdvanceInvoicePostingProfile_W)
        {
            if (! CustParameters::find().AdvanceInvoiceOffsetLedgerDimension_W)
            {
                ok = checkFailed("@GLS114134");
            }

            if (! invoiceTable.DocumentDate)
            {
                ok = checkFailed(strFmt("@SYS84378", fieldPName(CzCustAdvanceInvoiceTable, DocumentDate)));
            }

            if (! invoiceTable.VatDueDate_W &&
                // The error should not be raised for PL context with customer-specific field unchecked
                ! (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) && (!custTable.MandatoryVatDate_PL)))
            {
                select firstonly RecId from invoiceLine
                    where invoiceLine.ParentRecId == invoiceTable.RecId &&
                          invoiceLine.TaxGroup                          &&
                          invoiceLine.TaxItemGroup;
                if (invoiceLine.RecId)
                {
                    ok = checkFailed(strFmt("@SYS84378", fieldPName(CzCustAdvanceInvoiceTable, VatDueDate_W)));
                }
            }
        }

        if (invoiceTable.creditNote())
        {
            if (- invoiceTable.InvoiceAmount > invoiceTable.origAdvanceInvoiceAmount())
            {
                ok = checkFailed("@GLS114119");
            }

            if (ok && invoiceTable.Type == AdvanceInvoiceType_W::CreditNote)
            {
                [ amountOrigOpen, oneCurrency ] = invoiceTable.origPaymentAmountCur_Open();
                if (oneCurrency &&
                    (- invoiceTable.InvoiceAmount > amountOrigOpen))
                {
                    ok = checkFailed(strFmt("@GLS114120", amountOrigOpen));
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CzCustPostAdvanceInvoice construct()
    {
        return new CzCustPostAdvanceInvoice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@GLS108361";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        CzCustAdvanceInvoiceTable invoiceTable;
        Object                    invoiceTable_ds;

        CzCustPostAdvanceInvoice  post;

        invoiceTable = _args.record();
        if (FormDataUtil::isFormDataSource(invoiceTable))
        {
            invoiceTable_ds = FormDataUtil::getFormDataSource(invoiceTable);
        }

        post = CzCustPostAdvanceInvoice::construct();
        post.parmInvoiceTable(invoiceTable);

        if (post.prompt())
        {
            post.runOperation();

            if (invoiceTable && invoiceTable_ds)
            {
                invoiceTable_ds.reRead();
                invoiceTable_ds.reFresh();
                invoiceTable_ds.active();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newRun</Name>
				<Source><![CDATA[
    public static void newRun(CzCustAdvanceInvoiceTable _invoiceTable)
    {
        CzCustPostAdvanceInvoice post = CzCustPostAdvanceInvoice::construct();

        post.parmInvoiceTable(_invoiceTable);
        post.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>