<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchCopying</Name>
	<SourceCode>
		<Declaration><![CDATA[
[SalesPurchCopyFactory(SalesPurchCopy::CopyAllHeader, tableStr(PurchTable))]
[SalesPurchCopyFactory(SalesPurchCopy::CopyAllLines, tableStr(PurchTable))]
[SalesPurchCopyFactory(SalesPurchCopy::CopyJournalHeader, tableStr(PurchTable))]
[SalesPurchCopyFactory(SalesPurchCopy::CopyJournalLines, tableStr(PurchTable))]
public class PurchCopying extends PurchCopyingBase
{
    PurchTable              purchTable;
    PriceDiscPolicySystem   cachedSystemEntryChangePolicyNoLink;
    PriceDiscPolicySystem   cachedSystemEntryChangePolicyNoLinkZero;
    PriceDiscSystemSource   cachedSystemEntrySource;
    PriceDiscSystemSource   cachedSystemEntrySourceZero;
    boolean                 purchTableHasNoLines;
    Set                     usedLineNumbers;
    boolean                 renumberLines;

    // <GIN><GEERU>
    #ISOcountryRegionCodes
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkHeaderAgreement</Name>
				<Source><![CDATA[
    // </GEERU></GIN>

    /// <summary>
    /// Validates the header record against the matching agreement.
    /// </summary>
    /// <param name="_header">
    /// A header record.
    /// </param>
    /// <returns>
    /// true if the validation passes; otherwise, false.
    /// </returns>
    public boolean checkHeaderAgreement(Common _header)
    {
        AgreementHeaderExtRecId_RU  agreementHeaderExt = this.headerAgreementExt(_header);
        boolean                     ret = true;
        PurchTable_RU               purchTable_RU = purchTable.purchTable_RU();

        if (agreementHeaderExt && purchTable_RU.AgreementHeaderExt_RU && agreementHeaderExt != purchTable_RU.AgreementHeaderExt_RU)
        {
            ret = checkFailed("@GLS222709");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the line is valid.
    /// </summary>
    /// <param name="_purchLine">
    ///    The purchase line to be validated.
    /// </param>
    /// <returns>
    ///    true if the line is valid; otherwise, false.
    /// </returns>
    public boolean checkLine(PurchLine _purchLine)
    {
        EcoResCategory  ecoResCategory;

        //Validate category used in the line exists and is active
        if (_purchLine.ProcurementCategory)
        {
            ecoResCategory = EcoResCategory::find(_purchLine.ProcurementCategory);

            if (ecoResCategory)
            {
                //Category is not active
                if (!ecoResCategory.IsActive)
                {
                    throw error(strFmt("@SYS309006", ecoResCategory.Name));
                }
            }
            else
            {
                //Category does not exist
                throw error("@SYS309007");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLineAgreement</Name>
				<Source><![CDATA[
    public boolean checkLineAgreement(Common _line, AgreementHeaderExtRecId_RU _newAgreementHeaderExt = 0)
    {
        AgreementHeaderExtRecId_RU agreementHeaderExt = this.lineAgreementExt(_line);
        boolean                    ret                = true;
        PurchTable_RU              purchTable_RU      = purchTable.purchTable_RU();

        if (agreementHeaderExt)
        {
            if (!((purchTable_RU.AgreementHeaderExt_RU && agreementHeaderExt == purchTable_RU.AgreementHeaderExt_RU)               ||
                 (!purchTable_RU.AgreementHeaderExt_RU && _newAgreementHeaderExt && agreementHeaderExt == _newAgreementHeaderExt)))
            {
                ret = checkFailed("@GLS222711");
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLinesAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates all line records against the matching agreement.
    /// </summary>
    /// <returns>
    /// true if the validation passes; otherwise, false.
    /// </returns>
    public boolean checkLinesAgreement()
    {
        AgreementHeaderExtRecId_RU  agreementHeaderExt;
        boolean                     ret = true;

        select count(RecId) from tmpFrmVirtualHeader;

        if (tmpFrmVirtualHeader.RecId == 1)
        {
            select firstonly tmpFrmVirtualHeader;

            agreementHeaderExt = this.headerAgreementExt();
        }

        while select tmpFrmVirtualLines order by LineNum
        {
            ret = this.checkLineAgreement(null, agreementHeaderExt);

            if (! ret)
            {
                break;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Copies the exchange rate.
    /// </summary>
    /// <param name="_exchRate">
    ///   An exchange rate.
    /// </param>
    protected void copyExchRate(ExchRate _exchRate)
    {
        // Does nothing because it is only a method stub for inherited classes.
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFromInvoice_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the record ID from <c>VendInvoiceJour</c> table record to <c>PurchTable</c> table record
    /// </summary>
    /// <param name="_vendInvoiceJour">
    /// A <c>VendInvoiceJour</c> table record
    /// </param>
    protected void copyFromInvoice_BR(VendInvoiceJour _vendInvoiceJour)
    {
        FiscalDocument_BR fiscalDocument;
        PurchTable_BR     purchTable_BR;

        fiscalDocument = FiscalDocument_BR::findByRef(_vendInvoiceJour.TableId, _vendInvoiceJour.RecId);

        Debug::assert(fiscalDocument.RecId > 0);

        if (this is PurchCopying_VoidFiscalDocument_BR)
        {
            purchTable_BR = purchTable.purchTable_BR();
            purchTable_BR.InvoiceRefRecId_BR = _vendInvoiceJour.RecId;
            purchTable.packPurchTable_BR(purchTable_BR);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFromInvoiceTrans_BR</Name>
				<Source><![CDATA[
    public void copyFromInvoiceTrans_BR(VendInvoiceTrans _vendInvoiceTrans)
    {
        if (purchTable.purchTable_BR().InvoiceRefRecId_BR)
        {
            return;
        }

        this.copyFromInvoice_BR(_vendInvoiceTrans.vendInvoiceJour());

        purchTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyHeader</Name>
				<Source><![CDATA[
    void copyHeader()
    {
        //should be reread, because purchTable was selected outside transaction scope
        purchTable.reread();

        using (var activityContext = instrumentationLogger.purchCopyingActivities().copyHeader())
        {
            select firstonly tmpFrmVirtualHeader;

            if (tmpFrmVirtualHeader)
            {
                Common fromTrans = this.copyHeaderFromSource(tmpFrmVirtualHeader);

                using (SysInstrumentationActivityContext activityContextRecord = instrumentationLogger.purchCopyingActivities().copyHeaderRecord(fromTrans))
                {
                    // <GEERU>
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                    {
                        AgreementHeaderExt_RU agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(purchTable.DefaultDimension);
                        PurchAgreementHeader purchAgreementHeader    = PurchAgreementHeader::find(agreementHeaderExt.AgreementHeader);
                        if (purchAgreementHeader && purchAgreementHeader.VendAccount == purchTable.OrderAccount)
                        {
                            PurchTable_RU purchTable_RU = purchTable.purchTable_RU();
                            purchTable_RU.AgreementHeaderExt_RU = agreementHeaderExt.RecId;
                            purchTable.packPurchTable_RU(purchTable_RU);

                            purchTable.MatchingAgreement     = purchAgreementHeader.RecId;
                        }
                        else
                        {
                            purchTable.DefaultDimension = AgreementHeaderExt_RU::clearAgreementDimension(purchTable.DefaultDimension);
                        }
                    }
                    // </GEERU>

                    //Check for inconsistency since currency code was read outside TTS first time
                    if (headerCurrencyCode != purchTable.CurrencyCode)
                    {
                        purchTable.reread();
                        throw error("@SYS18722");
                    }

                    if (copyMarkup)
                    {
                        Markup::delete(purchTable);
                    }

                    if (convertCurrency)
                    {
                        purchTable.convertCurrencyCode(purchTable.CurrencyCode, tradeCurencyConversion);
                    }

                    if (tmpFrmVirtualHeader.TableNum == tableNum(PurchTable))
                    {
                        ProjId projId = PurchTable::findRecId(tmpFrmVirtualHeader.RecordNo).ProjId;
                        if (copyPrecisely && projId)
                        {
                            purchTable.ProjId = projId;
                        }
                    }

                    if (purchTable.validateWrite())
                    {
                        this.setPriceDiscHeaderChangePolicy(tmpFrmVirtualHeader.TableNum, purchTable);
                        purchTable.update();
                    }
                    else
                    {
                        purchTable.reread();
                        throw error("@SYS18722");
                    }

                    activityContext
                        .addCustomProperty(tableStr(PurchTable), int642Str(purchTable.RecId));

                    tmpFrmVirtualHeader.delete();

                    if (copyMarkup)
                    {
                        Markup::copy(reverseSign,fromTrans,purchTable);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyHeaderFromSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the purchase order from the source.
    /// </summary>
    /// <param name = "_tmpFrmVirtualHeader">A <c>TmpFrmVirtual</c> record.</param>
    /// <returns>A <c>Common</c> record, which is the source record from which the purchase order was copied.</returns>
    protected Common copyHeaderFromSource(TmpFrmVirtual _tmpFrmVirtualHeader)
    {
        Common fromTrans;

        switch (_tmpFrmVirtualHeader.TableNum)
        {
            case tableNum(PurchTable):
                fromTrans = this.copyFromPurchTable(_tmpFrmVirtualHeader);
                break;
            case tableNum(VendInvoiceJour)   :
                fromTrans = this.copyFromVendInvoiceJour(_tmpFrmVirtualHeader);
                break;
            case tableNum(VendPackingSlipJour )  :
                fromTrans = this.copyFromVendPackingSlipJour(_tmpFrmVirtualHeader);
                break;
            case tableNum(VendPurchOrderJour)   :
                fromTrans = this.copyFromVendPurchOrderJour(_tmpFrmVirtualHeader);
                break;
        }

        return fromTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFromPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies from a purchase order.
    /// </summary>
    /// <param name = "_tmpFrmVirtualHeader">A <c>TmpFrmVirtual</c> record, which is the source record.</param>
    /// <returns>A <c>PurchTable</c> record.</returns>
    protected PurchTable copyFromPurchTable(TmpFrmVirtual _tmpFrmVirtualHeader)
    {
        PurchTable fromTrans = PurchTable::findRecId(tmpFrmVirtualHeader.RecordNo);
        purchTable.initFromPurchTable(fromTrans);

        if (copyPrecisely)
        {
            purchTable.InventSiteId           = fromTrans.InventSiteId;
            purchTable.InventLocationId       = fromTrans.InventLocationId;
        }

        return fromTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFromVendInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies from a purchase order invoice.
    /// </summary>
    /// <param name = "_tmpFrmVirtualHeader">A <c>TmpFrmVirtual</c> record, which is the source record.</param>
    /// <returns>A <c>VendInvoiceJour</c> record.</returns>
    protected VendInvoiceJour copyFromVendInvoiceJour(TmpFrmVirtual _tmpFrmVirtualHeader)
    {
        VendInvoiceJour fromTrans = VendInvoiceJour::findRecId(_tmpFrmVirtualHeader.RecordNo);

        //<GBR>
        if (BrazilParameters::isEnabled())
        {
            this.copyFromInvoice_BR(fromTrans);
        }
        //</GBR>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) 
            || (PurchCopyExchRateInEEURegionFlight::instance().isEnabled() 
            && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL])))
        {
            this.copyExchRate(fromTrans.(fieldNum(VendInvoiceJour, ExchRate)));
        }

        purchTable.initFromVendInvoiceJour(fromTrans);
        purchTable.setEndDiscFromVendInvoiceJour(fromTrans);

        return VendInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFromVendPackingSlipJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies from a purchase order packing slip.
    /// </summary>
    /// <param name = "_tmpFrmVirtualHeader">A <c>TmpFrmVirtual</c> record, which is the source record.</param>
    /// <returns>A <c>VendPackingSlipJour</c> record.</returns>
    protected VendPackingSlipJour copyFromVendPackingSlipJour(TmpFrmVirtual _tmpFrmVirtualHeader)
    {
        VendPackingSlipJour fromTrans = VendPackingSlipJour::findRecId(_tmpFrmVirtualHeader.RecordNo);
        purchTable.initFromVendPackingSlipJour(fromTrans);

        return fromTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyFromVendPurchOrderJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies from a purchase order confirmation.
    /// </summary>
    /// <param name = "_tmpFrmVirtualHeader">A <c>TmpFrmVirtual</c> record, which is the source record.</param>
    /// <returns>A <c>VendPurchOrderJour</c> record.</returns>
    protected PurchTableHistory copyFromVendPurchOrderJour(TmpFrmVirtual _tmpFrmVirtualHeader)
    {
        PurchTableHistory fromTrans = VendPurchOrderJour::findRecId(tmpFrmVirtualHeader.RecordNo).purchTableHistory();
        purchTable.copyFromPurchTableHistory(fromTrans);

        return fromTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiatePurchLineCopyFromSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>PurchLineCopyFromSource</c> class.
    /// </summary>
    /// <param name = "_purchLine">A <c>PurchLine</c> record to copy to.</param>
    /// <param name = "_tmpFrmVirtualLines">A <c>TmpFrmVirtual</c> record which is the source for the copy.</param>
    /// <returns>An instance of <c>PurchLineCopyFromSource</c> class.</returns>
    protected PurchLineCopyFromSource instantiatePurchLineCopyFromSource(
        PurchLine _purchLine,
        TmpFrmVirtual _tmpFrmVirtualLine)
    {
        return PurchLineCopyFromSource::construct(_purchLine, purchTable, _tmpFrmVirtualLine, this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyLine</Name>
				<Source><![CDATA[
    protected void copyLine(TmpFrmVirtual _tmpFrmVirtualLine)
    {
        PurchLine purchLine;

        ttsbegin;

        purchLine.clear();
        purchLine.initFromPurchTable(purchTable);
        purchLine.initValue();

        PurchLineCopyFromSource purchLineCopyFromSource = this.instantiatePurchLineCopyFromSource(purchLine, _tmpFrmVirtualLine);

        using (SysInstrumentationActivityContext activityContext = instrumentationLogger.purchCopyingActivities().copyLine(purchLineCopyFromSource))
        {
            this.updateGeneralBudgetReservationsLineRef(purchLine, _tmpFrmVirtualLine);
        
            isCopyValid = purchLineCopyFromSource.canCopy();

            if (!isCopyValid)
            {
                ttsabort;
                return;
            }

            isCopyValid = purchLineCopyFromSource.copy();

            if (!isCopyValid)
            {
                ttsabort;
                return;
            }

            if ((deleteLines || purchTableHasNoLines)
                && !usedLineNumbers.in(purchLineCopyFromSource.retrieveSourceLineNumber()))
            {
                purchLine.LineNumber = purchLineCopyFromSource.retrieveSourceLineNumber();
                renumberLines = true;
            }

            this.createLine(purchLine);

            if (FeatureStateProvider::isFeatureEnabled(AssetReversePOForeignCurrencyFeature::instance()))
            {
                purchLineCopyFromSource.updateAssetCreditNotePurchLine();
            }

            usedLineNumbers.add(purchLine.LineNumber);
            this.updatePriceDiscLineChangePolicy(purchLine);

            purchLineCopyFromSource.updateCopiedLine(purchLine, purchTable);

            activityContext
                .addCustomProperty(tableStr(PurchLine), int642Str(purchLine.RecId))
                .addCustomProperty(tableStr(PurchTable), int642Str(purchTable.RecId));

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateGeneralBudgetReservationsLineRef</Name>
				<Source><![CDATA[
    protected void updateGeneralBudgetReservationsLineRef(PurchLine purchLine, TmpFrmVirtual _tmpFrmVirtualLine)
    {
        PurchLine purchLineLocal;

        select BudgetReservationLine_PSN from purchLineLocal
            where purchLineLocal.PurchId == _tmpFrmVirtualLine.Id
                && purchLineLocal.LineNumber == _tmpFrmVirtualLine.LineNum;

        BudgetReservationLineRecId_PSN budgetReservationLineRecId = purchLineLocal.BudgetReservationLine_PSN;

        if (budgetReservationLineRecId)
        {
            purchLine.BudgetReservationLine_PSN = budgetReservationLineRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the purchase order line being copied.
    /// </summary>
    /// <param name = "_purchLine">A <c>PurchLine</c> record.</param>
    protected void createLine(PurchLine _purchLine)
    {
        using (ProjPurchLineParameters insertParameters = ProjPurchLineParameters::newSkipLoadTableUpdate(copyPrecisely))
        {
            _purchLine.createLine(true,              //_validation                  = false
            false,             //_initFromPurchTable          = false
            false,             //_initFromItemOrCategory      = false
            false,             //_calcInventQty               = false  //InventQty is calculated anyway by initFromInventTable.
            !copyMarkup,       //_searchMarkup                = true
            searchPrice,       //_searchPrice                 = false
            false,             //_ignorePurchTableInventDim   = false
            false,             //_searchAgreementLine         = false
            true,              //_setRemain                   =  true
            true               //_skipPurchTableUpdate        = false
            );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePriceDiscLineChangePolicy</Name>
				<Source><![CDATA[
    protected void updatePriceDiscLineChangePolicy(PurchLine _purchLine)
    {
        if (_purchLine.PurchaseType != PurchaseType::ReturnItem)
        {
            if (_purchLine.MatchingAgreementLine)
            {
                this.setPriceDiscLineChangePolicy(tmpFrmVirtualLines.TableNum, _purchLine);
            }
            else
            {
                if (!_purchLine.PurchPrice)
                {
                    if (cachedSystemEntryChangePolicyNoLinkZero)
                    {
                        _purchLine.SystemEntryChangePolicy = cachedSystemEntryChangePolicyNoLinkZero;
                        _purchLine.SystemEntrySource       = cachedSystemEntrySourceZero;
                    }
                    else
                    {
                        this.setPriceDiscLineChangePolicy(tmpFrmVirtualLines.TableNum, _purchLine);
                        cachedSystemEntryChangePolicyNoLinkZero = _purchLine.SystemEntryChangePolicy;
                        cachedSystemEntrySourceZero             = _purchLine.SystemEntrySource;
                    }
                }
                else
                {
                    if(cachedSystemEntryChangePolicyNoLink)
                    {
                        _purchLine.SystemEntryChangePolicy = cachedSystemEntryChangePolicyNoLink;
                        _purchLine.SystemEntrySource       = cachedSystemEntrySource;
                    }
                    else
                    {
                        this.setPriceDiscLineChangePolicy(tmpFrmVirtualLines.TableNum, _purchLine);
                        cachedSystemEntryChangePolicyNoLink = _purchLine.SystemEntryChangePolicy;
                        cachedSystemEntrySource             = _purchLine.SystemEntrySource;
                    }
                }
            }
            _purchLine.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyRBOLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>RetailPackagePurch</c> record based on an existing one.
    /// </summary>
    /// <param name="_copyQty">
    /// The <paramref name="_copyQty" /> parameter indicates whether the original quantity should be
    /// copied; optional.
    /// </param>
    /// <param name="_qty">
    /// The <paramref name="_qty" /> parameter indicates an alternative quantity; optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// The insert validation fails in the event the operation is interrupted.
    /// </exception>
    public void copyRBOLines(boolean _copyQty = true,
                             Qty     _qty = 0.0)
    {
        Common                  fromTrans;
        RetailPackagePurch         rboFromPackagePurch;
        while select tmpFrmVirtualRBOLines order by LineNum
        {
            rboPackagePurch.clear();

            rboPackagePurch.selectForUpdate(true);

            if (tmpFrmVirtualRBOLines)
            {
                switch (tmpFrmVirtualRBOLines.TableNum)
                {
                    case tableNum(RetailPackagePurch)   :

                        fromTrans=RetailPackagePurch::findRecId(tmpFrmVirtualRBOLines.RecordNo);
                        rboFromPackagePurch = fromTrans;
                        rboPackagePurch.initFromPurchTable(purchTable);
                        rboPackagePurch.initFromRBOPackagePurch(fromTrans,_copyQty,_qty);
                        [rboLineNumCont,rboPackagePurch.LineNum] = this.lineNumIndex(rboLineNumCont,rboFromPackagePurch.PurchId,rboFromPackagePurch.LineNum); //Sets the correct linenum from the mapping list

                        if (_copyQty)
                        {
                            rboPackagePurch.Qty = rboPackagePurch.Qty * qtyFactor;
                            rboPackagePurch.Qty = reverseSign ? -rboPackagePurch.Qty : rboPackagePurch.Qty;
                        }

                        break;
                }

                if (rboPackagePurch.validateWrite())
                    rboPackagePurch.insert();
                else
                {
                    rboPackagePurch.reread();
                    throw error("@SYS18722");
                }

                tmpFrmVirtualRBOLines.delete();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>IsPurchLineChecked</Name>
				<Source><![CDATA[
    boolean IsPurchLineChecked(PurchLine purchLine)
    {
        select firstonly RecId from tmpFrmVirtualLines
            where tmpFrmVirtualLines.RecordNo == purchLine.RecId;

        return tmpFrmVirtualLines.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLines</Name>
				<Source><![CDATA[
    void deleteLines()
    {
        PurchLine purchLine;

        QueryRun queryRun = this.buildPurchCopyingDeleteLinesQuery();

        while (queryRun.next())
        {
            purchLine = queryRun.get(tableNum(PurchLine));

            if (this.IsPurchLineChecked(purchLine))
            {
                continue;
            }

            if (!purchLine.validateDelete())
            {
                throw error("@SYS18722");
            }
            
            purchLine.delete();
        }

        // Soft deleted lines numbers cannot be reused.
        while select LineNumber from purchLine
              where purchLine.PurchId == purchTable.PurchId
                 && purchLine.IsDeleted
        {
            usedLineNumbers.add(purchLine.LineNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPurchCopyingDeleteLinesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for deleting <c>PurchLine</c> records.
    /// </summary>
    /// <returns>
    /// A <c>Query</c> object.
    /// </returns>
    protected QueryRun buildPurchCopyingDeleteLinesQuery()
    {
        QueryRun queryRun = new QueryRun(queryStr(PurchLine));
        queryRun.query().dataSourceTable(tableNum(PurchLine)).rangeField(fieldNum(PurchLine, PurchId)).value(queryValue(purchTable.PurchId));

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRBOPackagePurch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes records in the <c>RetailPackagePurch</c> table related to the <c>PurchTable</c> class
    /// member.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    /// The operation is interrupted in the event the deletion validation fails.
    /// </exception>
    void deleteRBOPackagePurch()
    {
        RetailPackagePurch tPackagePurch;

        while select forupdate tPackagePurch
              where tPackagePurch.PurchId == purchTable.PurchId
        {
            if (tPackagePurch.validateDelete())
                tPackagePurch.delete();
            else
                throw error("@SYS18722");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRBOSumLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes records in the <c>RetailSumLines</c> table related to the <c>PurchTable</c> class member.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    /// The operation is interrupted in the event the deletion validation fails.
    /// </exception>
    void deleteRBOSumLines()
    {
        RetailSumLines     tSumLines;
        while select forupdate tSumLines
              where tSumLines.PurchId == purchTable.PurchId
        {
            if (tSumLines.validateDelete())
                tSumLines.delete();
            else
                throw error("@SYS18722");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endCopy</Name>
				<Source><![CDATA[
    protected void endCopy()
    {
        PurchLine   purchLine;

        super();
        this.setRefCustVendCreditInvoicingTable(purchTable, vendInvoiceJour);
        purchTable.reread();

        if (renumberLines)
        {
            purchLine.PurchId = purchTable.PurchId;
            TradeLineRenumbering::mainOnServer(purchLine);
        }

        purchTable.updateStatusFromPurchLines();

        if (copyPrecisely && purchTable.SourceDocumentHeader)
        {
            SourceDocumentLine sourceDocumentLine;

            //We will not distribute the scenario where the PurchLine Line amount is 0 because we have cases like
            //project attached to PO lines where transaction currency amount gets derived from pricing model and 
            //in those cases we want to avoid creation of distribution line as the line will get the amount different 
            //and could be 0 but Project accounting distribution will have a value or may not have a value.
            while select sourceDocumentLine
                join purchLine 
                where purchLine.SourceDocumentLine == sourceDocumentLine.RecId
                    && purchLine.LineAmount != 0
                    && sourceDocumentLine.SourceDocumentHeader == purchTable.SourceDocumentHeader
                    && sourceDocumentLine.ParentSourceDocumentLine == 0
                    && (sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::Draft
                    || sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::PartlyDistributed)
            {
                SourceDocumentLineProcessor::submitSourceDocumentLine(
                    sourceDocumentLine,
                    false,
                    SourceDocumentLineAccountingStatus::FullyDistributed);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>headerAgreementExt</Name>
				<Source><![CDATA[
    private AgreementHeaderExtRecId_RU headerAgreementExt(Common _header = null)
    {
        PurchTableHistory           fromPurchTableHistory;
        VendPackingSlipJour         fromVendPackingSlipJour;
        PurchTable                  fromPurchTable;
        VendInvoiceJour             fromVendInvoiceJour;
        VendInvoice4PaymJour_RU     fromVendInvoice4PaymJour_RU;
        AgreementHeaderExtRecId_RU  agreementHeaderExt;
        TableId                     tableId;
        RecId                       recId;

        if (_header)
        {
            tableId = _header.TableId;
            recId   = _header.RecId;
        }
        else
        {
            tableId = tmpFrmVirtualHeader.TableNum;
            recId   = tmpFrmVirtualHeader.RecordNo;
        }

        if (tableId && recId)
        {
            switch (tableId)
            {
                case tableNum(PurchTable)   :
                    fromPurchTable=PurchTable::findRecId(recId);
                    agreementHeaderExt = fromPurchTable.purchTable_RU().AgreementHeaderExt_RU;
                    break;
                case tableNum(VendInvoiceJour)   :
                    fromVendInvoiceJour=VendInvoiceJour::findRecId(recId);
                    agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(fromVendInvoiceJour.DefaultDimension).RecId;
                    break;
                case tableNum(VendPackingSlipJour )  :
                    fromVendPackingSlipJour=VendPackingSlipJour::findRecId(recId);
                    agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(fromVendPackingSlipJour.DefaultDimension).RecId;
                    break;
                case tableNum(VendPurchOrderJour)   :
                    fromPurchTableHistory=VendPurchOrderJour::findRecId(recId).purchTableHistory();
                    agreementHeaderExt = fromPurchTableHistory.purchTableHistory_RU().AgreementHeaderExt_RU;
                    break;
                case tableNum(VendInvoice4PaymJour_RU)   :
                    fromVendInvoice4PaymJour_RU=VendInvoice4PaymJour_RU::findRecId(recId);
                    agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(fromVendInvoice4PaymJour_RU.DefaultDimension).RecId;
                    break;
            }
        }

        return agreementHeaderExt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParameters</Name>
				<Source><![CDATA[
    public void initParameters(PurchCopyingContract _contract)
    {
        ListEnumerator                  le;
        PurchCopyingPurchTableContract  localContract = _contract;

        purchTable              = _contract.parmCallingTable() as PurchTable;
        purchTableHasNoLines    = !purchTable.existPurchLine();

        super(_contract);

        this.parmVendInvoiceJour(localContract.parmVendInvoiceJour());
        // <GEERU>
        this.parmCopyExchRate(localContract.parmCopyExchRate());
        // </GEERU>

        tmpFrmVirtualRBOLines = null;
        if (localContract.parmPackedTmpFrmVirtualRBOLines() != conNull())
        {
            le = List::create(localContract.parmPackedTmpFrmVirtualRBOLines()).getEnumerator();
            while (le.moveNext())
            {
                tmpFrmVirtualRBOLines.clear();
                tmpFrmVirtualRBOLines.data(le.current());
                tmpFrmVirtualRBOLines.insert();
            }
        }

        select firstonly tmpFrmVirtualHeader;

        if (tmpFrmVirtualHeader)
        {
            switch (tmpFrmVirtualHeader.TableNum)
            {
                case tableNum(PurchTable)           :
                    headerCurrencyCode = PurchTable::findRecId(tmpFrmVirtualHeader.RecordNo).CurrencyCode;
                    break;
                case tableNum(VendInvoiceJour)      :
                    headerCurrencyCode = VendInvoiceJour::findRecId(tmpFrmVirtualHeader.RecordNo).CurrencyCode;
                    break;
                case tableNum(VendPurchOrderJour)   :
                    headerCurrencyCode = VendPurchOrderJour::findRecId(tmpFrmVirtualHeader.RecordNo).purchTableHistory().CurrencyCode;
                    break;

                case tableNum(VendPackingSlipJour)  : //Fall Through
                default                             :
                    headerCurrencyCode = purchTable.CurrencyCode;
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAgreementExt</Name>
				<Source><![CDATA[
    private AgreementHeaderExtRecId_RU lineAgreementExt(Common _line = null)
    {
        AgreementHeaderExtRecId_RU agreementHeaderExt;
        PurchLine                  fromPurchLine;
        VendInvoiceTrans           fromVendInvoiceTrans;
        VendPackingSlipTrans       fromVendPackingSlipTrans;
        PurchLineHistory           fromPurchLineHistory;
        VendInvoice4PaymTrans_RU   fromVendInvoice4PaymTrans;
        boolean                    ret = true;
        TableId                    tableId;
        RecId                      recId;

        if (_line)
        {
            tableId = _line.TableId;
            recId   = _line.RecId;
        }
        else
        {
            tableId = tmpFrmVirtualLines.TableNum;
            recId   = tmpFrmVirtualLines.RecordNo;
        }

        if (tableId && recId)
        {
            switch (tableId)
            {
                case tableNum(PurchLine):
                    fromPurchLine = PurchLine::findRecId(recId);
                    agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(fromPurchLine.DefaultDimension).RecId;
                    break;

                case tableNum(VendInvoiceTrans):
                    fromVendInvoiceTrans = VendInvoiceTrans::findRecId(recId);
                    agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(fromVendInvoiceTrans.DefaultDimension).RecId;
                    break;

                case tableNum(VendPackingSlipTrans):
                    fromVendPackingSlipTrans        = VendPackingSlipTrans::findRecId(recId);
                    agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(fromVendPackingSlipTrans.DefaultDimension).RecId;
                    break;

                case tableNum(PurchLineHistory):
                    fromPurchLineHistory = PurchLineHistory::findRecId(recId);
                    agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(fromPurchLineHistory.DefaultDimension).RecId;
                    break;

                case tableNum(VendInvoice4PaymTrans_RU) :
                    fromVendInvoice4PaymTrans = VendInvoice4PaymTrans_RU::findRecId(recId);
                    agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(fromVendInvoice4PaymTrans.DefaultDimension).RecId;
                    break;
            }
        }

        return agreementHeaderExt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRBOContainers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>rboLineNumCont</c> and <c>fshLineNumCont</c> container type class members.
    /// </summary>
    void initRBOContainers()
    {
        rboLineNumCont = conIns(rboLineNumCont,1,(select maxof(LineNum) from retailPackagePurch
        where retailPackagePurch.PurchId == purchTable.PurchId).LineNum);

        fshLineNumCont = conIns(fshLineNumCont,1,(select maxof(LineNum) from retailSumLines
        where retailSumLines.PurchId == purchTable.PurchId).LineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineNumIndex</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns unique line numbers to lines that are not related to the same header record.
    /// </summary>
    /// <param name="_cont">
    /// A <c>container</c> type that contains line numbers.
    /// </param>
    /// <param name="_id">
    /// A <c>Num</c> extended data type.
    /// </param>
    /// <param name="_lineNum">
    /// A <c>LineNum</c> extended data type.
    /// </param>
    /// <returns>
    /// A container type that contains two elements; a container of the mapped line numbers and an
    /// <c>int</c> type specifying the number of line numbers.
    /// </returns>
    public container lineNumIndex(container _cont, Num _id, LineNum _lineNum)
    {
        /*
        *  We create a container that maps orig ID and LINENUM to a new LINENUM.
        *  This assigns unique LINENUMS to LINES that are not from the same HEADER.
        *  (fshLineNum/rboPackageLineNum conflicts are handled).
        *  The first entry always contains the maxOf line num (next starting point)
        */
        rboNum      = -1;
        rboCounter  = 2;

        rboMaxOfNewNum = conPeek(_cont,1);

        if (conLen(_cont) == 0)
            this.initRBOContainers();

        do
        {
            [rboOrigId, rboOrigNum, rboNewNum] = conPeek(_cont,rboCounter);

            if (rboOrigNum == _lineNum && rboOrigId == _id)
                rboNum = rboNewNum;
            else
                rboMaxOfNewNum = rboMaxOfNewNum < rboNewNum ? rboNewNum : rboMaxOfNewNum;

            rboCounter++;
        }
        while (rboCounter <= conLen(_cont));

        if (rboNum > -1)
            return [_cont,rboNum];
        else
        {
            _cont          = conIns(_cont,2,[_id,_lineNum,rboMaxOfNewNum + 1]);
            rboMaxOfNewNum +=1;
            _cont          = conPoke(_cont,1,rboMaxOfNewNum);

            return [_cont,rboMaxOfNewNum];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markAgainstVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current <c>PurchLine</c> transaction should be marked against vendor invoice transaction.
    /// </summary>
    /// <returns>
    /// true if marking against a referenced voucher is needed; Otherwise false; true by default.
    /// </returns>
    /// <remarks>
    /// The method can be overriden in the subclasses.
    /// </remarks>
    public boolean markAgainstVoucher()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markForSettlement</Name>
				<Source><![CDATA[
    void markForSettlement(VendInvoiceTrans vendInvoiceTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        usedLineNumbers            = new Set(Types::Int64);
        
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmtmpFrmVirtualRBOLines</Name>
				<Source><![CDATA[
    public TmpFrmVirtual parmtmpFrmVirtualRBOLines(TmpFrmVirtual _tmpFrmVirtualRBOLines = tmpFrmVirtualRBOLines)
    {
        tmpFrmVirtualRBOLines = _tmpFrmVirtualRBOLines;

        return tmpFrmVirtualRBOLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVendInvoiceJour</Name>
				<Source><![CDATA[
    public VendInvoiceJour parmVendInvoiceJour(VendInvoiceJour     _vendInvoiceJour = vendInvoiceJour)
    {
        vendInvoiceJour = _vendInvoiceJour;
        return vendInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSetRemain</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the remainder quantities should be set for the <c>purchLine</c> parameter.
    /// </summary>
    /// <param name="_purchLine">
    /// The <c>purchLine</c> record to be updated.
    /// </param>
    /// <returns>
    /// A boolean value indicating whether the quantities should be set.
    /// </returns>
    /// <remarks>
    /// Always returns true.
    /// </remarks>
    public boolean pdsSetRemain(PurchLine _purchLine)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preCILUserInterAction</Name>
				<Source><![CDATA[
    public void preCILUserInterAction(PurchCopyingContract _contract = null)
    {
        ListEnumerator      le;
        tmpFrmVirtualHeader = null;

        if (_contract && _contract.parmPackedTmpFrmVirtualHeader() != conNull())
        {
            le = List::create(_contract.parmPackedTmpFrmVirtualHeader()).getEnumerator();
            while (le.moveNext())
            {
                tmpFrmVirtualHeader.clear();
                tmpFrmVirtualHeader.data(le.current());
                tmpFrmVirtualHeader.insert();
            }
            purchTable = _contract.parmCallingTable();
        }

        super();
        this.promptConvertCurrencyCode();
        this.promptRemoveSettlement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptConvertCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompts the user if the currency code is being changed as a consequence of the copying.
    /// </summary>
    /// <remarks>
    /// Note - The actual recalculation does not take place in this method
    /// </remarks>
    protected void promptConvertCurrencyCode()
    {
        if (headerCurrencyCode && headerCurrencyCode != purchTable.CurrencyCode &&
                (PurchLine::exist(purchTable.PurchId) || MarkupTrans::exist(purchTable.TableId, purchTable.RecId)))
        {
            [convertCurrency, tradeCurencyConversion] = PurchTable::promptConvertCurrencyCode();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptRemoveSettlement</Name>
				<Source><![CDATA[
    void promptRemoveSettlement()
    {
        // Does nothing because it is only a method stub for inherited classes.
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchCopyingCopyLineDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows customizing the <c>PurchCopying.copyLines</c> method in higher layers.
    /// </summary>
    /// <param name="_instance">
    /// An instance of the <c>PurchCopying</c> class that the customizations will use.
    /// </param>
    /// <param name="_purchLine">
    /// The <c>PurchLine</c> record to copy.
    /// </param>
    /// <param name="_tmpFrmVirtualLines">
    /// The <c>TmpFrmVirtual</c> record that was passed to the <c>PurchCopying.copyLines</c> method.
    /// </param>
    /// <param name="_result">
    /// A struct that contains two fields.
    /// </param>
    /// <remarks>
    /// This delegate is called when the <paramref name="_tmpFrmVirtualLines" /> parameter contains a table
    /// that is not recognized by the method.
    /// </remarks>
    delegate void purchCopyingCopyLineDefault(PurchCopying _instance, PurchLine _purchLine, TmpFrmVirtual _tmpFrmVirtualLines, Struct _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>callPurchCopyingCopyLineDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes the delegate purchCopyingCopyLineDefault.
    /// </summary>
    /// <param name="_purchLine">
    /// The <c>PurchLine</c> record to copy.
    /// </param>
    /// <param name="_tmpFrmVirtualLines">
    /// The <c>TmpFrmVirtual</c> record that was passed to the <c>PurchCopying.copyLines</c> method.
    /// </param>
    /// <param name="_result">
    /// A struct that contains two fields.
    /// </param>
    /// <returns>
    /// A struct that contains two fields.
    /// </returns>
    public Struct callPurchCopyingCopyLineDefault(PurchLine _purchLine, TmpFrmVirtual _tmpFrmVirtualLines, Struct _result)
    {
        this.purchCopyingCopyLineDefault(this, _purchLine, _tmpFrmVirtualLines, _result);

        return _result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchCopyingCopyLineFinal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows customizing the <c>PurchCopying.copyLines</c> method in higher layers.
    /// </summary>
    /// <param name="_instance">
    /// An instance of the <c>PurchCopying</c> class that the customizations will use.
    /// </param>
    /// <param name="_purchLine">
    /// The <c>PurchLine</c> record to copy.
    /// </param>
    /// <param name="_tmpFrmVirtualLines">
    /// The <c>TmpFrmVirtual</c> record that is passed to the <c>PurchCopying.copyLines</c> method.
    /// </param>
    /// <remarks>
    /// The <c>PurchCopying.copyLines</c> method will call this delegate at the end of the method.
    /// Customizations in higher layers will attach specific event handlers to this delegate.
    /// </remarks>
    delegate void purchCopyingCopyLineFinal(PurchCopying _instance, PurchLine _purchLine, TmpFrmVirtual _tmpFrmVirtualLines)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>callPurchCopyingCopyLineFinal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the purchCopyingCopyLineFinal delegate.
    /// </summary>
    /// <param name="_purchLine">
    /// The <c>PurchLine</c> record to copy.
    /// </param>
    /// <param name="_tmpFrmVirtualLines">
    /// The <c>TmpFrmVirtual</c> record that is passed to the <c>PurchCopying.copyLines</c> method.
    /// </param>
    public void callPurchCopyingCopyLineFinal(PurchLine _purchLine, TmpFrmVirtual _tmpFrmVirtualLines)
    {
        this.purchCopyingCopyLineFinal(this, _purchLine, _tmpFrmVirtualLines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPdsCWQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the catch weight quantity and calculates the <c>PurchQty</c> and <c>QtyOrdered</c>.
    /// </summary>
    /// <param name="_purchLine">
    /// <c>PurchLine</c> record to be modified.
    /// </param>
    /// <param name="_reverseSign">
    /// Boolean value that determines whether the inventory sign should be reversed.
    /// </param>
    /// <param name="_qtyFactor">
    /// Factor used to determine new quantities.
    /// </param>
    public void setPdsCWQty(
        PurchLine   _purchLine,
        boolean     _reverseSign,
        real        _qtyFactor)
    {
        _purchLine.PdsCWQty     = _reverseSign
                                        ? -_purchLine.PdsCWQty
                                        : _purchLine.PdsCWQty;
        _purchLine.PdsCWQty     = decRound(
                                        _purchLine.PdsCWQty * _qtyFactor,
                                        UnitOfMeasure::unitOfMeasureDecimalPrecision(
                                            UnitOfMeasure::unitOfMeasureIdBySymbol(_purchLine.pdsCWUnitId())));

        _purchLine.PurchQty     = PdsCatchWeight::inventQty(
                                        _purchLine.ItemId,
                                        _purchLine.PdsCWQty,
                                        _purchLine.PurchUnit);
        _purchLine.QtyOrdered   = PdsCatchWeight::inventQty(
                                        _purchLine.ItemId,
                                        _purchLine.PdsCWQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventTransIdReturn_W</Name>
				<Source><![CDATA[
    // overloaded in PurchCopying_CreditNote
    public void setInventTransIdReturn_W(PurchLine _purchLine, VendInvoiceTrans _vendInvoiceTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceDiscHeaderChangePolicy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the price discount policies for the lines of the new Purchase order.
    /// </summary>
    /// <param name="_tmpFrmVirtualId">
    ///    The ID of the original table from which to copy.
    /// </param>
    /// <param name="_purchTable">
    ///    A <c>PurchTable</c> table buffer.
    /// </param>
    protected void setPriceDiscHeaderChangePolicy(RefTableId _tmpFrmVirtualId, PurchTable _purchTable)
    {
        switch (_tmpFrmVirtualId)
        {
            case tableNum(PurchTable)           :
            case tableNum(VendInvoiceJour)      :
            case tableNum(VendPackingSlipJour)  :
                _purchTable.setPriceDiscChangePolicy(PriceDiscSystemSource::CopyFromPurchaseOrder);
                break;

            case tableNum(PurchRFQCaseTable)    :
                _purchTable.setPriceDiscChangePolicy(PriceDiscSystemSource::RequestForQuote);
                break;

            case tableNum(PurchReqTable)        :
                _purchTable.setPriceDiscChangePolicy(PriceDiscSystemSource::PurchaseReq);
                break;

            default : break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceDiscLineChangePolicy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets price discount policies for the lines of the new Purchase order.
    /// </summary>
    /// <param name="_tmpFrmVirtualId">
    ///    The ID of the original table from which to copy.
    /// </param>
    /// <param name="_purchLine">
    ///    A <c>PurchLine</c> table buffer.
    /// </param>
    protected void setPriceDiscLineChangePolicy(RefTableId _tmpFrmVirtualId, PurchLine _purchLine)
    {
        switch (_tmpFrmVirtualId)
        {
            case tableNum(PurchLine)            :
            case tableNum(VendInvoiceTrans)     :
            case tableNum(VendPackingSlipTrans) :
                _purchLine.setPriceDiscChangePolicy(PriceDiscSystemSource::CopyFromPurchaseOrder);
                break;

            case tableNum(PurchRFQCaseLine)     :
                _purchLine.setPriceDiscChangePolicy(PriceDiscSystemSource::RequestForQuote);
                break;

            case tableNum(PurchReqLine)         :
                _purchLine.setPriceDiscChangePolicy(PriceDiscSystemSource::PurchaseReq);
                break;

            default : break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRefCustVendCreditInvoicingTable</Name>
				<Source><![CDATA[
    protected void setRefCustVendCreditInvoicingTable(PurchTable       _purchTable,
                                                      VendInvoiceJour  _vendInvoiceJour)
    {
        CustVendCreditInvoicingTable custVendCreditInvoicingTable;
        #ISOCountryRegionCodes

        if (_vendInvoiceJour && this.isCreditNote())
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES, #isoSE, #isoPL, #isoTH, #isoIT])
                || FeatureStateProvider::isFeatureEnabled(CreditInvoicingForVendorInvoicesFeature::instance()))
            {
                custVendCreditInvoicingTable = CustVendCreditInvoicingTable::findRefId(_purchTable.TableId,
                                                                                       _purchTable.RecId,
                                                                                       true);

                if (custVendCreditInvoicingTable)
                {
                    custVendCreditInvoicingTable.CustVendCorrectedInvoiceId = _vendInvoiceJour.InvoiceId;
                    custVendCreditInvoicingTable.CustVendCorrectedInvoiceDate = _vendInvoiceJour.InvoiceDate;
                    custVendCreditInvoicingTable.update();
                }
                else
                {
                    custVendCreditInvoicingTable.CustVendInvoiceAccount     = _purchTable.InvoiceAccount;
                    custVendCreditInvoicingTable.AccountType                = LedgerJournalACType::Vend;
                    custVendCreditInvoicingTable.CustVendCorrectedInvoiceId = _vendInvoiceJour.InvoiceId;
                    custVendCreditInvoicingTable.CustVendCorrectedInvoiceDate = _vendInvoiceJour.InvoiceDate;
                    custVendCreditInvoicingTable.RefTableId                 = _purchTable.TableId;
                    custVendCreditInvoicingTable.RefRecId                   = _purchTable.RecId;
                    custVendCreditInvoicingTable.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleInvoiceTrans</Name>
				<Source><![CDATA[
    boolean settleInvoiceTrans()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoiceCreditCopy</Name>
				<Source><![CDATA[
    public void updateInvoiceCreditCopy(PurchLine purchLine, VendInvoiceTrans vendInvoiceTrans)
    {
        // Does nothing because it is only a method stub for inherited classes.
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCopy</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Executes a copying on the server
    /// </summary>
    /// <param name="_salesPurchCopy">
    ///   An element from the <c>SalesPurchCopy</c> enum.
    /// </param>
    /// <param name="__contract">
    ///   The <c>PurchCopyingContract</c> class.
    /// </param>
    public static void newCopy(
        SalesPurchCopy  _salesPurchCopy,
        PurchCopyingContract _contract)
    {
        PurchCopyService::runFromContract(_contract, _contract.parmCallingTable(), _salesPurchCopy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRefInvoice_MY</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets original invoice id and original invoice date.
    /// </summary>
    /// <param name = "_purchLine">
    /// The purchase line of the credit note.
    /// </param>
    /// <param name = "_invoicejour">
    /// The original invoice journal.
    /// </param>
    public void setRefInvoice_MY(PurchLine _purchLine, VendInvoiceJour _invoicejour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchCopyingContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a current instance of <c>PurchCopyingContract</c> contract.
    /// </summary>
    /// <returns>An instance of <c>PurchCopyingContract</c>.</returns>
    public PurchCopyingContract getPurchCopyingContract()
    {
        PurchCopyingPurchTableContract  contract;

        contract = super() as PurchCopyingPurchTableContract;

        contract.parmVendInvoiceJour(this.parmVendInvoiceJour());
        contract.parmCopyExchRate(this.parmCopyExchRate());

        List list = new List(Types::Record);

        while select tmpFrmVirtualRBOLines
        {
            list.addEnd(tmpFrmVirtualRBOLines);
        }

        contract.parmPackedTmpFrmVirtualRBOLines(list.pack());

        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createContact</Name>
				<Source><![CDATA[
    protected PurchCopyingContract createContact()
    {
        return new PurchCopyingPurchTableContract();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>