<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailDeploymentUtility</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.ApplicationPlatform.Environment;
using Microsoft.DynamicsOnline.Infrastructure.Components.SharedServiceUnitStorage;
using AppLogging = Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource;

/// <summary>
/// Retail deployment utility class.
/// </summary>
class RetailDeploymentUtility
{
    internal const str AzureGlobal = 'AzureGlobal';
    internal const str AzureChina = 'AzureChina';
    internal const str AzureGermany = 'AzureGermany';
    internal const str AzureUSGov = 'AzureUSGov';
    public const str DefaultRetailServerProfileName = 'Retail server channel profile';
    public const str RetailCompanyName = 'USRT';
    public const str RetailPerfStoreNumber = 'S1001';
    public const int RetailChannelProfileMediaServerProperty = 2;
    public const str SqlAzureHostName = '.database.windows.net';

    private const int SleepIntervalForCDX = 60000;
    private const str internalTenantId = 'contosoax7.onmicrosoft.com';
    private const str internalAadIssuerPrefix = 'ppe';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>EnableBatchThrottling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enable or disable batch throttling if throttling has been configured on the instance.
    /// </summary>
    /// <param name='enableThrotting'>Flag to indicate if batch throttling should be enabled.</param>
    public static void EnableBatchThrottling(NoYes enableThrotting)
    {
        SysServerConfig serverConfig;

        update_recordset serverConfig
            setting ThrottlingEnabled = enableThrotting
            where serverConfig.ThrottlingCpuReservationLimit != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>TaskerRunCDXDownloadJobsE2E</Name>
				<Source><![CDATA[
    /// <summary>
    /// Run commerce data exchange download jobs.
    /// </summary>
    /// <param name = "dataGroupRecId">RecId of the data group to perform full data sync.</param>
    /// <param name = "timeoutInMinutes">Timeout minutes to perform full data sync, default 30 mins.</param>
    public static void TaskerRunCDXDownloadJobsE2E(RefRecId dataGroupRecId = 0, int timeoutInMinutes = 30)
    {
        RetailCDXDataGroup          dataGroup;
        RetailConnDatabaseProfile   dataStore;

        // single-box: data group name is hardcoded
        // multi-box: data group name is from config file
        if (dataGroupRecId)
        {
            select firstonly dataGroup where dataGroup.RecId == dataGroupRecId;
        }
        else
        {
            select firstonly dataGroup where dataGroup.Name == 'Houston';
        }

        select firstonly dataStore where dataStore.DataGroup == dataGroup.RecId;  // there should be only one channel DB linked to data group.

        if (!dataGroup)
        {
            throw error("Data group could not be found.");
        }

        if (!dataStore)
        {
            throw error("Data store could not be found.");
        }

        // Bug 380190: last parameter set to false to avoid timeout of CDX jobs.
        RetailDeploymentUtility::RunCDXJobsForDataGroup(dataGroup, dataStore, timeoutInMinutes, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>RunCDXDownloadJobsForAllDataGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Run commerce data exchange download jobs for all the datagroup, this method won't throw if there is any error.
    /// </summary>
    /// <param name = "timeoutInMinutes">Timeout minutes to perform full data sync, default 30 mins.</param>
    /// <param name = "waitForJobToFinish">Whether to wait for the CDX job to finish or not, default true.</param>
    public static void RunCDXDownloadJobsForAllDataGroup(int timeoutInMinutes = 30, boolean waitForJobToFinish = true)
    {
        RetailCDXDataGroup          dataGroup;
        RetailConnDatabaseProfile   dataStore;

        // Bug 380190: hard coding the below flag to false while the batch throttling issue is being investigated
        waitForJobToFinish = false;

        while select dataGroup
        {
            if (!dataGroup)
            {
                error ("Data group could not be found.");
                continue;
            }

            select firstonly RecId from dataStore where dataStore.DataGroup == dataGroup.RecId;

            if (!dataStore)
            {
                AppLogging::EventWriteSelfServiceWarning(strfmt('Data store could not be found for datagroup %1.', dataGroup.Name));
                continue;
            }

            info (strfmt('Scheduling full sync for datagroup %1.', dataGroup.Name));

            RetailDeploymentUtility::RunCDXJobsForDataGroup(dataGroup, dataStore, timeoutInMinutes, waitForJobToFinish);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>RestoreDevices</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to restore devices.
    /// </summary>
    /// <param name = "_args">Caller args.</param>
    static void RestoreDevices(Args _args = null)
    {
        RetailDevice retailDevice;

        ttsBegin;
        while select forupdate retailDevice
        where retailDevice.ActivationStatus != RetailDeviceActivationStatusBase::Pending
        {
            retailDevice.ActivationStatus = RetailDeviceActivationStatusBase::Pending;
            retailDevice.ActivationStaffId = null;
            retailDevice.DeactivationStaffId = null;
            retailDevice.ActivatedDateTime = utcDateTimeNull();
            retailDevice.DeactivatedDateTime = utcDateTimeNull();
            retailDevice.update();
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>TaskerRegisterCommerceTestIdentityProvider</Name>
				<Source><![CDATA[
    /// <summary>
    /// Register Commerce Test Open Id Provider.
    /// </summary>
    /// <param name = "_args">Unused.</param>
    public static void TaskerRegisterCommerceTestIdentityProvider(Args _args = null)
    {
        RetailIdentityProvider identityProvider;
        RetailRelyingParty relyingParty;

        ttsbegin;
        select forupdate identityProvider;
        identityProvider.Name = "RetailTest";
        identityProvider.Issuer = "https://erp.dynamicstest.com:8801";
        identityProvider.insert();
        ttscommit;

        ttsbegin;
        select forupdate relyingParty;
        relyingParty.ProviderId = identityProvider.RecId;
        relyingParty.ClientId = "https://commerce.dynamics.com";
        relyingParty.Type = 2;
        relyingParty.UserType = 2;
        relyingParty.insert();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>MapAADStaff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Maps a staff to an Microsoft Entra ID user.
    /// </summary>
    /// <param name = "staffId">The staff identifier.</param>
    /// <param name = "tenantId">The tenant identifier.</param>
    /// <param name = "aadUserId">The Microsoft Entra ID user identifier, it is a guid and it will be referenced as external identity sub id for a workder.</param>
    public static void MapAADStaff(str staffId, str tenantId, str aadUserId)
    {
        RetailStaffTable staff = RetailStaffTable::find(staffId, true);

        if (!staff)
        {
            throw error(strFmt("Staff with id '{0}' expected to be present in the DemoData but not found.", staffId));
        }

        // if this Microsoft Entra ID user has already been associated with an worker, the association needs to be removed before this Microsoft Entra ID user can be mapped to a new worker
        RetailStaffTable oldStaff;
        select firstonly forupdate oldStaff where oldStaff.ExternalIdentitySubId == aadUserId;
        if (oldStaff && oldStaff.staffId != staffId)
        {
            oldStaff.ExternalIdentityId = '';
            oldStaff.ExternalIdentitySubId = '';
            oldStaff.update();
        }

        staff.ExternalIdentityId = tenantId;
        staff.ExternalIdentitySubId = aadUserId;
        staff.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDemoDataLoaded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the demo data is loaded by checking the data area in the ax database.
    /// </summary>
    /// <returns> True if the demo data is loaded; otherwise, false. </returns>
    public static boolean isDemoDataLoaded()
    {
        DataArea da;
        select firstonly da where da.id == RetaildeploymentUtility::RetailCompanyName;

        return da != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPerfDataLoaded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the perf data is loaded by checking the retail store in the ax database.
    /// </summary>
    /// <returns>True if the perf data is loaded; otherwise, false.</returns>
    public static boolean isPerfDataLoaded()
    {
        if (!RetailDeploymentUtility::isDemoDataLoaded())
        {
            return false;
        }
        RetailStoreTable store;
        select firstonly store where store.StoreNumber == RetailDeploymentUtility::RetailPerfStoreNumber;

        return store != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSqlAzureConnectionString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if a connection string a sql azure connection string or not, if the server name contains .database.windows.net, returns true, otherwise, returns false.
    /// </summary>
    /// <param name = "connectionString">Target connection string</param>
    /// <returns>If the server name contains .database.windows.net, returns true, otherwise, returns false.</returns>
    public static boolean isSqlAzureConnectionString(str connectionString)
    {
        boolean isSqlAzureConnectionString = false;
        new InteropPermission(InteropKind::ClrInterop).assert();

        try
        {
            // Return true if its a sql azure connection string.
            System.Data.SqlClient.SqlConnectionStringBuilder builder = new System.Data.SqlClient.SqlConnectionStringBuilder(connectionString);
            if (builder.DataSource.ToLower().Contains(SqlAzureHostName))
            {
                isSqlAzureConnectionString =  true;
            }
        }
        catch (Exception::CLRError)
        {
            System.Exception e = CLRInterop::getLastException();
        }
        catch (Exception::Error)
        {
        }

        //Revert CAS back to normal
        CodeAccessPermission::revertAssert();

        return isSqlAzureConnectionString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStoreSystemSupported</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if store system is supported for this channel database.
    /// </summary>
    /// <param name = "databaseProfile">Target RetailConnDatabaseProfile</param>
    /// <returns>If the db connnection is empty, datastore type is not offline database and retail scale unit type is not RCSU, returns true, otherwise, returns false.</returns>
    public static boolean isStoreSystemSupported(RetailConnDatabaseProfile databaseProfile)
    {
        #define.Default('Default')
        RetailScaleUnit                 scaleUnit;
        RetailScaleUnitConfiguration    configuration;
        boolean result;

        // Check if it's not offline, nor Default collocate DB, nor Customer search database.
        result = databaseProfile.DataStoreType != RetailCDXDataStoreType::OfflineDatabase && databaseProfile.Name != #Default && databaseProfile.Name != RetailCustomerSearchConstants::CdxDatabaseProfileName;

        if (result)
        {
            // Make the connection string decryption as the last step of checking
            // whether the record is RSSU type.
            str connStr = databaseProfile.connectionStringEdit(false, '');
            result = strLen(connStr) == 0;
        }

        // Distinguish between RSSU and RCSU
        if (result)
        {
            select firstonly scaleUnit
                where scaleUnit.Type == RetailScaleUnitType::RCSU
            exists join configuration
                where   configuration.RetailScaleUnit   == scaleUnit.RecId
                    &&  configuration.RefRecId          == databaseProfile.RecId
                    &&  configuration.RefTableId        == tableNum(RetailConnDatabaseProfile);
            
            result = scaleUnit.RecId ? false : true;
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidConnectionString</Name>
				<Source><![CDATA[
    private static boolean isValidConnectionString(str connectionString)
    {
        boolean isValidConnectionString = false;
        new InteropPermission(InteropKind::ClrInterop).assert();

        try
        {
            // Return true if its a valid connection string.
            System.Data.SqlClient.SqlConnectionStringBuilder builder = new System.Data.SqlClient.SqlConnectionStringBuilder(connectionString);
            isValidConnectionString =  true;
        }
        catch (Exception::CLRError)
        {
            System.Exception e = CLRInterop::getLastException();
            isValidConnectionString =  false;
        }
        catch (Exception::Error)
        {
            isValidConnectionString =  false;
        }

        //Revert CAS back to normal
        CodeAccessPermission::revertAssert();

        return isValidConnectionString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateRetailServiceUser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create retail service user, which will be used by retail server to communicate with realtime service (RTS).
    /// </summary>
    /// <param name = "userId">The target user network id (Email address).</param>
    /// <param name = "identityProvider">The identity provider for this user.</param>
    public static void CreateRetailServiceUser(str userId, str identityProvider)
    {
        #define.RetailServiceUserId('RetailServiceAccount')
        #define.RetailServiceUserObjectId('FA6B0156-76D9-4BC2-B618-68CB7A3BF599')
        #define.AdminUser('Admin')

        UserInfo userInfoTable, adminUser, findUserBySid;
        str retailServiceUserSid;
        System.Exception exception;

        try
        {
            // Step 1: Remove any existing records from the UserInfo table where the networkAlias or Id meets our given criterion.
            // Due to the platform change, deletion of microsoft account is not allowed, so exclude the account that is markred isMicrosoftAccount = Yes
            AppLogging::EventWriteSelfServiceInformation('Remove any existing records from the UserInfo table where the networkAlias or Id meets our given criterion.');
            delete_from userInfoTable where userInfoTable.isMicrosoftAccount == NoYes::No && (userInfoTable.networkAlias == userId || userInfoTable.id == #RetailServiceUserId);

            // Step 2: Gather language, help language settings and user sid information to create the RetailServiceAccount.
            select firstonly1 language, helplanguage from adminUser where adminUser.id == #AdminUser;

            AxaptaUserManager userManager = new AxaptaUserManager();
            xAxaptaUserDetails userDetails = userManager.getSIDFromName(userId, identityProvider, UserAccountType::ClaimsUser);

            select * from findUserBySid where findUserBySid.sid == userDetails.getUserSid(0);

            if (findUserBySid.RecId != 0)
            {
                AppLogging::EventWriteSelfServiceWarning("This retail service user SID already exists in AX as some other user. Please update the account manually.");
            }
   
            retailServiceUserSid = userDetails.getUserSid(0);

            // Step 3: Create the retail service user account in the UserInfo table.
            AppLogging::EventWriteSelfServiceInformation('Create the retail service user account in the UserInfo table.');
            select forupdate firstonly1 * from userInfoTable where userInfoTable.networkAlias == userId || userInfoTable.id == #RetailServiceUserId;

            userInfoTable.id               = #RetailServiceUserId;
            userInfoTable.name             = #RetailServiceUserId;
            userInfoTable.networkAlias     = userId;
            userInfoTable.networkDomain    = identityProvider;
            userInfoTable.accountType      = UserAccountType::ClaimsUser;
            userInfoTable.company          = curExt();
            userInfoTable.defaultPartition = true;
            userInfoTable.enable           = true;
            userInfoTable.language         = adminUser.language;
            userInfoTable.helplanguage     = adminUser.helplanguage;
            userInfoTable.sid              = retailServiceUserSid;
            userInfoTable.ObjectId         = guidFromString(#RetailServiceUserObjectId);
            userInfoTable.isMicrosoftAccount = NoYes::Yes;

            userInfoTable.write();

            // Step 4: Assign the retail service user role to the newly created user.
            AppLogging::EventWriteSelfServiceInformation('Assign the retail service user role to the newly created user.');
            RetailDeploymentUtility::AssignRetailServiceRole(userInfoTable);
        }
        catch (exception)
        {
            str errorMessage = 'Retail Post-Deployment configuration service encountered a failure during creation of RetailServiceAccount user.';

            AppLogging::EventWriteSelfServiceError(errorMessage, exception.Message, exception.StackTrace);
            throw Global::error(errorMessage);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>AssignRetailServiceRole</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assign RetailService role to the user, generally this user will be used by the retail server to communicate with realtime service (RTS).
    /// </summary>
    /// <param name = "userInfo">The user object which needs to be assigned with the RetailService role.</param>
    public static void AssignRetailServiceRole(UserInfo userInfo)
    {
        #define.RetailServiceRoleAOTName('RetailService')
        #define.AccountantAOTName('LEDGERACCOUNTANT')
        #define.AccountsReceivableClerkAOTName('CUSTINVOICEACCOUNTSRECEIVABLECLERK')
        #define.AccountsReceivableManagerAOTName('CUSTINVOICEACCOUNTSRECEIVABLEMANAGER')
        #define.BatchJobManagerAOTName('BATCHJOBMANAGER')
        #define.CollectionManagerAOTName('COLLECTIONLETTERCOLLECTIONSMANAGER')
        #define.InventCostAccountantAOTName('INVENTCOSTACCOUNTANT')
        #define.InventCostClerkAOTName('INVENTCOSTCOSTCLERK')
        #define.InventMaterialManagerAOTName('INVENTMATERIALSMANAGER')
        #define.InventQualityControlAOTName('INVENTQUALITYCONTROLMANAGER')
        #define.InventReceivingAOTName('INVENTRECEIVINGCLERK')
        #define.InventShippingAOTName('INVENTSHIPPINGCLERK')
        #define.TimeWorkerName('JMGADVTIMEWORKER')
        #define.TradePurchasingManagerAOTName('TRADEPURCHASINGMANAGER')
        #define.RetailCatalogManagerAOTName('RETAILCATALOGMANAGER')
        #define.RetailMerchandisingManagerAOTName('RETAILMERCHANDISINGMANAGER')
        #define.RetailOperationsManagerAOTName('RETAILOPERATIONSMANAGER')
        #define.RetailWarehouseManagerAOTName('RETAILWAREHOUSEMANAGER')
        #define.RetailWarehouseClerkAOTName('RETAILWAREHOUSECLERK')
        #define.TradeSalesClerkAOTName('TRADESALESCLERK')
        #define.TradeSalesManagerAOTName('TRADESALESMANAGER')
        #define.TradeSalesRepresnetativeAOTName('TRADESALESREPRESENTATIVE')
        #define.ServiceDeliveryManagerAOTName('SMASERVICEDELIVERYMANAGER')
        #define.SubledgerJournalAOTName('SUBLEDGERJOURNALTRANSFERMAINTAINROLE')
        #define.TaxAccountantAOTName('FBTAXACCOUNTANT_BR')
        #define.VendorManagerAOTName('VENDVENDORACCOUNTMANAGER')
        #define.VendorPurchasingAgentAOTName('VENDPURCHASINGAGENT')

        container roleNames;
        SecurityUserRole securityUserRole;
        SecurityRole securityRole;

        roleNames += #RetailServiceRoleAOTName;
        roleNames += #AccountantAOTName;
        roleNames += #AccountsReceivableClerkAOTName;
        roleNames += #AccountsReceivableManagerAOTName;
        roleNames += #BatchJobManagerAOTName;
        roleNames += #CollectionManagerAOTName;
        roleNames += #InventCostAccountantAOTName;
        roleNames += #InventCostClerkAOTName;
        roleNames += #InventMaterialManagerAOTName;
        roleNames += #InventQualityControlAOTName;
        roleNames += #InventReceivingAOTName;
        roleNames += #InventShippingAOTName;
        roleNames += #TimeWorkerName;
        roleNames += #TradePurchasingManagerAOTName;
        roleNames += #RetailCatalogManagerAOTName;
        roleNames += #RetailMerchandisingManagerAOTName;
        roleNames += #RetailOperationsManagerAOTName;
        roleNames += #RetailWarehouseManagerAOTName;
        roleNames += #RetailWarehouseClerkAOTName;
        roleNames += #TradeSalesClerkAOTName;
        roleNames += #TradeSalesManagerAOTName;
        roleNames += #TradeSalesRepresnetativeAOTName;
        roleNames += #ServiceDeliveryManagerAOTName;
        roleNames += #SubledgerJournalAOTName;
        roleNames += #TaxAccountantAOTName;
        roleNames += #VendorManagerAOTName;
        roleNames += #VendorPurchasingAgentAOTName;

        if (userInfo)
        {
            str userName = userInfo.name;
            int length = conLen(roleNames);
            for (int counter = 1; counter <= length; counter++)
            {
                str roleName = conPeek(roleNames, counter);
                select firstonly securityRole where securityRole.AotName == roleName;

                select firstonly securityUserRole
                    where securityUserRole.User == userInfo.id && securityUserRole.SecurityRole == securityRole.RecID;

                if (!securityUserRole)
                {
                    AppLogging::EventWriteSelfServiceInformation(strFmt('Assigning role %1 to user %2', roleName, userName));

                    securityUserRole.SecurityRole = securityRole.RecID;
                    securityUserRole.User = userInfo.id;
                    securityUserRole.AssignmentMode = 1;
                    securityUserRole.AssignmentStatus = 1;
                    securityUserRole.insert();

                    AppLogging::EventWriteSelfServiceInformation(strFmt('Succeeded assigning role %1 to user %2.', roleName, userName));
                }
                else
                {
                    AppLogging::EventWriteSelfServiceInformation(strFmt('Skipping adding role %1 to user %2 since the role already exists.', roleName, userName));
                }
            }
        }
        else
        {
            AppLogging::EventWriteSelfServiceWarning('UserInfo is NULL, cannot add roles to the user.');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateAllValidChannelDatabaseProfileReferences</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Channel Database Profile record pointer for every <c>RetailCDXDataStoreChannel</c> and <c>channelTableExt</c>
    /// entry currently pointing to a valid <c>RetailConnDatabaseProfile</c> record.
    /// </summary>
    /// <param name = "newChannelDBProfileRecId"> The  Channel Database Profile Record to point to. </param>
    public static void UpdateAllValidChannelDatabaseProfileReferences(RecId newChannelDBProfileRecId)
    {
        ttsbegin;

        RetailCDXDataStoreChannel channelDataStore;
        RetailCDXDataStoreChannel channelDataStoreCheck;

        // Ensure at most one entry exists in the DataStoreChannel table for each channel.
        delete_from channelDataStore
            exists join channelDataStoreCheck
            where channelDataStore.Channel == channelDataStoreCheck.Channel
            && channelDataStore.RecId > channelDataStoreCheck.RecId;

        // Update these unique channel records to point to the specified database profile.
        update_recordset channelDataStore
            setting DatabaseProfile = newChannelDBProfileRecId;

        RetailChannelTableExt channelTableExt;
        RetailConnDatabaseProfile databaseProfile;

        // Delete any channelTableExt entries for channels not mapped to a database profile
        delete_from channelTableExt
            notexists join channelDataStore
            where channelTableExt.Channel == channelDataStore.channel;

        // For every channelTableExt entry currently pointed to liveChannelDatabase,
        // update that reference to the specified channel DB.
        update_recordset channelTableExt
            setting LiveChannelDatabase = newChannelDBProfileRecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateAllRtsProfileReferences</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces the existing Transaction Service Profile ID on every Retail channel table, retail shared parameters, and
    /// store connect profile entry.
    /// </summary>
    /// <param name = "profileId"> The Transaction Service Profile to point all tables that reference <c>RetailTransactionServiceProfile</c> to. </param>
    public static void UpdateAllRtsProfileReferences(RetailTransactionServiceProfileId profileId)
    {
        RetailChannelTable retailChannelTable;
        RetailSharedParameters retailSharedParameters;
        RetailConnStoreConnectProfile retailConnStoreConnectProfile;

        ttsbegin;

        while select forupdate retailSharedParameters
        {
            retailSharedParameters.transactionServiceProfile = profileId;
            retailSharedParameters.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetailSchedulerEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the Retail and RetailScheduler are enabled or not.
    /// </summary>
    /// <returns> True if Retail and RetailScheduler are enabled; otherwise, false. </returns>
    public static boolean isRetailSchedulerEnabled()
    {
        return RetailDeploymentUtility::isRetailEnabled() && isConfigurationkeyEnabled(configurationKeyNum(RetailScheduler));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetailEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the Retail is enabled or not.
    /// </summary>
    /// <returns> True if Retail is enabled; otherwise, false. </returns>
    public static boolean isRetailEnabled()
    {
        return isConfigurationkeyEnabled(configurationKeyNum(Retail));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEnvironmentConfiguredForProduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the currently deployment environment is configured for production use.
    /// </summary>
    /// <returns>True if configured for production; otherwise, false.</returns>
    public static boolean isEnvironmentConfiguredForProduction()
    {
        UserInfo userInfoTable;
        boolean result = false;

        select firstonly1 userInfoTable where userInfoTable.id == 'Admin';
        System.String networkDomainField = userInfoTable.networkDomain;

        // Check if the string "ppe" exists in the parent string.
        if (networkDomainField.IndexOf("ppe", System.StringComparison::OrdinalIgnoreCase) < 0)
        {
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentCloud</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the cloud environment region.
    /// </summary>
    /// <returns>The string identifying current cloud region.</returns>
    public static str getCurrentCloud()
    {
        str azureCloud = AzureGlobal;

        try
        {
            // full set of possible values is available here:
            // https://docs.microsoft.com/en-us/azure/active-directory/develop/authentication-national-cloud
            IApplicationEnvironment environment = EnvironmentFactory::GetApplicationEnvironment();
            System.String identityEndpoint = environment.Provisioning.AdminIdentityProvider;
            if (identityEndpoint != '')
            {
                System.Uri aadUrl = new System.Uri(identityEndpoint);
                if (aadUrl.HostNameType == System.UriHostNameType::Dns || aadUrl.HostNameType == System.UriHostNameType::Basic)
                {
                    if (aadUrl.Host.EndsWith(".cn", System.StringComparison::InvariantCultureIgnoreCase))
                    {
                        azureCloud = AzureChina;
                    }
                    else if (aadUrl.Host.EndsWith(".de", System.StringComparison::InvariantCultureIgnoreCase))
                    {
                        azureCloud = AzureGermany;
                    }
                    else if (aadUrl.Host.EndsWith(".us", System.StringComparison::InvariantCultureIgnoreCase))
                    {
                        azureCloud = AzureUSGov;
                    }
                }
            }
        }
        catch (Exception::CLRError)
        {
            System.Exception clrEx = ClrInterop::getLastException();
            if (clrEx != null && clrEx.get_InnerException() != null)
            {
                AppLogging::EventWriteSelfServiceWarning(strfmt('Unexpected error when reading AdminIdentityProvider configuration: %1. The Azure Global Cloud will be used.', clrEx.get_InnerException().ToString()));
            }
        }
        catch
        {
            AppLogging::EventWriteSelfServiceWarning(strFmt('Unexpected error when reading AdminIdentityProvider configuration. The Azure Global Cloud will be used.'));
        }

        return azureCloud;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateChannelDatabaseAndProfileReferences</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the retail channel database profile and channel profile.
    /// </summary>
    /// <param name = "_fromChannelDatabase">The current channel database profile.</param>
    /// <param name = "_toChannelDatabase">The new channel database profile.</param>
    /// <param name = "_profile">The new channel profile.</param>
    public static void updateChannelDatabaseAndProfileReferences(RetailConnDatabaseProfile _fromChannelDatabase, RetailConnDatabaseProfile _toChannelDatabase, RetailChannelProfile _profile)
    {
        RetailCDXDataStoreChannel   dataStoreChannel;
        RetailChannelTableExt       channelTableExt;
        
        ttsbegin;

        // point RetailCdxDataStoreChannel to new database
        while select forupdate dataStoreChannel
            where dataStoreChannel.DatabaseProfile == _fromChannelDatabase.RecId
        {
            try
            {
                dataStoreChannel.DatabaseProfile = _toChannelDatabase.RecId;
                dataStoreChannel.update();
            }
            catch(Exception::DuplicateKeyException)
            {
                // it is expected to have some duplicated key exceptions in case multiple
                // databases map the same channel.
                continue;
            }
        }

        // point RetailChannelTableExt to new database and profile
        update_recordset channelTableExt
            setting LiveChannelDatabase = _toChannelDatabase.RecId,
                    ChannelProfile      = _profile.RecId
                where channelTableExt.LiveChannelDatabase == _fromChannelDatabase.RecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLegacyCDXDataGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// This creates a new CDX Data Group which we move disabled data bases too to prevent them from being processed.
    /// This will happen on scale unit registration.
    /// Once the group exists we leave it in place.
    /// </summary>
    internal static void addLegacyCDXDataGroup()
    {
        RetailCDXDataGroup dataGroup;
        #RetailCDX;

        dataGroup = RetailCDXDataGroup::findByName(#RetailCdxDataGroup_LegacyName, true);

        if (!dataGroup)
        {
            ttsbegin;
            dataGroup.ChannelSchema = RetailConnChannelSchema::findByName(#AX7SchemaName).RecId;
            dataGroup.Description = "@Retail:RetailCDXLegacyDatabaseGroup";
            dataGroup.Name = #RetailCdxDataGroup_LegacyName;
            dataGroup.FileStorageProvider = 0;
            dataGroup.insert();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDefaultDatabaseGroupMapping</Name>
				<Source><![CDATA[
    /// <summary>
    /// This moves the default database to the disabled CDX data group and vice versa depending if scale unit registration or unregistration is executed.
    /// </summary>
    /// <param name = "_retailCDXDataGroupFrom">Move default database from</param>
    /// <param name = "_retailCDXDataGroupTo">Move dafault database to</param>
    internal static void updateDefaultDatabaseGroupMapping(Name _dataGroupFrom, Name _dataGroupTo)
    {
        RetailCDXDataGroup dataGroupFrom;
        RetailCDXDataGroup dataGroupTo;
        RetailConnDatabaseProfile defaultChannelDatabase;
        #RetailCDX;

        ttsbegin;
        dataGroupFrom = RetailCDXDataGroup::findByName(_dataGroupFrom);
        dataGroupTo = RetailCDXDataGroup::findByName(_dataGroupTo);

        if (dataGroupFrom && dataGroupTo)
        {
            update_recordset defaultChannelDatabase
                setting DataGroup = dataGroupTo.RecId
                where defaultChannelDatabase.DataGroup == dataGroupFrom.RecId
                && defaultChannelDatabase.Name == #RetailConnDatabaseProfile_DefaultDBName;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>RunCDXJobsForDataGroup</Name>
				<Source><![CDATA[
    private static void RunCDXJobsForDataGroup(RetailCDXDataGroup dataGroup, RetailConnDatabaseProfile dataStore, int timeoutInMinutes, boolean waitForJobToFinish)
    {
        RetailCDXDownloadSession            downloadSession;
        RetailCDXDownloadSessionDataStore   downloadSessionDataStore;
        RetailCDXScheduleRunner             runner;
        RetailCDXSessionNumber              lowerBound;
        RetailConnSchedule                  schedule;
        
        System.Exception                    exception;
        
        str aggregatedErrorMessage = '';
        str errorMessage;

        int i = 1;

        select maxof(Session)
            from downloadSession;

        lowerBound = downloadSession.Session;

        select firstonly RecId from schedule where schedule.Name == '9999';

        try
        {
            runner = new RetailCDXScheduleRunner();
            runner.setFullSync(schedule.RecId, dataGroup.RecId, conNull());
            runner.runOperation();
            info (strfmt('Scheduling full sync for datagroup %1 is done.', dataGroup.Name));

            if (waitForJobToFinish)
            {
                for (i = 1; i <= timeoutInMinutes; ++i)
                {
                    // all download sessions should be Available or NoData
                    select firstonly * from downloadSession
                        where downloadSession.Session > lowerBound
                            && (downloadSession.Status == RetailCDXDownloadSessionStatus::CreateFailed
                            || downloadSession.Status == RetailCDXDownloadSessionStatus::ApplyFailed
                            || downloadSession.Status == RetailCDXDownloadSessionStatus::DownloadFailed
                            );

                    if (downloadSession)
                    {
                        error (strfmt('Scheduler job %1 has failed with error message: %2', downloadSession.JobID, downloadSession.Message));
                    }
                
                    // Start state of DownloadSessionStatStore is Available. They should be changed to other state when processing completes.
                    select firstonly RecId
                        from downloadSessionDataStore
                            exists join downloadSession
                        where downloadSessionDataStore.Session == downloadSession.RecId
                           && downloadSession.Session > lowerBound
                           && downloadSession.Status == RetailCDXDownloadSessionStatus::Available
                           && downloadSessionDataStore.DataStore == dataStore.RecId
                           && downloadSessionDataStore.Status != RetailCDXDownloadSessionStatus::Applied;

                    if (downloadSessionDataStore)
                    {
                        sleep(SleepIntervalForCDX); // check 1 min later
                    }
                    else
                    {
                        info (strFmt('Finished processing data packages for all download sessions in %1 min, checking result...', i));
                        break;
                    }
                }

                if (i > timeoutInMinutes)
                {
                    errorMessage = strFmt('Not able to finish applying data packages for all download sessions within %1 min timeout.', timeoutInMinutes);
                    info (errorMessage);
                    aggregatedErrorMessage = errorMessage;
                    aggregatedErrorMessage += System.Environment::NewLine;

                    // downloadSessionDataStore records always exist, otherwise it would have failed in previous step.
                    while select *
                        from downloadSessionDataStore
                            join * from downloadSession
                            order by downloadSession.Session
                        where downloadSessionDataStore.Session == downloadSession.RecId
                            && downloadSession.Session > lowerBound
                            && downloadSessionDataStore.DataStore == dataStore.RecId
                            && downloadSessionDataStore.Status != RetailCDXDownloadSessionStatus::Applied
                    {
                        errorMessage = strFmt("Session: %1; Job: %2; Status: %3; Message: %4; Try count: %5; Row version: %6; Rows affected (reading): %7;",
                        downloadSession.Session,
                        downloadSession.JobID,
                        downloadSessionDataStore.Status,
                        downloadSessionDataStore.Message,
                        downloadSessionDataStore.TryCount,
                        downloadSession.SyncRowVersion,
                        downloadSession.RowsAffected);

                        info (errorMessage);

                        aggregatedErrorMessage += System.Environment::NewLine;
                        aggregatedErrorMessage += errorMessage;
                    }

                    if (aggregatedErrorMessage)
                    {
                        throw Global::error(aggregatedErrorMessage);
                    }
                }

                info ('All data packages have been successfully applied.');
            }
            else
            {
                info (strfmt('waitForJobToFinish is NOT set for datagroup %1, will return to other processing.', dataGroup.Name));
            }
        }
        catch (exception)
        {
            errorMessage = 'Retail Post-Deployment configuration service encountered a failure during CDX full sync job.';
            error (errorMessage);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSetupDataForTestEnvironment</Name>
				<Source><![CDATA[
    internal static boolean shouldSetupDataForTestEnvironment(str identityProvider, str aadTenantId)
    {
        IApplicationEnvironment environment = EnvironmentFactory::GetApplicationEnvironment();
        HostingEnvironment hostingEnv = environment.Common.HostingEnvironment;
        str hostingEnvStr = hostingEnv.ToString();
        AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('Hosting environment: %1', hostingEnvStr));

        // For service fabric environments, the hosting environment is ServiceFabric or SyncEngine, based on whether it is executed as batch job or DB Sync.
        boolean isSFEnvironment = hostingEnv == HostingEnvironment::ServiceFabric
            || hostingEnv == HostingEnvironment::SyncEngine;

        if (!isSFEnvironment)
        {
            AppLogging::EventWriteRetailDeploymentSetupInformation('Skip running seed data because environment is not Service Fabric.');
            return false;
        }

        if (!RetailDeploymentUtility::DoesAadIssuerIndicateTestEnvironment(identityProvider) && !RetailDeploymentUtility::DoesAadTenantIdIndicateTestEnvironment(aadTenantId))
        {
            AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('Skip running seed data because neither identity provider: %1 or tenant id %2 indicating that this is a test environment.', identityProvider, aadTenantId));
            return false;
        }

        if (!RetailDeploymentUtility::isDemoDataLoaded())
        {
            AppLogging::EventWriteRetailDeploymentSetupInformation('Skip running seed data because demo data is not loaded.');
            return false;
        }
        
        AppLogging::EventWriteRetailDeploymentSetupInformation('Test environment detected using Service Fabric with demo data loaded.');
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAadAuthorityPrefix</Name>
				<Source><![CDATA[
    internal static str getAadAuthorityPrefix()
    {
        AppLogging::EventWriteRetailDeploymentSetupInformation('BEGIN - getAadAuthorityPrefix');
        str aadIssuerNameFormat = RetailDeploymentUtility::GetAadIssuerNameFormat();
        str adminIdentityProvider = RetailDeploymentUtility::GetAdminIdentityProvider();
        str lcsEndpoint = RetailDeploymentUtility::GetLcsEndpoint();
        str aadAuthorityPrefix;
        str ppeAuthorityPrefix = 'https://sts.windows-ppe.net/';
        str nonPPEAuthorityPrefix = 'https://sts.windows.net/';

        if (aadIssuerNameFormat)
        {
            // Assign AADAuthorityPrefix from AADIssuerNameFormat
            AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('Assigning identity provider from web.config Aad.AADIssuerNameFormat: %1', aadIssuerNameFormat));

            if (strEndsWith(aadIssuerNameFormat, '{0}'))
            {
                aadAuthorityPrefix = strReplace(aadIssuerNameFormat, '{0}', '');
            }
            else
            {
                aadAuthorityPrefix = strReplace(aadIssuerNameFormat, '{0}/', '');
            }

            AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('Value of aadAuthorityPrefix: %1', aadAuthorityPrefix));
        }
        else if (adminIdentityProvider)
        {
            // Assign AADAuthorityPrefix from AdminIdentityProvider
            AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('Assigning identity provider from web.config Provisioning.AdminIdentityProvider: %1.', adminIdentityProvider));
            aadAuthorityPrefix = adminIdentityProvider;
        }
        else if (lcsEndpoint)
        {
            // Assign AADAuthorityPrefix from LCS endpoint.
            if (strContains(lcsEndpoint, 'lcsapi.lcs.dynamics') || strContains(lcsEndpoint, 'lcsapi.eu.lcs.dynamics') ||
                strContains(lcsEndpoint, 'lcsapi.fr.lcs.dynamics') || strContains(lcsEndpoint, 'lcsapi.sa.lcs.dynamics') ||
                strContains(lcsEndpoint, 'lcsapi.uae.lcs.dynamics') || strContains(lcsEndpoint, 'lcsapi.ch.lcs.dynamics') ||
                strContains(lcsEndpoint, 'lcsapi.gov.lcs.microsoftdynamics.us'))
            {
                AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('LCS API endpoint is %1, environment is recognized as PROD. Assigning identity provider to %2.', adminIdentityProvider, nonPPEAuthorityPrefix));
                aadAuthorityPrefix = nonPPEAuthorityPrefix;
            }
            else
            {
                AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('LCS API endpoint is %1, environment is NOT recognized as PROD. Assigning identity provider to %2.', adminIdentityProvider, ppeAuthorityPrefix));
                aadAuthorityPrefix = ppeAuthorityPrefix;
            }
        }
        else
        {
            // Couldn't find any values from web config.
            AppLogging::EventWriteRetailDeploymentSetupWarning('Failed to get aadAuthorityPrefix.');
        }

        AppLogging::EventWriteRetailDeploymentSetupInformation('END - getAadAuthorityPrefix');
        return aadAuthorityPrefix;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAadTenantId</Name>
				<Source><![CDATA[
    internal static str GetAadTenantId()
    {
        str aadTenantId;
        int fromLine;

        try
        {
            fromLine = Global::infologLine();
            AppLogging::EventWriteRetailDeploymentSetupInformation('BEGIN - getAadTenantId...');
            IApplicationEnvironment environment = EnvironmentFactory::GetApplicationEnvironment();
            
            if (!environment.Aad)
            {
                // Property Aad on environment instance is NULL
                AppLogging::EventWriteRetailDeploymentSetupWarning('Property Aad is NULL from object instance IApplicationEnvironment');
            }
            else
            {
                AppLogging::EventWriteRetailDeploymentSetupInformation('Property Aad is NOT NULL from object instance IApplicationEnvironment. Getting property Aad.AADTenantId...');

                if (!environment.Aad.AADTenantId)
                {
                    // Property AADTenantId on instance environment.Aad is empty string
                    AppLogging::EventWriteRetailDeploymentSetupWarning('Property Aad.AADTenantId is empty string from object instance IApplicationEnvironment');
                }
                else
                {
                    // Example value on web.config:
                    // <add key="Aad.AADTenantId" value="contosoax7.onmicrosoft.com" />
                    AppLogging::EventWriteRetailDeploymentSetupInformation('Getting web.config property Aad.AADTenantId');
                    aadTenantId = environment.Aad.AADTenantId;
                    AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('Succeeded getting web.config property Aad.AADTenantId: %1', aadTenantId));
                }
            }
        }
        catch (Exception::CLRError)
        {
            System.Exception clrException = RetailUtilities::getLatestClrException();
             
            AppLogging::EventWriteRetailDeploymentSetupWarning(strFmt('CLR Exception thrown when trying to get identity provider using Aad.AADTenantId config. Message: %1 Stack Trace: %2', clrException.Message, clrException.StackTrace));
        }
        catch (Exception::Error)
        {
            str exceptionMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            AppLogging::EventWriteRetailDeploymentSetupWarning(strFmt('X++ Exception thrown when trying to get identity provider using Aad.AADTenantId config. Message: %1', exceptionMessage));
        }

        AppLogging::EventWriteRetailDeploymentSetupInformation('END - getAadTenantId...');

        return aadTenantId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAadIssuerNameFormat</Name>
				<Source><![CDATA[
    private static str GetAadIssuerNameFormat()
    {
        str aadIssuerNameFormat;
        int fromLine;

        try
        {
            fromLine = Global::infologLine();
            AppLogging::EventWriteRetailDeploymentSetupInformation('BEGIN - getAadIssuerNameFormat...');
            IApplicationEnvironment environment = EnvironmentFactory::GetApplicationEnvironment();
            
            if (!environment.Aad)
            {
                // Property Aad on environment instance is NULL
                AppLogging::EventWriteRetailDeploymentSetupWarning('Property Aad is NULL from object instance IApplicationEnvironment');
            }
            else
            {
                AppLogging::EventWriteRetailDeploymentSetupInformation('Property Aad is NOT NULL from object instance IApplicationEnvironment. Getting property Aad.AADIssuerNameFormat...');

                if (!environment.Aad.AADIssuerNameFormat)
                {
                    // Property AADIssuerNameFormat on instance environment.Aad is empty string
                    AppLogging::EventWriteRetailDeploymentSetupWarning('Property Aad.AADIssuerNameFormat is empty string from object instance IApplicationEnvironment');
                }
                else
                {
                    // Example value on web.config:
                    // <add key="Aad.AADIssuerNameFormat" value="https://sts.windows-ppe.net/{0}/" />
                    AppLogging::EventWriteRetailDeploymentSetupInformation('Getting web.config property Aad.AADIssuerNameFormat');
                    aadIssuerNameFormat = environment.Aad.AADIssuerNameFormat;
                    AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('Succeeded getting web.config property Aad.AADIssuerNameFormat: %1', aadIssuerNameFormat));
                }
            }
        }
        catch (Exception::CLRError)
        {
            System.Exception clrException = RetailUtilities::getLatestClrException();
             
            AppLogging::EventWriteRetailDeploymentSetupWarning(strFmt('CLR Exception thrown when trying to get identity provider using Aad.AADIssuerNameFormat config. Message: %1 Stack Trace: %2', clrException.Message, clrException.StackTrace));
        }
        catch (Exception::Error)
        {
            str exceptionMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            AppLogging::EventWriteRetailDeploymentSetupWarning(strFmt('X++ Exception thrown when trying to get identity provider using Aad.AADIssuerNameFormat config. Message: %1', exceptionMessage));
        }

        AppLogging::EventWriteRetailDeploymentSetupInformation('END - getAadIssuerNameFormat...');

        return aadIssuerNameFormat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAdminIdentityProvider</Name>
				<Source><![CDATA[
    private static str GetAdminIdentityProvider()
    {
        str adminIdentityProvider;
        int fromLine;

        try
        {
            fromLine = Global::infologLine();
            AppLogging::EventWriteRetailDeploymentSetupInformation('BEGIN - getAdminIdentityProvider...');
            IApplicationEnvironment environment = EnvironmentFactory::GetApplicationEnvironment();
            
            if (!environment.Provisioning)
            {
                // Property Provisioning on environment instance is NULL
                AppLogging::EventWriteRetailDeploymentSetupWarning('Property Provisioning is NULL from object instance IApplicationEnvironment');
            }
            else
            {
                AppLogging::EventWriteRetailDeploymentSetupInformation('Property Provisioning is NOT NULL from object instance IApplicationEnvironment. Getting property Provisioning.AdminIdentityProvider...');

                if (!environment.Provisioning.AdminIdentityProvider)
                {
                    // Property AdminIdentityProvider on instance environment.Provisioning is empty string
                    AppLogging::EventWriteRetailDeploymentSetupWarning('Property Provisioning.AdminIdentityProvider is empty string from object instance IApplicationEnvironment');
                }
                else
                {
                    // Example value on web.config:
                    // <add key="Provisioning.AdminIdentityProvider" value="https://sts.windows-ppe.net/" />
                    AppLogging::EventWriteRetailDeploymentSetupInformation('Getting web.config property Provisioning.AdminIdentityProvider');
                    adminIdentityProvider = environment.Provisioning.AdminIdentityProvider;
                    AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('Succeeded getting web.config property Provisioning.AdminIdentityProvider: %1', adminIdentityProvider));
                }
            }
        }
        catch (Exception::CLRError)
        {
            System.Exception clrException = RetailUtilities::getLatestClrException();
             
            AppLogging::EventWriteRetailDeploymentSetupWarning(strFmt('CLR Exception thrown when trying to get Provisioning.AdminIdentityProvider config. Message: %1 Stack Trace: %2', clrException.Message, clrException.StackTrace));
        }
        catch (Exception::Error)
        {
            str exceptionMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            AppLogging::EventWriteRetailDeploymentSetupWarning(strFmt('X++ Exception thrown when trying to get Provisioning.AdminIdentityProvider config. Message: %1', exceptionMessage));
        }

        AppLogging::EventWriteRetailDeploymentSetupInformation('END - getAdminIdentityProvider...');
        return adminIdentityProvider;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLcsEndpoint</Name>
				<Source><![CDATA[
    private static str GetLcsEndpoint()
    {
        str lcsEndpoint;
        int fromLine;

        try
        {
            fromLine = Global::infologLine();
            AppLogging::EventWriteRetailDeploymentSetupInformation('BEGIN - getLcsEndpoint...');
            IApplicationEnvironment environment = EnvironmentFactory::GetApplicationEnvironment();
            
            if (!environment.LCS)
            {
                // Property LCS on environment instance is NULL
                AppLogging::EventWriteRetailDeploymentSetupWarning('Property LCS is NULL from object instance IApplicationEnvironment');
            }
            else
            {
                AppLogging::EventWriteRetailDeploymentSetupInformation('Property LCS is NOT NULL from object instance IApplicationEnvironment. Getting property LCS.LCSAPIEndPoint...');

                if (!environment.LCS.LCSAPIEndPoint)
                {
                    // Property LCSAPIEndPoint on instance environment.LCS is empty string.
                    AppLogging::EventWriteRetailDeploymentSetupWarning('Property LCS.LCSAPIEndPoint is is empty string from object instance IApplicationEnvironment');
                }
                else
                {
                    // Example value on web.config:
                    // <add key="LCS.APIEndPoint" value="https://lcsapi.lcs.tie.dynamics.com" />
                    AppLogging::EventWriteRetailDeploymentSetupInformation('Getting web.config property Provisioning.AdminIdentityProvider');
                    lcsEndpoint = environment.LCS.LCSAPIEndPoint;
                    AppLogging::EventWriteRetailDeploymentSetupInformation(strFmt('Succeeded getting web.config property LCS.APIEndPoint: %1', lcsEndpoint));
                }
            }
        }
        catch (Exception::CLRError)
        {
            System.Exception clrException = RetailUtilities::getLatestClrException();
             
            AppLogging::EventWriteRetailDeploymentSetupWarning(strFmt('CLR Exception thrown when trying to get LCS.LCSAPIEndPoint config. Message: %1 Stack Trace: %2', clrException.Message, clrException.StackTrace));
        }
        catch (Exception::Error)
        {
            str exceptionMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            AppLogging::EventWriteRetailDeploymentSetupWarning(strFmt('X++ Exception thrown when trying to get LCS.LCSAPIEndPoint config. Message: %1', exceptionMessage));
        }

        AppLogging::EventWriteRetailDeploymentSetupInformation('END - getLcsEndpoint...');
        return lcsEndpoint;
    }

]]></Source>
			</Method>
			<Method>
				<Name>DoesAadIssuerIndicateTestEnvironment</Name>
				<Source><![CDATA[
    private static boolean DoesAadIssuerIndicateTestEnvironment(str identityProvider)
    {
        str identityProviderLowerCase = strLwr(identityProvider);

        if (System.String::IsNullOrWhiteSpace(identityProviderLowerCase))
        {
            return false;
        }

        return strContains(identityProviderLowerCase, internalAadIssuerPrefix);
    }

]]></Source>
			</Method>
			<Method>
				<Name>DoesAadTenantIdIndicateTestEnvironment</Name>
				<Source><![CDATA[
    private static boolean DoesAadTenantIdIndicateTestEnvironment(str aadTenantId)
    {
        str aadTenantIdLowerCase = strLwr(aadTenantId);
        
        if (System.String::IsNullOrWhiteSpace(aadTenantIdLowerCase))
        {
            return false;
        }

        return strCmp(aadTenantIdLowerCase, internalTenantId) == 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>