<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceEmployee</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;
using AppLogging = Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource;

/// <summary>
/// The <c>RetailTransactionServiceEmployee</c> implements the employee related methods of the service interface exposed by the <c>RetailTransactionService</c> class to the retail channels.
/// </summary>
public class RetailTransactionServiceEmployee
{
    #define.timeEntryValuesToReturn(timeEntry.RecId, timeEntry.RegDateTime)
    #define.timeEntrySuccessResultPosition(1)
    #define.timeEntryErrorMessagePosition(2)
    #define.timeEntryRecIdPosition(3)
    #define.timeEntryRegDateTimePosition(4)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addTimeRawRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a record to time raw registrations for the worker specified.
    /// </summary>
    /// <param name="_workerRecId">
    /// RecId of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id, which time registration applies to.
    /// </param>
    /// <param name="_regType">
    /// Type of time registration (Clock In, Clock Out, Break, Stop break)
    /// </param>
    /// <param name="_jobId">
    /// Job id (e.g. job for break for lunch). Optional.
    /// </param>
    /// <param name="_matchRecId">
    /// Rec id that newly added record should be matched to (in case stop break registration). Optional.
    /// </param>
    /// <returns>
    /// Container with operation status (success or error), error message (if any), RecId of the new clock entry and its registration time (last two, if operation is successful).
    /// </returns>
    private static container addTimeRawRegistration(RecId _workerRecId, RetailTerminalId _terminalId, JmgTermRegType _regType,
                                                        JmgJobId _jobId = '', RefRecId _matchRecId = 0)
    {
        JmgTermReg      timeEntry;
        JmgJobId        jobId;
        JmgProfileDay   jmgProfileDay;
        utcDateTime     now = DateTimeUtil::getSystemDateTime();
        Timezone        timezone = RetailTransactionServiceEmployee::getWorkerTimezoneByTerminalId(_terminalId);
        Timezone        originalTimeZone = DateTimeUtil::getUserPreferredTimeZone();
        JmgDate         regDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(now,timezone));
        JmgTime         regTime = DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(now,timezone));

        switch (_regType)
        {
            case JmgTermRegType::ClockIn:
                //checking time registration profile for the worker
                jmgProfileDay   = JmgProfileDay::find(JmgEmployee::find(_workerRecId).profileId(regDate, regTime), JmgProfiles::date2DayId(regDate));
                if (!jmgProfileDay)
                {
                    return [false ,(strFmt("@REX4520239",HcmWorker::find(_workerRecId).PersonnelNumber))];
                }
                jobId = JmgIpcActivity::findSignInJobId();
                break;
            case JmgTermRegType::ClockOut:
                jobId = JmgIpcActivity::findSignOutJobId();
                break;
            case JmgTermRegType::BrkFlowStart:
                jobId = JmgIpcActivity::findJobId(_jobId).JobId;
                break;
            case JmgTermRegType::BrkFlowStop:
                jobId = JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StopBreak);
                if (jobId && _matchRecId == 0)
                {
                    // wrong parameters specified
                    return [false, strfmt("@SYS83964", enum2str(JmgSignInOut::StopBreak))];
                }
                else
                {
                    timeEntry.MatchRecIdStartStop = _matchRecId; // match start and stop break records
                }
                break;
            default:
                jobId = '';
        }

        if (!jobId)
        {
            // job doesn't exist
            return [false, strfmt("@SYS38535", enum2str(_regType))];
        }

        ttsBegin;

        try
        {
            // Set the timezone as corresponding store timezone.
            // If not, it will directly use retailserviceAccount timezone, which may not be making sense for customer has stores across different timezone areas.
            DateTimeUtil::setUserPreferredTimeZone(timezone, false);
            timeEntry.Worker = _workerRecId;
            timeEntry.ProfileDate = DateTimeUtil::getSystemDate(timezone);
            timeEntry.RegType = _regType;
            timeEntry.JobId = jobId;
            timeEntry.JobActive = NoYes::Yes;
            timeEntry.RegDateTime = now;
            timeEntry.RetailTerminalId = _terminalId;
            timeEntry.TerminalId = _terminalId;         // This is for populating the information to JmgStampJournalTrans TermStart and TermStop.
            timeEntry.insert();
        }
        finally
        {
            DateTimeUtil::setUserPreferredTimeZone(originalTimeZone, false);
        }

        ttsCommit;

        return [true, '', #timeEntryValuesToReturn];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkerTimezoneByTerminalId</Name>
				<Source><![CDATA[
    private static Timezone getWorkerTimezoneByTerminalId(RetailTerminalId _terminalId)
    {
        Timezone timezone = DateTimeUtil::getUserPreferredTimeZone();
        RetailTerminalTable terminal = RetailTerminalTable::find(_terminalId);
        if (terminal.StoreRecId)
        {
            timezone = RetailTransactionServiceEmployee::getWorkerTimezonebyStoreRecId(terminal.StoreRecId);
        }

        return timezone;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkerTimezonebyStoreRecId</Name>
				<Source><![CDATA[
    private static Timezone getWorkerTimezonebyStoreRecId(RecId storeRecId)
    {
        Timezone timezone = DateTimeUtil::getUserPreferredTimeZone();
        if (RetailStoreTable::findRecId(storeRecId))
        {
            timezone = RetailChannelTable::getChannelTimezone(storeRecId);
        }

        return timezone;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyCompanyTimeZone</Name>
				<Source><![CDATA[
    private static str applyCompanyTimeZone(utcdatetime _dateTime)
    {
        return RetailTransactionServiceUtilities::utcDateTimeToString(DateTimeUtil::applyTimeZoneOffset(_dateTime, DateTimeUtil::getCompanyTimeZone()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>clockIn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers clock-in for the worker specified.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id, where worker makes a time registration.
    /// </param>
    /// <returns>
    /// A container having information whether registration is successful.
    /// </returns>
    /// <remarks>
    /// If time registration fails, returned container will also have error message.
    /// </remarks>
    public static container clockIn(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId)
    {
        boolean     success = true;
        str         errorMessage;
        utcDateTime operationDateTime;
        container   newTimeEntryResult;
        JmgTermReg  currentTimeRegistrationState = RetailTransactionServiceEmployee::getLatestTimeRegistrationByWorker(_personnelNumber, _terminalId, true);
        HcmWorker   worker = HcmWorker::findByPersonnelNumber(_personnelNumber);
        Timezone	timezone = RetailTransactionServiceEmployee::getWorkerTimezoneByTerminalId(_terminalId);
        Timezone	originalTimeZone = DateTimeUtil::getUserPreferredTimeZone();

        // Check current registration state of the worker
        // Clockin is allowed when:
        // - there is no information about worker's registration state (recid = 0);
        // - worker is not already clocked in.
        if (    (currentTimeRegistrationState.RecId == 0)
             || (currentTimeRegistrationState.RegType != JmgTermRegType::ClockIn) )
        {
            // if worker is on break now, we will update the current registration state after registering a clock-in
            if (currentTimeRegistrationState.RegType == JmgTermRegType::BrkFlowStart)
            {
                ttsBegin;
                newTimeEntryResult = RetailTransactionServiceEmployee::addTimeRawRegistration(worker.RecId, _terminalId, JmgTermRegType::BrkFlowStop, '', currentTimeRegistrationState.RecId);
                if (conPeek(newTimeEntryResult, #timeEntrySuccessResultPosition)) // new entry has been added successfully or not?
                {
                    currentTimeRegistrationState.MatchRecIdStartStop = conPeek(newTimeEntryResult, #timeEntryRecIdPosition); // match start and stop break records
                    // Set the timezone as corresponding store timezone, to be consistent with addTimeRawRegistration
                    DateTimeUtil::setUserPreferredTimeZone(timezone, false);
                    try
                    {
                        currentTimeRegistrationState.update();
                    }
                    finally
                    {
                        DateTimeUtil::setUserPreferredTimeZone(originalTimeZone, false);
                    }
                    operationDateTime = conPeek(newTimeEntryResult, #timeEntryRegDateTimePosition);
                }
                else
                {
                    success = false;
                    errorMessage = conPeek(newTimeEntryResult, #timeEntryErrorMessagePosition); // reason of why new time entry has not been added
                }
                ttsCommit;
            }
            else
            {
                // if worker is not on break, just register a clock-in
                newTimeEntryResult = RetailTransactionServiceEmployee::addTimeRawRegistration(worker.RecId, _terminalId, JmgTermRegType::ClockIn);
                if (conPeek(newTimeEntryResult, #timeEntrySuccessResultPosition)) // new entry has been added successfully or not?
                {
                    operationDateTime = conPeek(newTimeEntryResult, #timeEntryRegDateTimePosition);
                }
                else
                {
                    success = false;
                    errorMessage = conPeek(newTimeEntryResult, #timeEntryErrorMessagePosition); // reason of why new time entry has not been added
                }
            }
        }
        else
        {
            // if worker is already clocked in, return error
            success = false;
            errorMessage = "@RET4160280";
        }

        // returning time of operation, so POS can get the exact clock-in time
        return [success, errorMessage, DateTimeUtil::toStr(operationDateTime)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>clockOut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers clock-out for the worker specified.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id, where worker makes a time registration.
    /// </param>
    /// <returns>
    /// A container having information whether registration is successful.
    /// </returns>
    /// <remarks>
    /// If time registration fails, returned container will also have error message.
    /// </remarks>
    public static container clockOut(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId)
    {
        boolean             success = true;
        str                 errorMessage;
        utcDateTime         operationDateTime;
        container           newTimeEntryResult;
        JmgTermReg          currentTimeRegistrationState = RetailTransactionServiceEmployee::getLatestTimeRegistrationByWorker(_personnelNumber, _terminalId);
        HcmWorker           worker = HcmWorker::findByPersonnelNumber(_personnelNumber);

        // check current registration state of the worker
        if (currentTimeRegistrationState.regType != JmgTermRegType::ClockOut)
        {
            // check whether the worker is on break
            if (currentTimeRegistrationState.regType != JmgTermRegType::BrkFlowStart)
            {
                // if the worker is not on break, register clock-out
                newTimeEntryResult = RetailTransactionServiceEmployee::addTimeRawRegistration(worker.RecId, _terminalId, JmgTermRegType::ClockOut);
                if (conPeek(newTimeEntryResult, #timeEntrySuccessResultPosition)) // new entry has been added successfully or not?
                {
                    operationDateTime = conPeek(newTimeEntryResult, #timeEntryRegDateTimePosition);
                }
                else
                {
                    success = false;
                    errorMessage = conPeek(newTimeEntryResult, #timeEntryErrorMessagePosition); // reason of why new time entry has not been added
                }
            }
            else
            {
                // if the worker is on break, he or she should not be allowed to clock out
                success = false;
                errorMessage = "@RET4160281";
            }
        }
        else
        {
            // if worker is already clocked out, return error
            success = false;
            errorMessage = "@RET4160282";
        }

        return [success, errorMessage, DateTimeUtil::toStr(operationDateTime)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExtendedLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record in <c>RetailStaffExtendedLogOn</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// Staff ID.
    /// </param>
    /// <param name="_logOnKey">
    /// LogOn key.
    /// </param>
    /// <param name="_logOnType">
    /// LogOn key type.
    /// </param>
    /// <param name="_extraData">
    /// Device specific extra data as base 64 string.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container createExtendedLogOn(RetailStaffId _staffId, RetailStaffExtendedLogOnKey _logOnKey, RetailStaffExtendedLogOnType _logOnType, str _extraData)
    {
        #define.ErrorStaffNotFound(1)
        #define.ErrorAlreadyExists(2)
        #define.ErrorSavingRecord(3)

        boolean result = false;
        int errorCode = 0;
        RetailStaffExtendedLogon staffExtendedLogOn;
        RetailStaffTable retailStaff;

        try
        {
            retailStaff = RetailStaffTable::find(_staffId);

            if (retailStaff)
            {
                staffExtendedLogOn = RetailStaffExtendedLogon::find(_logOnKey, _logOnType);

                if (!staffExtendedLogOn)
                {
                    staffExtendedLogOn.clear();
                    staffExtendedLogOn.LogOnKey = _logOnKey;
                    staffExtendedLogOn.LogOnType = _logOnType;
                    staffExtendedLogOn.ExtraData = BinData::loadFromBase64(_extraData);
                    staffExtendedLogOn.Staff = retailStaff.RecId;
                    staffExtendedLogOn.insert();
                    result = true;
                }
                else
                {
                    errorCode = #ErrorAlreadyExists;
                }
            }
            else
            {
                errorCode = #ErrorStaffNotFound;
            }
        }
        catch(Exception::Error)
        {
            ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), RetailTransactionServiceUtilities::getInfologMessages(Global::infologLine()));
            errorCode = #ErrorSavingRecord;
        }

        return [result, int2str(errorCode), staffExtendedLogOn ? staffExtendedLogOn.RecId : 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSecureExtendedLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record in <c>RetailStaffExtendedLogOn</c>table with hashed log on key.
    /// </summary>
    /// <param name="_staffId">
    /// Staff ID.
    /// </param>
    /// <param name="_logOnKey">
    /// LogOn key.
    /// </param>
    /// <param name="_logOnType">
    /// LogOn key type.
    /// </param>
    /// <param name="_extraData">
    /// Device specific extra data as base 64 string.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container createSecureExtendedLogOn(RetailStaffId _staffId, RetailStaffExtendedLogOnKey _logOnKey, RetailStaffExtendedLogOnType _logOnType, str _extraData)
    {
        #define.ErrorStaffNotFound(1)
        #define.ErrorAlreadyExists(2)
        #define.ErrorSavingRecord(3)

        boolean result = false;
        int errorCode = 0;
        RetailStaffExtendedLogon staffExtendedLogOn;
        RetailStaffTable retailStaff;
        str 256 hashedLogonKey;

        try
        {
            hashedLogonKey = RetailData::HashData2(_logOnKey, RetailSharedParameters::find().StaffPasswordHash, int2str(enum2int(_logOnType)), RetailStaffTable::localContext());

            retailStaff = RetailStaffTable::find(_staffId);

            if (retailStaff)
            {
                select firstonly staffExtendedLogon
                where (staffExtendedLogon.LogOnKey == _logOnKey || staffExtendedLogon.LogOnData == hashedLogonKey)
                && staffExtendedLogon.LogOnType == _logOnType;

                if (!staffExtendedLogOn)
                {
                    staffExtendedLogOn.clear();
                    staffExtendedLogOn.LogOnData = hashedLogonKey;
                    staffExtendedLogOn.LogOnType = _logOnType;
                    staffExtendedLogOn.ExtraData = BinData::loadFromBase64(_extraData);
                    staffExtendedLogOn.Staff = retailStaff.RecId;
                    staffExtendedLogOn.insert();
                    result = true;
                }
                else
                {
                    errorCode = #ErrorAlreadyExists;
                }
            }
            else
            {
                errorCode = #ErrorStaffNotFound;
            }
        }
        catch(Exception::Error)
        {
            ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), RetailTransactionServiceUtilities::getInfologMessages(Global::infologLine()));
            errorCode = #ErrorSavingRecord;
        }

        return [result, int2str(errorCode), staffExtendedLogOn ? staffExtendedLogOn.RecId : 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExtendedLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove records from <c>RetailStaffExtendedLogOn</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// Staff ID.
    /// </param>
    /// <param name="_logOnType">
    /// LogOn key type.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container deleteExtendedLogOn(RetailStaffId _staffId, RetailStaffExtendedLogOnType _logOnType)
    {
        #define.ErrorStaffNotFound(1)
        #define.ErrorSavingRecord(3)

        boolean result = false;
        int errorCode = 0;
        RetailStaffExtendedLogon staffExtendedLogOn;
        RetailStaffTable retailStaff;

        try
        {
            retailStaff = RetailStaffTable::find(_staffId);

            if (retailStaff)
            {
                delete_from staffExtendedLogOn
                    where staffExtendedLogOn.Staff == retailStaff.RecId;

                result = true;
            }
            else
            {
                errorCode = #ErrorStaffNotFound;
            }
        }
        catch(Exception::Error)
        {
            ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), RetailTransactionServiceUtilities::getInfologMessages(Global::infologLine()));
            errorCode = #ErrorSavingRecord;
        }

        return [result, int2str(errorCode)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelIdForTerminal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the channel identifier for the specified terminal.
    /// </summary>
    /// <param name="_terminalId">
    /// The terminal identifier.
    /// </param>
    /// <returns>
    /// The identifier associated with the specified terminal.
    /// </returns>
    private static RetailChannelRecId getChannelIdForTerminal(RetailTerminalId _terminalId)
    {
        RetailTerminalTable retailTerminalTable;

        select firstOnly StoreRecId from retailTerminalTable where retailTerminalTable.TerminalId == _terminalId;
        return retailTerminalTable.StoreRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLatestTimeRegistrationByWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about the latest time registration action of the worker specified.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id associated with the time registration.
    /// </param>
    /// <param name="_forUpdate">
    /// True, if the record should be selected for update; false - otherwise.
    /// </param>
    /// <returns>
    /// JmgTermReg buffer variable with information about worker's latest time registration.
    /// </returns>
    /// <remarks>
    /// When worker stops break, records with start and stop break entries are linked by MatchRecIdStartStop field
    /// So if the last record has StartBreak type and MatchRecIdStartStop == 0, then the worker is on break
    /// If the last record has StopBreak type and MatchRecIdStartStop != 0, then the worker is in clockin status
    /// </remarks>
    private static JmgTermReg getLatestTimeRegistrationByWorker(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId = '', boolean _forUpdate = false)
    {
        JmgTermReg  timeEntries;
        HcmWorker   worker;
        RetailTerminalTable retailTerminalTable;
        RetailChannelRecId channelId;

        if (_terminalId == '')
        {
            select firstOnly timeEntries
                order by timeEntries.RegDateTime desc, RegType desc
                where timeEntries.MatchRecIdStartStop == 0
                exists join worker where worker.RecId == timeEntries.Worker
                    && worker.PersonnelNumber == _personnelNumber;
        }
        else
        {
            channelId = RetailTransactionServiceEmployee::getChannelIdForTerminal(_terminalId);

            select firstOnly timeEntries
                order by timeEntries.RegDateTime desc, RegType desc
                where timeEntries.MatchRecIdStartStop == 0
                exists join worker where worker.RecId == timeEntries.Worker
                    && worker.PersonnelNumber == _personnelNumber
                exists join retailTerminalTable where retailTerminalTable.TerminalId == timeEntries.RetailTerminalId
                    && retailTerminalTable.StoreRecId == channelId;
        }

        timeEntries.selectForUpdate(_forUpdate);

        return timeEntries;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getManagerHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a logbook of time registrations for the manager.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_storeIds">
    /// Ids of stores, where time registration can be viewed (comma separated value CSV of store IDs).
    /// </param>
    /// <param name="_regTypesStr">
    /// The type of time registration (comma seperated value CSV of filters - up to 10 len).
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_jobId">
    /// Job Id of the specific break.
    /// </param>
    /// <returns>
    /// A container having history of time registrations.
    /// </returns>
    /// <remarks>
    /// _jobId parameter is used only if _regType == JmgTermRegType::BrkFlowStart, otherwise it will be skipped
    ///  if _regType == JmgTermRegType::BrkFlowStart and _jobId param is empty or not set, the method will return all the records with break activity disregarding the kind of break
    /// </remarks>
    public static container getManagerHistory(HcmPersonnelNumberId _personnelNumber = '',
                str _storeIds = '',
                str _regTypesStr = '',
                utcDateTime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), 0), // start of the current day
                utcDateTime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), 0), 24), // end of the current day
                JmgJobId _jobId = '')
    {
        container           workerLogBook = [true, ''];
        JmgEmployee         employee;
        JmgTermReg          timeEntry;
        RetailStoreTable    store;
        DirPerson           dirPerson;
        HcmWorker           worker;
        container           regTypes;
        container           stores;
        QueryRun            qr;

        regTypes = RetailTransactionServiceEmployee::intCsvToCon(_regTypesStr);
        stores = str2con(_storeIds, ',', false);
        qr = RetailTransactionServiceEmployee::getTimeclockHistory(true, _personnelNumber, stores, _fromDate, _toDate, regTypes, _jobId);
        while (qr.next())
        {
            worker = qr.get(tableNum(HcmWorker));
            employee = qr.get(tableNum(JmgEmployee));
            timeEntry = qr.get(tableNum(JmgTermReg));
            store = qr.get(tableNum(RetailStoreTable));
            dirPerson = qr.get(tableNum(DirPerson));

            workerLogBook = conIns(workerLogBook, conLen(workerLogBook) + 1,
                                [dirPerson.Name,
                                    worker.PersonnelNumber,
                                    employee.profileId(DateTimeUtil::date(timeEntry.RegDateTime)),
                                    DateTimeUtil::toStr(timeEntry.RegDateTime),
                                    DateTimeUtil::toStr(timeEntry.RegDateTime),
                                    enum2int(timeEntry.RegType),
                                    store.storeNumber,
                                    timeEntry.RecId]);
        }

        return workerLogBook;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getManagerHistoryUtc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a logbook of time registrations for the manager in UTC time zone.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_storeIds">
    /// Ids of stores, where time registration can be viewed (comma separated value CSV of store IDs).
    /// </param>
    /// <param name="_regTypesStr">
    /// The type of time registration (comma seperated value CSV of filters - up to 10 len).
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_jobIds">
    /// Job Ids of the break activities (comma separated value CSV of store IDs).
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of employee activities to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of employee activities to skip.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <returns>
    /// A container having history of time registrations.
    /// </returns>
    /// <remarks>
    /// _jobId parameter is used only if _regType == JmgTermRegType::BrkFlowStart, otherwise it will be skipped
    ///  if _regType == JmgTermRegType::BrkFlowStart and _jobId param is empty or not set, the method will return all the records with break activity disregarding the kind of break
    /// </remarks>
    public static container getManagerHistoryUtc(HcmPersonnelNumberId _personnelNumber = '',
                str _storeIds = '',
                str _regTypesStr = '',
                utcdatetime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), // start of the current date and time (UTC time zone)
                utcdatetime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), 24), // end of the current date and time (UTC time zone)
                str _jobIds = '',
                int64 _top = 100,
                int64 _skip = 0,
                str _orderByField = fieldStr(JmgTermReg, RegDateTime),
                SortOrder _sortOrder = SortOrder::Descending)
    {
        container           workerLogBook = [true, ''];
        JmgEmployee         employee;
        JmgTermReg          timeEntry;
        RetailStoreTable    store;
        DirPerson           dirPerson;
        HcmWorker           worker;
        container           regTypes;
        container           stores;
        container           jobIds;
        QueryRun            qr;

        regTypes = RetailTransactionServiceEmployee::intCsvToCon(_regTypesStr);
        stores = str2con(_storeIds, ',', false);
        jobIds = str2con(_jobIds, ',', false);
        qr = RetailTransactionServiceEmployee::getTimeclockHistoryUtc(
                true,
                _personnelNumber,
                stores,
                _fromDate,
                _toDate,
                regTypes,
                jobIds,
                _top,
                _skip,
                _orderByField,
                _sortOrder);

        while (qr.next())
        {
            worker = qr.get(tableNum(HcmWorker));
            employee = qr.get(tableNum(JmgEmployee));
            timeEntry = qr.get(tableNum(JmgTermReg));
            store = qr.get(tableNum(RetailStoreTable));
            dirPerson = qr.get(tableNum(DirPerson));

            workerLogBook = conIns(workerLogBook, conLen(workerLogBook) + 1,
                                [dirPerson.Name,
                                    worker.PersonnelNumber,
                                    employee.profileId(DateTimeUtil::date(timeEntry.RegDateTime)),
                                    DateTimeUtil::toStr(timeEntry.RegDateTime),
                                    DateTimeUtil::toStr(timeEntry.RegDateTime),
                                    enum2int(timeEntry.RegType),
                                    store.storeNumber,
                                    timeEntry.RecId]);
        }

        return workerLogBook;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStaffPermission</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a container with staff permissions.
    /// </summary>
    /// <param name="staff">
    /// A <c>RetailStaffTable</c> buffer.
    /// </param>
    /// <param name="party">
    /// A <c>DirPartyTable</c> buffer.
    /// </param>
    /// <param name="staffPermission">
    /// A <c>RetailStaffPermission</c> buffer.
    /// </param>
    /// <returns>
    /// The container with staff and permission information.
    /// </returns>
    public static container getStaffPermission( RetailStaffTable staff, DirPartyTable party, RetailStaffPermission staffPermission)
    {
        container result;
        RetailSharedParameters retailSharedParameters = RetailSharedParameters::find();

        // NOTE TO ENG: If this method throws an exception due to error indicating that ID can not be 0
        // field on RetailStaffPermission, then you may need to:
        // 1. Incldue "Maps\RetailStaffPermission" and "Table\RetailPosPermissionGroup" in your project and recompile;
        // 2. Ensure mapping connections exist in "Table\RetailPosPermissionGroup".

        // NOTE TO ENG: The result set returned is also mapped in CRT: TransactionServiceClient.Staff.cs
        // Cooresponding changes here should also be updated in the CRT.
        result = [  staff.staffId, // private const int StaffIdIndex = 0;
                    staff.nameOnReceipt, // private const int NameOnReceiptIndex = 1;
                    staff.Image ? staff.Image : RetailAttributeHelper::getDefaultTextValue(retailSharedParameters.WorkerDefaultAttributeGroup, retailSharedParameters.ImagesAttributeType),
                    party.Name, // private const int NameIndex = 3;
                    staffPermission.maximumDiscountPct, // private const int MaximumDiscountPercentageIndex = 4;
                    staffPermission.maxLineDiscountAmount, // private const int MaximumLineDiscountAmountIndex = 5;
                    staffPermission.maxLineReturnAmount, // private const int MaximumLineReturnAmountIndex = 6;
                    staffPermission.maxTotalDiscountAmount, // private const int MaximumTotalDiscountAmountIndex = 7;
                    staffPermission.maxTotalDiscountPct, // private const int MaximumTotalDiscountPercentageIndex = 8;
                    staffPermission.maxTotalReturnAmount, // private const int MaximumTotalReturnAmountIndex = 9;
                    enum2int(staffPermission.AllowBlindClose),  // private const int AllowBlindCloseIndex = 10;
                    enum2int(staffPermission.allowChangeNoVoid), // private const int AllowChangeNoVoidIndex = 11;
                    enum2int(staffPermission.allowCreateOrder), // private const int AllowCreateOrderIndex = 12;
                    enum2int(staffPermission.allowEditOrder), // private const int AllowEditOrderIndex = 13;
                    enum2int(staffPermission.allowFloatingTenderDeclaration), // private const int AllowFloatingTenderDeclarationIndex = 14;
                    enum2int(staffPermission.allowMultipleLogins), // private const int AllowMultipleLoginsIndex = 15;
                    enum2int(staffPermission.allowMultipleShiftLogon), // private const int AllowMUltipleShiftLogOnIndex = 16;
                    enum2int(staffPermission.allowOpenDrawerOnly), // private const int AllowOpenDrawerIndex = 17;
                    enum2int(staffPermission.allowPriceOverride), // private const int AllowPriceOverrideIndex = 18;
                    enum2int(staffPermission.allowRetrieveOrder), // private const int AllowRetrieveOrderIndex = 19;
                    enum2int(staffPermission.allowSalesTaxChange), // private const int AllowSalesTaxChangeIndex = 20;
                    enum2int(staffPermission.allowTenderDeclaration), // private const int AllowTenderDeclarationIndex = 21;
                    enum2int(staffPermission.allowTransactionSuspension), // private const int AllowTransactionSuspensionIndex = 22;
                    enum2int(staffPermission.allowTransactionVoiding), // private const int AllowTransactionVoidingIndex = 23;
                    enum2int(staffPermission.allowXReportPrinting), // private const int AllowXReportPrintingIndex = 24;
                    enum2int(staffPermission.AllowZReportPrinting), // private const int AllowZReportPrintingIndex = 25;
                    enum2int(staffPermission.allowKitDisassembly),  // private const int AllowKitDisassemblyIndex = 26;
                    enum2int(staffPermission.allowChangePeripheralStation), // private const int AllowChangePeripheralStationIndex = 27;
                    enum2int(staffPermission.manageDevice), // private const int ManageDeviceIndex = 28;
                    enum2int(staffPermission.managerPrivileges), // private const int AllowManagerPrivilegesIndex = 29;
                    enum2int(staffPermission.AllowPasswordChange), // private const int AllowPasswordChangeIndex = 30;
                    enum2int(staffPermission.AllowResetPassword), // private const int AllowResetPasswordIndex = 31;
                    enum2int(staff.continueOnTSErrors), // private const int ContinueOnTSErrorsIndex = 32;
                    staff.cultureName, // private const int CultureNameIndex = 33;
                    enum2int(staff.changePassword), // private const int ChangePasswordIndex = 34;
                    staff.PasswordLastChangedDateTime, // private const int PasswordLastChangedDateTimeIndex = 35;
                    enum2int(staffPermission.allowUseSharedShift), // private const int AllowUseSharedShiftIndex = 36;
                    enum2int(staffPermission.allowManageSharedShift),  // private const int AllowManageSharedShiftIndex = 37;
                    enum2int(staffPermission.AllowSaleOutsideAssortment), // private const int AllowSaleOutsideAssortmentIndex = 38;
                    enum2int(staffPermission.AllowPrintingReceiptCopy), // private const int AllowPrintingReceiptCopyIndex = 39;
                    enum2int(staffPermission.AllowSkipFiscalRegistration), // private const int AllowSkipFiscalRegistrationIndex = 40;
                    enum2int(staffPermission.AllowAcceptOrder), // Not mapped - See TFS#3888756
                    enum2int(staffPermission.AllowRejectOrder), // Not mapped - See TFS#3888756
                    enum2int(staffPermission.AllowMassActivation), // private const int AllowMassActivationIndex = 43;
                    enum2int(staffPermission.AllowCreateTransferOrder), // private const int AllowCreateTransferOrderIndex = 44;
                    enum2int(staffPermission.AllowSkipRegistrationOrMarkAsRegistered), // private const int AllowSkipRegistrationOrMarkAsRegisteredIndex = 45;
                    enum2int(staffPermission.UseHandheld), // private const int UseHandheldIndex = 46;
                    enum2int(staffPermission.ViewTimeClockEntries), // private const int ViewTimeClockEntriesIndex = 47;
                    enum2int(staffPermission.AllowTaskGuides), // private const int AllowTaskGuidesIndex = 48;
                    enum2int(staffPermission.AllowTaskManagement), // private const int AllowTaskManagementIndex = 49;
                    enum2int(staffPermission.AllowPostponeRegistration), // private const int AllowPostponeRegistration = 50;
                    enum2int(staffPermission.AllowPostInventoryAdjustment), // private const int AllowPostInventoryAdjustment = 51;
                    enum2int(staffPermission.AllowPostStockCounting), // private const int AllowPostStockCounting = 52;
                    enum2int(staffPermission.AllowCloseShift), // private const int AllowPostCloseShift = 53;
                    enum2int(staffPermission.AllowCreatePurchaseOrder), // private const int AllowCreatePurchaseOrder = 54;
                    enum2int(staffPermission.AllowConfirmPurchaseOrder) // private const int AllowConfirmPurchaseOrder = 55;
                ];
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTimeclockHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a history of time registrations.
    /// </summary>
    /// <param name="_isManagerLogbook">
    /// True, if data for manager logbook are required, false - otherwise.
    /// </param>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_stores">
    /// Container with store IDs, where time registration has been made.
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_regTypes">
    /// Time registration type.
    /// </param>
    /// <param name="_jobId">
    /// Job Id of the specific break.
    /// </param>
    /// <returns>
    /// A container having history of worker's registrations.
    /// </returns>
    private static QueryRun getTimeclockHistory(boolean _isManagerLogbook = false,
                HcmPersonnelNumberId _personnelNumber = "",
                container _stores = conNull(),
                utcDateTime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), 0), // start of the current day (current time zone)
                utcDateTime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), 0), 24),  // end of the current day (current time zone)
                container _regTypes = conNull(),
                JmgJobId _jobId = '')
    {
        Query q;

        QueryBuildDataSource qbds;
        int i;

        if (_isManagerLogbook)
        {
            q = new Query(queryStr(RetailTimeclockManage));
        }
        else
        {
            q = new Query(queryStr(RetailTimeclockLogbook));
        }

        // set time range filter
        qbds = q.dataSourceTable(tableNum(JmgTermReg));
        // date range values are in the current time zone, while values in DB are in UTC
        // so we need to remove time zone offset in range values
        qbds
            .addRange(fieldNum(JmgTermReg, RegDateTime))
            .value(queryRange(DateTimeUtil::removeTimeZoneOffset(_fromDate, DateTimeUtil::getUserPreferredTimeZone()),
                              DateTimeUtil::removeTimeZoneOffset(_toDate, DateTimeUtil::getUserPreferredTimeZone())));

        // set registration type filter
        for (i = 1; i <= conLen(_regTypes); i++)
        {
            qbds.addRange(fieldNum(JmgTermReg, RegType)).value(queryValue(conPeek(_regTypes, i)));

            // set break type filter
            if (!prmisDefault(_jobId) && (conPeek(_regTypes, i) == JmgTermRegType::BrkFlowStart))
            {
                qbds.addRange(fieldNum(JmgTermReg, JobId)).value(queryValue(_jobId));
            }
        }

        // set worker filter, if required
        qbds = q.dataSourceTable(tableNum(HcmWorker));
        if (!prmisDefault(_personnelNumber))
        {
            qbds.addRange(fieldNum(HcmWorker, PersonnelNumber)).value(_personnelNumber);
        }

        // set store filter, if required
        qbds = q.dataSourceTable(tableNum(RetailStoreTable));
        for (i = 1; i <= conLen(_stores); i++)
        {
            if (conPeek(_stores, i) != '')
            {
                qbds.addRange(fieldNum(RetailStoreTable, StoreNumber)).value(queryValue(conPeek(_stores, i)));
            }
        }

        return new QueryRun(q);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTimeclockHistoryUtc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a history of time registrations in UTC time zone.
    /// </summary>
    /// <param name="_isManagerLogbook">
    /// True, if data for manager logbook are required, false - otherwise.
    /// </param>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_stores">
    /// Container with store IDs, where time registration has been made.
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_regTypes">
    /// Time registration type.
    /// </param>
    /// <param name="_jobIds">
    /// Job Ids of the break activities.
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of employee activities to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of employee activities to skip.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <returns>
    /// A container having history of worker's registrations.
    /// </returns>
    private static QueryRun getTimeclockHistoryUtc(boolean _isManagerLogbook = false,
                HcmPersonnelNumberId _personnelNumber = "",
                container _stores = conNull(),
                utcdatetime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), // start of the current date and time (UTC time zone)
                utcdatetime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), 24), // end of the current date and time (UTC time zone)
                container _regTypes = conNull(),
                container _jobIds = conNull(),
                int64 _top = 100,
                int64 _skip = 0,
                str _orderByField = fieldStr(JmgTermReg, RegDateTime),
                SortOrder _sortOrder = SortOrder::Descending)
    {
        Query q;
        QueryRun qr;
        QueryBuildDataSource qbds, qbdsJmgTermReg;
        int i, j;
        RetailStoreId storeNumber;
        JmgJobId jobId;
        boolean breakActivityFound = false;

        if (_isManagerLogbook)
        {
            q = new Query(queryStr(RetailTimeclockManage));
        }
        else
        {
            q = new Query(queryStr(RetailTimeclockLogbook));
        }

        // set time range filter
        qbdsJmgTermReg = q.dataSourceTable(tableNum(JmgTermReg));
        qbdsJmgTermReg.addRange(fieldNum(JmgTermReg, RegDateTime))
                      .value(queryRange(_fromDate, _toDate));

        // set registration type filter
        for (i = 1; i <= conLen(_regTypes); i++)
        {
            qbdsJmgTermReg.addRange(fieldNum(JmgTermReg, RegType)).value(queryValue(conPeek(_regTypes, i)));

            // set break type filter
            if (!breakActivityFound && (conPeek(_regTypes, i) == JmgTermRegType::BrkFlowStart))
            {
                for (j = 1; j <= conLen(_jobIds); j++)
                {
                    jobId = conPeek(_jobIds, j);
                    qbdsJmgTermReg.addRange(fieldNum(JmgTermReg, JobId)).value(queryValue(jobId));
                    breakActivityFound = true;
                }
            }
        }

        // set worker filter, if required
        qbds = q.dataSourceTable(tableNum(HcmWorker));
        if (_personnelNumber != '')
        {
            qbds.addRange(fieldNum(HcmWorker, PersonnelNumber)).value(_personnelNumber);
        }

        // set store filter, if required
        qbds = q.dataSourceTable(tableNum(RetailStoreTable));
        for (i = 1; i <= conLen(_stores); i++)
        {
            storeNumber = conPeek(_stores, i);
            if (storeNumber != '')
            {
                qbds.addRange(fieldNum(RetailStoreTable, StoreNumber)).value(queryValue(storeNumber));
            }
        }

        // set the order by field to be StoreNumber, RegDateTime or RegType (Description), if required
        if (_orderByField == fieldStr(RetailStoreTable, StoreNumber))
        {
            qbdsJmgTermReg.sortClear();
            qbds.addOrderByField(fieldNum(RetailStoreTable, StoreNumber), _sortOrder);
            qbdsJmgTermReg.addOrderByField(fieldNum(JmgTermReg, RegDateTime), SortOrder::Descending);
        }
        else if (_orderByField == fieldStr(JmgTermReg, RegDateTime))
        {
            qbdsJmgTermReg.sortClear();
            qbdsJmgTermReg.addOrderByField(fieldNum(JmgTermReg, RegDateTime), _sortOrder);
            qbdsJmgTermReg.addOrderByField(fieldNum(JmgTermReg, RegType), SortOrder::Ascending);
        }
        else if (_orderByField == fieldStr(JmgTermReg, RegType))
        {
            qbdsJmgTermReg.sortClear();
            if (_isManagerLogbook)
            {
                qbdsJmgTermReg.addOrderByField(fieldNum(JmgTermReg, RegType), _sortOrder);
            }
            else
            {
                qbds = q.dataSourceTable(tableNum(JmgIpcActivity));
                qbds.addOrderByField(fieldNum(JmgIpcActivity, Description), _sortOrder);
            }
            qbdsJmgTermReg.addOrderByField(fieldNum(JmgTermReg, RegDateTime), SortOrder::Descending);
        }

        qr = new QueryRun(q);

        // set the pagination info, if _top is greater than 0
        if (_top > 0)
        {
            qr.enablePositionPaging(true);
            qr.addPageRange(_skip + 1, _top);
        }

        return qr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkerCurrentTimeRegistrationState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an information about the current worker's time registration status.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id associated with the time registration.
    /// </param>
    /// <returns>
    /// A container having information about the type of latest worker's time registration.
    /// </returns>
    /// <remarks>
    /// If time registration fails, returned container will also have an error message.
    /// </remarks>
    public static container getWorkerCurrentTimeRegistrationState(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId = '')
    {
        JmgTermReg latestTimeEntry = RetailTransactionServiceEmployee::getLatestTimeRegistrationByWorker(_personnelNumber, _terminalId);

        if (latestTimeEntry.RecId > 0)
        {
            return [true, '',
                    DateTimeUtil::toStr(latestTimeEntry.RegDateTime),
                    enum2int(latestTimeEntry.RegType),
                    latestTimeEntry.RegType == JmgTermRegType::BrkFlowStart ? latestTimeEntry.JobId : '',
                    latestTimeEntry.RecId];
        }
        else
        {
            return [false, "@RET4160565"];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkerHistoryUtc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a history of time registrations for the worker specified in UTC time zone.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_storeId">
    /// Number of the store, where time registration has been made.
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of employee activities to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of employee activities to skip.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <returns>
    /// A container having history of worker's registrations.
    /// </returns>
    public static container getWorkerHistoryUtc(HcmPersonnelNumberId _personnelNumber,
                RetailStoreId _storeId,
                utcdatetime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), // start of the current date and time (UTC time zone)
                utcdatetime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), 24), // end of the current date and time (UTC time zone)
                int64 _top = 100,
                int64 _skip = 0,
                str _orderByField = fieldStr(JmgTermReg, RegDateTime),
                SortOrder _sortOrder = SortOrder::Descending)
    {
        container           workerLogBook = [true, ''];
        container           regType = conNull();
        container           jobId = conNull();
        JmgTermReg          timeEntry;
        JmgIpcActivity      ipcActivity;
        RetailStoreTable    store;
        QueryRun            qr;

        qr = RetailTransactionServiceEmployee::getTimeclockHistoryUtc(
                false,
                _personnelNumber,
                [_storeId],
                _fromDate,
                _toDate,
                regType,
                jobId,
                _top,
                _skip,
                _orderByField,
                _sortOrder);

        while (qr.next())
        {
            timeEntry = qr.get(tableNum(JmgTermReg));
            ipcActivity = qr.get(tableNum(JmgIpcActivity));
            store = qr.get(tableNum(RetailStoreTable));
            workerLogBook = conIns(workerLogBook, conLen(workerLogBook) + 1,
                                [enum2int(timeEntry.RegType),
                                    ipcActivity.Category,
                                    ipcActivity.Description,
                                    DateTimeUtil::toStr(timeEntry.RegDateTime),
                                    store.storeNumber,
                                    timeEntry.RecId]);
        }

        return workerLogBook;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intCsvToCon</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Convert an integer based CSV string into a container
    /// </summary>
    /// <param name="_csv">
    /// Comma seperated string of integer values
    /// </param>
    /// <remarks>
    /// Work around bug in str2con() that returns a container of 1 when the string is empty instead of conNull
    /// </remarks>
    /// <returns>
    /// A container of integers
    /// </returns>
    private static container intCsvToCon(str _csv)
    {
        container result;

        result = str2con(_csv, ',', true);

        // Due to bug in AX, add code here to see if container is length 1 where the first element is not int64
        // if this is the case return conNull()
        if (conLen(result) == 1)
        {
            if (typeOf(conPeek(result, 1)) == Types::String)
            {
                result = conNull();
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffChangePassword</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the RetailStaffLoginLog.staffId with the value in <c>_staffId</c> if the record exists in <c>RetailStaffLoginLog</c>;
    /// else creates the record in <c>RetailStaffLoginLog</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_oldPassword">
    /// ID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_newPassword">
    /// ID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="changePassword">
    /// A flag indicating if the user has to change the password at next POS login.
    /// </param>
    /// <param name="_loginToStore">
    /// Boolean set to true to login to a particular store, set to false to login with only staffId and Password
    /// </param>
    /// <param name="_channelId">
    /// The channel or store requesting the data package.
    /// </param>
    /// <param name="_useLegacyPasswordHash">
    /// A value indicating whether to use the legacy password hash.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container staffChangePassword(RetailStaffId _staffId, RetailStaffPassword _oldPassword, RetailStaffPassword _newPassword, boolean changePassword, boolean _loginToStore = true, RecId _channelId = 0, boolean _useLegacyPasswordHash = false)
    {
        #define.StaffNotFound(1);
        #define.IncorrectPassword(2);
        #define.PasswordHistoryValidationFailed(4);

        container staffStatus = [true,""];
        RetailStaffTable				rboStaffTable;
        HcmWorker						hcmWorker;
        HcmPositionWorkerAssignment		hcmPositionWorkerAssignment;
        boolean							isInAddressBook = false;
        RetailStaffPermission			staffPermission;
        DirPartyTable					party;
        RetailStaffData					passwordData;
        str								passwordSalt;
        str								legacyLocalContext;
        str								legacyRegistryData2;
        str								passwordHashAlgorithm;
        utcdatetime						passwordLastChangedDateTime;
        RetailAuthenticationOperation	passwordLastUpdateOperation;
        container						updatePasswordResult;
        int								errorCode;
        str                             staffPasswordPackage = '';
        str                             passwordHash;
        boolean                         isPasswordValid = false;
        boolean                         isPasswordChanged = false;

        try
        {
            rboStaffTable = RetailStaffTable::find(_staffId);

            hcmWorker = HcmWorker::findByPersonnelNumber(rboStaffTable.StaffId);
            select Worker from hcmPositionWorkerAssignment
                where hcmPositionWorkerAssignment.Worker == hcmWorker.RecId;

            //change password
            if (rboStaffTable)
            {
                passwordHashAlgorithm = rboStaffTable.PasswordHashAlgorithm;

                if (passwordHashAlgorithm == '')
                {
                    passwordHashAlgorithm = RetailSharedParameters::find(false).StaffPasswordHash;
                }

                if (!_useLegacyPasswordHash)
                {
                    // If this call is from the new clients (version greater than 7.0), old password is sent in clear text and the password hash should be recalculated.
                    // Verify if the password has changed by comparing the random salt hash.
                    passwordHash = RetailData::HashUnified(_oldPassword, passwordHashAlgorithm, _staffId, rboStaffTable.passwordSalt, rboStaffTable.LegacyLocalContext, rboStaffTable.LegacyRegKeyData2Value);
                    isPasswordValid = RetailTransactionService::staffIsPasswordValid(passwordHash, rboStaffTable.passwordData);
                    isPasswordChanged = (passwordHash != RetailData::HashUnified(_newPassword, passwordHashAlgorithm, _staffId, rboStaffTable.passwordSalt, rboStaffTable.LegacyLocalContext, rboStaffTable.LegacyRegKeyData2Value)) ? true : false;
                }
                else
                {
                    // If this call is from the old clients (AX 2012), old password hash is sent which should be compared to legacy password hash.
                    // Always set the change password to true.
                    isPasswordValid = RetailTransactionService::staffIsPasswordValid(_oldPassword, rboStaffTable.LegacyPasswordData);
                    isPasswordChanged = true;
                }

                if (isPasswordValid)
                {
                    // The password is changed only if the new password is different from the old password.
                    if (isPasswordChanged)
                    {
                        if (conPeek(staffStatus,1) == true )
                        {
                            updatePasswordResult = RetailTransactionService::updateStaffPassword(_staffId, _newPassword, changePassword ? 1 : 0, RetailAuthenticationOperation::ChangePassword, 0, _useLegacyPasswordHash);

                            // if password was updated successfully
                            if (conPeek(updatePasswordResult, 1) == true)
                            {
                                passwordData = conPeek(updatePasswordResult, 3);
                                passwordSalt = conPeek(updatePasswordResult, 4);
                                passwordHashAlgorithm = conPeek(updatePasswordResult, 5);
                                passwordLastChangedDateTime = conPeek(updatePasswordResult, 6);
                                passwordLastUpdateOperation = conPeek(updatePasswordResult, 7);
                                legacyLocalContext = conPeek(updatePasswordResult, 9);
                                legacyRegistryData2 = conPeek(updatePasswordResult, 10);
                                staffPermission = RetailTransactionServiceEmployee::staffPermission(_staffId);
                                
                                // Add serialized updated staff password data package to the response if _channelId is present.
                                if (_channelId != 0)
                                {
                                    staffPasswordPackage = RetailTransactionServiceEmployee::getStaffPasswordDataPackage(_staffId, _channelId);
                                }
                                
                                if (!_useLegacyPasswordHash)
                                {
                                    staffStatus =
                                        staffStatus +
                                        [passwordData, passwordSalt, passwordHashAlgorithm, passwordLastChangedDateTime, enum2int(passwordLastUpdateOperation), staffPasswordPackage, legacyLocalContext, legacyRegistryData2];
                                }
                            }
                            else
                            {
                                errorCode = conPeek(updatePasswordResult, 3);

                                // return failure
                                staffStatus = [false, conPeek(updatePasswordResult, 2), errorCode];
                                ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), strFmt('An error has occurred when updating the staff password. The error code was: %1.', errorCode));
                            }
                        }
                    }
                    else
                    {
                        staffStatus = [false, "@SYS4006632" + ":\n" + "@Retail:PasswordHistoryRequirementsNotMetError", #PasswordHistoryValidationFailed];
                        ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), 'The password does not meet the history requirements');
                    }
                }
                else
                {
                    staffStatus = [false,"@RET4230026", #IncorrectPassword];
                    ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), strFmt('The old password for staff member : %1 is not correct.', _staffId));
                }
            }
            else
            {
                staffStatus = [false,"@RET2386", #StaffNotFound];
                ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), strFmt('The staff member : %1 does not exist.', _staffId));
            }
        }
        catch
        {
            ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), 'An error occcured.');
            throw error("@RET2382");
        }

        return staffStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStaffPasswordDataPackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the specified staff's updated password data package.
    /// </summary>
    /// <param name="staffId">
    /// The desired staff's recId.
    /// </param>
    /// <param name="channelId">
    /// The channel or store requesting the staff updated password package.
    /// </param>
    /// <returns>
    /// A serialized CDX package representing the updated password information for staff.
    /// </returns>
    public static str getStaffPasswordDataPackage(RetailStaffId staffId, RecId channelId)
    {
        RetailCdxDataPackageSerializationHelper serializer;
        RecId                       channelSchemaRecId;
        RetailStaffTable            staffTable;
        str                         serializedPackage;

        boolean                     success = true;
        str                         error   = '';

        Counter     infologline = infolog.num();
        int         fromLine = Global::infologLine();

        staffTable = RetailStaffTable::find(staffId);

        try
        {
            channelSchemaRecId = RetailTransactionServiceUtilities::getChannelSchemaRecId(channelId);
            serializer = new RetailCdxDataPackageSerializationHelper(channelSchemaRecId);

            if (staffTable)
            {
                serializer.writeRecord(staffTable);
            }

            serializedPackage = serializer.getBase64EncodedDataPackage();
        }
        catch (Exception::CLRError)
        {
            success = false;
            error = "@Retail:DataPackageGenerationError";

            System.Exception ex = CLRInterop::getLastException();
            error += ex.ToString();
        }
        catch
        {
            success = false;
            error = "@Retail:DataPackageGenerationError";
            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }
        finally
        {
            if (serializer)
            {
                serializer.cleanUp();
                serializer = null;
            }
        }

        return serializedPackage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffIsPasswordValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns true if the <c>_password</c> is equal to <c>_realPassword</c>; else false.
    /// </summary>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <param name="_realPassword">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <returns>
    /// true if the <c>_password</c> is equal to <c>_realPassword</c>; else false.
    /// </returns>
    public static boolean staffIsPasswordValid(RetailStaffPassword _password, RetailStaffPassword _realPassword)
    {
        return (_password == _realPassword);
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffIsPasswordValidForStaff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for validating if password is correct for a particular staff Id.
    /// </summary>
    /// <param name="_staffId">
    /// <c>RetailStaffId</c>
    /// </param>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container staffIsPasswordValidForStaff(RetailStaffId _staffId, RetailStaffPassword _password)
    {
        container staffStatus = [true,""];
        RetailStaffTable            rboStaffTable;

        try
        {
            rboStaffTable = RetailStaffTable::find(_staffId);

            if (rboStaffTable)
            {
                if (rboStaffTable.Blocked == false)
                {
                    if (!RetailTransactionService::staffIsPasswordValid(_password, rboStaffTable.PasswordData))
                    {
                        staffStatus = [false,"@RET2384"];
                        ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeWarning(funcName(), strFmt('The password for staff member : %1 is not correct.', rboStaffTable.StaffId));
                    }
                }
                else
                {
                    staffStatus = [false,"@RET2385"];
                    ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeWarning(funcName(), strFmt('The staff member : %1 is blocked.', rboStaffTable.StaffId));
                }
            }
            else
            {
                staffStatus = [false,"@RET2386"];
                ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeWarning(funcName(), strFmt('The staff member : %1 does not exist.', rboStaffTable.StaffId));
            }
        }
        catch
        {
            ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), 'An error occcured.');
            throw error("@RET2382");
        }

        return staffStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffLogOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method deletes the record from <c>RetailStaffLoginLog</c> table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_logoffFromStore">
    /// ID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to delete.
    /// </exception>
    public static container staffLogOff(RetailStaffId _staffId, RetailStoreId _storeId, RetailTerminalId _terminalId, boolean _logoffFromStore = true)
    {
        container result = [true,""];
        RetailStaffLoginLog rboStaffLoginLog;

        if ( !_logoffFromStore )
            return result;
        try
        {
            delete_from rboStaffLoginLog
            where rboStaffLoginLog.StaffId == _staffId
               && rboStaffLoginLog.StoreId == _storeId
               && rboStaffLoginLog.TerminalId == _terminalId;
        }
        catch
        {
            ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), 'An errror has occurred.');
            throw error("@RET2382");
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the RetailStaffLoginLog.staffId with the value in <c>_staffId</c> if the record exists in <c>RetailStaffLoginLog</c>;
    /// else creates the record in <c>RetailStaffLoginLog</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <param name="_loginToStore">
    /// Boolean set to true to login to a particular store, set to false to login with only staffId and Password
    /// </param>
    /// <param name="_skipPasswordValidation">
    /// A value indicating whether password validation must not be performed.
    /// </param>
    /// <param name="_useLegacyPasswordHash">
    /// A value indicating whether to use the legacy password hash.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container staffLogOn(RetailStaffId _staffId, RetailStoreId _storeId, RetailTerminalId _terminalId, RetailStaffPassword _password, boolean _loginToStore = true, boolean _skipPasswordValidation = false, boolean _useLegacyPasswordHash = false)
    {
        #define.UserBlockedErrorCode(1);
        #define.UserPasswordNotConfiguredErrorCode(2);
        #define.UserIdOrPasswordInvalid(3);
        #define.UserCannotUseMultipleTerminalsAtSameTime(4);
        #define.EmptyString('');

        container staffStatus = [true,""];
        RetailStaffTable            rboStaffTable;
        RetailStaffLoginLog         rboStaffLoginLog;
        HcmWorker                   hcmWorker;
        RetailStoreAddressBook      storeAddressBook;
        boolean                     isInAddressBook = false;
        RetailStoreTable            storeTable;
        DirAddressBookParty         addressBookParty;
        RetailStaffPermission staffPermission;
        DirPartyTable party;

        try
        {
            rboStaffTable = RetailStaffTable::find(_staffId);

            if (rboStaffTable)
            {
                hcmWorker = HcmWorker::findByPersonnelNumber(rboStaffTable.StaffId);

                if ( !_loginToStore )
                {
                    ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeInfoLog(funcName(), strFmt('Performing non-store log on for staff member : %1. HCM Worker party : %2 (HcmWorker.RecId : %3)', rboStaffTable.StaffId, hcmWorker.Person, hcmWorker.RecId));
                    select firstonly AddressBook from storeAddressBook
                        where storeAddressBook.AddressBookType == RetailAddressBookType::Employee
                        exists join addressBookParty
                        where addressBookParty.AddressBook == storeAddressBook.AddressBook
                            && addressBookParty.Party == hcmWorker.Person;

                    if (storeAddressBook)
                    {
                        isInAddressBook = true;
                    }
                }
                else
                {
                    select RecId from storeTable where storeTable.StoreNumber == _storeId;
                    ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeInfoLog(funcName(), strFmt('Performing store specific log on for staff member : %1.  HCM Worker party : %2 (HcmWorker.RecId : %3). Store number: %4 (Store.RecId : %5).', rboStaffTable.StaffId, hcmWorker.Person, hcmWorker.RecId, _storeId, storeTable.RecId));

                    select firstonly AddressBook from storeAddressBook
                        where storeAddressBook.StoreRecId == storeTable.RecId
                            && storeAddressBook.AddressBookType == RetailAddressBookType::Employee
                        exists join addressBookParty
                        where addressBookParty.AddressBook == storeAddressBook.AddressBook 
                            && addressBookParty.Party == hcmWorker.Person;

                    if (storeAddressBook)
                    {
                        isInAddressBook = true;
                    }
                }

                RetailStaffData passwordHash;
                boolean isPasswordValid = false;

                if (!_skipPasswordValidation)
                {
                    if (!_useLegacyPasswordHash)
                    {
                        // If this call is from the new clients (version greater than 7.0), staff password is sent in clear text and a hash should be calculated.
                        if (rboStaffTable.passwordSalt == null || rboStaffTable.passwordSalt == #EmptyString)
                        {
                            staffStatus = [false,"@Retail:RetailStaffNotConfiguredCorrectly", #UserPasswordNotConfiguredErrorCode];
                            ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeWarning(funcName(), strFmt('The staff member : %1 is not configured correctly, the password is missing.', rboStaffLoginLog.StaffId));
                            return staffStatus;
                        }

                        str passwordHashAlgorithm = rboStaffTable.PasswordHashAlgorithm;

                        if (passwordHashAlgorithm == '')
                        {
                            passwordHashAlgorithm = RetailSharedParameters::find(false).StaffPasswordHash;
                        }

                        passwordHash = RetailData::HashUnified(_password, passwordHashAlgorithm, _staffId, rboStaffTable.passwordSalt, rboStaffTable.LegacyLocalContext, rboStaffTable.LegacyRegKeyData2Value);
                        isPasswordValid = RetailTransactionService::staffIsPasswordValid(passwordHash, rboStaffTable.PasswordData);
                    }
                    else
                    {
                        // If this call is from the old clients (AX 2012), staff password hash is sent and should be compared as is with the legacy hash.
                        isPasswordValid = RetailTransactionService::staffIsPasswordValid(_password, rboStaffTable.LegacyPasswordData);
                    }
                }

                //Only after password check is complete specific error should be thrown to the client.
                if (_skipPasswordValidation || isPasswordValid)
                {
                    if (isInAddressBook)
                    {
                        if (rboStaffTable.Blocked == false)
                        {
                            // Get the staff permission to check user has AllowMultipleLogin permission.
                            staffPermission = RetailTransactionServiceEmployee::staffPermission(_staffId);
                            select Name from party
                                exists join hcmWorker where hcmWorker.PersonnelNumber == _staffId && hcmWorker.Person == party.RecId;

                            if (!staffPermission.allowMultipleLogins && _loginToStore)
                            {
                                rboStaffLoginLog = RetailStaffLoginLog::findStaff(rboStaffTable.StaffId);

                                if (rboStaffLoginLog && (rboStaffLoginLog.StoreId != _storeId ||rboStaffLoginLog.TerminalId != _terminalId))
                                {
                                    staffStatus = [false, strFmt("@RET2383",rboStaffLoginLog.StaffId,rboStaffLoginLog.TerminalId,rboStaffLoginLog.StoreId), #UserCannotUseMultipleTerminalsAtSameTime, rboStaffLoginLog.TerminalId];
                                    ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeWarning(funcName(), strFmt('Staff member : %1 is already logged on to register : %2 at store : %3.', rboStaffLoginLog.StaffId, rboStaffLoginLog.TerminalId, rboStaffLoginLog.StoreId));
                                }
                            }
                        }
                        else
                        {
                            staffStatus = [false,"@RET2385", #UserBlockedErrorCode];
                            ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeWarning(funcName(), strFmt('The staff member : %1 is blocked.', rboStaffTable.StaffId));
                        }
                    }
                    else
                    {
                        staffStatus = [false, "@SYP4910140"];
                        ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeWarning(funcName(), strFmt('The staff member : %1 not assigned to work in the store.', rboStaffTable.StaffId));
                    }
                }
                else
                {
                    staffStatus = [false,"@SYP4910133", #UserIdOrPasswordInvalid];
                    ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeWarning(funcName(), strFmt('The password for staff member : %1 is not correct.', rboStaffTable.StaffId));
                }
            }
            else
            {
                staffStatus = [false,"@SYP4910133", #UserIdOrPasswordInvalid];
                ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeWarning(funcName(), strFmt('The staff member : %1 does not exist.', rboStaffTable.StaffId));
            }

            if (conPeek(staffStatus,1) == true )
            {
                staffStatus = staffStatus + RetailTransactionServiceEmployee::getStaffPermission(rboStaffTable, party, staffPermission);
                if ( _loginToStore)
                {
                    ttsbegin;

                    rboStaffLoginLog.concurrencyModel(ConcurrencyModel::Pessimistic);
                    select firstonly rboStaffLoginLog
                        where rboStaffLoginLog.StoreId == _storeId
                        && rboStaffLoginLog.TerminalId == _terminalId
                        && rboStaffLoginLog.staffId == _staffId;

                    if (!rboStaffLoginLog)
                    {
                        rboStaffLoginLog.clear();
                        rboStaffLoginLog.StaffId = _staffId;
                        rboStaffLoginLog.StoreId = _storeId;
                        rboStaffLoginLog.TerminalId = _terminalId;
                        rboStaffLoginLog.insert();
                    }
                    ttscommit;
                }
                ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeInfoLog(funcName(), strFmt('The staff member : %1 logged in sucessfully.', rboStaffLoginLog.StaffId));
            }
        }
        catch
        {
            ApplicationEventSource::EventWriteRetailTransactionServiceEmployeeFailure(funcName(), 'An error occcured.');
            throw error("@RET2382");
        }

        return staffStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffPermission</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves staff permissions.
    /// </summary>
    /// <param name="_staffId">
    /// The staff identifier for which to retrieve data.
    /// </param>
    /// <returns>
    /// A <c>RetailStaffPermission</c> with staff permissions.
    /// </returns>
    public static RetailStaffPermission staffPermission(RetailStaffId _staffId)
    {
        RetailPosPermissionGroup posPermissionGroup, posPermission;
        HcmPosition position;
        HcmPositionDetail positionDetail;
        RetailJobPosPermissionGroup jobPermissionGroup;
        HcmJob job;
        HcmWorker worker;
        HcmPositionWorkerAssignment assignment;
        RetailPositionPosPermission positionPosPermission;
        RetailStaffPermission staffPermission;
        RetailStaffTable foundStaff;
        boolean override = false;
        boolean foundNonOverriddenPermissions = false;
        guid correlationId = newGuid();
        int staffIdLength = strLen(_staffId);

        boolean isRetailHideStoreInventoryUserFlight = RetailHideStoreInventoryUserFlight::instance().isEnabled();

        AppLogging::EventWriteRetailTransactionServiceBeginGetStaffPermissions(_staffId, staffIdLength, correlationId);

        foundStaff = RetailStaffTable::find(_staffId);
        if (foundStaff)
        {
            AppLogging::EventWriteRetailTransactionServiceGetStaffPermissionsFoundEmployee(foundStaff.RecId, _staffId, staffIdLength, correlationId);
        }
        else
        {
            AppLogging::EventWriteRetailTransactionServiceGetStaffPermissionsDidNotFindEmployee(_staffId, staffIdLength, correlationId);
        }

        // Enumerate override for each position of the worker
        while select positionPosPermission
            exists join worker where worker.PersonnelNumber == _staffId
            exists join assignment where assignment.Worker == worker.RecId
            exists join position where ( position.RecId == assignment.Position && positionPosPermission.Position == position.RecId )
        {
            posPermissionGroup.AllowBlindClose = posPermissionGroup.AllowBlindClose | positionPosPermission.AllowBlindClose;
            posPermissionGroup.allowChangeNoVoid = posPermissionGroup.allowChangeNoVoid | positionPosPermission.allowChangeNoVoid;
            posPermissionGroup.allowChangePeripheralStation = posPermissionGroup.allowChangePeripheralStation | positionPosPermission.allowChangePeripheralStation;
            posPermissionGroup.allowCreateOrder = posPermissionGroup.allowCreateOrder | positionPosPermission.allowCreateOrder;
            posPermissionGroup.allowEditOrder = posPermissionGroup.allowEditOrder | positionPosPermission.allowEditOrder;
            posPermissionGroup.allowFloatingTenderDeclaration = posPermissionGroup.allowFloatingTenderDeclaration | positionPosPermission.allowFloatingTenderDeclaration;
            posPermissionGroup.allowKitDisassembly = posPermissionGroup.allowKitDisassembly | positionPosPermission.allowKitDisassembly;
            posPermissionGroup.allowMultipleLogins = posPermissionGroup.allowMultipleLogins | positionPosPermission.allowMultipleLogins;
            posPermissionGroup.allowMultipleShiftLogon = posPermissionGroup.allowMultipleShiftLogon | positionPosPermission.allowMultipleShiftLogon;
            posPermissionGroup.allowOpenDrawerOnly = posPermissionGroup.allowOpenDrawerOnly | positionPosPermission.allowOpenDrawerOnly;
            posPermissionGroup.allowPriceOverride = posPermissionGroup.allowPriceOverride | positionPosPermission.allowPriceOverride;
            posPermissionGroup.allowRetrieveOrder = posPermissionGroup.allowRetrieveOrder | positionPosPermission.allowRetrieveOrder;
            posPermissionGroup.allowSalesTaxChange = posPermissionGroup.allowSalesTaxChange | positionPosPermission.allowSalesTaxChange;
            posPermissionGroup.allowTenderDeclaration = posPermissionGroup.allowTenderDeclaration | positionPosPermission.allowTenderDeclaration;
            posPermissionGroup.allowTransactionSuspension = posPermissionGroup.allowTransactionSuspension | positionPosPermission.allowTransactionSuspension;
            posPermissionGroup.allowTransactionVoiding = posPermissionGroup.allowTransactionVoiding | positionPosPermission.allowTransactionVoiding;
            posPermissionGroup.allowXReportPrinting = posPermissionGroup.allowXReportPrinting | positionPosPermission.allowXReportPrinting;
            posPermissionGroup.AllowZReportPrinting = posPermissionGroup.AllowZReportPrinting | positionPosPermission.AllowZReportPrinting;
            posPermissionGroup.managerPrivileges = posPermissionGroup.managerPrivileges | positionPosPermission.managerPrivileges;
            posPermissionGroup.AllowPasswordChange = posPermissionGroup.AllowPasswordChange | positionPosPermission.AllowPasswordChange;
            posPermissionGroup.AllowResetPassword = posPermissionGroup.AllowResetPassword | positionPosPermission.AllowResetPassword;
            posPermissionGroup.manageDevice = posPermissionGroup.manageDevice | positionPosPermission.manageDevice;
            posPermissionGroup.maximumDiscountPct = max( posPermissionGroup.maximumDiscountPct, positionPosPermission.maximumDiscountPct );
            posPermissionGroup.maxLineDiscountAmount = max ( posPermissionGroup.maxLineDiscountAmount, positionPosPermission.maxLineDiscountAmount );
            posPermissionGroup.maxLineReturnAmount = max ( posPermissionGroup.maxLineReturnAmount, positionPosPermission.maxLineReturnAmount );
            posPermissionGroup.maxTotalDiscountAmount = max ( posPermissionGroup.maxTotalDiscountAmount, posPermissionGroup.maxTotalDiscountAmount );
            posPermissionGroup.maxTotalDiscountPct = max ( posPermissionGroup.maxTotalDiscountPct, positionPosPermission.maxTotalDiscountPct );
            posPermissionGroup.maxTotalReturnAmount = max ( posPermissionGroup.maxTotalReturnAmount, positionPosPermission.maxTotalReturnAmount );
            posPermissionGroup.allowManageSharedShift = posPermissionGroup.allowManageSharedShift | positionPosPermission.allowManageSharedShift;
            posPermissionGroup.allowUseSharedShift = posPermissionGroup.allowUseSharedShift | positionPosPermission.allowUseSharedShift;
            posPermissionGroup.AllowSaleOutsideAssortment = posPermissionGroup.AllowSaleOutsideAssortment | positionPosPermission.AllowSaleOutsideAssortment;
            posPermissionGroup.AllowPrintingReceiptCopy = min ( posPermissionGroup.AllowPrintingReceiptCopy, positionPosPermission.AllowPrintingReceiptCopy );
            posPermissionGroup.AllowSkipFiscalRegistration = posPermissionGroup.AllowSkipFiscalRegistration | positionPosPermission.AllowSkipFiscalRegistration;
            posPermissionGroup.AllowAcceptOrder = posPermissionGroup.AllowAcceptOrder | positionPosPermission.AllowAcceptOrder;
            posPermissionGroup.AllowRejectOrder = posPermissionGroup.AllowRejectOrder | positionPosPermission.AllowRejectOrder;
            posPermissionGroup.AllowMassActivation = posPermissionGroup.AllowMassActivation | positionPosPermission.AllowMassActivation;
            posPermissionGroup.AllowCreateTransferOrder = posPermissionGroup.AllowCreateTransferOrder | positionPosPermission.AllowCreateTransferOrder;

            if (!isRetailHideStoreInventoryUserFlight)
            {
                posPermissionGroup.UseHandheld = posPermissionGroup.UseHandheld | positionPosPermission.UseHandheld;
            }
            posPermissionGroup.viewTimeclockEntries = posPermissionGroup.viewTimeclockEntries | positionPosPermission.viewTimeclockEntries;
            posPermissionGroup.AllowTaskGuides = posPermissionGroup.AllowTaskGuides | positionPosPermission.AllowTaskGuides;
            posPermissionGroup.AllowSkipRegistrationOrMarkAsRegistered = posPermissionGroup.AllowSkipRegistrationOrMarkAsRegistered | positionPosPermission.AllowSkipRegistrationOrMarkAsRegistered;
            posPermissionGroup.AllowTaskManagement = posPermissionGroup.AllowTaskManagement | positionPosPermission.AllowTaskManagement;
            posPermissionGroup.AllowPostponeRegistration = posPermission.AllowPostponeRegistration | positionPosPermission.AllowPostponeRegistration;
            posPermissionGroup.AllowPostInventoryAdjustment = posPermission.AllowPostInventoryAdjustment | positionPosPermission.AllowPostInventoryAdjustment;
            posPermissionGroup.AllowPostStockCounting = posPermission.AllowPostStockCounting | positionPosPermission.AllowPostStockCounting;
            posPermissionGroup.AllowCloseShift = posPermission.AllowCloseShift | positionPosPermission.AllowCloseShift;
            posPermissionGroup.AllowCreatePurchaseOrder = posPermission.AllowCreatePurchaseOrder | positionPosPermission.AllowCreatePurchaseOrder;
            posPermissionGroup.AllowConfirmPurchaseOrder = posPermission.AllowConfirmPurchaseOrder | positionPosPermission.AllowConfirmPurchaseOrder;
            override = true;
        }

        // If override is found, return overridden permission
        if ( override == true )
        {
            AppLogging::EventWriteRetailTransactionServiceGetStaffPermissionsFoundOverriddenPermissions(foundStaff.RecId, _staffId, staffIdLength, posPermissionGroup.RecId, posPermissionGroup.managerPrivileges, posPermissionGroup.manageDevice, correlationId);
            staffPermission = posPermissionGroup;
            return staffPermission;
        }
        else
        {
            AppLogging::EventWriteRetailTransactionServiceGetStaffPermissionsDidNotFindOverriddenPermissions(foundStaff.RecId, _staffId, staffIdLength, correlationId);
        }

        // Get the Staff permission from the RetailPosPermissionGroup.
        while select * from posPermission
            exists join worker where worker.PersonnelNumber == _staffId
            exists join assignment where assignment.Worker == worker.RecId
            exists join position where position.RecId == assignment.Position
            exists join position from positionDetail where positiondetail.Position == assignment.Position
            exists join RecId from job where job.RecId == positionDetail.Job
            exists join job from jobPermissionGroup where (jobPermissionGroup.Job == job.RecId && posPermission.RecId == jobPermissionGroup.RetailPosPermissionGroup)
        {
            posPermissionGroup.AllowBlindClose = posPermissionGroup.AllowBlindClose | posPermission.AllowBlindClose;
            posPermissionGroup.allowChangeNoVoid = posPermissionGroup.allowChangeNoVoid | posPermission.allowChangeNoVoid;
            posPermissionGroup.allowChangePeripheralStation = posPermissionGroup.allowChangePeripheralStation | posPermission.allowChangePeripheralStation;
            posPermissionGroup.allowCreateOrder = posPermissionGroup.allowCreateOrder | posPermission.allowCreateOrder;
            posPermissionGroup.allowEditOrder = posPermissionGroup.allowEditOrder | posPermission.allowEditOrder;
            posPermissionGroup.allowFloatingTenderDeclaration = posPermissionGroup.allowFloatingTenderDeclaration | posPermission.allowFloatingTenderDeclaration;
            posPermissionGroup.allowKitDisassembly = posPermissionGroup.allowKitDisassembly | posPermission.allowKitDisassembly;
            posPermissionGroup.allowMultipleLogins = posPermissionGroup.allowMultipleLogins | posPermission.allowMultipleLogins;
            posPermissionGroup.allowMultipleShiftLogon = posPermissionGroup.allowMultipleShiftLogon | posPermission.allowMultipleShiftLogon;
            posPermissionGroup.allowOpenDrawerOnly = posPermissionGroup.allowOpenDrawerOnly | posPermission.allowOpenDrawerOnly;
            posPermissionGroup.allowPriceOverride = posPermissionGroup.allowPriceOverride | posPermission.allowPriceOverride;
            posPermissionGroup.allowRetrieveOrder = posPermissionGroup.allowRetrieveOrder | posPermission.allowRetrieveOrder;
            posPermissionGroup.allowSalesTaxChange = posPermissionGroup.allowSalesTaxChange | posPermission.allowSalesTaxChange;
            posPermissionGroup.allowTenderDeclaration = posPermissionGroup.allowTenderDeclaration | posPermission.allowTenderDeclaration;
            posPermissionGroup.allowTransactionSuspension = posPermissionGroup.allowTransactionSuspension | posPermission.allowTransactionSuspension;
            posPermissionGroup.allowTransactionVoiding = posPermissionGroup.allowTransactionVoiding | posPermission.allowTransactionVoiding;
            posPermissionGroup.allowXReportPrinting = posPermissionGroup.allowXReportPrinting | posPermission.allowXReportPrinting;
            posPermissionGroup.AllowZReportPrinting = posPermissionGroup.AllowZReportPrinting | posPermission.AllowZReportPrinting;
            posPermissionGroup.managerPrivileges = posPermissionGroup.managerPrivileges | posPermission.managerPrivileges;
            posPermissionGroup.manageDevice = posPermissionGroup.manageDevice | posPermission.manageDevice;
            posPermissionGroup.AllowPasswordChange = posPermissionGroup.AllowPasswordChange | posPermission.AllowPasswordChange;
            posPermissionGroup.AllowResetPassword = posPermissionGroup.AllowResetPassword | posPermission.AllowResetPassword;
            posPermissionGroup.maximumDiscountPct = max( posPermissionGroup.maximumDiscountPct, posPermission.maximumDiscountPct );
            posPermissionGroup.maxLineDiscountAmount = max ( posPermissionGroup.maxLineDiscountAmount, posPermission.maxLineDiscountAmount );
            posPermissionGroup.maxLineReturnAmount = max ( posPermissionGroup.maxLineReturnAmount, posPermission.maxLineReturnAmount );
            posPermissionGroup.maxTotalDiscountAmount = max ( posPermissionGroup.maxTotalDiscountAmount, posPermission.maxTotalDiscountAmount );
            posPermissionGroup.maxTotalDiscountPct = max ( posPermissionGroup.maxTotalDiscountPct, posPermission.maxTotalDiscountPct );
            posPermissionGroup.maxTotalReturnAmount = max ( posPermissionGroup.maxTotalReturnAmount, posPermission.maxTotalReturnAmount );
            posPermissionGroup.allowManageSharedShift = posPermissionGroup.allowManageSharedShift | positionPosPermission.allowManageSharedShift;
            posPermissionGroup.allowUseSharedShift = posPermissionGroup.allowUseSharedShift | positionPosPermission.allowUseSharedShift;
            posPermissionGroup.AllowSaleOutsideAssortment = posPermissionGroup.AllowSaleOutsideAssortment | positionPosPermission.AllowSaleOutsideAssortment;
            posPermissionGroup.AllowPrintingReceiptCopy = min ( posPermissionGroup.AllowPrintingReceiptCopy, positionPosPermission.AllowPrintingReceiptCopy );
            posPermissionGroup.AllowSkipFiscalRegistration = posPermissionGroup.AllowSkipFiscalRegistration | positionPosPermission.AllowSkipFiscalRegistration;
            posPermissionGroup.AllowAcceptOrder = posPermissionGroup.AllowAcceptOrder | positionPosPermission.AllowAcceptOrder;
            posPermissionGroup.AllowRejectOrder = posPermissionGroup.AllowRejectOrder | positionPosPermission.AllowRejectOrder;
            posPermissionGroup.AllowMassActivation = posPermissionGroup.AllowMassActivation | posPermission.AllowMassActivation;
            posPermissionGroup.AllowCreateTransferOrder = posPermissionGroup.AllowCreateTransferOrder | posPermission.AllowCreateTransferOrder;

            if (!isRetailHideStoreInventoryUserFlight)
            {
                posPermissionGroup.UseHandheld = posPermissionGroup.UseHandheld | posPermission.UseHandheld;
            }
            posPermissionGroup.viewTimeclockEntries = posPermissionGroup.viewTimeclockEntries | posPermission.viewTimeclockEntries;
            posPermissionGroup.AllowTaskGuides = posPermissionGroup.AllowTaskGuides | posPermission.AllowTaskGuides;
            posPermissionGroup.AllowSkipRegistrationOrMarkAsRegistered = posPermissionGroup.AllowSkipRegistrationOrMarkAsRegistered | posPermission.AllowSkipRegistrationOrMarkAsRegistered;
            posPermissionGroup.AllowTaskManagement = posPermissionGroup.AllowTaskManagement | posPermission.AllowTaskManagement;
            posPermissionGroup.AllowPostponeRegistration = posPermissionGroup.AllowPostponeRegistration | posPermission.AllowPostponeRegistration;
            posPermissionGroup.AllowPostInventoryAdjustment = posPermissionGroup.AllowPostInventoryAdjustment | posPermission.AllowPostInventoryAdjustment;
            posPermissionGroup.AllowPostStockCounting = posPermission.AllowPostStockCounting | positionPosPermission.AllowPostStockCounting;
            posPermissionGroup.AllowCloseShift = posPermission.AllowCloseShift | positionPosPermission.AllowCloseShift;
            posPermissionGroup.AllowCreatePurchaseOrder = posPermission.AllowCreatePurchaseOrder | positionPosPermission.AllowCreatePurchaseOrder;
            posPermissionGroup.AllowConfirmPurchaseOrder = posPermission.AllowConfirmPurchaseOrder | positionPosPermission.AllowConfirmPurchaseOrder;
            foundNonOverriddenPermissions = true;
        }

        if (foundNonOverriddenPermissions)
        {
            AppLogging::EventWriteRetailTransactionServiceGetStaffPermissionsFoundNonOverriddenPermissions(foundStaff.RecId, _staffId, staffIdLength, posPermissionGroup.RecId, posPermissionGroup.managerPrivileges, posPermissionGroup.manageDevice, correlationId);
        }
        else
        {
            AppLogging::EventWriteRetailTransactionServiceGetStaffPermissionsDidNotFindNonOverriddenPermissions(foundStaff.RecId, _staffId, staffIdLength, correlationId);
        }

        staffPermission = posPermissionGroup;
        return staffPermission;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startBreak</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers break for the worker specified.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id, where time registration is made.
    /// </param>
    /// <param name="_breakJobId">
    /// The job id of the break.
    /// </param>
    /// <returns>
    /// A container having information whether registration is successful.
    /// </returns>
    /// <remarks>
    /// With the job id we can specify the kind of break (e.g. break for lunch, break from work etc.).
    /// Currently, any kind of break can be added in JmgIpcActivity table.
    /// </remarks>
    public static container startBreak(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId, JmgJobId _breakJobId)
    {
        boolean             success = true;
        str                 errorMessage;
        utcDateTime         operationDateTime;
        container           newTimeEntryResult;
        JmgTermReg          currentTimeRegistrationState = RetailTransactionServiceEmployee::getLatestTimeRegistrationByWorker(_personnelNumber, _terminalId);
        HcmWorker           worker = HcmWorker::findByPersonnelNumber(_personnelNumber);

        // check the current time registration state of the worker
        if (currentTimeRegistrationState.RegType != JmgTermRegType::ClockOut)
        {
            if (currentTimeRegistrationState.RegType != JmgTermRegType::BrkFlowStart)
            {
                // register break
                newTimeEntryResult = RetailTransactionServiceEmployee::addTimeRawRegistration(worker.RecId, _terminalId, JmgTermRegType::BrkFlowStart, _breakJobId);
                if (conPeek(newTimeEntryResult, #timeEntrySuccessResultPosition)) // new entry has been added successfully or not?
                {
                    operationDateTime = conPeek(newTimeEntryResult, #timeEntryRegDateTimePosition);
                }
                else
                {
                    success = false;
                    errorMessage = conPeek(newTimeEntryResult, #timeEntryErrorMessagePosition); // reason of why new time entry has not been added
                }
            }
            else
            {
                // if the worker is already on break, another break can not be registered
                success = false;
                errorMessage = "@RET4160279";
            }
        }
        else
        {
            // if the worker is clocked out, break can not be registered
            success = false;
            errorMessage = "@REX4161263";
        }

        return [success, errorMessage, DateTimeUtil::toStr(operationDateTime)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method gets the staff Id and returns detail information about the staff and permissions for staff.
    /// </summary>
    /// <param name="_staffId">
    /// Staff Id.
    /// </param>
    /// <returns>
    /// The Staff Information as a container.
    /// </returns>
    public static container retailServerStaffInfo(RetailStaffId _staffId)
    {
        RetailStaffTable staff;
        HcmWorker worker;
        RetailStaffPermission staffPermission;
        DirPartyTable party;
        container result = [true,""];

        staff = RetailStaffTable::find(_staffId);
        select Name from party
            exists join worker where worker.PersonnelNumber == _staffId && worker.Person == party.RecId;

        staffPermission = RetailTransactionServiceEmployee::staffPermission(_staffId);

        result = result + RetailTransactionServiceEmployee::getStaffPermission(staff, party, staffPermission);
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffInfoByExternalIdentity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method gets the staff Id and returns detail information about the staff and permissions for staff.
    /// </summary>
    /// <param name="_externalIdentityId">
    /// Primary external identity identifier (eg: AAD Tenent Id).
    /// </param>
    /// <param name="_externalIdentitySubId">
    /// Sub-identifier for external identity (eg: AAD Object Id).
    /// </param>
    /// <returns>
    /// The Staff Information as a container.
    /// </returns>
    public static container retailServerStaffInfoByExternalIdentity(str _externalIdentityId, str _externalIdentitySubId)
    {
        RetailStaffTable staff;
        HcmWorker worker;
        RetailStaffPermission staffPermission;
        DirPartyTable party;
        container result = [true,""];
        guid correlationId = newGuid();

        int userObjectIdLength = strLen(_externalIdentitySubId);
        AppLogging::EventWriteRetailTransactionServiceBeginFindByExternalIdentity(_externalIdentityId, _externalIdentitySubId, userObjectIdLength, correlationId);
        staff = RetailStaffTable::findByExternalIdentity(_externalIdentityId, _externalIdentitySubId);

        if (!staff)
        {
            AppLogging::EventWriteRetailTransactionServiceFindByExternalIdentityWithTenantIdNotFound(_externalIdentityId, _externalIdentitySubId, userObjectIdLength, correlationId);

            // If we didn't find an exact match on both Tenant+Object Ids, fall back to a match on only Object as Tenant is not mandatory.
            staff = RetailStaffTable::findByExternalIdentity('', _externalIdentitySubId);
        }

        if (!staff)
        {
            AppLogging::EventWriteRetailTransactionServiceFindByExternalIdentityNotFound(_externalIdentityId, _externalIdentitySubId, userObjectIdLength, correlationId);
        }
        else
        {
            int staffIdLength = strLen(staff.staffId);
            AppLogging::EventWriteRetailTransactionServiceFindByExternalIdentityFound(_externalIdentityId, _externalIdentitySubId, userObjectIdLength, staff.RecId, staff.staffId, staffIdLength, correlationId);
        }

        select Name from party
            exists join worker where worker.PersonnelNumber == staff.staffId && worker.Person == party.RecId;

        staffPermission = RetailTransactionServiceEmployee::staffPermission(staff.staffId);

        result = result + RetailTransactionServiceEmployee::getStaffPermission(staff, party, staffPermission);
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffLogOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method deletes the record from <c>RetailStaffLoginLog</c> table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeRecId">
    /// RecID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalRecId">
    /// RecID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_logoffFromStore">
    /// True to logoff from store, false otherwise
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to delete.
    /// </exception>
    public static container retailServerStaffLogOff(RetailStaffId _staffId, RetailChannelRecId _storeRecId, RefRecId _terminalRecId, boolean _logoffFromStore = true)
    {
        RetailStoreId       storeNumber;
        RetailTerminalId    terminalId;
        RetailTerminalTable terminalTable;

        select firstOnly terminalId from terminalTable where terminalTable.RecId == _terminalRecId;
        terminalId = terminalTable.terminalId;
        storeNumber = RetailStoreTable::findRecId(_storeRecId).StoreNumber;

        return RetailTransactionService::staffLogOff(_staffId, storeNumber, terminalId, _logoffFromStore);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the RetailStaffLoginLog.staffId with the value in <c>_staffId</c> if the record exists in <c>RetailStaffLoginLog</c>;
    /// else creates the record in <c>RetailStaffLoginLog</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeRecId">
    /// RecID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalRecId">
    /// RecID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <param name="_loginToStore">
    /// True to login to a store, false to login without store association
    /// </param>
    /// <param name="_skipPasswordValidation">
    /// A value indicating whether password validation must not be performed.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container retailServerStaffLogOn(RetailStaffId _staffId, RetailChannelRecId _storeRecId, RefRecId _terminalRecId, RetailStaffPassword _password, boolean _loginToStore=true, boolean _skipPasswordValidation = false)
    {
        RetailStoreId       storeNumber;
        RetailTerminalId    terminalId;
        RetailTerminalTable terminalTable;
        container           results, staff_results;

        select firstOnly terminalId from terminalTable where terminalTable.RecId == _terminalRecId;
        terminalId = terminalTable.terminalId;
        storeNumber = RetailStoreTable::findRecId(_storeRecId).StoreNumber;

        ttsBegin;
        try
        {
            results = RetailTransactionService::staffLogOn(_staffId, storeNumber, terminalId, _password, _loginToStore, _skipPasswordValidation);

            if (conPeek(results, 1)  == true)
            {
                staff_results = results;
                ttsCommit;
            }
            else
            {
                staff_results = results;
                ttsAbort;
            }
        }
        catch
        {
            ttsAbort;
            throw error("@RET2382");
        }

        return staff_results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmployeeStoresFromAddressBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all accessible stores for the employee.
    /// </summary>
    /// <param name="_staffId">
    /// The employee's identifier.
    /// </param>
    /// <param name="_top">
    /// The number of store records to get.
    /// </param>
    /// <param name="_skip">
    /// The number of store records to skip.
    /// </param>
    /// <returns>
    /// The list of accessible stores by this employee (ordered by StoreNumber).
    /// </returns>
    public static container getEmployeeStoresFromAddressBook(RetailStaffId _staffId, int64 _top = 100, int64 _skip = 0)
    {
        DirAddressBookParty dirAddressBookParty;
        HcmWorker hcmWorker;
        RetailStoreAddressBook retailStoreAddressBook;
        RetailStoreTable retailStoreTable;
        RetailChannelTable retailChannelTable;
        DirPartyTable dirPartyTable;
        OMOperatingUnit omOperatingUnit;
        DirPartyPostalAddressView dirPartyPostalAddressView;

        container stores = [true, ''];
        int64 numOfRecords = 1;

        if (_staffId == '')
        {
            // Returns false when _staffId is undefined.
            return [false, "@Retail:StaffIdIsMissing"];
        }
        else
        {
            while select * from dirAddressBookParty
                join hcmWorker
                    where dirAddressBookParty.Party == hcmWorker.Person
                        && hcmWorker.PersonnelNumber == _staffId
                join retailStoreAddressBook
                    where dirAddressBookParty.AddressBook == retailStoreAddressBook.AddressBook
                        && retailStoreAddressBook.AddressBookType == RetailAddressBookType::Employee
                join StoreNumber from retailStoreTable
                    group by StoreNumber
                    where retailStoreAddressBook.StoreRecId == retailStoreTable.RecId
                join retailChannelTable
                    where retailStoreTable.RecId == retailChannelTable.RecId
                join Name from dirPartyTable
                    group by Name
                    order by Name
                    where retailChannelTable.OMOperatingUnitID == dirPartyTable.RecId
                join OMOperatingUnitNumber from omOperatingUnit
                    group by OMOperatingUnitNumber
                    where retailChannelTable.OMOperatingUnitID == omOperatingUnit.RecId
                outer join Address from dirPartyPostalAddressView
                    group by Address
                    where retailChannelTable.OMOperatingUnitID == dirPartyPostalAddressView.Party
                        && dirPartyPostalAddressView.IsPrimary == NoYes::Yes
            {
                // Gets the records from _skip to _skip+_top.
                if (numOfRecords > _skip && numOfRecords - _skip <= _top)
                {
                    stores = conIns(stores,
                        conLen(stores) + 1,
                        [retailStoreTable.StoreNumber,
                        dirPartyTable.Name,
                        dirPartyPostalAddressView.Address,
                        omOperatingUnit.OMOPERATINGUNITNUMBER]);
                }

                numOfRecords++;
            }
        }

        return stores;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enrollUserCredentials</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enrolls a user's authentication credentials.
    /// </summary>
    /// <param name = "staffId">The staff identifier.</param>
    /// <param name = "grantType">The authentication grant type.</param>
    /// <param name = "credentialId">The credential identifier.</param>
    /// <param name = "credential">The user credential secret.</param>
    /// <param name = "additionalAuthenticationData">Any additional authentication data.</param>
    /// <returns>The result of the operation according to RTS protocol - extra data returned, in order: hashed credentials, salt, hash algorithm, recid.</returns>
    public static container enrollUserCredentials(RetailStaffId staffId, str grantType, str credentialId, str credential, str additionalAuthenticationData)
    {
        #define.StaffNotFoundError(0)
        #define.CredentialIdAlreadyInUse(1)

        container fail(int errorId)
        {
            return [false, '', errorId];
        }

        container result;
        RetailStaffTable staff;
        RetailStaffCredentialTable staffCredential;
        RetailStaffCredentialTable existingStaffCredential;
        boolean newRecord;

        staff = RetailStaffTable::find(staffId);

        // check if user exists
        if (!staff)
        {
            return fail(#StaffNotFoundError);
        }

        ttsbegin;

        // check if credential id is already in use by another user
        existingStaffCredential = RetailStaffCredentialTable::findByCredentialId(credentialId, grantType);
        if (existingStaffCredential && existingStaffCredential.staffId != staffId)
        {
            HcmWorker hcmWorker = HcmWorker::findByPersonnelNumber(existingStaffCredential.staffId);

            if(!hcmWorker || HcmPositionWorkerAssignment::countActivePositionWorkerAssignment(hcmWorker.RecId) == 0)
            {
                // This credential existing staff is already not valid, unenroll credential from this staff first.
                RetailTransactionServiceEmployee::deleteUserCredential(existingStaffCredential.staffId, grantType);
            }
            else
            {
                // This credential existing staff is still valid, throw CredentialIdAlreadyInUse error.
                ttsabort;
                return fail(#CredentialIdAlreadyInUse);
            }
        }

        staffCredential = RetailStaffCredentialTable::find(staffId, grantType, true);
        newRecord = staffCredential.RecId == 0;

        staffCredential.staffId = staffId;
        staffCredential.grantType = grantType;
        staffCredential.additionalAuthenticationData = additionalAuthenticationData;

        // update credential (hash it)
        staffCredential.hashCredential(credentialId, credential);

        if (newRecord)
        {
            staffCredential.insert();
        }
        else
        {
            staffCredential.update();
        }

        ttscommit;
        return [true, '', staffCredential.hashedCredential, staffCredential.salt, staffCredential.hashAlgorithm, staffCredential.RecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>unenrollUserCredentials</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes a user's authentication credentials.
    /// </summary>
    /// <param name = "staffId">The staff identifier.</param>
    /// <param name = "grantType">The authentication grant type.</param>
    /// <returns>The result of the operation according to RTS protocol - no extra data.</returns>
    public static container unenrollUserCredentials(RetailStaffId staffId, str grantType)
    {
        #define.StaffNotFoundError(0)

        container fail(int errorId)
        {
            return [false, '', errorId];
        }

        container result;
        RetailStaffTable staff;
        staff = RetailStaffTable::find(staffId);
        // check if user exists
        if (!staff)
        {
             return fail(#StaffNotFoundError);
        }

        RetailTransactionServiceEmployee::deleteUserCredential(staffId, grantType);

        return [true, ''];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUserCredential</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a user's authentication credentials.
    /// </summary>
    /// <param name = "credentialId">The credential identifier.</param>
    /// <param name = "grantType">The authentication grant type.</param>
    /// <returns>The result of the operation according to RTS protocol - extra data returned, in order: an xml representing the <c>RetailStaffCredentialTable</c> record found.</returns>
    public static container getUserCredential(str credentialId, str grantType)
    {
        RetailStaffCredentialTable staffCredential;
        str xml;
        boolean success;

        staffCredential = RetailStaffCredentialTable::findByCredentialId(credentialId, grantType);

        if (staffCredential)
        {
            success = true;
            xml = RetailTransactionServiceEmployee::xmlSerializeRecord(staffCredential, tableNum(RetailStaffCredentialTable));
        }
        else
        {
            success = false;
            xml = '';
        }

        return [success, '', xml];
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteUserCredential</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes a user's authentication credentials.
    /// </summary>
    /// <param name = "staffId">The staff identifier.</param>
    /// <param name = "grantType">The authentication grant type.</param>
    private static void deleteUserCredential(RetailStaffId staffId, str grantType)
    {
        #define.AllGrantTypes('*');

        RetailStaffCredentialTable staffCredential;
        utcdatetime currentDateTimeUtc = System.DateTime::UtcNow;

        ttsbegin;

        staffCredential.disableCache(true);
        // In below, we do insert a 'delete' record and delete original one instead of update record as 'delete' record directly.
        // The reason is update can cause conflict when CDX sync data to Channel DBs, since CDX has no guarantee of row insert/update order when applying data.
        // There can be situation the same staffId get unenroll and enroll again, see bug #413682, but CDX applies the enrollment first which causes conflict, see the below situation:
        // RECID    STAFFID GRANTTYPE   DELETEDDATETIME
        // 123      ABC     XYZ         2020-01-21 00:00:00.0000
        // 124      ABC     XYZ         1900-01-01 00:00:00.0000
        // If the order of apply is doing RECID 123 first, that's OK. But the problem happens if RECID 124 apply first, which conflict with RECID 123 which DELETEDDATETIME is not updated yet.
        // Solution below is do a real delete of original record, and insert back the original data as historial data.
        // Since CDX must apply for deleting record first, as the result, there must be no conflict for those unenroll (delete) record.
        if (grantType == #AllGrantTypes)
        {
            // keep the historial data as mark as 'deleted' records
            while select staffCredential
                where
                staffCredential.staffId == staffId
                && staffCredential.deletedDateTime == utcDateTimeNull()
            {
                staffCredential.deletedDateTime = currentDateTimeUtc;
                staffCredential.insert();
            }
            
            // delete the original records
            delete_from staffCredential
                where
                staffCredential.staffId == staffId
                && staffCredential.deletedDateTime == utcDateTimeNull(); 
        }
        else
        {
            // keep the historial data as mark as 'deleted' records
            while select staffCredential
                where
                staffCredential.staffId == staffId
                && staffCredential.grantType == grantType
                && staffCredential.deletedDateTime == utcDateTimeNull()
            {
                staffCredential.deletedDateTime = currentDateTimeUtc;
                staffCredential.insert();
            }

            // delete the original records
            delete_from staffCredential
                where
                staffCredential.staffId == staffId
                && staffCredential.grantType == grantType
                && staffCredential.deletedDateTime == utcDateTimeNull();

        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>xmlSerializeRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serializes a record in XML format.
    /// </summary>
    /// <param name = "record">The record to be serialized.</param>
    /// <param name = "tableId">The table identifier for the record.</param>
    /// <returns>The xml string.</returns>
    private static str xmlSerializeRecord(common record, TableId tableId)
    {
        DictTable table;
        DictField field;
        fieldId fieldId;
        str fieldName;
        anytype fieldValue;

        XmlDocument xmlDoc;
        XmlElement xmlRoot;
        XmlElement xmlElement;

        xmlDoc = XmlDocument::newBlank();
        xmlRoot = xmlDoc.createElement(tableId2Name(tableId));

        table = new DictTable(tableId);
        fieldId = table.fieldNext(0);

        // for each field in the table
        while (fieldId)
        {
            // get field details
            field = table.fieldObject(fieldId);

            // if it is a data field
            if (field.isSql())
            {
                // create an xml element for it
                fieldName = table.fieldName(fieldId);
                fieldValue = record.(fieldId);

                xmlElement = xmlDoc.createElement(field.name());
                xmlElement.innerText(any2Str(fieldValue));
                xmlRoot.appendChild(xmlElement);
            }

            fieldId = table.fieldNext(fieldId);
        }

        xmlDoc.appendChild(xmlRoot);
        return xmlDoc.toString();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>