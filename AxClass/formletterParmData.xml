<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>formletterParmData</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>FormletterParmData</c> class is a base class that is used by specialized classes for
/// creating the data that a specified order update is based on.
/// </summary>
abstract class FormletterParmData
{
    RecordInsertList        recordInsertParmTable;
    RecordInsertList        recordInsertParmLine;
    RecordInsertList        recordInsertParmSubTable;

    Map                     parmTableMap;
    Map                     parmLineMap;
    Map                     parmSubTableMap;

    systemSequence          systemSequence;

    SysQueryRun             chooseLines;
    boolean                 skipInitChooseLinesQuery;
    int                     progressTotal;

    DocumentStatus          documentStatus;
    ParmId                  parmId;

    boolean                 allowEmptyParmTable;
    boolean                 allowCreateParmTable;

    boolean                 showQueryForm;

    boolean                 tableRefIdUsed;
    TradeLineRefId          currentTableRefId;
    container               datasourceRecordsPacked;

    container               packedHistoryList;
    boolean                 createFromHistory;
    boolean                 createFromLines;
    boolean                 proforma;

    container               interCompanyMapPacked;
    InterCompanyCompanyId   interCompanyCompanyId;
    ParmId                  interCompanyParmId;
    boolean                 interCompanySelectFromJournal;

    ParmId                  parmIdSynched;
    NoYes                   multiForm;

    TransDate               transDate;
    Map                     mayJournalBePostedMap;

    Common                  parmUpdateSysLastValue;

    Set                     origOrderIdSet;
    boolean                 onlyCreateParmUpdate;

    boolean                 isInBatch;
    boolean                 executeLateSelection;
    Counter                 numberOfLines;

    boolean                 wasQueryFormCancelled;
    boolean                 usePackedMapInChooseLinesQuery;

    container               packedLineList;
    Common                  callerTable;

    FormLetterParmDataOutputContract outputContract;

    FormLetterParmDataVersioning    versioningStrategy;

    private FormLetterCustomInstrumentationLogger customInstrumentationLogger;

    // <GEERU>
    #ISOCountryRegionCodes
    boolean                 forceUpdate;
    // </GEERU>

    MCRPickingWave          mcrPickWaveReference;

    #define.KeyDelimitor('#')

    #define.posNewQty(1)
    #define.posNewInventQty(2)
    #define.posPreviousQty(3)
    #define.posPreviousInventQty(4)
    #define.PosNewCWQty(1)
    #define.PosPreviousCWQty(2)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addToKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a string value to a key.
    /// </summary>
    /// <param name="_key">
    /// A string value that contains a key.
    /// </param>
    /// <param name="_addTokey">
    /// The string value to add to the given key.
    /// </param>
    /// <returns>
    /// A string with the modified key.
    /// </returns>
    protected str addToKey(str _key, str _addTokey)
    {
        str key = _key;

        if (_addTokey)
        {
            if (key)
            {
                key += #keyDelimitor;
            }
            key += _addTokey;
        }
        return key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>formletterParmData.doChooseLines</c> method can be executed.
    /// </summary>
    /// <returns>
    /// true if the <c>formletterParmData.doChooseLines</c> method can be executed; otherwise, false.
    /// </returns>
    protected boolean allowChooseLines()
    {
        return !this.existsParmLines();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowCreateParmTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a posting header record without the associated lines can be created.
    /// </summary>
    /// <param name="_allowCreateParmTable">
    /// A Boolean value to set; optional.
    /// </param>
    /// <returns>
    /// A Boolean value.
    /// </returns>
    protected boolean  allowCreateParmTable(boolean  _allowCreateParmTable = allowCreateParmTable)
    {
        allowCreateParmTable = _allowCreateParmTable;
        return _allowCreateParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>catchAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs clean-up if an exception is thrown.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    /// The update has been canceled.
    /// </exception>
    protected void catchAll()
    {
        this.removeRecIdSuspension();
        throw error("@SYS18738");
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAdvancePayments_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stub method for checking if advance payments.
    /// </summary>
    /// <param name="_showBox">
    /// Determines if box should be shown to user to prompt for proceeding if prepayments exist
    /// </param>
    /// <returns>
    /// This method always returns True.
    /// </returns>

    public boolean checkAdvancePayments_W(boolean _showBox = false)
    {
        boolean dummy()
        {
            return _showBox;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBeforePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to perform validation before posting.
    /// </summary>
    /// <param name="_showBox">
    /// A Boolean value that indicates whether to show box; optional.
    /// </param>
    /// <returns>
    /// Always returns true.
    /// </returns>
    public boolean checkBeforePost(boolean _showBox = false)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesChangedSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the source table in the <c>SysQueryRun</c> object has changed.
    /// </summary>
    /// <returns>
    /// true if the source table has changed; otherwise, false.
    /// </returns>
    protected boolean chooseLinesChangedSourceTable()
    {
        return chooseLines.changed(this.sourceTableTableId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesFromLineEnd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Runs when the records that are based on a list of order lines in the posting parameter tables are
    ///    created.
    /// </summary>
    protected void chooseLinesFromLineEnd()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesFromLineGetSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current source line for the <c>formletterParmData.doChooseLinesFromLine</c> method.
    /// </summary>
    /// <param name="_sourceLine">
    /// The source line record on which to base the retrieval.
    /// </param>
    /// <returns>
    /// The source line record.
    /// </returns>
    protected Common chooseLinesFromLineGetSourceLine(Common _sourceLine)
    {
        return _sourceLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesGetInventOwner_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets InventOwnerId of the current source line from the <c>ChooseLines</c> query.
    /// </summary>
    /// <returns>
    ///    The InventOwnerId.
    /// </returns>
    protected InventOwnerId_RU chooseLinesGetInventOwner_RU()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesGetSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current source line from the <c>SysQueryRun</c> object.
    /// </summary>
    /// <returns>
    /// The source line record.
    /// </returns>
    protected Common chooseLinesGetSourceLine()
    {
        return chooseLines.get(this.sourceLineTableId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesGetSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current source table from the <c>SysQueryRun</c> object.
    /// </summary>
    /// <returns>
    /// The source table record.
    /// </returns>
    protected Common chooseLinesGetSourceTable()
    {
        return chooseLines.get(this.sourceTableTableId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesNext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls next on the <c>SysQueryRun</c> object.
    /// </summary>
    /// <returns>
    /// true if a record was selected; otherwise, false.
    /// </returns>
    protected boolean chooseLinesNext()
    {
        return chooseLines.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Re-enables a source table in a query.
    /// </summary>
    /// <remarks>
    ///    The method can be overridden in derived classes to perform a cleanup at the end of the
    ///    <c>ChooseLines</c>method.
    /// </remarks>
    protected void cleanupChooseLines()
    {
        chooseLines.query().dataSourceTable(this.sourceLineTableId()).enabled(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the data on which the posting is to be based.
    /// </summary>
    /// <param name="_append">
    /// A Boolean value that indicates whether to append records or to delete existing records first;
    /// optional.
    /// </param>
    public void createData(boolean _append = false)
    {
        #OCCRetryCount

        const int MaxRetryDuplicateKeyException = 10;

        Common localParmUpdate;
        QueryBuildDataSource qbds;

        try
        {
            if (!this.parmParmUpdate().RecId)
            {
                ttsbegin;
                localParmUpdate = this.createParmUpdate();
                this.insertParmUpdate(localParmUpdate);
                ttscommit;
            }

            if (this.parmCreateFromHistory())
            {
                ttsbegin;
                this.createFromHistory();
                ttscommit;
            }
            else
            if (!onlyCreateParmUpdate)
            {
                if (!skipInitChooseLinesQuery)
                {
                    this.initLinesQuery();
                }
                if (this.promptChooseLines())
                {
                    boolean mustDeleteParmTables = this.mustDeleteParmTables() && FormletterParmDataDeleteParmTableFlight::instance().isEnabled();
                    
                    ttsbegin;
                    if (!_append || mustDeleteParmTables)
                    {
                        using (var activityContext = this.instrumentationLogger().formLetterParmDataActivities().deleteParmTables(_append, mustDeleteParmTables))
                        {
                            this.deleteParmTables();
                        }
                    }

                    if (!this.lateSelection() || this.parmExecuteLateSelection())
                    {
                        this.selectChooseLines(_append);
                    }
                    ttscommit;
                }

                qbds = chooseLines.query().dataSourceTable(this.sourceTableTableId());
                if (qbds)
                {
                    qbds.enabled(true);
                }
            }

            this.fillOutputContractForCreateData();
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (SysTransientSqlConnectionErrorHandler::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw Exception::TransientSqlConnectionError;
            }
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::DuplicateKeyExceptionNotRecovered)
        {
            if ((FormLetterParmDataParmIdRetryFlight::instance().isEnabled()
                && xSession::currentRetryCount() <= MaxRetryDuplicateKeyException)
                && xSession::lastDuplicateKeyViolatingTable() == this.parmTableTableId())
            {
                this.parmParmUpdate(null);

                retry;
            }
            else
            {
                throw Exception::DuplicateKeyExceptionNotRecovered;
            }
        }
        catch
        {
            this.catchAll();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDeleteParmTables</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Indicates if posting parameter table records should be deleted.
    /// </summary>
    /// <returns>
    /// true if posting parameter table records should be deleted; otherwise; <c>false</c>.
    /// </returns>
    protected boolean mustDeleteParmTables()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into posting parameter tables that are based on the previous posted records in the
    /// posting parameter tables.
    /// </summary>
    private void createFromHistory()
    {
        Common              parmTable;
        ListEnumerator      listEnumerator;

        if (this.parmHistoryList())
        {
            listEnumerator = List::create(this.parmHistoryList()).getEnumerator();
            this.initRecordLists();
            while (listEnumerator.moveNext())
            {
                parmTable = listEnumerator.current();

                this.resetParmTableJobStatus(parmTable);
                this.createFromHistoryParmTable(parmTable);
                this.createFromHistoryParmSubTables(parmTable);
                this.createFromHistoryParmLines(parmTable);
            }
            this.insertRecordLists();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetParmTableJobStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the job status for posting parameter table.
    /// </summary>
    /// <param name = "_parmTable">A previously posted order header parameter record.</param>
    protected void resetParmTableJobStatus(Common _parmTable)
    {
        FormletterParmTable formLetterParmTable = _parmTable as FormletterParmTable;
        formLetterParmTable.ParmJobStatus = ParmJobStatus::Waiting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromHistoryParmLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records in the order line posting parameter table.
    /// </summary>
    /// <param name="_parmTable">
    /// A previously posted order header parameter record.
    /// </param>
    /// <remarks>
    /// The method must be overridden in derived classes in which posting from history is supported.
    /// </remarks>
    protected void createFromHistoryParmLines(Common _parmTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromHistoryParmSubTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records in the order header sub posting parameter table.
    /// </summary>
    /// <param name="_parmTable">
    /// A previously posted order header parameter record.
    /// </param>
    /// <remarks>
    /// The method must be overridden in derived classes in which posting from history is supported.
    /// </remarks>
    protected void createFromHistoryParmSubTables(Common _parmTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromHistoryParmTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in the order header posting parameter table.
    /// </summary>
    /// <param name="_parmTable">
    /// A previously posted order header parameter record.
    /// </param>
    /// <remarks>
    /// The method must be overridden in derived classes in which posting from history is supported.
    /// </remarks>
    protected void createFromHistoryParmTable(Common _parmTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in the order line posting parameter table.
    /// </summary>
    /// <param name="_sourceLineTable">
    /// A record from the order line table.
    /// </param>
    /// <param name="_tableRefId">
    /// The reference ID from the connected record in the order header posting parameter table.
    /// </param>
    /// <returns>
    /// true if the record in the order line posting parameter table was created; otherwise; <c>false</c>.
    /// </returns>
    abstract protected boolean createParmLine(Common _sourceLineTable, TradeLineRefId _tableRefId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLinesAndTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates document processing lines and related document headers.
    /// </summary>
    protected void createParmLinesAndTable()
    {
        Common          sourceTable;
        Common          sourceLineTable;
        boolean         mayJournalBePosted;
        boolean         mayJournalTransBePosted;
        boolean         parmLineCreated;
        TradeLineRefId  tableRefId;
        // <GIN>
        PurchTable      purchTableRange;
        PurchTable_W    purchTableRange_W;
        SalesTable      salesTableRange;
        PurchParmUpdate purchParmUpdateLoc;
        SalesParmUpdate salesParmUpdateLoc;
        boolean         isCustomsEnable_IN = TaxParameters::isCustomsEnable_IN();
        // </GIN>

        chooseLines.reset();
        
        while (this.chooseLinesNext())
        {
            progressTotal++;

            if (this.chooseLinesChangedSourceTable())
            {
                sourceTable = this.chooseLinesGetSourceTable();
                this.sourceTableChanged(sourceTable);
                if (this.skipMayJournalBePosted())
                {
                    mayJournalBePosted = true;
                }
                else
                {
                    mayJournalBePosted = this.doMayJournalBePosted(sourceTable);
                }
            }

            if (!mayJournalBePosted)
            {
                continue;
            }

            // <GIN>
            //To block parm table and parm line creation from select button based on value of "Order" field
            if (isCustomsEnable_IN)
            {
                if (this.sourceTableTableId() == tableNum(PurchTable)
                    && this.parmDocumentStatus() != DocumentStatus::BillOfEntry_IN
                    && this.parmDocumentStatus() != DocumentStatus::ApproveJournal)
                {
                    purchTableRange   = sourceTable as PurchTable;
                    purchParmUpdateLoc  = this.parmParmUpdate() as PurchParmUpdate;

                    purchTableRange_W = purchTableRange.purchTable_W();
                    if ((purchParmUpdateLoc.CustomsImportOrderType_IN == CustomsImportOrderType_IN::ImportOrder   && purchTableRange_W.CustomsImportOrder_IN == NoYes::No) ||
                        (purchParmUpdateLoc.CustomsImportOrderType_IN == CustomsImportOrderType_IN::PurchaseOrder && purchTableRange_W.CustomsImportOrder_IN == NoYes::Yes))
                    {
                        continue;
                    }
                }
                else if (this.sourceTableTableId() == tableNum(SalesTable) && this.parmDocumentStatus() != DocumentStatus::ShippingBill_IN)
                {
                    salesTableRange   = sourceTable as SalesTable;
                    salesParmUpdateLoc  = this.parmParmUpdate() as SalesParmUpdate;

                    if ((salesParmUpdateLoc.CustomsExportOrderType_IN == CustomsExportOrderType_IN::ExportOrder && salesTableRange.CustomsExportOrder_IN == NoYes::No) ||
                        (salesParmUpdateLoc.CustomsExportOrderType_IN == CustomsExportOrderType_IN::SalesOrder  && salesTableRange.CustomsExportOrder_IN == NoYes::Yes))
                    {
                        continue;
                    }
                }
            }
            // </GIN>

            sourceLineTable = this.chooseLinesGetSourceLine();
            mayJournalTransBePosted = this.mayJournalTransBePosted(sourceLineTable);
            this.updateTaxIdDuringCreatingParmLinesAndTable();

            tableRefId = this.getTableRefId(sourceLineTable?sourceLineTable:sourceTable);

            if (sourceLineTable && mayJournalTransBePosted)
            {
                parmLineCreated = this.createParmLine(sourceLineTable, tableRefId);
            }
            else
            {
                parmLineCreated = false;
            }

            if ((parmLineCreated ||
                this.parmAllowEmptyParmTable()) && !this.existsParmTableKey(sourceTable, sourceLineTable))
            {
                this.createParmTable(sourceTable, sourceLineTable, tableRefId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxIdDuringCreatingParmLinesAndTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Call tax calculation to get the TaxId for splitting the order.
    /// This method should be called in createParmLinesAndTable method.
    /// </summary>
    internal void updateTaxIdDuringCreatingParmLinesAndTable()
    {
        // Placeholder for subclass to override.
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsParmTableKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if parameter table key exists in the map with added records keys.
    /// </summary>
    /// <param name = "_sourceTable">Source document table record.</param>
    /// <param name = "_sourceLineTable">Source document line record.</param>
    /// <returns>true if key is found; otherwise, false.</returns>
    protected boolean existsParmTableKey(Common _sourceTable, Common _sourceLineTable)
    {
        Common record = _sourceLineTable ? _sourceLineTable
                                         : _sourceTable;

        return parmTableMap.exists(this.parmTableMapKey(record));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmSubTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Inserts a record in the sub order header posting parameter table.
    /// </summary>
    /// <param name="_parmTable">
    ///   The connected order header posting parameter record.
    /// </param>
    abstract protected void createParmSubTable(Common _parmTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in the order header posting parameter table.
    /// </summary>
    /// <param name="_sourceTable">
    /// A record from the order header table.
    /// </param>
    /// <param name="_sourceLineTable">
    /// A record from the order line table.
    /// </param>
    /// <param name="_tableRefId">
    /// The reference ID to apply to the order header posting record.
    /// </param>
    /// <param name="_skipParmSubTable">
    /// A Boolean value that indicates whether how to create sub order header posting parameter records is
    /// to be skipped; optional.
    /// </param>
    /// <returns>
    /// The inserted record.
    /// </returns>
    abstract protected Common createParmTable(Common            _sourceTable,
                                              Common            _sourceLineTable,
                                              TradeLineRefId    _tableRefId,
                                              boolean           _skipParmSubTable = false)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Inserts a record in the order posting parameter table.
    /// </summary>
    /// <returns>
    ///   The inserted record.
    /// </returns>
    abstract protected Common createParmUpdate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Deletes a record from the order line posting parameter table.
    /// </summary>
    /// <param name="_refRecId">
    ///   A <c>RecID</c> from the record to be deleted.
    /// </param>
    protected void deleteParmLine(RefRecId _refRecId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteParmLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Deletes records in the order line posting parameter table for the current posting.
    /// </summary>
    abstract protected void deleteParmLines()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteParmTables</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Deletes records in the order header posting parameter table for the current posting.
    /// </summary>
    abstract protected void deleteParmTables()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>doChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates records in the posting parameter tables.
    /// </summary>
    /// <param name="_append">
    /// A Boolean value that determines whether to append records or delete existing records first;
    /// optional.
    /// </param>
    private void doChooseLines(boolean _append = false)
    {
        if (!_append && !this.allowChooseLines())
        {
            return;
        }

        this.initChooseLines();

        this.processAdditional();

        this.initRecordLists();

        this.allowCreateParmTable(this.parmAllowEmptyParmTable());

        this.createParmLinesAndTable();

        this.insertRecordLists();

        if (this.lateSelection() && this.parmExecuteLateSelection())
        {
            if (numberOfLines < 1
                && (!PurchFormletterParmDataPurchOrderSkipWarningFlight::instance().isEnabled()
                    || this.expectParmLinesCreated()))
            {
                checkFailed("@SYS26185");
            }
        }
        this.cleanupChooseLines();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doChooseLines_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The event handler when choose lines.
    /// </summary>
    /// <param name="_append">
    /// True if there is any append data.
    /// </param>
    // Method added to override standard doChooseLines functionality for ShippingBill Documents.
    protected void doChooseLines_IN(boolean _append = false)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>doChooseLinesFromLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates records in the posting parameter tables that are based on the specified list of order line
    /// records.
    /// </summary>
    private void doChooseLinesFromLine()
    {
        if (this.canChooseLinesFromLine())
        {
            this.initChooseLinesFromLine();

            ttsbegin;
            this.initRecordLists();
            using (var activityContextCreateChoosLines = this.instrumentationLogger().formLetterParmDataActivities().createChooseLinesFromLine())
            {
                this.createChooseLinesFromLine();
            }

            this.insertRecordLists();
            ttscommit;

            this.chooseLinesFromLineEnd();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canChooseLinesFromLine</Name>
				<Source><![CDATA[
    protected boolean canChooseLinesFromLine()
    {
        return conLen(this.parmLineList());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createChooseLinesFromLine</Name>
				<Source><![CDATA[
    [Replaceable]
    protected void createChooseLinesFromLine()
    {
        List lineList;
        ListEnumerator listEnumerator;
        Common sourceLine;
        Common line;

        lineList = List::create(this.parmLineList());
        listEnumerator = lineList.getEnumerator();

        while (listEnumerator.moveNext())
        {
            line = listEnumerator.current();

            sourceLine = this.chooseLinesFromLineGetSourceLine(line);

            if (!this.mayJournalTransBePosted(sourceLine))
            {
                continue;
            }

            using (var activityContextChoosLine = this.instrumentationLogger().formLetterParmDataActivities().chooseLineFromLine())
            {
                this.chooseLineFromLine(sourceLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLineFromLine</Name>
				<Source><![CDATA[
    protected void chooseLineFromLine(Common _sourceLine)
    {
        TradeLineRefId      tableRefId;
        
        if (!parmLineMap.exists(this.parmLineMapKey(_sourceLine)))
        {
            tableRefId = this.getTableRefId(_sourceLine);

            if ((this.createParmLine(_sourceLine, tableRefId)
                    ||  this.parmAllowEmptyParmTable())
                    && !parmTableMap.exists(this.parmTableMapKey(_sourceLine)))
            {
                this.createParmTable(this.getSourceTableFromSourceLine(_sourceLine), _sourceLine, tableRefId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doMayJournalBePosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the order can be posted.
    /// </summary>
    /// <param name="_sourceTable">
    /// The order header record.
    /// </param>
    /// <returns>
    /// true if posting is enabled; otherwise, false.
    /// </returns>
    protected boolean doMayJournalBePosted(Common _sourceTable)
    {
        boolean ok;

        if (!mayJournalBePostedMap)
        {
            mayJournalBePostedMap = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Enum);
        }

        if (mayJournalBePostedMap.exists(_sourceTable.RecId))
        {
            ok = mayJournalBePostedMap.lookup(_sourceTable.RecId);
        }
        else
        {
            ok = this.mayJournalBePosted(_sourceTable);
            mayJournalBePostedMap.insert(_sourceTable.RecId, ok);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doReArrange</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Performs a re-arrange for the records in the posting parameter tables.
    /// </summary>
    private void doReArrange()
    {
        using (var activityContext = this.instrumentationLogger().formLetterParmDataActivities().doReArrange())
        {
            QueryRun    queryRun;

            ttsbegin;

            using (var activityContextInit = this.instrumentationLogger().formLetterParmDataActivities().reArrangeInit())
            {
                this.reArrangeInit();
                this.initRecordLists();
            }

            using (SysInstrumentationActivityContext activityContextLines = this.instrumentationLogger().formLetterParmDataActivities().reArrangeLines())
            {
                queryRun = this.reArrangeQueryRun();

                int reArrangeLinesCount;

                while (queryRun.next())
                {
                    this.reArrangeLines(queryRun);

                    reArrangeLinesCount++;
                }

                activityContextLines.addCustomProperty('reArrangeLinesCount', int2Str(reArrangeLinesCount));
            }

            this.insertRecordLists();

            if (this.useSplitting())
            {
                using (var activityContextSplitting = this.instrumentationLogger().formLetterParmDataActivities().useSplitting())
                {
                    this.initRecordLists();
                    this.reArrangeSplit();
                    this.insertRecordLists();
                    this.updateParmTableReArrangeSplit();
                    this.updateShippingStatReArrangeSplit();
                }
            }

            using (var activityContextEnd = this.instrumentationLogger().formLetterParmDataActivities().reArrangeEnd())
            {
                this.reArrangeEnd();
            }

            // <GEERU>
            this.initOfficials_RU();
            // </GEERU>
            // <GEEU>
            this.checkAdvancePayments_W();
            // </GEEU>

            ttscommit;
            this.fillOutputContractForReArrange();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doReSelect</Name>
				<Source><![CDATA[
    private void doReSelect()
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().formLetterParmDataActivities().doReSelect())
        {
            SetEnumerator   setEnumerator;
            Num             origOrderId;

            ttsbegin;

            using (var activityContextInit = this.instrumentationLogger().formLetterParmDataActivities().reSelectInit())
            {
                this.reSelectInit();
                this.deleteParmLines();
                this.initRecordLists();
                this.fillOrigOrderIsSet();
            }

            setEnumerator = origOrderIdSet.getEnumerator();
            while (setEnumerator.moveNext())
            {
                using (var activityContextLines = this.instrumentationLogger().formLetterParmDataActivities().reSelectLines())
                {
                    origOrderId = setEnumerator.current();
                    this.reSelectLines(origOrderId);
                }
            }

            // Insert data prior to reSelectEnd so it can act on the database, if necessary
            this.insertRecordLists();

            using (var activityContextEnd = this.instrumentationLogger().formLetterParmDataActivities().reSelectEnd())
            {
                this.reSelectEnd();
            }

            // <GEERU>
            this.initOfficials_RU();
            // </GEERU>
            // <GEEU>
            this.checkAdvancePayments_W();
            // </GEEU>
            ttscommit;

            this.fillOutputContractForReSelect();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsParmLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether order line posting parameter records exist for the current posting.
    /// </summary>
    /// <returns>
    /// true if records exists; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method always returns false in the base class.
    /// </remarks>
    protected boolean existsParmLines()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsParmSubTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified record exists.
    /// </summary>
    /// <param name="_parmSubTable">
    /// The record to check for  existence.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    protected boolean existsParmSubTable(Common _parmSubTable)
    {
        return parmSubTableMap.exists(this.parmSubTableMapKey(_parmSubTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsParmUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a posting parameter record exists.
    /// </summary>
    /// <param name="_parmUpdate">
    /// A posting record to check for existence.
    /// </param>
    /// <returns>
    /// true if the record exists; otherwise, false.
    /// </returns>
    abstract protected boolean existsParmUpdate(Common _parmUpdate)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldIdParmTable_TableRefId</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the field ID for the <c>TableRefID</c> field in the posting parameter header table.
    /// </summary>
    /// <returns>
    ///   A field ID.
    /// </returns>
    abstract protected FieldId fieldIdParmTable_TableRefId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldIdSourceTable_OrderId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the field ID for the field that contains the order ID in the source table.
    /// </summary>
    /// <returns>
    /// A field ID.
    /// </returns>
    abstract protected FieldId fieldIdSourceTable_OrderId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillOrigOrderIsSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the internal set of original order IDs that are being processed.
    /// </summary>
    abstract protected void fillOrigOrderIsSet()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillOutputContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the <c>FormletterParmDataOutputContract</c> object by using data.
    /// </summary>
    protected void fillOutputContract()
    {
        outputContract.parmParmId(this.parmParmId());
        outputContract.parmParmUpdate(this.parmParmUpdate());
        if (this.parmQueryChooseLines())
        {
            outputContract.parmChooseLinesQueryPacked(SysOperationHelper::base64Encode(this.parmQueryChooseLines().pack()));
        }
        outputContract.parmWasQueryFormCancelled(this.parmWasQueryFormCancelled());
        if (parmTableMap)
        {
            outputContract.parmNumberOfParmTablesCreated(parmTableMap.elements());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillOutputContractForCreateData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the <c>FormletterParmDataOutputContract</c> object by using data when create data is invoked.
    /// </summary>
    [Hookable(false)]
    internal void fillOutputContractForCreateData()
    {
        this.fillOutputContract();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillOutputContractForReArrange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the <c>FormletterParmDataOutputContract</c> object by using data when re-arrange is invoked.
    /// </summary>
    [Hookable(false)]
    internal void fillOutputContractForReArrange()
    {
        this.fillOutputContract();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillOutputContractForReSelect</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the <c>FormletterParmDataOutputContract</c> object by using data when re-select is invoked.
    /// </summary>
    [Hookable(false)]
    internal void fillOutputContractForReSelect()
    {
        this.fillOutputContract();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOutputContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>FormletterParmDataOutputContract</c> object.
    /// </summary>
    /// <returns>
    /// An instance of the <c>FormletterParmDataOutputContract</c> class.
    /// </returns>
    public FormLetterParmDataOutputContract getOutputContract()
    {
        return outputContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOutputContractPacked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a packed version of the <c>FormletterParmDataOutputContract</c> object.
    /// </summary>
    /// <returns>
    /// A container with a packed version of the <c>FormletterParmDataOutputContract</c> object.
    /// </returns>
    public container getOutputContractPacked()
    {
        return this.getOutputContract().pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceTableFromSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the order header record for the order line specified.
    /// </summary>
    /// <param name="_sourceLine">
    ///    An order line record.
    /// </param>
    /// <returns>
    ///    An order header record.
    /// </returns>
    protected Common getSourceTableFromSourceLine(Common _sourceLine)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitInventOwnerId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines if result document should be splitted by inventory owner dimension in its lines
    /// </summary>
    /// <returns>
    ///   Always No
    /// </returns>
    protected NoYes getSplitInventOwnerId_RU()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitInventProfileType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines if result document should be splitted by inventory profile dimension in its lines
    /// </summary>
    /// <returns>
    ///   Always No
    /// </returns>
    protected NoYes getSplitInventProfileType_RU()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitPostingProfile_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines if result document should be splitted by posting profile in its lines
    /// </summary>
    /// <returns>
    ///   Always No
    /// </returns>
    protected NoYes getSplitPostingProfile_RU()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTableRefId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a table reference ID.
    /// </summary>
    /// <param name="_sourceLineTable">
    /// A record.
    /// </param>
    /// <param name="_reuse">
    /// A Boolean value that indicates whether a table reference ID can be reused.
    /// </param>
    /// <returns>
    /// A table reference ID.
    /// </returns>
    protected TradeLineRefId getTableRefId(Common _sourceLineTable, boolean _reuse = true)
    {
        TradeLineRefId  tableRefId;
        Common          parmTable;
        str             parmTableMapKey = this.parmTableMapKey(_sourceLineTable);

        if (_reuse && parmTableMap.exists(parmTableMapKey))
        {
            parmTable  = parmTableMap.lookup(parmTableMapKey);
            tableRefId = parmTable.(this.fieldIdParmTable_TableRefId());
        }
        else
        {
            if (this.tableRefIdUsed() || !currentTableRefId)
            {
                currentTableRefId = formletterParmData::getNewTableRefId();
                this.tableRefIdUsed(false);
            }
            tableRefId = currentTableRefId;
        }

        return tableRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>infoSourceTableSkipped</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when a source table record is skipped.
    /// </summary>
    /// <param name="_sourceTable">
    /// A record.
    /// </param>
    abstract protected void infoSourceTableSkipped(Common _sourceTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the class.
    /// </summary>
    public void init()
    {
        origOrderIdSet = new Set(Types::String);
        versioningStrategy.init();
        systemSequence = new systemSequence();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Allows method to be overridden so that some initialization at the start of the
    ///    <c>ChooseLines</c>method can be done.
    /// </summary>
    protected void initChooseLines()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initChooseLinesFromLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Starts creating records in the posting parameter tables, depending on the specified list of order
    /// line records.
    /// </summary>
    protected void initChooseLinesFromLine()
    {
        this.parmAllowEmptyParmTable(false);
        this.allowCreateParmTable(this.parmAllowEmptyParmTable());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLinesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the query.
    /// </summary>
    protected void initLinesQuery()
    {
        versioningStrategy.initQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOfficials_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method should initialize officials for update
    /// Overridden in descendants
    /// </summary>
    /// <param name="_parmTable">
    /// ParmTable to create officials for
    /// </param>
    public void initOfficials_RU(Common _parmTable = null)
    {
        container dummy() // BP warning
        {
            return [ _parmTable ];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQueryBuild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>chooseLines</c> query.
    /// </summary>
    protected void initQueryBuild()
    {
        chooseLines = new SysQueryRun(this.queryName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the record list and map variables.
    /// </summary>
    protected void initRecordLists()
    {
        this.suspendRecIds();

        recordInsertParmTable       = new RecordInsertList(this.parmTableTableId(),true, true, true);
        recordInsertParmSubTable    = new RecordInsertList(this.parmSubTableTableId(), true, true, true);
        recordInsertParmLine        = new RecordInsertList(this.parmLineTableId(), true, true, true);

        parmLineMap                 = new Map(Types::String,Types::Record);
        parmTableMap                = new Map(Types::String,Types::Record);
        parmSubTableMap             = new Map(Types::String,Types::Record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Inserts a record in the order line posting parameter table.
    /// </summary>
    /// <param name="_parmLine">
    ///   The record to insert.
    /// </param>
    protected void insertParmLine(Common _parmLine)
    {
        recordInsertParmLine.add(_parmLine);
        parmLineMap.insert(this.parmLineMapKey(_parmLine), _parmLine);
        numberOfLines++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmSubTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Inserts a record in the sub order header posting parameter table.
    /// </summary>
    /// <param name="_parmSubTable">
    ///   The record to insert.
    /// </param>
    protected void insertParmSubTable(Common _parmSubTable)
    {
        recordInsertParmSubTable.add(_parmSubTable);
        this.insertParmSubTableMap(_parmSubTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmSubTableMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the specified record into the map that keeps track of the records.
    /// </summary>
    /// <param name="_parmSubTable">
    /// The record to insert into the map.
    /// </param>
    /// <param name="_mapKey">
    /// A unique key for the record.
    /// </param>
    protected void insertParmSubTableMap(Common _parmSubTable, str _mapKey = this.parmSubTableMapKey(_parmSubTable))
    {
        parmSubTableMap.insert(_mapKey, _parmSubTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Inserts a record in the order header posting parameter table.
    /// </summary>
    /// <param name="_parmTable">
    ///   The record to insert.
    /// </param>
    protected void insertParmTable(Common _parmTable)
    {
        recordInsertParmTable.add(_parmTable);
        this.insertParmTableMap(_parmTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmTableMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the specified record into the map that keeps track of these records.
    /// </summary>
    /// <param name="_parmTable">
    /// The record to insert into the map.
    /// </param>
    /// <param name="_mapKey">
    /// A unique key for the record.
    /// </param>
    protected void insertParmTableMap(Common _parmTable, str _mapKey = this.parmTableMapKey(_parmTable))
    {
        parmTableMap.insert(_mapKey, _parmTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Inserts a record in the posting parameter table.
    /// </summary>
    /// <param name="_parmUpdate">
    ///   The record to insert.
    /// </param>
    protected void insertParmUpdate(Common _parmUpdate)
    {
        // When called from the batch dialog the record already exists
        if (!this.existsParmUpdate(_parmUpdate))
        {
            _parmUpdate.insert();
            this.parmParmUpdate(_parmUpdate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the records that are in the record lists into the database.
    /// </summary>
    protected void insertRecordLists()
    {
        recordInsertParmTable.insertDatabase();
        recordInsertParmSubTable.insertDatabase();
        recordInsertParmLine.insertDatabase();

        this.removeRecIdSuspension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets and sets the posting parameter line for an intercompany line.
    /// </summary>
    /// <param name="_common">
    ///   A record.
    /// </param>
    /// <returns>
    ///   A record.
    /// </returns>
    protected Common interCompanyParmLine(Common _common)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyParmLineQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the quantity for an intercompany line.
    /// </summary>
    /// <param name="_common">
    /// A record.
    /// </param>
    /// <param name="_isInventQty">
    /// A Boolean value that indicates whether the quantity is an inventory quantity.
    /// </param>
    /// <returns>
    /// A quantity.
    /// </returns>
    protected Qty interCompanyParmLineQty(Common _common, boolean _isInventQty = false)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>lateSelection</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether last selection is used.
    /// </summary>
    /// <returns>
    ///   true if late selection is used; otherwise, false.
    /// </returns>
    protected boolean lateSelection()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lateSelectionQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the <c>Query</c> to use in late selection.
    /// </summary>
    /// <returns>
    ///   The late selection <c>Query</c>.
    /// </returns>
    protected SysQueryRun lateSelectionQuery()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineListTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the table ID from the list of order line records that are specified.
    /// </summary>
    /// <returns>
    ///    A table ID.
    /// </returns>
    protected TableId lineListTableId()
    {
        Common          common;
        TableId         tableId;
        ListEnumerator  le;

        if (this.parmLineList() != conNull())
        {
            le = List::create(this.parmLineList()).getEnumerator();
            if (le.moveNext())
            {
                common  = le.current();
                tableId = common.TableId;
            }
        }
        return tableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadLastUsedQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to use the last used query when the prompt of the <c>SysQueryRun</c> object
    /// executes.
    /// </summary>
    /// <returns>
    /// true if the last used query will be used; otherwise, false.
    /// </returns>
    protected boolean loadLastUsedQuery()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayJournalBePosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a parameter table record is to be created for a given source table.
    /// </summary>
    /// <param name="_sourceTable">
    /// An order header record.
    /// </param>
    /// <returns>
    /// true if a parameter table record is to be created for the source table; otherwise, false.
    /// </returns>
    protected boolean  mayJournalBePosted(Common _sourceTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayJournalBePosted_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the journal should be posted.
    /// </summary>
    /// <param name="_sourceTable">
    /// The source table.
    /// </param>
    /// <returns>
    /// Returns true if the journal should be posted.
    /// </returns>
    protected boolean  mayJournalBePosted_IN(Common _sourceTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayJournalTransBePosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a parameter line is to be created for a given source line.
    /// </summary>
    /// <param name="_sourceLineTable">
    /// The source line record.
    /// </param>
    /// <returns>
    /// true if a parameter line is to be created for the source line; otherwise, false.
    /// </returns>
    protected boolean mayJournalTransBePosted(Common _sourceLineTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSplitData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits the parm table and parm lines further parm tables and parm lines.
    /// </summary>
    /// <returns>
    /// true if the parm table and parm lines were split without error; otherwise, false.
    /// </returns>
    /// <remarks>
    /// At this level in class hierarchy do nothing.  Split may be done by subclasses
    /// for ship alone and box splitting features.
    /// </remarks>
    public boolean mcrSplitData()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        outputContract = new FormLetterParmDataOutputContract();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowEmptyParmTable</Name>
				<Source><![CDATA[
    public boolean parmAllowEmptyParmTable(boolean  _allowEmptyParmTable = allowEmptyParmTable)
    {
        allowEmptyParmTable = _allowEmptyParmTable;
        return _allowEmptyParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCallerTable</Name>
				<Source><![CDATA[
    public Common parmCallerTable(Common _callerTable = callerTable)
    {
        callerTable = _callerTable;
        return callerTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreateFromHistory</Name>
				<Source><![CDATA[
    public boolean parmCreateFromHistory(boolean _createFromHistory = createFromHistory)
    {
        createFromHistory = _createFromHistory;
        return createFromHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreateFromLines</Name>
				<Source><![CDATA[
    boolean parmCreateFromLines(boolean _createFromLines = createFromLines)
    {
        createFromLines = _createFromLines;
        return createFromLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDatasourceRecordsPacked</Name>
				<Source><![CDATA[
    public container parmDatasourceRecordsPacked(container _datasourceRecordsPacked = datasourceRecordsPacked)
    {
        datasourceRecordsPacked = _datasourceRecordsPacked;
        return datasourceRecordsPacked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentStatus</Name>
				<Source><![CDATA[
    public DocumentStatus parmDocumentStatus(DocumentStatus _documentStatus = documentStatus)
    {
        documentStatus = _documentStatus;
        return documentStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExecuteLateSelection</Name>
				<Source><![CDATA[
    public boolean parmExecuteLateSelection(boolean _executeLateSelection = executeLateSelection)
    {
        executeLateSelection = _executeLateSelection;
        return executeLateSelection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForceUpdate_W</Name>
				<Source><![CDATA[
    public boolean parmForceUpdate_W(boolean _forceUpdate = forceUpdate)
    {
        forceUpdate = _forceUpdate;
        return _forceUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHistoryList</Name>
				<Source><![CDATA[
    public container parmHistoryList(container _packedHistoryList = packedHistoryList)
    {
        packedHistoryList = _packedHistoryList;
        return packedHistoryList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmId</Name>
				<Source><![CDATA[
    protected ParmId parmId()
    {
        if (!parmId)
        {
            parmId = formletterParmData::getNewParmId();
        }
        return parmId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyCompanyId</Name>
				<Source><![CDATA[
    public InterCompanyCompanyId parmInterCompanyCompanyId(InterCompanyCompanyId _interCompanyCompanyId = interCompanyCompanyId)
    {
        interCompanyCompanyId = _interCompanyCompanyId;
        return interCompanyCompanyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyMap</Name>
				<Source><![CDATA[
    container parmInterCompanyMap(container _interCompanyMapPacked = interCompanyMapPacked)
    {
        interCompanyMapPacked = _interCompanyMapPacked;
        return _interCompanyMapPacked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyParmId</Name>
				<Source><![CDATA[
    public ParmId  parmInterCompanyParmId(ParmId _interCompanyParmId = interCompanyParmId)
    {
        interCompanyParmId = _interCompanyParmId;
        return interCompanyParmId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyParmSelectFromJournal</Name>
				<Source><![CDATA[
    public boolean parmInterCompanyParmSelectFromJournal(boolean _selectFromJournal = interCompanySelectFromJournal)
    {
        interCompanySelectFromJournal = _selectFromJournal;

        return interCompanySelectFromJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsInBatch</Name>
				<Source><![CDATA[
    public boolean parmIsInBatch(boolean _isInBatch = isInBatch)
    {
        isInBatch = _isInBatch;
        return isInBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTrans</Name>
				<Source><![CDATA[
    public LedgerJournalTrans parmLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans = null)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineList</Name>
				<Source><![CDATA[
    public container parmLineList(container _packedLineList = packedLineList)
    {
        packedLineList = _packedLineList;
        return packedLineList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineMapKey</Name>
				<Source><![CDATA[
    abstract protected str parmLineMapKey(Common _parmLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineTableId</Name>
				<Source><![CDATA[
    abstract protected TableId parmLineTableId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRPickWaveReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the pick wave reference.
    /// </summary>
    /// <param name="_mcrPickWaveReference">
    /// The new pick wave reference value; optional.
    /// </param>
    /// <returns>
    /// The current or newly set pick wave reference.
    /// </returns>
    /// <remarks>
    /// The pick wave reference is used by the picking workbench.  It is used to control
    /// behaviors such as:
    ///     <list type="bullet">
    ///         <item>
    ///             <description>The process flow for orders that are picked using the workbench.</description>
    ///         </item>
    ///         <item>
    ///             <description>Whether the progress bar is displayed during posting.</description>
    ///         </item>
    ///         <item>
    ///             <description>Whether only lines needed for the pick wave should be selected.</description>
    ///         </item>
    ///         <item>
    ///             <description>Updating the correct quantity to pick.</description>
    ///         </item>
    ///    </list>
    /// </remarks>
    protected MCRPickingWave parmMCRPickWaveReference(MCRPickingWave _mcrPickWaveReference = mcrPickWaveReference)
    {
        mcrPickWaveReference = _mcrPickWaveReference;

        return mcrPickWaveReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMultiForm</Name>
				<Source><![CDATA[
    public NoYes parmMultiForm(NoYes _multiForm = multiForm)
    {
        multiForm = _multiForm;
        return multiForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOnlyCreateParmUpdate</Name>
				<Source><![CDATA[
    public boolean parmOnlyCreateParmUpdate(boolean _onlyCreateParmUpdate = onlyCreateParmUpdate)
    {
        onlyCreateParmUpdate = _onlyCreateParmUpdate;
        return onlyCreateParmUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmId</Name>
				<Source><![CDATA[
    public ParmId parmParmId(ParmId _parmId = parmId)
    {
        parmId = _parmId;
        return parmId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmIdSynched</Name>
				<Source><![CDATA[
    public ParmId  parmParmIdSynched(ParmId  _parmIdSynched = parmIdSynched)
    {
        parmIdSynched = _parmIdSynched;
        return parmIdSynched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTable_W</Name>
				<Source><![CDATA[
    public Common parmParmTable_W(Common _parmTable = null)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmUpdate</Name>
				<Source><![CDATA[
    abstract Common parmParmUpdate(Common _parmUpdate = null)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmUpdateSysLastValue</Name>
				<Source><![CDATA[
    public Common parmParmUpdateSysLastValue(Common _parmUpdateSysLastValue = parmUpdateSysLastValue)
    {
        parmUpdateSysLastValue = _parmUpdateSysLastValue;
        return parmUpdateSysLastValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProforma</Name>
				<Source><![CDATA[
    public boolean parmProforma(boolean _proforma = proforma)
    {
        proforma = _proforma;
        return proforma;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryChooseLines</Name>
				<Source><![CDATA[
    public SysQueryRun parmQueryChooseLines(SysQueryRun  _chooseLines = chooseLines)
    {
        if (_chooseLines)
        {
            skipInitChooseLinesQuery = true;
        }
        chooseLines = _chooseLines;
        return chooseLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowQueryForm</Name>
				<Source><![CDATA[
    public boolean parmShowQueryForm(boolean _showQueryForm = showQueryForm)
    {
        showQueryForm = _showQueryForm;
        return showQueryForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceTable</Name>
				<Source><![CDATA[
    abstract public Common parmSourceTable(Common _sourceTable = null)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubTableMapKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a key for the specified record.
    /// </summary>
    /// <param name="_source">
    /// The record for which to generate a key.
    /// </param>
    /// <returns>
    /// A string that holds the key for the record.
    /// </returns>
    protected str parmSubTableMapKey(Common _source)
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubTableTableId</Name>
				<Source><![CDATA[
    abstract protected TableId parmSubTableTableId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTableMapKey</Name>
				<Source><![CDATA[
    abstract protected str parmTableMapKey(Common _source)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTableTableId</Name>
				<Source><![CDATA[
    abstract protected TableId parmTableTableId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    TransDate parmTransDate(TransDate  _transDate = transDate)
    {
        if (!_transDate)
        {
            _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        transDate = _transDate;
        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUsePackedMapInChooseLinesQuery</Name>
				<Source><![CDATA[
    public boolean parmUsePackedMapInChooseLinesQuery(boolean _usePackedMapInChooseLinesQuery = usePackedMapInChooseLinesQuery)
    {
        usePackedMapInChooseLinesQuery = _usePackedMapInChooseLinesQuery;

        return usePackedMapInChooseLinesQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVersioningStrategy</Name>
				<Source><![CDATA[
    public FormLetterParmDataVersioning parmVersioningStrategy(FormLetterParmDataVersioning _versioningStrategy = versioningStrategy)
    {
        versioningStrategy = _versioningStrategy;
        return versioningStrategy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWasQueryFormCancelled</Name>
				<Source><![CDATA[
    public boolean parmWasQueryFormCancelled(boolean _wasQueryFormCancelled = wasQueryFormCancelled)
    {
        wasQueryFormCancelled = _wasQueryFormCancelled;
        return wasQueryFormCancelled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWInterCompanyParmLineQty</Name>
				<Source><![CDATA[
    protected PdsCWInventQty pdsCWInterCompanyParmLineQty(Common _common)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAdditional</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Overrides method to support processing of additional lines in parameter tables that were used by
    ///    the purchase invoice.
    /// </summary>
    protected void processAdditional()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the prompt of the <c>ChooseLines</c> query on the client-side if the class is currently
    ///    running on the server.
    /// </summary>
    /// <returns>
    ///    true if the prompt is executed; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <c>SysQueryRun</c> class does not support the <c>promptOnClient</c> framework to execute the
    ///    prompt on the client, which gives you multiple client calls when prompting from the server.
    /// </remarks>
    protected boolean  promptChooseLines()
    {
        container   packedChooseLines;
        boolean     result = true;

        if (this.parmShowQueryForm()
            && this.parmMCRPickWaveReference() == ""
            )
        {
            FormletterParmDataChooseLinesContext context = FormletterParmDataChooseLinesContext::current();

            if (context != null)
            {
                [result, packedChooseLines] = formletterParmData::promptChooseLinesOnClient(chooseLines.pack(), false);
            }
            else
            {
                [result, packedChooseLines] = formletterParmData::promptChooseLinesOnClient(chooseLines.pack(), this.loadLastUsedQuery());
            }

            this.parmWasQueryFormCancelled(!result);
            chooseLines = new SysQueryRun(packedChooseLines);
            if (VendInvoiceApprovalSelectPurchOrderFlightV2::instance().isEnabled())
            {
                if (result && ((this is PurchFormletterParmDataApproveJournal) || (this is PurchFormletterParmDataInvoice)))
                {
                    result = this.openSelectPurchVendOrder(chooseLines);
                    this.parmWasQueryFormCancelled(!result);
                }
            }
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the name of the query that is used to create data.
    /// </summary>
    /// <returns>
    /// A string with the name of the query that is used.
    /// </returns>
    abstract protected str queryName()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrange</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Performs a re-arrange of the created data.
    /// </summary>
    public void reArrange()
    {
        #OCCRetryCount

        try
        {
            using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().formLetterParmDataActivities().reArrange())
            {
                this.doReArrange();
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (SysTransientSqlConnectionErrorHandler::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw Exception::TransientSqlConnectionError;
            }
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch
        {
            this.catchAll();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the re-arrange of data is completed.
    /// </summary>
    protected void reArrangeEnd()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeInit</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the re-arrange process.
    /// </summary>
    protected void reArrangeInit()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Re-arranges the record in the line posting parameter table.
    /// </summary>
    /// <param name="_queryRun">
    ///   A <c>QueryRun</c> object.
    /// </param>
    abstract protected void reArrangeLines(QueryRun _queryRun)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeQueryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>QueryRun</c> that is used in the re-arrange process.
    /// </summary>
    /// <returns>
    /// A <c>QueryRun</c> object.
    /// </returns>
    abstract protected QueryRun reArrangeQueryRun()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeSplit</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Performs a split of the re-arranged data.
    /// </summary>
    protected void reArrangeSplit()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>recIdSuspensionTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>List</c> of tables that should have suspended Record ID generation.
    /// </summary>
    /// <returns>
    /// A <c>List</c> of table IDs that should have suspended Record ID generation.
    /// </returns>
    protected List recIdSuspensionTables()
    {
        return new List(Types::Integer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeRecIdSuspension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes a Record ID suspension.
    /// </summary>
    protected void removeRecIdSuspension()
    {
        List                list = this.recIdSuspensionTables();
        ListEnumerator      le;
        TableId             tableId;
        SysRecIdSequence    sysRecIdSequence;

        if (!list.empty())
        {
            sysRecIdSequence = appl.sysRecIdSequence();

            le = list.getEnumerator();
            while (le.moveNext())
            {
                tableId = le.current();
                if (sysRecIdSequence.isRecidSuspended(tableId))
                {
                    sysRecIdSequence.removeRecIdSuspension(tableId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelect</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Performs a re-select of the created data.
    /// </summary>
    public void reSelect()
    {
        #OCCRetryCount

        try
        {
            using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().formLetterParmDataActivities().reSelect())
            {
                this.doReSelect();
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (SysTransientSqlConnectionErrorHandler::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw Exception::TransientSqlConnectionError;
            }
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch
        {
            this.catchAll();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the re-selection of data is completed.
    /// </summary>
    protected void reSelectEnd()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectInit</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the re-select process.
    /// </summary>
    protected void reSelectInit()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a parameter line record during reselect, depending on whether journal transactions can be
    /// posted.
    /// </summary>
    /// <param name="_sourceLineTable">
    /// The source line record for which to create a parameter line record.
    /// </param>
    protected void reSelectLine(Common _sourceLineTable)
    {
        TradeLineRefId  tableRefId;

        if (this.mayJournalTransBePosted(_sourceLineTable))
        {
            tableRefId = this.getTableRefId(_sourceLineTable);
            this.createParmLine(_sourceLineTable, tableRefId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Re-selects the record in the line posting parameter table.
    /// </summary>
    /// <param name="_origOrderId">
    ///   An order ID.
    /// </param>
    abstract protected void reSelectLines(Num _origOrderId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reselectSummaryPackingSlip_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stub method to reread packing slip record.
    /// </summary>
    /// <returns>
    /// true if packing slip record should be reread; otherwise, false.
    /// </returns>
    protected boolean reselectSummaryPackingSlip_W()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes either the <c>formletterParmData.doChooseLinesFromLine</c> method or the
    /// <c>formletterParmData.doChooseLines</c> method.
    /// </summary>
    /// <param name="_append">
    /// A Boolean value that indicates whether to append or delete existing data first; optional.
    /// </param>
    [Replaceable]
    protected void selectChooseLines(boolean  _append = false)
    {
        if (this.parmCreateFromLines())
        {
            using (var activityContextDoChooseLines = this.instrumentationLogger().formLetterParmDataActivities().doChooseLinesFromLine())
            {
                this.doChooseLinesFromLine();
            }
        }
        else
        {
            this.doChooseLines(_append);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipMayJournalBePosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to make the call to the <c>formletterParmData.mayJournalBePosted</c> method when
    /// data is created.
    /// </summary>
    /// <returns>
    /// true if the method call is not to be made; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method always returns false in the base class.
    /// </remarks>
    protected boolean skipMayJournalBePosted()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLineTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the table ID for the source line table.
    /// </summary>
    /// <returns>
    ///    A table ID.
    /// </returns>
    abstract protected TableId sourceLineTableId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whenever the source table is changed.
    /// </summary>
    /// <param name="newSourceTable">
    /// The new source table record.
    /// </param>
    /// <remarks>
    /// This method can be overridden to perform some initialization.
    /// </remarks>
    protected void sourceTableChanged(Common newSourceTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the table ID for the source table.
    /// </summary>
    /// <returns>
    ///   A table ID.
    /// </returns>
    abstract protected TableId sourceTableTableId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitInventOwnerId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether splitting of the posting parameter lines by inventory owner ID is supported.
    /// </summary>
    /// <param name="_splitInventOwnerId">
    ///   Indicates whether the posting parameter lines should be splitted by inventory owner ID or not.
    /// </param>
    /// <returns>
    ///   true if the splitting process should be executed; otherwise, false.
    /// </returns>
    /// <remarks>
    ///   Always returns false in base class.
    /// </remarks>
    public NoYes splitInventOwnerId_RU(NoYes _splitInventOwnerId = NoYes::No)
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitInventProfileType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether splitting of the posting parameter lines by inventory profile type is supported.
    /// </summary>
    /// <param name="_splitInventProfileType">
    ///   Indicates whether the posting parameter lines should be splitted by inventory profile type or not.
    /// </param>
    /// <returns>
    ///   true if the splitting process should be executed; otherwise, false.
    /// </returns>
    /// <remarks>
    ///   Always returns false in base class.
    /// </remarks>
    public NoYes splitInventProfileType_RU(NoYes _splitInventProfileType = NoYes::No)
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitPostingProfile_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether splitting of the posting parameter lines by inventory profile is supported.
    /// </summary>
    /// <param name="_splitPostingProfile">
    ///   Indicates whether the posting parameter lines should be splitted by inventory profile or not.
    /// </param>
    /// <returns>
    ///   true if the splitting process should be executed; otherwise, false.
    /// </returns>
    /// <remarks>
    ///   Always returns false in base class.
    /// </remarks>
    public NoYes splitPostingProfile_RU(NoYes _splitPostingProfile = NoYes::No)
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>suspendRecIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Suspends record ID generation.
    /// </summary>
    protected void suspendRecIds()
    {
        List            list    = this.recIdSuspensionTables();
        ListEnumerator  le      = list.getEnumerator();
        TableId         tableId;

        if (list.elements() > 0)
        {
            while (le.moveNext())
            {
                tableId = le.current();
                appl.sysRecIdSequence().suspendRecIds(tableId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableRefIdUsed</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Sets and gets a <c>Boolean</c> value indicating if the current table reference ID is used.
    /// </summary>
    /// <param name="_tableRefIdUsed">
    ///   A <c>Boolean</c> value.
    /// </param>
    /// <returns>
    ///   true if the current table reference ID is used; otherwise, false.
    /// </returns>
    protected boolean tableRefIdUsed(boolean _tableRefIdUsed = tableRefIdUsed)
    {
        tableRefIdUsed = _tableRefIdUsed;
        return tableRefIdUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParmTableSplit</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Updates the posting parameter header record according to the split settings.
    /// </summary>
    /// <param name="_parmTable">
    ///   A posting parameter header record.
    /// </param>
    /// <param name="_fromLine">
    ///   A posting parameter line record.
    /// </param>
    protected void updateParmTableSplit(Common _parmTable, Common _fromLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryBuild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the query that is used during data creation.
    /// </summary>
    public void updateQueryBuild()
    {
        #Query

        if (this.parmUsePackedMapInChooseLinesQuery() && !this.parmDatasourceRecordsPacked())
        {
            throw error(strFmt("@SYS22828", funcName()));
        }

        if (this.useLateSelectionQuery())
        {
            chooseLines = this.lateSelectionQuery();
            chooseLines.literals(#QueryForceLiterals);
            return;
        }

        this.initQueryBuild();

        chooseLines.query().interactive(showQueryForm);
        chooseLines.literals(#queryForcePlaceholders);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryDocumentRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds ranges on order ID to the query that is used when data is created.
    /// </summary>
    /// <param name="_datasourceRecordsPackedMap">
    /// A container with a packed version of a map with order IDs.
    /// </param>
    /// <param name="_abortOnError">
    /// A Boolean value that indicates whether to stop the update of the query if an error occurs.
    /// </param>
    /// <returns>
    /// The number of order ID ranges that are added to the query.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// An error occurred during the update.
    /// </exception>
    protected int updateQueryDocumentRanges(container _datasourceRecordsPackedMap, boolean _abortOnError = false)
    {
        Common          localSourceTable;
        Map             map;
        MapEnumerator   mapEnumerator;
        int             noSelected;
        QueryBuildRange range;
        int             occurence = 1;

        if (_datasourceRecordsPackedMap)
        {
            if (this.parmUsePackedMapInChooseLinesQuery() && this.useLateSelectionQuery())
            {
                // The range on OrderId should be disabled so that it can be replaced with the contents of the map.
                do
                {
                    range = chooseLines.query().dataSourceTable(this.sourceTableTableId()).findRange(this.fieldIdSourceTable_OrderId(), occurence);

                    if (range)
                    {
                        range.enabled(false);
                    }

                    occurence++;
                } while ((chooseLines.query().dataSourceTable(this.sourceTableTableId()).findRange(this.fieldIdSourceTable_OrderId(), occurence)));
            }

            map = Map::create(_datasourceRecordsPackedMap);
            mapEnumerator = map.getEnumerator();

            while (mapEnumerator.moveNext())
            {
                localSourceTable = mapEnumerator.currentValue();

                if (this.skipAddRangeForSourceTable(localSourceTable, _abortOnError))
                {
                    continue;
                }

                noSelected++;
                chooseLines.query().dataSourceTable(localSourceTable.TableId).addRange(this.fieldIdSourceTable_OrderId()).value(queryValue(localSourceTable.(this.fieldIdSourceTable_OrderId())));
            }
        }

        // If no Rows was selected, make sure the query doesn't select all row's (no criteria is the equivalent of select all).
        if (noSelected == 0)
        {
            chooseLines.query().dataSourceTable(this.sourceTableTableId()).enabled(false);
        }

        this.parmDatasourceRecordsPacked(conNull());

        return noSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipAddRangeForSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to continue adding range to the source table.
    /// </summary>
    /// <param name="_localSourceTable">
    /// The order header record.
    /// </param>
    /// <param name="_abortOnError">
    /// Indicates whether to stop the update of the query if an error occurs.
    /// </param>
    /// <returns>
    /// true if adding the range to the source table must be skipped; otherwise, false.
    /// </returns>
    protected boolean skipAddRangeForSourceTable(Common _localSourceTable, boolean _abortOnError)
    {
        if (!this.doMayJournalBePosted(_localSourceTable))
        {
            this.infoSourceTableSkipped(_localSourceTable);
            if (_abortOnError)
            {
                throw error("@SYS78886");
            }
            
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useLateSelectionQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to use the last selection query.
    /// </summary>
    /// <returns>
    /// true if the late selection query will be used; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method always returns false in the base class.
    /// </remarks>
    protected boolean useLateSelectionQuery()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSplitting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether splitting of the posting parameter lines is supported.
    /// </summary>
    /// <returns>
    /// true if the splitting process is to be executed; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method always returns false in the base class.
    /// </remarks>
    protected boolean useSplitting()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewParmId</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets a new parameter ID.
    /// </summary>
    /// <returns>
    ///   A parameter ID.
    /// </returns>
    static ParmId getNewParmId()
    {
        return NumberSeq::newGetNum(formletterParmData::numRefParmId()).num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewTableRefId</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets a new table reference ID.
    /// </summary>
    /// <returns>
    ///   A table reference ID.
    /// </returns>
    static TradeLineRefId  getNewTableRefId()
    {
        return NumberSeq::newGetNum(formletterParmData::numRefParmId()).num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>numRefParmId</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the <c>NumberSequenceReference</c> object for the parameter ID.
    /// </summary>
    /// <returns>
    ///   An instance of the <c>NumberSequenceReference</c> object.
    /// </returns>
    static NumberSequenceReference numRefParmId()
    {
        return CompanyInfo::numRefParmId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptChooseLinesOnClient</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays the <c>chooseLines</c> prompt on the client.
    /// </summary>
    /// <param name="_packedChooseLines">
    /// A packed query.
    /// </param>
    /// <param name="_loadLastUsedQuery">
    /// A Boolean value that indicates whether the query that was used last should be loaded.
    /// </param>
    /// <returns>
    /// A Container that containszz the result from the prompt.
    /// </returns>
    protected static container  promptChooseLinesOnClient(container _packedChooseLines, boolean _loadLastUsedQuery)
    {
        SysQueryRun  chooseLines;
        boolean      result;

        chooseLines = new SysQueryRun(_packedChooseLines);
        chooseLines.promptLoadLastUsedQuery(_loadLastUsedQuery);
        result = chooseLines.prompt();

        return [result, chooseLines.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParmTableReArrangeSplit</Name>
				<Source><![CDATA[
    protected void updateParmTableReArrangeSplit()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateShippingStatReArrangeSplit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates sales shipping specification records that are not merged.
    /// </summary>
    protected void updateShippingStatReArrangeSplit()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal FormLetterInstrumentationLogger instrumentationLogger()
    {
        if (!customInstrumentationLogger)
        {
            customInstrumentationLogger = FormLetterCustomInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return customInstrumentationLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openSelectPurchVendOrder</Name>
				<Source><![CDATA[
    private boolean openSelectPurchVendOrder(SysQueryRun _chooseLines)
    {
        PurchTable purchTable;
        container purchCon, vendCon;
        str purchId;

        if (_chooseLines) //looping purchase order record to get purchId to filter form VendInvoiceApprovalSelectPurchOrder
        {
            while (_chooseLines.next())
            {
                if (_chooseLines.changed(tableNum(PurchTable)))
                {
                    purchTable = _chooseLines.get(tableNum(PurchTable));
                    purchCon += str2con(purchTable.PurchId, ',', false); 
                    vendCon += str2con(purchTable.OrderAccount, ',', false);
                }
            }
        }
        if (conLen(purchCon) > 0)
        {
            purchId = SysQuery::valueLike(con2StrUnlimited(purchCon));
        }
        
        // open form
        Args args = new Args();
        args.name(formstr(VendInvoiceApprovalSelectPurchOrder));
        args.parm(purchId);
        FormRun formRun = classfactory.formRunClass(args);
        formRun.init();
        FormDataSource formDataSource = new FormDataSource();
        formDataSource = formRun.dataSource();
        formRun.run();
        formDataSource.filter(fieldNum(PurchTable, PurchId), SysQuery::valueLike(con2StrUnlimited(purchCon)));
        formDataSource.filter(fieldNum(PurchTable, OrderAccount), SysQuery::valueLike(con2StrUnlimited(vendCon)));
        
        // Count the no. of records in the form
        if (formDataSource.numberOfRowsLoaded() > 1)
        {
            formRun.wait();
            if (formRun.closedCancel())
            {
                return false;
            }

            if (_chooseLines)
            {
                //passing range and create pending vendor invoice
                Query sourceQuery = _chooseLines.query();
                QueryBuildRange purchRange = sourceQuery.dataSourceTable(tableNum(PurchTable)).findRange(fieldNum(PurchTable, PurchId));
                purchRange.value(formRun.getStrValue());
                purchRange.status(RangeStatus::Locked);
            }
        }
        else
        {
            formRun.close();
            return true;
        }
        return formRun.ClosedOk();
    }

]]></Source>
			</Method>
			<Method>
				<Name>expectParmLinesCreated</Name>
				<Source><![CDATA[
    protected boolean expectParmLinesCreated()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>